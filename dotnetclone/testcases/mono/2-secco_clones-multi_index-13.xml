<clones hamthreshold="13" nfragments="1523" ngroups="369">
<clone_group groupid="0" nfragments="2">
<clone_fragment endline="136" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" hamdist="0" pcid="1341" startline="130"><![CDATA[
 		}
 
 		private void ComputeFlags()
 		{
 			module.MethodSemantics.ComputeFlags(module, this.MetadataToken, out isPublic, out isStatic);
 			flagsCached = true;
 		}
]]></clone_fragment>
<clone_fragment endline="154" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" hamdist="0" pcid="5571" startline="148"><![CDATA[
 		}
 
 		private void ComputeFlags()
 		{
 			module.MethodSemantics.ComputeFlags(module, this.MetadataToken, out isPublic, out isStatic);
 			flagsCached = true;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="1" nfragments="3">
<clone_fragment endline="4279" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="0" pcid="3483" startline="4273"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Unchecked target = (Unchecked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]></clone_fragment>
<clone_fragment endline="4309" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="8" pcid="3487" startline="4303"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]></clone_fragment>
<clone_fragment endline="4341" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="10" pcid="3493" startline="4335"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Unsafe target = (Unsafe) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="2" nfragments="16">
<clone_fragment endline="122" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="0" pcid="9587" startline="116"><![CDATA[
 
     Shared Function CreateInt32Token(ByVal Location As Span, ByVal Value As Integer) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int32Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="80" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="6" pcid="9575" startline="74"><![CDATA[
 
     Shared Function CreateDateToken(ByVal Location As Span, ByVal Value As Date) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DateLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="94" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="10" pcid="9579" startline="88"><![CDATA[
 
     Shared Function CreateDecimalToken(ByVal Location As Span, ByVal Value As Decimal) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DecimalLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="157" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="4" pcid="9597" startline="151"><![CDATA[
 
     Shared Function CreateStringLiteral(ByVal Location As Span, ByVal Value As String) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.StringLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="101" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="5" pcid="9581" startline="95"><![CDATA[
 
     Shared Function CreateSingleToken(ByVal Location As Span, ByVal Value As Single) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.SingleLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="136" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="6" pcid="9591" startline="130"><![CDATA[
 
     Shared Function CreateUInt16Token(ByVal Location As Span, ByVal Value As UShort) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt16Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="150" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="8" pcid="9595" startline="144"><![CDATA[
 
     Shared Function CreateUInt64Token(ByVal Location As Span, ByVal Value As ULong) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt64Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="108" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="4" pcid="9583" startline="102"><![CDATA[
 
     Shared Function CreateDoubleToken(ByVal Location As Span, ByVal Value As Double) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.DoubleLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="115" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="4" pcid="9585" startline="109"><![CDATA[
 
     Shared Function CreateInt16Token(ByVal Location As Span, ByVal Value As Short) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int16Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="129" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="8" pcid="9589" startline="123"><![CDATA[
 
     Shared Function CreateInt64Token(ByVal Location As Span, ByVal Value As Long) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Int64Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="87" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="7" pcid="9577" startline="81"><![CDATA[
 
     Shared Function CreateCharToken(ByVal Location As Span, ByVal Value As Char) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.CharLiteral
         result.m_TokenObject = Value
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="143" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="9" pcid="9593" startline="137"><![CDATA[
 
     Shared Function CreateUInt32Token(ByVal Location As Span, ByVal Value As UInteger) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.UInt32Literal
         result.m_TokenObject = Value
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="73" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="8" pcid="9573" startline="67"><![CDATA[
 
     Shared Function CreateKeywordToken(ByVal Location As Span, ByVal Keyword As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Keyword
         result.m_TokenObject = Keyword
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="75" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" hamdist="9" pcid="6521" startline="67"><![CDATA[
 
     Function ReplaceAndVerifyArguments(ByVal NewArguments As ArgumentList, ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim result As Boolean = True
 
         ReplaceArguments(NewArguments)
         result = VerifyArguments(Method) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="84" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" hamdist="4" pcid="6523" startline="76"><![CDATA[
 
     Function ReplaceAndVerifyArguments(ByVal NewArguments As ArgumentList, ByVal Method As Mono.Cecil.PropertyReference) As Boolean
         Dim result As Boolean = True
 
         ReplaceArguments(NewArguments)
         result = VerifyArguments(Method) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="69" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" hamdist="9" pcid="8391" startline="62"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Expressions) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="3" nfragments="2">
<clone_fragment endline="570" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" hamdist="0" pcid="245" startline="564"><![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (break_origins);
 			return vector;
 		}
]]></clone_fragment>
<clone_fragment endline="594" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" hamdist="7" pcid="251" startline="588"><![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (continue_origins);
 			return vector;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="4" nfragments="20">
<clone_fragment endline="1041" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="0" pcid="3345" startline="1035"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			GotoCase target = (GotoCase) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="88" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" hamdist="8" pcid="5671" startline="82"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Yield target = (Yield) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="627" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="9" pcid="3319" startline="621"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			StatementExpression target = (StatementExpression) t;
 
 			target.expr = (ExpressionStatement) expr.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="1220" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="6" pcid="4743" startline="1214"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			UnaryMutator target = (UnaryMutator) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="336" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="13" pcid="3299" startline="329"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Do target = (Do) t;
 
 			target.EmbeddedStatement = EmbeddedStatement.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="1091" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="11" pcid="3353" startline="1084"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Throw target = (Throw) t;
 
 			if (expr != null)
 				target.expr = expr.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="5763" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="10" pcid="3539" startline="5755"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Foreach target = (Foreach) t;
 
 			target.type = type.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 			target.statement = statement.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="1613" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="11" pcid="4773" startline="1606"><![CDATA[
 		
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Cast target = (Cast) t;
 
 			target.target_type = target_type.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="808" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="5" pcid="1317" startline="801"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Return target = (Return) t;
 			// It's null for simple return;
 			if (Expr != null)
 				target.Expr = Expr.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="2046" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="8" pcid="1191" startline="2038"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			if (expr == null)
 				return;
 
 			ShimExpression target = (ShimExpression) t;
 			target.expr = expr.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="255" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="15" pcid="3291" startline="246"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			If target = (If) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.TrueStatement = TrueStatement.Clone (clonectx);
 			if (FalseStatement != null)
 				target.FalseStatement = FalseStatement.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="4526" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="11" pcid="4827" startline="4518"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Conditional target = (Conditional) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.true_expr = true_expr.Clone (clonectx);
 			target.false_expr = false_expr.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="5106" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="10" pcid="1633" startline="5095"><![CDATA[
 		}
 		#endregion
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Invocation target = (Invocation) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 
 			target.expr = expr.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="7914" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="11" pcid="1629" startline="7908"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			MemberAccess target = (MemberAccess) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="9309" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="11" pcid="5111" startline="9303"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CollectionElementInitializer target = (CollectionElementInitializer) t;
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="7976" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="10" pcid="4987" startline="7970"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CheckedExpr target = (CheckedExpr) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="1206" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" hamdist="11" pcid="3807" startline="1199"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			NullCoalescingOperator target = (NullCoalescingOperator) t;
 
 			target.left = left.Clone (clonectx);
 			target.right = right.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="3869" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="3" pcid="3769" startline="3862"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Binary target = (Binary) t;
 
 			target.left = left.Clone (clonectx);
 			target.right = right.Clone (clonectx);
 		}
]]></clone_fragment>
<clone_fragment endline="4810" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="12" pcid="3515" startline="4802"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			TryFinally target = (TryFinally) t;
 
 			target.stmt = (Statement) stmt.Clone (clonectx);
 			if (fini != null)
 				target.fini = clonectx.LookupBlock (fini);
 		}
]]></clone_fragment>
<clone_fragment endline="5882" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="12" pcid="4865" startline="5873"><![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			New target = (New) t;
 
 			target.RequestedType = RequestedType.Clone (clonectx);
 			if (arguments != null){
 				target.arguments = arguments.Clone (clonectx);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="5" nfragments="3">
<clone_fragment endline="459" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" hamdist="0" pcid="6749" startline="453"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal ParamArray Methods As Mono.Cecil.MemberReference())
         Me.New(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(New Generic.List(Of Mono.Cecil.MemberReference)(Methods))
         Helper.Assert(Methods.Length > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]></clone_fragment>
<clone_fragment endline="466" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" hamdist="8" pcid="6751" startline="460"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal Methods As Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference))
         Me.new(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(Methods)
         Helper.Assert(Methods.Count > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]></clone_fragment>
<clone_fragment endline="473" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" hamdist="4" pcid="6753" startline="467"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal Methods As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         Me.new(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(Methods)
         Helper.Assert(Methods.Count > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="6" nfragments="6">
<clone_fragment endline="236" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" hamdist="0" pcid="6817" startline="230"><![CDATA[
 
     Sub New(ByVal Classification As MethodPointerClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></clone_fragment>
<clone_fragment endline="243" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" hamdist="3" pcid="6819" startline="237"><![CDATA[
 
     Sub New(ByVal Classification As LateBoundAccessClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></clone_fragment>
<clone_fragment endline="222" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" hamdist="4" pcid="6813" startline="216"><![CDATA[
 
     Sub New(ByVal Classification As PropertyGroupClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></clone_fragment>
<clone_fragment endline="215" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" hamdist="3" pcid="6811" startline="209"><![CDATA[
 
     Sub New(ByVal Classification As VariableClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></clone_fragment>
<clone_fragment endline="229" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" hamdist="6" pcid="6815" startline="223"><![CDATA[
 
     Sub New(ByVal Classification As MethodGroupClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></clone_fragment>
<clone_fragment endline="250" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ValueClassification.vb" hamdist="2" pcid="6821" startline="244"><![CDATA[
 
     Sub New(ByVal Classification As PropertyAccessClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="7" nfragments="3">
<clone_fragment endline="82" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" hamdist="0" pcid="9451" startline="76"><![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal ArrayNameModifier As ArrayNameModifier, ByVal TypeName As TypeName, ByVal Expression As Expression)
         m_Identifier = Identifier
         m_ArrayNameModifier = ArrayNameModifier
         m_TypeName = TypeName
         m_Expression = Expression
     End Sub
]]></clone_fragment>
<clone_fragment endline="62" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" hamdist="7" pcid="8393" startline="55"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Identifier As Identifier, ByVal TypeName As TypeName, ByVal ConstantExpression As Expression)
         MyBase.Init(Modifiers, Identifier.Name)
         m_Identifier = Identifier
         m_TypeName = TypeName
         m_ConstantExpression = ConstantExpression
         UpdateDefinition()
     End Sub
]]></clone_fragment>
<clone_fragment endline="58" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" hamdist="10" pcid="8479" startline="49"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Identifier As Identifier, ByVal ImplementsClause As MemberImplementsClause)
         MyBase.Init(Modifiers, Identifier.Name)
 
         m_Identifier = Identifier
         m_ImplementsClause = ImplementsClause
 
         Helper.Assert(m_Identifier IsNot Nothing)
         UpdateDefinition()
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="8" nfragments="2">
<clone_fragment endline="1481" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="0" pcid="2299" startline="1475"><![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			base.Emit (ec);
 			
 			ec.Emit (OpCodes.Box, child.Type);
 		}
]]></clone_fragment>
<clone_fragment endline="1211" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="9" pcid="2253" startline="1205"><![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			child.Emit (ec);
 
 			ec.Emit (OpCodes.Call, operators [type]);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="9" nfragments="2">
<clone_fragment endline="769" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" hamdist="0" pcid="277" startline="763"><![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddContinueOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="762" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" hamdist="8" pcid="275" startline="756"><![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddBreakOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="10" nfragments="2">
<clone_fragment endline="297" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" hamdist="0" pcid="6357" startline="291"><![CDATA[
 
     Public Function CreateAndEmitNop() As Mono.Cecil.Cil.Instruction
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         CilWorker.Append(result)
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="290" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" hamdist="9" pcid="6355" startline="284"><![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="11" nfragments="2">
<clone_fragment endline="798" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" hamdist="0" pcid="5939" startline="792"><![CDATA[
 
 		public void EmitWriteLine(string text)
 		{
 			Universe u = moduleBuilder.universe;
 			Emit(OpCodes.Ldstr, text);
 			Emit(OpCodes.Call, u.Import(typeof(Console)).GetMethod("WriteLine", new Type[] { u.System_String }));
 		}
]]></clone_fragment>
<clone_fragment endline="822" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" hamdist="7" pcid="5943" startline="815"><![CDATA[
 
 		public void EmitWriteLine(LocalBuilder local)
 		{
 			Universe u = moduleBuilder.universe;
 			Emit(OpCodes.Call, u.Import(typeof(Console)).GetMethod("get_Out"));
 			Emit(OpCodes.Ldloc, local);
 			Emit(OpCodes.Callvirt, u.Import(typeof(System.IO.TextWriter)).GetMethod("WriteLine", new Type[] { local.LocalType }));
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="12" nfragments="2">
<clone_fragment endline="133" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" hamdist="0" pcid="2939" startline="127"><![CDATA[
 
 		internal void WriteParamRecord(MetadataWriter mw)
 		{
 			mw.Write(flags);
 			mw.Write(sequence);
 			mw.WriteStringIndex(nameIndex);
 		}
]]></clone_fragment>
<clone_fragment endline="156" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" hamdist="9" pcid="6229" startline="150"><![CDATA[
 
 		internal void WriteFieldRecords(MetadataWriter mw)
 		{
 			mw.Write((short)attribs);
 			mw.WriteStringIndex(nameIndex);
 			mw.WriteBlobIndex(signature);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="13" nfragments="15">
<clone_fragment endline="961" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="0" pcid="3075" startline="955"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="1265" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="4" pcid="3089" startline="1259"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="1521" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="4" pcid="3099" startline="1515"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.float_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="1142" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="6" pcid="3085" startline="1136"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="1772" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="4" pcid="3111" startline="1766"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.decimal_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="1898" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="4" pcid="3117" startline="1892"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.string_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="1644" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="9" pcid="3103" startline="1638"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.double_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="625" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="6" pcid="3819" startline="619"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.sbyte_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="849" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="4" pcid="3827" startline="843"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.ushort_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="8762" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="6" pcid="5059" startline="8756"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Value;
 			type = TypeManager.object_type;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="501" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="9" pcid="3067" startline="495"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.char_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="346" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="9" pcid="3063" startline="340"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = TypeManager.bool_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="1404" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="10" pcid="3095" startline="1398"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="731" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="4" pcid="3823" startline="725"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.short_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="418" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="8" pcid="3815" startline="412"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = TypeManager.byte_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="14" nfragments="2">
<clone_fragment endline="316" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" hamdist="0" pcid="5895" startline="310"><![CDATA[
 
 		public void BeginFaultBlock()
 		{
 			ExceptionBlock block = BeginFinallyFilterFaultBlock();
 			block.handlerOffset = code.Position;
 			block.exceptionType = FAULT;
 		}
]]></clone_fragment>
<clone_fragment endline="309" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" hamdist="6" pcid="5893" startline="303"><![CDATA[
 
 		public void BeginExceptFilterBlock()
 		{
 			ExceptionBlock block = BeginFinallyFilterFaultBlock();
 			block.filterOffset = code.Position;
 			UpdateStack(1);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="15" nfragments="15">
<clone_fragment endline="91" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" hamdist="0" pcid="7149" startline="85"><![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent IsNot Nothing Then NewParent = Me.Parent
         Dim result As New LiteralExpression(NewParent)
         result.Init(m_Value)
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" hamdist="8" pcid="8387" startline="37"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As BoundList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New BoundList(NewParent)
         result.Init(Helper.CloneExpressionArray(m_Expressions, result))
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="38" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BooleanLiteralExpression.vb" hamdist="8" pcid="6689" startline="32"><![CDATA[
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent IsNot Nothing Then NewParent = Me.Parent
         Dim result As New BooleanLiteralExpression(NewParent)
         result.Init(m_Value)
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="45" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" hamdist="6" pcid="8357" startline="39"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributeArgumentExpression
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributeArgumentExpression(NewParent)
         result.Init(m_Expression.Clone(result))
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="112" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" hamdist="8" pcid="8809" startline="106"><![CDATA[
 
     Overridable Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SubSignature
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New SubSignature(NewParent)
         CloneTo(result)
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="67" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" hamdist="8" pcid="9815" startline="61"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ConstructedTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ConstructedTypeName(NewParent)
         result.Init(m_QualifiedIdentifier.Clone(result), m_TypeArgumentList.Clone(result))
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="60" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" hamdist="9" pcid="9989" startline="54"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeParameterConstraints
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeParameterConstraints(NewParent)
         result.Init(m_ConstraintList.clone(result))
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="53" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializerList.vb" hamdist="6" pcid="8871" startline="45"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As VariablePropertyInitializerList
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New VariablePropertyInitializerList(NewParent)
         For Each item As VariablePropertyInitializer In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="52" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributePositionalArgumentList.vb" hamdist="6" pcid="8373" startline="44"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As AttributePositionalArgumentList
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New AttributePositionalArgumentList(NewParent)
         For Each item As AttributeArgumentExpression In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="62" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" hamdist="11" pcid="9799" startline="54"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayTypeName(NewParent)
 
         result.Init(m_TypeName.Clone(result), m_ArrayTypeModifiers.Clone(result))
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="55" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParameterList.vb" hamdist="10" pcid="8723" startline="47"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ParameterList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterList(NewParent)
         For i As Integer = 0 To Me.Count - 1
             result.Add(Me.Item(i).Clone(result))
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="38" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attributes.vb" hamdist="10" pcid="8377" startline="30"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Attributes
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New Attributes(NewParent)
         For Each item As Attribute In Me
             result.Add(item.Clone(NewParent))
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="38" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstraintList.vb" hamdist="7" pcid="9811" startline="30"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ConstraintList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ConstraintList(NewParent)
         For Each item As Constraint In Me
             result.Add(item.Clone(result))
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="50" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" hamdist="9" pcid="8333" startline="40"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayTypeModifiers
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayTypeModifiers(NewParent)
         Dim mods(m_ArrayTypeModifiers.GetUpperBound(0)) As ArrayTypeModifier
         For i As Integer = 0 To mods.GetUpperBound(0)
             mods(i) = m_ArrayTypeModifiers(i).Clone(result)
         Next
         result.Init(mods)
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="55" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterList.vb" hamdist="9" pcid="9995" startline="47"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeParameterList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeParameterList(NewParent)
         For Each item As TypeParameter In Me
             result.Add(item.clone(result))
         Next
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="16" nfragments="2">
<clone_fragment endline="78" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" hamdist="0" pcid="7839" startline="72"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal InnerException As Exception)
         MyBase.New("", InnerException)
         m_Message = "There has been an internal error in the compiler
 StopOnInternalException()
     End Sub
]]></clone_fragment>
<clone_fragment endline="95" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" hamdist="6" pcid="7843" startline="89"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal strMsg As String)
         MyBase.new()
         m_Message = "There has been an internal error in the compiler
         StopOnInternalException()
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="17" nfragments="2">
<clone_fragment endline="387" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" hamdist="0" pcid="655" startline="381"><![CDATA[
 
 		public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			return DefinePropertyImpl(name, attributes, CallingConventions.Standard, true, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers,
 				parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 		}
]]></clone_fragment>
<clone_fragment endline="395" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" hamdist="3" pcid="657" startline="388"><![CDATA[
 
 		public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention,
 			Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			return DefinePropertyImpl(name, attributes, callingConvention, false, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers,
 				parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="18" nfragments="2">
<clone_fragment endline="161" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" hamdist="0" pcid="723" startline="155"><![CDATA[
 
 		public static void DefineCapturedLocal (int scope_id, string name,
 							string captured_name)
 		{
 			if (symwriter != null)
 				symwriter.DefineCapturedLocal (scope_id, name, captured_name);
 		}
]]></clone_fragment>
<clone_fragment endline="168" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" hamdist="8" pcid="725" startline="162"><![CDATA[
 
 		public static void DefineCapturedParameter (int scope_id, string name,
 							    string captured_name)
 		{
 			if (symwriter != null)
 				symwriter.DefineCapturedParameter (scope_id, name, captured_name);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="19" nfragments="2">
<clone_fragment endline="509" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" hamdist="0" pcid="8283" startline="503"><![CDATA[
 
     Function IsUnsignedIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(Type, Compiler.TypeCache.System_Byte) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt64)
     End Function
]]></clone_fragment>
<clone_fragment endline="502" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" hamdist="6" pcid="8281" startline="496"><![CDATA[
 
     Function IsSignedIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(Type, Compiler.TypeCache.System_SByte) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int16) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int32) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int64)
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="20" nfragments="193">
<clone_fragment endline="38" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariablePropertyInitializer.vb" hamdist="0" pcid="8863" startline="32"><![CDATA[
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_AttributeArgumentExpression.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="154" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" hamdist="4" pcid="8589" startline="147"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="42" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" hamdist="9" pcid="6969" startline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="149" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" hamdist="17" pcid="9703" startline="141"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         'vbnc.Helper.Assert(result = (Compiler.Report.Errors = 0))
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="57" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetTypeExpression.vb" hamdist="13" pcid="7077" startline="49"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveCode(info) AndAlso result
         Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" hamdist="8" pcid="6871" startline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="77" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" hamdist="0" pcid="6881" startline="68"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="80" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" hamdist="0" pcid="6889" startline="71"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" hamdist="0" pcid="6895" startline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" hamdist="0" pcid="6903" startline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" hamdist="0" pcid="6911" startline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" hamdist="0" pcid="6919" startline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" hamdist="0" pcid="6945" startline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" hamdist="0" pcid="6953" startline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" hamdist="0" pcid="6961" startline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" hamdist="0" pcid="6991" startline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" hamdist="0" pcid="6999" startline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" hamdist="0" pcid="7007" startline="34"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="124" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" hamdist="8" pcid="8425" startline="115"><![CDATA[
 
     Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="51" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" hamdist="3" pcid="6501" startline="45"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Classification.AsMethodPointerClassification.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="419" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" hamdist="6" pcid="9429" startline="412"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = GenerateCodeInternal(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" hamdist="6" pcid="9545" startline="36"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_WithExpression) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="103" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ArrayTypeName.vb" hamdist="5" pcid="9803" startline="96"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="288" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" hamdist="3" pcid="8413" startline="281"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="74" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" hamdist="0" pcid="8451" startline="67"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="61" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" hamdist="0" pcid="8459" startline="54"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="195" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" hamdist="0" pcid="8493" startline="188"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="84" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" hamdist="0" pcid="8607" startline="77"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="128" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" hamdist="0" pcid="8825" startline="121"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="53" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" hamdist="5" pcid="8359" startline="46"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="66" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" hamdist="6" pcid="8603" startline="59"><![CDATA[
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="50" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" hamdist="5" pcid="7181" startline="43"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info) AndAlso result 'Helper.NotImplemented()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="75" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" hamdist="5" pcid="7205" startline="68"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Classification.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="416" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" hamdist="2" pcid="9791" startline="409"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="38" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" hamdist="6" pcid="6927" startline="30"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
         result = Validate(Info, Expression) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="88" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" hamdist="9" pcid="8787" startline="80"><![CDATA[
     End Property
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="184" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" hamdist="8" pcid="8473" startline="176"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         If m_ConstantExpression IsNot Nothing Then result = m_ConstantExpression.ResolveExpression(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="98" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" hamdist="8" pcid="9513" startline="90"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Lock.ResolveExpression(INfo) AndAlso result
         result = CodeBlock.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="67" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\NewExpression.vb" hamdist="9" pcid="7183" startline="59"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(info) AndAlso result
         Classification = m_Expression.Classification
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="72" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableInitializer.vb" hamdist="8" pcid="8859" startline="64"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Initializer.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="60" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" hamdist="8" pcid="8731" startline="52"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_ParameterList IsNot Nothing Then result = m_ParameterList.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="63" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="8" pcid="8887" startline="54"><![CDATA[
 
     Public Function Parse(ByVal RootNamespace As String, ByVal assembly As AssemblyDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = ParseAssemblyDeclaration(RootNamespace, assembly) AndAlso result
 
         result = Compiler.Report.Errors = 0 AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="66" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LoadFieldExpression.vb" hamdist="12" pcid="7155" startline="55"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_InstanceExpression IsNot Nothing Then
             result = m_InstanceExpression.GenerateCode(Info) AndAlso result
         End If
 
         Emitter.EmitLoadVariable(Info, m_Field)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="182" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" hamdist="10" pcid="9717" startline="171"><![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         BaseType = Compiler.TypeCache.System_MulticastDelegate
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         result = m_Signature.ResolveTypeReferences(False) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="323" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" hamdist="12" pcid="7053" startline="311"><![CDATA[
 
     Function ResolveAddressOfExpression(ByVal DelegateType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
         Dim aoe As AddressOfExpression = TryCast(Me, AddressOfExpression)
 
         If aoe Is Nothing Then
             result = False
         Else
             result = aoe.Resolve(DelegateType) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="54" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesClause.vb" hamdist="12" pcid="8543" startline="47"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_List.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="61" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" hamdist="3" pcid="8361" startline="54"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="132" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventMemberSpecifier.vb" hamdist="0" pcid="8511" startline="125"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="85" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\AddressOfExpression.vb" hamdist="8" pcid="6503" startline="77"><![CDATA[
 
     Function Resolve(ByVal DelegateType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
 
         result = Classification.AsMethodPointerClassification.Resolve(DelegateType) AndAlso result
         m_ExpressionType = DelegateType
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="60" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" hamdist="10" pcid="9737" startline="53"><![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="218" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" hamdist="6" pcid="9819" startline="211"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = VerifyConstraints() AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="332" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" hamdist="4" pcid="6545" startline="325"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Arguments.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="56" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\GotoStatement.vb" hamdist="10" pcid="9435" startline="48"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         m_Destination = Me.FindFirstParent(Of CodeBlock).FindLabel(m_GotoWhere)
         result = m_Destination IsNot Nothing AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="45" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" hamdist="10" pcid="9509" startline="36"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Lock) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="47" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" hamdist="2" pcid="9539" startline="38"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Condition) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" hamdist="7" pcid="7241" startline="36"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
         result = m_Type.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="78" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" hamdist="2" pcid="9991" startline="71"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_ConstraintList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="125" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" hamdist="11" pcid="9483" startline="117"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_AssignStatement.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="540" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" hamdist="6" pcid="9711" startline="532"><![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         'Define type parameters
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="65" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReDimStatement.vb" hamdist="5" pcid="9487" startline="57"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Helper.GenerateCodeCollection(m_Clauses, Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="236" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" hamdist="8" pcid="7101" startline="228"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="67" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" hamdist="6" pcid="8517" startline="58"><![CDATA[
     End Property
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="67" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" hamdist="0" pcid="8529" startline="58"><![CDATA[
     End Property
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="58" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" hamdist="7" pcid="6583" startline="49"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_LeftExpression.ResolveTypeReferences AndAlso result
         result = m_RightExpression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="117" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" hamdist="11" pcid="8559" startline="108"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_1.ResolveTypeReferences AndAlso result
 
         m_ResolvedType = m_1.ResolvedType
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="127" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" hamdist="10" pcid="8561" startline="118"><![CDATA[
 
 
     Public Function ResolveEarly() As Boolean
         Dim result As Boolean = True
 
         result = ResolveTypeReferences() AndAlso result
         result = ResolveCode(ResolveInfo.Default(Compiler)) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="139" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" hamdist="8" pcid="8795" startline="130"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then result = m_HandlesOrImplements.ResolveCode(Info) AndAlso result
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="88" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WhileStatement.vb" hamdist="4" pcid="9543" startline="79"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveExpression(Info) AndAlso result
         result = Helper.VerifyValueClassification(m_Condition, Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="118" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" hamdist="4" pcid="9537" startline="108"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
 
         result = m_UsingResources.ResolveCode(Info) AndAlso result
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="100" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" hamdist="5" pcid="6865" startline="89"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         If result = False Then Return result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="87" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" hamdist="4" pcid="7195" startline="73"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         result = Helper.VerifyValueClassification(m_Expression, Info) AndAlso result
 
         Classification = New ValueClassification(Me, Me.ExpressionType)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="71" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EraseStatement.vb" hamdist="8" pcid="9391" startline="64"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Targets.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="33" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" hamdist="14" pcid="7141" startline="26"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="59" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" hamdist="16" pcid="9745" startline="51"><![CDATA[
 
     Public Overrides Function DefineType() As Boolean
         Dim result As Boolean = True
 
         result = AddAttribute() AndAlso result
         result = MyBase.DefineType() AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="62" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" hamdist="4" pcid="9725" startline="53"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences() AndAlso result
         UpdateDefinition()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="57" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" hamdist="10" pcid="6565" startline="47"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For Each exp As Expression In m_Initializers
             result = exp.ResolveExpression(Info) AndAlso result
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="176" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" hamdist="11" pcid="8831" startline="166"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="108" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="12" pcid="9627" startline="97"><![CDATA[
 
     Private Function DefineType(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.DefineType AndAlso result
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = DefineType(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="61" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" hamdist="12" pcid="8735" startline="54"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="146" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberDeclaration.vb" hamdist="4" pcid="8587" startline="138"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="94" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" hamdist="11" pcid="8609" startline="85"><![CDATA[
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         Helper.Assert(Me.DeclaringType IsNot Nothing)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="92" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" hamdist="9" pcid="9729" startline="83"><![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="241" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" hamdist="10" pcid="6333" startline="234"><![CDATA[
 
     Function Clone(ByVal Context As ParsedObject, ByVal DesiredType As Mono.Cecil.TypeReference) As EmitInfo
         Dim result As New EmitInfo(Me)
         result.m_DesiredType = DesiredType
         result.m_RHSExpression = Nothing
         result.m_Context = Context
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="53" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\OnErrorStatement.vb" hamdist="8" pcid="9465" startline="46"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedLabel IsNot Nothing Then result = m_ResolvedLabel.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="51" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" hamdist="11" pcid="9533" startline="42"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         ' result = Helper.ResolveTypeReferences(m_UsingResources) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="61" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" hamdist="6" pcid="9371" startline="52"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_PreCondition, m_PostCondition) AndAlso result
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="130" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" hamdist="6" pcid="8469" startline="121"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         result = Helper.ResolveTypeReferences(m_ConstantExpression) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="88" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" hamdist="9" pcid="9521" startline="79"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Catches.ResolveCode(Info) AndAlso result
         If m_FinallyBlock IsNot Nothing Then result = m_FinallyBlock.ResolveCode(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="64" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ThrowStatement.vb" hamdist="3" pcid="9517" startline="53"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Exception IsNot Nothing Then
             result = m_Exception.ResolveExpression(Info) AndAlso result
             If result = False Then Return result
             result = Helper.VerifyValueClassification(m_Exception, Info) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="47" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\GotoStatement.vb" hamdist="11" pcid="9433" startline="40"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitBranchOrLeave(Info, m_Destination.GetLabel(Info), Me, m_Destination)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="120" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="14" pcid="9629" startline="109"><![CDATA[
 
     Private Function DefineTypeHierarchy(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.DefineTypeHierarchy AndAlso result
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = DefineTypeHierarchy(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="41" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\EndStatement.vb" hamdist="17" pcid="9385" startline="34"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__EndApp)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="56" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ErrorStatement.vb" hamdist="14" pcid="9395" startline="47"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_ErrNumber.ResolveExpression(info) AndAlso result
 
         Compiler.Helper.AddCheck("The expression must be classified as a value and its type must be implicitly convertible to Integer.")
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="344" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" hamdist="10" pcid="7919" startline="337"><![CDATA[
 
     Public Overridable Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         result = DefineSecurityDeclarations() AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="101" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" hamdist="15" pcid="9327" startline="91"><![CDATA[
 
     Friend NotOverridable Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         'result = m_CompoundExpression.GenerateCode(Info.Clone(True, False, LSide.ExpressionType)) AndAlso result
 
         Dim lInfo As EmitInfo = Info.Clone(Me, m_CompoundExpression)
         result = LSide.Classification.GenerateCode(lInfo) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="59" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\GetRefExpression.vb" hamdist="15" pcid="7071" startline="52"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Classification = New ValueClassification(Me, m_ExpressionType)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="66" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" hamdist="18" pcid="8449" startline="57"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Operand.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="70" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" hamdist="4" pcid="9381" startline="61"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="155" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeParameter.vb" hamdist="7" pcid="9981" startline="145"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeParameterConstraints IsNot Nothing Then
             result = m_TypeParameterConstraints.ResolveTypeReferences AndAlso result
             result = DefineParameterConstraints() AndAlso result
         End If
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="106" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" hamdist="7" pcid="9357" startline="96"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Clauses IsNot Nothing Then
             result = m_Clauses.ResolveStatements(Info) AndAlso result
         End If
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="99" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" hamdist="7" pcid="9523" startline="89"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Catches IsNot Nothing Then result = m_Catches.ResolveTypeReferences() AndAlso result
         If m_FinallyBlock IsNot Nothing Then result = m_FinallyBlock.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="163" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" hamdist="9" pcid="8815" startline="152"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ParameterList IsNot Nothing)
 
         result = m_ParameterList.ResolveCode(info) AndAlso result
         If m_TypeParameters IsNot Nothing Then result = m_TypeParameters.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="192" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" hamdist="13" pcid="8431" startline="181"><![CDATA[
 
     Public Overrides Function DefineMember() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineMember AndAlso result
 
         'Helper.SetTypeOrTypeBuilder(Compiler, ParameterTypes)
 
         UpdateDefinition()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="38" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CTypeExpression.vb" hamdist="15" pcid="6977" startline="26"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_DestinationType IsNot Nothing Then
             result = m_DestinationType.ResolveTypeReferences AndAlso result
             m_ResolvedDestinationType = m_DestinationType.ResolvedType
             Helper.Assert(CecilHelper.IsByRef(m_ResolvedDestinationType) = False)
         End If
 
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="46" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" hamdist="9" pcid="7143" startline="34"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.LateBoundAccess.Name Is Nothing Then
             result = EmitLateIndexGet(Info) AndAlso result
         Else
             result = EmitLateGet(Info) AndAlso result
         End If
 
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="119" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" hamdist="6" pcid="8791" startline="107"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info Is Nothing Then
             Info = New EmitInfo(Me)
         End If
 
         result = DefineHandlesOrImplements() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="336" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" hamdist="4" pcid="7917" startline="323"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         result = ResolveOverrides() AndAlso result
         result = m_Signature.ResolveCode(Info) AndAlso result
 
         If m_Code IsNot Nothing Then
             result = m_Code.ResolveCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="141" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" hamdist="9" pcid="6935" startline="126"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression.IsResolved = False Then
             result = m_Expression.ResolveExpression(Info) AndAlso result
         End If
 
         If result = False Then Return result
 
         result = Helper.VerifyValueClassification(m_Expression, Info) AndAlso result
         Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="314" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" hamdist="11" pcid="7913" startline="299"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         result = m_Signature.ResolveTypeReferences AndAlso result
         If result = False Then Return result
 
         ReturnType = m_Signature.ReturnType
 
         If m_Code IsNot Nothing Then result = m_Code.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="129" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" hamdist="9" pcid="8793" startline="120"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then result = m_HandlesOrImplements.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="151" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" hamdist="12" pcid="8541" startline="141"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
         result = MyBase.ResolveCode(info) AndAlso result
 
         Helper.Assert(m_ReturnType IsNot Nothing OrElse Compiler.Report.Errors > 0)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="62" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" hamdist="9" pcid="9499" startline="53"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Test IsNot Nothing Then result = m_Test.ResolveTypeReferences AndAlso result
         If m_Cases IsNot Nothing Then result = m_Cases.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="90" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" hamdist="6" pcid="9325" startline="73"><![CDATA[
 
     Public NotOverridable Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveStatement(Info) AndAlso result
 
         If result = False Then Return result
 
         result = CheckIndexedStatement(Info, TryCast(LSide, InvocationOrIndexExpression)) AndAlso result
 
         m_CompoundExpression = ResolveStatement(LSide, RSide)
 
         result = m_CompoundExpression.ResolveExpression(Info) AndAlso result
 
         m_CompoundExpression = Helper.CreateTypeConversion(Me, m_CompoundExpression, LSide.ExpressionType, result)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="39" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" hamdist="9" pcid="9311" startline="32"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_LSide.ResolveTypeReferences AndAlso result
         result = m_RSide.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="108" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" hamdist="12" pcid="8611" startline="95"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         If Signature.Parameters IsNot Nothing Then
             For i As Integer = 0 To Signature.Parameters.Count - 1
                 result = Signature.Parameters(i).GenerateCode(Info) AndAlso result
             Next
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="114" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" hamdist="12" pcid="8823" startline="100"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         Helper.Assert(VariableType IsNot Nothing)
 
         UpdateDefinition()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="37" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" hamdist="6" pcid="8299" startline="31"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_VariableInitializerList IsNot Nothing Then result = m_VariableInitializerList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="234" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" hamdist="13" pcid="9951" startline="223"><![CDATA[
 
     Private Function ResolveQualifiedName(ByVal Qualifier As TypeNameResolutionInfo, ByVal R1 As String, ByVal R2 As String, ByVal TypeArgumentCount As Integer) As Boolean
         Dim result As Boolean = True
 
         result = ResolveQualifiedNameInternal(Qualifier, R1, R2 Is Nothing, TypeArgumentCount) AndAlso result
 
         If result = False AndAlso R2 IsNot Nothing Then
             result = ResolveQualifiedNameInternal(Qualifier, R2, True, TypeArgumentCount) 'AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="103" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SelectStatement.vb" hamdist="13" pcid="9503" startline="87"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Test.ResolveExpression(Info) AndAlso result
         If result = False Then Return False
 
         result = Helper.VerifyValueClassification(m_Test, Info) AndAlso result
         If result = False Then Return False
 
         m_CachedTest = New CachedExpression(m_Test, m_Test)
 
         result = m_Cases.ResolveCode(info) AndAlso result
 
         Compiler.Helper.AddCheck("Check that there is at most one else block, and only at the end.")
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="32" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" hamdist="14" pcid="9553" startline="25"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_TypeArguments IsNot Nothing Then result = m_TypeArguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="164" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" hamdist="11" pcid="8573" startline="145"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             If IsLocalVariable Then
                 If m_LocalBuilder Is Nothing Then result = DefineLocalVariable(Info) AndAlso result
                 Helper.Assert(m_LocalBuilder IsNot Nothing)
                 result = EmitVariableInitializer(Info) AndAlso result
             ElseIf Me.Modifiers.Is(ModifierMasks.Static) Then
                 result = DefineField() AndAlso result
                 result = EmitStaticInitializer(Info) AndAlso result
             End If
 
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="416" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="9" pcid="9661" startline="407"><![CDATA[
 
     Function EmitAttributes() As Boolean
         Dim result As Boolean = True
 
         If m_Attributes IsNot Nothing Then
             result = m_Attributes.GenerateCode(Nothing) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="177" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" hamdist="8" pcid="8489" startline="170"><![CDATA[
 
     Private Function CreateImplicitMembers() As Boolean Implements IHasImplicitMembers.CreateImplicitMembers
         Dim result As Boolean = True
 
         result = ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="48" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodDeclaration.vb" hamdist="12" pcid="8601" startline="40"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         UpdateDefinition()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="114" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" hamdist="0" pcid="8423" startline="105"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         UpdateDefinition()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="67" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" hamdist="12" pcid="8457" startline="54"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Type IsNot Nothing Then
             result = m_Type.ResolveTypeReferences AndAlso result
             EventType = m_Type.ResolvedType
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="135" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" hamdist="10" pcid="6589" startline="117"><![CDATA[
     End Property
 
     Protected Overridable Function ResolveExpressions(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LeftExpression.ResolveExpression(Info) AndAlso result
         result = m_RightExpression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return False
 
         If m_LeftExpression.Classification.IsValueClassification = False Then
             result = Helper.VerifyValueClassification(m_LeftExpression, Info) AndAlso result
         End If
 
         If m_RightExpression.Classification.IsValueClassification = False Then
             result = Helper.VerifyValueClassification(m_RightExpression, Info) AndAlso result
         End If
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="52" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" hamdist="9" pcid="9735" startline="41"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeParameters IsNot Nothing Then
             result = m_TypeParameters.ResolveTypeReferences AndAlso result
         End If
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="85" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" hamdist="14" pcid="9853" startline="76"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
         If m_TypeParameter IsNot Nothing Then result = m_TypeParameter.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="268" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" hamdist="11" pcid="8757" startline="258"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Get IsNot Nothing Then result = m_Get.GenerateCode(Info) AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.GenerateCode(Info) AndAlso result
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="173" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" hamdist="8" pcid="8747" startline="160"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_Signature IsNot Nothing Then result = m_Signature.ResolveTypeReferences AndAlso result
         If m_Get IsNot Nothing Then result = m_Get.ResolveTypeReferences AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveTypeReferences AndAlso result
 
         If m_MemberImplementsClause IsNot Nothing Then result = m_MemberImplementsClause.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="60" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" hamdist="14" pcid="9379" startline="45"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim falseLabel As Label = Emitter.DefineLabel(Info)
 
         result = m_Condition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
         Emitter.EmitBranchIfFalse(Info, falseLabel)
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, ParentAsIfStatement.EndLabel)
 
         Emitter.MarkLabel(Info, falseLabel)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="128" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" hamdist="14" pcid="9363" startline="113"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then
             result = m_TypeName.ResolveTypeReferences AndAlso result
         End If
 
         If m_When IsNot Nothing Then
             result = m_When.ResolveTypeReferences AndAlso result
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="263" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="12" pcid="9645" startline="244"><![CDATA[
 
     Private Overloads Function ResolveTypeReferences(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         For Each Member As ParsedObject In Type.Members
             Dim NestedType As TypeDeclaration = TryCast(Member, TypeDeclaration)
             If NestedType IsNot Nothing Then
                 result = ResolveTypeReferences(NestedType) AndAlso result
             Else
                 result = Member.ResolveTypeReferences() AndAlso result
             End If
             If result = False Then Return result
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="53" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToPropertyAccessExpression.vb" hamdist="11" pcid="7139" startline="34"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsLHS Then
             If LateBoundAccess.Name Is Nothing Then
                 result = EmitLateindexSet(Info) AndAlso result
             Else
                 result = EmitLateSet(Info) AndAlso result
             End If
         Else
             If LateBoundAccess.Name Is Nothing Then
                 result = EmitLateIndexGet(Info) AndAlso result
             Else
                 result = EmitLateGet(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="63" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" hamdist="7" pcid="9347" startline="54"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression1 IsNot Nothing Then result = m_Expression1.ResolveTypeReferences AndAlso result
         If m_Expression2 IsNot Nothing Then result = m_Expression2.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="119" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" hamdist="6" pcid="7223" startline="111"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="39" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventHandlesList.vb" hamdist="11" pcid="8505" startline="30"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For Each Item As EventMemberSpecifier In Me
             result = Item.ResolveTypeReferences AndAlso result
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="62" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" hamdist="6" pcid="9353" startline="52"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Clauses IsNot Nothing Then result = m_Clauses.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="408" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" hamdist="19" pcid="9789" startline="396"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Compiler.Report.Trace("{0}
 
         result = MyBase.ResolveCode(Info) AndAlso result
         Compiler.VerifyConsistency(result, Location)
         result = m_Members.ResolveCode(Info) AndAlso result
         'vbnc.Helper.Assert(result = (Compiler.Report.Errors = 0))
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="42" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" hamdist="14" pcid="9471" startline="35"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Event IsNot Nothing Then result = m_Event.ResolveTypeReferences AndAlso result
         If m_Arguments IsNot Nothing Then result = m_Arguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="125" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" hamdist="5" pcid="9411" startline="111"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_LoopControlVariable IsNot Nothing Then result = m_LoopControlVariable.ResolveTypeReferences AndAlso result
         If m_LoopStartExpression IsNot Nothing Then result = m_LoopStartExpression.ResolveTypeReferences AndAlso result
         If m_LoopEndExpression IsNot Nothing Then result = m_LoopEndExpression.ResolveTypeReferences AndAlso result
         If m_LoopStepExpression IsNot Nothing Then result = m_LoopStepExpression.ResolveTypeReferences AndAlso result
         If m_NextExpressionList IsNot Nothing Then result = m_NextExpressionList.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="169" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" hamdist="6" pcid="8487" startline="154"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ImplementsClause IsNot Nothing Then result = m_ImplementsClause.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_AddMethod IsNot Nothing Then result = m_AddMethod.ResolveTypeReferences AndAlso result
         If m_RemoveMethod IsNot Nothing Then result = m_RemoveMethod.ResolveTypeReferences AndAlso result
         If m_RaiseMethod IsNot Nothing Then result = m_RaiseMethod.ResolveTypeReferences AndAlso result
 
         Helper.Assert(EventType IsNot Nothing)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="218" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" hamdist="9" pcid="8751" startline="199"><![CDATA[
 
     Public Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         result = m_Signature.ResolveCode(Info) AndAlso result
 
         If m_Get IsNot Nothing Then result = m_Get.ResolveMember(ResolveInfo.Default(Info.Compiler)) AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveMember(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
         If Modifiers.Is(ModifierMasks.Default) Then
             Dim tp As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
             result = tp.SetDefaultAttribute(Me.Name) AndAlso result
         End If
 
         UpdateDefinition()
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="100" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" hamdist="10" pcid="8329" startline="92"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_BoundList IsNot Nothing Then result = m_BoundList.ResolveCode(Info) AndAlso result
         If m_ArrayTypeModifiers IsNot Nothing Then result = m_ArrayTypeModifiers.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="366" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" hamdist="11" pcid="7921" startline="345"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = DefineOverrides() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         If Me.IsPropertyHandlesHandler Then
             result = GeneratePropertyHandlers() AndAlso result
         ElseIf Me.HasMethodBody Then
             Helper.Assert(m_Code IsNot Nothing)
 
             'Create the default return variable
             If Me.HasReturnValue Then
                 m_DefaultReturnVariable = Emitter.DeclareLocal(Info, ReturnType)
             End If
 
             result = m_Code.GenerateCode(Me) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="187" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" hamdist="14" pcid="8491" startline="178"><![CDATA[
 
     Public Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         If m_ImplementsClause IsNot Nothing Then result = m_ImplementsClause.ResolveCode(Info) AndAlso result
 
         Helper.Assert(EventType IsNot Nothing)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="59" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" hamdist="11" pcid="6547" startline="49"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_NonArrayTypeName IsNot Nothing Then result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
         If m_ArrayElementInitializer IsNot Nothing Then result = m_ArrayElementInitializer.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="73" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParametersOrType.vb" hamdist="6" pcid="8733" startline="61"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ParameterList IsNot Nothing Then
             result = m_ParameterList.ResolveTypeReferences AndAlso result
         End If
         If m_NonArrayTypeName IsNot Nothing Then
             result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="499" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" hamdist="9" pcid="7115" startline="478"><![CDATA[
 
     Private Function ResolveReclassifyToValueThenIndex() As Boolean
         Dim result As Boolean = True
         Dim tmpExp As Expression
         Dim oldExp As Expression
 
         tmpExp = m_Expression.ReclassifyToValueExpression
         result = tmpExp.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) AndAlso result
 
         If result = False Then
             Helper.AddError(Me)
             Return False
         End If
 
         oldExp = m_Expression
         m_Expression = tmpExp
         result = ResolveIndexInvocation(Me, m_Expression.ExpressionType) AndAlso result
 
         Helper.StopIfDebugging(result = False)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="74" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" hamdist="12" pcid="9747" startline="64"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         MyBase.BaseType = Compiler.TypeCache.System_Object
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Me.FindDefaultConstructors()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="115" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" hamdist="13" pcid="9527" startline="102"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_IsVariableDeclaration Then
             result = m_VariableDeclaration.GenerateCode(Info.Clone(Me, True, False, UsingVariableType)) AndAlso result
             UsingVariable = m_VariableDeclaration.LocalBuilder
         Else
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="156" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="14" pcid="9633" startline="145"><![CDATA[
 
     Friend Function Emit(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.GenerateCode(Nothing) AndAlso result
         result = Type.Members.GenerateCode(Nothing) AndAlso result
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = Emit(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="59" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeArguments.vb" hamdist="15" pcid="8365" startline="51"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_AttributePositionalArgumentList IsNot Nothing Then result = m_AttributePositionalArgumentList.ResolveCode(info) AndAlso result
         If m_VariablePropertyInitializerList IsNot Nothing Then result = m_VariablePropertyInitializerList.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="44" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\AttributeList.vb" hamdist="18" pcid="8371" startline="36"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For Each attrib As Attribute In m_List
             result = attrib.ResolveCode(info) AndAlso result
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="99" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\WithStatement.vb" hamdist="17" pcid="9549" startline="80"><![CDATA[
     End Property
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_WithExpression.ResolveExpression(Info) AndAlso result
 
         If result Then
             If CecilHelper.IsValueType(m_WithExpression.ExpressionType) AndAlso m_WithExpression.Classification.IsVariableClassification Then
                 m_WithVariableExpression = m_WithExpression
             Else
                 m_WithVariableExpression = New CompilerGeneratedExpression(Me, New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateVariableCode), m_WithExpression.ExpressionType)
                 result = m_WithVariableExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="69" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MemberAccessExpression.vb" hamdist="12" pcid="7161" startline="58"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_First IsNot Nothing Then result = m_First.ResolveTypeReferences AndAlso result
         If m_Second IsNot Nothing Then result = m_Second.ResolveTypeReferences AndAlso result
 
         ' If m_TypeArguments IsNot Nothing Then result = m_TypeArguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="71" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" hamdist="6" pcid="9449" startline="59"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
         If m_Expression IsNot Nothing Then result = m_Expression.ResolveTypeReferences AndAlso result
 
         If m_Declaration IsNot Nothing Then result = m_Declaration.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="123" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" hamdist="13" pcid="9529" startline="116"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_TypeName, m_ArgumentList, m_VariableInitializer) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="76" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\AssignmentStatement.vb" hamdist="13" pcid="9315" startline="65"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim lInfo As EmitInfo = Info.Clone(Me, RSide)
 
         Helper.Assert(LSide.Classification.IsVariableClassification OrElse LSide.Classification.IsPropertyAccessClassification)
         result = LSide.Classification.GenerateCode(lInfo) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="71" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" hamdist="17" pcid="9739" startline="56"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_InterfaceBases IsNot Nothing Then
             result = m_InterfaceBases.ResolveTypeReferences AndAlso result
             For i As Integer = 0 To m_InterfaceBases.Bases.Length - 1
                 AddInterface(m_InterfaceBases.Bases(i).ResolvedType)
             Next
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="197" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" hamdist="18" pcid="9407" startline="186"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_LoopControlVariable IsNot Nothing Then result = m_LoopControlVariable.ResolveTypeReferences AndAlso result
         If m_InExpression IsNot Nothing Then result = m_InExpression.ResolveTypeReferences AndAlso result
         If m_NextExpression IsNot Nothing Then result = m_NextExpression.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="72" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyGroupToValueExpression.vb" hamdist="11" pcid="7209" startline="53"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_PropertyGroup.IsResolved = False OrElse m_PropertyGroup.ResolvedProperty Is Nothing Then
             result = m_PropertyGroup.ResolveGroup(New ArgumentList(Me)) AndAlso result
         End If
 
         If result = False Then
             Return False
         End If
 
         m_ExpressionType = m_PropertyGroup.ResolvedProperty.PropertyType
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="164" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="13" pcid="9599" startline="158"><![CDATA[
 
     Shared Function CreateSymbolToken(ByVal Location As Span, ByVal Symbol As KS) As Token
         Dim result As New Token(Location)
         result.m_TokenType = TokenType.Symbol
         result.m_TokenObject = Symbol
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="78" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\TryStatement.vb" hamdist="15" pcid="9519" startline="57"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.EmitBeginExceptionBlock(Info)
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         For i As Integer = 0 To m_Catches.Count - 1
             Dim catchstmt As CatchStatement = m_Catches(i)
             result = catchstmt.GenerateCode(Info) AndAlso result
         Next
 
         If m_FinallyBlock IsNot Nothing Then
             Info.ILGen.BeginFinallyBlock()
             result = m_FinallyBlock.GenerateCode(Info) AndAlso result
         End If
 
         Info.ILGen.EndExceptionBlock()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="157" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" hamdist="18" pcid="9443" startline="146"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If m_Condition IsNot Nothing Then result = m_Condition.ResolveTypeReferences AndAlso result
         If m_ElseIfs IsNot Nothing Then result = m_ElseIfs.ResolveTypeReferences AndAlso result
         If m_FalseCode IsNot Nothing Then result = m_FalseCode.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="243" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" hamdist="10" pcid="8849" startline="222"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             'If IsLocalVariable Then
             '    If m_LocalBuilder Is Nothing Then result = DefineLocalVariable(Info) AndAlso result
             '    Helper.Assert(m_LocalBuilder IsNot Nothing)
             '    result = EmitVariableInitializer(Info) AndAlso result
             'ElseIf Me.Modifiers.Is(ModifierMasks.Static) Then
             '    result = EmitStaticInitializer(Info) AndAlso result
             'Else
             '    'Field builder has been defined in DefineMember
             '    'EmitVariableInitializer will be called by the constructor declaration
             'End If
 
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="221" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" hamdist="10" pcid="8847" startline="201"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Compiler.Report.Trace("{0}
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
 
         result = MyBase.ResolveCode(ResolveInfo.Default(Info.Compiler)) AndAlso result
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveCode(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
         If m_NewExpression IsNot Nothing Then
             result = m_NewExpression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
         End If
 
         If m_VariableInitializer IsNot Nothing Then
             result = m_VariableInitializer.ResolveCode(New ExpressionResolveInfo(Compiler, VariableType)) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="99" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ElseIfStatement.vb" hamdist="11" pcid="9383" startline="71"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveExpression(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         If m_Condition.Classification.IsValueClassification Then
             'nothing to do
         ElseIf m_Condition.Classification.CanBeValueClassification Then
             m_Condition = m_Condition.ReclassifyToValueExpression
             result = m_Condition.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
 
             If result = False Then
                 result = Helper.AddError(Me) AndAlso result
                 Return result
             End If
             m_Condition = Helper.CreateTypeConversion(Me, m_Condition, Compiler.TypeCache.System_Boolean, result)
 
             If result = False Then
                 result = Helper.AddError(Me) AndAlso result
                 Return result
             End If
         Else
             result = Helper.AddError(Me, "Each expression in an If...Then...Else statement must be classified as a value and be implicitly convertible to Boolean") AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="58" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RedimClause.vb" hamdist="7" pcid="9477" startline="51"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then result = m_Expression.ResolveTypeReferences AndAlso result
         If m_ArraySizeInitModifier IsNot Nothing Then result = m_ArraySizeInitModifier.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="49" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" hamdist="6" pcid="7031" startline="41"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_FirstPart IsNot Nothing Then result = m_FirstPart.ResolveTypeReferences AndAlso result
         If m_SecondPart IsNot Nothing Then result = m_SecondPart.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="142" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" hamdist="11" pcid="9377" startline="118"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_PreCondition IsNot Nothing Then
             result = m_PreCondition.ResolveExpression(Info) AndAlso result
             result = Helper.VerifyValueClassification(m_PreCondition, Info) AndAlso result
 
             If Me.Location.File(Compiler).IsOptionStrictOn AndAlso Compiler.TypeResolution.IsImplicitlyConvertible(Me, m_PreCondition.ExpressionType, Compiler.TypeCache.System_Boolean) = False Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30512, m_PreCondition.Location, m_PreCondition.ExpressionType.FullName, "Boolean")
             End If
         End If
 
         If m_PostCondition IsNot Nothing Then
             result = m_PostCondition.ResolveExpression(info) AndAlso result
             result = Helper.VerifyValueClassification(m_PostCondition, Info) AndAlso result
 
             If Me.Location.File(Compiler).IsOptionStrictOn AndAlso Compiler.TypeResolution.IsImplicitlyConvertible(Me, m_PostCondition.ExpressionType, Compiler.TypeCache.System_Boolean) = False Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30512, m_PostCondition.Location, m_PostCondition.ExpressionType.FullName, "Boolean")
             End If
         End If
         result = CodeBlock.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="178" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" hamdist="17" pcid="8817" startline="168"><![CDATA[
 
     Overridable Overloads Function ResolveTypeReferences(ByVal ResolveTypeParameters As Boolean) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ParameterList IsNot Nothing)
 
         result = m_ParameterList.ResolveTypeReferences AndAlso result
         If ResolveTypeParameters = True AndAlso m_TypeParameters IsNot Nothing Then result = m_TypeParameters.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="39" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" hamdist="11" pcid="8323" startline="32"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_BoundList IsNot Nothing Then result = m_BoundList.ResolveTypeReferences AndAlso result
         If m_ArrayTypeModifiers IsNot Nothing Then result = m_ArrayTypeModifiers.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="110" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" hamdist="11" pcid="8549" startline="96"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If HandlesClause IsNot Nothing Then
             result = HandlesClause.ResolveTypeReferences AndAlso result
         ElseIf ImplementsClause IsNot Nothing Then
             result = ImplementsClause.ResolveTypeReferences AndAlso result
         Else
             Helper.Stop()
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="91" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\TypeOfExpression.vb" hamdist="11" pcid="7245" startline="73"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
         result = m_Type.ResolveTypeReferences AndAlso result
 
         Classification = New ValueClassification(Me)
 
         If m_Expression.Classification.IsValueClassification Then
         ElseIf m_Expression.Classification.CanBeValueClassification Then
             m_Expression = m_Expression.ReclassifyToValueExpression()
             result = m_Expression.ResolveExpression(Info) AndAlso result
         Else
             result = Helper.AddError(Me) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="71" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReturnStatement.vb" hamdist="8" pcid="9497" startline="49"><![CDATA[
 
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             result = m_Expression.ResolveExpression(info) AndAlso result
             If result AndAlso m_Expression.Classification.IsValueClassification = False Then
                 m_Expression = m_Expression.ReclassifyToValueExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         If result = False Then Return result
 
         If m_Expression IsNot Nothing Then
             Dim method As IMethod
             method = Me.FindFirstParent(Of IMethod)()
             m_Expression = Helper.CreateTypeConversion(Me, m_Expression, method.Signature.ReturnType, result)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="397" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" hamdist="12" pcid="7483" startline="364"><![CDATA[
 
     Private Function Compile_Resolve() As Boolean
         Dim result As Boolean = True
 
         result = CommandLine.Imports.ResolveCode(ResolveInfo.Default(Me)) AndAlso result
         VerifyConsistency(result, "ResolveCode")
         If result = False Then Return result
 
         result = CommandLine.Files.Resolve(ResolveInfo.Default(Me)) AndAlso result
         VerifyConsistency(result, "Resolve")
         If result = False Then Return result
 
         result = theAss.CreateImplicitTypes AndAlso result
         VerifyConsistency(result, "CreateImplicitTypes")
         If result = False Then Return result
 
         result = theAss.ResolveTypeReferences AndAlso result
         VerifyConsistency(result, "ResolveTypeReferences")
         If result = False Then Return result
 
         m_TypeCache.InitInternalVBMembers()
 
         result = theAss.CreateImplicitMembers AndAlso result
         VerifyConsistency(result, "CreateImplicitMembers")
         If result = False Then Return result
 
         result = theAss.ResolveMembers AndAlso result
         VerifyConsistency(result, "ResolveMembers")
         result = theAss.ResolveCode(ResolveInfo.Default(Me)) AndAlso result
 
         VerifyConsistency(result, "FinishedResolve")
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="39" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AddOrRemoveHandlerStatement.vb" hamdist="9" pcid="9303" startline="32"><![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Event IsNot Nothing Then result = m_Event.ResolveTypeReferences AndAlso result
         If m_EventHandler IsNot Nothing Then result = m_EventHandler.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="228" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" hamdist="8" pcid="8753" startline="219"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         If m_Get IsNot Nothing Then result = m_Get.ResolveCode(Info) AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="54" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" hamdist="9" pcid="9331" startline="44"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Target IsNot Nothing Then result = m_Target.ResolveTypeReferences AndAlso result
         If m_Start IsNot Nothing Then result = m_Start.ResolveTypeReferences AndAlso result
         If m_Length IsNot Nothing Then result = m_Length.ResolveTypeReferences AndAlso result
         If m_Source IsNot Nothing Then result = m_Source.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="145" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" hamdist="10" pcid="9441" startline="112"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveExpression(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
         If m_FalseCode IsNot Nothing Then result = m_FalseCode.ResolveCode(Info) AndAlso result
         If m_ElseIfs IsNot Nothing Then result = m_ElseIfs.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         If m_Condition.Classification.IsValueClassification Then
             'nothing to do
         ElseIf m_Condition.Classification.CanBeValueClassification Then
             m_Condition = m_Condition.ReclassifyToValueExpression
             result = m_Condition.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
 
             If result = False Then
                 Helper.AddError(Me)
                 Return result
             End If
         Else
             Helper.AddError(Me, "Each expression in an If...Then...Else statement must be classified as a value and be implicitly convertible to Boolean")
         End If
 
         m_Condition = Helper.CreateTypeConversion(Me, m_Condition, Compiler.TypeCache.System_Boolean, result)
 
         If result = False Then
             Helper.AddError(Me)
             Return result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="196" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" hamdist="7" pcid="9461" startline="159"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim sne As SimpleNameExpression
 
         If m_Expression IsNot Nothing Then
             sne = TryCast(m_Expression, SimpleNameExpression)
             If sne IsNot Nothing Then
                 sne.InferEnabled = Me.IsOptionInferOn
                 If sne.ResolveExpression(Info) = False Then
                     If sne.InferPossible Then
                         MustInfer = True
                         result = True 'So far so good
                     Else
                         result = False
                     End If
                 End If
             Else
                 result = m_Expression.ResolveExpression(Info) AndAlso result
 
                 Dim iie As InvocationOrIndexExpression = TryCast(m_Expression, InvocationOrIndexExpression)
                 If iie IsNot Nothing AndAlso iie.IsLateBoundArray Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30039, Location) AndAlso result
                 End If
             End If
         Else
             'result = m_Identifier.Resolve AndAlso result
             'result = m_ArrayNameModifier.Resolve AndAlso result
             result = m_TypeName.ResolveTypeReferences AndAlso result
             m_Declaration = New LocalVariableDeclaration(Me, New Modifiers(), m_Identifier, False, m_TypeName, Nothing, Nothing)
             result = m_Declaration.ResolveTypeReferences() AndAlso result
             'result = m_Declaration.ResolveMember(ResolveInfo.Default(Info.Compiler)) AndAlso result
             result = m_Declaration.ResolveCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="105" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" hamdist="8" pcid="6515" startline="87"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             result = m_Expression.ResolveExpression(Info) AndAlso result
 
             If result AndAlso m_Expression.Classification.IsMethodGroupClassification Then
                 m_Expression = m_Expression.ReclassifyToValueExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             ElseIf result AndAlso m_Expression.Classification.IsPropertyGroupClassification Then
                 m_Expression = m_Expression.ReclassifyToPropertyAccessExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="523" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" hamdist="17" pcid="6277" startline="503"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Variables.Count - 1
             Dim var As LocalVariableDeclaration = m_Variables(i)
             result = CreateLabelForCurrentInstruction(Info) AndAlso result
             result = var.DefineLocalVariable(Info) AndAlso result
         Next
 
         For i As Integer = 0 To m_Sequence.Count - 1
             Dim stmt As BaseObject = m_Sequence.Item(i)
 
             Emitter.MarkSequencePoint(Info, stmt.Location)
 
             result = CreateLabelForCurrentInstruction(Info) AndAlso result
             result = stmt.GenerateCode(Info) AndAlso result
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="223" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" hamdist="16" pcid="8407" startline="207"><![CDATA[
 
     Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         If m_TypeName Is Nothing AndAlso Location.File(Compiler).IsOptionStrictOn Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30209, Me.Location) AndAlso result
         End If
 
         If m_ConstantExpression Is Nothing Then
             Helper.AddError(Me, "No constant expression.")
             Return False
         End If
 
         result = ResolveConstantValue(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="67" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeArityList.vb" hamdist="12" pcid="9923" startline="55"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_TypeParameters.Length - 1
             If m_TypeParameters(i) IsNot Nothing Then
                 result = m_TypeParameters(i).ResolveTypeReferences() AndAlso result
             End If
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="86" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseClause.vb" hamdist="16" pcid="9349" startline="74"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim casestmt As CaseStatement = Me.FindFirstParent(Of CaseStatement)()
         Dim selectstmt As SelectStatement = Me.FindFirstParent(Of SelectStatement)()
 
         result = m_ComparisonExpression.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
 
         Emitter.EmitBranchIfTrue(Info, casestmt.StartCode)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="111" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\IfStatement.vb" hamdist="7" pcid="9439" startline="82"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim startFalse As Label = Emitter.DefineLabel(Info)
         EndLabel = Emitter.DefineLabel(Info)
 
         result = m_Condition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
 
         Emitter.EmitBranchIfFalse(Info, startFalse)
         'True code
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, EndLabel)
 
         'False code
         Emitter.MarkLabel(Info, startFalse)
         If m_ElseIfs IsNot Nothing Then
             For Each eif As ElseIfStatement In m_ElseIfs
                 result = eif.GenerateCode(Info) AndAlso result
             Next
         End If
 
         If m_FalseCode IsNot Nothing Then
             result = m_FalseCode.GenerateCode(Info) AndAlso result
         End If
         Emitter.MarkLabel(Info, EndLabel)
 
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="140" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" hamdist="13" pcid="8539" startline="106"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences(ByVal ResolveTypeParameters As Boolean) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences(ResolveTypeParameters) AndAlso result
         If m_ReturnTypeAttributes IsNot Nothing Then result = m_ReturnTypeAttributes.ResolveTypeReferences AndAlso result
 
         If m_ReturnType Is Nothing Then
             If m_TypeName IsNot Nothing Then
                 result = m_TypeName.ResolveTypeReferences AndAlso result
                 If result = False Then Return result
                 m_ReturnType = m_TypeName.ResolvedType
             ElseIf Identifier.HasTypeCharacter Then
                 m_ReturnType = TypeCharacters.TypeCharacterToType(Compiler, Identifier.TypeCharacter)
             Else
                 If Me.Location.File(Compiler).IsOptionStrictOn Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30210, Me.Location) AndAlso result
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC42024, Me.Location) AndAlso result
                 End If
                 m_ReturnType = Compiler.TypeCache.System_Object
             End If
 
             If result AndAlso m_ReturnType.GenericParameters.Count > 0 Then
                 Dim tmp As New Mono.Cecil.GenericInstanceType(m_ReturnType)
                 For i As Integer = 0 To m_ReturnType.GenericParameters.Count - 1
                     tmp.GenericArguments.Add(m_ReturnType.GenericParameters(i))
                 Next
                 m_ReturnType = tmp
             End If
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="58" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ConcatExpression.vb" hamdist="9" pcid="6601" startline="23"><![CDATA[
     Protected Overrides Function ResolveExpressions(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressions(Info) AndAlso result
 
         If result = False Then Return result
 
         Dim l, r, other As Boolean
         l = Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_DBNull)
         r = Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_DBNull)
         If l AndAlso r = False Then 'DBNull & whatever
             m_LeftExpression = New NothingConstantExpression(Me)
             result = m_LeftExpression.ResolveExpression(Info) AndAlso result
         ElseIf l = False AndAlso r Then 'whatever & DBNull
             m_RightExpression = New NothingConstantExpression(Me)
             result = m_RightExpression.ResolveExpression(Info) AndAlso result
         Else
             other = True
         End If
 
         If l = False Then
             If Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_Char_Array) Then
                 m_LeftExpression = New CStrExpression(Me, m_LeftExpression)
                 result = m_LeftExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         If r = False Then
             If Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_Char_Array) Then
                 m_RightExpression = New CStrExpression(Me, m_RightExpression)
                 result = m_RightExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="359" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" hamdist="14" pcid="7057" startline="348"><![CDATA[
 
     Function DereferenceByRef() As Expression
         Dim result As Expression
 
         If CecilHelper.IsByRef(ExpressionType) Then
             result = New DeRefExpression(Me, Me)
         Else
             result = Me
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="61" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\BoundList.vb" hamdist="15" pcid="8389" startline="49"><![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Expressions.Length - 1
             result = m_Expressions(i).ResolveExpression(Info) AndAlso result
             If result Then
                 m_Expressions(i) = Helper.CreateTypeConversion(Me, m_Expressions(i), Compiler.TypeCache.System_Int32, result)
             End If
         Next
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="21" nfragments="2">
<clone_fragment endline="108" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" hamdist="0" pcid="9933" startline="102"><![CDATA[
     End Property
 
     ReadOnly Property AsArrayTypeName() As ArrayTypeName
         Get
             Helper.Assert(IsArray)
             Return DirectCast(m_TypeName, ArrayTypeName)
         End Get
]]></clone_fragment>
<clone_fragment endline="101" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" hamdist="7" pcid="9931" startline="95"><![CDATA[
     End Property
 
     ReadOnly Property AsNonArrayTypeName() As NonArrayTypeName
         Get
             Helper.Assert(IsNotArray)
             Return DirectCast(m_TypeName, NonArrayTypeName)
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="22" nfragments="2">
<clone_fragment endline="841" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="0" pcid="1263" startline="835"><![CDATA[
 		}
 
 		public TypeParameterSpec[] TypeParameters {
 			get {
 				// TODO
 				return CurrentTypeParameters.Select (l => l.Type).ToArray ();
 			}
]]></clone_fragment>
<clone_fragment endline="673" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" hamdist="8" pcid="2139" startline="667"><![CDATA[
 		}
 
 		TypeParameterSpec[] ITypeDefinition.TypeParameters {
 			get {
 				// TODO MemberCache
 				return PartialContainer.type_params.Select (l => l.Type).ToArray ();
 			}
]]></clone_fragment>
</clone_group>
<clone_group groupid="23" nfragments="3">
<clone_fragment endline="1514" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="0" pcid="2303" startline="1508"><![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			base.Emit (ec);
 
 			ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]></clone_fragment>
<clone_fragment endline="1487" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="7" pcid="4765" startline="1478"><![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			expr.Emit (ec);
 
 			ec.Emit (OpCodes.Isinst, type);
 
 			if (TypeManager.IsGenericParameter (type) || TypeManager.IsNullableType (type))
 				ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]></clone_fragment>
<clone_fragment endline="7249" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="10" pcid="4965" startline="7242"><![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldtoken, member);
 
 			base.Emit (ec);
 			ec.Emit (OpCodes.Castclass, type);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="24" nfragments="3">
<clone_fragment endline="198" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="0" pcid="6371" startline="192"><![CDATA[
 
     Shared Sub EmitNotEquals(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Ceq)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]></clone_fragment>
<clone_fragment endline="228" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="4" pcid="6375" startline="222"><![CDATA[
 
     Shared Sub EmitLE(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Cgt)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]></clone_fragment>
<clone_fragment endline="205" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="3" pcid="6373" startline="199"><![CDATA[
 
     Shared Sub EmitGE(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Clt)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="25" nfragments="2">
<clone_fragment endline="174" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" hamdist="0" pcid="2913" startline="168"><![CDATA[
 		}
 
 		public override Type[] GetGenericArguments()
 		{
 			PopulateGenericArguments();
 			return Util.Copy(typeArgs);
 		}
]]></clone_fragment>
<clone_fragment endline="219" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" hamdist="0" pcid="6079" startline="213"><![CDATA[
 		}
 
 		public override Type[] GetGenericArguments()
 		{
 			PopulateGenericArguments();
 			return Util.Copy(typeArgs);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="26" nfragments="2">
<clone_fragment endline="48" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" hamdist="0" pcid="2613" startline="42"><![CDATA[
 		internal TextSection(PEWriter peWriter, CliHeader cliHeader, ModuleBuilder moduleBuilder, int strongNameSignatureLength)
 		{
 			this.peWriter = peWriter;
 			this.cliHeader = cliHeader;
 			this.moduleBuilder = moduleBuilder;
 			this.strongNameSignatureLength = (uint)strongNameSignatureLength;
 		}
]]></clone_fragment>
<clone_fragment endline="46" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" hamdist="9" pcid="2933" startline="39"><![CDATA[
 		internal ParameterBuilder(ModuleBuilder moduleBuilder, int sequence, ParameterAttributes attribs, string name)
 		{
 			this.moduleBuilder = moduleBuilder;
 			this.flags = (short)attribs;
 			this.sequence = (short)sequence;
 			this.nameIndex = name == null ? 0 
 			this.name = name;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="27" nfragments="2">
<clone_fragment endline="218" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" hamdist="0" pcid="5449" startline="211"><![CDATA[
 
 		public int Read ()
 		{
 			if ((pos >= char_count) && !ReadBuffer ())
 				return -1;
 
 			return buffer [pos++];
 		}
]]></clone_fragment>
<clone_fragment endline="210" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" hamdist="10" pcid="5447" startline="203"><![CDATA[
 
 		public int Peek ()
 		{
 			if ((pos >= char_count) && !ReadBuffer ())
 				return -1;
 
 			return buffer [pos];
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="28" nfragments="6">
<clone_fragment endline="188" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" hamdist="0" pcid="727" startline="181"><![CDATA[
 
 		public static void OpenCompilerGeneratedBlock (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.OpenCompilerGeneratedBlock (offset);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="212" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" hamdist="4" pcid="733" startline="205"><![CDATA[
 
 		public static void EndIteratorBody (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.EndIteratorBody (offset);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="196" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" hamdist="5" pcid="729" startline="189"><![CDATA[
 
 		public static void CloseCompilerGeneratedBlock (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.CloseCompilerGeneratedBlock (offset);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="204" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" hamdist="8" pcid="731" startline="197"><![CDATA[
 
 		public static void StartIteratorBody (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.StartIteratorBody (offset);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="220" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" hamdist="6" pcid="735" startline="213"><![CDATA[
 
 		public static void StartIteratorDispatcher (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.StartIteratorDispatcher (offset);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="228" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" hamdist="6" pcid="737" startline="221"><![CDATA[
 
 		public static void EndIteratorDispatcher (EmitContext ec)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ec.ig);
 				symwriter.EndIteratorDispatcher (offset);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="29" nfragments="2">
<clone_fragment endline="859" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="0" pcid="7355" startline="852"><![CDATA[
 
     Public Shared Function IsDefined(ByVal CustomAttributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal Type As TypeReference) As Boolean
         For i As Integer = 0 To CustomAttributes.Count - 1
             Dim Attribute As CustomAttribute = CustomAttributes(i)
             If Helper.CompareType(Attribute.Constructor.DeclaringType, Type) Then Return True
         Next
         Return False
     End Function
]]></clone_fragment>
<clone_fragment endline="176" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" hamdist="9" pcid="7995" startline="169"><![CDATA[
 
     Function IsNamespaceExact(ByVal A As String, ByVal B As String) As Boolean
         For i As Integer = 0 To Me.Count - 1
             Dim ns As [Namespace] = Me.Item(i)
             If ns.Equals(A, B) Then Return True
         Next
         Return False
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="30" nfragments="2">
<clone_fragment endline="1262" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7611" startline="1255"><![CDATA[
 
     Public Shared Function CompareParameterTypes(ByVal a As Mono.Collections.Generic.Collection(Of ParameterDefinition), ByVal b As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         If a.Count <> b.Count Then Return False
         For i As Integer = 0 To a.Count - 1
             If Helper.CompareType(a(i).ParameterType, b(i).ParameterType) = False Then Return False
         Next
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="1342" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="6" pcid="7417" startline="1334"><![CDATA[
 
     Public Shared Function AreSame(ByVal a As Mono.Collections.Generic.Collection(Of ParameterDefinition), ByVal b As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         If a.Count <> b.Count Then Return False
         If a.Count = 0 Then Return True
         For i As Integer = 0 To a.Count - 1
             If Not AreSame(a(i).ParameterType, b(i).ParameterType) Then Return False
         Next
         Return True
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="31" nfragments="4">
<clone_fragment endline="277" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" hamdist="0" pcid="8013" startline="270"><![CDATA[
 
     ''' <summary>
     ''' Shows the multiline message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message() As Messages, ByVal Location As Span, ByVal ParamArray Parameters()() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]></clone_fragment>
<clone_fragment endline="285" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" hamdist="8" pcid="8015" startline="278"><![CDATA[
 
     ''' <summary>
     ''' Saves the message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function SaveMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(True, New Message(Compiler, Message, Parameters, Location))
     End Function
]]></clone_fragment>
<clone_fragment endline="260" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" hamdist="6" pcid="8009" startline="253"><![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]></clone_fragment>
<clone_fragment endline="269" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" hamdist="6" pcid="8011" startline="261"><![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessageNoLocation(ByVal Message As Messages, ByVal ParamArray Parameters() As String) As Boolean
         Dim Location As Span = Nothing
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="32" nfragments="3">
<clone_fragment endline="53" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" hamdist="0" pcid="2073" startline="46"><![CDATA[
 
 		static bool IsValidEnumType (TypeSpec t)
 		{
 			return (t == TypeManager.int32_type || t == TypeManager.uint32_type || t == TypeManager.int64_type ||
 				t == TypeManager.byte_type || t == TypeManager.sbyte_type || t == TypeManager.short_type ||
 				t == TypeManager.ushort_type || t == TypeManager.uint64_type || t == TypeManager.char_type ||
 				TypeManager.IsEnumType (t));
 		}
]]></clone_fragment>
<clone_fragment endline="2415" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="10" pcid="3719" startline="2407"><![CDATA[
 
 		static bool IsUnsigned (TypeSpec t)
 		{
 			if (t.IsPointer)
 				return true;
 
 			return (t == TypeManager.uint32_type || t == TypeManager.uint64_type ||
 				t == TypeManager.ushort_type || t == TypeManager.byte_type);
 		}
]]></clone_fragment>
<clone_fragment endline="364" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="12" pcid="4277" startline="353"><![CDATA[
 
 		static bool IsValidArgumentType (TypeSpec t)
 		{
 			if (t.IsArray)
 				t = TypeManager.GetElementType (t);
 
 			return t == TypeManager.string_type ||
 				TypeManager.IsPrimitiveType (t) ||
 				TypeManager.IsEnumType (t) ||
 				t == TypeManager.object_type ||
 				t == TypeManager.type_type;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="33" nfragments="2">
<clone_fragment endline="139" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" hamdist="0" pcid="5341" startline="132"><![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.callingConvention = callingConvention;
 			return sig;
 		}
]]></clone_fragment>
<clone_fragment endline="131" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" hamdist="4" pcid="5339" startline="123"><![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, CallingConvention unmanagedCallConv, Type returnType)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.unmanaged = true;
 			sig.unmanagedCallConv = unmanagedCallConv;
 			return sig;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="34" nfragments="3">
<clone_fragment endline="908" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="0" pcid="7363" startline="901"><![CDATA[
 
     Public Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim result As New Mono.Collections.Generic.Collection(Of TypeReference)(Params.Count)
         For i As Integer = 0 To Params.Count - 1
             result.Add(Params(i))
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="900" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="3" pcid="7361" startline="893"><![CDATA[
 
     Public Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of GenericParameter)) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim result As New Mono.Collections.Generic.Collection(Of TypeReference)(Params.Count)
         For i As Integer = 0 To Params.Count - 1
             result.Add(Params(i))
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1593" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="10" pcid="7639" startline="1584"><![CDATA[
 
     Shared Function ApplyTypeArguments(ByVal Parent As ParsedObject, ByVal OpenParameters As Mono.Collections.Generic.Collection(Of ParameterReference), ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.ParameterReference()
         Dim result(OpenParameters.Count - 1) As Mono.Cecil.ParameterReference
 
         For i As Integer = 0 To result.Length - 1
             result(i) = ApplyTypeArguments(Parent, OpenParameters(i), TypeParameters, TypeArguments)
         Next
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="35" nfragments="3">
<clone_fragment endline="2036" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7669" startline="2029"><![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypeToSearch As Mono.Cecil.TypeReference, ByVal TypesToFind As Mono.Collections.Generic.Collection(Of TypeReference)) As Boolean
         For i As Integer = 0 To TypesToFind.Count - 1
             Dim t As Mono.Cecil.TypeReference = TypesToFind(i)
             If Helper.CompareType(t, TypeToSearch) OrElse Helper.IsSubclassOf(TypeToSearch, t) Then Return True
         Next
         Return False
     End Function
]]></clone_fragment>
<clone_fragment endline="2044" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="5" pcid="7671" startline="2037"><![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypesToSearch As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeToFind As Mono.Cecil.TypeReference) As Boolean
         For i As Integer = 0 To TypesToSearch.Count - 1
             Dim t As Mono.Cecil.TypeReference = TypesToSearch(i)
             If Helper.CompareType(t, TypeToFind) OrElse Helper.IsSubclassOf(TypeToFind, t) Then Return True
         Next
         Return False
     End Function
]]></clone_fragment>
<clone_fragment endline="2028" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="7" pcid="7667" startline="2021"><![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypesToSearch As Mono.Cecil.TypeReference(), ByVal TypeToFind As Mono.Cecil.TypeReference) As Boolean
         For i As Integer = 0 To TypesToSearch.Length - 1
             Dim t As Mono.Cecil.TypeReference = TypesToSearch(i)
             If Helper.CompareType(t, TypeToFind) OrElse Helper.IsSubclassOf(t, TypeToFind) Then Return True
         Next
         Return False
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="36" nfragments="6">
<clone_fragment endline="1662" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="0" pcid="4781" startline="1655"><![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]></clone_fragment>
<clone_fragment endline="7300" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="0" pcid="4957" startline="7293"><![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]></clone_fragment>
<clone_fragment endline="167" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="0" pcid="2267" startline="159"><![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]></clone_fragment>
<clone_fragment endline="8795" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="9" pcid="5063" startline="8786"><![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (3);
 			args.Add (new Argument (source.CreateExpressionTree (ec)));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			args.Add (new Argument (new TypeOfMethod (method, loc)));
 			return CreateExpressionFactoryCall (ec, "Convert", args);
 		}
]]></clone_fragment>
<clone_fragment endline="7118" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="10" pcid="4943" startline="7108"><![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (this));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			return CreateExpressionFactoryCall (ec, "Constant", args);
 		}
]]></clone_fragment>
<clone_fragment endline="1045" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="9" pcid="2241" startline="1033"><![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (child.CreateExpressionTree (ec)));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 
 			if (type.IsPointer || child.Type.IsPointer)
 				Error_PointerInsideExpressionTree (ec);
 
 			return CreateExpressionFactoryCall (ec, ec.HasSet (ResolveContext.Options.CheckedScope) ? "ConvertChecked" 
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="37" nfragments="2">
<clone_fragment endline="60" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" hamdist="0" pcid="7191" startline="53"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="50" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleExpression.vb" hamdist="0" pcid="7215" startline="43"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="38" nfragments="2">
<clone_fragment endline="180" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" hamdist="0" pcid="6033" startline="173"><![CDATA[
 
 		public void CloseScope (int end_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.EndBlock (end_offset);
 		}
]]></clone_fragment>
<clone_fragment endline="197" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" hamdist="10" pcid="6037" startline="190"><![CDATA[
 
 		public void CloseCompilerGeneratedBlock (int end_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.EndBlock (end_offset);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="39" nfragments="2">
<clone_fragment endline="975" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" hamdist="0" pcid="3199" startline="968"><![CDATA[
 
 		/// <summary>
 		///  User-defined Explicit conversions
 		/// </summary>
 		static Expression ExplicitUserConversion (ResolveContext ec, Expression source, TypeSpec target, Location loc)
 		{
 			return UserDefinedConversion (ec, source, target, false, loc);
 		}
]]></clone_fragment>
<clone_fragment endline="967" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" hamdist="10" pcid="3197" startline="960"><![CDATA[
 
 		/// <summary>
 		///  User-defined Implicit conversions
 		/// </summary>
 		static public Expression ImplicitUserConversion (ResolveContext ec, Expression source, TypeSpec target, Location loc)
 		{
 			return UserDefinedConversion (ec, source, target, true, loc);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="40" nfragments="4">
<clone_fragment endline="2027" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="0" pcid="4391" startline="2020"><![CDATA[
 
 		public void EmitAttribute (FieldBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="2043" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="7" pcid="4395" startline="2036"><![CDATA[
 
 		public void EmitAttribute (PropertyBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="2035" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="6" pcid="4393" startline="2028"><![CDATA[
 
 		public void EmitAttribute (ParameterBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="2051" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="7" pcid="4397" startline="2044"><![CDATA[
 
 		public void EmitAttribute (TypeBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="41" nfragments="2">
<clone_fragment endline="548" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Code\CodeBlock.vb" hamdist="0" pcid="6281" startline="541"><![CDATA[
     End Property
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If m_Variables IsNot Nothing Then m_Variables.Initialize(Me)
         If m_Statements IsNot Nothing Then m_Statements.Initialize(Me)
     End Sub
]]></clone_fragment>
<clone_fragment endline="91" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" hamdist="9" pcid="8805" startline="82"><![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         Helper.Assert(TypeOf Parent Is ClassDeclaration = False)
 
         If m_Identifier IsNot Nothing Then m_Identifier.Initialize(Me)
         If m_TypeParameters IsNot Nothing Then m_TypeParameters.Initialize(Me)
         If m_ParameterList IsNot Nothing Then m_ParameterList.Initialize(Me)
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="42" nfragments="2">
<clone_fragment endline="5230" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="0" pcid="9233" startline="5223"><![CDATA[
 
     Private Function ParseRedimClauses(ByVal Parent As ReDimStatement) As RedimClauses
         Dim result As New RedimClauses(Parent)
         If ParseList(Of RedimClause)(result, New ParseDelegate_Parent(Of RedimClause)(AddressOf ParseRedimClause), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2967" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="10" pcid="9077" startline="2958"><![CDATA[
 
     Private Function ParseExpressionList(ByVal Parent As ParsedObject) As ExpressionList
         Dim result As New ExpressionList(Parent)
 
         If ParseList(Of Expression)(result, New ParseDelegate_Parent(Of Expression)(AddressOf ParseExpression), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="43" nfragments="3">
<clone_fragment endline="67" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" hamdist="0" pcid="9401" startline="60"><![CDATA[
 
     Shadows Sub Init(ByVal LoopControlVariable As LoopControlVariable, ByVal InExpression As Expression, ByVal NextExpression As Expression, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_LoopControlVariable = LoopControlVariable
         m_InExpression = InExpression
         m_NextExpression = NextExpression
     End Sub
]]></clone_fragment>
<clone_fragment endline="139" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" hamdist="9" pcid="9413" startline="130"><![CDATA[
 
     Shadows Sub Init(ByVal LoopControlVariable As LoopControlVariable, ByVal LoopStartExpression As Expression, ByVal LoopEndExpression As Expression, ByVal LoopStepExpression As Expression, ByVal NextExpressionList As ExpressionList, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_LoopControlVariable = LoopControlVariable
         m_LoopStartExpression = LoopStartExpression
         m_LoopEndExpression = LoopEndExpression
         m_LoopStepExpression = LoopStepExpression
         m_NextExpressionList = NextExpressionList
     End Sub
]]></clone_fragment>
<clone_fragment endline="90" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" hamdist="11" pcid="9525" startline="81"><![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal ArgumentList As ArgumentList, ByVal VariableInitializer As VariableInitializer, ByVal IsVariableDeclaration As Boolean, ByVal VariableDeclaration As LocalVariableDeclaration)
         m_Identifier = Identifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_ArgumentList = ArgumentList
         m_VariableInitializer = VariableInitializer
         m_IsVariableDeclaration = IsVariableDeclaration
         m_VariableDeclaration = VariableDeclaration
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="44" nfragments="3">
<clone_fragment endline="44" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" hamdist="0" pcid="7187" startline="37"><![CDATA[
 
     Shared Function IsUnaryMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="71" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" hamdist="1" pcid="9557" startline="64"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="52" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\OperatorExpression.vb" hamdist="4" pcid="7189" startline="45"><![CDATA[
 
     Shared Function IsBinaryMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="45" nfragments="3">
<clone_fragment endline="2110" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7683" startline="2103"><![CDATA[
 
     Shared Function GenerateCodeCollection(ByVal Collection As IEnumerable, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         For Each obj As IBaseObject In Collection
             result = obj.GenerateCode(Info) AndAlso result
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2094" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="7" pcid="7679" startline="2087"><![CDATA[
 
     Shared Function ResolveTypeReferences(ByVal ParamArray Collection As ParsedObject()) As Boolean
         Dim result As Boolean = True
         For Each obj As ParsedObject In Collection
             If obj IsNot Nothing Then result = obj.ResolveTypeReferences AndAlso result
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2071" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="5" pcid="7675" startline="2064"><![CDATA[
 
     Shared Function DefineMembersCollection(ByVal Collection As Generic.IEnumerable(Of IDefinableMember)) As Boolean
         Dim result As Boolean = True
         For Each obj As IDefinableMember In Collection
             result = obj.DefineMember AndAlso result
         Next
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="46" nfragments="3">
<clone_fragment endline="55" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" hamdist="0" pcid="8531" startline="48"><![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As Mono.Cecil.TypeReference, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_ReturnType = TypeName
         MyBase.Location = Location
     End Sub
]]></clone_fragment>
<clone_fragment endline="63" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" hamdist="7" pcid="8533" startline="56"><![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_TypeName = TypeName
         MyBase.Location = Location
     End Sub
]]></clone_fragment>
<clone_fragment endline="71" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" hamdist="4" pcid="8535" startline="64"><![CDATA[
 
     Shadows Sub Init(ByVal Identifier As Identifier, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_TypeName = TypeName
         MyBase.Location = Location
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="47" nfragments="2">
<clone_fragment endline="114" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" hamdist="0" pcid="2017" startline="107"><![CDATA[
 
 		public void AddUndefine (string value)
 		{
 			if (conditionals == null)
 				conditionals = new Dictionary<string, bool> (2);
 
 			conditionals [value] = false;
 		}
]]></clone_fragment>
<clone_fragment endline="106" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" hamdist="10" pcid="2015" startline="99"><![CDATA[
 
 		public void AddDefine (string value)
 		{
 			if (conditionals == null)
 				conditionals = new Dictionary<string, bool> (2);
 
 			conditionals [value] = true;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="48" nfragments="3">
<clone_fragment endline="54" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" hamdist="0" pcid="7119" startline="47"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="53" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceBases.vb" hamdist="10" pcid="8551" startline="44"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Bases IsNot Nothing)
         result = Helper.ResolveTypeReferencesCollection(m_Bases)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="48" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ReturnStatement.vb" hamdist="7" pcid="9495" startline="32"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim isSub As Boolean
 
         isSub = Info.Method.Signature.ReturnType Is Nothing OrElse Helper.CompareType(Info.Method.Signature.ReturnType, Compiler.TypeCache.System_Void)
         If isSub Then
             Helper.Assert(m_Expression Is Nothing)
         Else
             Helper.Assert(m_Expression IsNot Nothing)
             result = m_Expression.GenerateCode(Info.Clone(Me, True, , Info.Method.Signature.ReturnType)) AndAlso result
         End If
 
         Emitter.EmitRetOrLeave(Info, Me, Not isSub)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="49" nfragments="4">
<clone_fragment endline="745" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="0" pcid="7343" startline="738"><![CDATA[
 
     Public Shared Function MakeGenericMethod(ByVal Method As MethodReference, ByVal Types() As Mono.Cecil.TypeReference) As Mono.Cecil.GenericInstanceMethod
         Dim result As New Mono.Cecil.GenericInstanceMethod(Method)
         For i As Integer = 0 To Types.Length - 1
             result.GenericArguments.Add(Types(i))
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="454" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" hamdist="9" pcid="8247" startline="446"><![CDATA[
 
     Function MakeGenericParameter(ByVal Parent As ParsedObject, ByVal OpenParameter As Mono.Cecil.ParameterReference, ByVal ParameterType As Mono.Cecil.TypeReference) As Mono.Cecil.ParameterReference
         Dim result As Mono.Cecil.ParameterReference
 
         'result = New GenericParameterDescriptor(Parent, ParameterType, OpenParameter)
         result = Nothing 
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3657" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="13" pcid="7803" startline="3649"><![CDATA[
 
     Shared Function GetEventAccess(ByVal [Event] As Mono.Cecil.EventReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
 
         result = GetEventAttributes([Event])
         result = result And Mono.Cecil.MethodAttributes.MemberAccessMask
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3648" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="5" pcid="7801" startline="3640"><![CDATA[
 
     Shared Function GetPropertyAccess(ByVal [Property] As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
 
         result = GetPropertyAttributes([Property])
         result = result And Mono.Cecil.MethodAttributes.MemberAccessMask
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="50" nfragments="2">
<clone_fragment endline="827" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7583" startline="820"><![CDATA[
 
     Shared Function FilterByName(ByVal Types As TypeList, ByVal Name As String) As TypeList
         Dim result As New TypeList
         For Each obj As Mono.Cecil.TypeReference In Types
             If Helper.CompareName(Name, obj.Name) Then result.Add(obj)
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="807" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="9" pcid="7581" startline="798"><![CDATA[
 
     Shared Function FilterByName(ByVal collection As Generic.List(Of Type), ByVal Name As String) As Generic.List(Of Type)
         Dim result As New Generic.List(Of Type)
         Dim tmpname As String = ""
         For Each obj As Type In collection
             If Helper.CompareName(Name, obj.Name) Then result.Add(obj)
         Next
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="51" nfragments="2">
<clone_fragment endline="1723" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" hamdist="0" pcid="817" startline="1716"><![CDATA[
 
 		public TypeSpec GetAttributeCoClass ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.CoClass;
 		}
]]></clone_fragment>
<clone_fragment endline="1731" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" hamdist="10" pcid="819" startline="1724"><![CDATA[
 
 		public string GetAttributeDefaultMember ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.DefaultIndexerName;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="52" nfragments="2">
<clone_fragment endline="2006" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="0" pcid="5383" startline="1999"><![CDATA[
 	}
 
 	sealed class PointerType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new PointerType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]></clone_fragment>
<clone_fragment endline="1766" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="7" pcid="5369" startline="1757"><![CDATA[
 	}
 
 	sealed class MultiArrayType 
 	{
 		private readonly int rank;
 
 		internal static Type Make(Type type, int rank, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new MultiArrayType(type, rank, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="53" nfragments="2">
<clone_fragment endline="33" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToPropertyAccessExpression.vb" hamdist="0" pcid="7137" startline="26"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Me.Classification = New PropertyAccessClassification(Me)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="373" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" hamdist="10" pcid="7107" startline="364"><![CDATA[
 
     Private Function ResolveLateBoundArrayInvocation(ByVal Context As ParsedObject) As Boolean
         Dim result As Boolean = True
 
         Classification = New LateBoundAccessClassification(Me, Expression, Nothing, Nothing)
 
         m_IsLateBoundArray = True
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="54" nfragments="2">
<clone_fragment endline="2269" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7707" startline="2262"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> Shared Sub [Stop](Optional ByVal Message As String = "")
         If IsDebugging() Then
             IndirectedStop()
         Else
             Throw New InternalException(Message)
         End If
     End Sub
]]></clone_fragment>
<clone_fragment endline="2261" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="9" pcid="7705" startline="2248"><![CDATA[
 
     Class StopException
         Inherits Exception
 
         Sub New(ByVal Message As String)
             MyBase.New(Message)
         End Sub
     End Class
 
     <Diagnostics.DebuggerHidden()> Shared Sub StopIfDebugging(Optional ByVal Condition As Boolean = True)
         If Condition AndAlso IsDebugging() Then
             IndirectedStop()
         End If
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="55" nfragments="2">
<clone_fragment endline="771" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" hamdist="0" pcid="1803" startline="764"><![CDATA[
 
 		public void SetParameter (Parameter parameter)
 		{
 			base.parameters = new ParametersCompiled (parameter);
 			base.parameter_info = new ParameterInfo[] {
 				new ParameterInfo (this, 0)
 			};
 		}
]]></clone_fragment>
<clone_fragment endline="780" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" hamdist="8" pcid="1805" startline="772"><![CDATA[
 
 		public void SetParameters (Parameter first, Parameter second)
 		{
 			base.parameters = new ParametersCompiled (first, second);
 			base.parameter_info = new ParameterInfo[] {
 				new ParameterInfo (this, 0),
 				new ParameterInfo (this, 1)
 			};
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="56" nfragments="2">
<clone_fragment endline="125" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" hamdist="0" pcid="2619" startline="118"><![CDATA[
 		}
 
 		internal uint StrongNameSignatureRVA
 		{
 			get
 			{
 				return (ResourcesRVA + ResourcesLength + 3) & ~3U;
 			}
]]></clone_fragment>
<clone_fragment endline="112" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" hamdist="7" pcid="2617" startline="98"><![CDATA[
 		}
 
 		private uint ResourcesRVA
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 				{
 					return (MethodBodiesRVA + MethodBodiesLength + 3) & ~3U;
 				}
 				else
 				{
 					return (MethodBodiesRVA + MethodBodiesLength + 15) & ~15U;
 				}
 			}
]]></clone_fragment>
</clone_group>
<clone_group groupid="57" nfragments="8">
<clone_fragment endline="610" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="0" pcid="1365" startline="602"><![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]></clone_fragment>
<clone_fragment endline="1547" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="0" pcid="1457" startline="1539"><![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]></clone_fragment>
<clone_fragment endline="873" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="4" pcid="1393" startline="865"><![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteHasConstant()
 				.WriteBlobIndex()
 				.Value;
 		}
]]></clone_fragment>
<clone_fragment endline="2217" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="10" pcid="1535" startline="2209"><![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteImplementation()
 				.Value;
 		}
]]></clone_fragment>
<clone_fragment endline="1196" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="14" pcid="1415" startline="1188"><![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteHasDeclSecurity()
 				.WriteBlobIndex()
 				.Value;
 		}
]]></clone_fragment>
<clone_fragment endline="2111" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="16" pcid="1521" startline="2103"><![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]></clone_fragment>
<clone_fragment endline="1469" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="16" pcid="1447" startline="1461"><![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteTypeDefOrRef()
 				.Value;
 		}
]]></clone_fragment>
<clone_fragment endline="1596" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="7" pcid="1463" startline="1588"><![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteMethodDef()
 				.WriteHasSemantics()
 				.Value;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="58" nfragments="2">
<clone_fragment endline="1653" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="0" pcid="3383" startline="1645"><![CDATA[
 
 		public void Emit (EmitContext ec)
 		{
 			// TODO
 			if ((flags & Flags.CompilerGenerated) != 0)
 				CreateBuilder (ec);
 
 			ec.Emit (OpCodes.Ldloc, builder);
 		}
]]></clone_fragment>
<clone_fragment endline="1662" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="8" pcid="3385" startline="1654"><![CDATA[
 
 		public void EmitAssign (EmitContext ec)
 		{
 			// TODO
 			if ((flags & Flags.CompilerGenerated) != 0)
 				CreateBuilder (ec);
 
 			ec.Emit (OpCodes.Stloc, builder);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="59" nfragments="3">
<clone_fragment endline="59" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" hamdist="0" pcid="6005" startline="51"><![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			FieldSignature other = obj as FieldSignature;
 			return other != null
 				&& other.fieldType.Equals(fieldType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]></clone_fragment>
<clone_fragment endline="67" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" hamdist="5" pcid="5795" startline="59"><![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			PropertySignature other = obj as PropertySignature;
 			return other != null
 				&& other.propertyType.Equals(propertyType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]></clone_fragment>
<clone_fragment endline="59" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" hamdist="11" pcid="3259" startline="49"><![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			MethodSignature other = obj as MethodSignature;
 			return other != null
 				&& other.callingConvention == callingConvention
 				&& other.genericParamCount == genericParamCount
 				&& other.returnType.Equals(returnType)
 				&& Util.ArrayEquals(other.parameterTypes, parameterTypes)
 				&& Util.ArrayEquals(other.modifiers, modifiers);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="60" nfragments="2">
<clone_fragment endline="436" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" hamdist="0" pcid="2051" startline="428"><![CDATA[
 		}
 
 		public int File {
 			get {
 				if (token == 0)
 					return 0;
 if (checkpoints.Length <= CheckpointIndex) throw new Exception (String.Format ("Should not happen. Token is {0
 				return checkpoints [CheckpointIndex].File;
 			}
]]></clone_fragment>
<clone_fragment endline="427" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" hamdist="7" pcid="2049" startline="419"><![CDATA[
 		}
 
 		public int CompilationUnitIndex {
 			get {
 				if (token == 0)
 					return 0;
 if (checkpoints.Length <= CheckpointIndex) throw new Exception (String.Format ("Should not happen. Token is {0
 				return checkpoints [CheckpointIndex].CompilationUnit;
 			}
]]></clone_fragment>
</clone_group>
<clone_group groupid="61" nfragments="2">
<clone_fragment endline="3038" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="0" pcid="2353" startline="3030"><![CDATA[
 		}
 
 		public override bool IsInstance {
 			get {
 				if (best_candidate != null)
 					return !best_candidate.IsStatic;
 
 				return false;
 			}
]]></clone_fragment>
<clone_fragment endline="3047" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="4" pcid="2355" startline="3039"><![CDATA[
 		}
 
 		public override bool IsStatic {
 			get {
 				if (best_candidate != null)
 					return best_candidate.IsStatic;
 
 				return false;
 			}
]]></clone_fragment>
</clone_group>
<clone_group groupid="62" nfragments="2">
<clone_fragment endline="74" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" hamdist="0" pcid="2945" startline="66"><![CDATA[
 
 		public void AddOtherMethod(MethodBuilder mdBuilder)
 		{
 			if (otherMethods == null)
 			{
 				otherMethods = new List<MethodBuilder>();
 			}
 			otherMethods.Add(mdBuilder);
 		}
]]></clone_fragment>
<clone_fragment endline="86" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" hamdist="3" pcid="4655" startline="77"><![CDATA[
 
 		public void AddOtherMethod(MethodBuilder mdBuilder)
 		{
 			PatchCallingConvention(mdBuilder);
 			if (otherMethods == null)
 			{
 				otherMethods = new List<MethodBuilder>();
 			}
 			otherMethods.Add(mdBuilder);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="63" nfragments="2">
<clone_fragment endline="45" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" hamdist="0" pcid="8519" startline="37"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal CharsetModifier As KS, ByVal Identifier As Identifier, ByVal LibraryClause As LibraryClause, ByVal AliasClause As AliasClause, ByVal ParameterList As ParameterList)
         MyBase.Init(Modifiers, New SubSignature(Me, Identifier.Name, ParameterList), Nothing)
         Modifiers = Modifiers.AddModifier(KS.Shared)
         m_CharsetModifier = CharsetModifier
         m_Identifier = Identifier
         m_LibraryClause = LibraryClause
         m_AliasClause = AliasClause
     End Sub
]]></clone_fragment>
<clone_fragment endline="54" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" hamdist="8" pcid="8521" startline="46"><![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal CharsetModifier As KS, ByVal LibraryClause As LibraryClause, ByVal AliasClause As AliasClause, ByVal Signature As SubSignature)
         MyBase.Init(Modifiers, Signature, Nothing)
         Modifiers = Modifiers.AddModifier(KS.Shared)
         m_CharsetModifier = CharsetModifier
         m_Identifier = Identifier
         m_LibraryClause = LibraryClause
         m_AliasClause = AliasClause
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="64" nfragments="2">
<clone_fragment endline="95" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="0" pcid="469" startline="87"><![CDATA[
 
 		internal void Write(int value)
 		{
 			buffer[0] = (byte)value;
 			buffer[1] = (byte)(value >> 8);
 			buffer[2] = (byte)(value >> 16);
 			buffer[3] = (byte)(value >> 24);
 			stream.Write(buffer, 0, 4);
 		}
]]></clone_fragment>
<clone_fragment endline="113" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="9" pcid="471" startline="101"><![CDATA[
 
 		internal void Write(long value)
 		{
 			buffer[0] = (byte)value;
 			buffer[1] = (byte)(value >> 8);
 			buffer[2] = (byte)(value >> 16);
 			buffer[3] = (byte)(value >> 24);
 			buffer[4] = (byte)(value >> 32);
 			buffer[5] = (byte)(value >> 40);
 			buffer[6] = (byte)(value >> 48);
 			buffer[7] = (byte)(value >> 56);
 			stream.Write(buffer, 0, 8);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="65" nfragments="2">
<clone_fragment endline="552" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" hamdist="0" pcid="4709" startline="544"><![CDATA[
 
 		Attribute ResolveModuleAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("module", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
]]></clone_fragment>
<clone_fragment endline="543" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" hamdist="9" pcid="4707" startline="535"><![CDATA[
 
 		public Attribute ResolveAssemblyAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("assembly", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="66" nfragments="2">
<clone_fragment endline="218" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" hamdist="0" pcid="2917" startline="210"><![CDATA[
 
 		public override MethodInfo GetGenericMethodDefinition()
 		{
 			if (this.IsGenericMethodDefinition)
 			{
 				return this;
 			}
 			throw new InvalidOperationException();
 		}
]]></clone_fragment>
<clone_fragment endline="357" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" hamdist="9" pcid="4003" startline="349"><![CDATA[
 
 		public override MethodInfo GetGenericMethodDefinition()
 		{
 			if (gtpb == null)
 			{
 				throw new InvalidOperationException();
 			}
 			return this;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="67" nfragments="2">
<clone_fragment endline="347" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" hamdist="0" pcid="5287" startline="339"><![CDATA[
 
 		public void SetNestedStoryParent (AnonymousMethodStorey parentStorey)
 		{
 			Parent = parentStorey;
 			type_params = null;
 			spec.IsGeneric = false;
 			spec.DeclaringType = parentStorey.CurrentType;
 			MemberName.TypeArguments = null;
 		}
]]></clone_fragment>
<clone_fragment endline="1084" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" hamdist="9" pcid="301" startline="1068"><![CDATA[
 
 		private TypeInfo (TypeSpec type)
 		{
 			this.Type = type;
 
 			struct_info = StructInfo.GetStructInfo (type);
 			if (struct_info != null) {
 				Length = struct_info.Length;
 				TotalLength = struct_info.TotalLength;
 				SubStructInfo = struct_info.StructFields;
 				IsStruct = true;
 			} else {
 				Length = 0;
 				TotalLength = 1;
 				IsStruct = false;
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="68" nfragments="2">
<clone_fragment endline="1135" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="0" pcid="3357" startline="1127"><![CDATA[
 
 		bool unwind_protect;
 
 		public override bool Resolve (BlockContext ec)
 		{
 			unwind_protect = ec.CurrentBranching.AddContinueOrigin (ec.CurrentBranching.CurrentUsageVector, loc);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="1108" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="3" pcid="3355" startline="1100"><![CDATA[
 
 		bool unwind_protect;
 
 		public override bool Resolve (BlockContext ec)
 		{
 			unwind_protect = ec.CurrentBranching.AddBreakOrigin (ec.CurrentBranching.CurrentUsageVector, loc);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="69" nfragments="2">
<clone_fragment endline="1454" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" hamdist="0" pcid="149" startline="1446"><![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakePointerType ();
 			}
 
 			return info;
 		}
]]></clone_fragment>
<clone_fragment endline="1417" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" hamdist="2" pcid="143" startline="1409"><![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakeByRefType ();
 			}
 
 			return info;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="70" nfragments="2">
<clone_fragment endline="204" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" hamdist="0" pcid="2955" startline="196"><![CDATA[
 
 		private void AddMethodSemantics(short semantics, int methodToken, int propertyToken)
 		{
 			MethodSemanticsTable.Record rec = new MethodSemanticsTable.Record();
 			rec.Semantics = semantics;
 			rec.Method = methodToken;
 			rec.Association = propertyToken;
 			typeBuilder.ModuleBuilder.MethodSemantics.AddRecord(rec);
 		}
]]></clone_fragment>
<clone_fragment endline="229" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" hamdist="0" pcid="4669" startline="221"><![CDATA[
 
 		private void AddMethodSemantics(short semantics, int methodToken, int propertyToken)
 		{
 			MethodSemanticsTable.Record rec = new MethodSemanticsTable.Record();
 			rec.Semantics = semantics;
 			rec.Method = methodToken;
 			rec.Association = propertyToken;
 			typeBuilder.ModuleBuilder.MethodSemantics.AddRecord(rec);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="71" nfragments="2">
<clone_fragment endline="654" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" hamdist="0" pcid="5921" startline="646"><![CDATA[
 
 		private void WriteToken(FieldToken token)
 		{
 			if (token.IsPseudoToken)
 			{
 				tokenFixups.Add(code.Position);
 			}
 			code.Write(token.Token);
 		}
]]></clone_fragment>
<clone_fragment endline="663" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" hamdist="3" pcid="5923" startline="655"><![CDATA[
 
 		private void WriteToken(MethodToken token)
 		{
 			if (token.IsPseudoToken)
 			{
 				tokenFixups.Add(code.Position);
 			}
 			code.Write(token.Token);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="72" nfragments="2">
<clone_fragment endline="926" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="0" pcid="7367" startline="918"><![CDATA[
 
     Public Shared Function GetGenericArguments(ByVal Method As Mono.Cecil.MethodReference) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim mR As Mono.Cecil.GenericInstanceMethod = TryCast(Method, Mono.Cecil.GenericInstanceMethod)
         If mR Is Nothing Then
             Return GetTypes(Method.GenericParameters)
         Else
             Return GetTypes(mR.GenericArguments)
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="917" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="8" pcid="7365" startline="909"><![CDATA[
 
     Public Shared Function GetGenericArguments(ByVal Type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim tR As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         If tR Is Nothing Then
             Return GetTypes(Type.GenericParameters)
         Else
             Return GetTypes(tR.GenericArguments)
         End If
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="73" nfragments="2">
<clone_fragment endline="992" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="0" pcid="9689" startline="984"><![CDATA[
 
     Function FindTypeWithFullname(ByVal Fullname As String) As TypeDeclaration
         For i As Integer = 0 To m_Members.Count - 1
             Dim tD As TypeDeclaration = TryCast(m_Members(i), TypeDeclaration)
             If tD Is Nothing Then Continue For
             If Helper.CompareName(tD.FullName, Fullname) Then Return tD
         Next
         Return Nothing
     End Function
]]></clone_fragment>
<clone_fragment endline="983" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="6" pcid="9687" startline="975"><![CDATA[
 
     Function FindTypeWithName(ByVal Name As String) As TypeDeclaration
         For i As Integer = 0 To m_Members.Count - 1
             Dim tD As TypeDeclaration = TryCast(m_Members(i), TypeDeclaration)
             If tD Is Nothing Then Continue For
             If Helper.CompareName(tD.Name, Name) Then Return tD
         Next
         Return Nothing
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="74" nfragments="2">
<clone_fragment endline="3633" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="0" pcid="3761" startline="3625"><![CDATA[
 
 		private static bool IsTypeUnsigned (TypeSpec type)
 		{
 			return type == TypeManager.uint64_type ||
 				type == TypeManager.uint32_type ||
 				type == TypeManager.ushort_type ||
 				type == TypeManager.byte_type ||
 				type == TypeManager.char_type;
 		}
]]></clone_fragment>
<clone_fragment endline="3624" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="7" pcid="3759" startline="3612"><![CDATA[
 
 		private static bool IsTypeIntegral (TypeSpec type)
 		{
 			return type == TypeManager.uint64_type ||
 				type == TypeManager.int64_type ||
 				type == TypeManager.uint32_type ||
 				type == TypeManager.int32_type ||
 				type == TypeManager.ushort_type ||
 				type == TypeManager.short_type ||
 				type == TypeManager.sbyte_type ||
 				type == TypeManager.byte_type ||
 				type == TypeManager.char_type;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="75" nfragments="2">
<clone_fragment endline="1477" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="0" pcid="4763" startline="1469"><![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				expr.CreateExpressionTree (ec),
 				new TypeOf (probe_type_expr, loc));
 
 			return CreateExpressionFactoryCall (ec, "TypeAs", args);
 		}
]]></clone_fragment>
<clone_fragment endline="1309" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="5" pcid="4751" startline="1301"><![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				expr.CreateExpressionTree (ec),
 				new TypeOf (probe_type_expr, loc));
 
 			return CreateExpressionFactoryCall (ec, "TypeIs", args);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="76" nfragments="2">
<clone_fragment endline="66" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" hamdist="0" pcid="6645" startline="58"><![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="67" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" hamdist="0" pcid="6681" startline="59"><![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="77" nfragments="2">
<clone_fragment endline="600" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" hamdist="0" pcid="675" startline="591"><![CDATA[
 
 		public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
 		{
 			attribs |= TypeAttributes.HasSecurity;
 			if (declarativeSecurity == null)
 			{
 				declarativeSecurity = new List<CustomAttributeBuilder>();
 			}
 			declarativeSecurity.Add(customBuilder);
 		}
]]></clone_fragment>
<clone_fragment endline="276" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" hamdist="9" pcid="3995" startline="267"><![CDATA[
 
 		public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
 		{
 			attributes |= MethodAttributes.HasSecurity;
 			if (declarativeSecurity == null)
 			{
 				declarativeSecurity = new List<CustomAttributeBuilder>();
 			}
 			declarativeSecurity.Add(customBuilder);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="78" nfragments="2">
<clone_fragment endline="923" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7595" startline="914"><![CDATA[
 
     Shared Function GetParameterTypes(ByVal Parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         Helper.Assert(Parameters IsNot Nothing)
         ReDim result(Parameters.Count - 1)
         For i As Integer = 0 To Parameters.Count - 1
             result(i) = Parameters(i).ParameterType
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="913" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="9" pcid="7593" startline="904"><![CDATA[
 
     Shared Function GetParameterTypes(ByVal Parameters As Mono.Cecil.ParameterReference()) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         Helper.Assert(Parameters IsNot Nothing)
         ReDim result(Parameters.Length - 1)
         For i As Integer = 0 To Parameters.GetUpperBound(0)
             result(i) = Parameters(i).ParameterType
         Next
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="79" nfragments="2">
<clone_fragment endline="133" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" hamdist="0" pcid="839" startline="124"><![CDATA[
 	
 		internal void Write(int value)
 		{
 			if (pos + 4 > buffer.Length)
 				Grow(4);
 			buffer[pos++] = (byte)value;
 			buffer[pos++] = (byte)(value >> 8);
 			buffer[pos++] = (byte)(value >> 16);
 			buffer[pos++] = (byte)(value >> 24);
 		}
]]></clone_fragment>
<clone_fragment endline="152" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" hamdist="5" pcid="841" startline="139"><![CDATA[
 
 		internal void Write(long value)
 		{
 			if (pos + 8 > buffer.Length)
 				Grow(8);
 			buffer[pos++] = (byte)value;
 			buffer[pos++] = (byte)(value >> 8);
 			buffer[pos++] = (byte)(value >> 16);
 			buffer[pos++] = (byte)(value >> 24);
 			buffer[pos++] = (byte)(value >> 32);
 			buffer[pos++] = (byte)(value >> 40);
 			buffer[pos++] = (byte)(value >> 48);
 			buffer[pos++] = (byte)(value >> 56);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="80" nfragments="2">
<clone_fragment endline="756" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" hamdist="0" pcid="2555" startline="747"><![CDATA[
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]></clone_fragment>
<clone_fragment endline="5480" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="0" pcid="1653" startline="5470"><![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="81" nfragments="2">
<clone_fragment endline="275" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" hamdist="0" pcid="6537" startline="266"><![CDATA[
 
     ReadOnly Property HasNamedArguments() As Boolean
         Get
             For Each argument As Argument In m_Arguments
                 If TypeOf argument Is NamedArgument Then
                     Return True
                 End If
             Next
             Return False
         End Get
]]></clone_fragment>
<clone_fragment endline="286" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" hamdist="6" pcid="6539" startline="276"><![CDATA[
     End Property
 
     ReadOnly Property HasPositionalArguments() As Boolean
         Get
             For Each argument As Argument In m_Arguments
                 If TypeOf argument Is PositionalArgument Then
                     Return True
                 End If
             Next
             Return False
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="82" nfragments="11">
<clone_fragment endline="340" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" hamdist="0" pcid="9891" startline="331"><![CDATA[
     ''' <summary>
     ''' GotoNewline defaults to false for this overload.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal ParamArray MessageParameters() As String) As Boolean
         Return AcceptIfNotError(Special, Message, False, MessageParameters)
     End Function
]]></clone_fragment>
<clone_fragment endline="432" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="8" pcid="7547" startline="420"><![CDATA[
 
     ''' <summary>
     ''' Compares two vb-names (case-insensitive)
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareName(ByVal Value1 As String, ByVal Value2 As String) As Boolean
         Helper.Assert(Value1 IsNot Nothing)
         Helper.Assert(Value2 IsNot Nothing)
         Return String.Equals(Value1, Value2, StringComparison.OrdinalIgnoreCase)
     End Function
]]></clone_fragment>
<clone_fragment endline="464" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="2" pcid="7551" startline="452"><![CDATA[
 
     ''' <summary>
     ''' Compares two strings.
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareNameOrdinal(ByVal Value1 As String, ByVal Value2 As String) As Boolean
         Helper.Assert(Value1 IsNot Nothing)
         Helper.Assert(Value2 IsNot Nothing)
         Return String.Equals(Value1, Value2, System.StringComparison.Ordinal)
     End Function
]]></clone_fragment>
<clone_fragment endline="71" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeDictionary.vb" hamdist="11" pcid="8213" startline="56"><![CDATA[
 
     ''' <summary>
     ''' Returns nothing if the specified key is not found.
     ''' </summary>
     ''' <param name="key"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal key As String) As Mono.Cecil.TypeReference
         Get
             If MyBase.ContainsKey(key) Then
                 Return MyBase.Item(key)
             Else
                 Return Nothing
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="350" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Token.vb" hamdist="10" pcid="9613" startline="336"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Compares this token to any of the specified tokens. 
     ''' Returns true if any token matches.
     ''' </summary>
     ''' <param name="AnySpecial"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Overloads Function Equals(ByVal AnySpecial() As KS) As Boolean
         For i As Integer = 0 To VB.UBound(AnySpecial)
             If Equals(AnySpecial(i)) = True Then Return True
         Next
         Return False
     End Function
]]></clone_fragment>
<clone_fragment endline="72" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" hamdist="12" pcid="8545" startline="61"><![CDATA[
 
     ''' <summary>
     ''' Returns nothing if it is not a handles clause.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property HandlesClause() As HandlesClause
         Get
             Helper.Assert(m_Clause IsNot Nothing)
             Return TryCast(m_Clause, HandlesClause)
         End Get
]]></clone_fragment>
<clone_fragment endline="81" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Namespaces.vb" hamdist="9" pcid="7985" startline="63"><![CDATA[
 
     ''' <summary>
     ''' Looks up the specified child of the namespace.
     ''' Returns nothing if nothing is found.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Child"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Overloads ReadOnly Property Item(ByVal Parent As [Namespace], ByVal Child As String) As [Namespace]
         Get
             Dim name As String = Parent.Name & "." & Child
             If ContainsKey(name) Then
                 Return Item(name)
             Else
                 Return Nothing
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="85" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\HandlesOrImplements.vb" hamdist="10" pcid="8547" startline="73"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if it is not an implements clause.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ImplementsClause() As MemberImplementsClause
         Get
             helper.Assert(m_clause IsNot Nothing)
             Return TryCast(m_Clause, MemberImplementsClause)
         End Get
]]></clone_fragment>
<clone_fragment endline="62" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\NamespaceDictionary.vb" hamdist="9" pcid="7977" startline="47"><![CDATA[
 
     ''' <summary>
     ''' Never returns nothing.
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal [Namespace] As String) As TypeDictionary
         Get
             If MyBase.ContainsKey([Namespace]) Then
                 Return MyBase.Item([Namespace])
             Else
                 Return TypeDictionary.EmptyDictionary
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="347" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="10" pcid="8907" startline="316"><![CDATA[
 
     ''' <summary>
     ''' ImportsAliasClause  
     '''	Identifier  =  QualifiedIdentifier  |
     '''	Identifier  =  ConstructedTypeName
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     ''' 
     ''' This overload is used when parsing commandline imports.
     ''' </summary>
     ''' <param name="str"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsAliasClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsAliasClause
         Dim result As New ImportsAliasClause(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_Second As ImportsNamespaceClause = Nothing
 
         Dim values() As String = str.Split("="c)
         If values.Length <> 2 Then Return Nothing
 
         m_Identifier = New Identifier(result, values(0), Span.CommandLineSpan, TypeCharacters.Characters.None)
 
         m_Second = ParseImportsNamespaceClause(result, values(1))
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
 
         result.Init(m_Identifier, m_Second)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="397" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="3" pcid="8911" startline="376"><![CDATA[
 
     ''' <summary>
     ''' ImportsNamespaceClause  
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     '''    
     ''' Only namespaces, classes, structures, enumerated types, and standard modules may be imported.
     ''' This overload is used when parsing commandline imports.
     ''' </summary>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsNamespaceClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsNamespaceClause
         Dim result As New ImportsNamespaceClause(Parent)
 
         Dim qi As QualifiedIdentifier = Nothing
         qi = ParseQualifiedIdentifier(result, str)
         If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
 
         result.Init(qi)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="83" nfragments="28">
<clone_fragment endline="88" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" hamdist="0" pcid="5425" startline="79"><![CDATA[
 
 		internal Assembly ToAssembly()
 		{
 			if (imported)
 			{
 				throw new InvalidOperationException();
 			}
 			imported = true;
 			return module.Assembly;
 		}
]]></clone_fragment>
<clone_fragment endline="91" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="10" pcid="865" startline="80"><![CDATA[
 
 		internal int ReadBlobIndex()
 		{
 			if (bigBlobs)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="79" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="6" pcid="863" startline="68"><![CDATA[
 
 		internal int ReadGuidIndex()
 		{
 			if (bigGuids)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="469" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="3" pcid="897" startline="458"><![CDATA[
 
 		internal int ReadMethodDef()
 		{
 			if (bigMethodDef)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="493" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="4" pcid="901" startline="482"><![CDATA[
 
 		internal int ReadProperty()
 		{
 			if (bigProperty)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="67" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="10" pcid="861" startline="56"><![CDATA[
 
 		internal int ReadStringIndex()
 		{
 			if (bigStrings)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="457" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="8" pcid="895" startline="446"><![CDATA[
 
 		internal int ReadField()
 		{
 			if (bigField)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="505" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="4" pcid="903" startline="494"><![CDATA[
 
 		internal int ReadEvent()
 		{
 			if (bigEvent)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="481" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="5" pcid="899" startline="470"><![CDATA[
 
 		internal int ReadParam()
 		{
 			if (bigParam)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1464" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="10" pcid="613" startline="1450"><![CDATA[
 		}
 
 		internal virtual Type BindTypeParameters(IGenericBinder binder)
 		{
 			if (IsGenericTypeDefinition)
 			{
 				Type[] args = GetGenericArguments();
 				Type.InplaceBindTypeParameters(binder, args);
 				return GenericTypeInstance.Make(this, args, null, null);
 			}
 			else
 			{
 				return this;
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="161" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="16" pcid="477" startline="150"><![CDATA[
 
 		internal void WriteStringIndex(int index)
 		{
 			if (bigStrings)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="210" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" hamdist="11" pcid="2975" startline="199"><![CDATA[
 
 		internal override Type GetGenericMethodArgument(int index)
 		{
 			if (methodArgs == null)
 			{
 				return method.GetGenericMethodArgument(index);
 			}
 			else
 			{
 				return methodArgs[index];
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="310" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="11" pcid="497" startline="299"><![CDATA[
 
 		internal void WriteTypeDef(int index)
 		{
 			if (bigTypeDef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="274" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="5" pcid="491" startline="263"><![CDATA[
 
 		internal void WriteField(int index)
 		{
 			if (bigField)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="686" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" hamdist="9" pcid="4017" startline="670"><![CDATA[
 		}
 
 		internal override int ImportTo(ModuleBuilder other)
 		{
 			if (typeBuilder.IsGenericTypeDefinition)
 			{
 				return other.ImportMember(TypeBuilder.GetMethod(typeBuilder, this));
 			}
 			else if (other == typeBuilder.ModuleBuilder)
 			{
 				return pseudoToken;
 			}
 			else
 			{
 				return other.ImportMethodOrField(typeBuilder, name, this.MethodSignature);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="432" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" hamdist="12" pcid="5635" startline="421"><![CDATA[
 		}
 
 		public IList<CustomAttributeTypedArgument> ConstructorArguments
 		{
 			get
 			{
 				if (lazyConstructorArguments == null)
 				{
 					LazyParseArguments();
 				}
 				return lazyConstructorArguments;
 			}
]]></clone_fragment>
<clone_fragment endline="185" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="12" pcid="481" startline="174"><![CDATA[
 
 		internal void WriteBlobIndex(int index)
 		{
 			if (bigBlobs)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="182" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" hamdist="13" pcid="6231" startline="166"><![CDATA[
 		}
 
 		internal override int ImportTo(ModuleBuilder other)
 		{
 			if (typeBuilder.IsGenericTypeDefinition)
 			{
 				return other.ImportMember(TypeBuilder.GetField(typeBuilder, this));
 			}
 			else if (other == typeBuilder.ModuleBuilder)
 			{
 				return pseudoToken;
 			}
 			else
 			{
 				return other.ImportMethodOrField(typeBuilder, name, fieldSig);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="77" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" hamdist="12" pcid="2615" startline="63"><![CDATA[
 		}
 
 		internal uint ImportAddressTableLength
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 				{
 					return 8;
 				}
 				else
 				{
 					return 16;
 				}
 			}
]]></clone_fragment>
<clone_fragment endline="173" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="14" pcid="479" startline="162"><![CDATA[
 
 		internal void WriteGuidIndex(int index)
 		{
 			if (bigGuids)
 			{
 				Write(index);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="358" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="9" pcid="505" startline="347"><![CDATA[
 
 		internal void WriteModuleRef(int index)
 		{
 			if (bigModuleRef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="490" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" hamdist="17" pcid="5791" startline="478"><![CDATA[
 		}
 
 		internal CustomAttributeBuilder DecodeBlob(Assembly asm)
 		{
 			if (blob == null)
 			{
 				return this;
 			}
 			else
 			{
 				return ToData(asm).__ToBuilder();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="286" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="13" pcid="493" startline="275"><![CDATA[
 
 		internal void WriteMethodDef(int index)
 		{
 			if (bigMethodDef)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="334" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="6" pcid="501" startline="323"><![CDATA[
 
 		internal void WriteProperty(int index)
 		{
 			if (bigProperty)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="298" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="8" pcid="495" startline="287"><![CDATA[
 
 		internal void WriteParam(int index)
 		{
 			if (bigParam)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="322" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="6" pcid="499" startline="311"><![CDATA[
 
 		internal void WriteEvent(int index)
 		{
 			if (bigEvent)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="346" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="10" pcid="503" startline="335"><![CDATA[
 
 		internal void WriteGenericParam(int index)
 		{
 			if (bigGenericParam)
 			{
 				Write(index & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)index);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="225" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="8" pcid="485" startline="214"><![CDATA[
 
 		internal void WriteEncodedTypeDefOrRef(int encodedToken)
 		{
 			if (bigTypeDefOrRef)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="84" nfragments="2">
<clone_fragment endline="2002" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="0" pcid="5515" startline="1993"><![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				Error_ConditionalAttributeIsNotValid ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]></clone_fragment>
<clone_fragment endline="2345" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="0" pcid="5523" startline="2336"><![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				Error_ConditionalAttributeIsNotValid ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="85" nfragments="2">
<clone_fragment endline="61" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" hamdist="0" pcid="929" startline="52"><![CDATA[
 
 		public override string ToString()
 		{
 			string str = name.ToString();
 			if (culture != null)
 			{
 				str = str.Replace("Culture=neutral", "Culture=" + culture);
 			}
 			return str;
 		}
]]></clone_fragment>
<clone_fragment endline="160" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" hamdist="4" pcid="931" startline="148"><![CDATA[
 		}
 
 		public string FullName
 		{
 			get
 			{
 				string str = name.FullName;
 				if (culture != null)
 				{
 					str = str.Replace("Culture=neutral", "Culture=" + culture);
 				}
 				return str;
 			}
]]></clone_fragment>
</clone_group>
<clone_group groupid="86" nfragments="3">
<clone_fragment endline="1988" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="0" pcid="1507" startline="1979"><![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(16)
 				.WriteBlobIndex()
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.Value;
 		}
]]></clone_fragment>
<clone_fragment endline="2159" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="5" pcid="1527" startline="2150"><![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteImplementation()
 				.Value;
 		}
]]></clone_fragment>
<clone_fragment endline="574" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="12" pcid="1361" startline="563"><![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteTypeDefOrRef()
 				.WriteField()
 				.WriteMethodDef()
 				.Value;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="87" nfragments="2">
<clone_fragment endline="452" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" hamdist="0" pcid="2991" startline="443"><![CDATA[
 		}
 
 		private MethodInfo Wrap(MethodInfo method)
 		{
 			if (method == null)
 			{
 				return null;
 			}
 			return new GenericMethodInstance(typeInstance, method, null);
 		}
]]></clone_fragment>
<clone_fragment endline="559" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" hamdist="0" pcid="2997" startline="550"><![CDATA[
 		}
 
 		private MethodInfo Wrap(MethodInfo method)
 		{
 			if (method == null)
 			{
 				return null;
 			}
 			return new GenericMethodInstance(typeInstance, method, null);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="88" nfragments="4">
<clone_fragment endline="134" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" hamdist="0" pcid="8743" startline="125"><![CDATA[
     End Property
 
     Public ReadOnly Property GetMethod() As Mono.Cecil.MethodDefinition
         Get
             If m_Get IsNot Nothing Then
                 Return m_Get.CecilBuilder
             Else
                 Return Nothing
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="102" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" hamdist="9" pcid="8485" startline="93"><![CDATA[
     End Property
 
     ReadOnly Property RaiseDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_RaiseMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_RaiseMethod.CecilBuilder
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="92" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" hamdist="5" pcid="8483" startline="83"><![CDATA[
     End Property
 
     ReadOnly Property RemoveDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_RemoveMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_RemoveMethod.CecilBuilder
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="82" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\EventDeclaration.vb" hamdist="8" pcid="8481" startline="73"><![CDATA[
     End Property
 
     ReadOnly Property AddDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_AddMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_AddMethod.CecilBuilder
             End If
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="89" nfragments="2">
<clone_fragment endline="71" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" hamdist="0" pcid="8801" startline="62"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As ParameterList)
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         If Parameters Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = Parameters
         End If
     End Sub
]]></clone_fragment>
<clone_fragment endline="81" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubSignature.vb" hamdist="11" pcid="8803" startline="72"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As Mono.Cecil.TypeReference())
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         If Parameters Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = New ParameterList(Me, Parameters)
         End If
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="90" nfragments="2">
<clone_fragment endline="320" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" hamdist="0" pcid="8719" startline="311"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.CustomAttributes IsNot Nothing Then
             result = Me.CustomAttributes.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="54" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LoadFieldExpression.vb" hamdist="10" pcid="7153" startline="44"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.Classification IsNot Nothing Then
             Me.Classification = New ValueClassification(Me, m_Field.FieldType)
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="91" nfragments="2">
<clone_fragment endline="71" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ParemeterIdentifier.vb" hamdist="0" pcid="8737" startline="62"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As Parameter = Nothing) As ParameterIdentifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterIdentifier(NewParent)
         result.m_Identifier = m_Identifier
         If m_ArrayNameModifier IsNot Nothing Then
             result.m_ArrayNameModifier = m_ArrayNameModifier.clone(result)
         End If
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="74" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" hamdist="6" pcid="7219" startline="62"><![CDATA[
     End Property
 
     Public Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Expression
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New SimpleNameExpression(NewParent)
         If m_TypeArgumentList Is Nothing Then
             result.Init(m_Identifier, Nothing)
         Else
             result.Init(m_Identifier, m_TypeArgumentList.Clone(result))
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="92" nfragments="3">
<clone_fragment endline="164" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" hamdist="0" pcid="7283" startline="155"><![CDATA[
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="174" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" hamdist="8" pcid="7285" startline="165"><![CDATA[
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="186" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" hamdist="6" pcid="7287" startline="175"><![CDATA[
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="93" nfragments="2">
<clone_fragment endline="71" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" hamdist="0" pcid="8677" startline="62"><![CDATA[
 
     ''' <summary>
     ''' Adds a modifier to the list if the modifier isn't there already.
     ''' </summary>
     ''' <param name="Modifier"></param>
     ''' <remarks></remarks>
     Public Function AddModifiers(ByVal Modifier As ModifierMasks) As Modifiers
         m_ModifierMask = m_ModifierMask Or Modifier
         Return Me
     End Function
]]></clone_fragment>
<clone_fragment endline="61" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" hamdist="8" pcid="8675" startline="51"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Adds a modifier to the list if the modifier isn't there already.
     ''' </summary>
     ''' <param name="Modifier"></param>
     ''' <remarks></remarks>
     Public Function AddModifier(ByVal Modifier As KS) As Modifiers
         m_ModifierMask = m_ModifierMask Or KSToMask(Modifier)
         Return Me
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="94" nfragments="3">
<clone_fragment endline="219" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" hamdist="0" pcid="9423" startline="210"><![CDATA[
 
     Private Function EmitStoreCounterInstanceExpression(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
 
         If Data.InstanceExpression IsNot Nothing Then
             result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="209" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" hamdist="9" pcid="9421" startline="192"><![CDATA[
 
     Private Function EmitLoadCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 If Data.InstanceExpression IsNot Nothing Then
                     result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
                 End If
                 Emitter.EmitLoadVariable(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitLoadVariable(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="191" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" hamdist="3" pcid="9419" startline="174"><![CDATA[
 
     Private Function EmitLoadAddressCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 If Data.InstanceExpression IsNot Nothing Then
                     result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
                 End If
                 Emitter.EmitLoadVariableLocation(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitLoadVariableLocation(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="95" nfragments="4">
<clone_fragment endline="118" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Message.vb" hamdist="0" pcid="7891" startline="109"><![CDATA[
 
     ''' <summary>
     ''' Create a new message with the specified data.
     ''' </summary>
     Sub New(ByVal Compiler As Compiler, ByVal Message As Messages(), ByVal Parameters()() As String, ByVal Location As Span)
         Me.m_Compiler = Compiler
         Me.m_Message = Message
         Me.m_Location = Location
         Me.m_Parameters = Parameters
     End Sub
]]></clone_fragment>
<clone_fragment endline="94" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Define.vb" hamdist="9" pcid="7507" startline="83"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Create a new define with the specified values.
     ''' </summary>
     Sub New(ByVal Compiler As Compiler, ByVal Symbol As String, ByVal Value As String)
         Me.m_Symbol = Symbol
         Me.m_Value = Value
         Me.m_Compiler = Compiler
 
         Parse()
     End Sub
]]></clone_fragment>
<clone_fragment endline="108" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Message.vb" hamdist="9" pcid="7889" startline="96"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Create a new message with the specified data.
     ''' </summary>
     ''' <param name="Message"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler, ByVal Message As Messages, ByVal Location As Span)
         Me.m_Compiler = Compiler
         Me.m_Message = New Messages() {Message}
         Me.m_Location = Location
         Me.m_Parameters = New String()() {}
     End Sub
]]></clone_fragment>
<clone_fragment endline="132" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Message.vb" hamdist="7" pcid="7893" startline="119"><![CDATA[
 
     ''' <summary>
     ''' Create a new message with the specified data.
     ''' </summary>
     Sub New(ByVal Compiler As Compiler, ByVal Message As Messages, ByVal Parameters() As String, ByVal Location As Span)
         Me.m_Compiler = Compiler
         Me.m_Message = New Messages() {Message}
         Me.m_Location = Location
         If Parameters Is Nothing Then
             Me.m_Parameters = New String()() {New String() {}}
         Else
             Me.m_Parameters = New String()() {Parameters}
         End If
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="96" nfragments="2">
<clone_fragment endline="41" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Argument.vb" hamdist="0" pcid="6509" startline="32"><![CDATA[
     End Property
 
     Overridable ReadOnly Property AsString() As String
         Get
             If m_Expression Is Nothing Then
                 Return "Nothing"
             Else
                 Return m_Expression.AsString
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="162" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" hamdist="9" pcid="6827" startline="153"><![CDATA[
     End Property
 
     ReadOnly Property LocalBuilder() As Mono.Cecil.Cil.VariableDefinition
         Get
             If m_LocalVariable IsNot Nothing Then
                 Return m_LocalVariable.LocalBuilder
             Else
                 Return Nothing
             End If
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="97" nfragments="3">
<clone_fragment endline="835" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="0" pcid="6393" startline="826"><![CDATA[
 
     ''' <summary>
     ''' Loads Me onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadMe(ByVal Info As EmitInfo, ByVal TypeOfMe As Mono.Cecil.TypeReference)
         TypeOfMe = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeOfMe)
         Info.ILGen.Emit(OpCodes.Ldarg_0)
     End Sub
]]></clone_fragment>
<clone_fragment endline="1514" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="8" pcid="6443" startline="1505"><![CDATA[
 
     ''' <summary>
     ''' Load a constant decimal value on to the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="decimalValue"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadDecimalValue(ByVal Info As EmitInfo, ByVal decimalValue As Decimal)
         EmitLoadDecimalValue(Info, New DecimalFields(decimalValue))
     End Sub
]]></clone_fragment>
<clone_fragment endline="1353" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="7" pcid="6433" startline="1340"><![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadValueAddress(ByVal Info As EmitInfo, ByVal Value As Object)
         Helper.Assert(CecilHelper.IsByRef(Info.DesiredType))
         EmitLoadValue(Info.Clone(Info.Context, CecilHelper.GetElementType(Info.DesiredType)), Value)
         Dim local As Mono.Cecil.Cil.VariableDefinition = DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Info.Compiler, CecilHelper.GetElementType(Info.DesiredType)))
         EmitStoreVariable(Info, local)
         EmitLoadVariableLocation(Info, local)
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="98" nfragments="2">
<clone_fragment endline="1227" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="0" pcid="7401" startline="1218"><![CDATA[
 
     Public Shared Function GetField(ByVal collection As ICollection, ByVal reference As FieldReference) As FieldDefinition
         For Each field As FieldDefinition In collection
             If Not Helper.CompareNameOrdinal(field.Name, reference.Name) Then
                 Continue For
             End If
             Return field
         Next
         Return Nothing
     End Function
]]></clone_fragment>
<clone_fragment endline="1292" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="8" pcid="7409" startline="1283"><![CDATA[
 
     Public Shared Function GetEvent(ByVal collection As ICollection, ByVal reference As EventReference) As EventDefinition
         For Each meth As EventDefinition In collection
             If Helper.CompareNameOrdinal(meth.Name, reference.Name) = False Then
                 Continue For
             End If
             Return meth
         Next
         Return Nothing
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="99" nfragments="3">
<clone_fragment endline="1184" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="0" pcid="8099" startline="1174"><![CDATA[
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="1236" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="5" pcid="8107" startline="1226"><![CDATA[
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="1210" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="7" pcid="8103" startline="1200"><![CDATA[
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="100" nfragments="21">
<clone_fragment endline="38" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceSubDeclaration.vb" hamdist="0" pcid="8565" startline="31"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Sub)
     End Function
]]></clone_fragment>
<clone_fragment endline="52" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" hamdist="6" pcid="8767" startline="45"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Event)
     End Function
]]></clone_fragment>
<clone_fragment endline="79" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" hamdist="2" pcid="9741" startline="72"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Interface)
     End Function
]]></clone_fragment>
<clone_fragment endline="42" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularPropertyDeclaration.vb" hamdist="3" pcid="8783" startline="35"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.PropertyModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.PropertyModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]></clone_fragment>
<clone_fragment endline="100" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" hamdist="2" pcid="9731" startline="93"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Enum)
     End Function
]]></clone_fragment>
<clone_fragment endline="52" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionDeclaration.vb" hamdist="7" pcid="8527" startline="45"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Function
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceFunctionDeclaration.vb" hamdist="4" pcid="8555" startline="36"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Function)
     End Function
]]></clone_fragment>
<clone_fragment endline="82" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyGetDeclaration.vb" hamdist="6" pcid="8761" startline="75"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Get
     End Function
]]></clone_fragment>
<clone_fragment endline="548" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" hamdist="8" pcid="9713" startline="541"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ClassModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ClassModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Class)
     End Function
]]></clone_fragment>
<clone_fragment endline="48" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" hamdist="11" pcid="8455" startline="41"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals("Custom") AndAlso tm.PeekToken(i + 1).Equals(KS.Event)
     End Function
]]></clone_fragment>
<clone_fragment endline="40" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfacePropertyMemberDeclaration.vb" hamdist="10" pcid="8563" startline="33"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfacePropertyModifier)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfacePropertyModifier)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]></clone_fragment>
<clone_fragment endline="39" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MustOverridePropertyDeclaration.vb" hamdist="2" pcid="8685" startline="32"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverridePropertyModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverridePropertyModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]></clone_fragment>
<clone_fragment endline="190" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" hamdist="6" pcid="9719" startline="183"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Delegate)
     End Function
]]></clone_fragment>
<clone_fragment endline="82" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ModuleDeclaration.vb" hamdist="0" pcid="9749" startline="75"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Module)
     End Function
]]></clone_fragment>
<clone_fragment endline="51" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" hamdist="4" pcid="9763" startline="44"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.StructureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.StructureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Structure)
     End Function
]]></clone_fragment>
<clone_fragment endline="38" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\InterfaceEventMemberDeclaration.vb" hamdist="4" pcid="8553" startline="31"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceEventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceEventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Event)
     End Function
]]></clone_fragment>
<clone_fragment endline="118" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" hamdist="4" pcid="8765" startline="111"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]></clone_fragment>
<clone_fragment endline="153" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\SubDeclaration.vb" hamdist="9" pcid="8797" startline="145"><![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Sub AndAlso tm.PeekToken(i + 1).IsIdentifier
     End Function
]]></clone_fragment>
<clone_fragment endline="378" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" hamdist="8" pcid="8445" startline="370"><![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConstructorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConstructorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Sub) = False Then Return False
         Return tm.PeekToken(i + 1).Equals(KS.[New])
     End Function
]]></clone_fragment>
<clone_fragment endline="87" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" hamdist="6" pcid="8453" startline="79"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConversionOperatorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConversionOperatorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Operator) = False Then Return False
         Return IsOverloadableConversionOperator(tm.PeekToken(i + 1))
     End Function
]]></clone_fragment>
<clone_fragment endline="52" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" hamdist="14" pcid="8515" startline="43"><![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         If tm.PeekToken(i) <> KS.Declare Then Return False
         If tm.PeekToken(i + 1).Equals(ModifierMasks.CharSetModifiers) Then i += 1
         Return tm.PeekToken(i + 1) = KS.Function
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="101" nfragments="2">
<clone_fragment endline="3668" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7805" startline="3658"><![CDATA[
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal Caller As Mono.Cecil.TypeReference, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Constructor, MemberTypes.Method
                 Return IsAccessible(Context, Caller, DirectCast(Member, Mono.Cecil.MethodReference))
             Case MemberTypes.Property
                 Return IsAccessible(Context, Caller, DirectCast(Member, Mono.Cecil.PropertyReference))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="3551" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="9" pcid="7793" startline="3541"><![CDATA[
 
     Shared Function GetMethodAttributes(ByVal Member As Mono.Cecil.MemberReference) As Mono.Cecil.MethodAttributes
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Method, MemberTypes.Constructor
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).Attributes
             Case MemberTypes.Property
                 Return GetPropertyAttributes(DirectCast(Member, Mono.Cecil.PropertyReference))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="102" nfragments="3">
<clone_fragment endline="1243" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="0" pcid="4335" startline="1233"><![CDATA[
 
 		protected override bool ResolveNamedArguments (ResolveContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveNamedArguments (ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1232" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="7" pcid="4333" startline="1222"><![CDATA[
 
 		protected override MethodSpec ResolveConstructor (ResolveContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveConstructor (ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1221" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="7" pcid="4331" startline="1211"><![CDATA[
 
 		protected override TypeExpr ResolveAsTypeTerminal (Expression expr, IMemberContext ec)
 		{
 			try {
 				Enter ();
 				return base.ResolveAsTypeTerminal (expr, ec);
 			}
 			finally {
 				Leave ();
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="103" nfragments="4">
<clone_fragment endline="557" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" hamdist="0" pcid="5741" startline="547"><![CDATA[
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			binder_args.Add (new Argument (new BinderFlags (0, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			return new Invocation (GetBinder ("InvokeConstructor", loc), binder_args);
 		}
]]></clone_fragment>
<clone_fragment endline="536" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" hamdist="7" pcid="5737" startline="525"><![CDATA[
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			flags |= ec.HasSet (ResolveContext.Options.CheckedScope) ? CSharpBinderFlags.CheckedContext 
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			return new Invocation (GetBinder ("Convert", loc), binder_args);
 		}
]]></clone_fragment>
<clone_fragment endline="591" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" hamdist="14" pcid="5753" startline="580"><![CDATA[
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetIndex" 
 		}
]]></clone_fragment>
<clone_fragment endline="735" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" hamdist="3" pcid="5767" startline="723"><![CDATA[
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (4);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new StringLiteral (name, loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetMember" 
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="104" nfragments="2">
<clone_fragment endline="365" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="0" pcid="8049" startline="355"><![CDATA[
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]></clone_fragment>
<clone_fragment endline="424" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="4" pcid="8053" startline="414"><![CDATA[
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="105" nfragments="2">
<clone_fragment endline="669" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" hamdist="0" pcid="4015" startline="659"><![CDATA[
 
 		internal override MethodSignature MethodSignature
 		{
 			get
 			{
 				if (methodSignature == null)
 				{
 					methodSignature = MethodSignature.MakeFromBuilder(returnType, parameterTypes, modifiers, callingConvention, gtpb == null ? 0 
 				}
 				return methodSignature;
 			}
]]></clone_fragment>
<clone_fragment endline="1330" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" hamdist="7" pcid="5377" startline="1319"><![CDATA[
 		}
 
 		internal override MethodSignature MethodSignature
 		{
 			get
 			{
 				if (methodSignature == null)
 				{
 					methodSignature = MethodSignature.MakeFromBuilder(returnType, parameterTypes, null, callingConvention, 0);
 				}
 				return methodSignature;
 			}
]]></clone_fragment>
</clone_group>
<clone_group groupid="106" nfragments="3">
<clone_fragment endline="1911" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="0" pcid="6481" startline="1901"><![CDATA[
 
     ''' <summary>
     ''' Emits a box instruction, no checks are done.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitBox(ByVal Info As EmitInfo, ByVal SourceType As Mono.Cecil.TypeReference)
         Dim OriginalDestinationType As Mono.Cecil.TypeReference = SourceType
         SourceType = Helper.GetTypeOrTypeBuilder(Info.Compiler, SourceType)
         Info.ILGen.Emit(OpCodes.Box, SourceType)
     End Sub
]]></clone_fragment>
<clone_fragment endline="357" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="11" pcid="6383" startline="345"><![CDATA[
 
     ''' <summary>
     ''' Emit a newobj.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Constructor"></param>
     ''' <remarks></remarks>
     Shared Sub EmitNew(ByVal Info As EmitInfo, ByVal Constructor As Mono.Cecil.MethodReference)
         Dim vOriginalConstructor As Mono.Cecil.MethodReference = Constructor
         Helper.Assert(Constructor IsNot Nothing)
         Constructor = CecilHelper.MakeEmittable(Constructor)
         Info.ILGen.Emit(OpCodes.Newobj, Constructor)
     End Sub
]]></clone_fragment>
<clone_fragment endline="1070" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="11" pcid="6413" startline="1060"><![CDATA[
 
     ''' <summary>
     ''' Emits a Ldobj instruction.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadObject(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Ldobj, ElementType)
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="107" nfragments="2">
<clone_fragment endline="147" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" hamdist="0" pcid="7471" startline="137"><![CDATA[
 
     Public Sub VerifyConsistency(ByVal result As Boolean, ByVal Location As Span)
         If Report.Errors = 0 AndAlso result = False Then
             Report.WriteLine(vbnc.Report.ReportLevels.Debug, Location.AsString(Compiler) & " No errors, but compilation failed? ")
             Helper.StopIfDebugging()
             Throw New InternalException("Consistency check failed")
         ElseIf Report.Errors > 0 AndAlso result Then
             'Report.WriteLine(vbnc.Report.ReportLevels.Debug, Report.Errors.ToString & " errors, but compilation succeeded? " & Location)
             'Throw New InternalException("Consistency check failed")
         End If
     End Sub
]]></clone_fragment>
<clone_fragment endline="136" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" hamdist="7" pcid="7469" startline="124"><![CDATA[
     End Property
 
     Public Sub VerifyConsistency(ByVal result As Boolean, ByVal where As String)
         'Console.WriteLine("Verifying consistency
         If Report.Errors = 0 AndAlso result = False Then
             Report.WriteLine(vbnc.Report.ReportLevels.Debug, where & "
             Helper.StopIfDebugging()
             Throw New InternalException("Consistency check failed")
         ElseIf Report.Errors > 0 AndAlso result Then
             'Report.WriteLine(vbnc.Report.ReportLevels.Debug, Report.Errors.ToString & " errors, but compilation succeeded? " & Location)
             'Throw New InternalException("Consistency check failed")
         End If
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="108" nfragments="2">
<clone_fragment endline="584" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" hamdist="0" pcid="6173" startline="574"><![CDATA[
 
 		internal int ImportMember(FieldInfo member)
 		{
 			int token;
 			if (!importedMembers.TryGetValue(member, out token))
 			{
 				token = member.ImportTo(this);
 				importedMembers.Add(member, token);
 			}
 			return token;
 		}
]]></clone_fragment>
<clone_fragment endline="573" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" hamdist="7" pcid="6171" startline="563"><![CDATA[
 
 		internal int ImportMember(MethodBase member)
 		{
 			int token;
 			if (!importedMembers.TryGetValue(member, out token))
 			{
 				token = member.ImportTo(this);
 				importedMembers.Add(member, token);
 			}
 			return token;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="109" nfragments="2">
<clone_fragment endline="989" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="0" pcid="419" startline="979"><![CDATA[
 		{
 			Expression e = Resolve (ec);
 			if (e == null)
 				return null;
 
 			ExpressionStatement es = e as ExpressionStatement;
 			if (es == null)
 				Error_InvalidExpressionStatement (ec);
 
 			return es;
 		}
]]></clone_fragment>
<clone_fragment endline="1246" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" hamdist="10" pcid="3811" startline="1227"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			unwrap = Unwrap.Create (expr, false);
 			if (unwrap == null)
 				return null;
 
 			underlying = (UnaryMutator) new UnaryMutator (Mode, unwrap, loc).Resolve (ec);
 			if (underlying == null)
 				return null;
 
 
 			eclass = ExprClass.Value;
 			type = expr.Type;
 			return this;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="110" nfragments="2">
<clone_fragment endline="280" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" hamdist="0" pcid="9883" startline="270"><![CDATA[
 
     ''' <summary>
     ''' If the current token is not the specified keyword / symbol, then a
     ''' InternalException is thrown. (In which case it doesn't return,
     ''' so this is not a function).
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <remarks></remarks>
     Sub AcceptIfNotInternalError(ByVal Special As KS)
         If Not Accept(Special) Then Throw New InternalException("Location
     End Sub
]]></clone_fragment>
<clone_fragment endline="406" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" hamdist="11" pcid="6837" startline="394"><![CDATA[
 
     ''' <summary>
     ''' A variable declaration which refers to the implicitly declared local variable
     ''' for methods with return values (functions and get properties)
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="method"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal method As IMethod)
         MyBase.New(Classifications.Variable, Parent)
         Helper.Assert(TypeOf method Is FunctionDeclaration OrElse TypeOf method Is PropertyGetDeclaration)
         m_Method = method
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="111" nfragments="3">
<clone_fragment endline="290" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" hamdist="0" pcid="6737" startline="280"><![CDATA[
 
     Private Sub SetMethods(ByVal lst As Generic.IList(Of Mono.Cecil.MethodReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]></clone_fragment>
<clone_fragment endline="279" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" hamdist="5" pcid="6735" startline="269"><![CDATA[
 
     Private Sub SetMethods(ByVal lst As Generic.IList(Of Mono.Cecil.MemberReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]></clone_fragment>
<clone_fragment endline="268" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" hamdist="7" pcid="6733" startline="257"><![CDATA[
     End Property
 
     Private Sub SetMethods(ByVal lst As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="112" nfragments="2">
<clone_fragment endline="61" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DeRefExpression.vb" hamdist="0" pcid="7029" startline="51"><![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
 
         Emitter.EmitLoadIndirect(Info, m_Expression.ExpressionType)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="43" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CachedExpression.vb" hamdist="8" pcid="6697" startline="30"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Local Is Nothing Then
             result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
             m_Local = Emitter.DeclareLocal(Info, m_Expression.ExpressionType)
             Emitter.EmitStoreVariable(Info, m_Local)
         End If
 
         Emitter.EmitLoadVariable(Info, m_Local)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="113" nfragments="3">
<clone_fragment endline="73" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObjects`1.vb" hamdist="0" pcid="7305" startline="63"><![CDATA[
 
     Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To Count - 1
             Dim pO As BaseObject = TryCast(CObj(Item(i)), BaseObject)
             If pO IsNot Nothing Then
                 result = pO.ResolveCode(Info) AndAlso result
             End If
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="169" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\ConversionExpression.vb" hamdist="11" pcid="6939" startline="151"><![CDATA[
 
     Protected Shared Function ValidateForNullable(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression, ByRef expTypeCode As TypeCode, ByRef expType As TypeReference) As Boolean
         Dim result As Boolean = True
         Dim ConversionMethod As MethodReference = Nothing
 
         expType = Conversion.Expression.ExpressionType
 
         If CecilHelper.IsNullable(expType) Then
             If SelectNarrowingConversionOperator(Info.Compiler, expType, Conversion.ExpressionType, ConversionMethod) = False Then
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Conversion.Expression.Location)
             End If
             expType = CecilHelper.GetNulledType(expType)
             Conversion.ConversionMethod = ConversionMethod
         End If
 
         expTypeCode = Helper.GetTypeCode(Info.Compiler, expType)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1158" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" hamdist="20" pcid="7461" startline="1137"><![CDATA[
 
     Private Function AddFile(ByVal File As String) As Boolean
         Dim result As Boolean = True
 
         Dim strFile As String
         Dim strFiles As String()
 
         strFiles = GetFullPaths(File)
 
         If strFiles Is Nothing OrElse strFiles.Length = 0 Then
             If IsPattern(File) = False Then
                 result = Compiler.Report.SaveMessage(Messages.VBNC2001, Span.CommandLineSpan, File) AndAlso result
             End If
             Return result
         End If
 
         For Each strFile In strFiles
             m_lstFileNames.Add(New CodeFile(strFile, System.IO.Path.GetDirectoryName(File), Me.Compiler))
         Next
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="114" nfragments="3">
<clone_fragment endline="60" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" hamdist="0" pcid="7835" startline="50"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Obj As IBaseObject)
         MyBase.new()
         If Obj IsNot Nothing Then
             m_Message = "There has been an internal error in the compiler caused by the line
         Else
             m_Message = "There has been an internal error in the compiler."
         End If
         StopOnInternalException()
     End Sub
]]></clone_fragment>
<clone_fragment endline="71" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" hamdist="6" pcid="7837" startline="61"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Obj As ExpressionClassification)
         MyBase.new()
         If Obj IsNot Nothing Then
             m_Message = "There has been an internal error in the compiler caused by the line
         Else
             m_Message = "There has been an internal error in the compiler."
         End If
         StopOnInternalException()
     End Sub
]]></clone_fragment>
<clone_fragment endline="49" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\InternalException.vb" hamdist="7" pcid="7833" startline="39"><![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Location As Span)
         MyBase.new()
         'If Location IsNot Nothing Then
         m_Message = "There has been an internal error in the compiler caused by the line
         'Else
         'm_Message = "There has been an internal error in the compiler."
         'End If
         StopOnInternalException()
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="115" nfragments="2">
<clone_fragment endline="635" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" hamdist="0" pcid="3027" startline="625"><![CDATA[
 
 	public static bool IsBuiltinType (TypeSpec t)
 	{
 		if (t == object_type || t == string_type || t == int32_type || t == uint32_type ||
 		    t == int64_type || t == uint64_type || t == float_type || t == double_type ||
 		    t == char_type || t == short_type || t == decimal_type || t == bool_type ||
 		    t == sbyte_type || t == byte_type || t == ushort_type || t == void_type)
 			return true;
 		else
 			return false;
 	}
]]></clone_fragment>
<clone_fragment endline="647" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" hamdist="7" pcid="3029" startline="636"><![CDATA[
 
 	//
 	// This is like IsBuiltinType, but lacks decimal_type, we should also clean up
 	// the pieces in the code where we use IsBuiltinType and special case decimal_type.
 	// 
 	public static bool IsPrimitiveType (TypeSpec t)
 	{
 		return (t == int32_type || t == uint32_type ||
 		    t == int64_type || t == uint64_type || t == float_type || t == double_type ||
 		    t == char_type || t == short_type || t == bool_type ||
 		    t == sbyte_type || t == byte_type || t == ushort_type);
 	}
]]></clone_fragment>
</clone_group>
<clone_group groupid="116" nfragments="2">
<clone_fragment endline="2322" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" hamdist="0" pcid="4171" startline="2315"><![CDATA[
 		}
 
 		public new void VerifyClsCompliance ()
 		{
 			foreach (TypeParameter tp in TypeParameters) {
 				tp.VerifyClsCompliance ();
 			}
 			foreach (TypeParameter tp in TypeParameters) {
 				tp.VerifyClsCompliance ();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1495" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" hamdist="8" pcid="2101" startline="1480"><![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			if (type_params != null) {
 				foreach (TypeParameter tp in type_params) {
 					tp.VerifyClsCompliance ();
 				}
 				foreach (TypeParameter tp in type_params) {
 					tp.VerifyClsCompliance ();
 				}
 			}
 
 			return true;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="117" nfragments="3">
<clone_fragment endline="1158" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="0" pcid="7391" startline="1148"><![CDATA[
 
     Public Shared Function FindProperties(ByVal properties As Mono.Collections.Generic.Collection(Of PropertyDefinition), ByVal name As String) As Mono.Collections.Generic.Collection(Of PropertyDefinition)
         Dim result As Mono.Collections.Generic.Collection(Of PropertyDefinition) = Nothing
         For i As Integer = 0 To properties.Count - 1
             If Helper.CompareNameOrdinal(properties(i).Name, name) Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of PropertyDefinition)
                 result.Add(properties(i))
             End If
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="871" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="11" pcid="7357" startline="860"><![CDATA[
 
     Public Shared Function GetAttributes(ByVal CustomAttributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal Type As TypeReference) As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim result As Mono.Collections.Generic.Collection(Of CustomAttribute) = Nothing
         For i As Integer = 0 To CustomAttributes.Count - 1
             Dim Attribute As CustomAttribute = CustomAttributes(i)
             If Helper.CompareType(Attribute.Constructor.DeclaringType, Type) Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of CustomAttribute)()
                 result.Add(Attribute)
             End If
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="844" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="4" pcid="7351" startline="831"><![CDATA[
 
     Public Shared Function GetCustomAttributes(ByVal Attributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal AttributeType As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim result As Mono.Collections.Generic.Collection(Of CustomAttribute) = Nothing
 
         For i As Integer = 0 To Attributes.Count - 1
             Dim attrib As CustomAttribute = Attributes(i)
             If Helper.CompareType(AttributeType, attrib.Constructor.DeclaringType) Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of CustomAttribute)()
                 result.Add(attrib)
             End If
         Next
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="118" nfragments="2">
<clone_fragment endline="490" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" hamdist="0" pcid="7875" startline="480"><![CDATA[
 
     ''' <summary>
     ''' Looks up the name in the flattened cache.
     ''' Looks case-insensitively
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupFlattened(ByVal Name As String, ByVal From As Mono.Cecil.TypeReference) As MemberCacheEntry
         Return LookupFlattened(Name, Helper.GetVisibility(Compiler, From, m_Type))
     End Function
]]></clone_fragment>
<clone_fragment endline="538" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" hamdist="9" pcid="7879" startline="522"><![CDATA[
 
     ''' <summary>
     ''' Looks up the name in the cache.
     ''' Looks case-insensitively
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function Lookup(ByVal Name As String, ByVal Visibility As MemberVisibility, ByVal PreventLoad As Boolean) As MemberCacheEntry
         Dim cache_insensitive As MemberCacheEntries = Nothing
         Dim result As MemberCacheEntry = Nothing
 
         If Not PreventLoad Then Load(Name, Visibility)
 
         m_CacheInsensitive(Visibility).TryGetValue(Name, result)
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="119" nfragments="6">
<clone_fragment endline="57" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\IdentifierOrKeywordWithTypeArguments.vb" hamdist="0" pcid="9555" startline="47"><![CDATA[
 
     Shadows Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As IdentifierOrKeywordWithTypeArguments
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New IdentifierOrKeywordWithTypeArguments(NewParent)
         If m_TypeArguments IsNot Nothing Then
             result.Init(Me.Identifier, Me.Keyword, m_TypeArguments.Clone(result))
         Else
             result.Init(Me.Identifier, Me.Keyword, Nothing)
         End If
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="57" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" hamdist="8" pcid="9849" startline="45"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SimpleTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New SimpleTypeName(NewParent)
         If Me.IsBuiltInTypeName Then
             result.Init(Me.AsBuiltInTypeName.Clone(result))
         ElseIf Me.IsQualifiedIdentifier Then
             result.Init(Me.AsQualifiedIdentifier.Clone(result))
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="62" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayNameModifier.vb" hamdist="9" pcid="8319" startline="50"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ArrayNameModifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ArrayNameModifier(NewParent)
         If Me.IsArrayTypeModifiers Then
             result.Init(Me.AsArrayTypeModifiers.Clone(result))
         ElseIf Me.IsArraySizeInitializationModifier Then
             result.Init(Me.AsArraySizeInitializationModifier.Clone(result))
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="75" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeName.vb" hamdist="7" pcid="9927" startline="63"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As TypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New TypeName(NewParent)
         If Me.IsNonArrayTypeName Then
             result.Init(Me.AsNonArrayTypeName.clone)
         ElseIf Me.IsArrayTypeName Then
             result.Init(Me.AsArrayTypeName.clone)
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="72" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" hamdist="8" pcid="9839" startline="58"><![CDATA[
     End Property
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As NonArrayTypeName
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New NonArrayTypeName(NewParent)
         result.IsNullable = IsNullable
         If Me.IsConstructedTypeName Then
             result.Init(Me.AsConstructedTypeName.Clone)
         ElseIf Me.IsSimpleTypeName Then
             result.Init(Me.AsSimpleTypeName.Clone)
         Else
             Throw New InternalException(Me)
         End If
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="67" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" hamdist="11" pcid="8875" startline="51"><![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As QualifiedIdentifier
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New QualifiedIdentifier(NewParent, Me.Location)
 
         If Me.IsFirstGlobal Then
             result.Init(Me.FirstAsGlobal.Clone(result), m_Second)
         ElseIf Me.IsFirstIdentifier Then
             result.Init(Me.FirstAsIdentifier.Clone(result), m_Second)
         ElseIf Me.IsFirstQualifiedIdentifier Then
             result.Init(Me.FirstAsQualifiedIdentifier.Clone(result), m_Second)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="120" nfragments="3">
<clone_fragment endline="140" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Tokens\Span.vb" hamdist="0" pcid="9565" startline="130"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The end column of the span.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public ReadOnly Property EndColumn() As Byte
         Get
             Return m_EndColumn + m_Column
         End Get
]]></clone_fragment>
<clone_fragment endline="262" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\TypeDeclaration.vb" hamdist="10" pcid="9777" startline="248"><![CDATA[
     End Property
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Property BaseType() As Mono.Cecil.TypeReference Implements IType.BaseType
         Get
             If m_CecilType Is Nothing Then
                 Return Nothing
             End If
             Return m_CecilType.BaseType
         End Get
]]></clone_fragment>
<clone_fragment endline="349" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" hamdist="11" pcid="7445" startline="335"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The filename to report to the user in errors.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property FileNameToReport() As String
         Get
             If m_FileName.IndexOfAny(System.IO.Path.GetInvalidFileNameChars) >= 0 Then
                 Return m_FileName
             End If
             Return System.IO.Path.Combine(m_RelativePath, System.IO.Path.GetFileName(m_FileName))
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="121" nfragments="2">
<clone_fragment endline="9536" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="0" pcid="5129" startline="9525"><![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (base.CreateExpressionTree (ec)));
 			if (!initializers.IsEmpty)
 				args.Add (new Argument (initializers.CreateExpressionTree (ec)));
 
 			return CreateExpressionFactoryCall (ec,
 				initializers.IsCollectionInitializer ? "ListInit" 
 				args);
 		}
]]></clone_fragment>
<clone_fragment endline="5275" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="11" pcid="2425" startline="5255"><![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args;
 			if (IsSingleDimensionalArrayLength ()) {
 				args = new Arguments (1);
 				args.Add (new Argument (InstanceExpression.CreateExpressionTree (ec)));
 				return CreateExpressionFactoryCall (ec, "ArrayLength", args);
 			}
 
 			args = new Arguments (2);
 			if (InstanceExpression == null)
 				args.Add (new Argument (new NullLiteral (loc)));
 			else
 				args.Add (new Argument (InstanceExpression.CreateExpressionTree (ec)));
 			args.Add (new Argument (new TypeOfMethod (Getter, loc)));
 			return CreateExpressionFactoryCall (ec, "Property", args);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="122" nfragments="2">
<clone_fragment endline="2510" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" hamdist="0" pcid="3865" startline="2499"><![CDATA[
 
 		public override void Emit ()
 		{
 			base.Emit ();
 
 			if ((ModFlags & Modifiers.METHOD_EXTENSION) != 0)
 				Module.PredefinedAttributes.Extension.EmitAttribute (TypeBuilder);
 
 			if (base_type != null && base_type.HasDynamicElement) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (TypeBuilder, base_type, Location);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="241" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" hamdist="10" pcid="997" startline="219"><![CDATA[
 		}
 
 		public override void Emit ()
 		{
 			if (member_type == InternalType.Dynamic) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (FieldBuilder);
 			} else if (!(Parent is CompilerGeneratedClass) && member_type.HasDynamicElement) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (FieldBuilder, member_type, Location);
 			}
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (FieldBuilder);
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			if (((status & Status.HAS_OFFSET) == 0) && (ModFlags & (Modifiers.STATIC | Modifiers.BACKING_FIELD)) == 0 && Parent.PartialContainer.HasExplicitLayout) {
 				Report.Error (625, Location, "`{0}'
 			}
 
 			base.Emit ();
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="123" nfragments="2">
<clone_fragment endline="316" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" hamdist="0" pcid="21" startline="305"><![CDATA[
 
 		protected static Type ReadParam(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			switch (br.PeekByte())
 			{
 				case ELEMENT_TYPE_TYPEDBYREF
 					br.ReadByte();
 					return module.universe.System_TypedReference;
 				default
 					return ReadTypeOrByRef(module, br, context);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="179" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" hamdist="11" pcid="11" startline="167"><![CDATA[
 
 		private static Type ReadTypeOrVoid(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			if (br.PeekByte() == ELEMENT_TYPE_VOID)
 			{
 				br.ReadByte();
 				return module.universe.System_Void;
 			}
 			else
 			{
 				return ReadType(module, br, context);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="124" nfragments="2">
<clone_fragment endline="61" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\ExpressionParseInfo.vb" hamdist="0" pcid="8881" startline="50"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Initializing constructor.
     ''' </summary>
     ''' <param name="LeftSide"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, Optional ByVal LeftSide As Boolean = False, Optional ByVal IsInTypeOf As Boolean = False)
         m_IsLeftSide = LeftSide
         m_IsInTypeOf = IsInTypeOf
         m_Parent = Parent
     End Sub
]]></clone_fragment>
<clone_fragment endline="98" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\LateBoundAccessClassification.vb" hamdist="10" pcid="6715" startline="84"><![CDATA[
     End Property
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="InstanceExpression">May be Nothing</param>
     ''' <param name="TypeArguments">May be Nothing</param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Name As String)
         MyBase.New(Classifications.LateBoundAccess, Parent)
         m_InstanceExpression = InstanceExpression
         m_Name = Name
         m_TypeArguments = TypeArguments
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="125" nfragments="2">
<clone_fragment endline="107" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\NonArrayTypeName.vb" hamdist="0" pcid="9841" startline="96"><![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             If IsConstructedTypeName Then
                 Return AsConstructedTypeName.Name
             ElseIf Me.IsSimpleTypeName Then
                 Return AsSimpleTypeName.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="135" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\SimpleTypeName.vb" hamdist="10" pcid="9857" startline="124"><![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             If IsBuiltInTypeName Then
                 Return AsBuiltInTypeName.Name
             ElseIf IsQualifiedIdentifier Then
                 Return AsQualifiedIdentifier.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="126" nfragments="2">
<clone_fragment endline="169" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" hamdist="0" pcid="9417" startline="158"><![CDATA[
 
     Private Function IsPositiveStep() As Boolean
         Dim constant As Object
 
         constant = m_LoopStepExpression.ConstantValue
 
         If TypeOf constant Is Decimal Then
             Return CDec(constant) > 0
         Else
             Return CDbl(constant) > 0
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="157" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" hamdist="9" pcid="9415" startline="145"><![CDATA[
     End Property
 
     Private Function IsNegativeStep() As Boolean
         Dim constant As Object
 
         constant = m_LoopStepExpression.ConstantValue
 
         If TypeOf constant Is Decimal Then
             Return CDec(constant) < 0
         Else
             Return CDbl(constant) < 0
         End If
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="127" nfragments="2">
<clone_fragment endline="160" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" hamdist="0" pcid="6129" startline="153"><![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="152" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" hamdist="9" pcid="6127" startline="145"><![CDATA[
 
 		internal void WriteParamTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteParamRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteParamRecords(mw);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="128" nfragments="2">
<clone_fragment endline="117" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" hamdist="0" pcid="1337" startline="106"><![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]></clone_fragment>
<clone_fragment endline="88" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ManifestResourceInfo.cs" hamdist="11" pcid="4677" startline="69"><![CDATA[
 		}
 
 		public string FileName
 		{
 			get
 			{
 				int implementation = module.ManifestResource.records[index].Implementation;
 				if ((implementation >> 24) == FileTable.Index)
 				{
 					if ((implementation & 0xFFFFFF) == 0)
 					{
 						return null;
 					}
 					else
 					{
 						return module.GetString(module.File.records[(implementation & 0xFFFFFF) - 1].Name);
 					}
 				}
 				throw new NotImplementedException();
 			}
]]></clone_fragment>
</clone_group>
<clone_group groupid="129" nfragments="3">
<clone_fragment endline="562" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" hamdist="0" pcid="6169" startline="551"><![CDATA[
 
 		public MethodToken GetConstructorToken(ConstructorInfo constructor)
 		{
 			if (constructor.Module == this && constructor.GetMethodInfo() is MethodBuilder)
 			{
 				return new MethodToken(constructor.MetadataToken);
 			}
 			else
 			{
 				return new MethodToken(ImportMember(constructor));
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="473" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" hamdist="11" pcid="6159" startline="462"><![CDATA[
 
 		public TypeToken GetTypeToken(Type type)
 		{
 			if (type.Module == this)
 			{
 				return new TypeToken(type.GetModuleBuilderToken());
 			}
 			else
 			{
 				return new TypeToken(ImportType(type));
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="186" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" hamdist="8" pcid="2971" startline="166"><![CDATA[
 		}
 
 		public override MethodInfo GetGenericMethodDefinition()
 		{
 			if (this.IsGenericMethod)
 			{
 				if (this.IsGenericMethodDefinition)
 				{
 					return this;
 				}
 				else if (declaringType.IsGenericType && !declaringType.IsGenericTypeDefinition)
 				{
 					return new GenericMethodInstance(declaringType, method, null);
 				}
 				else
 				{
 					return method;
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="130" nfragments="5">
<clone_fragment endline="1374" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="0" pcid="1435" startline="1367"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1806" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="0" pcid="1487" startline="1799"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1766" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="7" pcid="1481" startline="1759"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1331" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="8" pcid="1429" startline="1323"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.WriteField(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.WriteField(records[i].Field);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1902" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="4" pcid="1499" startline="1894"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].RVA);
 				mw.WriteField(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].RVA);
 				mw.WriteField(records[i].Field);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="131" nfragments="2">
<clone_fragment endline="95" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" hamdist="0" pcid="1913" startline="84"><![CDATA[
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (!MemberType.IsCLSCompliant ()) {
 				Report.Warning (3003, 1, Location, "Type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="357" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" hamdist="10" pcid="2519" startline="341"><![CDATA[
 		}
 
 		//TODO
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			parameters.VerifyClsCompliance (this);
 
 			if (!ReturnType.Type.IsCLSCompliant ()) {
 				Report.Warning (3002, 1, Location, "Return type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="132" nfragments="2">
<clone_fragment endline="174" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" hamdist="0" pcid="6829" startline="163"><![CDATA[
     End Property
 
     ReadOnly Property FieldDefinition() As Mono.Cecil.FieldDefinition
         Get
             If m_TypeVariable IsNot Nothing AndAlso m_TypeVariable.FieldBuilder IsNot Nothing Then
                 Return m_TypeVariable.FieldBuilder
             ElseIf m_LocalVariable IsNot Nothing AndAlso m_LocalVariable.FieldBuilder IsNot Nothing Then
                 Return m_LocalVariable.FieldBuilder
             Else
                 Return CecilHelper.FindDefinition(m_FieldInfo)
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="186" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" hamdist="4" pcid="6831" startline="175"><![CDATA[
     End Property
 
     ReadOnly Property FieldInfo() As Mono.Cecil.FieldReference
         Get
             If m_TypeVariable IsNot Nothing AndAlso m_TypeVariable.FieldBuilder IsNot Nothing Then
                 Return m_TypeVariable.FieldBuilder
             ElseIf m_LocalVariable IsNot Nothing AndAlso m_LocalVariable.FieldBuilder IsNot Nothing Then
                 Return m_LocalVariable.FieldBuilder
             Else
                 Return m_FieldInfo
             End If
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="133" nfragments="2">
<clone_fragment endline="1324" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" hamdist="0" pcid="2089" startline="1313"><![CDATA[
 		
 		/// <summary>
 		///   Returns the MemberCore associated with a given name in the declaration
 		///   space. It doesn't return method based symbols !!
 		/// </summary>
 		/// 
 		public MemberCore GetDefinition (string name)
 		{
 			MemberCore mc = null;
 			defined_names.TryGetValue (name, out mc);
 			return mc;
 		}
]]></clone_fragment>
<clone_fragment endline="1454" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="11" pcid="2295" startline="1440"><![CDATA[
 	}
 
 	/// <summary>
 	///   This kind of cast is used to encapsulate Value Types in objects.
 	///
 	///   The effect of it is to box the value type emitted by the previous
 	///   operation.
 	/// </summary>
 	public class BoxedCast 
 
 		public BoxedCast (Expression expr, TypeSpec target_type)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="134" nfragments="2">
<clone_fragment endline="444" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" hamdist="0" pcid="5637" startline="433"><![CDATA[
 		}
 
 		public IList<CustomAttributeNamedArgument> NamedArguments
 		{
 			get
 			{
 				if (lazyNamedArguments == null)
 				{
 					LazyParseArguments();
 				}
 				return lazyNamedArguments;
 			}
]]></clone_fragment>
<clone_fragment endline="731" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" hamdist="11" pcid="5929" startline="719"><![CDATA[
 
 		public void Emit(OpCode opc, Type type)
 		{
 			Emit(opc);
 			if (opc == OpCodes.Ldtoken)
 			{
 				code.Write(moduleBuilder.GetTypeToken(type).Token);
 			}
 			else
 			{
 				code.Write(moduleBuilder.GetTypeTokenForMemberRef(type));
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="135" nfragments="2">
<clone_fragment endline="403" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" hamdist="0" pcid="3591" startline="392"><![CDATA[
 
 		public override void SetFlags (uint flags, Location loc)
 		{
 			try {
 				if (assembly_flags == null)
 					assembly_flags = typeof (AssemblyBuilder).GetField ("flags", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField);
 
 				assembly_flags.SetValue (builder, flags);
 			} catch {
 				base.SetFlags (flags, loc);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="415" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" hamdist="10" pcid="3593" startline="404"><![CDATA[
 
 		public override void SetVersion (Version version, Location loc)
 		{
 			try {
 				if (assembly_version == null)
 					assembly_version = typeof (AssemblyBuilder).GetField ("version", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField);
 
 				assembly_version.SetValue (builder, version.ToString (4));
 			} catch {
 				base.SetVersion (version, loc);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="136" nfragments="2">
<clone_fragment endline="1573" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="0" pcid="6449" startline="1562"><![CDATA[
 
     Shared Sub EmitLoadVariable(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             EmitLoadVariable(Info, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             EmitLoadVariable(Info, Variable.FieldInfo)
         ElseIf Variable.ParameterInfo IsNot Nothing Then
             EmitLoadVariable(Info, Variable.ParameterInfo)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]></clone_fragment>
<clone_fragment endline="1837" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="10" pcid="6473" startline="1826"><![CDATA[
 
     Shared Sub EmitStoreVariable(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             EmitStoreVariable(Info, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             EmitStoreField(Info, Variable.FieldInfo)
         ElseIf Variable.ParameterInfo IsNot Nothing Then
             EmitStoreVariable(Info, Variable.ParameterInfo)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="137" nfragments="2">
<clone_fragment endline="173" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" hamdist="0" pcid="1859" startline="162"><![CDATA[
 	}
 
 	sealed class StringHeap 
 	{
 		private List<string> list = new List<string>();
 		private Dictionary<string, int> strings = new Dictionary<string, int>();
 		private int nextOffset;
 
 		internal StringHeap()
 		{
 			Add("");
 		}
]]></clone_fragment>
<clone_fragment endline="213" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" hamdist="4" pcid="1865" startline="202"><![CDATA[
 	}
 
 	sealed class UserStringHeap 
 	{
 		private List<string> list = new List<string>();
 		private Dictionary<string, int> strings = new Dictionary<string, int>();
 		private int nextOffset;
 
 		internal UserStringHeap()
 		{
 			nextOffset = 1;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="138" nfragments="2">
<clone_fragment endline="218" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" hamdist="0" pcid="6529" startline="207"><![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             Dim result As String = ""
             Dim sep As String = ""
 
             For Each arg As Argument In m_Arguments
                 result = result & sep & arg.AsString
                 sep = ", "
             Next
             Return result
         End Get
]]></clone_fragment>
<clone_fragment endline="231" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" hamdist="3" pcid="6531" startline="219"><![CDATA[
     End Property
 
     ReadOnly Property ArgumentsTypesAsString() As String
         Get
             Dim result As String = ""
             Dim sep As String = ""
 
             For Each arg As Argument In m_Arguments
                 result = result & sep & arg.AsTypeString
                 sep = ", "
             Next
             Return result
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="139" nfragments="3">
<clone_fragment endline="3333" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="0" pcid="9107" startline="3322"><![CDATA[
 
     Private Function ParseNot(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As UnaryNotExpression
 
         If tm.CurrentToken = KS.Not Then
             result = ParseUnaryNotExpression(Info)
         Else
             Return ParseComparison(Info)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3171" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="6" pcid="9091" startline="3158"><![CDATA[
 
     Private Function ParseUnaryPlusMinus(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As UnaryExpression
 
         If tm.CurrentToken = KS.Add Then
             result = ParseUnaryPlusExpression(Info)
         ElseIf tm.CurrentToken = KS.Minus Then
             result = ParseUnaryMinusExpression(Info)
         Else
             Return ParseExponent(Info)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5550" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="9" pcid="9251" startline="5534"><![CDATA[
 
     Private Function ParseDoStatementCondition(ByVal Parent As ParsedObject, ByRef IsWhile As Boolean) As Expression
         Dim result As Expression = Nothing
 
         If tm.Accept(KS.While) Then
             IsWhile = True
             result = ParseExpression(Parent)
         ElseIf tm.Accept(KS.Until) Then
             IsWhile = False
             result = ParseExpression(Parent)
         Else
             Throw New InternalException(result)
         End If
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="140" nfragments="10">
<clone_fragment endline="258" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" hamdist="0" pcid="9879" startline="247"><![CDATA[
 
     ''' <summary>
     ''' Eats the current token if if coincides, if not shows a 
     ''' message "Expected
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         Return AcceptIfNotError(Special, Messages.VBNC90019, GotoNewline, Enums.strSpecial(Special))
     End Function
]]></clone_fragment>
<clone_fragment endline="320" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" hamdist="11" pcid="9887" startline="303"><![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal GotoNewline As Boolean, ByVal MessageParameters() As String) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation, MessageParameters)
             Return False
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="488" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" hamdist="11" pcid="9907" startline="472"><![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Accept(ByVal Special As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Special) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="445" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" hamdist="11" pcid="9901" startline="429"><![CDATA[
 
     ''' <summary>
     ''' Returns true if the current token is an identifier
     ''' and advances to the next token.
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIdentifier(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsIdentifier Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="506" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" hamdist="11" pcid="9909" startline="489"><![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Accept(ByVal Special1 As KS, ByVal Special2 As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Special1) AndAlso PeekToken.Equals(Special2) Then
             NextToken()
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
 
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="302" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" hamdist="11" pcid="9885" startline="285"><![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation)
             Return False
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="471" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" hamdist="12" pcid="9905" startline="456"><![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIntegerLiteral(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsIntegerLiteral Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="364" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" hamdist="8" pcid="9893" startline="341"><![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' Accepts only newline, not endofcode, nor endoffile. 
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <param name="EOFIsError">Specifies whether to return false if the current token is EOF or not.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptNewLine(Optional ByVal GotoNewline As Boolean = False, Optional ByVal EOFIsError As Boolean = True, Optional ByVal ReportError As Boolean = False) As Boolean
         If CurrentToken.IsEndOfLine Then
             If CurrentToken.IsEndOfLineOnly Then
                 NextToken()
                 Return True
             ElseIf EOFIsError = False Then
                 Return True
             Else
                 Return False
             End If
         Else
             If GotoNewline Then Me.GotoNewline(True, ReportError)
             Return False
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="519" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" hamdist="11" pcid="9911" startline="507"><![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     Function Accept(ByVal Identifier As String, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Identifier) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="409" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" hamdist="18" pcid="8241" startline="394"><![CDATA[
 
     ''' <summary>
     ''' Returns all the types within the specified namespace.
     ''' Never returns nothing and never throws an exception.
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetTypesByNamespace(ByVal [Namespace] As String) As TypeDictionary
         If [Namespace] Is Nothing Then [Namespace] = ""
         If m_CecilTypesByNamespace.ContainsKey([Namespace]) Then
             Return m_CecilTypesByNamespace([Namespace])
         Else
             Return New TypeDictionary()
         End If
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="141" nfragments="2">
<clone_fragment endline="77" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\PropertyAccessToValueExpression.vb" hamdist="0" pcid="7201" startline="66"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim propD As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(m_PropertyAccess.ResolvedProperty)
         Dim methodD As Mono.Cecil.MethodReference = propD.GetMethod
         Dim methodR As Mono.Cecil.MethodReference = CecilHelper.GetCorrectMember(methodD, m_PropertyAccess.ResolvedProperty.DeclaringType, True)
         Dim methodE As Mono.Cecil.MethodReference = Helper.GetMethodOrMethodReference(Compiler, methodR)
 
         result = Helper.EmitArgumentsAndCallOrCallVirt(Info, m_PropertyAccess.InstanceExpression, m_PropertyAccess.Parameters, methodE) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1583" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="9" pcid="7637" startline="1564"><![CDATA[
 
     Shared Function ApplyTypeArguments(ByVal Parent As ParsedObject, ByVal OpenParameter As Mono.Cecil.ParameterReference, ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.ParameterReference
         Dim result As Mono.Cecil.ParameterReference
 
         Helper.Assert(TypeParameters IsNot Nothing AndAlso TypeArguments IsNot Nothing)
         Helper.Assert(TypeParameters.Count = TypeArguments.Count)
 
         Dim paramType As Mono.Cecil.TypeReference
         paramType = ApplyTypeArguments(Parent, OpenParameter.ParameterType, TypeParameters, TypeArguments)
 
         If paramType Is OpenParameter.ParameterType Then
             result = OpenParameter
         Else
             result = Parent.Compiler.TypeManager.MakeGenericParameter(Parent, OpenParameter, paramType)
         End If
 
         Helper.Assert(result IsNot Nothing)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="142" nfragments="2">
<clone_fragment endline="91" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" hamdist="0" pcid="9697" startline="79"><![CDATA[
 
     ''' <summary>
     ''' Returns the default constructor (non-private, non-shared, with no parameters) for the base type (if any).          ''' If no constructor found, returns nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetBaseDefaultConstructorCecil() As Mono.Cecil.MethodReference
         If CecilHelper.IsGenericType(Me.BaseType) Then
             Return Helper.GetDefaultGenericConstructor(Me.BaseType)
         Else
             Return Helper.GetDefaultConstructor(Me.BaseType)
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="78" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" hamdist="6" pcid="9695" startline="66"><![CDATA[
 
     ''' <summary>
     ''' Returns the default constructor (non-private, non-shared, with no parameters) for the base type (if any).          ''' If no constructor found, returns nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetBaseDefaultConstructor() As Mono.Cecil.MethodReference
         If CecilHelper.IsGenericType(Me.BaseType) Then
             Return Helper.GetDefaultGenericConstructor(Me.BaseType)
         Else
             Return Helper.GetDefaultConstructor(Me.BaseType)
         End If
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="143" nfragments="2">
<clone_fragment endline="553" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" hamdist="0" pcid="2589" startline="543"><![CDATA[
 
 		public SourceFileEntry[] Sources {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				SourceFileEntry[] retval = new SourceFileEntry [SourceCount];
 				for (int i = 0; i < SourceCount; i++)
 					retval [i] = GetSourceFile (i + 1);
 				for (int i = 0; i < SourceCount; i++)
 					retval [i] = GetSourceFile (i + 1);
 				return retval;
 			}
]]></clone_fragment>
<clone_fragment endline="589" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" hamdist="10" pcid="2593" startline="579"><![CDATA[
 
 		public CompileUnitEntry[] CompileUnits {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				CompileUnitEntry[] retval = new CompileUnitEntry [CompileUnitCount];
 				for (int i = 0; i < CompileUnitCount; i++)
 					retval [i] = GetCompileUnit (i + 1);
 				for (int i = 0; i < CompileUnitCount; i++)
 					retval [i] = GetCompileUnit (i + 1);
 				return retval;
 			}
]]></clone_fragment>
</clone_group>
<clone_group groupid="144" nfragments="3">
<clone_fragment endline="88" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" hamdist="0" pcid="8419" startline="76"><![CDATA[
 
     Shared Function CreateTypeConstructor(ByVal Parent As TypeDeclaration) As ConstructorDeclaration
         Dim result As New ConstructorDeclaration(Parent)
 
         result.Init(New Modifiers(ModifierMasks.Shared), New SubSignature(result, SharedConstructorName, New ParameterList(result)), New CodeBlock(result))
 
         result.UpdateDefinition()
         If result.ResolveTypeReferences() = False Then
             Helper.ErrorRecoveryNotImplemented(Parent.Location)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4013" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="11" pcid="9151" startline="3998"><![CDATA[
 
     Private Function ParseImplementsClause(ByVal Parent As ParsedObject) As MemberImplementsClause
         Dim result As New MemberImplementsClause(Parent)
 
         Dim m_ImplementsList As New MemberImplementsList(Parent)
 
         tm.AcceptIfNotInternalError(KS.Implements)
 
         If ParseList(Of InterfaceMemberSpecifier)(m_ImplementsList, New ParseDelegate_Parent(Of InterfaceMemberSpecifier)(AddressOf ParseInterfaceMemberSpecifier), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_ImplementsList)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2441" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="9" pcid="9055" startline="2418"><![CDATA[
 
     Private Function ParseArrayInitializerExpression(ByVal Parent As ParsedObject) As ArrayInitializerExpression
         Dim result As New ArrayInitializerExpression(Parent)
 
         Dim m_Initializers As New Expressions()
 
         tm.AcceptIfNotInternalError(KS.LBrace)
 
         If tm.CurrentToken <> KS.RBrace Then
             Do
                 Dim newExp As Expression
                 newExp = ParseExpression(result)
                 If newExp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
                 m_Initializers.Add(newExp)
             Loop While tm.Accept(KS.Comma)
         End If
 
         If tm.Accept(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Initializers)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="145" nfragments="2">
<clone_fragment endline="560" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="0" pcid="8161" startline="548"><![CDATA[
 
     Shared Function GetUnaryResultType(ByVal op As KS, ByVal op1 As TypeCode) As TypeCode
         Select Case op
             Case KS.Add
                 Return GetUnaryPlusResultType(op1)
             Case KS.Minus
                 Return GetUnaryMinusResultType(op1)
             Case KS.Not
                 Return GetUnaryNotResultType(op1)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="624" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="2" pcid="8165" startline="612"><![CDATA[
 
     Shared Function GetUnaryOperandType(ByVal op As KS, ByVal operand As TypeCode) As TypeCode
         Select Case op
             Case KS.Add
                 Return GetUnaryPlusResultType(operand)
             Case KS.Minus
                 Return GetUnaryMinusResultType(operand)
             Case KS.Not
                 Return GetUnaryNotResultType(operand)
             Case Else
                 Throw New NotImplementedException
         End Select
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="146" nfragments="21">
<clone_fragment endline="2403" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="0" pcid="9051" startline="2391"><![CDATA[
 
     Private Function ParseUnaryNotExpression(ByVal Info As ExpressionParseInfo) As UnaryNotExpression
         Dim result As New UnaryNotExpression(Info.Parent)
 
         Dim m_Expression As Expression
         tm.AcceptIfNotInternalError(KS.Not)
 
         m_Expression = ParseComparison(Info)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1998" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="10" pcid="9007" startline="1985"><![CDATA[
 
     Private Function ParseCByteExpression(ByVal Parent As ParsedObject) As CByteExpression
         Dim result As New CByteExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CByte)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2013" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="5" pcid="9009" startline="1999"><![CDATA[
 
     Private Function ParseCBoolExpression(ByVal Parent As ParsedObject) As CBoolExpression
         Dim result As New CBoolExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CBool)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2043" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="4" pcid="9013" startline="2029"><![CDATA[
 
     Private Function ParseCDateExpression(ByVal Parent As ParsedObject) As CDateExpression
         Dim result As New CDateExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDate)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2193" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="4" pcid="9033" startline="2179"><![CDATA[
 
     Private Function ParseCUIntExpression(ByVal Parent As ParsedObject) As CUIntExpression
         Dim result As New CUIntExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CUInt)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2103" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="5" pcid="9021" startline="2089"><![CDATA[
 
     Private Function ParseCLngExpression(ByVal Parent As ParsedObject) As CLngExpression
         Dim result As New CLngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CLng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2118" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="4" pcid="9023" startline="2104"><![CDATA[
 
     Private Function ParseCObjExpression(ByVal Parent As ParsedObject) As CObjExpression
         Dim result As New CObjExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CObj)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2148" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="8" pcid="9027" startline="2134"><![CDATA[
 
     Private Function ParseCShortExpression(ByVal Parent As ParsedObject) As CShortExpression
         Dim result As New CShortExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CShort)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2163" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="3" pcid="9029" startline="2149"><![CDATA[
 
     Private Function ParseCSngExpression(ByVal Parent As ParsedObject) As CSngExpression
         Dim result As New CSngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CSng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2208" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="5" pcid="9035" startline="2194"><![CDATA[
 
     Private Function ParseCULngExpression(ByVal Parent As ParsedObject) As CULngExpression
         Dim result As New CULngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CULng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2058" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="7" pcid="9015" startline="2044"><![CDATA[
 
     Private Function ParseCDblExpression(ByVal Parent As ParsedObject) As CDblExpression
         Dim result As New CDblExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDbl)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2178" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="2" pcid="9031" startline="2164"><![CDATA[
 
     Private Function ParseCStrExpression(ByVal Parent As ParsedObject) As CStrExpression
         Dim result As New CStrExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CStr)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2417" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="4" pcid="9053" startline="2404"><![CDATA[
 
     Private Function ParseUnaryPlusExpression(ByVal Info As ExpressionParseInfo) As UnaryPlusExpression
         Dim result As New UnaryPlusExpression(Info.Parent)
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.Add)
 
         m_Expression = ParseExponent(Info)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2073" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="7" pcid="9017" startline="2059"><![CDATA[
 
     Private Function ParseCDecExpression(ByVal Parent As ParsedObject) As CDecExpression
         Dim result As New CDecExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDec)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2359" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="7" pcid="9047" startline="2345"><![CDATA[
 
 
     Private Function ParseUnaryMinusExpression(ByVal Info As ExpressionParseInfo) As UnaryMinusExpression
         Dim result As New UnaryMinusExpression(Info.Parent)
 
         Dim m_Expression As Expression
         tm.AcceptIfNotInternalError(KS.Minus)
 
         m_Expression = ParseExponent(Info)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2223" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="3" pcid="9037" startline="2209"><![CDATA[
 
     Private Function ParseCUShortExpression(ByVal Parent As ParsedObject) As CUShortExpression
         Dim result As New CUShortExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CUShort)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2133" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="8" pcid="9025" startline="2119"><![CDATA[
 
     Private Function ParseCSByteExpression(ByVal Parent As ParsedObject) As CSByteExpression
         Dim result As New CSByteExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CSByte)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2088" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="6" pcid="9019" startline="2074"><![CDATA[
 
     Private Function ParseCIntExpression(ByVal Parent As ParsedObject) As CIntExpression
         Dim result As New CIntExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CInt)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2028" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="7" pcid="9011" startline="2014"><![CDATA[
 
     Private Function ParseCCharExpression(ByVal Parent As ParsedObject) As CCharExpression
         Dim result As New CCharExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CChar)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5222" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="11" pcid="9231" startline="5205"><![CDATA[
 
     Private Function ParseReturnStatement(ByVal Parent As ParsedObject) As ReturnStatement
         Dim result As New ReturnStatement(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.Return)
         If Not tm.CurrentToken.IsEndOfStatement Then
             m_Expression = ParseExpression(result)
             If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Expression = Nothing
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="681" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="14" pcid="8931" startline="656"><![CDATA[
 
     Private Delegate Function ParseDelegate_Parent(Of T)(ByVal Parent As ParsedObject) As T
 
     ''' <summary>
     ''' VariablePropertyInitializer  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariablePropertyInitializer(ByVal Parent As ParsedObject) As VariablePropertyInitializer
         Dim result As New VariablePropertyInitializer(Parent)
 
         Dim m_IdentifierOrKeyword As IdentifierOrKeyword
         Dim m_AttributeArgumentExpression As AttributeArgumentExpression
 
         m_IdentifierOrKeyword = ParseIdentifierOrKeyword(result)
         If m_IdentifierOrKeyword Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         tm.AcceptIfNotInternalError(KS.Colon)
         tm.AcceptIfNotInternalError(KS.Equals)
 
         m_AttributeArgumentExpression = ParseAttributeArgumentExpression(result)
         If m_AttributeArgumentExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IdentifierOrKeyword, m_AttributeArgumentExpression)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="147" nfragments="3">
<clone_fragment endline="605" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" hamdist="0" pcid="4615" startline="593"><![CDATA[
 
 		internal FieldInfo GetFieldAt(TypeDefImpl owner, int index)
 		{
 			if (fields == null)
 			{
 				fields = new FieldInfo[Field.records.Length];
 			}
 			if (fields[index] == null)
 			{
 				fields[index] = new FieldDefImpl(this, owner ?? FindFieldOwner(index), index);
 			}
 			return fields[index];
 		}
]]></clone_fragment>
<clone_fragment endline="1934" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="10" pcid="4381" startline="1910"><![CDATA[
 
 		public PropertySpec GetProperty (string name, TypeSpec memberType, Location loc)
 		{
 			PropertySpec spec;
 
 			if (properties != null) {
 				spec = properties.Find (l => l.Name == name);
 			} else {
 				spec = null;
 			}
 
 			if (spec == null) {
 				spec = TypeManager.GetPredefinedProperty (type, name, loc, memberType);
 
 				if (spec != null) {
 					if (properties == null) {
 						properties = new List<PropertySpec> ();
 					}
 
 					properties.Add (spec);
 				}
 			}
 
 			return spec;
 		}
]]></clone_fragment>
<clone_fragment endline="503" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" hamdist="10" pcid="4603" startline="491"><![CDATA[
 
 		private Assembly ResolveAssemblyRef(int index)
 		{
 			if (assemblyRefs == null)
 			{
 				assemblyRefs = new Assembly[AssemblyRef.RowCount];
 			}
 			if (assemblyRefs[index] == null)
 			{
 				assemblyRefs[index] = ResolveAssemblyRefImpl(ref AssemblyRef.records[index]);
 			}
 			return assemblyRefs[index];
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="148" nfragments="2">
<clone_fragment endline="633" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="0" pcid="8069" startline="621"><![CDATA[
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
]]></clone_fragment>
<clone_fragment endline="620" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="9" pcid="8067" startline="606"><![CDATA[
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="149" nfragments="3">
<clone_fragment endline="1348" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="0" pcid="1431" startline="1340"><![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]></clone_fragment>
<clone_fragment endline="832" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="10" pcid="1387" startline="822"><![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Class))
 				{
 					records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Class))
 				{
 					records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
 				}
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1923" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="13" pcid="1501" startline="1911"><![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder, int sdataRVA)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].RVA += sdataRVA;
 				if (moduleBuilder.IsPseudoToken(records[i].Field))
 				{
 					records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].RVA += sdataRVA;
 				if (moduleBuilder.IsPseudoToken(records[i].Field))
 				{
 					records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="150" nfragments="3">
<clone_fragment endline="184" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" hamdist="0" pcid="7429" startline="172"><![CDATA[
 
     ''' <summary>
     ''' The state of the Option Explicit flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionExplicitOn() As Boolean
         Get
             If m_OptionExplicit Is Nothing Then
                 Return Compiler.CommandLine.OptionExplicit = CommandLine.OptionExplicitTypes.On
             Else
                 Return m_OptionExplicit.IsOn
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="212" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" hamdist="4" pcid="7433" startline="199"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareBinary() As Boolean
         Get
             If m_OptionCompare Is Nothing Then
                 Return Compiler.CommandLine.OptionCompare = CommandLine.OptionCompareTypes.Binary
             Else
                 Return m_OptionCompare.IsBinary
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="198" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" hamdist="7" pcid="7431" startline="185"><![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="151" nfragments="2">
<clone_fragment endline="3121" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7761" startline="3109"><![CDATA[
 
     Overloads Shared Function ToString(ByVal Types As Type()) As String
         Dim result As String = ""
         Dim sep As String = ""
 
         For Each t As Type In Types
             Helper.Assert(t IsNot Nothing)
             result &= sep & t.ToString
             sep = ", "
         Next
 
         Return "{" & result & "}"
     End Function
]]></clone_fragment>
<clone_fragment endline="3108" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="8" pcid="7759" startline="3094"><![CDATA[
 
     Overloads Shared Function ToString(ByVal Types As Mono.Cecil.TypeReference()) As String
         Dim result As String = ""
         Dim sep As String = ""
 
         If Types IsNot Nothing Then
             For Each t As Mono.Cecil.TypeReference In Types
                 Helper.Assert(t IsNot Nothing)
                 result &= sep & t.ToString
                 sep = ", "
             Next
         End If
 
         Return "{" & result & "}"
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="152" nfragments="2">
<clone_fragment endline="59" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" hamdist="0" pcid="6849" startline="47"><![CDATA[
     End Property
 End Class
 
 Public Class LoadLocalExpression
     Inherits CompilerGeneratedExpression
 
     Private m_Local As Mono.Cecil.Cil.VariableDefinition
     
     Sub New(ByVal Parent As ParsedObject, ByVal Local As Mono.Cecil.Cil.VariableDefinition)
         MyBase.New(Parent, Nothing, Local.VariableType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
         m_Local = Local
     End Sub
]]></clone_fragment>
<clone_fragment endline="94" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" hamdist="9" pcid="6853" startline="81"><![CDATA[
 End Class
 
 Public Class LoadElementExpression
     Inherits CompilerGeneratedExpression
 
     Private m_Local As Mono.Cecil.Cil.VariableDefinition
     Private m_Index As Integer
 
     Sub New(ByVal Parent As ParsedObject, ByVal Local As Mono.Cecil.Cil.VariableDefinition, ByVal Index As Integer)
         MyBase.New(Parent, Nothing, Local.VariableType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
         m_Local = Local
         m_Index = Index
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="153" nfragments="4">
<clone_fragment endline="900" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" hamdist="0" pcid="695" startline="888"><![CDATA[
 		}
 
 		internal void WriteTypeDefRecord(MetadataWriter mw, ref int fieldList, ref int methodList)
 		{
 			mw.Write((int)attribs);
 			mw.WriteStringIndex(typeName);
 			mw.WriteStringIndex(typeNameSpace);
 			mw.WriteTypeDefOrRef(extends);
 			mw.WriteField(fieldList);
 			mw.WriteMethodDef(methodList);
 			methodList += methods.Count;
 			fieldList += fields.Count;
 		}
]]></clone_fragment>
<clone_fragment endline="90" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\CliHeader.cs" hamdist="9" pcid="2493" startline="71"><![CDATA[
 
 		internal void Write(IKVM.Reflection.Writer.MetadataWriter mw)
 		{
 			mw.Write(Cb);
 			mw.Write(MajorRuntimeVersion);
 			mw.Write(MinorRuntimeVersion);
 			mw.Write(MetaDataRVA);
 			mw.Write(MetaDataSize);
 			mw.Write(Flags);
 			mw.Write(EntryPointToken);
 			mw.Write(ResourcesRVA);
 			mw.Write(ResourcesSize);
 			mw.Write(StrongNameSignatureRVA);
 			mw.Write(StrongNameSignatureSize);
 			mw.Write(CodeManagerTable);
 			mw.Write(VTableFixupsRVA);
 			mw.Write(VTableFixupsSize);
 			mw.Write(ExportAddressTableJumps);
 			mw.Write(ManagedNativeHeader);
 		}
]]></clone_fragment>
<clone_fragment endline="1978" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="9" pcid="1505" startline="1963"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].HashAlgId);
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKey);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].HashAlgId);
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKey);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="2059" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="3" pcid="1513" startline="2044"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKeyOrToken);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKeyOrToken);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="154" nfragments="39">
<clone_fragment endline="1066" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="0" pcid="7379" startline="1054"><![CDATA[
 
     Public Shared Function IsPrimitive(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Select Case Helper.GetTypeCode(Compiler, Type)
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Char, TypeCode.Double, TypeCode.Single
                 Return True
             Case Else
                 If Helper.CompareType(Type, Compiler.TypeCache.System_IntPtr) Then
                     Return True
                 Else
                     Return False
                 End If
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="152" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" hamdist="6" pcid="6869" startline="134"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, _
                   TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                     Return CBool(originalValue) 'No range checking needed.
                 Case TypeCode.DBNull
                     Return CBool(Nothing)
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return False
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="144" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" hamdist="2" pcid="6901" startline="126"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, _
                 TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                     Return CDbl(originalValue) 'No range checking needed.
                 Case TypeCode.DBNull
                     Return CDbl(0)
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Double
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="148" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" hamdist="6" pcid="7005" startline="126"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                     Return CULng(originalValue) 'No range checking needed.
                 Case TypeCode.Int16, TypeCode.Int32, TypeCode.SByte, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New ULong
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New ULong
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="148" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" hamdist="6" pcid="6917" startline="126"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32
                     Return CInt(originalValue) 'No range checking needed.
                 Case TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CInt(0)
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CInt(0)
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="148" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" hamdist="4" pcid="6959" startline="126"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16
                     Return CShort(originalValue) 'No range checking needed.
                 Case TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Short
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Short
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="148" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" hamdist="4" pcid="7013" startline="126"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16
                     Return CUShort(originalValue) 'No range checking needed.
                 Case TypeCode.Int16, TypeCode.Int32, TypeCode.SByte, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New UShort
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New UShort
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="52" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryPlusExpression.vb" hamdist="9" pcid="7261" startline="30"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
         result = Expression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Decimal
             Case TypeCode.Single, TypeCode.Double
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__PlusObject_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="146" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" hamdist="10" pcid="6909" startline="124"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Decimal
                     Return CDec(originalValue) 'No range checking needed.
                 Case TypeCode.Single, TypeCode.Double, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Expression.Location, ExpressionType.ToString)
                         Return New Decimal
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Expression.Location, originalValue.ToString, ExpressionType.ToString)
                     Return New Decimal
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="148" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" hamdist="2" pcid="6925" startline="126"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt32
                     Return CLng(originalValue) 'No range checking needed.
                 Case TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Long
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Long
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="148" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" hamdist="2" pcid="6951" startline="126"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.SByte
                     Return CSByte(originalValue) 'No range checking needed.
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New SByte
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CSByte(0)
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="137" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" hamdist="2" pcid="6967" startline="115"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Decimal
                     Return CSng(originalValue) 'No range checking needed.
                 Case TypeCode.Double, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New Single
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New Single
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="155" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" hamdist="2" pcid="6997" startline="133"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32
                     Return CUInt(originalValue) 'No range checking needed.
                 Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return New UInteger
                     End If
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return New UInteger
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="149" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" hamdist="3" pcid="6877" startline="125"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim tpCode As TypeCode
             Dim originalValue As Object
             originalValue = Expression.ConstantValue
             tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
             Select Case tpCode
                 Case TypeCode.Boolean, TypeCode.Byte
                     Return CByte(originalValue) 'No range checking needed.
                 Case TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                     Dim resultvalue As Object = 0
                     If Compiler.TypeResolution.CheckNumericRange(originalValue, resultvalue, ExpressionType) Then
                         Return resultvalue
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                         Return CByte(0)
                     End If
                 Case TypeCode.DBNull
                     Return CByte(0)
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                     Return CByte(0)
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="48" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinarySubExpression.vb" hamdist="13" pcid="6597" startline="24"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitSubOrSubOvfOrSubOvfUn(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitSub(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Subtract_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__SubtractObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="48" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\MultExpression.vb" hamdist="5" pcid="6657" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitMultOrMultOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitMult(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Multiply_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__MultiplyObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="44" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\XorExpression.vb" hamdist="4" pcid="6685" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitXOr(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__XorObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="62" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" hamdist="2" pcid="6671" startline="39"><![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitOr(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__OrObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="62" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" hamdist="1" pcid="6573" startline="39"><![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitAnd(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AndObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="48" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ModExpression.vb" hamdist="7" pcid="6653" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitMod(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitMod(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Remainder_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ModObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="74" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryAddExpression.vb" hamdist="8" pcid="6579" startline="46"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitAddOrAddOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitAdd(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Add_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AddObject_Object_Object)
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="57" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LShiftExpression.vb" hamdist="5" pcid="6643" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo.Clone(Me, Compiler.TypeCache.System_Int32)) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte
                 Dim shift As Integer
                 Select Case OperandTypeCode
                     Case TypeCode.Byte, TypeCode.SByte
                         shift = 7
                     Case TypeCode.Int16, TypeCode.UInt16
                         shift = 15
                     Case TypeCode.Int32, TypeCode.UInt32
                         shift = 31
                     Case TypeCode.Int64, TypeCode.UInt64
                         shift = 63
                 End Select
                 Emitter.EmitLoadI4Value(Info, shift)
                 Emitter.EmitAnd(Info, Info.Compiler.TypeCache.System_Int32)
                 Emitter.EmitLShift(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__LeftShiftObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="58" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" hamdist="1" pcid="6679" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo.Clone(Me, Compiler.TypeCache.System_Int32)) AndAlso result
 
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte
                 Dim shift As Integer
                 Select Case OperandTypeCode
                     Case TypeCode.Byte, TypeCode.SByte
                         shift = 7
                     Case TypeCode.Int16, TypeCode.UInt16
                         shift = 15
                     Case TypeCode.Int32, TypeCode.UInt32
                         shift = 31
                     Case TypeCode.Int64, TypeCode.UInt64
                         shift = 63
                 End Select
                 Emitter.EmitLoadI4Value(Info, shift)
                 Emitter.EmitAnd(Info, Info.Compiler.TypeCache.System_Int32)
                 Emitter.EmitRShift(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__RightShiftObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="67" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" hamdist="15" pcid="6879" startline="34"><![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 'Nothing to do
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32007, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Boolean, TypeCode.Double, TypeCode.DateTime, TypeCode.Decimal, TypeCode.Single
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToChar_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'Nothing to do
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToChar_String)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="53" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryNotExpression.vb" hamdist="14" pcid="7257" startline="30"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
         result = Expression.GenerateCode(expInfo) AndAlso result
 
         Select Case Me.OperandTypeCode
 
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, Compiler.TypeCache.System_Boolean)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Boolean)
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitNot(Info, OperandType)
             Case TypeCode.Object
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__NotObject_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="70" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" hamdist="12" pcid="6887" startline="34"><![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.DateTime
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Info.Compiler.TypeCache.System_Double.Name, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Double
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30533, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Boolean, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.SByte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDate_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDate_Object)
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDate_String)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="62" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LTExpression.vb" hamdist="11" pcid="6649" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitGT(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitLT(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitLT_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectLess_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLT(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="95" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryMinusExpression.vb" hamdist="17" pcid="7255" startline="64"><![CDATA[
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(IsConstant)
             Dim value As Object = Expression.ConstantValue
             Helper.Assert(value IsNot Nothing)
             Select Case Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, value))
                 Case TypeCode.SByte
                     Return -CSByte(value)
                 Case TypeCode.Int16
                     Return -CShort(value)
                 Case TypeCode.Int32
                     Return -CInt(value)
                 Case TypeCode.Int64
                     Return -CLng(value)
                 Case TypeCode.Byte
                 Case TypeCode.UInt16
                 Case TypeCode.UInt32
                 Case TypeCode.UInt64
                     Return -CULng(value)
                 Case TypeCode.Decimal
                     Return -CDec(value)
                 Case TypeCode.Double
                     Return -CDbl(value)
                 Case TypeCode.Single
                     Return -CSng(value)
                 Case Else
                     Helper.Stop()
             End Select
             Helper.Stop()
             Return Nothing
         End Get
]]></clone_fragment>
<clone_fragment endline="88" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ExponentExpression.vb" hamdist="16" pcid="6615" startline="60"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
 
             If lvalue Is Nothing Then lvalue = 0
             If rvalue Is Nothing Then rvalue = 0
 
             Dim tlvalue, trvalue As Mono.Cecil.TypeReference
             Dim clvalue, crvalue As TypeCode
             tlvalue = CecilHelper.GetType(Compiler, lvalue)
             clvalue = Helper.GetTypeCode(Compiler, tlvalue)
             trvalue = CecilHelper.GetType(Compiler, rvalue)
             crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
             Helper.Assert(Compiler.TypeResolution.IsNumericType(tlvalue) AndAlso Compiler.TypeResolution.IsNumericType(trvalue))
 
             'An exponent operator always returns a double result.
             Select Case clvalue
                 Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, _
                  TypeCode.Int64, TypeCode.UInt64, TypeCode.Double, TypeCode.Single, TypeCode.Decimal
                     Return Math.Pow(CDbl(lvalue), CDbl(rvalue))
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="62" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LEExpression.vb" hamdist="16" pcid="6637" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitGE(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitLE(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitLE_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectLessEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitLE(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="44" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\IntDivisionExpression.vb" hamdist="10" pcid="6625" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitIntDiv(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__IntDivideObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="62" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GTExpression.vb" hamdist="8" pcid="6621" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLT(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitGT(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitGT_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectGreater_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="62" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GEExpression.vb" hamdist="7" pcid="6617" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLE(Info, OperandType) 'LAMESPEC
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Char
                 Emitter.EmitGE(Info, OperandType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitGE_Un(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectGreaterEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitGE(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="58" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\NotEqualsExpression.vb" hamdist="6" pcid="6661" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim eqInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(eqInfo) AndAlso result
         result = m_RightExpression.GenerateCode(eqInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Boolean, TypeCode.Char
                 Emitter.EmitNotEquals(Info, OperandType)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitNotEquals(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitnotEquals(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectNotEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitNotEquals(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="46" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RealDivisionExpression.vb" hamdist="10" pcid="6675" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitRealDiv(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Divide_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__DivideObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="114" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" hamdist="11" pcid="6891" startline="81"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Info.Compiler.TypeCache.System_Double.Name, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Double
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30533, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Boolean, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.SByte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="64" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\EqualsExpression.vb" hamdist="13" pcid="6609" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Boolean, TypeCode.Char
                 Emitter.EmitEquals(Info, OperandType)
             Case TypeCode.DateTime
                 Helper.Assert(Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime IsNot Nothing, "Date_Compare__Date_Date Is Nothing")
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_DateTime__Compare_DateTime_DateTime)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Decimal
                 Helper.Assert(Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal IsNot Nothing, "Decimal_Compare__Decimal_Decimal Is Nothing")
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Compare_Decimal_Decimal)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Int32)
             Case TypeCode.Object
                 Helper.Assert(Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectEqual_Object_Object_Boolean IsNot Nothing, "MS_VB_CS_Operators_ConditionalCompareObjectEqual__Object_Object_Bool Is Nothing")
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 'Compiler.Report.WriteLine("MS_VB_CS_Operators_ConditionalCompareObjectEqual__Object_Object_Bool
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConditionalCompareObjectEqual_Object_Object_Boolean)
             Case TypeCode.String
                 Helper.Assert(Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean IsNot Nothing, "MS_VB_CS_Operators_CompareString__String_String_Bool Is Nothing")
                 Emitter.EmitLoadI4Value(Info, Info.IsOptionCompareText)
                 'Compiler.Report.WriteLine("MS_VB_CS_Operators_CompareString__String_String_Bool
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__CompareString_String_String_Boolean)
                 Emitter.EmitLoadI4Value(Info, 0)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Int32)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="120" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" hamdist="14" pcid="6899" startline="74"><![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Double
                 'Nothing to do
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30532, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToDouble_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="109" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" hamdist="9" pcid="6883" startline="78"><![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 'Nothing to do
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32007, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.String
                 'OK
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case Else
         End Select
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="155" nfragments="2">
<clone_fragment endline="113" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" hamdist="0" pcid="989" startline="100"><![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
]]></clone_fragment>
<clone_fragment endline="1038" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" hamdist="0" pcid="1981" startline="1025"><![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="156" nfragments="2">
<clone_fragment endline="733" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7573" startline="720"><![CDATA[
 
     Shared Function IsPrivate(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim mD As Mono.Cecil.MethodDefinition
 
         mD = TryCast(Method, Mono.Cecil.MethodDefinition)
 
         If mD IsNot Nothing Then Return mD.IsPrivate
 
         mD = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then Return mD.IsPrivate
 
         Throw New NotImplementedException
     End Function
]]></clone_fragment>
<clone_fragment endline="747" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="4" pcid="7575" startline="734"><![CDATA[
 
     Shared Function IsFamilyOrAssembly(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim mD As Mono.Cecil.MethodDefinition
 
         mD = TryCast(Method, Mono.Cecil.MethodDefinition)
 
         If mD IsNot Nothing Then Return mD.IsFamilyOrAssembly
 
         mD = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then Return mD.IsFamilyOrAssembly
 
         Throw New NotImplementedException
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="157" nfragments="2">
<clone_fragment endline="343" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" hamdist="0" pcid="4001" startline="334"><![CDATA[
 
 		public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names)
 		{
 			gtpb = new GenericTypeParameterBuilder[names.Length];
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], null, this, i);
 			}
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], null, this, i);
 			}
 			return (GenericTypeParameterBuilder[])gtpb.Clone();
 		}
]]></clone_fragment>
<clone_fragment endline="617" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" hamdist="4" pcid="677" startline="607"><![CDATA[
 
 		public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names)
 		{
 			typeFlags |= TypeFlags.IsGenericTypeDefinition;
 			gtpb = new GenericTypeParameterBuilder[names.Length];
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], this, null, i);
 			}
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], this, null, i);
 			}
 			return (GenericTypeParameterBuilder[])gtpb.Clone();
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="158" nfragments="4">
<clone_fragment endline="175" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" hamdist="0" pcid="8223" startline="162"><![CDATA[
 
 
     ''' <summary>
     ''' Searches for the type with the specified name.
     ''' </summary>
     ''' <param name="Name">The type's name to search for. Not case-sensitive.</param>
     ''' <param name="OnlyCreatedTypes">Specifes whether to search in all types, or only in types compiled now.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Function [GetType](ByVal Name As String, ByVal OnlyCreatedTypes As Boolean) As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
         result.AddRange(Me.GetType(Name, Types, OnlyCreatedTypes))
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="849" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="11" pcid="7587" startline="836"><![CDATA[
 
     ''' <summary>
     ''' Returns a list of type descriptors that only are modules.
     ''' </summary>
     ''' <param name="Types"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function FilterToModules(ByVal Compiler As Compiler, ByVal Types As TypeDictionary) As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
         For Each t As Mono.Cecil.TypeReference In Types.Values
             If IsModule(Compiler, t) Then result.Add(t)
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="228" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Report.vb" hamdist="11" pcid="8005" startline="212"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Show the saved messages. Returns true if any error messages have been shown.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ShowSavedMessages() As Boolean
         Dim result As Boolean = False
 
         For Each msg As Message In m_SavedMessages
             ShowMessage(False, msg) 'Compiler.Report.WriteLine(str)
             If msg.Level >= MessageLevel.Error Then result = True
         Next
         m_SavedMessages.Clear()
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="148" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" hamdist="11" pcid="6721" startline="134"><![CDATA[
 
     ''' <summary>
     ''' Reclassifies the method group to a value, at the same time the method
     ''' group might be resolved using an empty argument list.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Function ReclassifyToValue() As ValueClassification
         Dim result As ValueClassification
         If m_Resolved = False Then
             Me.ResolveGroup(New ArgumentList(Me.Parent))
         End If
         result = New ValueClassification(Me)
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="159" nfragments="3">
<clone_fragment endline="238" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" hamdist="0" pcid="6729" startline="225"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns the resolved method.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedMethod() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If m_Group.Count = 0 Then Return Nothing
             Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
         End Get
]]></clone_fragment>
<clone_fragment endline="224" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" hamdist="9" pcid="6727" startline="208"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if the resolved method isn't a constructorinfo.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedConstructor() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If TypeOf m_Group(0) Is Mono.Cecil.MethodReference Then
                 Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
             Else
                 Return Nothing
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="207" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" hamdist="2" pcid="6725" startline="192"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if the resolved method isn't a methodinfo.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedMethodInfo() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If TypeOf m_Group(0) Is Mono.Cecil.MethodReference Then
                 Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
             Else
                 Return Nothing
             End If
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="160" nfragments="6">
<clone_fragment endline="470" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="0" pcid="515" startline="457"><![CDATA[
 
 		internal void WriteHasSemantics(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasSemantics)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="563" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="4" pcid="525" startline="550"><![CDATA[
 
 		internal void WriteHasFieldMarshal(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasFieldMarshal)
 			{
 				Write(encodedToken & 0xFFFFFF);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="239" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="4" pcid="487" startline="226"><![CDATA[
 
 		internal void WriteHasCustomAttribute(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasCustomAttribute)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="512" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="2" pcid="519" startline="499"><![CDATA[
 
 		internal void WriteTypeOrMethodDef(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigTypeOrMethodDef)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="526" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="2" pcid="521" startline="513"><![CDATA[
 
 		internal void WriteHasDeclSecurity(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasDeclSecurity)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="456" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="1" pcid="513" startline="443"><![CDATA[
 
 		internal void WriteHasConstant(int encodedToken)
 		{
 			// NOTE because we've already had to do the encoding (to be able to sort the table)
 			// here we simple write the value
 			if (bigHasConstant)
 			{
 				Write(encodedToken);
 			}
 			else
 			{
 				Write((short)encodedToken);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="161" nfragments="8">
<clone_fragment endline="723" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="0" pcid="1375" startline="715"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteEncodedTypeDefOrRef(records[i].Interface);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteEncodedTypeDefOrRef(records[i].Interface);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1121" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="8" pcid="1407" startline="1113"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasFieldMarshal(records[i].Parent);
 				mw.WriteBlobIndex(records[i].NativeType);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasFieldMarshal(records[i].Parent);
 				mw.WriteBlobIndex(records[i].NativeType);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1715" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="12" pcid="1475" startline="1706"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteMethodDefOrRef(records[i].MethodBody);
 				mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteMethodDefOrRef(records[i].MethodBody);
 				mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="864" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="7" pcid="1391" startline="855"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Type);
 				mw.WriteHasConstant(records[i].Parent);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Type);
 				mw.WriteHasConstant(records[i].Parent);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="798" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="10" pcid="1383" startline="789"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMemberRefParent(records[i].Class);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Signature);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMemberRefParent(records[i].Class);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Signature);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1538" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="7" pcid="1455" startline="1529"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Type);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Type);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="2102" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="6" pcid="1519" startline="2093"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1460" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="10" pcid="1445" startline="1451"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].EventFlags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteTypeDefOrRef(records[i].EventType);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].EventFlags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteTypeDefOrRef(records[i].EventType);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="162" nfragments="2">
<clone_fragment endline="1420" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="0" pcid="1441" startline="1412"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteEvent(records[i].EventList);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteEvent(records[i].EventList);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1498" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="10" pcid="1451" startline="1490"><![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteProperty(records[i].PropertyList);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteProperty(records[i].PropertyList);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="163" nfragments="2">
<clone_fragment endline="223" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" hamdist="0" pcid="6111" startline="210"><![CDATA[
 
 		public override Module LoadModule(string moduleName, byte[] rawModule)
 		{
 			int index = GetModuleIndex(moduleName);
 			if (index == -1)
 			{
 				throw new ArgumentException();
 			}
 			if (externalModules[index] != null)
 			{
 				return externalModules[index];
 			}
 			return LoadModule(index, rawModule, null);
 		}
]]></clone_fragment>
<clone_fragment endline="112" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" hamdist="11" pcid="2499" startline="92"><![CDATA[
 
 		public Type GetType(string typeName, bool throwOnError)
 		{
 			TypeNameParser parser = TypeNameParser.Parse(typeName, throwOnError);
 			if (parser.Error)
 			{
 				return null;
 			}
 			if (parser.AssemblyName != null)
 			{
 				if (throwOnError)
 				{
 					throw new ArgumentException("Type names passed to Assembly.GetType() must not specify an assembly.");
 				}
 				else
 				{
 					return null;
 				}
 			}
 			return parser.Expand(GetTypeImpl(parser.FirstNamePart), this, throwOnError, typeName);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="164" nfragments="2">
<clone_fragment endline="200" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" hamdist="0" pcid="6131" startline="191"><![CDATA[
 
 		public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
 		{
 			TypeBuilder tb = DefineType(name, attr, parent);
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			return tb;
 		}
]]></clone_fragment>
<clone_fragment endline="441" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" hamdist="4" pcid="663" startline="432"><![CDATA[
 
 		public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
 		{
 			TypeBuilder tb = DefineNestedType(name, attr, parent);
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			return tb;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="165" nfragments="73">
<clone_fragment endline="695" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="0" pcid="8933" startline="682"><![CDATA[
 
     Private Function ParseIdentifierOrKeyword(ByVal Parent As ParsedObject) As IdentifierOrKeyword
         Dim result As IdentifierOrKeyword
 
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             result = New IdentifierOrKeyword(Parent, tm.CurrentToken)
             tm.NextToken()
         Else
             Helper.AddError(Compiler, tm.CurrentLocation)
             result = Nothing
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2344" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="11" pcid="9045" startline="2322"><![CDATA[
 
     ''' <summary>
     ''' ParenthesizedExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParenthesizedExpression(ByVal Parent As ParsedObject) As ParenthesizedExpression
         Dim result As New ParenthesizedExpression(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         m_Expression = ParseExpression(result)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4704" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="6" pcid="9187" startline="4682"><![CDATA[
 
     ''' <summary>
     ''' AliasClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAliasClause(ByVal Parent As ParsedObject) As AliasClause
         Dim result As New AliasClause(Parent)
 
         Dim m_StringLiteral As Token = Nothing
 
         tm.AcceptIfNotInternalError(KS.Alias)
 
         If tm.CurrentToken.IsStringLiteral Then
             m_StringLiteral = tm.CurrentToken
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_StringLiteral)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5016" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="12" pcid="9213" startline="4994"><![CDATA[
 
     ''' <summary>
     ''' ThrowStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseThrowStatement(ByVal Parent As ParsedObject) As ThrowStatement
         Dim result As New ThrowStatement(Parent)
 
         Dim m_Exception As Expression
 
         tm.AcceptIfNotInternalError(KS.Throw)
 
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_Exception = ParseExpression(result)
             If m_Exception Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Exception = Nothing
         End If
 
         result.Init(m_Exception)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4728" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="12" pcid="9189" startline="4705"><![CDATA[
 
     ''' <summary>
     ''' LibraryClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLibraryClause(ByVal Parent As ParsedObject) As LibraryClause
         Dim result As New LibraryClause(Parent)
 
         Dim m_StringLiteral As Token
 
         tm.AcceptIfNotInternalError(KS.Lib)
 
         If tm.CurrentToken.IsStringLiteral Then
             m_StringLiteral = tm.CurrentToken
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             m_StringLiteral = Nothing
         End If
 
         result.Init(m_StringLiteral)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3930" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="15" pcid="9145" startline="3906"><![CDATA[
 
     ''' <summary>
     ''' Constraint  
     ''' LAMESPEC? Using the following
     ''' Constraint  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstraint(ByVal Parent As ParsedObject) As Constraint
         Dim result As New Constraint(Parent)
 
         Dim m_Special As KS
         Dim m_TypeName As TypeName = Nothing
 
         If tm.CurrentToken.Equals(KS.[New], KS.Class, KS.Structure) Then
             m_Special = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_TypeName, m_Special)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="225" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="14" pcid="8897" startline="202"><![CDATA[
 
     ''' <summary>
     ''' OptionExplicitStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionExplicitStatement(ByVal Parent As BaseObject) As OptionExplicitStatement
         Dim result As New OptionExplicitStatement(Parent)
 
         Dim m_Off As Boolean
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Explicit")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30640, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5182" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="14" pcid="9227" startline="5159"><![CDATA[
 
     ''' <summary>
     '''ContinueStatement  
     '''ContinueKind  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseContinueStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ContinueStatement
         Dim result As New ContinueStatement(Parent)
 
         Dim m_ContinueWhat As KS
 
         tm.AcceptIfNotInternalError(KS.Continue)
         If tm.CurrentToken.Equals(KS.Do, KS.For, KS.While) Then
             m_ContinueWhat = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30781, tm.CurrentLocation)
             Return Nothing
         End If
 
         result.Init(m_ContinueWhat)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="997" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="15" pcid="8953" startline="972"><![CDATA[
 
     ''' <summary>
     ''' BoundList
     ''' UpperBoundList
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseBoundList(ByVal Parent As ParsedObject) As BoundList
         Dim result As New BoundList(Parent)
 
         Dim newExp As Expression = Nothing
         Dim tmp As New Generic.List(Of Expression)
 
         Do
             If tm.CurrentToken.IsIntegerLiteral AndAlso tm.CurrentToken.IntegralLiteral = 0 AndAlso tm.PeekToken.Equals(KS.To) Then tm.NextToken(2)
             newExp = ParseExpression(result)
             If newExp Is Nothing Then
                 If m_ShowErrors = False Then Return Nothing
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             tmp.Add(newExp)
         Loop While tm.Accept(KS.Comma)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2253" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="12" pcid="9039" startline="2224"><![CDATA[
 
     ''' <summary>
     ''' VariableIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableIdentifier(ByVal Parent As ParsedObject) As VariableIdentifier
         Dim result As New VariableIdentifier(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier
 
         If tm.CurrentToken.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
             Return Nothing
         End If
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayNameModifier.CanBeMe(tm) Then
             m_ArrayNameModifier = ParseArrayNameModifier(result)
             If m_ArrayNameModifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ArrayNameModifier = Nothing
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="429" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="15" pcid="8913" startline="398"><![CDATA[
 
     ''' <summary>
     ''' ImportsNamespaceClause  
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     '''    
     ''' Only namespaces, classes, structures, enumerated types, and standard modules may be imported.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsNamespaceClause(ByVal Parent As ParsedObject) As ImportsNamespaceClause
         Dim result As New ImportsNamespaceClause(Parent)
 
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim qi As QualifiedIdentifier
 
         qi = ParseQualifiedIdentifier(result)
         If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If result IsNot Nothing AndAlso tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             Dim ctn As ConstructedTypeName = Nothing
             tm.RestoreToPoint(iCurrent)
             ctn = ParseConstructedTypeName(result)
             If ctn Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(ctn)
         Else
             tm.IgnoreRestoredPoint()
             result.Init(qi)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1958" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="13" pcid="9003" startline="1933"><![CDATA[
 
     Private Function ParseIdentifierOrKeywordWithTypeArguments(ByVal Parent As ParsedObject) As IdentifierOrKeywordWithTypeArguments
         Dim result As New IdentifierOrKeywordWithTypeArguments(Parent)
 
         Dim m_TypeArguments As TypeArgumentList
         Dim m_Token As Token
 
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             m_Token = tm.CurrentToken
             tm.NextToken()
         Else
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Return Nothing
         End If
 
         If tm.CurrentToken.Equals(KS.LParenthesis) AndAlso tm.PeekToken.Equals(KS.Of) Then
             m_TypeArguments = ParseTypeArgumentList(result)
             If m_TypeArguments Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeArguments = Nothing
         End If
 
         result.Init(m_Token, m_TypeArguments)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1984" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="10" pcid="9005" startline="1959"><![CDATA[
 
     ''' <summary>
     ''' DictionaryAccessExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDictionaryAccessExpression(ByVal Parent As ParsedObject, ByVal FirstPart As Expression) As DictionaryAccessExpression
         Dim result As New DictionaryAccessExpression(Parent)
 
         Dim m_FirstPart As Expression
         Dim m_SecondPart As IdentifierOrKeyword
 
         m_FirstPart = FirstPart
         If m_FirstPart IsNot Nothing Then m_FirstPart.Parent = result
         tm.AcceptIfNotInternalError(KS.Exclamation)
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             m_SecondPart = ParseIdentifierOrKeyword(result)
             If m_SecondPart Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
             Return Nothing
         End If
 
         result.Init(m_FirstPart, m_SecondPart)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3471" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="14" pcid="9117" startline="3439"><![CDATA[
 
     ''' <summary>
     ''' "TypeOf" Expression "Is" TypeName
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeOfExpression(ByVal Parent As ParsedObject) As TypeOfExpression
         Dim result As New TypeOfExpression(Parent)
 
         Dim m_Expression As Expression
         Dim m_Is As Boolean
         Dim m_Type As TypeName
 
         tm.AcceptIfNotInternalError(KS.TypeOf)
 
         m_Expression = ParseExpression(New ExpressionParseInfo(result, False, True))
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Is) Then
             m_Is = True
         ElseIf tm.Accept(KS.IsNot) Then
             m_Is = False
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             Return Nothing
         End If
 
         m_Type = ParseTypeName(result)
         If m_Type Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression, m_Is, m_Type)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1243" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="12" pcid="8967" startline="1211"><![CDATA[
 
     ''' <summary>
     ''' SimpleTypeName 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSimpleTypeName(ByVal Parent As ParsedObject) As SimpleTypeName
         Dim result As New SimpleTypeName(Parent)
 
         If BuiltInTypeName.IsBuiltInTypeName(tm) Then
             Dim m_BuiltInTypeName As BuiltInTypeName
             m_BuiltInTypeName = ParseBuiltinTypeName(result)
             If m_BuiltInTypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             result.Init(m_BuiltInTypeName)
         Else
             Dim m_QualifiedIdentifier As QualifiedIdentifier
 
             If QualifiedIdentifier.CanBeQualifiedIdentifier(tm) = False Then
                 If tm.CurrentToken.IsKeyword Then
                     Compiler.Report.ShowMessage(Messages.VBNC30180, tm.CurrentLocation)
                     tm.NextToken()
                 End If
                 Return Nothing
             End If
 
             m_QualifiedIdentifier = ParseQualifiedIdentifier(result)
             If m_QualifiedIdentifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             result.Init(m_QualifiedIdentifier)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2672" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="10" pcid="9073" startline="2646"><![CDATA[
     ''' <summary>
     ''' A single identifier followed by an optional type argument list.
     ''' 
     ''' SimpleNameExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSimpleNameExpression(ByVal Parent As ParsedObject) As SimpleNameExpression
         Dim result As New SimpleNameExpression(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeArgumentList As TypeArgumentList
 
         m_Identifier = ParseIdentifier(result)
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             m_TypeArgumentList = ParseTypeArgumentList(result)
             If m_TypeArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             'If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented()
         Else
             m_TypeArgumentList = Nothing
         End If
 
         result.Init(m_Identifier, m_TypeArgumentList)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2546" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="7" pcid="9061" startline="2518"><![CDATA[
 
     ''' <summary>
     ''' DelegateCreationExpression 
     ''' ObjectCreationExpression   
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateOrObjectCreationExpression(ByVal Parent As ParsedObject) As DelegateOrObjectCreationExpression
         Dim result As New DelegateOrObjectCreationExpression(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName = Nothing
         Dim m_ArgumentList As ArgumentList = Nothing
 
         tm.AcceptIfNotInternalError(KS.[New])
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.CurrentToken <> KS.RParenthesis Then
                 m_ArgumentList = ParseArgumentList(result)
                 If m_ArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If m_ArgumentList Is Nothing Then m_ArgumentList = New ArgumentList(result)
 
         result.Init(m_NonArrayTypeName, m_ArgumentList)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4212" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="9" pcid="9163" startline="4185"><![CDATA[
 
     ''' <summary>
     ''' EnumMemberDeclaration  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEnumMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo, ByVal EnumIndex As Integer) As EnumMemberDeclaration
         Dim result As New EnumMemberDeclaration(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ConstantExpression As Expression
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Equals) Then
             m_ConstantExpression = ParseExpression(result)
             If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ConstantExpression = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(EnumIndex, m_Identifier, m_ConstantExpression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3997" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="7" pcid="9149" startline="3975"><![CDATA[
 
     ''' <summary>
     ''' ParameterIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParameterIdentifier(ByVal Parent As Parameter) As ParameterIdentifier
         Dim result As New ParameterIdentifier(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayNameModifier.CanBeMe(tm) Then
             m_ArrayNameModifier = ParseArrayNameModifier(result)
             If m_ArrayNameModifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4127" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="10" pcid="9159" startline="4094"><![CDATA[
 
     ''' <summary>
     ''' MustOverridePropertyMemberDeclaration  
     '''	[  Attributes  ]  [  MustOverridePropertyModifier+  ]  "Property" FunctionSignature  [  ImplementsClause  ]
     '''		StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseMustOverridePropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As MustOverridePropertyDeclaration
         Dim result As New MustOverridePropertyDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
         Dim m_ImplementsClause As MemberImplementsClause = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverridePropertyModifiers)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If MemberImplementsClause.IsMe(tm) Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, , , m_ImplementsClause)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2289" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="5" pcid="9041" startline="2254"><![CDATA[
 
     ''' <summary>
     ''' RaiseEventStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRaiseEventStatement(ByVal Parent As ParsedObject) As RaiseEventStatement
         Dim result As New RaiseEventStatement(Parent)
 
         Dim m_Event As SimpleNameExpression
         Dim m_Arguments As ArgumentList
         Dim m_Identifier As IdentifierOrKeyword
 
         tm.AcceptIfNotInternalError(KS.RaiseEvent)
 
         m_Identifier = ParseIdentifierOrKeyword(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Event = New SimpleNameExpression(result)
         m_Event.Identifier = New Identifier(m_Event, m_Identifier.Identifier, m_Identifier.Location, TypeCharacters.Characters.None)
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 m_Arguments = ParseArgumentList(result)
                 If m_Arguments Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 m_Arguments = New ArgumentList(result)
             End If
         Else
             m_Arguments = Nothing
         End If
 
         result.Init(m_Event, m_Arguments)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5935" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="12" pcid="9269" startline="5892"><![CDATA[
 
     ''' <summary>
     ''' ForEachStatement  
     '''	   "For" "Each" LoopControlVariable "In" Expression  StatementTerminator
     '''	         [  Block  ]
     '''	   "Next" [Expression  ]  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseForEachStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ForEachStatement
         Dim result As New ForEachStatement(Parent)
 
         Dim m_LoopControlVariable As LoopControlVariable
         Dim m_InExpression As Expression
         Dim m_NextExpression As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.For)
         tm.AcceptIfNotInternalError(KS.Each)
 
         m_LoopControlVariable = ParseLoopControlVariable(result)
         If m_LoopControlVariable Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.In) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_InExpression = ParseExpression(result)
         If m_InExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Next) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_NextExpression = ParseExpression(result)
             If m_NextExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_NextExpression = Nothing
         End If
 
         result.Init(m_LoopControlVariable, m_InExpression, m_NextExpression, m_Code)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3823" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="10" pcid="9137" startline="3792"><![CDATA[
 
     ''' <summary>
     ''' FunctionSignature  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseFunctionSignature(ByVal Parent As ParsedObject) As FunctionSignature
         Dim result As New FunctionSignature(Parent)
 
         Dim m_Identifier As Identifier = Nothing
         Dim m_TypeParameters As TypeParameters = Nothing
         Dim m_ParameterList As New ParameterList(result)
         Dim m_ReturnTypeAttributes As New Attributes(result)
         Dim m_TypeName As TypeName = Nothing
 
         If ParseSubSignature(result, m_Identifier, m_TypeParameters, m_ParameterList) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.As) Then
             If Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_TypeParameters, m_ParameterList, m_ReturnTypeAttributes, m_TypeName, New Span(m_Identifier.Location, tm.CurrentLocation))
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4761" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="7" pcid="9191" startline="4729"><![CDATA[
 
     ''' <summary>
     ''' ConstantDeclarator  
     ''' TODO
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstantDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo, ByVal Modifiers As Modifiers) As ConstantDeclaration
         Dim result As New ConstantDeclaration(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeName As TypeName = Nothing
         Dim m_ConstantExpression As Expression = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.AcceptIfNotError(KS.Equals) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ConstantExpression = ParseExpression(result)
         If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(Modifiers, m_Identifier, m_TypeName, m_ConstantExpression)
 
         'Don't parse a StatementTerminator as the VB spec says.
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3699" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="6" pcid="9129" startline="3656"><![CDATA[
 
     ''' <summary>
     ''' PropertySetDeclaration  
     '''	[  Attributes  ]  [  AccessModifier  ]  "Set" [  (  ParameterList  )  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Set" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParsePropertySetMember(ByVal Parent As PropertyDeclaration, ByVal Info As ParseAttributableInfo, ByVal ParentSignature As FunctionSignature, ByVal ParentImplements As MemberImplementsClause, ByVal ParentModifiers As ModifierMasks) As PropertySetDeclaration
         Dim result As New PropertySetDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_ParameterList As New ParameterList(result)
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.AccessModifiers)
         If m_Modifiers.Empty = False Then
             m_Modifiers.AddModifiers(ParentModifiers And (Not ModifierMasks.AccessModifiers))
         Else
             m_Modifiers.AddModifiers(ParentModifiers)
         End If
         tm.AcceptIfNotInternalError(KS.Set)
 
         If tm.Accept(KS.LParenthesis) Then
             If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Set) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, ParentImplements, m_Block, m_ParameterList)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3974" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="12" pcid="9147" startline="3931"><![CDATA[
 
     ''' <summary>
     ''' Parameter            
     ''' ParameterModifier    
     ''' ParameterIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParameter(ByVal Parent As ParsedObject) As Parameter
         Helper.Assert(TypeOf Parent Is ParameterList)
         Dim result As New Parameter(DirectCast(Parent, ParameterList))
 
         Dim m_Attributes As New Attributes(result)
         Dim m_Modifiers As Modifiers
         Dim m_ParameterIdentifier As ParameterIdentifier
         Dim m_TypeName As TypeName
         Dim m_ConstantExpression As Expression
 
         If vbnc.Attributes.IsMe(tm) Then
             ParseAttributes(result, m_Attributes)
         End If
 
         m_Modifiers = ParseModifiers(ModifierMasks.ParameterModifiers)
 
         m_ParameterIdentifier = ParseParameterIdentifier(result)
         If m_ParameterIdentifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         If tm.Accept(KS.Equals) Then
             m_ConstantExpression = ParseExpression(result)
             If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ConstantExpression = Nothing
         End If
 
         result.Init(m_Attributes, m_Modifiers, m_ParameterIdentifier, m_TypeName, m_ConstantExpression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5607" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="10" pcid="9253" startline="5551"><![CDATA[
 
     ''' <summary>
     ''' DoLoopStatement  
     ''' DoTopLoopStatement  
     '''	   "Do" [  WhileOrUntil  BooleanExpression  ]  StatementTerminator
     '''	       [  Block  ]
     '''	   "Loop" StatementTerminator
     ''' DoBottomLoopStatement  
     '''	   "Do" StatementTerminator
     '''	       [  Block  ]
     '''	   "Loop" WhileOrUntil  BooleanExpression  StatementTerminator
     '''WhileOrUntil  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDoStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As DoStatement
         Dim result As New DoStatement(Parent)
 
         Dim m_PreCondition As Expression
         Dim m_PostCondition As Expression
         Dim m_IsWhile As Boolean
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.Do)
         If tm.CurrentToken.Equals(KS.While, KS.Until) Then
             m_PreCondition = ParseDoStatementCondition(result, m_IsWhile)
             If m_PreCondition Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             End If
         Else
             m_PreCondition = Nothing
         End If
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Loop) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.CurrentToken.Equals(KS.While, KS.Until) Then
             m_PostCondition = ParseDoStatementCondition(result, m_IsWhile)
             If m_PostCondition Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             End If
         Else
             m_PostCondition = Nothing
         End If
 
         result.Init(m_PreCondition, m_PostCondition, m_IsWhile, m_Code)
 
         If m_PreCondition IsNot Nothing AndAlso m_PostCondition IsNot Nothing Then
             'helper.AddError "error BC30238
             Compiler.Report.ShowMessage(Messages.VBNC30238, tm.CurrentLocation)
             result.HasErrors = True
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3791" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="13" pcid="9135" startline="3772"><![CDATA[
 
     ''' <summary>
     ''' SubSignature  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSubSignature(ByVal Parent As ParsedObject) As SubSignature
         Dim result As New SubSignature(Parent)
 
         Dim m_Identifier As Identifier = Nothing
         Dim m_TypeParameters As TypeParameters = Nothing
         Dim m_ParameterList As New ParameterList(result)
 
         If ParseSubSignature(result, m_Identifier, m_TypeParameters, m_ParameterList) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_TypeParameters, m_ParameterList)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3878" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="7" pcid="9141" startline="3846"><![CDATA[
 
     ''' <summary>
     ''' TypeParameter  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeParameter(ByVal Parent As ParsedObject) As TypeParameter
         Dim result As New TypeParameter(Parent)
         Dim m_Identifier As Identifier
         Dim m_TypeParameterConstraints As TypeParameterConstraints
         Dim parentList As TypeParameterList
 
         Helper.Assert(TypeOf Parent Is TypeParameterList)
 
         parentList = DirectCast(Parent, TypeParameterList)
         result.GenericParameterPosition = parentList.Count + 1
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             result.Identifier = m_Identifier
         End If
 
         If TypeParameterConstraints.CanBeMe(tm) Then
             m_TypeParameterConstraints = ParseTypeParameterConstraints(result)
             If m_TypeParameterConstraints Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.TypeParameterConstraints = m_TypeParameterConstraints
         Else
             m_TypeParameterConstraints = Nothing
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1168" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="12" pcid="8961" startline="1129"><![CDATA[
 
 
     ''' <summary>
     ''' TypeName 
     ''' 
     ''' ArrayTypeName          
     ''' ArrayTypeModifiers     
     ''' ArrayTypeModifier      
     ''' RankList               
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeName(ByVal Parent As ParsedObject) As TypeName
         Dim result As New TypeName(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName
         Dim m_ArrayTypeModifiers As ArrayTypeModifiers
         Dim m_ArrayTypeName As ArrayTypeName
 
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If m_NonArrayTypeName Is Nothing Then Return Nothing
 
         If ArrayTypeName.CanBeArrayTypeModifier(tm) Then
             m_ArrayTypeName = New ArrayTypeName(Parent)
 
             m_ArrayTypeModifiers = ParseArrayTypeModifiers(m_ArrayTypeName)
             If m_ArrayTypeModifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             m_NonArrayTypeName.Parent = m_ArrayTypeName
 
             m_ArrayTypeName.Init(m_NonArrayTypeName, m_ArrayTypeModifiers)
 
             result.Init(m_ArrayTypeName)
         Else
             result.Init(m_NonArrayTypeName)
         End If
 
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5445" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="11" pcid="9245" startline="5390"><![CDATA[
 
     ''' <summary>
     ''' Homebrew
     ''' UsingDeclarator 
     '''  Identifier  [  As  [  New  ]  NonArrayTypeName  [  (  ArgumentList  )  ]  ]  |
     '''  Identifier  [  As  NonArrayTypeName  ]  [  =  VariableInitializer  ]
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseUsingDeclarator(ByVal Parent As ParsedObject) As UsingDeclarator
         Dim result As New UsingDeclarator(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_IsNew As Boolean
         Dim m_IsVariableDeclaration As Boolean
         Dim m_TypeName As NonArrayTypeName
         Dim m_VariableInitializer As VariableInitializer = Nothing
         Dim m_ArgumentList As ArgumentList = Nothing
         Dim m_VariableDeclaration As LocalVariableDeclaration
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_IsVariableDeclaration = True
             m_IsNew = tm.Accept(KS.[New])
 
             m_TypeName = ParseNonArrayTypeName(result)
 
             If m_IsNew = False Then
                 If tm.Accept(KS.Equals) Then
                     m_VariableInitializer = ParseVariableInitializer(result)
                 End If
             Else
                 If tm.Accept(KS.LParenthesis) Then
                     If tm.Accept(KS.RParenthesis) = False Then
                         m_ArgumentList = ParseArgumentList(result)
                         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
                 End If
                 If m_ArgumentList Is Nothing Then m_ArgumentList = New ArgumentList(result)
             End If
 
             m_VariableDeclaration = New LocalVariableDeclaration(result, m_Identifier, m_IsNew, m_TypeName, m_VariableInitializer, m_ArgumentList)
         Else
             m_VariableDeclaration = Nothing
             m_VariableInitializer = Nothing
             m_ArgumentList = Nothing
             m_TypeName = Nothing
         End If
 
 
         result.Init(m_Identifier, m_IsNew, m_TypeName, m_ArgumentList, m_VariableInitializer, m_IsVariableDeclaration, m_VariableDeclaration)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1738" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="8" pcid="8991" startline="1709"><![CDATA[
 
     ''' <summary>
     ''' InterfaceEventMemberDeclaration  
     '''	[  Attributes  ]  [  InterfaceEventModifiers+  ]  "Event"  Identifier  ParametersOrType  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceEventMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceEventMemberDeclaration
         Dim result As New InterfaceEventMemberDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_ParametersOrType As ParametersOrType
 
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceEventModifiers)
 
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ParametersOrType = ParseParametersOrType(result)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_ParametersOrType, Nothing)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1808" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="4" pcid="8995" startline="1772"><![CDATA[
 
     ''' <summary>
     ''' RegularEventMemberDeclaration  
     ''' 	[  Attributes  ]  [  EventModifiers+  ]  "Event"  Identifier  ParametersOrType  [  ImplementsClause  ] StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRegularEventDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As RegularEventDeclaration
         Dim result As New RegularEventDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_ParametersOrType As ParametersOrType
         Dim m_ImplementsClause As MemberImplementsClause
 
         m_Modifiers = ParseModifiers(ModifierMasks.EventModifiers)
 
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ParametersOrType = ParseParametersOrType(result)
 
         If MemberImplementsClause.IsMe(tm) Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ImplementsClause = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_ParametersOrType, m_ImplementsClause)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="591" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="13" pcid="8925" startline="555"><![CDATA[
 
     ''' <summary>
     ''' Attribute          
     ''' AttributeModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttribute(ByVal Parent As ParsedObject) As Attribute
         Dim result As New Attribute(Parent)
 
         Dim m_IsAssembly As Boolean
         Dim m_IsModule As Boolean
         Dim m_SimpleTypeName As SimpleTypeName = Nothing
         Dim m_AttributeArguments As AttributeArguments = Nothing
 
         If tm.Accept("Assembly") Then
             m_IsAssembly = True
             If tm.AcceptIfNotError(KS.Colon) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.Accept(KS.Module) Then
             m_IsModule = True
             If tm.AcceptIfNotError(KS.Colon) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_SimpleTypeName = ParseSimpleTypeName(result)
         If m_SimpleTypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.CurrentToken <> KS.RParenthesis Then
                 m_AttributeArguments = ParseAttributeArguments(result)
                 If m_AttributeArguments Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_IsAssembly, m_IsModule, m_SimpleTypeName, m_AttributeArguments)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4528" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="15" pcid="9179" startline="4503"><![CDATA[
 
     ''' <summary>
     ''' InterfaceSubDeclaration  
     ''' [  Attributes  ]  [  InterfaceProcedureModifier+  ]  "Sub" SubSignature  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceSubDeclaration
         Dim result As New InterfaceSubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As SubSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Signature = ParseSubSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="813" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="14" pcid="8939" startline="768"><![CDATA[
 
     ''' <summary>
     ''' ArrayCreationExpression    
     ''' 
     ''' LAMESPEC? I think the following should be used
     ''' ArrayCreationExpression    
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayCreationExpression(ByVal Parent As ParsedObject) As ArrayCreationExpression
         Dim result As New ArrayCreationExpression(Parent)
 
         Dim m_ArrayElementInitializer As ArrayElementInitializer
         Dim m_NonArrayTypeName As NonArrayTypeName
         Dim m_ArrayNameModifier As ArrayNameModifier
 
         tm.AcceptIfNotInternalError(KS.[New])
 
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If tm.CurrentToken <> KS.LParenthesis Then
             If ShowErrors Then tm.AcceptIfNotError(KS.LParenthesis)
             Return Nothing
         End If
         If ArrayNameModifier.CanBeMe(tm) = False Then
             If ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC90007, tm.CurrentLocation, tm.CurrentToken.ToString)
             Return Nothing
         End If
 
         m_ArrayNameModifier = ParseArrayNameModifier(result)
         If m_ArrayNameModifier Is Nothing Then
             If m_ShowErrors = False Then Return Nothing
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.CurrentToken <> KS.LBrace Then
             If ShowErrors Then tm.AcceptIfNotError(KS.LBrace)
             Return Nothing
         End If
 
         m_ArrayElementInitializer = ParseArrayElementInitializer(result)
         If m_ArrayElementInitializer Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_NonArrayTypeName, m_ArrayNameModifier, m_ArrayElementInitializer)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4417" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="15" pcid="9171" startline="4371"><![CDATA[
 
     ''' <summary>
     ''' SubDeclaration  
     '''	[  Attributes  ]  [  ProcedureModifier+  ] "Sub" SubSignature  [  HandlesOrImplements  ]  LineTerminator
     '''	Block
     '''	"End" "Sub" StatementTerminator
     ''' 
     ''' MustOverrideSubDeclaration  
     '''	[  Attributes  ]  [  MustOverrideProcedureModifier+  ] "Sub" SubSignature  [  HandlesOrImplements  ]
     '''		StatementTerminator
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As SubDeclaration
         Dim result As New SubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As SubSignature = Nothing
         Dim m_HandlesOrImplements As HandlesOrImplements = Nothing
         Dim m_Block As CodeBlock = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverrideProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Signature = ParseSubSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.HandlesOrImplements.IsMe(tm) Then
             m_HandlesOrImplements = ParseHandlesOrImplements(result)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_Modifiers.Is(ModifierMasks.MustOverride) = False Then
             m_Block = ParseCodeBlock(result, False)
             If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             If tm.AcceptIfNotError(KS.End, KS.Sub) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_HandlesOrImplements, m_Block)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1649" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="12" pcid="8987" startline="1602"><![CDATA[
 
 
     ''' <summary>
     ''' EventAccessorDeclaration  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEventAccessorDeclarations(ByVal Parent As EventDeclaration, ByVal EventName As Identifier, ByVal EventModifiers As Modifiers) As EventAccessorDeclarations
         Dim result As New EventAccessorDeclarations(Parent)
         Dim parsing As Boolean = True
 
         Dim m_AddHandler As CustomEventHandlerDeclaration = Nothing
         Dim m_RemoveHandler As CustomEventHandlerDeclaration = Nothing
         Dim m_RaiseEvent As CustomEventHandlerDeclaration = Nothing
 
         Do
             Dim attributes As Attributes
             attributes = New Attributes(result)
             If vbnc.Attributes.IsMe(tm) Then
                 ParseAttributes(result, attributes)
             End If
             If CustomEventHandlerDeclaration.IsMe(tm) Then
                 Dim newMember As CustomEventHandlerDeclaration
                 newMember = ParseCustomEventHandlerDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes), EventName, EventModifiers)
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Select Case newMember.HandlerType
                     Case KS.AddHandler
                         m_AddHandler = newMember
                     Case KS.RemoveHandler
                         m_RemoveHandler = newMember
                     Case KS.RaiseEvent
                         m_RaiseEvent = newMember
                     Case Else
                         Throw New InternalException(result)
                 End Select
             Else
                 If attributes IsNot Nothing AndAlso attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation)
                 End If
                 Exit Do
             End If
         Loop
 
         result.Init(m_AddHandler, m_RemoveHandler, m_RaiseEvent)
 
         result.HasErrors = m_AddHandler IsNot Nothing AndAlso m_RemoveHandler IsNot Nothing AndAlso m_RaiseEvent IsNot Nothing
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4613" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="12" pcid="9183" startline="4555"><![CDATA[
 
     ''' <summary>
     ''' ExternalSubDeclaration 
     ''' 	[  Attributes  ]  [  ExternalMethodModifier+  ] "Declare" [  CharsetModifier  ] "Sub" Identifier
     '''		LibraryClause  [  AliasClause  ]  [  (  [  ParameterList  ]  )  ]  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExternalSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ExternalSubDeclaration
         Dim result As New ExternalSubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_CharsetModifier As KS
         Dim m_Identifier As Identifier
         Dim m_LibraryClause As LibraryClause = Nothing
         Dim m_AliasClause As AliasClause = Nothing
         Dim m_ParameterList As ParameterList = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.ExternalMethodModifiers)
 
         tm.AcceptIfNotInternalError(KS.Declare)
 
         If tm.CurrentToken.Equals(ModifierMasks.CharSetModifiers) Then
             m_CharsetModifier = tm.CurrentToken.Keyword
             tm.NextToken()
         End If
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_LibraryClause = ParseLibraryClause(result)
         If m_LibraryClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If AliasClause.IsMe(tm) Then
             m_AliasClause = ParseAliasClause(result)
             If m_AliasClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.LParenthesis) Then
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
 
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_CharsetModifier, m_Identifier, m_LibraryClause, m_AliasClause, m_ParameterList)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="6459" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="8" pcid="9295" startline="6404"><![CDATA[
 
     ''' <summary>
     ''' InterfaceDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Interface" Identifier  [  TypeParameters  ]  StatementTerminator
     '''	[  InterfaceBase+  ]
     '''	[  InterfaceMemberDeclaration+  ]
     '''	"End" "Interface" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As InterfaceDeclaration
         Dim result As InterfaceDeclaration
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_GenericName As Identifier
         Dim m_TypeParameters As TypeParameters
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Interface)
 
         m_Identifier = ParseIdentifier()
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_TypeParameters = ParseTypeParameters(Parent)
             If m_TypeParameters Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_GenericName = Helper.CreateGenericTypename(m_Identifier, m_TypeParameters)
         Else
             m_TypeParameters = Nothing
             m_GenericName = m_Identifier
         End If
 
         result = New InterfaceDeclaration(Parent, [Namespace], m_GenericName, m_TypeParameters)
 
         If m_TypeParameters IsNot Nothing Then
             m_TypeParameters.Parent = result
         End If
 
         If InterfaceBases.IsMe(tm) Then
             result.InterfaceBases = ParseInterfaceBases(result)
             If result.InterfaceBases Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If ParseInterfaceMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Interface) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = m_Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="6567" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="5" pcid="9299" startline="6500"><![CDATA[
 
     ''' <summary>
     ''' StructureDeclaration  
     '''	[  Attributes  ]  [  StructureModifier+  ]  "Structure" Identifier  [  TypeParameters  ]	StatementTerminator
     '''	[  TypeImplementsClause+  ]
     '''	[  StructMemberDeclaration+  ]
     '''	"End" "Structure"  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseStructureDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As StructureDeclaration
         Dim result As StructureDeclaration = Nothing
         Dim partialType As PartialTypeDeclaration
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_TypeParameters As TypeParameters
         Dim m_DeclaringType As TypeDeclaration
         Dim m_Attributes As Attributes
 
         m_DeclaringType = TryCast(Parent, TypeDeclaration)
         Helper.Assert(m_DeclaringType IsNot Nothing OrElse TypeOf Parent Is AssemblyDeclaration)
 
         m_Attributes = Attributes
         m_Modifiers = ParseModifiers(ModifierMasks.StructureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Structure)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_TypeParameters = ParseTypeParameters(result)
             If m_TypeParameters Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeParameters = Nothing
         End If
 
         'Here we have enough information to know if it's a partial type or not
         partialType = GetPartialType(Parent, m_Identifier, m_TypeParameters, m_Modifiers, False, [Namespace])
 
         result = TryCast(partialType, StructureDeclaration)
         If result Is Nothing Then
             If partialType IsNot Nothing Then
                 Helper.AddError(tm.Compiler, tm.CurrentLocation, "Partial types must be either all classes or all structures.")
             Else
                 'Error message has already been shown
             End If
             Return Nothing
         End If
 
         m_Identifier.Parent = result
         If m_TypeParameters IsNot Nothing Then
             m_TypeParameters.Parent = result
         End If
 
         result.Implements = ParseTypeImplementsClauses(result)
         If result.Implements Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If ParseTypeMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Structure) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4681" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="5" pcid="9185" startline="4614"><![CDATA[
 
     ''' <summary>
     ''' ExternalFunctionDeclaration  
     '''	[  Attributes  ]  [  ExternalMethodModifier+  ]  "Declare" [  CharsetModifier  ] "Function" Identifier
     '''		LibraryClause  [  AliasClause  ]  [  (  [  ParameterList  ]  )  ]  [  As  [  Attributes  ]  TypeName  ]
     '''		StatementTerminator
     ''' 
     ''' CharsetModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExternalFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ExternalFunctionDeclaration
         Dim result As New ExternalFunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_CharsetModifier As KS = KS.None
         Dim m_Identifier As Identifier
         Dim m_LibraryClause As LibraryClause = Nothing
         Dim m_AliasClause As AliasClause = Nothing
         Dim m_ParameterList As ParameterList = Nothing
         Dim m_ReturnTypeAttributes As Attributes = Nothing
         Dim m_TypeName As TypeName = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.ExternalMethodModifiers)
         tm.AcceptIfNotInternalError(KS.Declare)
 
         If tm.CurrentToken.Equals(ModifierMasks.CharSetModifiers) Then
             m_CharsetModifier = tm.CurrentToken.Keyword
             tm.NextToken()
         End If
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_LibraryClause = ParseLibraryClause(result)
         If m_LibraryClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If AliasClause.IsMe(tm) Then
             m_AliasClause = ParseAliasClause(result)
             If m_AliasClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.Accept(KS.LParenthesis) Then
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
 
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         If tm.Accept(KS.As) Then
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_CharsetModifier, m_Identifier, m_LibraryClause, m_AliasClause, m_ParameterList, m_ReturnTypeAttributes, m_TypeName)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4944" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="8" pcid="9207" startline="4878"><![CDATA[
 
     ''' <summary>
     ''' VariableDeclarator  
     '''  	VariableIdentifiers  [  As  [  New  ]  TypeName  [  (  ArgumentList  )  ]  ]  |
     '''     VariableIdentifier   [  As  TypeName  ]  [  =  VariableInitializer  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableDeclarator(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo, ByVal result As IList, ByVal local As Boolean) As Boolean
         Dim m_VariableIdentifiers As VariableIdentifiers
         Dim m_IsNew As Boolean
         Dim m_TypeName As TypeName
         Dim m_VariableInitializer As VariableInitializer
         Dim m_ArgumentList As ArgumentList
 
         m_VariableIdentifiers = ParseVariableIdentifiers(Parent)
         If m_VariableIdentifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_IsNew = tm.Accept(KS.[New])
             If m_IsNew Then
                 'Arrays not allowed.
                 Dim m_NonArrayTypeName As NonArrayTypeName
                 m_NonArrayTypeName = ParseNonArrayTypeName(Parent)
                 If m_NonArrayTypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_TypeName = New TypeName(Parent, m_NonArrayTypeName)
             Else
                 'Arrays allowed.
                 m_TypeName = ParseTypeName(Parent)
                 If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         Else
             m_TypeName = Nothing
         End If
 
         If tm.Accept(KS.Equals) Then
             m_VariableInitializer = ParseVariableInitializer(Parent)
             If m_VariableInitializer Is Nothing Then Compiler.Report.ShowMessage(Messages.VBNC30201, tm.CurrentLocation)
             m_ArgumentList = Nothing
         ElseIf tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 m_ArgumentList = ParseArgumentList(Parent)
                 If m_ArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 m_ArgumentList = New ArgumentList(Parent)
             End If
             m_VariableInitializer = Nothing
         Else
             m_VariableInitializer = Nothing
             m_ArgumentList = Nothing
         End If
 
         'result Dim result As New Generic.List(Of VariableDeclaration)
         For Each identifier As VariableIdentifier In m_VariableIdentifiers
             Dim varD As VariableDeclaration
             If local Then
                 varD = New LocalVariableDeclaration(Parent, Modifiers, identifier, m_IsNew, m_TypeName, m_VariableInitializer, m_ArgumentList)
             Else
                 varD = New TypeVariableDeclaration(Parent, Modifiers, identifier, m_IsNew, m_TypeName, m_VariableInitializer, m_ArgumentList)
             End If
             varD.Location = identifier.Location
             varD.CustomAttributes = Info.Attributes
             result.Add(varD)
         Next
 
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="921" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="7" pcid="8947" startline="890"><![CDATA[
 
     ''' <summary>
     ''' ArraySizeInitializationModifier  
     ''' LAMESPEC this might be correct? REMOVED, CURRENTLY USING ^ SPEC!
     ''' ArraySizeInitializationModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArraySizeInitializationModifer(ByVal Parent As ParsedObject) As ArraySizeInitializationModifier
         Dim result As New ArraySizeInitializationModifier(Parent)
 
         Dim m_BoundList As BoundList = Nothing
         Dim m_ArrayTypeModifiers As ArrayTypeModifiers = Nothing
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         m_BoundList = ParseBoundList(result)
         If m_BoundList Is Nothing Then
             If m_ShowErrors = False Then Return Nothing
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayTypeModifiers.CanBeMe(tm) Then
             m_ArrayTypeModifiers = ParseArrayTypeModifiers(result)
             If m_ArrayTypeModifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_BoundList, m_ArrayTypeModifiers)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3570" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="11" pcid="9125" startline="3526"><![CDATA[
 
     ''' <summary>
     ''' ConstructorMemberDeclaration  
     ''' [  Attributes  ]  [  ConstructorModifier+  ]  "Sub" "New" [  "("  [  ParameterList  ]  ")"  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Sub" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstructorMember(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ConstructorDeclaration
         Dim result As New ConstructorDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_ParameterList As New ParameterList(result)
         Dim m_Signature As SubSignature
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.ConstructorModifiers)
 
         tm.AcceptIfNotInternalError(KS.Sub)
         tm.AcceptIfNotInternalError(KS.[New])
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         m_Signature = New SubSignature(result, "", m_ParameterList)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Sub) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_Block)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="6072" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="8" pcid="9275" startline="6040"><![CDATA[
 
     ''' <summary>
     ''' AddHandlerStatement  
     ''' RemoveHandlerStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAddOrRemoveHandlerStatement(ByVal Parent As ParsedObject) As AddOrRemoveHandlerStatement
         Dim result As New AddOrRemoveHandlerStatement(Parent)
 
         Dim m_Event As Expression
         Dim m_EventHandler As Expression
         Dim m_IsAddHandler As Boolean
 
         If tm.Accept(KS.AddHandler) Then
             m_IsAddHandler = True
         ElseIf tm.Accept(KS.RemoveHandler) Then
             m_IsAddHandler = False
         Else
             Throw New InternalException(result)
         End If
 
         m_Event = ParseExpression(result)
         If m_Event Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Comma) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_EventHandler = ParseExpression(result)
         If m_EventHandler Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Event, m_EventHandler, m_IsAddHandler)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1708" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="11" pcid="8989" startline="1650"><![CDATA[
 
     ''' <summary>
     ''' CustomEventMemberDeclaration  
     '''	[  Attributes  ]  [  EventModifiers+  ]  "Custom" "Event" Identifier "As" TypeName  [  ImplementsClause  ]
     '''		StatementTerminator
     '''		EventAccessorDeclaration+
     '''	"End" "Event" StatementTerminator
     ''' 
     ''' LAMESPEC!!! Using the following
     ''' CustomEventMemberDeclaration  
     '''	[  Attributes  ]  [  EventModifiers+  ]  "Custom" "Event" Identifier "As" NonArrayTypeName  [  ImplementsClause  ]
     '''		StatementTerminator
     '''		EventAccessorDeclaration+
     '''	"End" "Event" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCustomEventMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As CustomEventDeclaration
         Dim result As New CustomEventDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_TypeName As NonArrayTypeName
         Dim m_ImplementsClause As MemberImplementsClause = Nothing
         Dim m_EventAccessorDeclarations As EventAccessorDeclarations = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.EventModifiers)
 
         tm.AcceptIfNotInternalError("Custom")
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.As) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_TypeName = ParseNonArrayTypeName(result)
         If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_EventAccessorDeclarations = ParseEventAccessorDeclarations(result, m_Identifier, m_Modifiers)
         If m_EventAccessorDeclarations Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Event) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_TypeName, m_ImplementsClause)
 
         result.AddMethod = m_EventAccessorDeclarations.AddHandler
         result.RemoveMethod = m_EventAccessorDeclarations.RemoveHandler
         result.RaiseMethod = m_EventAccessorDeclarations.RaiseEvent
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5389" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="12" pcid="9243" startline="5360"><![CDATA[
 
     ''' <summary>
     ''' WithStatement  
     '''	   "With" Expression  StatementTerminator
     '''	        [  Block  ]
     '''	   "End" "With" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseWithStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As WithStatement
         Dim result As New WithStatement(Parent)
 
         Dim m_WithExpression As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.With)
 
         m_WithExpression = ParseExpression(result)
         If m_WithExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         m_Code = ParseCodeBlock(result, IsOneLiner)
 
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.End, KS.With) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Code, m_WithExpression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2487" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="10" pcid="9057" startline="2442"><![CDATA[
 
     ''' <summary>
     ''' LoopControlVariable  
     '''	   Identifier  [  ArrayNameModifier  ] "As" TypeName  |
     '''	   Expression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLoopControlVariable(ByVal Parent As ParsedObject) As LoopControlVariable
         Dim result As New LoopControlVariable(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier = Nothing
         Dim m_TypeName As TypeName = Nothing
         Dim m_Expression As Expression = Nothing
 
         'First try first option
         Dim tmpANM As ArrayNameModifier = Nothing
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim doExpression As Boolean = True
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If m_Identifier IsNot Nothing Then
             If ArrayNameModifier.CanBeMe(tm) Then
                 tmpANM = ParseArrayNameModifier(result)
                 If tmpANM Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tmpANM Is Nothing AndAlso tm.Accept(KS.As) Then
                 m_ArrayNameModifier = tmpANM
                 m_TypeName = ParseTypeName(result)
                 If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 doExpression = False
             End If
         End If
 
         If doExpression Then
             tm.RestoreToPoint(iCurrent)
             m_Expression = ParseExpression(New ExpressionParseInfo(result, True))
             If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             tm.IgnoreRestoredPoint()
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier, m_TypeName, m_Expression)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="6403" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="11" pcid="9293" startline="6359"><![CDATA[
 
     ''' <summary>
     ''' EnumDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Enum"  Identifier  [  "As"  IntegralTypeName  ]  StatementTerminator
     '''	   EnumMemberDeclaration+
     '''	"End" "Enum"  StatementTerminator
     ''' 
     ''' LAMESPEC
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEnumDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As EnumDeclaration
         Dim result As EnumDeclaration
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_QualifiedName As KS = KS.Integer
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Enum)
 
         m_Identifier = ParseIdentifier()
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             If tm.CurrentToken.Equals(Enums.IntegralTypeNames) Then
                 m_QualifiedName = tm.CurrentToken.Keyword
                 tm.NextToken()
             Else
                 Helper.AddError(Compiler, tm.CurrentLocation, "Enum type must be integral")
             End If
         End If
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result = New EnumDeclaration(Parent, [Namespace], m_Identifier, m_QualifiedName)
 
         If ParseEnumMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Enum) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = m_Modifiers
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3905" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="7" pcid="9143" startline="3879"><![CDATA[
 
     ''' <summary>
     ''' TypeParameterConstraints  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeParameterConstraints(ByVal Parent As ParsedObject) As TypeParameterConstraints
         Dim result As New TypeParameterConstraints(Parent)
 
         tm.AcceptIfNotInternalError(KS.As)
 
         Dim m_ConstraintList As New ConstraintList(result)
 
         If tm.Accept(KS.LBrace) Then
             If ParseList(Of Constraint)(m_ConstraintList, New ParseDelegate_Parent(Of Constraint)(AddressOf ParseConstraint), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             Dim tmpConstraint As Constraint = Nothing
             tmpConstraint = ParseConstraint(result)
             m_ConstraintList = New ConstraintList(result, tmpConstraint)
         End If
 
         result.Init(m_ConstraintList)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="6499" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="8" pcid="9297" startline="6460"><![CDATA[
 
     ''' <summary>
     ''' ModuleDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Module"  Identifier  StatementTerminator
     '''	[  ModuleMemberDeclaration+  ]
     '''	"End" "Module" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseModuleDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As ModuleDeclaration
         Dim result As ModuleDeclaration
 
         Dim m_Modifiers As Modifiers
         Dim m_Name As Identifier
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Module)
 
         m_Name = ParseIdentifier()
         If m_Name Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result = New ModuleDeclaration(Parent, [Namespace], m_Name)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If ParseTypeMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Module) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If result.CustomAttributes IsNot Nothing Then
             result.CustomAttributes.AddRange(Attributes)
         Else
             result.CustomAttributes = Attributes
         End If
         result.Modifiers = m_Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="6003" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="11" pcid="9271" startline="5936"><![CDATA[
 
     ''' <summary>
     ''' ForStatement  
     '''	   "For" LoopControlVariable  "="  Expression  "To"  Expression  [  "Step"  Expression  ]  StatementTerminator
     '''	      [ Block  ]
     '''	   "Next" [  NextExpressionList  ]  StatementTerminator
     ''' LoopControlVariable  
     '''	   Identifier  [  ArrayNameModifier  ] "As" TypeName  |
     '''	   Expression
     ''' NextExpressionList  
     '''	   Expression  |
     '''	   NextExpressionList "," Expression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseForStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ForStatement
         Dim result As New ForStatement(Parent)
 
         Dim m_LoopControlVariable As LoopControlVariable
         Dim m_LoopStartExpression As Expression
         Dim m_LoopEndExpression As Expression
         Dim m_LoopStepExpression As Expression
         Dim m_NextExpressionList As ExpressionList
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.For)
         m_LoopControlVariable = ParseLoopControlVariable(result)
         If m_LoopControlVariable Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Equals) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_LoopStartExpression = ParseExpression(result)
         If m_LoopStartExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.To) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_LoopEndExpression = ParseExpression(result)
         If m_LoopEndExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Step) Then
             m_LoopStepExpression = ParseExpression(result)
             If m_LoopStepExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_LoopStepExpression = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Next) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30084, tm.CurrentLocation)
             Return result
         End If
 
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_NextExpressionList = New ExpressionList(result)
             If ParseList(Of Expression)(m_NextExpressionList, New ParseDelegate_Parent(Of Expression)(AddressOf ParseExpression), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         Else
             m_NextExpressionList = Nothing
         End If
 
         result.Init(m_LoopControlVariable, m_LoopStartExpression, m_LoopEndExpression, m_LoopStepExpression, m_NextExpressionList, m_Code)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="6039" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="10" pcid="9273" startline="6004"><![CDATA[
 
     Private Function ParseCaseClause(ByVal Parent As ParsedObject) As CaseClause
         Dim result As New CaseClause(Parent)
 
         Dim m_Expression1 As Expression
         Dim m_Expression2 As Expression = Nothing
         Dim m_Comparison As KS
 
         If tm.Accept(KS.Is) Then
             If tm.CurrentToken.Equals(CaseClause.RelationalOperators) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30239, tm.CurrentLocation)
                 m_Comparison = KS.Equals
             Else
                 m_Comparison = tm.CurrentToken.Symbol
                 tm.NextToken()
             End If
             m_Expression1 = ParseExpression(result)
             If m_Expression1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken.Equals(CaseClause.RelationalOperators) Then
             m_Comparison = tm.CurrentToken.Symbol
             tm.NextToken()
             m_Expression1 = ParseExpression(result)
             If m_Expression1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Expression1 = ParseExpression(result)
             If m_Expression1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.Accept(KS.To) Then
                 m_Expression2 = ParseExpression(result)
                 If m_Expression2 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         result.Init(m_Expression1, m_Expression2, m_Comparison)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4239" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="20" pcid="9165" startline="4213"><![CDATA[
 
     ''' <summary>
     ''' Operand  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOperand(ByVal Parent As ParsedObject) As Operand
         Dim result As New Operand(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeName As TypeName
 
         tm.Accept(KS.ByVal)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         result.Init(m_Identifier, m_TypeName)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5651" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="17" pcid="9255" startline="5608"><![CDATA[
 
     ''' <summary>
     '''TryStatement  
     '''	"Try" StatementTerminator
     '''	   [  Block  ]
     '''	[  CatchStatement+  ]
     '''	[  FinallyStatement  ]
     '''	"End" "Try" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTryStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As TryStatement
         Dim result As New TryStatement(Parent)
 
         Dim m_TryCode As CodeBlock
         Dim m_FinallyBlock As CodeBlock
         Dim m_Catches As BaseObjects(Of CatchStatement)
 
         tm.AcceptIfNotInternalError(KS.Try)
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_TryCode = ParseCodeBlock(result, IsOneLiner)
         If m_TryCode Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Catches = New BaseObjects(Of CatchStatement)(result)
         While tm.CurrentToken = KS.Catch
             Dim newCatch As CatchStatement
             newCatch = ParseCatchStatement(result, IsOneLiner)
             m_Catches.Add(newCatch)
         End While
         While tm.CurrentToken = KS.Catch
             Dim newCatch As CatchStatement
             newCatch = ParseCatchStatement(result, IsOneLiner)
             m_Catches.Add(newCatch)
         End While
 
         If tm.Accept(KS.Finally) Then
             If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_FinallyBlock = ParseCodeBlock(result, IsOneLiner)
             If m_FinallyBlock Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_FinallyBlock = Nothing
         End If
 
         If tm.Accept(KS.End, KS.Try) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Catches, m_TryCode, m_FinallyBlock)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="2321" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="9" pcid="9043" startline="2290"><![CDATA[
 
     ''' <summary>
     ''' InvocationExpression
     ''' IndexExpression
     ''' Note that for the index expression the parenthesis are not optional.
     ''' This is reflected by the fact that m_ArgumentList is not nothing if 
     ''' parenthesis are provided.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInvocationOrIndexExpression(ByVal Parent As ParsedObject, ByVal First As Expression) As InvocationOrIndexExpression
         Dim result As New InvocationOrIndexExpression(Parent)
 
         Dim m_Expression As Expression
         Dim m_ArgumentList As ArgumentList
 
         m_Expression = First
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 m_ArgumentList = ParseArgumentList(result)
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 m_ArgumentList = New ArgumentList(result)
             End If
         Else
             m_ArgumentList = Nothing
         End If
 
         result.Init(m_Expression, m_ArgumentList)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4184" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="13" pcid="9161" startline="4128"><![CDATA[
 
     ''' <summary>
     ''' ConversionOperatorDeclaration    
     '''	[  Attributes  ]  [  ConversionOperatorModifier+  ]  "Operator" "CType" "("  Operand  ")"
     '''		[  "As"  [  Attributes  ]  TypeName  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Operator" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConversionOperatorDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ConversionOperatorDeclaration
         Dim result As New ConversionOperatorDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Operator As Token = Nothing
         Dim m_Operand As Operand = Nothing
         Dim m_ReturnTypeAttributes As Attributes = Nothing
         Dim m_TypeName As TypeName = Nothing
         Dim m_Block As CodeBlock = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.ConversionOperatorModifiers)
 
         tm.AcceptIfNotInternalError(KS.Operator)
 
         If vbnc.ConversionOperatorDeclaration.IsOverloadableConversionOperator(tm.CurrentToken) Then
             m_Operator = tm.CurrentToken 
         Else
             Throw New InternalException(result)
         End If
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Operand = ParseOperand(result)
         If m_Operand Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Operator) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Operator, m_Operand, m_ReturnTypeAttributes, m_TypeName, m_Block)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4966" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="11" pcid="9209" startline="4945"><![CDATA[
 
     Private Function ParseInterfacePropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfacePropertyMemberDeclaration
         Dim result As New InterfacePropertyMemberDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfacePropertyModifier)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, Nothing)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="6256" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="9" pcid="9285" startline="6166"><![CDATA[
     ''' <summary>
     ''' ClassDeclaration  
     '''	[  Attributes  ]  [  ClassModifier+  ]  "Class"  Identifier  [  TypeParameters  ]  StatementTerminator
     '''	[  ClassBase  ]
     '''	[  TypeImplementsClause+  ]
     '''	[  ClassMemberDeclaration+  ]
     '''	"End" "Class" StatementTerminator
     ''' 
     ''' ClassBase 
     ''' </summary>
     ''' <param name="Parent">Should be the declaring type of the assembly itself it is not a nested type.</param>
     ''' <param name="Attributes"></param>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseClassDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As ClassDeclaration
         Dim result As ClassDeclaration
         Dim partialType As PartialTypeDeclaration
 
         Dim m_Attributes As Attributes
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_TypeParameters As TypeParameters
         Dim m_Inherits As NonArrayTypeName
         Dim m_DeclaringType As TypeDeclaration
 
         m_DeclaringType = TryCast(Parent, TypeDeclaration)
         Helper.Assert(m_DeclaringType IsNot Nothing OrElse TypeOf Parent Is AssemblyDeclaration)
 
         m_Attributes = Attributes
         m_Modifiers = ParseModifiers(ModifierMasks.ClassModifiers)
 
         tm.AcceptIfNotInternalError(KS.Class)
 
         m_Identifier = ParseIdentifier(CType(Nothing, ParsedObject))
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_TypeParameters = ParseTypeParameters(Nothing)
             If m_TypeParameters Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeParameters = Nothing
         End If
 
         'Here we have enough information to know if it's a partial type or not
         partialType = GetPartialType(Parent, m_Identifier, m_TypeParameters, m_Modifiers, True, [Namespace])
 
         result = TryCast(partialType, ClassDeclaration)
         If result Is Nothing Then
             If partialType IsNot Nothing Then
                 Helper.AddError(tm.Compiler, tm.CurrentLocation, "Partial types must be either all classes or all structures.")
             Else
                 'Error message has already been shown
             End If
             Return Nothing
         End If
 
         m_Identifier.Parent = result
         If m_TypeParameters IsNot Nothing Then
             m_TypeParameters.Parent = result
         End If
 
         If tm.Accept(KS.Inherits) Then
             m_Inherits = ParseNonArrayTypeName(result)
             If m_Inherits Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Inherits = Nothing
         End If
         If m_Inherits IsNot Nothing Then result.AddInheritsClause(m_Inherits)
 
         If TypeImplementsClauses.IsMe(tm) Then
             result.Implements = ParseTypeImplementsClauses(result)
             If result.Implements Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If ParseTypeMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Class) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If result.CustomAttributes IsNot Nothing Then
             result.CustomAttributes.AddRange(Attributes)
         Else
             result.CustomAttributes = Attributes
         End If
         result.UpdateDefinition()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1062" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="9" pcid="8955" startline="998"><![CDATA[
 
     ''' <summary>
     ''' NonArrayTypeName  
     ''' SimpleTypeName    
     ''' BuiltInTypeName   
     ''' PrimitiveTypeName      
     ''' NumericTypeName        
     ''' IntegralTypeName       
     ''' FloatingPointTypeName  
     ''' ConstructedTypeName    
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseNonArrayTypeName(ByVal Parent As ParsedObject) As NonArrayTypeName
         Dim result As New NonArrayTypeName(Parent)
 
         Dim m_SimpleTypeName As SimpleTypeName
         Dim m_ConstructedTypeName As ConstructedTypeName
 
         m_SimpleTypeName = ParseSimpleTypeName(result)
 
         If m_SimpleTypeName Is Nothing Then Return Nothing
 
         If m_SimpleTypeName.IsQualifiedIdentifier AndAlso tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             Dim m_TypeArgumentList As TypeArgumentList
             Dim m_Q As QualifiedIdentifier
             Dim m_NestedTypeName As ConstructedTypeName
 
             m_TypeArgumentList = ParseTypeArgumentList(result)
             If m_TypeArgumentList Is Nothing Then Return Nothing
             m_ConstructedTypeName = New ConstructedTypeName(result)
             m_ConstructedTypeName.Init(m_SimpleTypeName.AsQualifiedIdentifier, m_TypeArgumentList)
 
             Do While tm.Accept(KS.Dot)
                 m_Q = ParseQualifiedIdentifier(result)
                 m_TypeArgumentList = Nothing
 
                 m_NestedTypeName = New ConstructedTypeName(m_ConstructedTypeName)
 
                 If tm.Accept(KS.LParenthesis) Then
                     tm.AcceptIfNotError(KS.Of)
 
                     m_TypeArgumentList = New TypeArgumentList(m_NestedTypeName)
                     If ParseList(Of TypeName)(m_TypeArgumentList, New ParseDelegate_Parent(Of TypeName)(AddressOf ParseTypeName), Parent) = False Then
                         Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
 
                     tm.AcceptIfNotError(KS.RParenthesis)
                 End If
 
                 m_NestedTypeName.Init(m_ConstructedTypeName, m_Q, m_TypeArgumentList)
 
                 m_ConstructedTypeName = m_NestedTypeName
             Loop
             Do While tm.Accept(KS.Dot)
                 m_Q = ParseQualifiedIdentifier(result)
                 m_TypeArgumentList = Nothing
 
                 m_NestedTypeName = New ConstructedTypeName(m_ConstructedTypeName)
 
                 If tm.Accept(KS.LParenthesis) Then
                     tm.AcceptIfNotError(KS.Of)
 
                     m_TypeArgumentList = New TypeArgumentList(m_NestedTypeName)
                     If ParseList(Of TypeName)(m_TypeArgumentList, New ParseDelegate_Parent(Of TypeName)(AddressOf ParseTypeName), Parent) = False Then
                         Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
 
                     tm.AcceptIfNotError(KS.RParenthesis)
                 End If
 
                 m_NestedTypeName.Init(m_ConstructedTypeName, m_Q, m_TypeArgumentList)
 
                 m_ConstructedTypeName = m_NestedTypeName
             Loop
 
             result.Init(m_ConstructedTypeName)
         Else
             result.Init(m_SimpleTypeName)
         End If
 
         If tm.Accept(KS.Interrogation) Then
             result.IsNullable = True
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1771" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="13" pcid="8993" startline="1739"><![CDATA[
 
     ''' <summary>
     ''' ParametersOrType  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParametersOrType(ByVal Parent As ParsedObject) As ParametersOrType
         Dim result As New ParametersOrType(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName
         Dim m_ParameterList As ParameterList
 
         If tm.Accept(KS.As) Then
             m_NonArrayTypeName = ParseNonArrayTypeName(result)
             result.Init(m_NonArrayTypeName)
         Else
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.LParenthesis) Then
                 If tm.Accept(KS.RParenthesis) = False Then
                     If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                         Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
                     If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Else
                     m_ParameterList = New ParameterList(result)
                 End If
                 result.Init(m_ParameterList)
             Else
                 result.Init(m_ParameterList)
             End If
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4370" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="15" pcid="9169" startline="4322"><![CDATA[
 
     ''' <summary>
     ''' FunctionDeclaration  
     '''	[  Attributes  ]  [  ProcedureModifier+  ]  "Function" FunctionSignature  [  HandlesOrImplements  ]
     '''		LineTerminator
     '''	Block
     '''	"End" "Function" StatementTerminator
     ''' 
     ''' MustOverrideFunctionDeclaration  
     '''	[  Attributes  ]  [  MustOverrideProcedureModifier+  ]  "Function" FunctionSignature
     '''		[  HandlesOrImplements  ]  StatementTerminator
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As FunctionDeclaration
         Dim result As New FunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
         Dim m_HandlesOrImplements As HandlesOrImplements = Nothing
         Dim m_Block As CodeBlock = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverrideProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.HandlesOrImplements.IsMe(tm) Then
             m_HandlesOrImplements = ParseHandlesOrImplements(result)
             If m_HandlesOrImplements Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_Modifiers.Is(ModifierMasks.MustOverride) = False Then
             m_Block = ParseCodeBlock(result, False)
             If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             If tm.AcceptIfNotError(KS.End, KS.Function) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_HandlesOrImplements, m_Block)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5879" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="13" pcid="9265" startline="5840"><![CDATA[
 
     ''' <summary>
     ''' CaseStatement  
     '''	   "Case" CaseClauses  StatementTerminator
     '''	        [  Block  ]
     ''' CaseElseStatement  
     '''	   "Case" "Else" StatementTerminator
     '''	   [  Block  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCaseStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As CaseStatement
         Dim result As New CaseStatement(Parent)
 
         Dim m_IsElse As Boolean
         Dim m_Clauses As CaseClauses
         Dim m_Block As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.Case)
         If tm.Accept(KS.Else) Then
             m_IsElse = True
             m_Clauses = Nothing
         Else
             m_Clauses = New CaseClauses(result)
             If ParseList(Of CaseClause)(m_Clauses, New ParseDelegate_Parent(Of CaseClause)(AddressOf ParseCaseClause), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         m_Block = ParseCodeBlock(result, IsOneLiner)
         If m_Block Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_IsElse, m_Clauses, m_Block)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3734" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="9" pcid="9131" startline="3700"><![CDATA[
 
     ''' <summary>
     ''' PropertyGetDeclaration  
     '''	[  Attributes  ]  [  AccessModifier  ]  Get  LineTerminator
     '''	[  Block  ]
     '''	End  Get  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParsePropertyGetMember(ByVal Parent As PropertyDeclaration, ByVal Info As ParseAttributableInfo, ByVal ParentSignature As FunctionSignature, ByVal ParentImplements As MemberImplementsClause, ByVal ParentModifiers As ModifierMasks) As PropertyGetDeclaration
         Dim result As New PropertyGetDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.AccessModifiers)
         If m_Modifiers.Empty = False Then
             m_Modifiers.AddModifiers(ParentModifiers And (Not ModifierMasks.AccessModifiers))
         Else
             m_Modifiers.AddModifiers(ParentModifiers)
         End If
 
         tm.AcceptIfNotInternalError(KS.Get)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Get) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, ParentImplements, m_Block)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3012" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="14" pcid="9085" startline="2993"><![CDATA[
     ''' <summary>
     ''' GetTypeExpression 
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseGetTypeExpression(ByVal Parent As ParsedObject) As GetTypeExpression
         Dim result As New GetTypeExpression(Parent)
 
         tm.AcceptIfNotInternalError(KS.GetType)
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Dim m_TypeName As GetTypeTypeName
         m_TypeName = ParseGetTypeTypeName(result)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_TypeName)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5691" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="16" pcid="9257" startline="5652"><![CDATA[
 
     ''' <summary>
     ''' CatchStatement  
     '''	   "Catch" [  Identifier "As" NonArrayTypeName  ]  [ "When" BooleanExpression  ]  StatementTerminator
     '''	      [  Block  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCatchStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As CatchStatement
         Dim result As New CatchStatement(Parent)
 
         Dim m_Code As CodeBlock
         Dim m_Variable As Identifier = Nothing
         Dim m_When As Expression = Nothing
         Dim m_TypeName As NonArrayTypeName = Nothing
 
         tm.AcceptIfNotInternalError(KS.Catch)
 
         If tm.AcceptEndOfStatement(IsOneLiner) = False Then
             m_Variable = ParseIdentifier(result)
             If m_Variable IsNot Nothing Then
                 If tm.AcceptIfNotError(KS.As) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_TypeName = ParseNonArrayTypeName(result)
                 If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.Accept(KS.When) Then
                 m_When = ParseExpression(result)
                 If m_When Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_Variable, m_TypeName, m_When, m_Code)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5109" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="13" pcid="9219" startline="5060"><![CDATA[
 
     ''' <summary>
     ''' OnErrorStatement  
     ''' ErrorClause  
     '''	   "GoTo"  "-"  "1" |
     '''	   "GoTo"  "0"  |
     '''	   GotoStatement  |
     '''	   "Resume" "Next"
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOnErrorStatement(ByVal Parent As ParsedObject) As OnErrorStatement
         Dim m_IsResumeNext As Boolean
         Dim m_Label As Token = Nothing
         Dim m_IsGotoMinusOne As Boolean
         Dim m_IsGotoZero As Boolean
 
         tm.AcceptIfNotInternalError(KS.On)
         If tm.Accept(KS.Error) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.Accept(KS.Resume) Then
             If tm.Accept(KS.Next) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_IsResumeNext = True
         Else
             If tm.Accept(KS.GoTo) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.CurrentToken.IsIntegerLiteral Then
                 If tm.CurrentToken.IntegralLiteral = 0 Then
                     m_IsGotoZero = True
                 Else
                     m_Label = tm.CurrentToken
                 End If
                 tm.NextToken()
             ElseIf tm.CurrentToken = KS.Minus AndAlso tm.PeekToken.IsIntegerLiteral Then
                 If tm.PeekToken.IntegralLiteral = 1 Then
                     m_IsGotoMinusOne = True
                     tm.NextToken(2)
                 Else
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     Compiler.Report.ShowMessage(Messages.VBNC90011, tm.CurrentLocation, "-1")
                 End If
             ElseIf tm.CurrentToken.IsIdentifier Then
                 m_Label = tm.CurrentToken
                 tm.NextToken()
             Else
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
                 Return Nothing
             End If
         End If
 
         Return New OnErrorStatement(Parent, m_IsResumeNext, m_Label, m_IsGotoMinusOne, m_IsGotoZero)
     End Function
]]></clone_fragment>
<clone_fragment endline="4321" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="16" pcid="9167" startline="4240"><![CDATA[
 
 
     ''' <summary>
     ''' BinaryOperatorDeclaration  
     '''	[  Attributes  ]  [  OperatorModifier+  ]  "Operator"  OverloadableBinaryOperator
     '''		"("  Operand  ","  Operand  ")"  [ "As"  [  Attributes  ]  TypeName  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Operator" StatementTerminator
     ''' 
     ''' UnaryOperatorDeclaration  
     '''	[  Attributes  ]  [  OperatorModifier+  ]  "Operator" OverloadableUnaryOperator 
     '''     "("  Operand  ")" 		[  "As" [  Attributes  ]  TypeName  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Operator" StatementTerminator
     ''' OverloadableUnaryOperator  
     ''' </summary>
     ''' <remarks></remarks>
 
     Private Function ParseOperatorDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As OperatorDeclaration
         Dim result As New OperatorDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_OperatorSymbol As KS
         Dim m_OperatorIdentifier As String = Nothing
         Dim m_Operand1 As Operand
         Dim m_Operand2 As Operand
         Dim m_TypeName As TypeName
         Dim m_ReturnTypeAttributes As New Attributes(Parent)
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.OperatorModifiers)
 
         tm.AcceptIfNotInternalError(KS.Operator)
 
         If vbnc.OperatorDeclaration.IsOverloadableOperator(tm.CurrentToken) Then
             If tm.CurrentToken.IsIdentifier Then
                 m_OperatorIdentifier = DirectCast(tm.Reader.TokenData, String)
             Else
                 m_OperatorSymbol = tm.CurrentToken.Symbol
             End If
             tm.NextToken()
         Else
             Throw New InternalException(result)
         End If
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Operand1 = ParseOperand(result)
         If m_Operand1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Comma) Then
             m_Operand2 = ParseOperand(result)
             If m_Operand2 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Operand2 = Nothing
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Operator) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_OperatorIdentifier, m_OperatorSymbol, m_Operand1, m_Operand2, m_ReturnTypeAttributes, m_TypeName, m_Block)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="6330" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="17" pcid="9289" startline="6281"><![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
         result.UpdateDefinition()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="638" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="12" pcid="8927" startline="592"><![CDATA[
 
     ''' <summary>
     ''' AttributeArguments  
     '''     AttributePositionalArgumentList  |
     ''' 	AttributePositionalArgumentList  ,  VariablePropertyInitializerList  |
     '''	    VariablePropertyInitializerList
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeArguments(ByVal Parent As ParsedObject) As AttributeArguments
         Dim result As New AttributeArguments(Parent)
 
         Dim m_AttributePositionalArgumentList As New AttributePositionalArgumentList(result)
         Dim m_VariablePropertyInitializerList As New VariablePropertyInitializerList(result)
 
         If AttributePositionalArgumentList.CanBeMe(tm) Then
             Do
                 Dim newObject As AttributeArgumentExpression
                 newObject = ParseAttributeArgumentExpression(Parent)
                 If newObject Is Nothing Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
                 m_AttributePositionalArgumentList.Add(newObject)
 
                 If tm.CurrentToken = KS.Comma Then
                     Dim current As RestorablePoint = tm.GetRestorablePoint
                     tm.NextToken()
                     If AttributePositionalArgumentList.CanBeMe(tm) = False Then
                         tm.RestoreToPoint(current)
                         Exit Do
                     Else
                         tm.RestoreToPoint(current)
                     End If
                 End If
             Loop While tm.Accept(KS.Comma)
         End If
 
         If m_AttributePositionalArgumentList.Count = 0 OrElse tm.Accept(KS.Comma) Then
             If ParseList(Of VariablePropertyInitializer)(m_VariablePropertyInitializerList, New ParseDelegate_Parent(Of VariablePropertyInitializer)(AddressOf ParseVariablePropertyInitializer), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         result.Init(m_AttributePositionalArgumentList, m_VariablePropertyInitializerList)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="3655" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="15" pcid="9127" startline="3571"><![CDATA[
 
     ''' <summary>
     ''' RegularPropertyMemberDeclaration  
     '''	[  Attributes  ]  [  PropertyModifier+  ] "Property" FunctionSignature  [  ImplementsClause  ]
     '''		LineTerminator
     '''	PropertyAccessorDeclaration+
     '''	"End" "Property" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRegularPropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As RegularPropertyDeclaration
         Dim result As New RegularPropertyDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Signature As FunctionSignature
         Dim m_ImplementsClause As MemberImplementsClause
         Dim m_Attributes As New Attributes(result)
         Dim m_Get As PropertyGetDeclaration = Nothing
         Dim m_Set As PropertySetDeclaration = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.PropertyModifiers)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If tm.AcceptEndOfStatement() = False Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ImplementsClause = Nothing
         End If
 
         Do
             m_Attributes = ParseAttributes(result)
             If PropertyGetDeclaration.IsMe(tm) Then
                 If m_Get IsNot Nothing Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Found more than one Get Property.")
                 End If
                 m_Get = ParsePropertyGetMember(result, New ParseAttributableInfo(Compiler, m_Attributes), m_Signature, m_ImplementsClause, m_Modifiers.Mask)
                 If m_Get Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Attributes = Nothing
             ElseIf PropertySetDeclaration.IsMe(tm) Then
                 If m_Set IsNot Nothing Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Found more than one Set Property.")
                 End If
                 m_Set = ParsePropertySetMember(result, New ParseAttributableInfo(Compiler, m_Attributes), m_Signature, m_ImplementsClause, m_Modifiers.Mask)
                 If m_Set Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Attributes = Nothing
             Else
                 If m_Attributes IsNot Nothing AndAlso m_Attributes.Count > 0 Then
                     'Hanging attributes.
                     Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
                 End If
                 Exit Do
             End If
         Loop
 
         If tm.AcceptIfNotError(KS.End, KS.Property) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_Modifiers.Is(ModifierMasks.ReadOnly) AndAlso m_Get Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC30126, m_Signature.Location)
         End If
         If m_Modifiers.Is(ModifierMasks.WriteOnly) AndAlso m_Set Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC30125, m_Signature.Location)
         End If
 
         If m_Modifiers.Is(ModifierMasks.ReadOnly) = False AndAlso m_Modifiers.Is(ModifierMasks.WriteOnly) = False Then
             If m_Get Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC30124, m_Signature.Location)
             End If
             If m_Set Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC30124, m_Signature.Location)
             End If
         End If
 
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_Get, m_Set, m_ImplementsClause)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="535" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="20" pcid="8921" startline="517"><![CDATA[
     ''' <summary>
     ''' AttributeBlock  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeBlock(ByVal Parent As ParsedObject, ByVal Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Attributes IsNot Nothing)
 
         tm.AcceptIfNotInternalError(KS.LT)
 
         If ParseAttributeList(Parent, Attributes) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result = tm.AcceptIfNotError(KS.GT) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="166" nfragments="3">
<clone_fragment endline="2538" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="0" pcid="5533" startline="2529"><![CDATA[
 
 		public static OpType? GetType (string metadata_name)
 		{
 			for (int i = 0; i < names.Length; ++i) {
 				if (names[i][1] == metadata_name)
 					return (OpType) i;
 			}
 			for (int i = 0; i < names.Length; ++i) {
 				if (names[i][1] == metadata_name)
 					return (OpType) i;
 			}
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="876" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="11" pcid="587" startline="861"><![CDATA[
 
 		private static bool MatchParameterTypes(ParameterInfo[] parameters, Type[] types)
 		{
 			if (parameters.Length == types.Length)
 			{
 				for (int i = 0; i < parameters.Length; i++)
 				{
 					if (!parameters[i].ParameterType.Equals(types[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < parameters.Length; i++)
 				{
 					if (!parameters[i].ParameterType.Equals(types[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]></clone_fragment>
<clone_fragment endline="2381" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="11" pcid="1555" startline="2369"><![CDATA[
 
 		internal int FindFirstByOwner(int token)
 		{
 			// TODO use binary search (if sorted)
 			for (int i = 0; i < records.Length; i++)
 			{
 				if (records[i].Owner == token)
 				{
 					return i;
 				}
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				if (records[i].Owner == token)
 				{
 					return i;
 				}
 			}
 			return -1;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="167" nfragments="2">
<clone_fragment endline="96" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" hamdist="0" pcid="2505" startline="82"><![CDATA[
 		}
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]></clone_fragment>
<clone_fragment endline="1056" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" hamdist="9" pcid="1983" startline="1039"><![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.Field) {
 				backing_field.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				int errors = Report.Errors;
 				Add.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				if (errors == Report.Errors)
 					Remove.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="168" nfragments="2">
<clone_fragment endline="79" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" hamdist="0" pcid="2965" startline="69"><![CDATA[
 		}
 
 		public override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = method.GetParameters();
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new GenericParameterInfoImpl(this, parameters[i]);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new GenericParameterInfoImpl(this, parameters[i]);
 			}
 			return parameters;
 		}
]]></clone_fragment>
<clone_fragment endline="59" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ConstructorInfo.cs" hamdist="3" pcid="1597" startline="49"><![CDATA[
 		}
 
 		public sealed override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = GetMethodInfo().GetParameters();
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoWrapper(this, parameters[i]);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoWrapper(this, parameters[i]);
 			}
 			return parameters;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="169" nfragments="2">
<clone_fragment endline="217" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" hamdist="0" pcid="6781" startline="203"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference))
         MyBase.New(Classifications.PropertyGroup, Parent)
         m_InstanceExpression = InstanceExpression
 
         m_Members = New Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)()
         m_Members.AddRange(Members)
 #If DEBUG Then
         For i As Integer = 0 To Members.Count - 1
             For j As Integer = i + 1 To Members.Count - 1
                 Helper.Assert(Members(i) IsNot Members(j))
             Next
         Next
 #End If
     End Sub
]]></clone_fragment>
<clone_fragment endline="202" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" hamdist="9" pcid="6779" startline="180"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         MyBase.New(Classifications.PropertyGroup, Parent)
         m_InstanceExpression = InstanceExpression
 
         m_Members = New Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)(Members.Count)
         For i As Integer = 0 To Members.Count - 1
             Dim tmp As Mono.Cecil.PropertyReference = TryCast(Members(i), Mono.Cecil.PropertyReference)
             If tmp IsNot Nothing Then
                 m_Members.Add(tmp)
             Else
                 Throw New InternalException(Me)
             End If
         Next
 
 #If DEBUG Then
         For i As Integer = 0 To Members.Count - 1
             For j As Integer = i + 1 To Members.Count - 1
                 Helper.Assert(Members(i) IsNot Members(j))
             Next
         Next
 #End If
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="170" nfragments="2">
<clone_fragment endline="1173" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="0" pcid="8097" startline="1159"><![CDATA[
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="1225" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="10" pcid="8105" startline="1211"><![CDATA[
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="171" nfragments="2">
<clone_fragment endline="740" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" hamdist="0" pcid="685" startline="726"><![CDATA[
 		}
 
 		public override string Name
 		{
 			get
 			{
 				if (this.IsNested)
 				{
 					return nameOrFullName;
 				}
 				else
 				{
 					return base.Name;
 				}
 			}
]]></clone_fragment>
<clone_fragment endline="754" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="11" pcid="575" startline="743"><![CDATA[
 
 		public virtual Type GetNestedType(string name, BindingFlags bindingAttr)
 		{
 			foreach (Type type in GetNestedTypes(bindingAttr))
 			{
 				if (type.Name == name)
 				{
 					return type;
 				}
 			}
 			foreach (Type type in GetNestedTypes(bindingAttr))
 			{
 				if (type.Name == name)
 				{
 					return type;
 				}
 			}
 			return null;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="172" nfragments="2">
<clone_fragment endline="38" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" hamdist="0" pcid="6571" startline="24"><![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]></clone_fragment>
<clone_fragment endline="38" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" hamdist="0" pcid="6669" startline="24"><![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="173" nfragments="3">
<clone_fragment endline="310" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="0" pcid="9651" startline="296"><![CDATA[
 
     Function ResolveMembers() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveMembers " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = ResolveMembers(type) AndAlso result
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="243" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="9" pcid="9643" startline="227"><![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveTypeReferences " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = ResolveTypeReferences(type) AndAlso result
         Next
 
         result = m_Attributes.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="281" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="10" pcid="9647" startline="264"><![CDATA[
 
     Function CreateImplicitMembers() As Boolean
         Dim result As Boolean = True
 
         For Each Type As TypeDeclaration In Me.Types
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "CreateImplicitMembers " & Type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             Dim tmp As IHasImplicitMembers = TryCast(Type, IHasImplicitMembers)
             If tmp IsNot Nothing Then result = tmp.CreateImplicitMembers AndAlso result
 
             result = CreateImplicitMembers(Type) AndAlso result
         Next
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="174" nfragments="5">
<clone_fragment endline="533" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" hamdist="0" pcid="8639" startline="519"><![CDATA[
 
     Sub RemoveNarrowingExceptObject()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowingExceptObject Then
                 Log("NARROWING (EXCEPT OBJECT)    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING (EXCEPT OBJECT)
             End If
         Next
     End Sub
]]></clone_fragment>
<clone_fragment endline="548" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" hamdist="8" pcid="8641" startline="534"><![CDATA[
 
     Sub RemoveNarrowing()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsNarrowing Then
                 Log("NARROWING    
                 m_Candidates(i) = Nothing
             Else
                 Log("NOT NARROWING
             End If
         Next
     End Sub
]]></clone_fragment>
<clone_fragment endline="518" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" hamdist="3" pcid="8637" startline="504"><![CDATA[
 
     Sub RemoveInapplicable()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.DefineApplicability = False Then
                 Log("NOT APPLICABLE
                 m_Candidates(i) = Nothing
             Else
                 Log("APPLICABLE    
             End If
         Next
     End Sub
]]></clone_fragment>
<clone_fragment endline="473" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" hamdist="3" pcid="8631" startline="459"><![CDATA[
 
     Sub RemoveInaccessible()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.IsAccessible = False Then
                 Log("NOT ACCESSIBLE
                 m_Candidates(i) = Nothing
             Else
                 Log("ACCESSIBLE    
             End If
         Next
     End Sub
]]></clone_fragment>
<clone_fragment endline="493" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" hamdist="7" pcid="8633" startline="474"><![CDATA[
 
     Sub InferTypeArguments()
         If m_TypeArguments IsNot Nothing AndAlso m_TypeArguments.Count > 0 Then
             Log("Type arguments specified, not inferring them")
             Return
         End If
 
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate Is Nothing Then Continue For
 
             If candidate.InferTypeArguments = False Then
                 Log("TYPE INFERENCE FAILED
                 m_Candidates(i) = Nothing
             Else
                 Log("TYPE INFERENCE PASSED
             End If
         Next
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="175" nfragments="2">
<clone_fragment endline="646" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" hamdist="0" pcid="4011" startline="636"><![CDATA[
 
 		internal void WriteParamRecords(MetadataWriter mw)
 		{
 			if (parameters != null)
 			{
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.WriteParamRecord(mw);
 				}
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.WriteParamRecord(mw);
 				}
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="658" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" hamdist="10" pcid="4013" startline="647"><![CDATA[
 
 		internal void FixupToken(int token, ref int parameterToken)
 		{
 			typeBuilder.ModuleBuilder.RegisterTokenFixup(this.pseudoToken, token);
 			if (parameters != null)
 			{
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.FixupToken(parameterToken++);
 				}
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.FixupToken(parameterToken++);
 				}
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="176" nfragments="3">
<clone_fragment endline="195" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" hamdist="0" pcid="8309" startline="181"><![CDATA[
 
     Shared Function GetGetMethod(ByVal Compiler As Compiler, ByVal ArrayType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim ranks As Integer = CecilHelper.GetArrayRank(ArrayType)
         
         ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, ArrayType)
         elementType = Helper.GetTypeOrTypeBuilder(Compiler, elementType)
         result = New Mono.Cecil.MethodReference("Get", ArrayType, elementType, True, False, Mono.Cecil.MethodCallingConvention.Default)
         For i As Integer = 1 To ranks
             result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int32)))
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="232" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" hamdist="2" pcid="8313" startline="216"><![CDATA[
 
     Shared Function GetAddressMethod(ByVal Compiler As Compiler, ByVal ArrayType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim ranks As Integer = CecilHelper.GetArrayRank(ArrayType)
         Dim methodtypes As Mono.Cecil.TypeReference() = Helper.CreateArray(Of Mono.Cecil.TypeReference)(Compiler.TypeCache.System_Int32, ranks)
 
         ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, ArrayType)
         elementType = Helper.GetTypeOrTypeBuilder(Compiler, elementType)
         result = New Mono.Cecil.MethodReference("Address", ArrayType, CecilHelper.MakeByRefType(elementType), True, False, Mono.Cecil.MethodCallingConvention.Default)
 
         For i As Integer = 1 To ranks
             result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int32)))
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="215" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" hamdist="4" pcid="8311" startline="196"><![CDATA[
 
     Shared Function GetSetMethod(ByVal Compiler As Compiler, ByVal ArrayType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim ranks As Integer = CecilHelper.GetArrayRank(ArrayType)
         Dim methodtypes As Mono.Cecil.TypeReference() = Helper.CreateArray(Of Mono.Cecil.TypeReference)(Compiler.TypeCache.System_Int32, ranks + 1)
 
         methodtypes(ranks) = elementType
 
         ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, ArrayType)
         elementType = Helper.GetTypeOrTypeBuilder(Compiler, elementType)
         result = New Mono.Cecil.MethodReference("Set", ArrayType, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void), True, False, Mono.Cecil.MethodCallingConvention.Default)
 
         For i As Integer = 1 To ranks
             result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int32)))
         Next
         result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, elementType)))
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="177" nfragments="4">
<clone_fragment endline="1315" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="0" pcid="6429" startline="1301"><![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Double) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         Dim tmp As EmitInfo = Info
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 If Value <= Single.MaxValue AndAlso Value >= Single.MinValue Then
                     EmitLoadValue(tmp, CSng(Value))
                     Return True
                 End If
         End Select
         Return False
     End Function
]]></clone_fragment>
<clone_fragment endline="1244" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="11" pcid="6423" startline="1222"><![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Long) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         If Value <= Integer.MaxValue AndAlso Value >= Integer.MinValue Then
             Return EmitLoadValue(Info, CInt(Value))
         End If
 
         Dim tmp As EmitInfo = Info.Clone(Info.Context, CType(Nothing, Mono.Cecil.TypeReference))
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 EmitLoadValue(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadValue(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadValue(tmp, CDec(Value))
                 Return True
         End Select
         Return False
     End Function
]]></clone_fragment>
<clone_fragment endline="1300" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="12" pcid="6427" startline="1275"><![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Decimal) As Boolean
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         Helper.Assert(Info.DesiredType IsNot Nothing)
         If Math.Truncate(Value) = Value Then
             If Value <= Integer.MaxValue AndAlso Value >= Integer.MinValue Then
                 Return EmitLoadValue(Info, CInt(Value))
             ElseIf Value <= Long.MaxValue AndAlso Value >= Long.MinValue Then
                 Return EmitLoadValue(Info, CLng(Value))
             ElseIf Value <= ULong.MaxValue AndAlso Value >= Long.MinValue Then
                 Return EmitLoadValue(Info, CULng(Value))
             End If
         End If
 
         Dim tmp As EmitInfo = Info.Clone(Info.Context, CType(Nothing, Mono.Cecil.TypeReference))
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 EmitLoadValue(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadValue(tmp, CDbl(Value))
                 Return True
         End Select
         Return False
     End Function
]]></clone_fragment>
<clone_fragment endline="1274" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="10" pcid="6425" startline="1245"><![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As ULong) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         Dim tmp As EmitInfo = Info
 
         'If Value <= Integer.MaxValue AndAlso Value >= Integer.MinValue Then
         '    Helper.NotImplemented() 'Return EmitLoadValue(Info, CInt(Value))
         'ElseIf Value <= Long.MaxValue AndAlso Value >= Long.MinValue Then
         '    Return EmitLoadValue(Info, CLng(Value))
         'End If
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 EmitLoadValue(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadValue(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadValue(tmp, CDec(Value))
                 Return True
             Case TypeCode.Int64, TypeCode.UInt64
                 EmitLoadI8Value(Info, Value)
                 Return True
         End Select
         Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         Return False
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="178" nfragments="3">
<clone_fragment endline="3853" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7813" startline="3837"><![CDATA[
 
     Shared Function IsHideBySig(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Constructor
                 Return False
             Case MemberTypes.Event, MemberTypes.Field, MemberTypes.NestedType, MemberTypes.TypeInfo
                 Return False
             Case MemberTypes.Property
                 Dim pInfo As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.PropertyReference))
                 Return CBool(GetPropertyAttributes(pInfo) And Mono.Cecil.MethodAttributes.HideBySig)
             Case MemberTypes.Method
                 Dim mInfo As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference))
                 Return mInfo.IsHideBySig
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="1374" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="10" pcid="7619" startline="1354"><![CDATA[
 
     Shared Function IsShadows(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Dim result As Boolean = True
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Method, MemberTypes.Constructor
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).IsHideBySig = False
             Case MemberTypes.Property
                 Return CBool(Helper.GetPropertyAttributes(DirectCast(Member, Mono.Cecil.PropertyReference)) And Mono.Cecil.MethodAttributes.HideBySig) = False
             Case MemberTypes.Field
                 Return True
             Case MemberTypes.TypeInfo
                 Return True
             Case MemberTypes.NestedType
                 Return True
             Case MemberTypes.Event
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.EventReference)).AddMethod.IsHideBySig = False
             Case Else
                 Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
         End Select
         Return False
     End Function
]]></clone_fragment>
<clone_fragment endline="1396" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="14" pcid="7621" startline="1375"><![CDATA[
 
     Shared Function IsShared(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Dim result As Boolean = True
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Method, MemberTypes.Constructor
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).IsStatic
             Case MemberTypes.Property
                 Dim pInfo As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.PropertyReference))
                 Return CBool(Helper.GetPropertyAttributes(pInfo) And Mono.Cecil.MethodAttributes.Static)
             Case MemberTypes.Field
                 Dim fInfo As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.FieldReference))
                 Return fInfo.IsStatic
             Case MemberTypes.TypeInfo
                 Return False
             Case MemberTypes.NestedType
                 Return False
             Case MemberTypes.Event
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.EventReference)).AddMethod.IsStatic
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="179" nfragments="29">
<clone_fragment endline="1366" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="0" pcid="1433" startline="1354"><![CDATA[
 	}
 
 	sealed class StandAloneSigTable 
 	{
 		internal const int Index = 0x11;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1798" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="4" pcid="1485" startline="1786"><![CDATA[
 	}
 
 	sealed class TypeSpecTable 
 	{
 		internal const int Index = 0x1B;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1758" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="8" pcid="1479" startline="1746"><![CDATA[
 	}
 
 	sealed class ModuleRefTable 
 	{
 		internal const int Index = 0x1A;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadStringIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1411" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="8" pcid="1439" startline="1392"><![CDATA[
 	}
 
 	sealed class EventMapTable 
 	{
 		internal const int Index = 0x12;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int EventList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].EventList = mr.ReadEvent();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].EventList = mr.ReadEvent();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1489" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="7" pcid="1449" startline="1470"><![CDATA[
 	}
 
 	sealed class PropertyMapTable 
 	{
 		internal const int Index = 0x15;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int PropertyList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].PropertyList = mr.ReadProperty();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].PropertyList = mr.ReadProperty();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1112" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="8" pcid="1405" startline="1093"><![CDATA[
 	}
 
 	sealed class FieldMarshalTable 
 	{
 		internal const int Index = 0x0D;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int NativeType;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasFieldMarshal();
 				records[i].NativeType = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasFieldMarshal();
 				records[i].NativeType = mr.ReadBlobIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1322" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="15" pcid="1427" startline="1303"><![CDATA[
 	}
 
 	sealed class FieldLayoutTable 
 	{
 		internal const int Index = 0x10;
 
 		internal struct Record
 		{
 			internal int Offset;
 			internal int Field;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="596" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="8" pcid="1363" startline="575"><![CDATA[
 	}
 
 	sealed class FieldTable 
 	{
 		internal const int Index = 0x04;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal int Name;
 			internal int Signature;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="2237" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="8" pcid="1537" startline="2218"><![CDATA[
 	}
 
 	sealed class NestedClassTable 
 	{
 		internal const int Index = 0x29;
 
 		internal struct Record
 		{
 			internal int NestedClass;
 			internal int EnclosingClass;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].NestedClass = mr.ReadTypeDef();
 				records[i].EnclosingClass = mr.ReadTypeDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].NestedClass = mr.ReadTypeDef();
 				records[i].EnclosingClass = mr.ReadTypeDef();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="2462" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="14" pcid="1565" startline="2443"><![CDATA[
 	}
 
 	sealed class GenericParamConstraintTable 
 	{
 		internal const int Index = 0x2C;
 
 		internal struct Record
 		{
 			internal int Owner;
 			internal int Constraint;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Owner = mr.ReadGenericParam();
 				records[i].Constraint = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Owner = mr.ReadGenericParam();
 				records[i].Constraint = mr.ReadTypeDefOrRef();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1177" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="11" pcid="1411" startline="1156"><![CDATA[
 	}
 
 	sealed class DeclSecurityTable 
 	{
 		internal const int Index = 0x0E;
 
 		internal struct Record
 		{
 			internal short Action;
 			internal int Parent;
 			internal int PermissionSet;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Action = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasDeclSecurity();
 				records[i].PermissionSet = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Action = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasDeclSecurity();
 				records[i].PermissionSet = mr.ReadBlobIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1528" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="6" pcid="1453" startline="1507"><![CDATA[
 	}
 
 	sealed class PropertyTable 
 	{
 		internal const int Index = 0x17;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal int Name;
 			internal int Type;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Type = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Type = mr.ReadBlobIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1450" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="4" pcid="1443" startline="1429"><![CDATA[
 	}
 
 	sealed class EventTable 
 	{
 		internal const int Index = 0x14;
 
 		internal struct Record
 		{
 			internal short EventFlags;
 			internal int Name;
 			internal int EventType;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].EventFlags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].EventType = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].EventFlags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].EventType = mr.ReadTypeDefOrRef();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="788" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="7" pcid="1381" startline="767"><![CDATA[
 	}
 
 	sealed class MemberRefTable 
 	{
 		internal const int Index = 0x0A;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Name;
 			internal int Signature;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadMemberRefParent();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadMemberRefParent();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1705" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="7" pcid="1473" startline="1684"><![CDATA[
 	}
 
 	sealed class MethodImplTable 
 	{
 		internal const int Index = 0x19;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int MethodBody;
 			internal int MethodDeclaration;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].MethodBody = mr.ReadMethodDefOrRef();
 				records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].MethodBody = mr.ReadMethodDefOrRef();
 				records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="2293" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="7" pcid="1543" startline="2268"><![CDATA[
 	}
 
 	sealed class GenericParamTable 
 	{
 		internal const int Index = 0x2A;
 
 		internal struct Record
 		{
 			internal short Number;
 			internal short Flags;
 			internal int Owner;
 			internal int Name;
 			// not part of the table, we use it to be able to fixup the GenericParamConstraint table
 			internal int unsortedIndex;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Number = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Owner = mr.ReadTypeOrMethodDef();
 				records[i].Name = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Number = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Owner = mr.ReadTypeOrMethodDef();
 				records[i].Name = mr.ReadStringIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="2401" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="8" pcid="1557" startline="2382"><![CDATA[
 	}
 
 	sealed class MethodSpecTable 
 	{
 		internal const int Index = 0x2B;
 
 		internal struct Record
 		{
 			internal int Method;
 			internal int Instantiation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Method = mr.ReadMethodDefOrRef();
 				records[i].Instantiation = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Method = mr.ReadMethodDefOrRef();
 				records[i].Instantiation = mr.ReadBlobIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="714" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="9" pcid="1373" startline="695"><![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="2092" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="12" pcid="1517" startline="2071"><![CDATA[
 	}
 
 	sealed class FileTable 
 	{
 		internal const int Index = 0x26;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int Name;
 			internal int HashValue;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="681" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="4" pcid="1371" startline="660"><![CDATA[
 	}
 
 	sealed class ParamTable 
 	{
 		internal const int Index = 0x08;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal short Sequence;
 			internal int Name;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Sequence = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Sequence = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1893" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="9" pcid="1497" startline="1874"><![CDATA[
 	}
 
 	sealed class FieldRVATable 
 	{
 		internal const int Index = 0x1D;
 
 		internal struct Record
 		{
 			internal int RVA;
 			internal int Field;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="505" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="11" pcid="1355" startline="484"><![CDATA[
 	}
 
 	sealed class TypeRefTable 
 	{
 		internal const int Index = 0x01;
 
 		internal struct Record
 		{
 			internal int ResolutionScope;
 			internal int TypeName;
 			internal int TypeNameSpace;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].ResolutionScope = mr.ReadResolutionScope();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNameSpace = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].ResolutionScope = mr.ReadResolutionScope();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNameSpace = mr.ReadStringIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="986" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="12" pcid="1399" startline="965"><![CDATA[
 	}
 
 	sealed class CustomAttributeTable 
 	{
 		internal const int Index = 0x0C;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int Type;
 			internal int Value;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasCustomAttribute();
 				records[i].Type = mr.ReadCustomAttributeType();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasCustomAttribute();
 				records[i].Type = mr.ReadCustomAttributeType();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="854" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="7" pcid="1389" startline="833"><![CDATA[
 	}
 
 	sealed class ConstantTable 
 	{
 		internal const int Index = 0x0B;
 
 		internal struct Record
 		{
 			internal short Type;
 			internal int Parent;
 			internal int Value;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Type = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasConstant();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Type = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasConstant();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="2197" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="15" pcid="1531" startline="2174"><![CDATA[
 	}
 
 	sealed class ManifestResourceTable 
 	{
 		internal const int Index = 0x28;
 
 		internal struct Record
 		{
 			internal int Offset;
 			internal int Flags;
 			internal int Name;
 			internal int Implementation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1577" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="9" pcid="1459" startline="1548"><![CDATA[
 	}
 
 	sealed class MethodSemanticsTable 
 	{
 		internal const int Index = 0x18;
 
 		// semantics
 		internal const short Setter = 0x0001;
 		internal const short Getter = 0x0002;
 		internal const short Other = 0x0004;
 		internal const short AddOn = 0x0008;
 		internal const short RemoveOn = 0x0010;
 		internal const short Fire = 0x0020;
 
 		internal struct Record
 		{
 			internal short Semantics;
 			internal int Method;
 			internal int Association;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Semantics = mr.ReadInt16();
 				records[i].Method = mr.ReadMethodDef();
 				records[i].Association = mr.ReadHasSemantics();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Semantics = mr.ReadInt16();
 				records[i].Method = mr.ReadMethodDef();
 				records[i].Association = mr.ReadHasSemantics();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1835" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="11" pcid="1489" startline="1812"><![CDATA[
 	}
 
 	sealed class ImplMapTable 
 	{
 		internal const int Index = 0x1C;
 
 		internal struct Record
 		{
 			internal short MappingFlags;
 			internal int MemberForwarded;
 			internal int ImportName;
 			internal int ImportScope;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MappingFlags = mr.ReadInt16();
 				records[i].MemberForwarded = mr.ReadMemberForwarded();
 				records[i].ImportName = mr.ReadStringIndex();
 				records[i].ImportScope = mr.ReadModuleRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MappingFlags = mr.ReadInt16();
 				records[i].MemberForwarded = mr.ReadMemberForwarded();
 				records[i].ImportName = mr.ReadStringIndex();
 				records[i].ImportScope = mr.ReadModuleRef();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="639" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="9" pcid="1367" startline="611"><![CDATA[
 	}
 
 	sealed class MethodDefTable 
 	{
 		internal const int Index = 0x06;
 		private int baseRVA;
 
 		internal struct Record
 		{
 			internal int RVA;
 			internal short ImplFlags;
 			internal short Flags;
 			internal int Name;
 			internal int Signature;
 			internal int ParamList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].ImplFlags = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 				records[i].ParamList = mr.ReadParam();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].ImplFlags = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 				records[i].ParamList = mr.ReadParam();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="552" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="4" pcid="1359" startline="525"><![CDATA[
 	}
 
 	sealed class TypeDefTable 
 	{
 		internal const int Index = 0x02;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int TypeName;
 			internal int TypeNamespace;
 			internal int Extends;
 			internal int FieldList;
 			internal int MethodList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Extends = mr.ReadTypeDefOrRef();
 				records[i].FieldList = mr.ReadField();
 				records[i].MethodList = mr.ReadMethodDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Extends = mr.ReadTypeDefOrRef();
 				records[i].FieldList = mr.ReadField();
 				records[i].MethodList = mr.ReadMethodDef();
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="180" nfragments="2">
<clone_fragment endline="6120" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="0" pcid="9281" startline="6104"><![CDATA[
 
     ''' <summary>
     ''' Parses a imports statement as specified on the commandline.
     ''' </summary>
     ''' <param name="str"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Shared Function ParseImportsStatement(ByVal Parent As ImportsStatement, ByVal str As String) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Parent IsNot Nothing)
         Helper.Assert(Parent.Clauses IsNot Nothing)
 
         result = ParseImportsClauses(Parent.Clauses, str) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="470" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" hamdist="11" pcid="8273" startline="453"><![CDATA[
 
     ''' <summary>
     ''' If explicitly or implicitly convertible.
     ''' </summary>
     ''' <param name="Compiler"></param>
     ''' <param name="tpFrom"></param>
     ''' <param name="tpTo"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsExplicitlyConvertible(ByVal Compiler As Compiler, ByVal tpFrom As TypeCode, ByVal tpTo As TypeCode) As Boolean
         Dim result As Boolean
         Dim ct As ConversionType
 
         ct = Conversion(tpFrom, tpTo).Conversion
         result = ct = ConversionType.Implicit OrElse ct = ConversionType.Explicit
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="181" nfragments="2">
<clone_fragment endline="253" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" hamdist="0" pcid="1587" startline="241"><![CDATA[
 
 		internal static int GetHashCode(Type[][] types)
 		{
 			int h = 0;
 			if (types != null)
 			{
 				foreach (Type[] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 				foreach (Type[] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 			}
 			return h;
 		}
]]></clone_fragment>
<clone_fragment endline="266" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" hamdist="7" pcid="1589" startline="254"><![CDATA[
 
 		internal static int GetHashCode(Type[][][] types)
 		{
 			int h = 0;
 			if (types != null)
 			{
 				foreach (Type[][] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 				foreach (Type[][] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 			}
 			return h;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="182" nfragments="4">
<clone_fragment endline="447" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" hamdist="0" pcid="3655" startline="431"><![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label is_null_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			unwrap.EmitCheck (ec);
 			ec.Emit (OpCodes.Brfalse, is_null_label);
 
 			expr.Emit (ec);
 
 			ec.Emit (OpCodes.Br, end_label);
 			ec.MarkLabel (is_null_label);
 
 			null_value.Emit (ec);
 			ec.MarkLabel (end_label);
 		}
]]></clone_fragment>
<clone_fragment endline="524" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" hamdist="5" pcid="3695" startline="502"><![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label is_null_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			unwrap.EmitCheck (ec);
 			ec.Emit (OpCodes.Brfalse, is_null_label);
 
 			if (user_operator != null) {
 				user_operator.Emit (ec);
 			} else {
 				EmitOperator (ec, NullableInfo.GetUnderlyingType (type));
 			}
 
 			ec.Emit (OpCodes.Newobj, NullableInfo.GetConstructor (type));
 			ec.Emit (OpCodes.Br_S, end_label);
 
 			ec.MarkLabel (is_null_label);
 			LiftedNull.Create (type, loc).Emit (ec);
 
 			ec.MarkLabel (end_label);
 		}
]]></clone_fragment>
<clone_fragment endline="1268" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" hamdist="9" pcid="3813" startline="1247"><![CDATA[
 
 		void DoEmit (EmitContext ec, bool is_expr)
 		{
 			Label is_null_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			unwrap.EmitCheck (ec);
 			ec.Emit (OpCodes.Brfalse, is_null_label);
 
 			if (is_expr) {
 				underlying.Emit (ec);
 				ec.Emit (OpCodes.Br_S, end_label);
 			} else {
 				underlying.EmitStatement (ec);
 			}
 
 			ec.MarkLabel (is_null_label);
 			if (is_expr)
 				LiftedNull.Create (type, loc).Emit (ec);
 
 			ec.MarkLabel (end_label);
 		}
]]></clone_fragment>
<clone_fragment endline="1198" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" hamdist="11" pcid="3805" startline="1164"><![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label end_label = ec.DefineLabel ();
 
 			if (unwrap != null) {
 				Label is_null_label = ec.DefineLabel ();
 
 				unwrap.EmitCheck (ec);
 				ec.Emit (OpCodes.Brfalse, is_null_label);
 
 				left.Emit (ec);
 				ec.Emit (OpCodes.Br, end_label);
 
 				ec.MarkLabel (is_null_label);
 				right.Emit (ec);
 
 				ec.MarkLabel (end_label);
 				return;
 			}
 
 			left.Emit (ec);
 			ec.Emit (OpCodes.Dup);
 
 			// Only to make verifier happy
 			if (left.Type.IsGenericParameter)
 				ec.Emit (OpCodes.Box, left.Type);
 
 			ec.Emit (OpCodes.Brtrue, end_label);
 
 			ec.Emit (OpCodes.Pop);
 			right.Emit (ec);
 
 			ec.MarkLabel (end_label);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="183" nfragments="8">
<clone_fragment endline="128" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" hamdist="0" pcid="9455" startline="112"><![CDATA[
 
     ''' <summary>
     ''' Loads the loop control variable onto the stack
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function EmitLoadVariable(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         If m_Declaration IsNot Nothing Then
             Helper.Assert(m_Declaration.LocalBuilder IsNot Nothing)
             Emitter.EmitLoadVariable(Info, m_Declaration.LocalBuilder)
         Else
             result = m_Expression.GenerateCode(Info.Clone(Me, True, False)) AndAlso result
         End If
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="87" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\FunctionSignature.vb" hamdist="10" pcid="8537" startline="72"><![CDATA[
 
     ''' <summary>
     ''' The returned object will always be a function signature.
     ''' </summary>
     ''' <param name="NewParent"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SubSignature
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New FunctionSignature(NewParent)
         MyBase.CloneTo(result)
         If m_ReturnTypeAttributes IsNot Nothing Then result.m_ReturnTypeAttributes = m_ReturnTypeAttributes.clone(result)
         result.m_ReturnType = m_ReturnType
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="111" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" hamdist="11" pcid="9453" startline="92"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Store the stack value into the loop control variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function EmitStoreVariable(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(Info.RHSExpression IsNot Nothing)
         If m_Declaration IsNot Nothing Then
             Helper.Assert(m_Declaration.LocalBuilder IsNot Nothing)
             result = Info.RHSExpression.Classification.GenerateCode(Info.Clone(Me, True, False, m_Declaration.LocalBuilder.VariableType)) AndAlso result
             Emitter.EmitStoreVariable(Info, m_Declaration.LocalBuilder)
         Else
             result = m_Expression.GenerateCode(Info) AndAlso result
         End If
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5204" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="12" pcid="9229" startline="5183"><![CDATA[
 
     ''' <summary>
     ''' EraseStatement  
     ''' EraseExpressions  
     '''	  Expression  |
     '''	  EraseExpressions  ,  Expression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEraseStatement(ByVal Parent As ParsedObject) As EraseStatement
         Dim result As New EraseStatement(Parent)
 
         Dim m_Targets As ExpressionList
 
         tm.AcceptIfNotInternalError(KS.Erase)
 
         m_Targets = ParseExpressionList(Parent)
         If m_Targets Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Targets)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="147" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\LoopControlVariable.vb" hamdist="11" pcid="9457" startline="129"><![CDATA[
 
     ''' <summary>
     ''' This creates the variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Declaration IsNot Nothing Then
             result = m_Declaration.DefineLocalVariable(Info) AndAlso result
             result = m_Declaration.GenerateCode(Info) AndAlso result
         Else
             'm_LoopVariableBuilder()
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5059" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="15" pcid="9217" startline="5032"><![CDATA[
 
     ''' <summary>
     ''' RedimStatement  
     ''' RedimClauses  
     '''	   RedimClause  |
     '''	   RedimClauses  ","  RedimClause
     ''' RedimClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseReDimStatement(ByVal Parent As ParsedObject) As ReDimStatement
         Dim result As New ReDimStatement(Parent)
 
         Dim m_IsPreserve As Boolean
         Dim m_Clauses As RedimClauses
 
         tm.AcceptIfNotInternalError(KS.ReDim)
         If tm.CurrentToken.Equals("Preserve") Then
             m_IsPreserve = True
             tm.NextToken()
         End If
 
         m_Clauses = ParseRedimClauses(result)
         If m_Clauses Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IsPreserve, m_Clauses)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="233" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitInfo.vb" hamdist="11" pcid="6331" startline="215"><![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Context"></param>
     ''' <param name="IsRHS">Default = True</param>
     ''' <param name="IsExplicitConversion"></param>
     ''' <param name="DesiredType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Clone(ByVal Context As ParsedObject, ByVal IsRHS As Boolean, Optional ByVal IsExplicitConversion As Boolean = False, Optional ByVal DesiredType As Mono.Cecil.TypeReference = Nothing) As EmitInfo
         Dim result As New EmitInfo(Me)
         result.m_IsRHS = IsRHS
         result.m_IsExplicitConversion = IsExplicitConversion
         result.m_DesiredType = DesiredType
         result.m_RHSExpression = Nothing
         result.m_Context = Context
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="233" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" hamdist="13" pcid="7047" startline="199"><![CDATA[
 
 #Region "Resolution region"
     ''' <summary>
     ''' Has this expression been resolved?
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Resolved As Boolean
 
     ''' <summary>
     ''' Is this expression beeing resolved (in Resolve / DoResolve)
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Resolving As Boolean
 
     Function ResolveExpression(ByVal ResolveInfo As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(ResolveInfo IsNot Nothing)
 
         StartResolve()
 
         Try
             result = ResolveExpressionInternal(ResolveInfo) AndAlso result
         Catch ex As Exception
             Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Internal compiler error close to this location")
             Throw
         End Try
 #If EXTENDEDDEBUG Then
         Helper.Assert(result = False OrElse m_Classification IsNot Nothing, "Classification is nothing! (type of expression = " & Me.GetType.ToString & ")")
         Helper.Assert(ResolveInfo.CanFail OrElse result = (Compiler.Report.Errors = 0))
 #End If
 
         EndResolve(result)
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="184" nfragments="2">
<clone_fragment endline="50" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" hamdist="0" pcid="6517" startline="42"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
     Private m_Arguments As New BaseObjects(Of Argument)(Me)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
         If Expressions IsNot Nothing Then
             For Each item As Expression In Expressions
                 m_Arguments.Add(New PositionalArgument(Me, m_Arguments.Count, item))
             Next
         End If
     End Sub
]]></clone_fragment>
<clone_fragment endline="57" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArgumentList.vb" hamdist="10" pcid="6519" startline="51"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Arguments As Generic.List(Of Argument))
         MyBase.New(Parent)
     Private m_Arguments As New BaseObjects(Of Argument)(Me)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
         If Expressions IsNot Nothing Then
             For Each item As Expression In Expressions
                 m_Arguments.Add(New PositionalArgument(Me, m_Arguments.Count, item))
             Next
         End If
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Arguments As Generic.List(Of Argument))
         MyBase.New(Parent)
         If Arguments IsNot Nothing Then
             m_Arguments.AddRange(Arguments)
         End If
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="185" nfragments="3">
<clone_fragment endline="4811" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="0" pcid="9197" startline="4795"><![CDATA[
 
     ''' <summary>
     ''' VariableMemberDeclaration  
     ''' </summary>
     Private Function ParseLocalVariableMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As Generic.List(Of LocalVariableDeclaration)
 
         Dim m_VariableModifiers As Modifiers
 
         m_VariableModifiers = ParseModifiers(ModifierMasks.VariableModifiers)
 
         result = ParseLocalVariableDeclarators(Parent, m_VariableModifiers, Info)
 
         If tm.FindNewLineAndShowError() = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4080" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="7" pcid="9155" startline="4059"><![CDATA[
 
     ''' <summary>
     ''' ConstantMemberDeclaration  
     ''' </summary>
     ''' <remarks>
     ''' </remarks>
     Private Function ParseConstantMemberDeclarations(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of ConstantDeclaration)
         Dim result As New Generic.List(Of ConstantDeclaration)
 
         Dim m_Modifiers As Modifiers
 
         m_Modifiers = ParseModifiers(ModifierMasks.ConstantModifiers)
 
         tm.AcceptIfNotInternalError(KS.Const)
         m_Modifiers.AddModifiers(ModifierMasks.Const)
 
         result = ParseConstantDeclarations(Parent, Info.Attributes, m_Modifiers)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5288" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="12" pcid="9237" startline="5270"><![CDATA[
 
     ''' <summary>
     ''' ErrorStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseErrorStatement(ByVal Parent As ParsedObject) As ErrorStatement
         Dim result As New ErrorStatement(Parent)
 
         Dim m_ErrNumber As Expression
 
         tm.AcceptIfNotInternalError(KS.Error)
 
         m_ErrNumber = ParseExpression(result)
         If m_ErrNumber Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_ErrNumber)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="186" nfragments="2">
<clone_fragment endline="245" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" hamdist="0" pcid="6349" startline="229"><![CDATA[
 
     Private Sub BeginFinallyBlockCecil()
         Log("BeginFinallyBlock")
         Dim ex As New Mono.Cecil.Cil.ExceptionHandler(Mono.Cecil.Cil.ExceptionHandlerType.Finally)
         Dim block As TryBlock = m_ExceptionBlocks.Peek
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
         If block.EndTry Is Nothing Then
             block.EndTry = CreateAndEmitNop()
         End If
         If block.Handlers.Count > 0 Then
             block.Handlers(block.Handlers.Count - 1).HandlerEnd = CreateAndEmitNop()
         End If
 
         ex.HandlerStart = CilBody.Instructions(CilBody.Instructions.Count - 1)
         ex.TryEnd = ex.HandlerStart
         block.Handlers.Add(ex)
     End Sub
]]></clone_fragment>
<clone_fragment endline="216" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\EmitLog.vb" hamdist="5" pcid="6345" startline="199"><![CDATA[
 
     Private Sub BeginExceptFilterBlockCecil()
         Log("BeginExceptFilterBlock")
         Dim ex As New Mono.Cecil.Cil.ExceptionHandler(Mono.Cecil.Cil.ExceptionHandlerType.Filter)
         Dim block As TryBlock = m_ExceptionBlocks.Peek
 
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
         If block.EndTry Is Nothing Then
             block.EndTry = CreateAndEmitNop()
         End If
         If block.Handlers.Count > 0 Then
             block.Handlers(block.Handlers.Count - 1).HandlerEnd = CreateAndEmitNop()
         End If
 
         ex.FilterStart = CilBody.Instructions(CilBody.Instructions.Count - 1)
         ex.HandlerStart = ex.FilterStart
         block.Handlers.Add(ex)
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="187" nfragments="2">
<clone_fragment endline="3157" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="0" pcid="9089" startline="3145"><![CDATA[
 
     Private Function ParseExponent(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseIdentifier(Info)
 
         While tm.Accept(KS.Power)
             rSide = ParseIdentifier(Info)
             lSide = New ExponentExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Power)
             rSide = ParseIdentifier(Info)
             lSide = New ExponentExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]></clone_fragment>
<clone_fragment endline="3255" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="11" pcid="9101" startline="3243"><![CDATA[
 
     Private Function ParseConcat(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParsePlusMinus(Info)
 
         While tm.Accept(KS.Concat)
             rSide = ParsePlusMinus(Info)
             lSide = New ConcatExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Concat)
             rSide = ParsePlusMinus(Info)
             lSide = New ConcatExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="188" nfragments="2">
<clone_fragment endline="102" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndAlsoExpression.vb" hamdist="0" pcid="6569" startline="86"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             ElseIf TypeOf lvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             ElseIf TypeOf rvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             Else
                 Return CBool(lvalue) AndAlso CBool(rvalue)
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="99" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrElseExpression.vb" hamdist="1" pcid="6667" startline="83"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             ElseIf TypeOf lvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             ElseIf TypeOf rvalue Is Boolean = False Then
                 Throw New InternalException(Me) 'TODO
             Else
                 Return CBool(lvalue) OrElse CBool(rvalue)
             End If
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="189" nfragments="2">
<clone_fragment endline="66" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\EventAccessClassification.vb" hamdist="0" pcid="6703" startline="50"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Loads the instance expression onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_InstanceExpression IsNot Nothing Then
             result = m_InstanceExpression.GenerateCode(Info.Clone(Parent, True, False, m_InstanceExpression.ExpressionType)) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="72" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Attributes.vb" hamdist="9" pcid="8381" startline="53"><![CDATA[
 
     ''' <summary>
     ''' Might return nothing
     ''' </summary>
     ''' <param name="AttributeType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindAttributes(ByVal AttributeType As Mono.Cecil.TypeReference) As Generic.List(Of Attribute)
         Dim result As Generic.List(Of Attribute) = Nothing
 
         If AttributeType Is Nothing Then Return Nothing
 
         For Each att As Attribute In Me
             If Helper.CompareType(att.AttributeType, AttributeType) Then
                 If result Is Nothing Then result = New Generic.List(Of Attribute)
                 result.Add(att)
             End If
         Next
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="190" nfragments="2">
<clone_fragment endline="96" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" hamdist="0" pcid="2947" startline="80"><![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = typeBuilder.ModuleBuilder.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= EventAttributes.SpecialName;
 			}
 			else
 			{
 				if (lazyPseudoToken == 0)
 				{
 					lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 				}
 				typeBuilder.ModuleBuilder.SetCustomAttribute(lazyPseudoToken, customBuilder);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="108" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" hamdist="0" pcid="4657" startline="92"><![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = typeBuilder.ModuleBuilder.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= PropertyAttributes.SpecialName;
 			}
 			else
 			{
 				if (lazyPseudoToken == 0)
 				{
 					lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 				}
 				typeBuilder.ModuleBuilder.SetCustomAttribute(lazyPseudoToken, customBuilder);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="191" nfragments="2">
<clone_fragment endline="1246" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" hamdist="0" pcid="3207" startline="1230"><![CDATA[
 
 
 		/// <summary>
 		///   Attempts to apply the `Standard Implicit
 		///   Conversion' rules to the expression `expr' into
 		///   the `target_type'.  It returns a new expression
 		///   that can be used in a context that expects a
 		///   `target_type'.
 		///
 		///   This is different from `ImplicitConversion' in that the
 		///   user defined implicit conversions are excluded.
 		/// </summary>
 		static public Expression ImplicitConversionStandard (ResolveContext ec, Expression expr,
 								     TypeSpec target_type, Location loc)
 		{
 			return ImplicitConversionStandard (ec, expr, target_type, loc, false);
 		}
]]></clone_fragment>
<clone_fragment endline="196" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" hamdist="8" pcid="5185" startline="175"><![CDATA[
 
 		/// <summary>
 		///   The base class for the classes that host the user generated code
 		/// </summary>
 		/// <remarks>
 		///
 		///   This is the base class that will host the code
 		///   executed by the Evaluator.  By default
 		///   this is the Mono.CSharp.InteractiveBase class
 		///   which is useful for interactive use.
 		///
 		///   By changing this property you can control the
 		///   base class and the static members that are
 		///   available to your evaluated code.
 		/// </remarks>
 		static public TypeSpec InteractiveBaseClass {
 			get {
 				if (interactive_base_class != null)
 					return interactive_base_class;
 
 				return loader.Importer.ImportType (typeof (InteractiveBase));
 			}
]]></clone_fragment>
</clone_group>
<clone_group groupid="192" nfragments="3">
<clone_fragment endline="70" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LiteralExpression.vb" hamdist="0" pcid="7147" startline="54"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             Helper.Assert(Me.Classification.IsValueClassification)
             If Me.Classification.CanBeValueClassification Then
                 result = Me.Classification.GenerateCode(Info) AndAlso result
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="63" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ParenthesizedExpression.vb" hamdist="4" pcid="7193" startline="48"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             If Me.Classification.IsValueClassification Then
                 result = m_Expression.GenerateCode(Info) AndAlso result
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="80" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\CompilerGeneratedExpression.vb" hamdist="9" pcid="6851" startline="60"><![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Local IsNot Nothing)
 
         If Info.IsRHS Then
             If CecilHelper.IsByRef(Info.DesiredType) Then
                 Emitter.EmitLoadVariableLocation(Info, m_Local)
             Else
                 Emitter.EmitLoadVariable(Info, m_Local)
             End If
         Else
             If Info.RHSExpression IsNot Nothing Then
                 result = Info.RHSExpression.GenerateCode(Info.Clone(Me, True, , m_Local.VariableType)) AndAlso result
             End If
             Emitter.EmitStoreVariable(Info, m_Local)
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="193" nfragments="3">
<clone_fragment endline="797" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7579" startline="781"><![CDATA[
 
     Shared Function FilterByName(ByVal Context As BaseObject, ByVal collection As ICollection, ByVal Name As String) As ArrayList
         Dim result As New ArrayList
         Dim tmpname As String = ""
         For Each obj As Object In collection
             If TypeOf obj Is INameable Then
                 tmpname = DirectCast(obj, INameable).Name
             ElseIf TypeOf obj Is Mono.Cecil.MemberReference Then
                 tmpname = DirectCast(obj, Mono.Cecil.MemberReference).Name
             Else
                 Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
             End If
             If Helper.CompareName(Name, tmpname) Then result.Add(obj)
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1650" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="11" pcid="7643" startline="1626"><![CDATA[
 
     Shared Function GetOperators(ByVal Compiler As Compiler, ByVal Names() As String, ByVal Type As Mono.Cecil.TypeReference) As Generic.List(Of Mono.Cecil.MethodReference)
         Dim result As New Generic.List(Of Mono.Cecil.MethodReference)
 
         'Dim members() As MemberInfo
         Dim members As Generic.List(Of Mono.Cecil.MemberReference)
         members = Compiler.TypeManager.GetCache(Type).GetAllFlattenedMembers(MemberVisibility.All)
 
         For i As Integer = 0 To Names.Length - 1
             Dim testName As String = Names(i)
             For m As Integer = 0 To members.Count - 1
                 Dim member As MemberReference = members(m)
                 Dim mR As Mono.Cecil.MethodReference = TryCast(member, Mono.Cecil.MethodReference)
                 If mR IsNot Nothing Then
                     Dim mD As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(mR)
                     If mD.IsSpecialName AndAlso Helper.CompareName(mD.Name, testName) AndAlso mD.IsStatic Then
                         result.Add(mR)
                     End If
                 End If
             Next
             If result.Count > 0 Then Exit For
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="66" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayTypeModifiers.vb" hamdist="9" pcid="8335" startline="51"><![CDATA[
 
     Function CreateArrayType(ByVal OriginalType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeReference(Compiler, OriginalType)
         Dim mods() As ArrayTypeModifier = m_ArrayTypeModifiers
         For i As Integer = mods.GetUpperBound(0) To 0 Step -1
             Dim arr As ArrayType
             arr = CecilHelper.MakeArrayType(result, mods(i).Ranks)
             result = arr
             If arr.Rank > 1 Then
                 For d As Integer = 0 To arr.Rank - 1
                     arr.Dimensions(d) = New ArrayDimension(New Nullable(Of Integer)(0), Nothing)
                 Next
             End If
         Next
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="194" nfragments="2">
<clone_fragment endline="951" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" hamdist="0" pcid="291" startline="936"><![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddContinueOrigin (vector, loc);
 				if (errors == Report.Errors)
 					Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new ContinueOrigin (saved_origins, vector, loc);
 			}
 
 			// either the loop test or a back jump will follow code
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="935" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" hamdist="1" pcid="289" startline="920"><![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddBreakOrigin (vector, loc);
 				if (errors == Report.Errors)
 					Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new BreakOrigin (saved_origins, vector, loc);
 			}
 
 			// either the loop test or a back jump will follow code
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="195" nfragments="2">
<clone_fragment endline="676" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" hamdist="0" pcid="3899" startline="661"><![CDATA[
 
 		static public DSA FromCapiKeyBlobDSA (byte[] blob, int offset)
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			switch (blob [offset]) {
 				case 0x06
 					return FromCapiPublicKeyBlobDSA (blob, offset);
 				case 0x07
 					return FromCapiPrivateKeyBlobDSA (blob, offset);
 			}
 			throw new CryptographicException ("Unknown blob format.");
 		}
]]></clone_fragment>
<clone_fragment endline="655" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" hamdist="11" pcid="3897" startline="633"><![CDATA[
 
 		static public RSA FromCapiKeyBlob (byte[] blob, int offset) 
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			switch (blob [offset]) {
 				case 0x00
 					// this could be a public key inside an header
 					// like "sn -e" would produce
 					if (blob [offset + 12] == 0x06) {
 						return FromCapiPublicKeyBlob (blob, offset + 12);
 					}
 					break;
 				case 0x06
 					return FromCapiPublicKeyBlob (blob, offset);
 				case 0x07
 					return FromCapiPrivateKeyBlob (blob, offset);
 			}
 			throw new CryptographicException ("Unknown blob format.");
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="196" nfragments="3">
<clone_fragment endline="314" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" hamdist="0" pcid="4463" startline="299"><![CDATA[
 	}
 
 	public struct LocalVariableEntry
 	{
 		#region This is actually written to the symbol file
 		public readonly int Index;
 		public readonly string Name;
 		public readonly int BlockIndex;
 		#endregion
 
 		public LocalVariableEntry (int index, string name, int block)
 		{
 			this.Index = index;
 			this.Name = name;
 			this.BlockIndex = block;
 		}
]]></clone_fragment>
<clone_fragment endline="358" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" hamdist="11" pcid="4469" startline="335"><![CDATA[
 	}
 
 	public struct CapturedVariable
 	{
 		#region This is actually written to the symbol file
 		public readonly string Name;
 		public readonly string CapturedName;
 		public readonly CapturedKind Kind;
 		#endregion
 
 		public enum CapturedKind 
 		{
 			Local,
 			Parameter,
 			This
 		}
 
 		public CapturedVariable (string name, string captured_name,
 					 CapturedKind kind)
 		{
 			this.Name = name;
 			this.CapturedName = captured_name;
 			this.Kind = kind;
 		}
]]></clone_fragment>
<clone_fragment endline="263" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" hamdist="11" pcid="4457" startline="233"><![CDATA[
 
 		public override string ToString ()
 		{
 			return String.Format ("[Line {0}
 		}
 	}
 
 	public class CodeBlockEntry
 	{
 		public int Index;
 		#region This is actually written to the symbol file
 		public int Parent;
 		public Type BlockType;
 		public int StartOffset;
 		public int EndOffset;
 		#endregion
 
 		public enum Type {
 			Lexical			= 1,
 			CompilerGenerated	= 2,
 			IteratorBody		= 3,
 			IteratorDispatcher	= 4
 		}
 
 		public CodeBlockEntry (int index, int parent, Type type, int start_offset)
 		{
 			this.Index = index;
 			this.Parent = parent;
 			this.BlockType = type;
 			this.StartOffset = start_offset;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="197" nfragments="2">
<clone_fragment endline="166" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" hamdist="0" pcid="1301" startline="151"><![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			BlockContext bc = new BlockContext (ec.MemberContext, Block, ReturnType);
 			Expression args = parameters.CreateExpressionTree (bc, loc);
 			Expression expr = Block.CreateExpressionTree (ec);
 			if (expr == null)
 				return null;
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (expr));
 			arguments.Add (new Argument (args));
 			return CreateExpressionFactoryCall (ec, "Lambda",
 				new TypeArguments (new TypeExpression (type, loc)),
 				arguments);
 		}
]]></clone_fragment>
<clone_fragment endline="51" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" hamdist="7" pcid="1193" startline="30"><![CDATA[
 
 		protected override Expression CreateExpressionTree (ResolveContext ec, TypeSpec delegate_type)
 		{
 			if (ec.IsInProbingMode)
 				return this;
 
 			BlockContext bc = new BlockContext (ec.MemberContext, ec.ConstructorBlock, TypeManager.void_type) {
 				CurrentAnonymousMethod = ec.CurrentAnonymousMethod
 			};
 
 			Expression args = Parameters.CreateExpressionTree (bc, loc);
 			Expression expr = Block.CreateExpressionTree (ec);
 			if (expr == null)
 				return null;
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (expr));
 			arguments.Add (new Argument (args));
 			return CreateExpressionFactoryCall (ec, "Lambda",
 				new TypeArguments (new TypeExpression (delegate_type, loc)),
 				arguments);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="198" nfragments="2">
<clone_fragment endline="7950" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="0" pcid="4983" startline="7935"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			using (ec.With (ResolveContext.Options.AllCheckStateFlags, true))
 				Expr = Expr.Resolve (ec);
 			
 			if (Expr == null)
 				return null;
 
 			if (Expr is Constant || Expr is MethodGroupExpr || Expr is AnonymousMethodExpression || Expr is DefaultValueExpression)
 				return Expr;
 			
 			eclass = Expr.eclass;
 			type = Expr.Type;
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="8012" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="1" pcid="4991" startline="7997"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			using (ec.With (ResolveContext.Options.AllCheckStateFlags, false))
 				Expr = Expr.Resolve (ec);
 
 			if (Expr == null)
 				return null;
 
 			if (Expr is Constant || Expr is MethodGroupExpr || Expr is AnonymousMethodExpression || Expr is DefaultValueExpression)
 				return Expr;
 			
 			eclass = Expr.eclass;
 			type = Expr.Type;
 			return this;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="199" nfragments="2">
<clone_fragment endline="632" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="0" pcid="4289" startline="617"><![CDATA[
 
 		/// <summary>
 		/// Returns custom name of indexer
 		/// </summary>
 		public string GetIndexerAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return null;
 
 			return ((Constant) PosArguments [0].Expr).GetValue () as string;
 		}
]]></clone_fragment>
<clone_fragment endline="648" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="9" pcid="4291" startline="633"><![CDATA[
 
 		/// <summary>
 		/// Returns condition of ConditionalAttribute
 		/// </summary>
 		public string GetConditionalAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return null;
 
 			return ((Constant) PosArguments[0].Expr).GetValue () as string;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="200" nfragments="2">
<clone_fragment endline="1667" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="0" pcid="6459" startline="1652"><![CDATA[
 
     ''' <summary>
     ''' Loads the value of the specified parameter.
     ''' If it is a byref parameter, the passed-in address is loaded.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Parameter"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadParameterAddress(ByVal Info As EmitInfo, ByVal Parameter As Mono.Cecil.ParameterDefinition)
         Dim position As Integer = GetParameterPosition(Info, Parameter)
         If position <= 255 Then
             Info.ILGen.Emit(OpCodes.Ldarga_S, CByte(position))
         Else
             Info.ILGen.Emit(OpCodes.Ldarga, position)
         End If
     End Sub
]]></clone_fragment>
<clone_fragment endline="1651" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="10" pcid="6457" startline="1627"><![CDATA[
 
     ''' <summary>
     ''' Loads the value of the specified parameter.
     ''' If it is a byref parameter, the passed-in address is loaded.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Parameter"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadParameter(ByVal Info As EmitInfo, ByVal Parameter As Mono.Cecil.ParameterDefinition)
         Dim position As Integer = GetParameterPosition(Info, Parameter)
         Select Case position
             Case 0
                 Info.ILGen.Emit(OpCodes.Ldarg_0)
             Case 1
                 Info.ILGen.Emit(OpCodes.Ldarg_1)
             Case 2
                 Info.ILGen.Emit(OpCodes.Ldarg_2)
             Case 3
                 Info.ILGen.Emit(OpCodes.Ldarg_3)
             Case Is <= 255
                 Info.ILGen.Emit(OpCodes.Ldarg_S, CByte(position))
             Case Else
                 Info.ILGen.Emit(OpCodes.Ldarg, position)
         End Select
    End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="201" nfragments="3">
<clone_fragment endline="3177" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7767" startline="3159"><![CDATA[
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.MethodAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.MethodAttributes.FamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.MethodAttributes.Assembly
                 Return "Friend"
             Case Mono.Cecil.MethodAttributes.Public
                 Return "Public"
             Case Mono.Cecil.MethodAttributes.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="3158" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="11" pcid="7765" startline="3139"><![CDATA[
 
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.FieldAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.FieldAttributes.FamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.FieldAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.FieldAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.FieldAttributes.Assembly
                 Return "Friend"
             Case Mono.Cecil.FieldAttributes.Public
                 Return "Public"
             Case Mono.Cecil.FieldAttributes.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="657" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="11" pcid="7567" startline="639"><![CDATA[
 
     Shared Function GetVisibility(ByVal Attributes As Mono.Cecil.FieldAttributes) As ModifierMasks
         Select Case Attributes And Mono.Cecil.FieldAttributes.FieldAccessMask
             Case Mono.Cecil.FieldAttributes.Private
                 Return ModifierMasks.Private
             Case Mono.Cecil.FieldAttributes.FamANDAssem
                 Throw New NotImplementedException
             Case Mono.Cecil.FieldAttributes.Assembly
                 Return ModifierMasks.Friend
             Case Mono.Cecil.FieldAttributes.Family
                 Return ModifierMasks.Protected
             Case Mono.Cecil.FieldAttributes.FamORAssem
                 Return ModifierMasks.Protected Or ModifierMasks.Friend
             Case Mono.Cecil.FieldAttributes.Public
                 Return ModifierMasks.Public
             Case Else
                 Throw New InternalException
         End Select
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="202" nfragments="2">
<clone_fragment endline="676" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7569" startline="658"><![CDATA[
 
     Shared Function GetVisibility(ByVal Attributes As Mono.Cecil.TypeAttributes) As ModifierMasks
         Select Case Attributes And Mono.Cecil.TypeAttributes.VisibilityMask
             Case Mono.Cecil.TypeAttributes.NestedPrivate, Mono.Cecil.TypeAttributes.NotPublic
                 Return ModifierMasks.Private
             Case Mono.Cecil.TypeAttributes.NestedFamANDAssem
                 Throw New NotImplementedException
             Case Mono.Cecil.TypeAttributes.NestedAssembly
                 Return ModifierMasks.Friend
             Case Mono.Cecil.TypeAttributes.NestedFamily
                 Return ModifierMasks.Protected
             Case Mono.Cecil.TypeAttributes.NestedFamORAssem
                 Return ModifierMasks.Protected Or ModifierMasks.Friend
             Case Mono.Cecil.TypeAttributes.NestedPublic, Mono.Cecil.TypeAttributes.Public
                 Return ModifierMasks.Public
             Case Else
                 Throw New InternalException
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="3196" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="11" pcid="7769" startline="3178"><![CDATA[
 
     Overloads Shared Function ToString(ByVal Accessibility As Mono.Cecil.TypeAttributes) As String
         Select Case Accessibility
             Case Mono.Cecil.TypeAttributes.NestedFamANDAssem
                 Return "Protected Friend"
             Case Mono.Cecil.TypeAttributes.NestedFamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.TypeAttributes.NestedFamANDAssem
                 Return "Protected"
             Case Mono.Cecil.TypeAttributes.NestedAssembly, Mono.Cecil.TypeAttributes.NotPublic
                 Return "Friend"
             Case Mono.Cecil.TypeAttributes.NestedPublic, Mono.Cecil.TypeAttributes.Public
                 Return "Public"
             Case Mono.Cecil.TypeAttributes.NestedPrivate
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="203" nfragments="2">
<clone_fragment endline="121" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" hamdist="0" pcid="8681" startline="103"><![CDATA[
     End Property
 
     Function GetMethodAttributeScope() As Mono.Cecil.MethodAttributes
         If Me.Is(ModifierMasks.Public) Then
             Return Mono.Cecil.MethodAttributes.Public
         ElseIf Me.Is(ModifierMasks.Friend) Then
             If Me.Is(ModifierMasks.Protected) Then
                 Return Mono.Cecil.MethodAttributes.FamORAssem
             Else
                 Return Mono.Cecil.MethodAttributes.Assembly
             End If
         ElseIf Me.Is(ModifierMasks.Protected) Then
             Return Mono.Cecil.MethodAttributes.Family
         ElseIf Me.Is(ModifierMasks.Private) Then
             Return Mono.Cecil.MethodAttributes.Private
         Else
             Return Mono.Cecil.MethodAttributes.Public
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="147" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Modifiers.vb" hamdist="7" pcid="8683" startline="122"><![CDATA[
 
     Function GetFieldAttributeScope(ByVal TypeDeclaration As TypeDeclaration) As Mono.Cecil.FieldAttributes
         If Me.Is(ModifierMasks.Public) Then
             Return Mono.Cecil.FieldAttributes.Public
         ElseIf Me.Is(ModifierMasks.Friend) Then
             If Me.Is(ModifierMasks.Protected) Then
                 Return Mono.Cecil.FieldAttributes.FamORAssem
             Else
                 Return Mono.Cecil.FieldAttributes.Assembly
             End If
         ElseIf Me.Is(ModifierMasks.Protected) Then
             Return Mono.Cecil.FieldAttributes.Family
         ElseIf Me.Is(ModifierMasks.Private) Then
             Return Mono.Cecil.FieldAttributes.Private
         ElseIf Me.Is(ModifierMasks.Dim) OrElse Me.Is(ModifierMasks.Const) Then
             If TypeOf TypeDeclaration Is StructureDeclaration Then
                 Return Mono.Cecil.FieldAttributes.Public
             Else
                 Return Mono.Cecil.FieldAttributes.Private
             End If
         ElseIf TypeOf TypeDeclaration Is EnumDeclaration Then
             Return Mono.Cecil.FieldAttributes.Public
         Else
             Return Mono.Cecil.FieldAttributes.Private
         End If
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="204" nfragments="3">
<clone_fragment endline="226" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" hamdist="0" pcid="6711" startline="208"><![CDATA[
     End Property
 
     ReadOnly Property CanBeValueClassification() As Boolean
         Get
             Select Case m_Classification
                 Case Classifications.Value, Classifications.Variable, _
                 Classifications.LateBoundAccess, Classifications.MethodGroup, _
                 Classifications.MethodPointer, Classifications.PropertyAccess, Classifications.PropertyGroup
                     Return True
                 Case Classifications.Type
                     Dim tc As TypeClassification = AsTypeClassification
                     Return tc.CanBeExpression AndAlso tc.Expression.Classification.CanBeValueClassification
                 Case Classifications.Void, Classifications.Namespace, Classifications.EventAccess
                     Return False
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
                     Return False
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="247" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" hamdist="4" pcid="6713" startline="227"><![CDATA[
     End Property
 
     ReadOnly Property CanBePropertyAccessClassification() As Boolean
         Get
             Select Case m_Classification
                 Case Classifications.PropertyGroup
                     Return True
                 Case Classifications.LateBoundAccess
                     Return True
                 Case Classifications.Type
                     Dim tc As TypeClassification = AsTypeClassification
                     Return tc.CanBeExpression AndAlso tc.Expression.Classification.CanBePropertyAccessClassification
                 Case Classifications.Value, Classifications.Variable, Classifications.EventAccess, _
 Classifications.LateBoundAccess, Classifications.MethodGroup, _
 Classifications.MethodPointer, Classifications.PropertyAccess, Classifications.Void, Classifications.Namespace
                     Return False
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
                     Return False
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="94" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\ExpressionClassification.vb" hamdist="9" pcid="6709" startline="67"><![CDATA[
     End Property
 
     Overloads Function [GetType](ByVal ThrowIfNoType As Boolean) As Mono.Cecil.TypeReference
         Select Case m_Classification
             Case Classifications.Value
                 Return AsValueClassification.Type
             Case Classifications.Variable
                 Return AsVariableClassification.Type
             Case Classifications.MethodGroup
                 Return AsMethodGroupClassification.Type
             Case Classifications.MethodPointer
                 Return AsMethodPointerClassification.Type
             Case Classifications.PropertyAccess
                 Return AsPropertyAccess.Type
             Case Classifications.PropertyGroup
                 Return AsPropertyGroup.Type
             Case Classifications.Void
                 Return Compiler.TypeCache.System_Void
             Case Classifications.LateBoundAccess
                 Return AsLateBoundAccess.Type
             Case Else
                 If ThrowIfNoType Then
                     Throw New InternalException("No type was found")
                 Else
                     Return Nothing
                 End If
         End Select
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="205" nfragments="3">
<clone_fragment endline="180" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" hamdist="0" pcid="8429" startline="162"><![CDATA[
     End Property
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         If Me.IsShared = False AndAlso Me.HasMethodBody AndAlso Me.HasExplicitCtorCall = False Then
             CreateDefaultCtorCall()
             CreateDefaultCtorCallCecil()
         ElseIf Code IsNot Nothing AndAlso Me.HasExplicitCtorCall Then
             m_BaseCtorCall = Code.FirstStatement
             If m_BaseCtorCall IsNot Nothing Then Code.RemoveStatement(m_BaseCtorCall)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="260" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinaryExpression.vb" hamdist="11" pcid="6593" startline="236"><![CDATA[
 
     Function DoOperatorOverloading() As Boolean
         Dim result As Boolean = True
         Dim methods As New Generic.List(Of Mono.Cecil.MethodReference)
         Dim methodClassification As MethodGroupClassification
         methods = Helper.GetBinaryOperators(Compiler, CType(Me.Keyword, BinaryOperators), Me.LeftType)
         If Helper.CompareType(Me.LeftType, Me.RightType) = False Then
             Dim methods2 As New Generic.List(Of Mono.Cecil.MethodReference)
             methods2 = Helper.GetBinaryOperators(Compiler, CType(Me.Keyword, BinaryOperators), Me.RightType)
             For Each method As Mono.Cecil.MethodReference In methods2
                 If methods.Contains(method) = False Then methods.Add(method)
             Next
         End If
         If methods.Count = 0 Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30452, Me.Location, Enums.strSpecial(Me.Keyword), Me.LeftType.FullName, Me.RightType.FullName) AndAlso result
             If result = False Then Return result
         End If
         methodClassification = New MethodGroupClassification(Me, Nothing, Nothing, New Expression() {Me.m_LeftExpression, Me.m_RightExpression}, methods.ToArray)
         result = methodClassification.ResolveGroup(New ArgumentList(Me, Me.m_LeftExpression, m_RightExpression)) AndAlso result
         result = methodClassification.SuccessfullyResolved AndAlso result
         If result = False Then Return result
         m_ExpressionType = methodClassification.ResolvedMethodInfo.ReturnType
         Classification = methodClassification
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="93" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" hamdist="12" pcid="9757" startline="54"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_InterfacesImplemented = False AndAlso m_TypeImplementsClauses IsNot Nothing Then
             result = m_TypeImplementsClauses.ResolveTypeReferences AndAlso result
             For i As Integer = 0 To m_TypeImplementsClauses.Clauses.Count - 1
                 AddInterface(m_TypeImplementsClauses.Clauses(i).ResolvedType)
             Next
             m_InterfacesImplemented = True
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If Me.IsPartial Then
             If PartialModifierFound = False Then
                 Dim first As PartialTypeDeclaration = Me
                 Compiler.Report.ShowMessage(Messages.VBNC30179, Me.Location, Me.DescriptiveType, Me.Name, Me.DescriptiveType, Me.Name, Me.Namespace, Me.Namespace)
                 result = False
             End If
             'TODO
             'If TypeOf Me Is ClassDeclaration Then
             '    Dim inheritedTypes() As Mono.Cecil.TypeReference
             '    inheritedTypes = GetInheritedTypes()
             '    If inheritedTypes.Length > 0 Then
             '        Dim tmpType As Mono.Cecil.TypeReference
             '        tmpType = CheckUniqueType(inheritedTypes)
             '        If tmpType Is Nothing Then
             '            Return Helper.AddError(Me, "Partial classes must inherit from only one base class.")
             '        Else
             '            BaseType = tmpType
             '        End If
             '    Else
             '        Helper.Assert(BaseType IsNot Nothing) 'Should already be set to System.Object.
             '    End If
             'End If
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="206" nfragments="2">
<clone_fragment endline="312" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" hamdist="0" pcid="5163" startline="294"><![CDATA[
 
 		protected override string[] GetDefaultReferences ()
 		{
 			//
 			// For now the "default config" is harcoded into the compiler
 			// we can move this outside later
 			//
 			var default_references = new List<string> (4);
 
 			default_references.Add ("System.dll");
 			default_references.Add ("System.Xml.dll");
 
 			if (RootContext.Version > LanguageVersion.ISO_2)
 				default_references.Add ("System.Core.dll");
 			if (RootContext.Version > LanguageVersion.V_3)
 				default_references.Add ("Microsoft.CSharp.dll");
 
 			return default_references.ToArray ();
 		}
]]></clone_fragment>
<clone_fragment endline="461" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" hamdist="8" pcid="3601" startline="437"><![CDATA[
 		}
 
 		protected override string[] GetDefaultReferences ()
 		{
 			//
 			// For now the "default config" is harcoded into the compiler
 			// we can move this outside later
 			//
 			var default_references = new List<string> (8);
 
 			default_references.Add ("System");
 			default_references.Add ("System.Xml");
 #if NET_2_1
 			default_references.Add ("System.Net");
 			default_references.Add ("System.Windows");
 			default_references.Add ("System.Windows.Browser");
 #endif
 
 			if (RootContext.Version > LanguageVersion.ISO_2)
 				default_references.Add ("System.Core");
 			if (RootContext.Version > LanguageVersion.V_3)
 				default_references.Add ("Microsoft.CSharp");
 
 			return default_references.ToArray ();
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="207" nfragments="2">
<clone_fragment endline="356" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" hamdist="0" pcid="7129" startline="338"><![CDATA[
 
     Public Shared Function EmitLateIndexGet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateIndexGet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info) AndAlso result
 
         '2 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateIndexGet_Object_Array_Array)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="405" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" hamdist="8" pcid="7133" startline="388"><![CDATA[
 
     Public Shared Function EmitLateIndexSet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateIndexSet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
 
         '2 - The arguments
         '3 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateIndexSet_Object_Array_Array)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="208" nfragments="3">
<clone_fragment endline="94" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" hamdist="0" pcid="8569" startline="76"><![CDATA[
 
     Private Function DefineField() As Boolean
         Dim result As Boolean = True
 
         'result = MyBase.Define AndAlso result
 
         If IsStatic AndAlso m_FieldBuilderStatic Is Nothing Then
             Dim staticName As String
             Dim attr As Mono.Cecil.FieldAttributes = Mono.Cecil.FieldAttributes.Private
 
             staticName = "$STATIC$" & Me.FindFirstParent(Of INameable).Name & "$" & Me.ObjectID.ToString & "$" & Me.Name
             If DeclaringMethod.IsShared Then attr = attr Or Mono.Cecil.FieldAttributes.Static
 
             m_FieldBuilderStatic = New Mono.Cecil.FieldDefinition(staticName, attr, Helper.GetTypeOrTypeReference(Compiler, Me.VariableType))
             DeclaringType.CecilType.Fields.Add(m_FieldBuilderStatic)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="75" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" hamdist="4" pcid="8567" startline="57"><![CDATA[
 
     Public Overrides Sub Initialize(ByVal Parent As BaseObject)
         MyBase.Initialize(Parent)
 
         If IsStatic Then
             If m_FieldBuilderStaticInit Is Nothing AndAlso HasInitializer Then
                 Dim staticName As String
                 Dim attr As Mono.Cecil.FieldAttributes = Mono.Cecil.FieldAttributes.Private
 
                 staticName = "$STATIC$" & Me.FindFirstParent(Of INameable).Name & "$" & Me.ObjectID.ToString & "$" & Me.Name & "$Init"
                 If DeclaringMethod.IsShared Then attr = attr Or Mono.Cecil.FieldAttributes.Static
 
                 m_FieldBuilderStaticInit = New Mono.Cecil.FieldDefinition(staticName, attr, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag))
                 DeclaringType.CecilType.Fields.Add(m_FieldBuilderStaticInit)
             End If
         Else
             'TODO
         End If
     End Sub
]]></clone_fragment>
<clone_fragment endline="257" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyDeclaration.vb" hamdist="14" pcid="8755" startline="229"><![CDATA[
 
     Public Function DefineMember() As Boolean Implements IDefinableMember.DefineMember
         Dim result As Boolean = True
 
         If m_Get IsNot Nothing Then
             result = m_Get.DefineMember() AndAlso result
         End If
 
         If m_Set IsNot Nothing Then
             result = m_Set.DefineMember AndAlso result
         End If
 
         Dim name As String
         Dim attributes As Mono.Cecil.PropertyAttributes
         Dim returnType As Mono.Cecil.TypeReference
         Dim parameterTypes() As Mono.Cecil.TypeReference
 
         name = Me.Name
         attributes = 0 'Mono.Cecil.PropertyAttributes.None
         returnType = Me.Signature.ReturnType
         parameterTypes = Me.Signature.Parameters.ToTypeArray
 
         Helper.SetTypeOrTypeBuilder(Compiler, parameterTypes)
         returnType = Helper.GetTypeOrTypeBuilder(Compiler, returnType)
 
         UpdateDefinition()
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="209" nfragments="3">
<clone_fragment endline="186" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" hamdist="0" pcid="6105" startline="175"><![CDATA[
 
 		private int GetModuleIndex(string name)
 		{
 			for (int i = 0; i < manifestModule.File.records.Length; i++)
 			{
 				if (name.Equals(manifestModule.GetString(manifestModule.File.records[i].Name), StringComparison.InvariantCultureIgnoreCase))
 				{
 					return i;
 				}
 			}
 			for (int i = 0; i < manifestModule.File.records.Length; i++)
 			{
 				if (name.Equals(manifestModule.GetString(manifestModule.File.records[i].Name), StringComparison.InvariantCultureIgnoreCase))
 				{
 					return i;
 				}
 			}
 			return -1;
 		}
]]></clone_fragment>
<clone_fragment endline="787" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" hamdist="11" pcid="53" startline="774"><![CDATA[
 
 		protected static Type[][][] BindTypeParameters(IGenericBinder binder, Type[][][] types)
 		{
 			if (types == null)
 			{
 				return null;
 			}
 			Type[][][] expanded = new Type[types.Length][][];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			return expanded;
 		}
]]></clone_fragment>
<clone_fragment endline="773" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" hamdist="11" pcid="51" startline="760"><![CDATA[
 
 		protected static Type[][] BindTypeParameters(IGenericBinder binder, Type[][] types)
 		{
 			if (types == null)
 			{
 				return null;
 			}
 			Type[][] expanded = new Type[types.Length][];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			return expanded;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="210" nfragments="2">
<clone_fragment endline="223" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" hamdist="0" pcid="5977" startline="212"><![CDATA[
 
 		public ModuleBuilder GetDynamicModule(string name)
 		{
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name == name)
 				{
 					return module;
 				}
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name == name)
 				{
 					return module;
 				}
 			}
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="588" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" hamdist="6" pcid="5995" startline="570"><![CDATA[
 
 		public override Module GetModule(string name)
 		{
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			return null;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="211" nfragments="4">
<clone_fragment endline="1294" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" hamdist="0" pcid="129" startline="1278"><![CDATA[
 		}
 
 		public MethodInfo GetConstructor ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var ctor = mb.GetArrayMethod (
 				GetMetaInfo (), Constructor.ConstructorName,
 				CallingConventions.HasThis,
 				null, arg_types);
 
 			return ctor;
 		}
]]></clone_fragment>
<clone_fragment endline="1326" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" hamdist="7" pcid="133" startline="1311"><![CDATA[
 
 		public MethodInfo GetGetMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var get = mb.GetArrayMethod (
 				GetMetaInfo (), "Get",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				Element.GetMetaInfo (), arg_types);
 
 			return get;
 		}
]]></clone_fragment>
<clone_fragment endline="1310" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" hamdist="3" pcid="131" startline="1295"><![CDATA[
 
 		public MethodInfo GetAddressMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var address = mb.GetArrayMethod (
 				GetMetaInfo (), "Address",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				ReferenceContainer.MakeType (Element).GetMetaInfo (), arg_types);
 
 			return address;
 		}
]]></clone_fragment>
<clone_fragment endline="1344" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" hamdist="7" pcid="135" startline="1327"><![CDATA[
 
 		public MethodInfo GetSetMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank + 1];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			arg_types[rank] = Element.GetMetaInfo ();
 
 			var set = mb.GetArrayMethod (
 				GetMetaInfo (), "Set",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				TypeManager.void_type.GetMetaInfo (), arg_types);
 
 			return set;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="212" nfragments="3">
<clone_fragment endline="473" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="0" pcid="551" startline="462"><![CDATA[
 
 		public EventInfo GetEvent(string name, BindingFlags bindingAttr)
 		{
 			foreach (EventInfo evt in GetEvents(bindingAttr))
 			{
 				if (evt.Name == name)
 				{
 					return evt;
 				}
 			}
 			foreach (EventInfo evt in GetEvents(bindingAttr))
 			{
 				if (evt.Name == name)
 				{
 					return evt;
 				}
 			}
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="924" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="10" pcid="591" startline="909"><![CDATA[
 
 		public Type GetInterface(string name, bool ignoreCase)
 		{
 			if (ignoreCase)
 			{
 				throw new NotImplementedException();
 			}
 			foreach (Type type in GetInterfaces())
 			{
 				if (type.FullName == name)
 				{
 					return type;
 				}
 			}
 			foreach (Type type in GetInterfaces())
 			{
 				if (type.FullName == name)
 				{
 					return type;
 				}
 			}
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="2356" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="8" pcid="5415" startline="2343"><![CDATA[
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]></clone_fragment>
</clone_group>
<clone_group groupid="213" nfragments="3">
<clone_fragment endline="1391" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="0" pcid="1437" startline="1380"><![CDATA[
 
 		internal int FindOrAddRecord(int blob)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == blob)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == blob)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(blob);
 		}
]]></clone_fragment>
<clone_fragment endline="1785" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="6" pcid="1483" startline="1774"><![CDATA[
 
 		internal int FindOrAddRecord(int str)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == str)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == str)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(str);
 		}
]]></clone_fragment>
<clone_fragment endline="2431" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="10" pcid="1561" startline="2419"><![CDATA[
 
 		internal int FindOrAddRecord(Record record)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Method == record.Method
 					&& records[i].Instantiation == record.Instantiation)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Method == record.Method
 					&& records[i].Instantiation == record.Instantiation)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(record);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="214" nfragments="2">
<clone_fragment endline="568" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" hamdist="0" pcid="5581" startline="550"><![CDATA[
 
 		public Assembly LoadFile(string path)
 		{
 			try
 			{
 				using (RawModule module = OpenRawModule(path))
 				{
 					return LoadAssembly(module);
 				}
 			}
 			catch (IOException x)
 			{
 				throw new FileNotFoundException(x.Message, x);
 			}
 			catch (UnauthorizedAccessException x)
 			{
 				throw new FileNotFoundException(x.Message, x);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="207" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" hamdist="10" pcid="935" startline="183"><![CDATA[
 
 		public static AssemblyName GetAssemblyName(string path)
 		{
 			try
 			{
 				path = Path.GetFullPath(path);
 				using (FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read))
 				{
 					ModuleReader module = new ModuleReader(null, null, fs, path);
 					if (module.Assembly == null)
 					{
 						throw new BadImageFormatException("Module does not contain a manifest");
 					}
 					return module.Assembly.GetName();
 				}
 			}
 			catch (IOException x)
 			{
 				throw new FileNotFoundException(x.Message, x);
 			}
 			catch (UnauthorizedAccessException x)
 			{
 				throw new FileNotFoundException(x.Message, x);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="215" nfragments="6">
<clone_fragment endline="239" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" hamdist="0" pcid="4583" startline="228"><![CDATA[
 
 		internal override void GetTypesImpl(List<Type> list)
 		{
 			PopulateTypeDef();
 			foreach (TypeDefImpl type in typeDefs)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (TypeDefImpl type in typeDefs)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="451" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" hamdist="7" pcid="6157" startline="441"><![CDATA[
 
 		internal override void GetTypesImpl(List<Type> list)
 		{
 			foreach (Type type in types)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in types)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="69" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" hamdist="8" pcid="5867" startline="56"><![CDATA[
 		}
 
 		public override Type[] __GetDeclaredInterfaces()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetGenericParameterConstraints())
 			{
 				if (type.IsInterface)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetGenericParameterConstraints())
 			{
 				if (type.IsInterface)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]></clone_fragment>
<clone_fragment endline="86" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" hamdist="9" pcid="2497" startline="73"><![CDATA[
 		}
 
 		public Type[] GetExportedTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]></clone_fragment>
<clone_fragment endline="346" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" hamdist="8" pcid="4565" startline="334"><![CDATA[
 
 		public Type[] FindTypes(TypeFilter filter, object filterCriteria)
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]></clone_fragment>
<clone_fragment endline="937" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="5" pcid="593" startline="925"><![CDATA[
 
 		public Type[] FindInterfaces(TypeFilter filter, object filterCriteria)
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetInterfaces())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetInterfaces())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="216" nfragments="2">
<clone_fragment endline="3687" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7807" startline="3669"><![CDATA[
 
     Overloads Shared Function GetParameters(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference) As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim mR As Mono.Cecil.MethodReference = TryCast(Member, Mono.Cecil.MethodReference)
         If mR IsNot Nothing Then Return mR.ResolvedParameters
 
         Dim pR As Mono.Cecil.PropertyReference = TryCast(Member, Mono.Cecil.PropertyReference)
         If pR IsNot Nothing Then Return CecilHelper.FindDefinition(pR).Parameters
 
         Dim tR As Mono.Cecil.TypeReference = TryCast(Member, Mono.Cecil.TypeReference)
         If tR IsNot Nothing Then Return Nothing
 
         Dim fR As Mono.Cecil.FieldReference = TryCast(Member, Mono.Cecil.FieldReference)
         If fR IsNot Nothing Then Return Nothing
 
         Dim eR As Mono.Cecil.EventReference = TryCast(Member, Mono.Cecil.EventReference)
         If eR IsNot Nothing Then Return CecilHelper.FindDefinition(eR).InvokeMethod.Parameters()
 
         Throw New NotImplementedException
     End Function
]]></clone_fragment>
<clone_fragment endline="3712" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="11" pcid="7809" startline="3688"><![CDATA[
 
     ''' <summary>
     ''' Gets the parameters in the definition (not inflated)
     ''' </summary>
     ''' <param name="Member"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Shared Function GetOriginalParameters(ByVal Member As Mono.Cecil.MemberReference) As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim mR As Mono.Cecil.MethodReference = TryCast(Member, Mono.Cecil.MethodReference)
         If mR IsNot Nothing Then Return CecilHelper.FindDefinition(mR).Parameters
 
         Dim pR As Mono.Cecil.PropertyReference = TryCast(Member, Mono.Cecil.PropertyReference)
         If pR IsNot Nothing Then Return CecilHelper.FindDefinition(pR).Parameters
 
         Dim tR As Mono.Cecil.TypeReference = TryCast(Member, Mono.Cecil.TypeReference)
         If tR IsNot Nothing Then Return Nothing
 
         Dim fR As Mono.Cecil.FieldReference = TryCast(Member, Mono.Cecil.FieldReference)
         If fR IsNot Nothing Then Return Nothing
 
         Dim eR As Mono.Cecil.EventReference = TryCast(Member, Mono.Cecil.EventReference)
         If eR IsNot Nothing Then Return CecilHelper.FindDefinition(eR).InvokeMethod.Parameters()
 
         Throw New NotImplementedException
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="217" nfragments="4">
<clone_fragment endline="483" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" hamdist="0" pcid="1929" startline="466"><![CDATA[
 		}
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.HasSecurityAttribute) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			PropertyBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]></clone_fragment>
<clone_fragment endline="57" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" hamdist="11" pcid="1807" startline="36"><![CDATA[
 		{
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					builder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if (a.HasSecurityAttribute) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]></clone_fragment>
<clone_fragment endline="2430" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" hamdist="12" pcid="3859" startline="2402"><![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.AttributeUsage) {
 				if (!BaseType.IsAttribute && spec != TypeManager.attribute_type) {
 					Report.Error (641, a.Location, "Attribute `{0}' is only valid on classes derived from System.Attribute", a.GetSignatureForError ());
 				}
 			}
 
 			if (a.Type == pa.Conditional && !BaseType.IsAttribute) {
 				Report.Error (1689, a.Location, "Attribute `System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes");
 				return;
 			}
 
 			if (a.Type == pa.ComImport && !attributes.Contains (pa.Guid)) {
 				a.Error_MissingGuidAttribute ();
 				return;
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			if (a.Type.IsConditionallyExcluded (Location))
 				return;
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]></clone_fragment>
<clone_fragment endline="156" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" hamdist="10" pcid="991" startline="114"><![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.FieldOffset) {
 				status |= Status.HAS_OFFSET;
 
 				if (!Parent.PartialContainer.HasExplicitLayout) {
 					Report.Error (636, Location, "The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)");
 					return;
 				}
 
 				if ((ModFlags & Modifiers.STATIC) != 0 || this is Const) {
 					Report.Error (637, Location, "The FieldOffset attribute is not allowed on static or const fields");
 					return;
 				}
 			}
 
 			if (a.Type == pa.FixedBuffer) {
 				Report.Error (1716, Location, "Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead");
 				return;
 			}
 
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					FieldBuilder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			FieldBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="218" nfragments="3">
<clone_fragment endline="311" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="0" pcid="8041" startline="294"><![CDATA[
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
]]></clone_fragment>
<clone_fragment endline="293" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="8" pcid="8039" startline="263"><![CDATA[
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
]]></clone_fragment>
<clone_fragment endline="262" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="11" pcid="8037" startline="231"><![CDATA[
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="219" nfragments="2">
<clone_fragment endline="589" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" hamdist="0" pcid="3609" startline="575"><![CDATA[
 
 		public override void LoadReferences (ModuleContainer module)
 		{
 			Assembly corlib;
 			List<Tuple<RootNamespace, Assembly>> loaded;
 			base.LoadReferencesCore (module, out corlib, out loaded);
 
 			if (corlib == null)
 				return;
 
 			importer.ImportAssembly (corlib, module.GlobalRootNamespace);
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="458" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" hamdist="4" pcid="5171" startline="444"><![CDATA[
 
 		public override void LoadReferences (ModuleContainer module)
 		{
 			List<Tuple<RootNamespace, Assembly>> loaded;
 			base.LoadReferencesCore (module, out corlib, out loaded);
 
 			if (corlib != null) {
 				importer.InitializeBuildinTypes (compiler.BuildinTypes, corlib);
 				importer.ImportAssembly (corlib, module.GlobalRootNamespace);
 			}
 
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="220" nfragments="3">
<clone_fragment endline="620" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" hamdist="0" pcid="5691" startline="600"><![CDATA[
 
 		void EmitMoveNext_NoResumePoints (EmitContext ec, Block original_block)
 		{
 			ec.Emit (OpCodes.Ldarg_0);
 			ec.Emit (OpCodes.Ldfld, IteratorHost.PC.Spec);
 
 			ec.Emit (OpCodes.Ldarg_0);
 			ec.EmitInt ((int) State.After);
 			ec.Emit (OpCodes.Stfld, IteratorHost.PC.Spec);
 
 			// We only care if the PC is zero (start executing) or non-zero (don't do anything)
 			ec.Emit (OpCodes.Brtrue, move_next_error);
 
 			SymbolWriter.StartIteratorBody (ec);
 			original_block.Emit (ec);
 			SymbolWriter.EndIteratorBody (ec);
 
 			ec.MarkLabel (move_next_error);
 			ec.Emit (OpCodes.Ldc_I4_0);
 			ec.Emit (OpCodes.Ret);
 		}
]]></clone_fragment>
<clone_fragment endline="765" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" hamdist="12" pcid="5699" startline="739"><![CDATA[
 
 		//
 		// Called back from Yield
 		//
 		public void MarkYield (EmitContext ec, Expression expr, int resume_pc, bool unwind_protect, Label resume_point)
 		{
 			// Store the new current
 			ec.Emit (OpCodes.Ldarg_0);
 			expr.Emit (ec);
 			ec.Emit (OpCodes.Stfld, IteratorHost.CurrentField.Spec);
 
 			// store resume program-counter
 			ec.Emit (OpCodes.Ldarg_0);
 			ec.EmitInt (resume_pc);
 			ec.Emit (OpCodes.Stfld, IteratorHost.PC.Spec);
 
 			// mark finally blocks as disabled
 			if (unwind_protect && skip_finally != null) {
 				ec.EmitInt (1);
 				ec.Emit (OpCodes.Stloc, skip_finally);
 			}
 
 			// Return ok
 			ec.Emit (unwind_protect ? OpCodes.Leave 
 
 			ec.MarkLabel (resume_point);
 		}
]]></clone_fragment>
<clone_fragment endline="838" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" hamdist="11" pcid="5705" startline="816"><![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			//
 			// Load Iterator storey instance
 			//
 			IteratorHost.Instance.Emit (ec);
 
 			//
 			// Initialize iterator PC when it's unitialized
 			//
 			if (IsEnumerable) {
 				ec.Emit (OpCodes.Dup);
 				ec.EmitInt ((int)State.Uninitialized);
 
 				var field = IteratorHost.PC.Spec;
 				if (Storey.MemberName.IsGeneric) {
 					field = MemberCache.GetMember (Storey.Instance.Type, field);
 				}
 
 				ec.Emit (OpCodes.Stfld, field);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="221" nfragments="4">
<clone_fragment endline="2282" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" hamdist="0" pcid="1125" startline="2262"><![CDATA[
 		
 		bool pp_unary (ref string s)
 		{
 			s = s.Trim ();
 			int len = s.Length;
 
 			if (len > 0){
 				if (s [0] == '!'){
 					if (len > 1 && s [1] == '='){
 						Error_InvalidDirective ();
 						return false;
 					}
 					s = s.Substring (1);
 					return ! pp_primary (ref s);
 				} else
 					return pp_primary (ref s);
 			} else {
 				Error_InvalidDirective ();
 				return false;
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="2309" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" hamdist="9" pcid="1127" startline="2283"><![CDATA[
 		
 		bool pp_eq (ref string s)
 		{
 			bool va = pp_unary (ref s);
 
 			s = s.Trim ();
 			int len = s.Length;
 			if (len > 0){
 				if (s [0] == '='){
 					if (len > 2 && s [1] == '='){
 						s = s.Substring (2);
 						return va == pp_unary (ref s);
 					} else {
 						Error_InvalidDirective ();
 						return false;
 					}
 				} else if (s [0] == '!' && len > 1 && s [1] == '='){
 					s = s.Substring (2);
 
 					return va != pp_unary (ref s);
 
 				} 
 			}
 
 			return va;
 				
 		}
]]></clone_fragment>
<clone_fragment endline="2329" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" hamdist="9" pcid="1129" startline="2310"><![CDATA[
 		
 		bool pp_and (ref string s)
 		{
 			bool va = pp_eq (ref s);
 
 			s = s.Trim ();
 			int len = s.Length;
 			if (len > 0){
 				if (s [0] == '&'){
 					if (len > 2 && s [1] == '&'){
 						s = s.Substring (2);
 						return (va & pp_and (ref s));
 					} else {
 						Error_InvalidDirective ();
 						return false;
 					}
 				} 
 			}
 			return va;
 		}
]]></clone_fragment>
<clone_fragment endline="2358" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" hamdist="7" pcid="1131" startline="2330"><![CDATA[
 		
 		//
 		// Evaluates an expression for `#if' or `#elif'
 		//
 		bool pp_expr (ref string s, bool isTerm)
 		{
 			bool va = pp_and (ref s);
 			s = s.Trim ();
 			int len = s.Length;
 			if (len > 0){
 				char c = s [0];
 				
 				if (c == '|'){
 					if (len > 2 && s [1] == '|'){
 						s = s.Substring (2);
 						return va | pp_expr (ref s, isTerm);
 					} else {
 						Error_InvalidDirective ();
 						return false;
 					}
 				}
 				if (isTerm) {
 					Error_EndLineExpected ();
 					return false;
 				}
 			}
 			
 			return va;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="222" nfragments="3">
<clone_fragment endline="457" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" hamdist="0" pcid="2053" startline="437"><![CDATA[
 		}
 
 		// The ISymbolDocumentWriter interface is used by the symbol writer to
 		// describe a single source file - for each source file there's exactly
 		// one corresponding ISymbolDocumentWriter instance.
 		//
 		// This class has an internal hash table mapping source document names
 		// to such ISymbolDocumentWriter instances - so there's exactly one
 		// instance per document.
 		//
 		// This property returns the ISymbolDocumentWriter instance which belongs
 		// to the location's source file.
 		//
 		// If we don't have a symbol writer, this property is always null.
 		public SourceFile SourceFile {
 			get {
 				int index = File;
 				if (index == 0)
 					return null;
 				return (SourceFile) source_list [index - 1];
 			}
]]></clone_fragment>
<clone_fragment endline="59" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="11" pcid="1303" startline="35"><![CDATA[
 
 		/// <summary>
 		///   We already know that the statement is unreachable, but we still
 		///   need to resolve it to catch errors.
 		/// </summary>
 		public virtual bool ResolveUnreachable (BlockContext ec, bool warn)
 		{
 			//
 			// This conflicts with csc's way of doing this, but IMHO it's
 			// the right thing to do.
 			//
 			// If something is unreachable, we still check whether it's
 			// correct.  This means that you cannot use unassigned variables
 			// in unreachable code, for instance.
 			//
 
 			if (warn)
 				ec.Report.Warning (162, 2, loc, "Unreachable code detected");
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Block, loc);
 			bool ok = Resolve (ec);
 			ec.KillFlowBranching ();
 
 			return ok;
 		}
]]></clone_fragment>
<clone_fragment endline="362" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" hamdist="19" pcid="441" startline="322"><![CDATA[
 		}
 
 		protected Options flags;
 
 		//
 		// Whether we are inside an anonymous method.
 		//
 		public AnonymousExpression CurrentAnonymousMethod;
 
 		//
 		// Holds a varible used during collection or object initialization.
 		//
 		public Expression CurrentInitializerVariable;
 
 		public Block CurrentBlock;
 
 		public readonly IMemberContext MemberContext;
 
 		/// <summary>
 		///   If this is non-null, points to the current switch statement
 		/// </summary>
 		public Switch Switch;
 
 		public ResolveContext (IMemberContext mc)
 		{
 			if (mc == null)
 				throw new ArgumentNullException ();
 
 			MemberContext = mc;
 
 			//
 			// The default setting comes from the command line option
 			//
 			if (RootContext.Checked)
 				flags |= Options.CheckedScope;
 
 			//
 			// The constant check state is always set to true
 			//
 			flags |= Options.ConstantCheckState;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="223" nfragments="2">
<clone_fragment endline="481" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" hamdist="0" pcid="5199" startline="461"><![CDATA[
 
 		/// <summary>
 		///   Executes the given expression or statement.
 		/// </summary>
 		/// <remarks>
 		///    Executes the provided statement, returns true
 		///    on success, false on parsing errors.  Exceptions
 		///    might be thrown by the called code.
 		/// </remarks>
 		public static bool Run (string statement)
 		{
 			if (!inited)
 				Init ();
 
 			object result;
 			bool result_set;
 
 			bool ok = Evaluate (statement, out result, out result_set) == null;
 			
 			return ok;
 		}
]]></clone_fragment>
<clone_fragment endline="330" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" hamdist="7" pcid="5193" startline="298"><![CDATA[
 
 		/// <summary>
 		///   Compiles the input string and returns a delegate that represents the compiled code.
 		/// </summary>
 		/// <remarks>
 		///
 		///   Compiles the input string as a C# expression or
 		///   statement, unlike the Evaluate method, the
 		///   resulting delegate can be invoked multiple times
 		///   without incurring in the compilation overhead.
 		///
 		///   This method can only deal with fully formed input
 		///   strings and does not provide a completion mechanism.
 		///   If you must deal with partial input (for example for
 		///   interactive use) use the other overload. 
 		///
 		///   On success, a delegate is returned that can be used
 		///   to invoke the method.
 		///
 	        /// </remarks>
 		static public CompiledMethod Compile (string input)
 		{
 			CompiledMethod compiled;
 
 			// Ignore partial inputs
 			if (Compile (input, out compiled) != null){
 				// Error, the input was partial.
 				return null;
 			}
 
 			// Either null (on error) or the compiled method.
 			return compiled;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="224" nfragments="2">
<clone_fragment endline="465" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" hamdist="0" pcid="5639" startline="445"><![CDATA[
 		}
 
 		private void LazyParseArguments()
 		{
 			ByteReader br = module.GetBlob(module.CustomAttribute.records[index].Value);
 			if (br.Length == 0)
 			{
 				// it's legal to have an empty blob
 				lazyConstructorArguments = Empty<CustomAttributeTypedArgument>.Array;
 				lazyNamedArguments = Empty<CustomAttributeNamedArgument>.Array;
 			}
 			else
 			{
 				if (br.ReadUInt16() != 1)
 				{
 					throw new BadImageFormatException();
 				}
 				lazyConstructorArguments = ReadConstructorArguments(module.Assembly, br, Constructor);
 				lazyNamedArguments = ReadNamedArguments(module.Assembly, br, br.ReadUInt16(), Constructor.DeclaringType);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="87" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" hamdist="12" pcid="5607" startline="68"><![CDATA[
 
 		internal CustomAttributeData(Assembly asm, ConstructorInfo constructor, ByteReader br)
 		{
 			this.lazyConstructor = constructor;
 			if (br.Length == 0)
 			{
 				// it's legal to have an empty blob
 				lazyConstructorArguments = Empty<CustomAttributeTypedArgument>.Array;
 				lazyNamedArguments = Empty<CustomAttributeNamedArgument>.Array;
 			}
 			else
 			{
 				if (br.ReadUInt16() != 1)
 				{
 					throw new BadImageFormatException();
 				}
 				lazyConstructorArguments = ReadConstructorArguments(asm, br, constructor);
 				lazyNamedArguments = ReadNamedArguments(asm, br, br.ReadUInt16(), constructor.DeclaringType);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="225" nfragments="2">
<clone_fragment endline="155" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" hamdist="0" pcid="2223" startline="135"><![CDATA[
 			}
 		}
 
 		public static readonly string UnderlyingValueField = "value__";
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE;
 
 		public Enum (NamespaceEntry ns, DeclSpace parent, TypeExpression type,
 			     Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			base_type_expr = type;
 			var accmods = IsTopLevel ? Modifiers.INTERNAL 
 			ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod_flags, accmods, Location, Report);
 			spec = new EnumSpec (null, this, null, null, ModFlags);
 		}
]]></clone_fragment>
<clone_fragment endline="2393" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" hamdist="10" pcid="3855" startline="2363"><![CDATA[
 		}
 	}
 
 
 	// TODO
 	public class Class 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.ABSTRACT |
 			Modifiers.SEALED |
 			Modifiers.STATIC |
 			Modifiers.UNSAFE;
 
 		public const TypeAttributes StaticClassAttribute = TypeAttributes.Abstract | TypeAttributes.Sealed;
 
 		public Class (NamespaceEntry ns, DeclSpace parent, MemberName name, Modifiers mod,
 			      Attributes attrs)
 			
 		{
 			var accmods = (Parent == null || Parent.Parent == null) ? Modifiers.INTERNAL 
 			this.ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod, accmods, Location, Report);
 			spec = new TypeSpec (Kind, null, this, null, ModFlags);
 
 			if (IsStatic && RootContext.Version == LanguageVersion.ISO_1) {
 				Report.FeatureIsNotAvailable (Location, "static classes");
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="226" nfragments="2">
<clone_fragment endline="487" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" hamdist="0" pcid="667" startline="474"><![CDATA[
 
 		public int Size
 		{
 			get
 			{
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return this.ModuleBuilder.ClassLayout.records[i].ClassSize;
 					}
 				}
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return this.ModuleBuilder.ClassLayout.records[i].ClassSize;
 					}
 				}
 				return 0;
 			}
]]></clone_fragment>
<clone_fragment endline="502" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" hamdist="5" pcid="669" startline="488"><![CDATA[
 		}
 
 		public PackingSize PackingSize
 		{
 			get
 			{
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return (PackingSize)this.ModuleBuilder.ClassLayout.records[i].PackingSize;
 					}
 				}
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return (PackingSize)this.ModuleBuilder.ClassLayout.records[i].PackingSize;
 					}
 				}
 				return PackingSize.Unspecified;
 			}
]]></clone_fragment>
</clone_group>
<clone_group groupid="227" nfragments="3">
<clone_fragment endline="239" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\ConstructedTypeName.vb" hamdist="0" pcid="9821" startline="219"><![CDATA[
 
     Function VerifyConstraints() As Boolean
         Dim result As Boolean = True
 
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim arguments As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim git As GenericInstanceType
         Dim td As TypeDefinition
 
         git = TryCast(m_ResolvedType, GenericInstanceType)
         td = CecilHelper.FindDefinition(git)
 
         If git Is Nothing OrElse td Is Nothing Then Return True
 
         parameters = td.GenericParameters
         arguments = git.GenericArguments
 
         result = Helper.VerifyConstraints(Me, parameters, arguments)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="500" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" hamdist="10" pcid="6755" startline="479"><![CDATA[
     End Property
 
     Function VerifyConstraints() As Boolean
         Dim result As Boolean = True
 
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim arguments As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim mit As GenericInstanceMethod
         Dim md As MethodDefinition
 
         mit = TryCast(ResolvedMethod, GenericInstanceMethod)
         md = CecilHelper.FindDefinition(mit)
 
         If mit Is Nothing OrElse md Is Nothing Then Return True
 
         parameters = md.GenericParameters
         arguments = mit.GenericArguments
 
         result = Helper.VerifyConstraints(Me.Parent, parameters, arguments)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="455" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" hamdist="12" pcid="7111" startline="423"><![CDATA[
 
     Private Function ResolveDelegateInvocation(ByVal Context As ParsedObject, ByVal DelegateType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
         Dim invokeMethod As Mono.Cecil.MethodReference
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim argTypes As Generic.List(Of Mono.Cecil.TypeReference)
         Dim paramTypes() As Mono.Cecil.TypeReference
         Dim Compiler As Compiler = Context.Compiler
 
         invokeMethod = Helper.GetInvokeMethod(Compiler, DelegateType)
         params = Helper.GetParameters(Compiler, invokeMethod)
         paramTypes = Helper.GetTypes(params)
         argTypes = m_ArgumentList.GetTypes
 
         If argTypes.Count <> paramTypes.Length Then Return False
 
         For i As Integer = 0 To argTypes.Count - 1
             If Compiler.TypeResolution.IsImplicitlyConvertible(Context, argTypes(i), paramTypes(i)) = False Then
                 Helper.AddError(Me, "Cannot convert implicitly from '" & argTypes(i).Name & "' to '" & paramTypes(i).Name & "'")
                 Return False
             End If
         Next
 
         m_InvocationMethod = invokeMethod
 
         If invokeMethod.ReturnType IsNot Nothing Then
             Classification = New ValueClassification(Me, invokeMethod.ReturnType)
         Else
             Classification = New VoidClassification(Me)
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="228" nfragments="3">
<clone_fragment endline="596" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7563" startline="577"><![CDATA[
 
     ''' <summary>
     ''' Removes private members if they are from an external assembly.
     ''' </summary>
     ''' <param name="Members"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function FilterExternalInaccessible(ByVal Compiler As Compiler, ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
         For i As Integer = 0 To Members.Count - 1
             Dim member As Mono.Cecil.MemberReference = Members(i)
             If (IsPrivate(member) OrElse IsFriend(member)) AndAlso Compiler.Assembly.IsDefinedHere(CecilHelper.FindDefinition(member.DeclaringType)) = False Then
                 Continue For
             End If
             result.Add(member)
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="564" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="12" pcid="7559" startline="543"><![CDATA[
 
     ''' <summary>
     ''' Returns all the members in the types with the specified name.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetMembersOfTypes(ByVal Compiler As Compiler, ByVal Types As TypeList, ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
 
         If Types Is Nothing Then Return Nothing
 
         For Each type As Mono.Cecil.TypeReference In Types
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             members = Compiler.TypeManager.GetCache(type).LookupFlattenedMembers(Name)
             If members IsNot Nothing AndAlso members.Count > 0 Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
                 result.AddRange(members)
             End If
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="542" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="3" pcid="7557" startline="521"><![CDATA[
 
     ''' <summary>
     ''' Returns all the members in the types with the specified name.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetMembersOfTypes(ByVal Compiler As Compiler, ByVal Types As TypeDictionary, ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
 
         If Types Is Nothing Then Return Nothing
 
         For Each type As Mono.Cecil.TypeReference In Types.Values
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             members = Compiler.TypeManager.GetCache(type).LookupFlattenedMembers(Name)
             If members IsNot Nothing Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
                 result.AddRange(members)
             End If
         Next
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="229" nfragments="2">
<clone_fragment endline="133" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="0" pcid="473" startline="114"><![CDATA[
 
 		internal void WriteCompressedInt(int value)
 		{
 			if (value <= 0x7F)
 			{
 				Write((byte)value);
 			}
 			else if (value <= 0x3FFF)
 			{
 				Write((byte)(0x80 | (value >> 8)));
 				Write((byte)value);
 			}
 			else
 			{
 				Write((byte)(0xC0 | (value >> 24)));
 				Write((byte)(value >> 16));
 				Write((byte)(value >> 8));
 				Write((byte)value);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="196" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" hamdist="0" pcid="845" startline="177"><![CDATA[
 
 		internal void WriteCompressedInt(int value)
 		{
 			if (value <= 0x7F)
 			{
 				Write((byte)value);
 			}
 			else if (value <= 0x3FFF)
 			{
 				Write((byte)(0x80 | (value >> 8)));
 				Write((byte)value);
 			}
 			else
 			{
 				Write((byte)(0xC0 | (value >> 24)));
 				Write((byte)(value >> 16));
 				Write((byte)(value >> 8));
 				Write((byte)value);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="230" nfragments="2">
<clone_fragment endline="186" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" hamdist="0" pcid="9873" startline="170"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Skips tokens until a newline is found.
     ''' Returns if CodeEnd of EndOfFile found.
     ''' </summary>
     ''' <param name="EatNewLine">Eat the newline character?</param>
     ''' <param name="ReportError">Report the error "End of line expected."? (Always shown if this paramter is true.</param>
     ''' <remarks></remarks>
     Sub GotoNewline(ByVal EatNewLine As Boolean, Optional ByVal ReportError As Boolean = False)
         If ReportError Then Compiler.Report.ShowMessage(Messages.VBNC90018, CurrentLocation)
 
         Do Until CurrentToken.IsEndOfLine
             NextToken()
         Loop
         Do Until CurrentToken.IsEndOfLine
             NextToken()
         Loop
         If EatNewLine AndAlso CurrentToken.IsEndOfFile = False Then NextToken()
     End Sub
]]></clone_fragment>
<clone_fragment endline="241" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TokenManager.vb" hamdist="10" pcid="9877" startline="223"><![CDATA[
 
     ''' <summary>
     ''' Skips tokens until it finds any of the specified tokens.
     ''' If StopOnNewLine = True then stops also when a NewLine is found 
     ''' (the newline token is not eaten).
     ''' </summary>
     ''' <param name="StopOnNewline"></param>
     ''' <param name="Specials"></param>
     ''' <remarks></remarks>
     Sub GotoAny(ByVal StopOnNewline As Boolean, ByVal ParamArray Specials() As KS)
         Do Until (CurrentToken.Equals(Specials))
             If StopOnNewline AndAlso CurrentToken.IsEndOfLine Then
                 Return
             ElseIf CurrentToken.IsEndOfFile Then
                 Return
             End If
             NextToken()
         Loop
         Do Until (CurrentToken.Equals(Specials))
             If StopOnNewline AndAlso CurrentToken.IsEndOfLine Then
                 Return
             ElseIf CurrentToken.IsEndOfFile Then
                 Return
             End If
             NextToken()
         Loop
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="231" nfragments="2">
<clone_fragment endline="1989" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="0" pcid="4387" startline="1970"><![CDATA[
 
 		public void EmitAttribute (ParameterBuilder builder, decimal value, Location loc)
 		{
 			if (Resolve (loc) == null)
 				return;
 
 			if (ctor == null && !ResolveConstructor (loc, TypeManager.byte_type, TypeManager.byte_type, TypeManager.uint32_type, TypeManager.uint32_type, TypeManager.uint32_type))
 				return;
 
 			int[] bits = decimal.GetBits (value);
 			AttributeEncoder encoder = new AttributeEncoder ();
 			encoder.Encode ((byte) (bits[3] >> 16));
 			encoder.Encode ((byte) (bits[3] >> 31));
 			encoder.Encode ((uint) bits[2]);
 			encoder.Encode ((uint) bits[1]);
 			encoder.Encode ((uint) bits[0]);
 			encoder.EncodeEmptyNamedArguments ();
 
 			EmitAttribute (builder, encoder);
 		}
]]></clone_fragment>
<clone_fragment endline="2009" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="2" pcid="4389" startline="1990"><![CDATA[
 
 		public void EmitAttribute (FieldBuilder builder, decimal value, Location loc)
 		{
 			if (Resolve (loc) == null)
 				return;
 
 			if (ctor == null && !ResolveConstructor (loc, TypeManager.byte_type, TypeManager.byte_type, TypeManager.uint32_type, TypeManager.uint32_type, TypeManager.uint32_type))
 				return;
 
 			int[] bits = decimal.GetBits (value);
 			AttributeEncoder encoder = new AttributeEncoder ();
 			encoder.Encode ((byte) (bits[3] >> 16));
 			encoder.Encode ((byte) (bits[3] >> 31));
 			encoder.Encode ((uint) bits[2]);
 			encoder.Encode ((uint) bits[1]);
 			encoder.Encode ((uint) bits[0]);
 			encoder.EncodeEmptyNamedArguments ();
 
 			EmitAttribute (builder, encoder);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="232" nfragments="3">
<clone_fragment endline="55" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" hamdist="0" pcid="8837" startline="45"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]></clone_fragment>
<clone_fragment endline="66" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" hamdist="2" pcid="8839" startline="56"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = New VariableIdentifier(Me, VariableIdentifier)
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]></clone_fragment>
<clone_fragment endline="78" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" hamdist="2" pcid="8841" startline="67"><![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = New VariableIdentifier(Me, VariableIdentifier)
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(New Modifiers(), Identifier.Name)
 
         m_VariableIdentifier = New VariableIdentifier(Me, Identifier)
         m_IsNew = IsNew
         m_TypeName = New TypeName(Me, TypeName)
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="233" nfragments="2">
<clone_fragment endline="4831" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="0" pcid="9199" startline="4812"><![CDATA[
 
     ''' <summary>
     ''' VariableDeclarators  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLocalVariableDeclarators(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As New Generic.List(Of LocalVariableDeclaration)
 
         Do
             Dim tmp As New Generic.List(Of LocalVariableDeclaration)
             tmp = ParseLocalVariableDeclarator(Parent, Modifiers, Info)
             If tmp Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result.AddRange(tmp)
             End If
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="4853" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="6" pcid="9201" startline="4832"><![CDATA[
 
     ''' <summary>
     ''' VariableDeclarators  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeVariableDeclarators(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As New Generic.List(Of TypeVariableDeclaration)
 
         Do
             Dim tmp As New Generic.List(Of TypeVariableDeclaration)
             'Console.WriteLine("ParseTypeVariableDeclarators...")
             tmp = ParseTypeVariableDeclarator(Parent, Modifiers, Info)
             'Console.WriteLine("Got something
             If tmp Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result.AddRange(tmp)
             End If
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="234" nfragments="2">
<clone_fragment endline="964" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="0" pcid="595" startline="942"><![CDATA[
 		}
 
 		public bool IsPrimitive
 		{
 			get
 			{
 				Universe u = this.Module.universe;
 				return this == u.System_Boolean
 					|| this == u.System_Byte
 					|| this == u.System_SByte
 					|| this == u.System_Int16
 					|| this == u.System_UInt16
 					|| this == u.System_Int32
 					|| this == u.System_UInt32
 					|| this == u.System_Int64
 					|| this == u.System_UInt64
 					|| this == u.System_IntPtr
 					|| this == u.System_UIntPtr
 					|| this == u.System_Char
 					|| this == u.System_Double
 					|| this == u.System_Single
 					;
 			}
]]></clone_fragment>
<clone_fragment endline="1536" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="5" pcid="623" startline="1515"><![CDATA[
 		}
 
 		internal bool IsPseudoCustomAttribute
 		{
 			get
 			{
 				Universe u = this.Module.universe;
 				return this == u.System_NonSerializedAttribute
 					|| this == u.System_SerializableAttribute
 					|| this == u.System_Runtime_InteropServices_DllImportAttribute
 					|| this == u.System_Runtime_InteropServices_FieldOffsetAttribute
 					|| this == u.System_Runtime_InteropServices_InAttribute
 					|| this == u.System_Runtime_InteropServices_MarshalAsAttribute
 					|| this == u.System_Runtime_InteropServices_OutAttribute
 					|| this == u.System_Runtime_InteropServices_StructLayoutAttribute
 					|| this == u.System_Runtime_InteropServices_OptionalAttribute
 					|| this == u.System_Runtime_InteropServices_PreserveSigAttribute
 					|| this == u.System_Runtime_InteropServices_ComImportAttribute
 					|| this == u.System_Runtime_CompilerServices_SpecialNameAttribute
 					|| this == u.System_Runtime_CompilerServices_MethodImplAttribute
 					;
 			}
]]></clone_fragment>
</clone_group>
<clone_group groupid="235" nfragments="2">
<clone_fragment endline="384" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" hamdist="0" pcid="1909" startline="369"><![CDATA[
 
 		private static bool IsEqual(byte[] b1, byte[] b2)
 		{
 			if (b1.Length != b2.Length)
 			{
 				return false;
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="351" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" hamdist="9" pcid="3271" startline="324"><![CDATA[
 
 		internal bool MatchParameterTypes(Type[] types)
 		{
 			if (types == parameterTypes)
 			{
 				return true;
 			}
 			if (types == null)
 			{
 				return parameterTypes.Length == 0;
 			}
 			if (parameterTypes == null)
 			{
 				return types.Length == 0;
 			}
 			if (types.Length == parameterTypes.Length)
 			{
 				for (int i = 0; i < types.Length; i++)
 				{
 					if (!Util.TypeEquals(types[i], parameterTypes[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < types.Length; i++)
 				{
 					if (!Util.TypeEquals(types[i], parameterTypes[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="236" nfragments="3">
<clone_fragment endline="158" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" hamdist="0" pcid="6299" startline="136"><![CDATA[
 
     Function RuleUnaryNegation(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing
 
         If CurrentToken.Equals(KS.Minus) Then
             NextToken()
             RuleUnaryNegation = RuleExponent(LSide)
 
             Dim op1 As Double
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 LSide = 0
             Else
                 LSide = -op1
             End If
         Else
             If RuleExponent(LSide) = False Then
                 Return False
             End If
         End If
         Result = LSide
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="446" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" hamdist="9" pcid="6315" startline="424"><![CDATA[
 
     Function RuleNot(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing
 
         If CurrentToken.Equals(KS.Not) Then
             NextToken()
             RuleNot = RuleRelational(LSide)
 
             Dim op1 As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 LSide = 0
             Else
                 LSide = Not op1
             End If
         Else
             If RuleRelational(LSide) = False Then
                 Return False
             End If
         End If
         Result = LSide
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="345" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" hamdist="10" pcid="6309" startline="320"><![CDATA[
 
     Function RuleStringConcat(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleAdditionSubtractionStringConcat(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Concat)
             NextToken()
             RuleAdditionSubtractionStringConcat(RSide)
 
             Dim op1, op2 As String
             Dim bErr As Boolean
 
             op1 = LSide.ToString
             op2 = RSide.ToString
 
             If bErr Then
                 LSide = ""
             Else
                 LSide = op1 & op2
             End If
         End While
         While CurrentToken.Equals(KS.Concat)
             NextToken()
             RuleAdditionSubtractionStringConcat(RSide)
 
             Dim op1, op2 As String
             Dim bErr As Boolean
 
             op1 = LSide.ToString
             op2 = RSide.ToString
 
             If bErr Then
                 LSide = ""
             Else
                 LSide = op1 & op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="237" nfragments="2">
<clone_fragment endline="499" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="0" pcid="8917" startline="482"><![CDATA[
 
     ''' <summary>
     '''  Attributes 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributes(ByVal Parent As ParsedObject, ByVal Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Attributes IsNot Nothing)
 
         While AttributeBlock.IsMe(tm)
             If ParseAttributeBlock(Parent, Attributes) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End While
         While AttributeBlock.IsMe(tm)
             If ParseAttributeBlock(Parent, Attributes) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End While
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="516" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="7" pcid="8919" startline="500"><![CDATA[
     ''' <summary>
     '''  Parses attributes (if any). Always returns something.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributes(ByVal Parent As ParsedObject) As Attributes
         Dim result As New Attributes(Parent)
 
         If Attributes.IsMe(tm) Then
             While AttributeBlock.IsMe(tm)
                 If ParseAttributeBlock(Parent, result) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End While
             While AttributeBlock.IsMe(tm)
                 If ParseAttributeBlock(Parent, result) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End While
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="238" nfragments="2">
<clone_fragment endline="8677" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="0" pcid="5057" startline="8655"><![CDATA[
 		public static readonly Expression Null = new EmptyExpression ();
 
 		public class OutAccess 
 		{
 			public static readonly OutAccess Instance = new OutAccess ();
 
 			public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 			{
 				rc.Report.Error (206, right_side.Location,
 					"A property, indexer or dynamic member access may not be passed as `ref' or `out' parameter");
 
 				return null;
 			}
 		}
 
 		public static readonly EmptyExpression LValueMemberAccess = new EmptyExpression ();
 		public static readonly EmptyExpression LValueMemberOutAccess = new EmptyExpression ();
 		public static readonly EmptyExpression UnaryAddress = new EmptyExpression ();
 		public static readonly EmptyExpression EventAddition = new EmptyExpression ();
 		public static readonly EmptyExpression EventSubtraction = new EmptyExpression ();
 		public static readonly EmptyExpression MissingValue = new EmptyExpression (InternalType.FakeInternalType);
 
 		static EmptyExpression temp = new EmptyExpression ();
]]></clone_fragment>
<clone_fragment endline="8683" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="5" pcid="5051" startline="8660"><![CDATA[
 
 			public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 			{
 				rc.Report.Error (206, right_side.Location,
 					"A property, indexer or dynamic member access may not be passed as `ref' or `out' parameter");
 
 				return null;
 			}
 		}
 
 		public static readonly EmptyExpression LValueMemberAccess = new EmptyExpression ();
 		public static readonly EmptyExpression LValueMemberOutAccess = new EmptyExpression ();
 		public static readonly EmptyExpression UnaryAddress = new EmptyExpression ();
 		public static readonly EmptyExpression EventAddition = new EmptyExpression ();
 		public static readonly EmptyExpression EventSubtraction = new EmptyExpression ();
 		public static readonly EmptyExpression MissingValue = new EmptyExpression (InternalType.FakeInternalType);
 
 		static EmptyExpression temp = new EmptyExpression ();
 		public static EmptyExpression Grab ()
 		{
 			EmptyExpression retval = temp == null ? new EmptyExpression () 
 			temp = null;
 			return retval;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="239" nfragments="4">
<clone_fragment endline="262" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="0" pcid="489" startline="240"><![CDATA[
 
 		internal void WriteCustomAttributeType(int token)
 		{
 			switch (token >> 24)
 			{
 				case MethodDefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 2;
 					break;
 				case MemberRefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 3;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigCustomAttributeType)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="442" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="10" pcid="511" startline="420"><![CDATA[
 
 		internal void WriteMethodDefOrRef(int token)
 		{
 			switch (token >> 24)
 			{
 				case MethodDefTable.Index
 					token = (token & 0xFFFFFF) << 1 | 0;
 					break;
 				case MemberRefTable.Index
 					token = (token & 0xFFFFFF) << 1 | 1;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigMethodDefOrRef)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="419" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="10" pcid="509" startline="388"><![CDATA[
 
 		internal void WriteMemberRefParent(int token)
 		{
 			switch (token >> 24)
 			{
 				case TypeDefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 0;
 					break;
 				case TypeRefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 1;
 					break;
 				case ModuleRefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 2;
 					break;
 				case MethodDefTable.Index
 					token = (token & 0xFFFFFF) << 3 | 3;
 					break;
 				case TypeSpecTable.Index
 					token = (token & 0xFFFFFF) << 3 | 4;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigMemberRefParent)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="549" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="10" pcid="523" startline="527"><![CDATA[
 
 		internal void WriteMemberForwarded(int token)
 		{
 			switch (token >> 24)
 			{
 				case FieldTable.Index
 					token = (token & 0xFFFFFF) << 1 | 0;
 				    break;
 				case MethodDefTable.Index
 					token = (token & 0xFFFFFF) << 1 | 1;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigMemberForwarded)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="240" nfragments="6">
<clone_fragment endline="7178" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="0" pcid="4949" startline="7161"><![CDATA[
 
 		static bool ContainsDynamicType (TypeSpec type)
 		{
 			if (type == InternalType.Dynamic)
 				return true;
 
 			var element_container = type as ElementTypeSpec;
 			if (element_container != null)
 				return ContainsDynamicType (element_container.Element);
 
 			foreach (var t in type.TypeArguments) {
 				if (ContainsDynamicType (t)) {
 					return true;
 				}
 			}
 			foreach (var t in type.TypeArguments) {
 				if (ContainsDynamicType (t)) {
 					return true;
 				}
 			}
 
 			return false;
 		}
]]></clone_fragment>
<clone_fragment endline="1095" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" hamdist="11" pcid="4087" startline="1077"><![CDATA[
 
 		public bool IsConvertibleToInterface (TypeSpec iface)
 		{
 			if (Interfaces != null) {
 				foreach (var t in Interfaces) {
 					if (t == iface)
 						return true;
 				}
 				foreach (var t in Interfaces) {
 					if (t == iface)
 						return true;
 				}
 			}
 
 			if (TypeArguments != null) {
 				foreach (var t in TypeArguments) {
 					if (((TypeParameterSpec) t).IsConvertibleToInterface (iface))
 						return true;
 				}
 				foreach (var t in TypeArguments) {
 					if (((TypeParameterSpec) t).IsConvertibleToInterface (iface))
 						return true;
 				}
 			}
 
 			return false;
 		}
]]></clone_fragment>
<clone_fragment endline="250" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" hamdist="9" pcid="4671" startline="230"><![CDATA[
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if ((getter != null && getter.IsPublic) || (setter != null && setter.IsPublic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]></clone_fragment>
<clone_fragment endline="283" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="11" pcid="535" startline="265"><![CDATA[
 		}
 
 		public virtual bool ContainsGenericParameters
 		{
 			get
 			{
 				if (this.IsGenericParameter)
 				{
 					return true;
 				}
 				foreach (Type arg in this.GetGenericArguments())
 				{
 					if (arg.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type arg in this.GetGenericArguments())
 				{
 					if (arg.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]></clone_fragment>
<clone_fragment endline="165" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" hamdist="10" pcid="2969" startline="144"><![CDATA[
 		}
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				if (declaringType.ContainsGenericParameters)
 				{
 					return true;
 				}
 				if (methodArgs != null)
 				{
 					foreach (Type type in methodArgs)
 					{
 						if (type.ContainsGenericParameters)
 						{
 							return true;
 						}
 					}
 					foreach (Type type in methodArgs)
 					{
 						if (type.ContainsGenericParameters)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]></clone_fragment>
<clone_fragment endline="272" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" hamdist="10" pcid="4673" startline="251"><![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if ((getter != null && getter.IsStatic) || (setter != null && setter.IsStatic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]></clone_fragment>
</clone_group>
<clone_group groupid="241" nfragments="4">
<clone_fragment endline="95" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CaseStatement.vb" hamdist="0" pcid="9355" startline="73"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim selectparent As SelectStatement = Me.FindFirstParent(Of SelectStatement)()
 
         EndLabel = Emitter.DefineLabel(Info)
         m_StartCode = Emitter.DefineLabel(Info)
 
         If m_IsElse = False Then
             For i As Integer = 0 To m_Clauses.Count - 1
                 Dim clause As CaseClause = m_Clauses.Item(i)
                 result = clause.GenerateCode(Info) AndAlso result
             Next
             Emitter.EmitBranch(Info, EndLabel)
         End If
         Emitter.MarkLabel(Info, m_StartCode)
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, selectparent.EndLabel)
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1107" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="8" pcid="7605" startline="1063"><![CDATA[
 
     Shared Function EmitLoadArrayElement(ByVal Info As EmitInfo, ByVal ArrayVariable As Expression, ByVal Arguments As ArgumentList) As Boolean
         Dim result As Boolean = True
         Dim ArrayType As Mono.Cecil.TypeReference = ArrayVariable.ExpressionType
         Dim ElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim isNonPrimitiveValueType As Boolean = CecilHelper.IsPrimitive(Info.Compiler, ElementType) = False AndAlso CecilHelper.IsValueType(ElementType)
         Dim isArrayGetValue As Boolean = CecilHelper.GetArrayRank(ArrayType) > 1
 
         result = ArrayVariable.GenerateCode(Info) AndAlso result
 
         If isArrayGetValue Then
             result = Arguments.GenerateCode(Info, Helper.CreateArray(Of Mono.Cecil.TypeReference)(Info.Compiler.TypeCache.System_Int32, Arguments.Length)) AndAlso result
             'result = EmitIntegerArray(Info, Arguments) AndAlso result
             Dim getMethod As Mono.Cecil.MethodReference
             getMethod = ArrayElementInitializer.GetGetMethod(Info.Compiler, ArrayType)
             Helper.Assert(getMethod IsNot Nothing, "getMethod for type " & ArrayType.FullName & " could not be found (" & ArrayType.GetType.Name & ")")
             Emitter.EmitCallVirt(Info, getMethod)
             'Emitter.EmitCallOrCallVirt(Info, Info.Compiler.TypeCache.Array_GetValue)
             'If ElementType.IsValueType Then
             '    Emitter.EmitUnbox(Info, ElementType)
             'Else
             '    Emitter.EmitCastClass(Info, Info.Compiler.TypeCache.Object, ElementType)
             'End If
         Else
             Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, Info.Compiler.TypeCache.System_Int32)
             Dim methodtypes(Arguments.Count - 1) As Mono.Cecil.TypeReference
             For i As Integer = 0 To Arguments.Count - 1
                 Dim exp As Expression = Arguments(i).Expression
                 If Info.Compiler.TypeResolution.IsImplicitlyConvertible(Compiler.m_Compiler, exp.ExpressionType, Info.Compiler.TypeCache.System_Int32) = False Then
                     'TODO
                     exp = New CIntExpression(exp, exp)
                 End If
                 result = exp.GenerateCode(elementInfo) AndAlso result
                 methodtypes(i) = Info.Compiler.TypeCache.System_Int32
             Next
 
             If isNonPrimitiveValueType Then
                 Emitter.EmitLoadElementAddress(Info, ElementType, ArrayType)
                 Emitter.EmitLoadObject(Info, ElementType)
             Else
                 Emitter.EmitLoadElement(Info, ArrayType)
             End If
         End If
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1062" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="10" pcid="7603" startline="1019"><![CDATA[
 
     Shared Function EmitStoreArrayElement(ByVal Info As EmitInfo, ByVal ArrayVariable As Expression, ByVal Arguments As ArgumentList) As Boolean
         Dim result As Boolean = True
         Dim ArrayType As Mono.Cecil.TypeReference = ArrayVariable.ExpressionType
         Dim ElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim isNonPrimitiveValueType As Boolean = CecilHelper.IsPrimitive(Info.Compiler, ElementType) = False AndAlso CecilHelper.IsValueType(ElementType)
         Dim isArraySetValue As Boolean = CecilHelper.GetArrayRank(ArrayType) > 1
         Dim newValue As Expression = Info.RHSExpression
 
         Helper.Assert(newValue IsNot Nothing)
         Helper.Assert(newValue.Classification.IsValueClassification)
 
         result = ArrayVariable.GenerateCode(Info.Clone(Info.Context, True, False, ArrayType)) AndAlso result
 
         If isArraySetValue Then
             result = newValue.GenerateCode(Info.Clone(Info.Context, True, False, ElementType)) AndAlso result
             If CecilHelper.IsValueType(ElementType) Then
                 Emitter.EmitBox(Info, ElementType)
             End If
             result = EmitIntegerArray(Info, Arguments) AndAlso result
             Emitter.EmitCallOrCallVirt(Info, Info.Compiler.TypeCache.System_Array__SetValue)
         Else
             Dim methodtypes As New Generic.List(Of Mono.Cecil.TypeReference)
             Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, Info.Compiler.TypeCache.System_Int32)
             For i As Integer = 0 To Arguments.Count - 1
                 result = Arguments(i).GenerateCode(elementInfo) AndAlso result
                 Emitter.EmitConversion(Arguments(i).Expression.ExpressionType, Info.Compiler.TypeCache.System_Int32, Info)
                 methodtypes.Add(Info.Compiler.TypeCache.System_Int32)
             Next
 
             Dim rInfo As EmitInfo = Info.Clone(Info.Context, True, False, ElementType)
             methodtypes.Add(ElementType)
 
             If isNonPrimitiveValueType Then
                 Emitter.EmitLoadElementAddress(Info, ElementType, ArrayType)
                 result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
                 Emitter.EmitStoreObject(Info, ElementType)
             Else
                 result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
                 Emitter.EmitStoreElement(Info, ElementType, ArrayType)
             End If
         End If
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="222" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\ArrayCreationExpression.vb" hamdist="12" pcid="6559" startline="183"><![CDATA[
 
     Private Function EmitElementInitializer(ByVal Info As EmitInfo, ByVal Initializer As VariableInitializer, ByVal CurrentDepth As Integer, ByVal ElementIndex As Integer, ByVal ArrayVariable As Mono.Cecil.Cil.VariableDefinition, ByVal ArrayType As Mono.Cecil.TypeReference, ByVal Indices As Generic.List(Of Integer)) As Boolean
         Dim result As Boolean = True
         Dim vi As VariableInitializer = Initializer
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
 
         If vi.IsRegularInitializer Then
             Emitter.EmitLoadVariable(Info, ArrayVariable)
             For i As Integer = 0 To Indices.Count - 1
                 Emitter.EmitLoadValue(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32), Indices(i))
             Next
             If CecilHelper.IsValueType(elementType) AndAlso CecilHelper.IsPrimitive(Compiler, elementType) = False AndAlso Helper.IsEnum(Compiler, elementType) = False Then
                 Emitter.EmitLoadElementAddress(Info, elementType, ArrayType)
             End If
 
             result = vi.AsRegularInitializer.GenerateCode(Info.Clone(Me, True, False, elementType)) AndAlso result
             If CurrentDepth = 1 Then
                 Emitter.EmitStoreElement(Info, elementType, ArrayType)
             Else
                 Dim setmethod As Mono.Cecil.MethodReference
                 setmethod = New Mono.Cecil.MethodReference("Set", ArrayType, Compiler.TypeCache.System_Void, True, False, Mono.Cecil.MethodCallingConvention.Default)
                 For i As Integer = 0 To CurrentDepth - 1
                     setmethod.Parameters.Add(New Mono.Cecil.ParameterDefinition(Compiler.TypeCache.System_Int32))
                 Next
                 setmethod.Parameters.Add(New Mono.Cecil.ParameterDefinition(CecilHelper.GetElementType(ArrayType)))
                 'setmethod = CecilHelper.FindDefinition(ArrayType).Methods.GetMethod("Set", settypes)
                 Emitter.EmitCallOrCallVirt(Info, setmethod)
             End If
         ElseIf vi.IsArrayElementInitializer Then
             For i As Integer = 0 To vi.AsArrayElementInitializer.Initializers.List.ToArray.GetUpperBound(0)
                 Indices.Add(i)
                 result = EmitElementInitializer(Info, vi.AsArrayElementInitializer.Initializers.List.ToArray()(i), CurrentDepth + 1, i, ArrayVariable, ArrayType, Indices) AndAlso result
                 Indices.RemoveAt(Indices.Count - 1)
             Next
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="242" nfragments="2">
<clone_fragment endline="296" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" hamdist="0" pcid="6085" startline="280"><![CDATA[
 
 		public override string ToString()
 		{
 			StringBuilder sb = new StringBuilder(this.FullName);
 			string sep = "[";
 			foreach (Type arg in GetGenericArguments())
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			foreach (Type arg in GetGenericArguments())
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			if (sep != "[")
 			{
 				sb.Append(']');
 			}
 			return sb.ToString();
 		}
]]></clone_fragment>
<clone_fragment endline="2307" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="9" pcid="5413" startline="2292"><![CDATA[
 		}
 
 		public override string ToString()
 		{
 			StringBuilder sb = new StringBuilder(type.FullName);
 			sb.Append('[');
 			string sep = "";
 			foreach (Type arg in args)
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			foreach (Type arg in args)
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			sb.Append(']');
 			return sb.ToString();
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="243" nfragments="3">
<clone_fragment endline="376" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="0" pcid="9657" startline="354"><![CDATA[
 
     ''' <summary>
     ''' - Base classes for classes, modules, structures, enums, interfaces and delegates are set.
     ''' - Implemented interfaces for classes are set.
     ''' - Type parameters for classes and structures are set.
     ''' - Classes, modules, structures, interfaces, enums,  delegates and events should implement IDefinable.DefineTypeHierarchy()
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineTypeHierarchy " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = DefineTypeHierarchy(type) AndAlso result
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="353" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="7" pcid="9655" startline="331"><![CDATA[
 
 
     ''' <summary>
     ''' - Types are defined with the reflection.emit namespace. 
     ''' - Only classes, modules, structures, interfaces, enums, delegates and eventnos (not a type by itself, bu an event might declare a new delegate). They are only defined, nothing else.
     ''' - Classes, modules, structures, interfaces, enums,  delegates and events should implement IDefinable.DefineType()
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineTypes() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineTypes " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = DefineType(type) AndAlso result
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="453" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="10" pcid="9663" startline="417"><![CDATA[
 
     ''' <summary>
     ''' - All code is emitted for fields with initializers.
     ''' - All the code is emitted for each and every method, constructor, operator and property.
     ''' - Classes, modules, structures, methods, constructors, properties, events, operators should implement IEmittable.Emit(Info as EmitInfo)
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Emit() As Boolean
         Dim result As Boolean = True
 
         result = EmitAttributes() AndAlso result
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Yellow
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Emit " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = Emit(type) AndAlso result
         Next
 
         SetFileVersion()
         SetAdditionalAttributes()
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="244" nfragments="2">
<clone_fragment endline="93" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" hamdist="0" pcid="3169" startline="71"><![CDATA[
 		
 		static bool IList_To_Array(TypeSpec list, ArrayContainer array)
 		{
 			if (array.Rank != 1 || !list.IsGeneric)
 				return false;
 
 			var open_version = list.GetDefinition ();
 			if ((open_version != TypeManager.generic_ilist_type) &&
 				(open_version != TypeManager.generic_icollection_type) &&
 				(open_version != TypeManager.generic_ienumerable_type))
 				return false;
 
 			var arg_type = list.TypeArguments[0];
 			if (array.Element == arg_type)
 				return true;
 			
 			if (MyEmptyExpr == null)
 				MyEmptyExpr = new EmptyExpression (array.Element);
 			else
 				MyEmptyExpr.SetType (array.Element);
 
 			return ImplicitReferenceConversionExists (MyEmptyExpr, arg_type) || ExplicitReferenceConversionExists (array.Element, arg_type);
 		}
]]></clone_fragment>
<clone_fragment endline="70" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" hamdist="12" pcid="3167" startline="40"><![CDATA[
 		
 		//
 		// From a one-dimensional array-type S[] to System.Collections.IList<T> and base
 		// interfaces of this interface, provided there is an implicit reference conversion
 		// from S to T.
 		//
 		static bool ArrayToIList (ArrayContainer array, TypeSpec list, bool isExplicit)
 		{
 			if (array.Rank != 1 || !list.IsGeneric)
 				return false;
 
 			var open_version = list.GetDefinition ();
 			if ((open_version != TypeManager.generic_ilist_type) &&
 				(open_version != TypeManager.generic_icollection_type) &&
 				(open_version != TypeManager.generic_ienumerable_type))
 				return false;
 
 			var arg_type = list.TypeArguments[0];
 			if (array.Element == arg_type)
 				return true;
 
 			if (isExplicit)
 				return ExplicitReferenceConversionExists (array.Element, arg_type);
 
 			if (MyEmptyExpr == null)
 				MyEmptyExpr = new EmptyExpression (array.Element);
 			else
 				MyEmptyExpr.SetType (array.Element);
 
 			return ImplicitReferenceConversionExists (MyEmptyExpr, arg_type);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="245" nfragments="3">
<clone_fragment endline="1928" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="0" pcid="1751" startline="1906"><![CDATA[
 
 		//
 		// It should be used by expressions which require to
 		// register a statement during resolve process.
 		//
 		public void AddScopeStatement (Statement s)
 		{
 			if (scope_initializers == null)
 				scope_initializers = new List<Statement> ();
 
 			//
 			// Simple recursive helper, when resolve scope initializer another
 			// new scope initializer can be added, this ensures it's initialized
 			// before existing one. For now this can happen with expression trees
 			// in base ctor initializer only
 			//
 			if (resolving_init_idx.HasValue) {
 				scope_initializers.Insert (resolving_init_idx.Value, s);
 				++resolving_init_idx;
 			} else {
 				scope_initializers.Add (s);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="544" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" hamdist="11" pcid="5301" startline="504"><![CDATA[
 
 		//
 		// Creates storey instance expression regardless of currect IP
 		//
 		public Expression GetStoreyInstanceExpression (EmitContext ec)
 		{
 			AnonymousExpression am = ec.CurrentAnonymousMethod;
 
 			//
 			// Access from original block -> storey
 			//
 			if (am == null)
 				return Instance;
 
 			//
 			// Access from anonymous method implemented as a static -> storey
 			//
 			if (am.Storey == null)
 				return Instance;
 
 			Field f = am.Storey.GetReferencedStoreyField (this);
 			if (f == null) {
 				if (am.Storey == this) {
 					//
 					// Access inside of same storey (S -> S)
 					//
 					return new CompilerGeneratedThis (CurrentType, Location);
 				}
 				//
 				// External field access
 				//
 				return Instance;
 			}
 
 			//
 			// Storey was cached to local field
 			//
 			FieldExpr f_ind = new FieldExpr (f, Location);
 			f_ind.InstanceExpression = new CompilerGeneratedThis (CurrentType, Location);
 			return f_ind;
 		}
]]></clone_fragment>
<clone_fragment endline="2189" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="12" pcid="1765" startline="2157"><![CDATA[
 		}
 
 		#endregion
 
 		//
 		// Creates anonymous method storey in current block
 		//
 		public AnonymousMethodStorey CreateAnonymousMethodStorey (ResolveContext ec)
 		{
 			//
 			// An iterator has only 1 storey block
 			//
 			if (ec.CurrentIterator != null)
 			    return ec.CurrentIterator.Storey;
 
 			//
 			// When referencing a variable in iterator storey from children anonymous method
 			//
 			if (ParametersBlock.am_storey is IteratorStorey) {
 				return ParametersBlock.am_storey;
 			}
 
 			if (am_storey == null) {
 				MemberBase mc = ec.MemberContext as MemberBase;
 
 				//
 				// Creates anonymous method storey for this block
 				//
 				am_storey = new AnonymousMethodStorey (this, ec.CurrentMemberDefinition.Parent.PartialContainer, mc, ec.CurrentTypeParameters, "AnonStorey");
 			}
 
 			return am_storey;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="246" nfragments="2">
<clone_fragment endline="1026" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="0" pcid="4731" startline="1004"><![CDATA[
 
 		void CreatePredefinedOperators ()
 		{
 			//
 			// Predefined ++ and -- operators exist for the following types
 			// sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal
 			//
 			predefined = new TypeSpec[] {
 				TypeManager.int32_type,
 
 				TypeManager.sbyte_type,
 				TypeManager.byte_type,
 				TypeManager.short_type,
 				TypeManager.ushort_type,
 				TypeManager.uint32_type,
 				TypeManager.int64_type,
 				TypeManager.uint64_type,
 				TypeManager.char_type,
 				TypeManager.float_type,
 				TypeManager.double_type,
 				TypeManager.decimal_type
 			};
 		}
]]></clone_fragment>
<clone_fragment endline="407" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="12" pcid="3665" startline="368"><![CDATA[
 
 		static void CreatePredefinedOperatorsTable ()
 		{
 			predefined_operators = new TypeSpec [(int) Operator.TOP] [];
 
 			//
 			// 7.6.1 Unary plus operator
 			//
 			predefined_operators [(int) Operator.UnaryPlus] = new TypeSpec [] {
 				TypeManager.int32_type, TypeManager.uint32_type,
 				TypeManager.int64_type, TypeManager.uint64_type,
 				TypeManager.float_type, TypeManager.double_type,
 				TypeManager.decimal_type
 			};
 
 			//
 			// 7.6.2 Unary minus operator
 			//
 			predefined_operators [(int) Operator.UnaryNegation] = new TypeSpec [] {
 				TypeManager.int32_type, 
 				TypeManager.int64_type,
 				TypeManager.float_type, TypeManager.double_type,
 				TypeManager.decimal_type
 			};
 
 			//
 			// 7.6.3 Logical negation operator
 			//
 			predefined_operators [(int) Operator.LogicalNot] = new TypeSpec [] {
 				TypeManager.bool_type
 			};
 
 			//
 			// 7.6.4 Bitwise complement operator
 			//
 			predefined_operators [(int) Operator.OnesComplement] = new TypeSpec [] {
 				TypeManager.int32_type, TypeManager.uint32_type,
 				TypeManager.int64_type, TypeManager.uint64_type
 			};
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="247" nfragments="6">
<clone_fragment endline="249" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="0" pcid="875" startline="228"><![CDATA[
 
 		internal int ReadCustomAttributeType()
 		{
 			int codedIndex;
 			if (bigCustomAttributeType)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 7)
 			{
 				case 2
 					return (MethodDefTable.Index << 24) + (codedIndex >> 3);
 				case 3
 					return (MemberRefTable.Index << 24) + (codedIndex >> 3);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="407" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="10" pcid="889" startline="386"><![CDATA[
 
 		internal int ReadMemberForwarded()
 		{
 			int codedIndex;
 			if (bigMemberForwarded)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="385" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="7" pcid="887" startline="364"><![CDATA[
 
 		internal int ReadTypeOrMethodDef()
 		{
 			int codedIndex;
 			if (bigTypeOrMethodDef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="317" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="10" pcid="881" startline="296"><![CDATA[
 
 		internal int ReadHasSemantics()
 		{
 			int codedIndex;
 			if (bigHasSemantics)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (EventTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (PropertyTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="271" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="10" pcid="877" startline="250"><![CDATA[
 
 		internal int ReadMethodDefOrRef()
 		{
 			int codedIndex;
 			if (bigMethodDefOrRef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MemberRefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="339" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="4" pcid="883" startline="318"><![CDATA[
 
 		internal int ReadHasFieldMarshal()
 		{
 			int codedIndex;
 			if (bigHasFieldMarshal)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (ParamTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="248" nfragments="2">
<clone_fragment endline="1503" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7633" startline="1482"><![CDATA[
 
     Shared Function ApplyTypeArguments(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference, ByVal TypeArguments As TypeArgumentList) As Mono.Cecil.MemberReference
         Dim result As Mono.Cecil.MemberReference
         Dim minfo As Mono.Cecil.MethodReference
 
         minfo = TryCast(Member, Mono.Cecil.MethodReference)
         If minfo IsNot Nothing Then
             Dim args As Mono.Collections.Generic.Collection(Of Mono.Cecil.TypeReference)
             args = CecilHelper.GetGenericArguments(minfo)
 
             If args.Count = TypeArguments.Count Then
                 result = TypeArguments.Compiler.TypeManager.MakeGenericMethod(TypeArguments.Parent, minfo, args, TypeArguments.ArgumentCollection)
             Else
                 result = Nothing
             End If
         Else
             result = Nothing
             Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="780" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="11" pcid="7577" startline="752"><![CDATA[
 
     Shared Function FilterByTypeArguments(ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference), ByVal TypeArguments As TypeArgumentList) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim argCount As Integer
 
         If TypeArguments IsNot Nothing Then argCount = TypeArguments.Count
 
         For i As Integer = 0 To Members.Count - 1
             Dim member As Mono.Cecil.MemberReference = Members(i)
 
             Dim minfo As Mono.Cecil.MethodReference = TryCast(member, Mono.Cecil.MethodReference)
             If minfo IsNot Nothing Then
                 If CecilHelper.GetGenericArguments(minfo).Count = argCount Then
                     If argCount > 0 Then
                         member = TypeArguments.Parent.Compiler.TypeManager.MakeGenericMethod(TypeArguments.Parent, minfo, CecilHelper.GetGenericArguments(minfo), TypeArguments.ArgumentCollection)
                         result.Add(member)
                     Else
                         result.Add(member)
                     End If
                 Else
                     'Helper.StopIfDebugging()
                 End If
             Else
                 result.Add(member)
             End If
         Next
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="249" nfragments="3">
<clone_fragment endline="172" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" hamdist="0" pcid="6075" startline="158"><![CDATA[
 
 		public override Type[] __GetDeclaredTypes()
 		{
 			int token = this.MetadataToken;
 			List<Type> list = new List<Type>();
 			// TODO use binary search?
 			for (int i = 0; i < module.NestedClass.records.Length; i++)
 			{
 				if (module.NestedClass.records[i].EnclosingClass == token)
 				{
 					list.Add(module.ResolveType(module.NestedClass.records[i].NestedClass));
 				}
 			}
 			for (int i = 0; i < module.NestedClass.records.Length; i++)
 			{
 				if (module.NestedClass.records[i].EnclosingClass == token)
 				{
 					list.Add(module.ResolveType(module.NestedClass.records[i].NestedClass));
 				}
 			}
 			return list.ToArray();
 		}
]]></clone_fragment>
<clone_fragment endline="360" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" hamdist="11" pcid="5875" startline="344"><![CDATA[
 		}
 
 		public override Type[] GetGenericParameterConstraints()
 		{
 			IGenericContext context = (this.DeclaringMethod as IGenericContext) ?? this.DeclaringType;
 			List<Type> list = new List<Type>();
 			int token = this.MetadataToken;
 			// TODO use binary search
 			for (int i = 0; i < module.GenericParamConstraint.records.Length; i++)
 			{
 				if (module.GenericParamConstraint.records[i].Owner == token)
 				{
 					list.Add(module.ResolveType(module.GenericParamConstraint.records[i].Constraint, context));
 				}
 			}
 			for (int i = 0; i < module.GenericParamConstraint.records.Length; i++)
 			{
 				if (module.GenericParamConstraint.records[i].Owner == token)
 				{
 					list.Add(module.ResolveType(module.GenericParamConstraint.records[i].Constraint, context));
 				}
 			}
 			return list.ToArray();
 		}
]]></clone_fragment>
<clone_fragment endline="317" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" hamdist="18" pcid="6087" startline="297"><![CDATA[
 
 		public override Type DeclaringType
 		{
 			get
 			{
 				// note that we cannot use Type.IsNested for this, because that calls DeclaringType
 				if ((this.Attributes & TypeAttributes.VisibilityMask & ~TypeAttributes.Public) == 0)
 				{
 					return null;
 				}
 				// TODO use binary search (if sorted)
 				int token = this.MetadataToken;
 				for (int i = 0; i < module.NestedClass.records.Length; i++)
 				{
 					if (module.NestedClass.records[i].NestedClass == token)
 					{
 						return module.ResolveType(module.NestedClass.records[i].EnclosingClass, null, null);
 					}
 				}
 				for (int i = 0; i < module.NestedClass.records.Length; i++)
 				{
 					if (module.NestedClass.records[i].NestedClass == token)
 					{
 						return module.ResolveType(module.NestedClass.records[i].EnclosingClass, null, null);
 					}
 				}
 				throw new InvalidOperationException();
 			}
]]></clone_fragment>
</clone_group>
<clone_group groupid="250" nfragments="3">
<clone_fragment endline="293" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="0" pcid="8903" startline="272"><![CDATA[
 
     ''' <summary>
     ''' ImportsClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsClause
         Dim result As New ImportsClause(Parent)
 
         If ImportsAliasClause.IsMe(str) Then
             Dim m_Clause As ImportsAliasClause
             m_Clause = ParseImportsAliasClause(Parent, str)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
             result.Init(m_Clause)
         Else
             Dim m_Clause As ImportsNamespaceClause
             m_Clause = ParseImportsNamespaceClause(Parent, str)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
             result.Init(m_Clause)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="315" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="9" pcid="8905" startline="294"><![CDATA[
 
     ''' <summary>
     ''' ImportsClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsClause(ByVal Parent As ParsedObject) As ImportsClause
         Dim result As New ImportsClause(Parent)
 
         If ImportsAliasClause.IsMe(tm) Then
             Dim m_Clause As ImportsAliasClause
             m_Clause = ParseImportsAliasClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         Else
             Dim m_Clause As ImportsNamespaceClause
             m_Clause = ParseImportsNamespaceClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="968" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" hamdist="15" pcid="7505" startline="941"><![CDATA[
 
     ''' <summary>
     ''' Returns the directory where the system assemblies are installed
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function GetSystemDir() As String
         Dim assemblies() As Reflection.Assembly
         Dim result As String
 
         If Not String.IsNullOrEmpty(CommandLine.SDKPath) Then
             If CommandLine.Verbose Then Report.WriteLine(string.Format ("Using alternate system path
             Return CommandLine.SDKPath
         End If
 
         assemblies = AppDomain.CurrentDomain.GetAssemblies
 
         For Each a As Reflection.Assembly In assemblies
             Dim codebase As String = a.Location
             If codebase.EndsWith("corlib.dll") Then
                 result = codebase.Substring(0, codebase.LastIndexOf(System.IO.Path.DirectorySeparatorChar))
                 If CommandLine.Verbose Then Report.WriteLine(String.Format("Using system path
                 Return result
             End If
         Next
         Throw New InternalException("Cannot compute the system directory.")
         Return ""
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="251" nfragments="2">
<clone_fragment endline="583" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" hamdist="0" pcid="7949" startline="559"><![CDATA[
 
     Function GenerateMyRequest() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Request"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Request As Global.System.Web.HttpRequest" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Request" & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="614" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" hamdist="2" pcid="7951" startline="590"><![CDATA[
 
     Function GenerateMyResponse() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Response"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Response As Global.System.Web.HttpResponse" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Response    " & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="252" nfragments="2">
<clone_fragment endline="93" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventHandlerDeclaration.vb" hamdist="0" pcid="8779" startline="69"><![CDATA[
 
     Private Function CreateRemoveHandlerCode(ByVal Info As EmitInfo) As Boolean
         If Me.IsShared = False Then
             With Info.ILGen
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_1)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Remove), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         Else
             With Info.ILGen
                 .Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_0)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Remove), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         End If
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="119" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventHandlerDeclaration.vb" hamdist="4" pcid="8781" startline="94"><![CDATA[
 
     Private Function CreateAddHandlerCode(ByVal Info As EmitInfo) As Boolean
         Helper.Assert([EventParent].EventField IsNot Nothing)
         If Me.IsShared = False Then
             With Info.ILGen
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_1)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Combine), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         Else
             With Info.ILGen
                 .Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_0)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Combine), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         End If
         Return True
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="253" nfragments="2">
<clone_fragment endline="1514" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="0" pcid="621" startline="1497"><![CDATA[
 
 		internal bool IsAllowMultipleCustomAttribute
 		{
 			get
 			{
 				IList<CustomAttributeData> cad = GetCustomAttributesData(this.Module.universe.System_AttributeUsageAttribute);
 				if (cad.Count == 1)
 				{
 					foreach (CustomAttributeNamedArgument arg in cad[0].NamedArguments)
 					{
 						if (arg.MemberInfo.Name == "AllowMultiple")
 						{
 							return (bool)arg.TypedValue.Value;
 						}
 					}
 					foreach (CustomAttributeNamedArgument arg in cad[0].NamedArguments)
 					{
 						if (arg.MemberInfo.Name == "AllowMultiple")
 						{
 							return (bool)arg.TypedValue.Value;
 						}
 					}
 				}
 				return false;
 			}
]]></clone_fragment>
<clone_fragment endline="610" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" hamdist="9" pcid="5649" startline="594"><![CDATA[
 
 		private static bool IsInheritableAttribute(Type attribute)
 		{
 			Type attributeUsageAttribute = attribute.Module.universe.System_AttributeUsageAttribute;
 			IList<CustomAttributeData> attr = attribute.GetCustomAttributesData(attributeUsageAttribute);
 			if (attr.Count != 0)
 			{
 				foreach (CustomAttributeNamedArgument named in attr[0].NamedArguments)
 				{
 					if (named.MemberInfo.Name == "Inherited")
 					{
 						return (bool)named.TypedValue.Value;
 					}
 				}
 				foreach (CustomAttributeNamedArgument named in attr[0].NamedArguments)
 				{
 					if (named.MemberInfo.Name == "Inherited")
 					{
 						return (bool)named.TypedValue.Value;
 					}
 				}
 			}
 			return true;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="254" nfragments="5">
<clone_fragment endline="141" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="0" pcid="869" startline="118"><![CDATA[
 
 		internal int ReadTypeDefOrRef()
 		{
 			int codedIndex;
 			if (bigTypeDefOrRef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (TypeRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (TypeSpecTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="363" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="6" pcid="885" startline="340"><![CDATA[
 
 		internal int ReadHasDeclSecurity()
 		{
 			int codedIndex;
 			if (bigHasDeclSecurity)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (AssemblyTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="431" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="7" pcid="891" startline="408"><![CDATA[
 
 		internal int ReadImplementation()
 		{
 			int codedIndex;
 			if (bigImplementation)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (FileTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (AssemblyRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (ExportedTypeTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="295" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="4" pcid="879" startline="272"><![CDATA[
 
 		internal int ReadHasConstant()
 		{
 			int codedIndex;
 			if (bigHasConstant)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (ParamTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (PropertyTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="117" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" hamdist="5" pcid="867" startline="92"><![CDATA[
 
 		internal int ReadResolutionScope()
 		{
 			int codedIndex;
 			if (bigResolutionScope)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (ModuleTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (ModuleRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (AssemblyRefTable.Index << 24) + (codedIndex >> 2);
 				case 3
 					return (TypeRefTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="255" nfragments="2">
<clone_fragment endline="91" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArraySizeInitializationModifier.vb" hamdist="0" pcid="8327" startline="68"><![CDATA[
     End Property
 
     Function CreateArrayType(ByVal OriginalType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = OriginalType
 
         If m_ArrayTypeModifiers IsNot Nothing Then
             result = m_ArrayTypeModifiers.CreateArrayType(result)
         End If
 
         If m_BoundList.Expressions.GetUpperBound(0) = 0 Then
             result = CecilHelper.MakeArrayType(result)
         Else
             Dim arr As ArrayType
             arr = CecilHelper.MakeArrayType(result, m_BoundList.Expressions.GetUpperBound(0) + 1)
             result = arr
             If arr.Rank > 1 Then
                 For d As Integer = 0 To arr.Rank - 1
                     arr.Dimensions(d) = New ArrayDimension(New Nullable(Of Integer)(0), Nothing)
                 Next
             End If
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1467" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="12" pcid="7629" startline="1433"><![CDATA[
 
     Shared Function GetTypeOrTypeReference(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         If Type Is Nothing Then Return Nothing
         If TypeOf Type Is Mono.Cecil.GenericParameter Then Return Type
 
         If Compiler.Assembly.IsDefinedHere(Type) Then
             Return Type
         ElseIf TypeOf Type Is ByReferenceType Then
             Dim refType As ByReferenceType = DirectCast(Type, ByReferenceType)
             Dim elementType As Mono.Cecil.TypeReference
             elementType = GetTypeOrTypeReference(Compiler, refType.ElementType)
             If elementType Is refType.ElementType Then Return Type
             Return New ByReferenceType(elementType)
         ElseIf TypeOf Type Is Mono.Cecil.ArrayType Then
             Dim arrType As Mono.Cecil.ArrayType = DirectCast(Type, Mono.Cecil.ArrayType)
             Dim elementType As Mono.Cecil.TypeReference
             elementType = GetTypeOrTypeReference(Compiler, arrType.ElementType)
             If elementType Is arrType.ElementType Then Return Type
             Dim result As Mono.Cecil.ArrayType = New Mono.Cecil.ArrayType(elementType, arrType.Rank)
             For i As Integer = 0 To arrType.Rank - 1
                 result.Dimensions(i) = arrType.Dimensions(i)
             Next
             Return result
         ElseIf TypeOf Type Is Mono.Cecil.GenericInstanceType Then
             Dim git As Mono.Cecil.GenericInstanceType = DirectCast(Type, Mono.Cecil.GenericInstanceType)
             Dim elementType As Mono.Cecil.TypeReference = GetTypeOrTypeReference(Compiler, git.ElementType)
             Dim result As New Mono.Cecil.GenericInstanceType(elementType)
             For i As Integer = 0 To git.GenericArguments.Count - 1
                 result.GenericArguments.Add(GetTypeOrTypeReference(Compiler, git.GenericArguments(i)))
             Next
             Return result
         Else
             Return Compiler.AssemblyBuilderCecil.MainModule.Import(CecilHelper.FindDefinition(Type))
         End If
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="256" nfragments="2">
<clone_fragment endline="363" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" hamdist="0" pcid="1013" startline="340"><![CDATA[
 	}
 
 	/// <summary>
 	/// Fixed buffer implementation
 	/// </summary>
 	public class FixedField 
 	{
 		public const string FixedElementName = "FixedElementField";
 		static int GlobalCounter = 0;
 
 		TypeBuilder fixed_buffer_type;
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.UNSAFE;
 
 		public FixedField (DeclSpace parent, FullNamedExpression type, Modifiers mod, MemberName name, Attributes attrs)
 			
 		{
 		}
]]></clone_fragment>
<clone_fragment endline="2812" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" hamdist="7" pcid="6253" startline="2785"><![CDATA[
 
 	}
 
 	/// <summary>
 	///   Interfaces
 	/// </summary>
 	public sealed class Interface 
 
 		/// <summary>
 		///   Modifiers allowed in a class declaration
 		/// </summary>
 		public const Modifiers AllowedModifiers =
 			Modifiers.NEW       |
 			Modifiers.PUBLIC    |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL  |
 		 	Modifiers.UNSAFE    |
 			Modifiers.PRIVATE;
 
 		public Interface (NamespaceEntry ns, DeclSpace parent, MemberName name, Modifiers mod,
 				  Attributes attrs)
 			
 		{
 			var accmods = parent.Parent == null ? Modifiers.INTERNAL 
 
 			this.ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod, accmods, name.Location, Report);
 			spec = new TypeSpec (Kind, null, this, null, ModFlags);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="257" nfragments="3">
<clone_fragment endline="855" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" hamdist="0" pcid="3157" startline="832"><![CDATA[
 
 		private static bool IsTypeName (string name)
 		{
 			switch (name) {
 			case "bool"
 			case "byte"
 			case "char"
 			case "decimal"
 			case "double"
 			case "float"
 			case "int"
 			case "long"
 			case "object"
 			case "sbyte"
 			case "short"
 			case "string"
 			case "uint"
 			case "ulong"
 			case "ushort"
 			case "void"
 				return true;
 			}
 			return false;
 		}
]]></clone_fragment>
<clone_fragment endline="571" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" hamdist="0" pcid="111" startline="542"><![CDATA[
 		}
 
 		#endregion
 
 		public override string GetSignatureForError ()
 		{
 			switch (Name) {
 			case "Int32"
 			case "Int64"
 			case "String"
 			case "Boolean"
 			case "Void"
 			case "Object"
 			case "UInt32"
 			case "Int16"
 			case "UInt16"
 			case "UInt64"
 			case "Single"
 			case "Double"
 			case "Decimal"
 			case "Char"
 			case "Byte"
 			case "SByte"
 			}
 
 			if (ns.Length == 0)
 				return name;
 
 			return FullName;
 		}
]]></clone_fragment>
<clone_fragment endline="747" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\OpCodes.cs" hamdist="0" pcid="6115" startline="716"><![CDATA[
 
 		public static bool TakesSingleByteArgument(OpCode inst)
 		{
 			switch (inst.Value)
 			{
 				case 14
 				case 15
 				case 16
 				case 17
 				case 18
 				case 19
 				case 31
 				case 43
 				case 44
 				case 45
 				case 46
 				case 47
 				case 48
 				case 49
 				case 50
 				case 51
 				case 52
 				case 53
 				case 54
 				case 55
 				case 222
 				case -494
 					return true;
 				default
 					return false;
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="258" nfragments="2">
<clone_fragment endline="209" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" hamdist="0" pcid="8773" startline="186"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_ParametersOrType.ResolveTypeReferences AndAlso result
         If EventType IsNot Nothing Then
             'Nothing to do
         ElseIf Type IsNot Nothing Then
             Helper.Assert(EventType Is Nothing)
             EventType = Type.ResolvedType
         ElseIf Parameters IsNot Nothing Then
             Helper.Assert(EventType IsNot Nothing OrElse ImplementsClause IsNot Nothing)
         Else
             Throw New InternalException(Me)
         End If
 
         If m_ImplicitEventDelegate IsNot Nothing Then
             result = m_ImplicitEventDelegate.ResolveTypeReferences AndAlso result
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="475" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" hamdist="10" pcid="6845" startline="450"><![CDATA[
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference 'Descriptor
         Get
             Dim result As Mono.Cecil.TypeReference
             If m_ExpressionType IsNot Nothing Then
                 result = m_ExpressionType
             ElseIf m_Method IsNot Nothing Then
                 result = m_Method.Signature.ReturnType
             ElseIf m_Variable IsNot Nothing Then
                 result = m_Variable.VariableType
             ElseIf m_FieldInfo IsNot Nothing Then
                 If Helper.IsEnum(Compiler, m_FieldInfo.DeclaringType) Then
                     result = m_FieldInfo.DeclaringType
                 Else
                     result = m_FieldInfo.FieldType
                 End If
             ElseIf m_Parameter IsNot Nothing Then
                 result = m_Parameter.ParameterType
             ElseIf m_ArrayVariable IsNot Nothing Then
                 result = CecilHelper.GetElementType(m_ArrayVariable.ExpressionType)
             Else
                 Throw New InternalException(Me)
             End If
             Helper.Assert(result IsNot Nothing)
             Return result
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="259" nfragments="2">
<clone_fragment endline="197" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" hamdist="0" pcid="2915" startline="175"><![CDATA[
 
 		private void PopulateGenericArguments()
 		{
 			if (typeArgs == null)
 			{
 				int token = this.MetadataToken;
 				int first = module.GenericParam.FindFirstByOwner(token);
 				if (first == -1)
 				{
 					typeArgs = Type.EmptyTypes;
 				}
 				else
 				{
 					List<Type> list = new List<Type>();
 					int len = module.GenericParam.records.Length;
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					typeArgs = list.ToArray();
 				}
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="242" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" hamdist="0" pcid="6081" startline="220"><![CDATA[
 
 		private void PopulateGenericArguments()
 		{
 			if (typeArgs == null)
 			{
 				int token = this.MetadataToken;
 				int first = module.GenericParam.FindFirstByOwner(token);
 				if (first == -1)
 				{
 					typeArgs = Type.EmptyTypes;
 				}
 				else
 				{
 					List<Type> list = new List<Type>();
 					int len = module.GenericParam.records.Length;
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					typeArgs = list.ToArray();
 				}
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="260" nfragments="2">
<clone_fragment endline="740" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" hamdist="0" pcid="4627" startline="724"><![CDATA[
 		}
 
 		private TypeDefImpl FindMethodOwner(int methodIndex)
 		{
 			// TODO use binary search?
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int method = TypeDef.records[i].MethodList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1 
 				if (method <= methodIndex && methodIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int method = TypeDef.records[i].MethodList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1 
 				if (method <= methodIndex && methodIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]></clone_fragment>
<clone_fragment endline="639" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" hamdist="4" pcid="4619" startline="624"><![CDATA[
 
 		private TypeDefImpl FindFieldOwner(int fieldIndex)
 		{
 			// TODO use binary search?
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int field = TypeDef.records[i].FieldList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1 
 				if (field <= fieldIndex && fieldIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int field = TypeDef.records[i].FieldList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1 
 				if (field <= fieldIndex && fieldIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="261" nfragments="2">
<clone_fragment endline="2762" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7735" startline="2736"><![CDATA[
 
     Shared Function GetMostEncompassedTypes(ByVal Compiler As Compiler, ByVal Types() As TypeCode) As TypeCode()
         Dim result As Generic.List(Of TypeCode)
 
         If Types Is Nothing Then Return Nothing
         If Types.Length <= 1 Then Return Types
 
         result = New Generic.List(Of TypeCode)(Types)
 
         If result.Count <= 1 Then Return result.ToArray
 
         Dim didSomething As Boolean = False
         Do
             didSomething = False
             For i As Integer = result.Count - 2 To 0 Step -1
                 If IsFirstEncompassingSecond(Compiler, result(i), result(i + 1)) Then
                     result.RemoveAt(i)
                     didSomething = True
                 ElseIf IsFirstEncompassingSecond(Compiler, result(i + 1), result(i)) Then
                     result.RemoveAt(i + 1)
                     didSomething = True
                 End If
             Next
         Loop While didSomething
 
         Return result.ToArray
     End Function
]]></clone_fragment>
<clone_fragment endline="140" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" hamdist="10" pcid="9701" startline="110"><![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_InheritsClauses Is Nothing OrElse m_InheritsClauses.Count > 0) 'Perf check
 
         If m_InheritsClauses IsNot Nothing AndAlso m_InheritsClauses.Count > 0 Then
             For i As Integer = 0 To m_InheritsClauses.Count - 1
                 result = m_InheritsClauses(i).ResolveTypeReferences AndAlso result
             Next
             If result = False Then Return False
 
             For i As Integer = 1 To m_InheritsClauses.Count - 1
                 If Helper.CompareType(m_InheritsClauses(0).ResolvedType, m_InheritsClauses(i).ResolvedType) = False Then
                     Helper.AddError(Compiler, Me.Location, "Class specifies different base classes")
                     result = False
                 End If
             Next
             If result = False Then Return False
             BaseType = m_InheritsClauses(0).ResolvedType
         Else
             BaseType = Compiler.TypeCache.System_Object
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         'Find the default constructors for this class
         Me.FindDefaultConstructors()
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="262" nfragments="13">
<clone_fragment endline="70" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" hamdist="0" pcid="6905" startline="44"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.DateTime, TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="127" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" hamdist="2" pcid="6867" startline="101"><![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="70" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" hamdist="0" pcid="6963" startline="44"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="68" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" hamdist="9" pcid="6971" startline="43"><![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         Dim expType As Mono.Cecil.TypeReference = Expression.ExpressionType
         Dim expTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, expType)
 
         Select Case expTypeCode
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Char_Array) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.System_Char_Array) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="72" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" hamdist="9" pcid="6873" startline="44"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="74" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" hamdist="0" pcid="6993" startline="44"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="73" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" hamdist="0" pcid="6897" startline="44"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30532, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="73" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" hamdist="0" pcid="6921" startline="44"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="73" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" hamdist="0" pcid="6947" startline="44"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="73" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" hamdist="0" pcid="6955" startline="44"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="73" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" hamdist="0" pcid="7001" startline="44"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="73" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" hamdist="0" pcid="7009" startline="44"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="73" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" hamdist="2" pcid="6913" startline="44"><![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="263" nfragments="2">
<clone_fragment endline="2714" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="0" pcid="2341" startline="2689"><![CDATA[
 
 		protected void DoBestMemberChecks<T> (ResolveContext rc, T member) where T 
 		{
 			if (InstanceExpression != null) {
 				InstanceExpression = InstanceExpression.Resolve (rc);
 				CheckProtectedMemberAccess (rc, member);
 			}
 
 			if (member.MemberType.IsPointer && !rc.IsUnsafe) {
 				UnsafeError (rc, loc);
 			}
 
 			var dep = member.GetMissingDependencies ();
 			if (dep != null) {
 				ImportedTypeDefinition.Error_MissingDependency (rc, dep, loc);
 			}
 
 			if (!rc.IsObsolete) {
 				ObsoleteAttribute oa = member.GetAttributeObsolete ();
 				if (oa != null)
 					AttributeTester.Report_ObsoleteMessage (oa, member.GetSignatureForError (), loc, rc.Report);
 			}
 
 			if (!(member is FieldSpec))
 				member.MemberDefinition.SetIsUsed ();
 		}
]]></clone_fragment>
<clone_fragment endline="5161" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="11" pcid="3529" startline="5124"><![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			VariableReference vr;
 			bool vr_locked = false;
 
 			using (ec.Set (ResolveContext.Options.UsingInitializerScope)) {
 				if (decl.Variable == null) {
 					vr = decl.ResolveExpression (ec) as VariableReference;
 					if (vr != null) {
 						vr_locked = vr.IsLockedByStatement;
 						vr.IsLockedByStatement = true;
 					}
 				} else {
 					if (!decl.Resolve (ec))
 						return false;
 
 					if (decl.Declarators != null) {
 						stmt = decl.RewriteForDeclarators (ec, stmt);
 					}
 
 					vr = null;
 				}
 			}
 
 			ec.StartFlowBranching (this);
 
 			stmt.Resolve (ec);
 
 			ec.EndFlowBranching ();
 
 			if (vr != null)
 				vr.IsLockedByStatement = vr_locked;
 
 			base.Resolve (ec);
 
 			return true;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="264" nfragments="2">
<clone_fragment endline="2587" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" hamdist="0" pcid="3869" startline="2564"><![CDATA[
 
 		/// Search for at least one defined condition in ConditionalAttribute of attribute class
 		/// Valid only for attribute classes.
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 
 			if (OptAttributes == null)
 				return null;
 
 			Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 			if (attrs == null)
 				return null;
 
 			string[] conditions = new string[attrs.Length];
 			for (int i = 0; i < conditions.Length; ++i)
 				conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			for (int i = 0; i < conditions.Length; ++i)
 				conditions[i] = attrs[i].GetConditionalAttributeValue ();
 
 			caching_flags |= Flags.Excluded;
 			return conditions;
 		}
]]></clone_fragment>
<clone_fragment endline="711" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="10" pcid="1255" startline="676"><![CDATA[
 		}
 
 		/// <summary>
 		/// Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
 		/// </summary>
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.Excluded) != 0)
 				return new string [0];
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 			string[] conditions;
 
 			if (base_method == null) {
 				if (OptAttributes == null)
 					return null;
 
 				Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 				if (attrs == null)
 					return null;
 
 				conditions = new string[attrs.Length];
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			} else {
 				conditions = base_method.MemberDefinition.ConditionalConditions();
 			}
 
 			if (conditions != null)
 				caching_flags |= Flags.Excluded;
 
 			return conditions;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="265" nfragments="3">
<clone_fragment endline="1297" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" hamdist="0" pcid="4541" startline="1274"><![CDATA[
 
 		public ScopeVariable[] GetScopeVariables ()
 		{
 			lock (SymbolFile) {
 				if (scope_vars != null)
 					return scope_vars;
 
 				if (ScopeVariableTableOffset == 0)
 					return null;
 
 				MyBinaryReader reader = SymbolFile.BinaryReader;
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = ScopeVariableTableOffset;
 
 				int num_scope_vars = reader.ReadLeb128 ();
 				scope_vars = new ScopeVariable [num_scope_vars];
 
 				for (int i = 0; i < num_scope_vars; i++)
 					scope_vars [i] = new ScopeVariable (reader);
 				for (int i = 0; i < num_scope_vars; i++)
 					scope_vars [i] = new ScopeVariable (reader);
 
 				reader.BaseStream.Position = old_pos;
 				return scope_vars;
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1273" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" hamdist="10" pcid="4539" startline="1250"><![CDATA[
 
 		public CodeBlockEntry[] GetCodeBlocks ()
 		{
 			lock (SymbolFile) {
 				if (code_blocks != null)
 					return code_blocks;
 
 				if (CodeBlockTableOffset == 0)
 					return null;
 
 				MyBinaryReader reader = SymbolFile.BinaryReader;
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = CodeBlockTableOffset;
 
 				int num_code_blocks = reader.ReadLeb128 ();
 				code_blocks = new CodeBlockEntry [num_code_blocks];
 
 				for (int i = 0; i < num_code_blocks; i++)
 					code_blocks [i] = new CodeBlockEntry (i, reader);
 				for (int i = 0; i < num_code_blocks; i++)
 					code_blocks [i] = new CodeBlockEntry (i, reader);
 
 				reader.BaseStream.Position = old_pos;
 				return code_blocks;
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1249" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" hamdist="12" pcid="4537" startline="1226"><![CDATA[
 
 		public LocalVariableEntry[] GetLocals ()
 		{
 			lock (SymbolFile) {
 				if (locals != null)
 					return locals;
 
 				if (LocalVariableTableOffset == 0)
 					return null;
 
 				MyBinaryReader reader = SymbolFile.BinaryReader;
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = LocalVariableTableOffset;
 
 				int num_locals = reader.ReadLeb128 ();
 				locals = new LocalVariableEntry [num_locals];
 
 				for (int i = 0; i < num_locals; i++)
 					locals [i] = new LocalVariableEntry (SymbolFile, reader);
 				for (int i = 0; i < num_locals; i++)
 					locals [i] = new LocalVariableEntry (SymbolFile, reader);
 
 				reader.BaseStream.Position = old_pos;
 				return locals;
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="266" nfragments="2">
<clone_fragment endline="883" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" hamdist="0" pcid="2689" startline="858"><![CDATA[
 
 		public int Fatal { get; set; }
 
 		static int NameToCode (string s)
 		{
 			switch (s) {
 			case "black"
 				return 0;
 			case "red"
 				return 1;
 			case "green"
 				return 2;
 			case "yellow"
 				return 3;
 			case "blue"
 				return 4;
 			case "magenta"
 				return 5;
 			case "cyan"
 				return 6;
 			case "grey"
 			case "white"
 				return 7;
 			}
 			return 7;
 		}
]]></clone_fragment>
<clone_fragment endline="540" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="12" pcid="3069" startline="512"><![CDATA[
 
 		static string descape (char c)
 		{
 			switch (c){
 			case '\a'
 				return "\\a"; 
 			case '\b'
 				return "\\b"; 
 			case '\n'
 				return "\\n"; 
 			case '\t'
 				return "\\t"; 
 			case '\v'
 				return "\\v"; 
 			case '\r'
 				return "\\r"; 
 			case '\\'
 				return "\\\\";
 			case '\f'
 				return "\\f"; 
 			case '\0'
 				return "\\0"; 
 			case '"'
 				return "\\\""; 
 			case '\''
 				return "\\\'"; 
 			}
 			return c.ToString ();
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="267" nfragments="11">
<clone_fragment endline="1874" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="0" pcid="3115" startline="1846"><![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type)
 				return new SByteConstant ((sbyte)Value, loc);
 			if (target_type == TypeManager.byte_type)
 				return new ByteConstant ((byte)Value, loc);
 			if (target_type == TypeManager.short_type)
 				return new ShortConstant ((short)Value, loc);
 			if (target_type == TypeManager.ushort_type)
 				return new UShortConstant ((ushort)Value, loc);
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int)Value, loc);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint)Value, loc);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long)Value, loc);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong)Value, loc);
 			if (target_type == TypeManager.char_type)
 				return new CharConstant ((char)Value, loc);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float)Value, loc);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double)Value, loc);
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="607" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="12" pcid="3071" startline="566"><![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}					
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="944" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="1" pcid="3829" startline="896"><![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="713" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="9" pcid="3821" startline="672"><![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type)
 				return new ShortConstant ((short) Value, Location);
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new UShortConstant ((ushort) Value, Location);
 			} if (target_type == TypeManager.int32_type)
 				  return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			} if (target_type == TypeManager.int64_type)
 				  return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="831" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="7" pcid="3825" startline="778"><![CDATA[
 		}		
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="1247" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="5" pcid="3087" startline="1189"><![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value > Int32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="1069" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="4" pcid="3077" startline="1008"><![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < Int16.MinValue || Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < UInt32.MinValue)
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="1378" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="2" pcid="3091" startline="1312"><![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < Int16.MinValue || Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < Int32.MinValue || Value > Int32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < UInt32.MinValue || Value > UInt32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="1749" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="6" pcid="3105" startline="1676"><![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (double) char.MinValue || Value > (double) char.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="1626" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="1" pcid="3101" startline="1553"><![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < byte.MinValue || Value > byte.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < sbyte.MinValue || Value > sbyte.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (float) char.MinValue || Value > (float) char.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="1503" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="11" pcid="3097" startline="1451"><![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context && Value > Byte.MaxValue)
 					throw new OverflowException ();
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context && Value > ((ulong) SByte.MaxValue))
 					throw new OverflowException ();
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context && Value > ((ulong) Int16.MaxValue))
 					throw new OverflowException ();
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value > UInt16.MaxValue)
 					throw new OverflowException ();
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context && Value > UInt32.MaxValue)
 					throw new OverflowException ();
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if  (in_checked_context && Value > UInt32.MaxValue)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context && Value > Int64.MaxValue)
 					throw new OverflowException ();
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context && Value > Char.MaxValue)
 					throw new OverflowException ();
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="268" nfragments="2">
<clone_fragment endline="61" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" hamdist="0" pcid="8699" startline="51"><![CDATA[
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
     Private m_ParameterAttributes As Mono.Cecil.ParameterAttributes = Mono.Cecil.ParameterAttributes.None
     
     Private m_ParameterBuilderCecil As Mono.Cecil.ParameterDefinition
     Private m_ParamArrayAttribute As Mono.Cecil.CustomAttribute
 
     ReadOnly Property CecilBuilder() As Mono.Cecil.ParameterDefinition
         Get
             Return m_ParameterBuilderCecil
         End Get
     End Property
 
     Sub New(ByVal Parent As ParameterList)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         Me.ParameterType = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
]]></clone_fragment>
<clone_fragment endline="72" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" hamdist="9" pcid="8701" startline="62"><![CDATA[
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As TypeName)
         MyBase.New(Parent)
     Private m_ParameterAttributes As Mono.Cecil.ParameterAttributes = Mono.Cecil.ParameterAttributes.None
     
     Private m_ParameterBuilderCecil As Mono.Cecil.ParameterDefinition
     Private m_ParamArrayAttribute As Mono.Cecil.CustomAttribute
 
     ReadOnly Property CecilBuilder() As Mono.Cecil.ParameterDefinition
         Get
             Return m_ParameterBuilderCecil
         End Get
     End Property
 
     Sub New(ByVal Parent As ParameterList)
         MyBase.New(Parent)
         UpdateDefinition()
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         Me.ParameterType = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As TypeName)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         m_TypeName = ParameterType
 
         UpdateDefinition()
 
         Helper.Assert(m_ParameterIdentifier IsNot Nothing)
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="269" nfragments="3">
<clone_fragment endline="387" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" hamdist="0" pcid="507" startline="359"><![CDATA[
 
 		internal void WriteResolutionScope(int token)
 		{
 			switch (token >> 24)
 			{
 				case ModuleTable.Index
 					token = (token & 0xFFFFFF) << 2 | 0;
 					break;
 				case ModuleRefTable.Index
 					token = (token & 0xFFFFFF) << 2 | 1;
 					break;
 				case AssemblyRefTable.Index
 					token = (token & 0xFFFFFF) << 2 | 2;
 					break;
 				case TypeRefTable.Index
 					token = (token & 0xFFFFFF) << 2 | 3;
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			if (bigResolutionScope)
 			{
 				Write(token);
 			}
 			else
 			{
 				Write((short)token);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="757" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="9" pcid="1377" startline="732"><![CDATA[
 
 		internal void Fixup()
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Interface;
 				switch (token >> 24)
 				{
 					case 0
 						break;
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case TypeRefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case TypeSpecTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Interface = token;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Interface;
 				switch (token >> 24)
 				{
 					case 0
 						break;
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case TypeRefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case TypeSpecTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Interface = token;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]></clone_fragment>
<clone_fragment endline="1225" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" hamdist="5" pcid="1417" startline="1197"><![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Parent;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the HasDeclSecurity encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case MethodDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case AssemblyTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Parent = token;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Parent;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the HasDeclSecurity encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case MethodDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case AssemblyTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Parent = token;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="270" nfragments="2">
<clone_fragment endline="116" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" hamdist="0" pcid="8399" startline="88"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then
             result = m_TypeName.ResolveTypeReferences AndAlso result
             If m_Identifier.HasTypeCharacter Then
                 Helper.AddError(Me)
             End If
         ElseIf m_Identifier.HasTypeCharacter Then
             m_TypeName = New TypeName(Me, TypeCharacters.TypeCharacterToType(Compiler, m_Identifier.TypeCharacter))
         End If
 
         If m_ConstantExpression IsNot Nothing Then result = m_ConstantExpression.ResolveTypeReferences AndAlso result
 
         UpdateDefinition()
 
         If result AndAlso m_TypeName IsNot Nothing Then
             Helper.Assert(m_TypeName IsNot Nothing)
             If Helper.CompareType(m_TypeName.ResolvedType, Compiler.TypeCache.System_Decimal) Then
                 m_RequiresSharedInitialization = True
             ElseIf Helper.CompareType(m_TypeName.ResolvedType, Compiler.TypeCache.System_DateTime) Then
                 m_RequiresSharedInitialization = True
             End If
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="310" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" hamdist="12" pcid="8717" startline="272"><![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_ConstantExpression, m_TypeName, m_ParameterIdentifier) AndAlso result
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         'If ParameterType Is Nothing Then
         If m_TypeName IsNot Nothing Then
             ParameterType = m_TypeName.ResolvedType
             If m_ParameterIdentifier.ArrayNameModifier IsNot Nothing Then
                 If m_TypeName.IsArrayTypeName Then
                     Helper.AddError(Me)
                 Else
                     ParameterType = m_ParameterIdentifier.ArrayNameModifier.CreateArrayType(ParameterType)
                 End If
             End If
         ElseIf m_ParameterIdentifier.Identifier.HasTypeCharacter Then
             ParameterType = TypeCharacters.TypeCharacterToType(Compiler, m_ParameterIdentifier.Identifier.TypeCharacter)
         ElseIf ParameterType Is Nothing OrElse Helper.CompareType(ParameterType, Compiler.TypeCache.System_Void) Then
             If Me.Location.File(Compiler).IsOptionStrictOn Then
                 Helper.AddError(Me, "Parameter type must be specified.")
             Else
                 Helper.AddWarning("Parameter type should be specified.")
             End If
             ParameterType = Compiler.TypeCache.System_Object
         End If
         'End If
         Helper.Assert(ParameterType IsNot Nothing)
         If m_Modifiers.Is(ModifierMasks.ByRef) Then
             ParameterType = Compiler.TypeManager.MakeByRefType(Me, ParameterType)
         End If
 
         UpdateDefinition()
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="271" nfragments="2">
<clone_fragment endline="369" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" hamdist="0" pcid="8443" startline="341"><![CDATA[
 
     Private Sub CreateDefaultCtorCallCecil()
         Dim type As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
         Dim classtype As ClassDeclaration = TryCast(type, ClassDeclaration)
         Dim defaultctor As Mono.Cecil.MethodReference
         If classtype IsNot Nothing Then
             defaultctor = classtype.GetBaseDefaultConstructorCecil()
             If defaultctor IsNot Nothing AndAlso Helper.IsPrivate(defaultctor) = False Then
                 If Helper.IsPrivate(defaultctor) OrElse (Helper.IsFamilyOrAssembly(defaultctor) AndAlso defaultctor.DeclaringType.Module.Assembly IsNot Me.Compiler.AssemblyBuilderCecil) Then
                     Helper.AddError(Compiler, Location, "Base class does not have an accessible default constructor")
                 Else
                     m_DefaultBaseConstructorCecil = defaultctor
                     m_DefaultBaseConstructorCecil = Helper.GetMethodOrMethodReference(Compiler, m_DefaultBaseConstructorCecil)
 
 #If DEBUG Then
                     Try
                         For Each param As Mono.Cecil.ParameterDefinition In m_DefaultBaseConstructor.Parameters
                             Helper.Assert(param.IsOptional)
                         Next
                     Catch ex As Exception
                         Helper.Assert(False)
                     End Try
 #End If
                 End If
             Else
                 Helper.AddError(Compiler, Location, "Base class does not have a default constructor")
             End If
         End If
     End Sub
]]></clone_fragment>
<clone_fragment endline="340" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" hamdist="6" pcid="8441" startline="313"><![CDATA[
 
     Private Sub CreateDefaultCtorCall()
         Dim type As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
         Dim classtype As ClassDeclaration = TryCast(type, ClassDeclaration)
         Dim defaultctor As Mono.Cecil.MethodReference
         If classtype IsNot Nothing Then
             defaultctor = classtype.GetBaseDefaultConstructor()
             If defaultctor IsNot Nothing AndAlso Helper.IsPrivate(defaultctor) = False Then
                 If Helper.IsPrivate(defaultctor) OrElse (Helper.IsFriend(defaultctor) AndAlso Not Compiler.Assembly.IsDefinedHere(defaultctor.DeclaringType)) Then
                     Helper.AddError(Me, "Base class does not have an accessible default constructor")
                 Else
                     m_DefaultBaseConstructor = defaultctor
 
 #If DEBUG Then
                     Try
                         For Each param As Mono.Cecil.ParameterDefinition In m_DefaultBaseConstructor.Parameters
                             Helper.Assert(param.IsOptional)
                         Next
                     Catch ex As Exception
                         Helper.Assert(False)
                     End Try
 #End If
                 End If
             Else
                 Helper.AddError(Me, "Base class does not have a default constructor")
             End If
         End If
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="272" nfragments="3">
<clone_fragment endline="860" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="0" pcid="585" startline="844"><![CDATA[
 
 		public PropertyInfo GetProperty(string name, Type[] types)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]></clone_fragment>
<clone_fragment endline="903" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="7" pcid="589" startline="887"><![CDATA[
 
 		public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType) && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType) && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]></clone_fragment>
<clone_fragment endline="843" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="9" pcid="583" startline="827"><![CDATA[
 
 		public PropertyInfo GetProperty(string name, Type returnType)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="273" nfragments="2">
<clone_fragment endline="445" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" hamdist="0" pcid="8245" startline="418"><![CDATA[
 
     ''' <summary>
     ''' Creates a closed method of an open generic method.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="OpenMethod"></param>
     ''' <param name="TypeParameters"></param>
     ''' <param name="TypeArguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function MakeGenericMethod(ByVal Parent As ParsedObject, ByVal OpenMethod As Mono.Cecil.MethodReference, ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim genM As Mono.Cecil.GenericInstanceMethod
 
         result = CecilHelper.GetCorrectMember(OpenMethod, TypeArguments)
 
         If OpenMethod.GenericParameters.Count = 0 Then Return result
 
         Helper.Assert(OpenMethod.GenericParameters.Count = TypeArguments.Count)
 
         genM = New Mono.Cecil.GenericInstanceMethod(result)
         genM.OriginalMethod = CecilHelper.FindDefinition(OpenMethod)
         For i As Integer = 0 To OpenMethod.GenericParameters.Count - 1
             genM.GenericArguments.Add(Helper.GetTypeOrTypeReference(Parent.Compiler, TypeArguments(i)))
         Next
 
         Return genM
     End Function
]]></clone_fragment>
<clone_fragment endline="2020" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="11" pcid="7665" startline="1991"><![CDATA[
 
     ''' <summary>
     ''' Finds the member with the exact same signature.
     ''' </summary>
     ''' <param name="grp"></param>
     ''' <param name="params"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function ResolveGroupExact(ByVal Context As BaseObject, ByVal grp As Generic.List(Of Mono.Cecil.MemberReference), ByVal params() As Mono.Cecil.TypeReference) As Mono.Cecil.MemberReference
         Dim Compiler As Compiler = Context.Compiler
 
         For i As Integer = 0 To grp.Count - 1
             Dim member As Mono.Cecil.MemberReference = grp(i)
             Dim paramtypes As Mono.Cecil.TypeReference() = Helper.GetParameterTypes(Context, member)
             If Helper.CompareTypes(paramtypes, params) Then Return member
 
             If paramtypes.Length <> params.Length Then Continue For
 
             Dim found As Boolean = True
             For j As Integer = 0 To paramtypes.Length - 1
                 If Helper.IsSubclassOf(paramtypes(j), params(j)) = False Then
                     found = False
                     Exit For
                 End If
             Next
             If found Then Return member
         Next
 
         Return Nothing
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="274" nfragments="2">
<clone_fragment endline="244" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" hamdist="0" pcid="3245" startline="229"><![CDATA[
 
 		private void WriteData(ByteBuffer bb)
 		{
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					bb.Write(entry.Data);
 					bb.Align(4);
 				}
 				else
 				{
 					entry.WriteData(bb);
 				}
 			}
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					bb.Write(entry.Data);
 					bb.Align(4);
 				}
 				else
 				{
 					entry.WriteData(bb);
 				}
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="228" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" hamdist="10" pcid="3243" startline="209"><![CDATA[
 
 		private void WriteResourceDataEntries(ByteBuffer bb, List<int> linkOffsets, ref int offset)
 		{
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					linkOffsets.Add(bb.Position);
 					bb.Write(offset);
 					bb.Write(entry.Data.Length);
 					bb.Write(0);	// code page
 					bb.Write(0);	// reserved
 					offset += (entry.Data.Length + 3) & ~3;
 				}
 				else
 				{
 					entry.WriteResourceDataEntries(bb, linkOffsets, ref offset);
 				}
 			}
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					linkOffsets.Add(bb.Position);
 					bb.Write(offset);
 					bb.Write(entry.Data.Length);
 					bb.Write(0);	// code page
 					bb.Write(0);	// reserved
 					offset += (entry.Data.Length + 3) & ~3;
 				}
 				else
 				{
 					entry.WriteResourceDataEntries(bb, linkOffsets, ref offset);
 				}
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="275" nfragments="2">
<clone_fragment endline="686" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="0" pcid="569" startline="670"><![CDATA[
 
 		public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
 		{
 			MethodInfo found = null;
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name && method.MethodSignature.MatchParameterTypes(types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name && method.MethodSignature.MatchParameterTypes(types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			return found;
 		}
]]></clone_fragment>
<clone_fragment endline="659" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="9" pcid="567" startline="643"><![CDATA[
 
 		public MethodInfo GetMethod(string name, BindingFlags bindingAttr)
 		{
 			MethodInfo found = null;
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name)
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name)
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			return found;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="276" nfragments="2">
<clone_fragment endline="206" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstantDeclaration.vb" hamdist="0" pcid="8405" startline="179"><![CDATA[
 
     Function ResolveConstantValue(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ConstantExpression IsNot Nothing)
         If m_ConstantExpression.IsResolved = False Then
             result = m_ConstantExpression.ResolveExpression(Info) AndAlso result
             If m_ConstantExpression.IsConstant Then
                 m_ConstantValue = m_ConstantExpression.ConstantValue
                 Helper.Assert(m_ConstantValue IsNot Nothing)
 
                 If m_TypeName Is Nothing Then
                     m_TypeName = New TypeName(Me, m_ConstantExpression.ExpressionType)
                 Else
                     result = TypeConverter.ConvertTo(m_ConstantExpression, m_ConstantValue, m_TypeName.ResolvedType, m_ConstantValue) AndAlso result
                 End If
                 UpdateDefinition()
                 'If m_ConstantValue IsNot Nothing Then Compiler.Report.WriteLine("Converted to
             Else
                 result = Compiler.Report.ShowMessage(Messages.VBNC30059, m_ConstantExpression.Location)
             End If
             m_Resolved = True
         End If
 
         Helper.Assert(m_Resolved)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="271" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\Parameter.vb" hamdist="12" pcid="8715" startline="234"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveCode(Info) AndAlso result
 
         If m_ConstantExpression IsNot Nothing Then
             result = m_ConstantExpression.ResolveExpression(Info) AndAlso result
         End If
 
         If Me.Modifiers.Is(ModifierMasks.Optional) Then
             m_ParameterAttributes = Mono.Cecil.ParameterAttributes.Optional
             If m_ConstantExpression Is Nothing Then
                 Helper.AddError(Me, "Optional parameters must have a constant expression.")
                 result = False
             ElseIf m_ConstantExpression.IsConstant = False Then
                 Helper.AddError(Me, "Optional expressions must be constant.")
                 result = False
             Else
                 Dim cv As Object = m_ConstantExpression.ConstantValue
                 result = TypeConverter.ConvertTo(Me, cv, ParameterType, cv) AndAlso result
                 If cv Is DBNull.Value Then
                     cv = Nothing
                 End If
                 ConstantValue = cv
             End If
         Else
             If m_ConstantExpression IsNot Nothing Then
                 Helper.AddError(Me, "Non-optional parameters cannot have constant expressions.")
                 result = False
             End If
         End If
 
         UpdateDefinition()
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="277" nfragments="3">
<clone_fragment endline="160" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" hamdist="0" pcid="6101" startline="140"><![CDATA[
 
 		public override Module[] GetModules(bool getResourceModules)
 		{
 			if (externalModules.Length == 0)
 			{
 				return new Module[] { manifestModule };
 			}
 			else
 			{
 				List<Module> list = new List<Module>();
 				list.Add(manifestModule);
 				for (int i = 0; i < manifestModule.File.records.Length; i++)
 				{
 					if (getResourceModules || (manifestModule.File.records[i].Flags & ContainsNoMetaData) == 0)
 					{
 						list.Add(GetModule(i));
 					}
 				}
 				for (int i = 0; i < manifestModule.File.records.Length; i++)
 				{
 					if (getResourceModules || (manifestModule.File.records[i].Flags & ContainsNoMetaData) == 0)
 					{
 						list.Add(GetModule(i));
 					}
 				}
 				return list.ToArray();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="433" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" hamdist="10" pcid="4569" startline="409"><![CDATA[
 
 		internal List<CustomAttributeData> GetCustomAttributes(int metadataToken, Type attributeType)
 		{
 			List<CustomAttributeData> list = new List<CustomAttributeData>();
 			// TODO use binary search?
 			for (int i = 0; i < CustomAttribute.records.Length; i++)
 			{
 				if (CustomAttribute.records[i].Parent == metadataToken)
 				{
 					if (attributeType == null)
 					{
 						list.Add(new CustomAttributeData(this, i));
 					}
 					else
 					{
 						ConstructorInfo constructor = (ConstructorInfo)ResolveMethod(CustomAttribute.records[i].Type);
 						if (attributeType.IsAssignableFrom(constructor.DeclaringType))
 						{
 							list.Add(new CustomAttributeData(this.Assembly, constructor, GetBlob(CustomAttribute.records[i].Value)));
 						}
 					}
 				}
 			}
 			for (int i = 0; i < CustomAttribute.records.Length; i++)
 			{
 				if (CustomAttribute.records[i].Parent == metadataToken)
 				{
 					if (attributeType == null)
 					{
 						list.Add(new CustomAttributeData(this, i));
 					}
 					else
 					{
 						ConstructorInfo constructor = (ConstructorInfo)ResolveMethod(CustomAttribute.records[i].Type);
 						if (attributeType.IsAssignableFrom(constructor.DeclaringType))
 						{
 							list.Add(new CustomAttributeData(this.Assembly, constructor, GetBlob(CustomAttribute.records[i].Value)));
 						}
 					}
 				}
 			}
 			return list;
 		}
]]></clone_fragment>
<clone_fragment endline="334" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" hamdist="12" pcid="181" startline="299"><![CDATA[
 
 		void AddMember (string name, MemberSpec member)
 		{
 			if (member.Kind == MemberKind.Operator) {
 				var dt = member.DeclaringType;
 				if (dt == TypeManager.string_type || dt == TypeManager.delegate_type || dt == TypeManager.multicast_delegate_type) {
 					// Some core types have user operators but they cannot be used as normal
 					// user operators as they are predefined and therefore having different
 					// rules (e.g. binary operators) by not setting the flag we hide them for
 					// user conversions
 					// TODO
 				} else if (name == Operator.GetMetadataName (Operator.OpType.Implicit) || name == Operator.GetMetadataName (Operator.OpType.Explicit)) {
 					state |= StateFlags.HasConversionOperator;
 				} else {
 					state |= StateFlags.HasUserOperator;
 				}
 			}
 
 			IList<MemberSpec> list;
 			if (!member_hash.TryGetValue (name, out list)) {
 				member_hash.Add (name, new MemberSpec[] { member });
 				return;
 			}
 
 			if (member.DeclaringType.IsInterface) {
 				if (AddInterfaceMember (member, ref list))
 					member_hash[name] = list;
 			} else {
 				if (list is MemberSpec[]) {
 					list = new List<MemberSpec> () { list[0] };
 					member_hash[name] = list;
 				}
 
 				list.Add (member);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="278" nfragments="2">
<clone_fragment endline="266" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" hamdist="0" pcid="3993" startline="236"><![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = this.ModuleBuilder.universe;
 			Type type = customBuilder.Constructor.DeclaringType;
 			if (type == u.System_Runtime_InteropServices_DllImportAttribute)
 			{
 				attributes |= MethodAttributes.PinvokeImpl;
 				SetDllImportPseudoCustomAttribute(customBuilder.DecodeBlob(this.Module.Assembly));
 			}
 			else if (type == u.System_Runtime_CompilerServices_MethodImplAttribute)
 			{
 				SetMethodImplAttribute(customBuilder.DecodeBlob(this.Module.Assembly));
 			}
 			else if (type == u.System_Runtime_InteropServices_PreserveSigAttribute)
 			{
 				implFlags |= MethodImplAttributes.PreserveSig;
 			}
 			else if (type == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= MethodAttributes.SpecialName;
 			}
 			else
 			{
 				if (type == u.System_Security_SuppressUnmanagedCodeSecurityAttribute)
 				{
 					attributes |= MethodAttributes.HasSecurity;
 				}
 				this.ModuleBuilder.SetCustomAttribute(pseudoToken, customBuilder);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="590" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" hamdist="11" pcid="673" startline="561"><![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = this.ModuleBuilder.universe;
 			Type type = customBuilder.Constructor.DeclaringType;
 			if (type == u.System_Runtime_InteropServices_StructLayoutAttribute)
 			{
 				SetStructLayoutPseudoCustomAttribute(customBuilder.DecodeBlob(this.Assembly));
 			}
 			else if (type == u.System_SerializableAttribute)
 			{
 				attribs |= TypeAttributes.Serializable;
 			}
 			else if (type == u.System_Runtime_InteropServices_ComImportAttribute)
 			{
 				attribs |= TypeAttributes.Import;
 			}
 			else if (type == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attribs |= TypeAttributes.SpecialName;
 			}
 			else
 			{
 				if (type == u.System_Security_SuppressUnmanagedCodeSecurityAttribute)
 				{
 					attribs |= TypeAttributes.HasSecurity;
 				}
 				this.ModuleBuilder.SetCustomAttribute(token, customBuilder);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="279" nfragments="3">
<clone_fragment endline="328" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="0" pcid="3297" startline="298"><![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			Label loop = ec.DefineLabel ();
 			Label old_begin = ec.LoopBegin;
 			Label old_end = ec.LoopEnd;
 			
 			ec.LoopBegin = ec.DefineLabel ();
 			ec.LoopEnd = ec.DefineLabel ();
 				
 			ec.MarkLabel (loop);
 			EmbeddedStatement.Emit (ec);
 			ec.MarkLabel (ec.LoopBegin);
 
 			//
 			// Dead code elimination
 			//
 			if (expr is Constant){
 				bool res = !((Constant) expr).IsDefaultValue;
 
 				expr.EmitSideEffect (ec);
 				if (res)
 					ec.Emit (OpCodes.Br, loop); 
 			} else
 				expr.EmitBranchable (ec, loop, true);
 			
 			ec.MarkLabel (ec.LoopEnd);
 
 			ec.LoopBegin = old_begin;
 			ec.LoopEnd = old_end;
 		}
]]></clone_fragment>
<clone_fragment endline="581" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="7" pcid="3313" startline="531"><![CDATA[
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (InitStatement != null)
 				InitStatement.Emit (ec);
 
 			if (empty) {
 				Test.EmitSideEffect (ec);
 				return;
 			}
 
 			Label old_begin = ec.LoopBegin;
 			Label old_end = ec.LoopEnd;
 			Label loop = ec.DefineLabel ();
 			Label test = ec.DefineLabel ();
 
 			ec.LoopBegin = ec.DefineLabel ();
 			ec.LoopEnd = ec.DefineLabel ();
 
 			ec.Emit (OpCodes.Br, test);
 			ec.MarkLabel (loop);
 			Statement.Emit (ec);
 
 			ec.MarkLabel (ec.LoopBegin);
 			Increment.Emit (ec);
 
 			ec.MarkLabel (test);
 			//
 			// If test is null, there is no test, and we are just
 			// an infinite loop
 			//
 			if (Test != null){
 				//
 				// The Resolve code already catches the case for
 				// Test == Constant (false) so we know that
 				// this is true
 				//
 				if (Test is Constant) {
 					Test.EmitSideEffect (ec);
 					ec.Emit (OpCodes.Br, loop);
 				} else {
 					Test.EmitBranchable (ec, loop, true);
 				}
 				
 			} else
 				ec.Emit (OpCodes.Br, loop);
 			ec.MarkLabel (ec.LoopEnd);
 
 			ec.LoopBegin = old_begin;
 			ec.LoopEnd = old_end;
 		}
]]></clone_fragment>
<clone_fragment endline="437" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="5" pcid="3305" startline="390"><![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (empty) {
 				expr.EmitSideEffect (ec);
 				return;
 			}
 
 			Label old_begin = ec.LoopBegin;
 			Label old_end = ec.LoopEnd;
 			
 			ec.LoopBegin = ec.DefineLabel ();
 			ec.LoopEnd = ec.DefineLabel ();
 
 			//
 			// Inform whether we are infinite or not
 			//
 			if (expr is Constant){
 				// expr is 'true', since the 'empty' case above handles the 'false' case
 				ec.MarkLabel (ec.LoopBegin);
 				expr.EmitSideEffect (ec);
 				Statement.Emit (ec);
 				ec.Emit (OpCodes.Br, ec.LoopBegin);
 					
 				//
 				// Inform that we are infinite (ie, `we return'), only
 				// if we do not `break' inside the code.
 				//
 				ec.MarkLabel (ec.LoopEnd);
 			} else {
 				Label while_loop = ec.DefineLabel ();
 
 				ec.Emit (OpCodes.Br, ec.LoopBegin);
 				ec.MarkLabel (while_loop);
 
 				Statement.Emit (ec);
 			
 				ec.MarkLabel (ec.LoopBegin);
 				ec.Mark (loc);
 
 				expr.EmitBranchable (ec, while_loop, true);
 				
 				ec.MarkLabel (ec.LoopEnd);
 			}	
 
 			ec.LoopBegin = old_begin;
 			ec.LoopEnd = old_end;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="280" nfragments="6">
<clone_fragment endline="1868" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="0" pcid="6475" startline="1838"><![CDATA[
 
     Shared Sub EmitStoreIndirect(ByVal Info As EmitInfo, ByVal ByRefType As Mono.Cecil.TypeReference)
         ByRefType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ByRefType)
         Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ByRefType)
         Select Case Helper.GetTypeCode(Info.Compiler, elementtype)
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Stind_I1)
             Case TypeCode.Int16, TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Stind_I2)
             Case TypeCode.Int32, TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Stind_I4)
             Case TypeCode.Int64, TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Stind_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Stind_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Stind_R8)
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Stind_Ref)
             Case TypeCode.DateTime, TypeCode.Decimal
                 Info.ILGen.Emit(OpCodes.Stobj, elementtype)
             Case TypeCode.Object
                 If CecilHelper.IsValueType(elementtype) Then
                     Info.ILGen.Emit(OpCodes.Stobj, elementtype)
                 Else
                     Info.ILGen.Emit(OpCodes.Stind_Ref)
                 End If
             Case Else
                 Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End Select
     End Sub
]]></clone_fragment>
<clone_fragment endline="1007" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="4" pcid="6407" startline="975"><![CDATA[
 
     Shared Sub LoadElement(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Select Case Helper.GetTypeCode(Info.Compiler, ElementType)
             Case TypeCode.Byte
                 Info.ILGen.Emit(OpCodes.Ldelem_U1)
             Case TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Ldelem_U2)
             Case TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Ldelem_U4)
             Case TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Ldelem_I8)
             Case TypeCode.SByte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Ldelem_I1)
             Case TypeCode.Int16
                 Info.ILGen.Emit(OpCodes.Ldelem_I2)
             Case TypeCode.Int32
                 Info.ILGen.Emit(OpCodes.Ldelem_I4)
             Case TypeCode.Int64
                 Info.ILGen.Emit(OpCodes.Ldelem_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Ldelem_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldelem_R8)
             Case TypeCode.DateTime, TypeCode.Decimal
                 Info.ILGen.Emit(OpCodes.Ldelema, ElementType)
                 Info.ILGen.Emit(OpCodes.Ldobj, ElementType)
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Ldelem_Ref)
             Case Else
                 Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End Select
     End Sub
]]></clone_fragment>
<clone_fragment endline="1048" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="5" pcid="6409" startline="1008"><![CDATA[
 
 
     ''' <summary>
     ''' Type = the type of the element. (not of the array.)
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitStoreElement(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference, ByVal ArrayType As Mono.Cecil.TypeReference)
         ArrayType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ArrayType)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Select Case Helper.GetTypeCode(Info.Compiler, ElementType)
             Case TypeCode.Int32, TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Stelem_I4)
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Stelem_I1)
             Case TypeCode.Int16, TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Stelem_I2)
             Case TypeCode.Int64, TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Stelem_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Stelem_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Stelem_R8)
             Case TypeCode.DateTime, TypeCode.Decimal
                 EmitStoreObject(Info, ElementType)
                 Return
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Stelem_Ref)
             Case TypeCode.Object
                 If CecilHelper.IsValueType(ElementType) Then
                     Info.ILGen.Emit(OpCodes.Stobj, ElementType)
                 ElseIf CecilHelper.IsGenericParameter(ElementType) Then
                     Info.ILGen.Emit(OpCodes.Stelem_Any, ElementType)
                 Else
                     Info.ILGen.Emit(OpCodes.Stelem_Ref)
                 End If
             Case Else
                 Helper.Stop()
         End Select
     End Sub
]]></clone_fragment>
<clone_fragment endline="1732" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="7" pcid="6463" startline="1682"><![CDATA[
 
     ''' <summary>
     ''' Loads the value of the specified address.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ByRefType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadIndirect(ByVal Info As EmitInfo, ByVal ByRefType As Mono.Cecil.TypeReference)
         ByRefType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ByRefType)
         Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ByRefType)
         Select Case Helper.GetTypeCode(Info.Compiler, elementtype)
             Case TypeCode.Byte
                 Info.ILGen.Emit(OpCodes.Ldind_U1)
             Case TypeCode.SByte
                 Info.ILGen.Emit(OpCodes.Ldind_I1)
             Case TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Ldind_U2)
             Case TypeCode.Int16
                 Info.ILGen.Emit(OpCodes.Ldind_I2)
             Case TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Ldind_U4)
             Case TypeCode.Int32
                 Info.ILGen.Emit(OpCodes.Ldind_I4)
             Case TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Ldind_I8)
             Case TypeCode.Int64
                 Info.ILGen.Emit(OpCodes.Ldind_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Ldind_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldind_R8)
             Case TypeCode.String, TypeCode.DBNull
                 Info.ILGen.Emit(OpCodes.Ldind_Ref)
             Case TypeCode.Object
                 If elementtype.IsValueType Then
                     Info.ILGen.Emit(OpCodes.Ldobj, elementtype)
                 Else
                     Info.ILGen.Emit(OpCodes.Ldind_Ref)
                 End If
             Case TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Ldind_I1)
             Case TypeCode.Decimal
                 Info.ILGen.Emit(OpCodes.Ldobj, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal))
             Case Else
                 If elementtype.IsValueType Then
                     Info.ILGen.Emit(OpCodes.Ldobj, elementtype)
                 Else
                     Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
                 End If
         End Select
     End Sub
]]></clone_fragment>
<clone_fragment endline="1493" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="11" pcid="6439" startline="1439"><![CDATA[
 
     ''' <summary>
     ''' Loads a nothing constant expression according to the desired type.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadNull(ByVal Info As EmitInfo)
         Helper.Assert(Info.DesiredType IsNot Nothing)
         If CecilHelper.IsGenericParameter(Info.DesiredType) Then ' TypeOf Info.DesiredType Is GenericTypeParameterBuilder OrElse TypeOf Info.DesiredType Is TypeParameterDescriptor Then
             Dim local As Mono.Cecil.Cil.VariableDefinition
             local = DeclareLocal(Info, Info.DesiredType)
             EmitLoadVariableLocation(Info, local)
             EmitInitObj(Info, Info.DesiredType)
             EmitLoadVariable(Info, local)
             'Info.Stack.Push(Info.DesiredType)
             FreeLocal(local)
         ElseIf CecilHelper.IsByRef(Info.DesiredType) Then
             Dim local As Mono.Cecil.Cil.VariableDefinition = DeclareLocal(Info, CecilHelper.GetElementType(Info.DesiredType))
             Info.ILGen.Emit(OpCodes.Ldnull)
             EmitStoreVariable(Info, local)
             EmitLoadVariableLocation(Info, local)
             FreeLocal(local)
         ElseIf CecilHelper.IsClass(Info.DesiredType) OrElse CecilHelper.IsInterface(Info.DesiredType) Then
             Info.ILGen.Emit(OpCodes.Ldnull)
         ElseIf CecilHelper.IsValueType(Info.DesiredType) Then
             Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
             Select Case DesiredTypeCode
                 Case TypeCode.Boolean
                     EmitLoadI4Value(Info, CInt(False), Info.DesiredType)
                 Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32
                     EmitLoadI4Value(Info, 0, Info.DesiredType)
                 Case TypeCode.Int64, TypeCode.UInt64
                     EmitLoadI8Value(Info, 0, Info.DesiredType)
                 Case TypeCode.Char
                     EmitLoadI4Value(Info, 0, Info.DesiredType)
                 Case TypeCode.Single
                     EmitLoadR4Value(Info, CSng(0), Info.DesiredType)
                 Case TypeCode.Double
                     EmitLoadR8Value(Info, CDbl(0), Info.DesiredType)
                 Case TypeCode.Object, TypeCode.DateTime, TypeCode.Decimal
                     Dim local As Mono.Cecil.Cil.VariableDefinition
                     local = DeclareLocal(Info, Info.DesiredType)
                     EmitLoadVariable(Info, local)
                     FreeLocal(local)
                 Case TypeCode.String
                     Info.ILGen.Emit(OpCodes.Ldnull)
                 Case Else
                     Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
             End Select
         ElseIf Helper.CompareType(Info.DesiredType, Info.Compiler.TypeCache.System_Enum) Then
             Info.ILGen.Emit(OpCodes.Ldnull)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]></clone_fragment>
<clone_fragment endline="974" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="10" pcid="6405" startline="942"><![CDATA[
 
     Shared Sub EmitLoadElement(ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference)
         ArrayType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ArrayType)
         Dim ElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Select Case Helper.GetTypeCode(Info.Compiler, ElementType)
             Case TypeCode.Byte
                 Info.ILGen.Emit(OpCodes.Ldelem_U1)
             Case TypeCode.SByte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Ldelem_I1)
             Case TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Ldelem_U2)
             Case TypeCode.Int16
                 Info.ILGen.Emit(OpCodes.Ldelem_I2)
             Case TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Ldelem_U4)
             Case TypeCode.Int32
                 Info.ILGen.Emit(OpCodes.Ldelem_I4)
             Case TypeCode.UInt64, TypeCode.Int64
                 Info.ILGen.Emit(OpCodes.Ldelem_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Ldelem_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldelem_R8)
             Case TypeCode.Object, TypeCode.String, TypeCode.DateTime, TypeCode.Decimal
                 If CecilHelper.IsValueType(ElementType) Then
                     Throw New InternalException("")
                 Else
                     Info.ILGen.Emit(OpCodes.Ldelem_Ref)
                 End If
             Case Else
                 Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End Select
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="281" nfragments="3">
<clone_fragment endline="387" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" hamdist="0" pcid="7131" startline="357"><![CDATA[
 
     Public Shared Function EmitLateSet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateSet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
 
         '2 - Type ??? - haven't found an example where this isn't nothing yet
         Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateSet_Object_Type_String_Array_Array_Array)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="337" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" hamdist="1" pcid="7127" startline="291"><![CDATA[
 
     Public Shared Function EmitLateGet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim copyBacks As Mono.Cecil.Cil.VariableDefinition = Nothing, arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
         Dim copyBackHints As Boolean() = Nothing
 
         'We need to emit a call to LateGet
 
         If LateBoundAccess.InstanceExpression Is Nothing Then
             '1 - the instance expression (none in this case)
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
 
             '2 - Type 
             Emitter.EmitLoadToken(Info, LateBoundAccess.LateBoundType)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
         Else
             '1 - the instance expression
             result = LateBoundAccess.InstanceExpression.GenerateCode(Info) AndAlso result
 
             '2 - Type  - we have the instance, so no need to pass the type here.
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
         End If
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         '7 - CopyBack
         EmitCopyBacks(Info, LateBoundAccess, copyBackHints, copyBacks)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateGet_Object_Type_String_Array_Array_Array_Array)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
 
         EmitStoreBacks(Info, LateBoundAccess, copyBackHints, copyBacks, arguments)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="455" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" hamdist="3" pcid="7135" startline="406"><![CDATA[
 
     Public Shared Function EmitLateCall(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim copyBacks As Mono.Cecil.Cil.VariableDefinition = Nothing, arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
         Dim copyBackHints As Boolean() = Nothing
 
         'We need to emit a call to LateCall
 
         '1 - the instance expression
         If LateBoundAccess.InstanceExpression IsNot Nothing Then
             result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Object))
         End If
 
         '2 - Type
         If LateBoundAccess.LateBoundType Is Nothing Then
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
         Else
             Emitter.EmitLoadToken(Info, LateBoundAccess.LateBoundType)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
         End If
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         '7 - CopyBack
         EmitCopyBacks(Info, LateBoundAccess, copyBackHints, copyBacks)
 
         '8 - Ignore return
         Emitter.EmitLoadI4Value(Info, 1)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateCall_Object_Type_String_Array_Array_Array_Array_Boolean)
 
         Emitter.EmitPop(Info, Info.Compiler.TypeCache.System_Object)
 
         EmitStoreBacks(Info, LateBoundAccess, copyBackHints, copyBacks, arguments)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="282" nfragments="2">
<clone_fragment endline="507" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="0" pcid="1243" startline="477"><![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			if (a.Type == pa.DllImport) {
 				const Modifiers extern_static = Modifiers.EXTERN | Modifiers.STATIC;
 				if ((ModFlags & extern_static) != extern_static) {
 					Report.Error (601, a.Location, "The DllImport attribute must be specified on a method marked `static' and `extern'");
 				}
 				is_external_implementation = true;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (MethodBuilder != null)
 				MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]></clone_fragment>
<clone_fragment endline="2164" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="12" pcid="1949" startline="2129"><![CDATA[
 		}
 
 		public abstract ParametersCompiled ParameterInfo { get ; }
 		public abstract TypeSpec ReturnType { get; }
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant || a.Type == pa.Obsolete || a.Type == pa.Conditional) {
 				Report.Error (1667, a.Location,
 					"Attribute `{0}' is not valid on property or event accessors. It is valid on `{1}' declarations only",
 					TypeManager.CSharpName (a.Type), a.GetValidTargets ());
 				return;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				method_data.MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			ApplyToExtraTarget (a, ctor, cdata, pa);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="283" nfragments="2">
<clone_fragment endline="1129" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" hamdist="0" pcid="5855" startline="1112"><![CDATA[
 
 		public void ResolveDefaultValues (MemberCore m)
 		{
 			ResolveContext rc = null;
 			for (int i = 0; i < parameters.Length; ++i) {
 				Parameter p = (Parameter) parameters [i];
 
 				//
 				// Try not to enter default values resolution if there are is not any default value possible
 				//
 				if (p.HasDefaultValue || p.OptAttributes != null) {
 					if (rc == null)
 						rc = new ResolveContext (m);
 
 					p.ResolveDefaultValue (rc);
 				}
 			}
 			for (int i = 0; i < parameters.Length; ++i) {
 				Parameter p = (Parameter) parameters [i];
 
 				//
 				// Try not to enter default values resolution if there are is not any default value possible
 				//
 				if (p.HasDefaultValue || p.OptAttributes != null) {
 					if (rc == null)
 						rc = new ResolveContext (m);
 
 					p.ResolveDefaultValue (rc);
 				}
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="662" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="13" pcid="3681" startline="614"><![CDATA[
 
 		Expression ResolveAddressOf (ResolveContext ec)
 		{
 			if (!ec.IsUnsafe)
 				UnsafeError (ec, loc);
 
 			Expr = Expr.DoResolveLValue (ec, EmptyExpression.UnaryAddress);
 			if (Expr == null || Expr.eclass != ExprClass.Variable) {
 				ec.Report.Error (211, loc, "Cannot take the address of the given expression");
 				return null;
 			}
 
 			if (!TypeManager.VerifyUnmanaged (ec.Compiler, Expr.Type, loc)) {
 				return null;
 			}
 
 			IVariableReference vr = Expr as IVariableReference;
 			bool is_fixed;
 			if (vr != null) {
 				VariableInfo vi = vr.VariableInfo;
 				if (vi != null) {
 					if (vi.LocalInfo != null)
 						vi.LocalInfo.SetIsUsed ();
 
 					//
 					// A variable is considered definitely assigned if you take its address.
 					//
 					vi.SetAssigned (ec);
 				}
 
 				is_fixed = vr.IsFixed;
 				vr.SetHasAddressTaken ();
 
 				if (vr.IsHoisted) {
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, vr, loc);
 				}
 			} else {
 				IFixedExpression fe = Expr as IFixedExpression;
 				is_fixed = fe != null && fe.IsFixed;
 			}
 
 			if (!is_fixed && !ec.HasSet (ResolveContext.Options.FixedInitializerScope)) {
 				ec.Report.Error (212, loc, "You can only take the address of unfixed expression inside of a fixed statement initializer");
 			}
 
 			type = PointerContainer.MakeType (Expr.Type);
 			eclass = ExprClass.Value;
 			return this;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="284" nfragments="3">
<clone_fragment endline="72" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" hamdist="0" pcid="9323" startline="42"><![CDATA[
 
     Private Function ResolveIndexedStatement(ByVal Info As ResolveInfo, ByVal InvocationExpression As InvocationOrIndexExpression) As Boolean
         Dim result As Boolean = True
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
 
         For i As Integer = 0 To InvocationExpression.ArgumentList.Count - 1
             Dim arg As Argument = InvocationExpression.ArgumentList(i)
             Dim exp As Expression = arg.Expression
             Dim newExp As VariableExpression
             Dim varDecl As LocalVariableDeclaration
             Dim stmt As AssignmentStatement
 
             varDecl = New LocalVariableDeclaration(arg)
             varDecl.Init(Nothing, "VB$tmp", exp.ExpressionType)
             block.AddVariable(varDecl)
 
             newExp = New VariableExpression(arg, varDecl)
 
             stmt = New AssignmentStatement(Me.Parent)
             stmt.Init(newExp, exp)
             block.AddStatementBefore(stmt, Me)
 
             arg.Expression = newExp
         Next
 
         If InvocationExpression.Classification.IsVariableClassification Then
             result = CheckIndexedStatement(Info, TryCast(InvocationExpression.Classification.AsVariableClassification.ArrayVariable, InvocationOrIndexExpression)) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="806" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" hamdist="13" pcid="8659" startline="772"><![CDATA[
     End Property
 
     Private Function IsNarrowingInternal(ByVal ExceptObject As Boolean) As Boolean
         For j As Integer = 0 To InputParameters.Count - 1
             Dim arg As Argument
             Dim param As Mono.Cecil.ParameterDefinition
             Dim IsConvertible As Boolean
             Dim elementType As Mono.Cecil.TypeReference
             Dim initializer As Expression
 
             param = InputParameters(j)
             arg = ExactArguments(j)
 
             If ExceptObject AndAlso Helper.CompareType(arg.Expression.ExpressionType, Compiler.TypeCache.System_Object) Then Continue For
 
             If m_IsParamArray AndAlso j = InputParameters.Count - 1 AndAlso ParamArrayExpression IsNot Nothing Then
                 'To match the automatically created array for the paramarray parameter each argument has to be 
                 'implicitly convertible to the element type of the paramarray parameter type.
                 IsConvertible = True
                 elementType = CType(param.ParameterType, Mono.Cecil.ArrayType).ElementType
                 For k As Integer = 0 To ParamArrayExpression.ArrayElementInitalizer.Initializers.Count - 1
                     initializer = ParamArrayExpression.ArrayElementInitalizer.Initializers(k).AsRegularInitializer
                     IsConvertible = IsConvertible AndAlso Compiler.TypeResolution.IsImplicitlyConvertible(arg, initializer.ExpressionType, elementType)
                 Next
             Else
                 IsConvertible = Compiler.TypeResolution.IsImplicitlyConvertible(arg, arg.Expression.ExpressionType, param.ParameterType)
             End If
 
             If IsConvertible = False Then
                 Return True
             End If
         Next
 
         Return False
     End Function
]]></clone_fragment>
<clone_fragment endline="87" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" hamdist="16" pcid="8303" startline="56"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         
         If m_VariableInitializerList IsNot Nothing Then
             Dim expInfo As ExpressionResolveInfo = TryCast(Info, ExpressionResolveInfo)
             Dim elementInfo As ResolveInfo
             If expInfo IsNot Nothing Then
                 Helper.Assert(CecilHelper.GetElementType(expInfo.LHSType) IsNot Nothing)
                 Helper.Assert(CecilHelper.IsArray(expInfo.LHSType))
                 If expInfo.LHSType IsNot Nothing AndAlso CecilHelper.GetArrayRank(expInfo.LHSType) > 1 Then
                     Dim newArrayRank As Integer = CecilHelper.GetArrayRank(expInfo.LHSType) - 1
                     Dim elementType As Mono.Cecil.TypeReference = CecilHelper.MakeArrayType(CecilHelper.GetElementType(expInfo.LHSType), newArrayRank)
                     elementInfo = New ExpressionResolveInfo(Compiler, elementType)
                 Else
                     elementInfo = New ExpressionResolveInfo(Compiler, CecilHelper.GetElementType(expInfo.LHSType))
                 End If
             Else
                 Helper.StopIfDebugging(True)
                 elementInfo = Info
             End If
 
                 Helper.Assert(expInfo Is Nothing OrElse DirectCast(elementInfo, ExpressionResolveInfo).LHSType IsNot Nothing)
 
                 result = m_VariableInitializerList.ResolveCode(elementInfo) AndAlso result
             End If
         result = SetElements() AndAlso result
 
         Compiler.Helper.AddCheck("Array element initializers must all have the same number of elements / ranks.")
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="285" nfragments="2">
<clone_fragment endline="2473" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7717" startline="2444"><![CDATA[
 
     'TODO
     Shared Function OctToInt(ByVal str As String) As ULong
         Dim i, n As Integer
         Dim l As Integer = str.Length
         OctToInt = 0
         For i = l To 1 Step -1
             Select Case str.Chars(i - 1)
                 Case "0"c
                     n = 0
                 Case "1"c
                     n = 1
                 Case "2"c
                     n = 2
                 Case "3"c
                     n = 3
                 Case "4"c
                     n = 4
                 Case "5"c
                     n = 5
                 Case "6"c
                     n = 6
                 Case "7"c
                     n = 7
                 Case Else
                     Throw New ArgumentOutOfRangeException("str", str, "Invalid octal number
             End Select
             OctToInt += CULng(n * (8 ^ (l - i)))
         Next
     End Function
]]></clone_fragment>
<clone_fragment endline="2422" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="7" pcid="7713" startline="2376"><![CDATA[
 
     'TODO
     Shared Function HexToInt(ByVal str As String) As ULong
         Dim i, n As Integer
         Dim l As Integer = str.Length
         HexToInt = 0
         For i = l To 1 Step -1
             Select Case str.Chars(i - 1)
                 Case "0"c
                     n = 0
                 Case "1"c
                     n = 1
                 Case "2"c
                     n = 2
                 Case "3"c
                     n = 3
                 Case "4"c
                     n = 4
                 Case "5"c
                     n = 5
                 Case "6"c
                     n = 6
                 Case "7"c
                     n = 7
                 Case "8"c
                     n = 8
                 Case "9"c
                     n = 9
                 Case "a"c, "A"c
                     n = 10
                 Case "b"c, "B"c
                     n = 11
                 Case "c"c, "C"c
                     n = 12
                 Case "d"c, "D"c
                     n = 13
                 Case "e"c, "E"c
                     n = 14
                 Case "f"c, "F"c
                     n = 15
                 Case Else
                     Throw New ArgumentOutOfRangeException("str", str, "Invalid hex number
             End Select
 
             HexToInt += CULng(n * (16 ^ (l - i)))
         Next
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="286" nfragments="4">
<clone_fragment endline="297" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="0" pcid="3295" startline="268"><![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Loop, loc);
 
 			bool was_unreachable = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Embedded, loc);
 			if (!EmbeddedStatement.Resolve (ec))
 				ok = false;
 			ec.EndFlowBranching ();
 
 			if (ec.CurrentBranching.CurrentUsageVector.IsUnreachable && !was_unreachable)
 				ec.Report.Warning (162, 2, expr.Location, "Unreachable code detected");
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				ok = false;
 			else if (expr is Constant){
 				bool infinite = !((Constant) expr).IsDefaultValue;
 				if (infinite)
 					ec.CurrentBranching.CurrentUsageVector.Goto ();
 			}
 
 			ec.EndFlowBranching ();
 
 			return ok;
 		}
]]></clone_fragment>
<clone_fragment endline="389" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="10" pcid="3303" startline="350"><![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				ok = false;
 
 			//
 			// Inform whether we are infinite or not
 			//
 			if (expr is Constant){
 				bool value = !((Constant) expr).IsDefaultValue;
 
 				if (value == false){
 					if (!Statement.ResolveUnreachable (ec, true))
 						return false;
 					empty = true;
 					return true;
 				} else
 					infinite = true;
 			}
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Loop, loc);
 			if (!infinite)
 				ec.CurrentBranching.CreateSibling ();
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Embedded, loc);
 			if (!Statement.Resolve (ec))
 				ok = false;
 			ec.EndFlowBranching ();
 
 			// There's no direct control flow from the end of the embedded statement to the end of the loop
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			ec.EndFlowBranching ();
 
 			return ok;
 		}
]]></clone_fragment>
<clone_fragment endline="530" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="12" pcid="3311" startline="472"><![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			if (InitStatement != null){
 				if (!InitStatement.Resolve (ec))
 					ok = false;
 			}
 
 			if (Test != null){
 				Test = Test.Resolve (ec);
 				if (Test == null)
 					ok = false;
 				else if (Test is Constant){
 					bool value = !((Constant) Test).IsDefaultValue;
 
 					if (value == false){
 						if (!Statement.ResolveUnreachable (ec, true))
 							return false;
 						if ((Increment != null) &&
 						    !Increment.ResolveUnreachable (ec, false))
 							return false;
 						empty = true;
 						return true;
 					} else
 						infinite = true;
 				}
 			} else
 				infinite = true;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Loop, loc);
 			if (!infinite)
 				ec.CurrentBranching.CreateSibling ();
 
 			bool was_unreachable = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Embedded, loc);
 			if (!Statement.Resolve (ec))
 				ok = false;
 			ec.EndFlowBranching ();
 
 			if (Increment != null){
 				if (ec.CurrentBranching.CurrentUsageVector.IsUnreachable) {
 					if (!Increment.ResolveUnreachable (ec, !was_unreachable))
 						ok = false;
 				} else {
 					if (!Increment.Resolve (ec))
 						ok = false;
 				}
 			}
 
 			// There's no direct control flow from the end of the embedded statement to the end of the loop
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			ec.EndFlowBranching ();
 
 			return ok;
 		}
]]></clone_fragment>
<clone_fragment endline="201" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="11" pcid="3287" startline="146"><![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			Report.Debug (1, "START IF BLOCK", loc);
 
 			expr = expr.Resolve (ec);
 			if (expr == null) {
 				ok = false;
 			} else {
 				//
 				// Dead code elimination
 				//
 				if (expr is Constant) {
 					bool take = !((Constant) expr).IsDefaultValue;
 
 					if (take) {
 						if (!TrueStatement.Resolve (ec))
 							return false;
 
 						if ((FalseStatement != null) &&
 							!FalseStatement.ResolveUnreachable (ec, true))
 							return false;
 						FalseStatement = null;
 					} else {
 						if (!TrueStatement.ResolveUnreachable (ec, true))
 							return false;
 						TrueStatement = null;
 
 						if ((FalseStatement != null) &&
 							!FalseStatement.Resolve (ec))
 							return false;
 					}
 
 					return true;
 				}
 			}
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Conditional, loc);
 			
 			ok &= TrueStatement.Resolve (ec);
 
 			is_true_ret = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 
 			ec.CurrentBranching.CreateSibling ();
 
 			if (FalseStatement != null)
 				ok &= FalseStatement.Resolve (ec);
 					
 			ec.EndFlowBranching ();
 
 			Report.Debug (1, "END IF BLOCK", loc);
 
 			return ok;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="287" nfragments="3">
<clone_fragment endline="569" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" hamdist="0" pcid="4245" startline="540"><![CDATA[
 
 		//
 		// The stack contains the pointer and the value of type `type'
 		//
 		public void EmitStoreFromPtr (TypeSpec type)
 		{
 			if (type.IsEnum)
 				type = EnumSpec.GetUnderlyingType (type);
 
 			if (type == TypeManager.int32_type || type == TypeManager.uint32_type)
 				ig.Emit (OpCodes.Stind_I4);
 			else if (type == TypeManager.int64_type || type == TypeManager.uint64_type)
 				ig.Emit (OpCodes.Stind_I8);
 			else if (type == TypeManager.char_type || type == TypeManager.short_type ||
 				 type == TypeManager.ushort_type)
 				ig.Emit (OpCodes.Stind_I2);
 			else if (type == TypeManager.float_type)
 				ig.Emit (OpCodes.Stind_R4);
 			else if (type == TypeManager.double_type)
 				ig.Emit (OpCodes.Stind_R8);
 			else if (type == TypeManager.byte_type || type == TypeManager.sbyte_type ||
 				 type == TypeManager.bool_type)
 				ig.Emit (OpCodes.Stind_I1);
 			else if (type == TypeManager.intptr_type)
 				ig.Emit (OpCodes.Stind_I);
 			else if (TypeManager.IsStruct (type) || TypeManager.IsGenericParameter (type))
 				Emit (OpCodes.Stobj, type);
 			else
 				ig.Emit (OpCodes.Stind_Ref);
 		}
]]></clone_fragment>
<clone_fragment endline="426" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" hamdist="8" pcid="4237" startline="385"><![CDATA[
 
 		//
 		// Emits the right opcode to store to an array
 		//
 		public void EmitArrayStore (ArrayContainer ac)
 		{
 			if (ac.Rank > 1) {
 				if (IsAnonymousStoreyMutateRequired)
 					ac = (ArrayContainer) ac.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 				ig.Emit (OpCodes.Call, ac.GetSetMethod ());
 				return;
 			}
 
 			var type = ac.Element;
 
 			if (type.IsEnum)
 				type = EnumSpec.GetUnderlyingType (type);
 
 			if (type == TypeManager.byte_type || type == TypeManager.sbyte_type || type == TypeManager.bool_type)
 				Emit (OpCodes.Stelem_I1);
 			else if (type == TypeManager.short_type || type == TypeManager.ushort_type || type == TypeManager.char_type)
 				Emit (OpCodes.Stelem_I2);
 			else if (type == TypeManager.int32_type || type == TypeManager.uint32_type)
 				Emit (OpCodes.Stelem_I4);
 			else if (type == TypeManager.int64_type || type == TypeManager.uint64_type)
 				Emit (OpCodes.Stelem_I8);
 			else if (type == TypeManager.float_type)
 				Emit (OpCodes.Stelem_R4);
 			else if (type == TypeManager.double_type)
 				Emit (OpCodes.Stelem_R8);
 			else if (type == TypeManager.intptr_type)
 				Emit (OpCodes.Stobj, type);
 			else if (TypeManager.IsStruct (type))
 				Emit (OpCodes.Stobj, type);
 			else if (type.IsGenericParameter)
 				Emit (OpCodes.Stelem, type);
 			else if (type.IsPointer)
 				Emit (OpCodes.Stelem_I);
 			else
 				Emit (OpCodes.Stelem_Ref);
 		}
]]></clone_fragment>
<clone_fragment endline="384" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" hamdist="6" pcid="4235" startline="335"><![CDATA[
 
 		//
 		// Emits the right opcode to load from an array
 		//
 		public void EmitArrayLoad (ArrayContainer ac)
 		{
 			if (ac.Rank > 1) {
 				if (IsAnonymousStoreyMutateRequired)
 					ac = (ArrayContainer) ac.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 				ig.Emit (OpCodes.Call, ac.GetGetMethod ());
 				return;
 			}
 
 			var type = ac.Element;
 			if (TypeManager.IsEnumType (type))
 				type = EnumSpec.GetUnderlyingType (type);
 
 			if (type == TypeManager.byte_type || type == TypeManager.bool_type)
 				Emit (OpCodes.Ldelem_U1);
 			else if (type == TypeManager.sbyte_type)
 				Emit (OpCodes.Ldelem_I1);
 			else if (type == TypeManager.short_type)
 				Emit (OpCodes.Ldelem_I2);
 			else if (type == TypeManager.ushort_type || type == TypeManager.char_type)
 				Emit (OpCodes.Ldelem_U2);
 			else if (type == TypeManager.int32_type)
 				Emit (OpCodes.Ldelem_I4);
 			else if (type == TypeManager.uint32_type)
 				Emit (OpCodes.Ldelem_U4);
 			else if (type == TypeManager.uint64_type)
 				Emit (OpCodes.Ldelem_I8);
 			else if (type == TypeManager.int64_type)
 				Emit (OpCodes.Ldelem_I8);
 			else if (type == TypeManager.float_type)
 				Emit (OpCodes.Ldelem_R4);
 			else if (type == TypeManager.double_type)
 				Emit (OpCodes.Ldelem_R8);
 			else if (type == TypeManager.intptr_type)
 				Emit (OpCodes.Ldelem_I);
 			else if (TypeManager.IsStruct (type)) {
 				Emit (OpCodes.Ldelema, type);
 				Emit (OpCodes.Ldobj, type);
 			} else if (type.IsGenericParameter) {
 				Emit (OpCodes.Ldelem, type);
 			} else if (type.IsPointer)
 				Emit (OpCodes.Ldelem_I);
 			else
 				Emit (OpCodes.Ldelem_Ref);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="288" nfragments="2">
<clone_fragment endline="5533" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="0" pcid="9249" startline="5504"><![CDATA[
 
     ''' <summary>
     '''SyncLockStatement  
     '''	"SyncLock" Expression  StatementTerminator
     '''	   [  Block  ]
     '''	"End" "SyncLock" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSyncLockStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As SyncLockStatement
         Dim result As New SyncLockStatement(Parent)
 
         Dim m_Lock As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.SyncLock)
 
         m_Lock = ParseExpression(result)
         If m_Lock Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.End, KS.SyncLock) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Lock, m_Code)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="5503" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="12" pcid="9247" startline="5446"><![CDATA[
 
     ''' <summary>
     ''' UsingStatement  
     '''	"Using" UsingResources  StatementTerminator
     '''		[  Block  ]
     '''	"End" "Using" StatementTerminator
     ''' 
     ''' UsingResources  
     ''' 
     ''' LAMESPEC!?
     ''' I'm using this
     ''' UsingResources 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseUsingStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As UsingStatement
         Dim result As New UsingStatement(Parent)
 
         Dim m_UsingResources As ParsedObject
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.Using)
 
         Dim newDecls As UsingDeclarators = Nothing
         If tm.CurrentToken.IsIdentifier AndAlso tm.PeekToken.Equals(KS.Equals, KS.As) Then
             'This is a variable declaration
             newDecls = New UsingDeclarators(result)
             If ParseList(Of UsingDeclarator)(newDecls, New ParseDelegate_Parent(Of UsingDeclarator)(AddressOf ParseUsingDeclarator), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_UsingResources = newDecls
         Else
             'This is an expression
             Dim exp As Expression = Nothing
             exp = ParseExpression(result)
             If exp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_UsingResources = exp
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If newDecls IsNot Nothing Then
             For Each decl As UsingDeclarator In newDecls
                 If decl.IsVariableDeclaration Then
                     m_Code.Variables.Add(decl.VariableDeclaration)
                 End If
                 decl.Parent = m_Code
             Next
         End If
 
         If tm.Accept(KS.End, KS.Using) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_UsingResources, m_Code)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="289" nfragments="2">
<clone_fragment endline="4624" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="0" pcid="1697" startline="4595"><![CDATA[
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Report.Debug (64, "VARIABLE EMIT", this, Variable, type, IsRef, loc);
 
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.Emit (ec, leave_copy);
 				return;
 			}
 
 			EmitLoad (ec);
 
 			if (IsRef) {
 				//
 				// If we are a reference, we loaded on the stack a pointer
 				// Now lets load the real value
 				//
 				ec.EmitLoadFromPtr (type);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="4669" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="11" pcid="1699" startline="4625"><![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy,
 					bool prepare_for_load)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.EmitAssign (ec, source, leave_copy, prepare_for_load);
 				return;
 			}
 
 			New n_source = source as New;
 			if (n_source != null) {
 				if (!n_source.Emit (ec, this)) {
 					if (leave_copy) {
 						EmitLoad (ec);
 						if (IsRef)
 							ec.EmitLoadFromPtr (type);
 					}
 					return;
 				}
 			} else {
 				if (IsRef)
 					EmitLoad (ec);
 
 				source.Emit (ec);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 
 			if (IsRef)
 				ec.EmitStoreFromPtr (type);
 			else
 				Variable.EmitAssign (ec);
 
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="290" nfragments="2">
<clone_fragment endline="186" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="0" pcid="9635" startline="157"><![CDATA[
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_TypeDeclarations.Length - 1
             Dim type As TypeDeclaration = m_TypeDeclarations(i)
 
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Green
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveCode " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = type.ResolveCode(Info) AndAlso result
             Compiler.VerifyConsistency(result, type.Location)
         Next
 
         result = m_Attributes.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="6165" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="10" pcid="9283" startline="6121"><![CDATA[
 
     Private Function GetPartialType(ByVal Parent As ParsedObject, ByVal m_Identifier As Identifier, ByVal m_TypeParameters As TypeParameters, ByVal m_Modifiers As Modifiers, ByVal IsClass As Boolean, ByVal [Namespace] As String) As PartialTypeDeclaration
         Dim result As PartialTypeDeclaration
 
         'Get the actual name of the type including generic number
         Dim CompleteName As String
         Dim GenericName As Identifier
         If m_TypeParameters Is Nothing Then
             GenericName = m_Identifier
         Else
             GenericName = New Identifier(Helper.CreateGenericTypename(m_Identifier.Name, m_TypeParameters.Parameters.Count))
         End If
 
         CompleteName = GenericName.Name
         If TypeOf Parent Is AssemblyDeclaration AndAlso [Namespace] <> String.Empty Then
             CompleteName = [Namespace] & "." & CompleteName
         End If
 
         'Try to find the type in the parent
         Dim partialType As TypeDeclaration = FindTypeInParent(Parent, CompleteName)
         Dim partialClassOrStruct As PartialTypeDeclaration = TryCast(partialType, PartialTypeDeclaration)
 
         If partialType IsNot Nothing Then
             'There is already a type with the same name
             result = partialClassOrStruct
             result.IsPartial = True
             result.Modifiers = result.Modifiers.AddModifiers(m_Modifiers.Mask)
             result.PartialModifierFound = result.Modifiers.Is(ModifierMasks.Partial) OrElse m_Modifiers.Is(ModifierMasks.Partial)
         ElseIf partialType IsNot Nothing Then
             'There is another type with the same name
             Helper.AddError(tm.Compiler, tm.CurrentLocation, "Two types with the same name
             Return Nothing
         Else
             'No type with the same name.
             If IsClass Then
                 result = New ClassDeclaration(Parent, [Namespace], GenericName, m_TypeParameters)
             Else
                 result = New StructureDeclaration(Parent, [Namespace], GenericName, m_TypeParameters)
             End If
             result.Modifiers = m_Modifiers
             result.UpdateDefinition()
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="291" nfragments="3">
<clone_fragment endline="531" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" hamdist="0" pcid="29" startline="505"><![CDATA[
 
 		struct CustomModifiers
 		{
 			internal Type[] required;
 			internal Type[] optional;
 		}
 
 		private static CustomModifiers ReadCustomModifiers(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			CustomModifiers mods = new CustomModifiers();
 			byte b = br.PeekByte();
 			if (IsCustomModifier(b))
 			{
 				List<Type> required = new List<Type>();
 				List<Type> optional = new List<Type>();
 				while (IsCustomModifier(b))
 				{
 					bool req = br.ReadByte() == ELEMENT_TYPE_CMOD_REQD;
 					Type type = ReadTypeDefOrRefEncoded(module, br, context);
 					(req ? required 
 					b = br.PeekByte();
 				}
 				while (IsCustomModifier(b))
 				{
 					bool req = br.ReadByte() == ELEMENT_TYPE_CMOD_REQD;
 					Type type = ReadTypeDefOrRefEncoded(module, br, context);
 					(req ? required 
 					b = br.PeekByte();
 				}
 				mods.required = required.ToArray();
 				mods.optional = optional.ToArray();
 			}
 			return mods;
 		}
]]></clone_fragment>
<clone_fragment endline="589" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" hamdist="13" pcid="35" startline="559"><![CDATA[
 
 		protected static void ReadCustomModifiers(ModuleReader module, ByteReader br, IGenericContext context, out Type[] requiredCustomModifiers, out Type[] optionalCustomModifiers)
 		{
 			byte b = br.PeekByte();
 			if (IsCustomModifier(b))
 			{
 				List<Type> required = new List<Type>();
 				List<Type> optional = new List<Type>();
 				while (IsCustomModifier(b))
 				{
 					br.ReadByte();
 					Type type = ReadTypeDefOrRefEncoded(module, br, context);
 					if (b == ELEMENT_TYPE_CMOD_REQD)
 					{
 						required.Add(type);
 					}
 					else
 					{
 						optional.Add(type);
 					}
 					b = br.PeekByte();
 				}
 				while (IsCustomModifier(b))
 				{
 					br.ReadByte();
 					Type type = ReadTypeDefOrRefEncoded(module, br, context);
 					if (b == ELEMENT_TYPE_CMOD_REQD)
 					{
 						required.Add(type);
 					}
 					else
 					{
 						optional.Add(type);
 					}
 					b = br.PeekByte();
 				}
 				requiredCustomModifiers = required.ToArray();
 				optionalCustomModifiers = optional.ToArray();
 			}
 			else
 			{
 				requiredCustomModifiers = null;
 				optionalCustomModifiers = null;
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="235" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" hamdist="11" pcid="3991" startline="200"><![CDATA[
 
 		private void SetMethodImplAttribute(CustomAttributeBuilder customBuilder)
 		{
 			MethodImplOptions opt;
 			switch (customBuilder.Constructor.ParameterCount)
 			{
 				case 0
 					opt = 0;
 					break;
 				case 1
 					{
 						object val = customBuilder.GetConstructorArgument(0);
 						if (val is short)
 						{
 							opt = (MethodImplOptions)(short)val;
 						}
 						else if (val is int)
 						{
 							opt = (MethodImplOptions)(int)val;
 						}
 						else
 						{
 							opt = (MethodImplOptions)val;
 						}
 						break;
 					}
 				default
 					throw new NotSupportedException();
 			}
 			MethodCodeType? type = customBuilder.GetFieldValue<MethodCodeType>("MethodCodeType");
 			implFlags = (MethodImplAttributes)opt;
 			if (type.HasValue)
 			{
 				implFlags |= (MethodImplAttributes)type;
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="292" nfragments="2">
<clone_fragment endline="1663" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="0" pcid="5361" startline="1642"><![CDATA[
 
 		private static Type[] BindArray(Type[] array, IGenericBinder binder)
 		{
 			if (array ==null || array.Length == 0)
 			{
 				return array;
 			}
 			Type[] result = array;
 			for (int i = 0; i < array.Length; i++)
 			{
 				Type type = array[i].BindTypeParameters(binder);
 				if (!ReferenceEquals(type, array[i]))
 				{
 					if (result == array)
 					{
 						result = (Type[])array.Clone();
 					}
 					result[i] = type;
 				}
 			}
 			for (int i = 0; i < array.Length; i++)
 			{
 				Type type = array[i].BindTypeParameters(binder);
 				if (!ReferenceEquals(type, array[i]))
 				{
 					if (result == array)
 					{
 						result = (Type[])array.Clone();
 					}
 					result[i] = type;
 				}
 			}
 			return result;
 		}
]]></clone_fragment>
<clone_fragment endline="481" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" hamdist="10" pcid="3281" startline="461"><![CDATA[
 
 		private static Type[] NormalizeAndCopy(Type[] array)
 		{
 			if (array == null || array.Length == 0)
 			{
 				return null;
 			}
 			Type[] copy = null;
 			for (int i = 0; i < array.Length; i++)
 			{
 				if (array[i] != null)
 				{
 					if (copy == null)
 					{
 						copy = new Type[array.Length];
 					}
 					copy[i] = array[i];
 				}
 			}
 			for (int i = 0; i < array.Length; i++)
 			{
 				if (array[i] != null)
 				{
 					if (copy == null)
 					{
 						copy = new Type[array.Length];
 					}
 					copy[i] = array[i];
 				}
 			}
 			return copy;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="293" nfragments="3">
<clone_fragment endline="635" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" hamdist="0" pcid="6177" startline="602"><![CDATA[
 
 		internal int ImportType(Type type)
 		{
 			int token;
 			if (!typeTokens.TryGetValue(type, out token))
 			{
 				if (type.HasElementType || (type.IsGenericType && !type.IsGenericTypeDefinition))
 				{
 					ByteBuffer spec = new ByteBuffer(5);
 					Signature.WriteTypeSpec(this, spec, type);
 					token = 0x1B000000 | this.TypeSpec.AddRecord(this.Blobs.Add(spec));
 				}
 				else
 				{
 					TypeRefTable.Record rec = new TypeRefTable.Record();
 					if (type.IsNested)
 					{
 						rec.ResolutionScope = GetTypeToken(type.DeclaringType).Token;
 						rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 						rec.TypeNameSpace = 0;
 					}
 					else
 					{
 						rec.ResolutionScope = ImportAssemblyRef(type.Assembly);
 						rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 						string ns = type.Namespace;
 						rec.TypeNameSpace = ns == null ? 0 
 					}
 					token = 0x01000000 | this.TypeRef.AddRecord(rec);
 				}
 				typeTokens.Add(type, token);
 			}
 			return token;
 		}
]]></clone_fragment>
<clone_fragment endline="714" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" hamdist="13" pcid="6183" startline="678"><![CDATA[
 
 		private int FindOrAddAssemblyRef(AssemblyName name)
 		{
 			AssemblyRefTable.Record rec = new AssemblyRefTable.Record();
 			Version ver = name.Version;
 			rec.MajorVersion = (ushort)ver.Major;
 			rec.MinorVersion = (ushort)ver.Minor;
 			rec.BuildNumber = (ushort)ver.Build;
 			rec.RevisionNumber = (ushort)ver.Revision;
 			rec.Flags = (int)(name.Flags & AssemblyNameFlags.Retargetable);
 			byte[] publicKeyOrToken = null;
 			if (usePublicKeyAssemblyReference)
 			{
 				publicKeyOrToken = name.GetPublicKey();
 			}
 			if (publicKeyOrToken == null || publicKeyOrToken.Length == 0)
 			{
 				publicKeyOrToken = name.GetPublicKeyToken();
 			}
 			else
 			{
 				const int PublicKey = 0x0001;
 				rec.Flags |= PublicKey;
 			}
 			rec.PublicKeyOrToken = this.Blobs.Add(ByteBuffer.Wrap(publicKeyOrToken));
 			rec.Name = this.Strings.Add(name.Name);
 			if (name.CultureInfo != null)
 			{
 				rec.Culture = this.Strings.Add(name.CultureInfo.Name);
 			}
 			else
 			{
 				rec.Culture = 0;
 			}
 			rec.HashValue = 0;
 			return 0x23000000 | this.AssemblyRef.FindOrAddRecord(rec);
 		}
]]></clone_fragment>
<clone_fragment endline="908" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" hamdist="17" pcid="6199" startline="882"><![CDATA[
 
 		internal void ExportTypes(Type[] types, int fileToken)
 		{
 			Dictionary<Type, int> declaringTypes = new Dictionary<Type, int>();
 			foreach (Type type in types)
 			{
 				if (!type.IsModulePseudoType && IsVisible(type))
 				{
 					ExportedTypeTable.Record rec = new ExportedTypeTable.Record();
 					rec.Flags = (int)type.Attributes;
 					rec.TypeDefId = type.MetadataToken & 0xFFFFFF;
 					rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 					string ns = type.Namespace;
 					rec.TypeNamespace = ns == null ? 0 
 					if (type.IsNested)
 					{
 						rec.Implementation = declaringTypes[type.DeclaringType];
 					}
 					else
 					{
 						rec.Implementation = fileToken;
 					}
 					int exportTypeToken = 0x27000000 | this.ExportedType.AddRecord(rec);
 					declaringTypes.Add(type, exportTypeToken);
 				}
 			}
 			foreach (Type type in types)
 			{
 				if (!type.IsModulePseudoType && IsVisible(type))
 				{
 					ExportedTypeTable.Record rec = new ExportedTypeTable.Record();
 					rec.Flags = (int)type.Attributes;
 					rec.TypeDefId = type.MetadataToken & 0xFFFFFF;
 					rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 					string ns = type.Namespace;
 					rec.TypeNamespace = ns == null ? 0 
 					if (type.IsNested)
 					{
 						rec.Implementation = declaringTypes[type.DeclaringType];
 					}
 					else
 					{
 						rec.Implementation = fileToken;
 					}
 					int exportTypeToken = 0x27000000 | this.ExportedType.AddRecord(rec);
 					declaringTypes.Add(type, exportTypeToken);
 				}
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="294" nfragments="2">
<clone_fragment endline="220" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" hamdist="0" pcid="4667" startline="191"><![CDATA[
 
 		internal void Bake()
 		{
 			PropertyTable.Record rec = new PropertyTable.Record();
 			rec.Flags = (short)attributes;
 			rec.Name = typeBuilder.ModuleBuilder.Strings.Add(name);
 			rec.Type = typeBuilder.ModuleBuilder.GetSignatureBlobIndex(sig);
 			int token = 0x17000000 | typeBuilder.ModuleBuilder.Property.AddRecord(rec);
 
 			if (lazyPseudoToken != 0)
 			{
 				typeBuilder.ModuleBuilder.RegisterTokenFixup(lazyPseudoToken, token);
 			}
 
 			if (getter != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Getter, getter.MetadataToken, token);
 			}
 			if (setter != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Setter, setter.MetadataToken, token);
 			}
 			if (otherMethods != null)
 			{
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="195" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" hamdist="10" pcid="2953" startline="161"><![CDATA[
 		}
 
 		internal void Bake()
 		{
 			EventTable.Record rec = new EventTable.Record();
 			rec.EventFlags = (short)attributes;
 			rec.Name = typeBuilder.ModuleBuilder.Strings.Add(name);
 			rec.EventType = eventtype;
 			int token = 0x14000000 | typeBuilder.ModuleBuilder.Event.AddRecord(rec);
 
 			if (lazyPseudoToken != 0)
 			{
 				typeBuilder.ModuleBuilder.RegisterTokenFixup(lazyPseudoToken, token);
 			}
 
 			if (addOnMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.AddOn, addOnMethod.MetadataToken, token);
 			}
 			if (removeOnMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.RemoveOn, removeOnMethod.MetadataToken, token);
 			}
 			if (fireMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Fire, fireMethod.MetadataToken, token);
 			}
 			if (otherMethods != null)
 			{
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="295" nfragments="3">
<clone_fragment endline="487" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" hamdist="0" pcid="25" startline="460"><![CDATA[
 
 		private static void WriteGenericSignature(ModuleBuilder module, ByteBuffer bb, Type type)
 		{
 			Type[] typeArguments = type.GetGenericArguments();
 			Type[][] requiredCustomModifiers = type.__GetGenericArgumentsRequiredCustomModifiers();
 			Type[][] optionalCustomModifiers = type.__GetGenericArgumentsOptionalCustomModifiers();
 			if (!type.IsGenericTypeDefinition)
 			{
 				type = type.GetGenericTypeDefinition();
 			}
 			bb.Write(ELEMENT_TYPE_GENERICINST);
 			if (type.IsValueType)
 			{
 				bb.Write(ELEMENT_TYPE_VALUETYPE);
 			}
 			else
 			{
 				bb.Write(ELEMENT_TYPE_CLASS);
 			}
 			bb.WriteTypeDefOrRefEncoded(module.GetTypeToken(type).Token);
 			bb.WriteCompressedInt(typeArguments.Length);
 			for (int i = 0; i < typeArguments.Length; i++)
 			{
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers[i]);
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers[i]);
 				WriteType(module, bb, typeArguments[i]);
 			}
 			for (int i = 0; i < typeArguments.Length; i++)
 			{
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers[i]);
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers[i]);
 				WriteType(module, bb, typeArguments[i]);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="704" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" hamdist="13" pcid="43" startline="666"><![CDATA[
 
 		internal static void WritePropertySig(ModuleBuilder module, ByteBuffer bb, CallingConventions callingConvention,
 			Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			byte flags = PROPERTY;
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				flags |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				flags |= EXPLICITTHIS;
 			}
 			if ((callingConvention & CallingConventions.VarArgs) != 0)
 			{
 				flags |= VARARG;
 			}
 			bb.Write(flags);
 			bb.WriteCompressedInt(parameterTypes == null ? 0 
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, returnTypeRequiredCustomModifiers);
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, returnTypeOptionalCustomModifiers);
 			WriteType(module, bb, returnType);
 			if (parameterTypes != null)
 			{
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterTypeRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterTypeRequiredCustomModifiers[i]);
 					}
 					if (parameterTypeOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterTypeOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterTypeRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterTypeRequiredCustomModifiers[i]);
 					}
 					if (parameterTypeOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterTypeOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="418" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" hamdist="12" pcid="3275" startline="370"><![CDATA[
 
 		private void WriteSigImpl(ModuleBuilder module, ByteBuffer bb, int parameterCount)
 		{
 			byte first;
 			if ((callingConvention & CallingConventions.Any) == CallingConventions.VarArgs)
 			{
 				Debug.Assert(genericParamCount == 0);
 				first = VARARG;
 			}
 			else if (genericParamCount > 0)
 			{
 				first = GENERIC;
 			}
 			else
 			{
 				first = DEFAULT;
 			}
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				first |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				first |= EXPLICITTHIS;
 			}
 			bb.Write(first);
 			if (genericParamCount > 0)
 			{
 				bb.WriteCompressedInt(genericParamCount);
 			}
 			bb.WriteCompressedInt(parameterCount);
 			// RetType
 			if (modifiers != null && modifiers[0] != null)
 			{
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[0][0]);
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[0][1]);
 			}
 			WriteType(module, bb, returnType);
 			// Param
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if (modifiers != null && modifiers[i + 1] != null)
 				{
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[i + 1][0]);
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[i + 1][1]);
 				}
 				WriteType(module, bb, parameterTypes[i]);
 			}
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if (modifiers != null && modifiers[i + 1] != null)
 				{
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[i + 1][0]);
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[i + 1][1]);
 				}
 				WriteType(module, bb, parameterTypes[i]);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="296" nfragments="3">
<clone_fragment endline="966" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" hamdist="0" pcid="2765" startline="936"><![CDATA[
 	
 	static int CompareMethodBase (object a, object b)
 	{
 		MethodBase aa = (MethodBase) a, bb = (MethodBase) b;
 		
 		if (aa.IsStatic == bb.IsStatic) {
 			int c = CompareMemberInfo (a, b);
 			if (c != 0)
 				return c;
 			ParameterInfo [] ap, bp;
 
 			//
 			// Sort overloads by the names of their types
 			// put methods with fewer params first.
 			//
 			
 			ap = aa.GetParameters ();
 			bp = bb.GetParameters ();
 			int n = System.Math.Min (ap.Length, bp.Length);
 
 			for (int i = 0; i < n; i ++)
 				if ((c = CompareType (ap [i].ParameterType, bp [i].ParameterType)) != 0)
 					return c;
 			for (int i = 0; i < n; i ++)
 				if ((c = CompareType (ap [i].ParameterType, bp [i].ParameterType)) != 0)
 					return c;
 
 			return ap.Length.CompareTo (bp.Length);
 		}
 		if (aa.IsStatic)
 			return -1;
 		
 		return 1;
 	}
]]></clone_fragment>
<clone_fragment endline="1661" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" hamdist="12" pcid="347" startline="1613"><![CDATA[
 
 		// <summary>
 		//   Performs an `and' operation on the bit vector.  The `new_vector' may have
 		//   a different size than the current one.
 		// </summary>
 		private MyBitVector And (MyBitVector new_vector)
 		{
 			if (Count == 0)
 				return this;
 
 			var o = new_vector.vector != null ? new_vector.vector 
 
 			if (o == null) {
 				for (int i = new_vector.Count; i < Count; ++i)
 					this [i] = false;
 				for (int i = new_vector.Count; i < Count; ++i)
 					this [i] = false;
 				return this;
 			}
 
 			if (o.Count == 0) {
 				SetAll (false);
 				return this;
 			}
 
 			if (Count == o.Count) {
 				if (vector == null) {
 					if (shared == null) {
 						shared = new_vector.MakeShared (Count);
 						return this;
 					}
 					initialize_vector ();
 				}
 				vector.And (o);
 				return this;
 			}
 
 			int min = o.Count;
 			if (Count < min)
 				min = Count;
 
 			for (int i = 0; i < min; i++) {
 				if (! o [i])
 					this [i] = false;
 			}
 			for (int i = 0; i < min; i++) {
 				if (! o [i])
 					this [i] = false;
 			}
 
 			for (int i = min; i < Count; i++)
 				this [i] = false;
 			for (int i = min; i < Count; i++)
 				this [i] = false;
 
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="1050" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" hamdist="12" pcid="2159" startline="1010"><![CDATA[
 	
 		bool CreateTypeBuilder ()
 		{
 			//
 			// Sets .size to 1 for structs with no instance fields
 			//
 			int type_size = Kind == MemberKind.Struct && first_nonstatic_field == null ? 1 
 
 			if (IsTopLevel) {
 				// TODO
 				if (Module.GlobalRootNamespace.IsNamespace (Name)) {
 					Report.Error (519, Location, "`{0}' clashes with a predefined namespace", Name);
 				}
 
 				TypeBuilder = Module.CreateBuilder (Name, TypeAttr, type_size);
 			} else {
 				TypeBuilder = Parent.TypeBuilder.DefineNestedType (Basename, TypeAttr, null, type_size);
 			}
 
 			spec.SetMetaInfo (TypeBuilder);
 			spec.MemberCache = new MemberCache (this);
 			spec.DeclaringType = Parent.CurrentType;
 
 			if (!IsTopLevel)
 				Parent.MemberCache.AddMember (spec);
 
 			if (IsGeneric) {
 				string[] param_names = new string[TypeParameters.Length];
 				for (int i = 0; i < TypeParameters.Length; i++)
 					param_names [i] = TypeParameters[i].Name;
 				for (int i = 0; i < TypeParameters.Length; i++)
 					param_names [i] = TypeParameters[i].Name;
 
 				all_tp_builders = TypeBuilder.DefineGenericParameters (param_names);
 
 				int offset = CurrentTypeParametersStartIndex;
 				for (int i = offset; i < all_tp_builders.Length; i++) {
 					CurrentTypeParameters [i - offset].Define (all_tp_builders [i], spec);
 				}
 				for (int i = offset; i < all_tp_builders.Length; i++) {
 					CurrentTypeParameters [i - offset].Define (all_tp_builders [i], spec);
 				}
 			}
 
 			return true;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="297" nfragments="3">
<clone_fragment endline="181" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" hamdist="0" pcid="1579" startline="154"><![CDATA[
 
 		internal static bool ArrayEquals(Type[][] t1, Type[][] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]></clone_fragment>
<clone_fragment endline="209" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" hamdist="3" pcid="1581" startline="182"><![CDATA[
 
 		internal static bool ArrayEquals(Type[][][] t1, Type[][][] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]></clone_fragment>
<clone_fragment endline="153" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" hamdist="6" pcid="1577" startline="125"><![CDATA[
 
 		// note that an empty array matches a null reference
 		internal static bool ArrayEquals(Type[] t1, Type[] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!TypeEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!TypeEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="298" nfragments="3">
<clone_fragment endline="89" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\SyncLockStatement.vb" hamdist="0" pcid="9511" startline="55"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim lockType As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeBuilder(Compiler, m_Lock.ExpressionType)
 
         Dim lockVariable As Mono.Cecil.Cil.VariableDefinition
         lockVariable = Emitter.DeclareLocal(Info, lockType)
 
         result = m_Lock.GenerateCode(Info.Clone(Me, True, False, lockType)) AndAlso result
         Emitter.EmitStoreVariable(Info, lockVariable)
 
         If Helper.CompareType(Compiler.TypeCache.System_Object, lockVariable.VariableType) Then
             Emitter.EmitLoadVariable(Info, lockVariable)
             Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ObjectFlowControl__CheckForSyncLockOnValueType_Object)
         End If
 
         Dim endException As Label
         endException = Emitter.EmitBeginExceptionBlock(Info)
         'Enter the lock
         Emitter.EmitLoadVariable(Info, lockVariable)
         Emitter.EmitCall(Info, Compiler.TypeCache.System_Threading_Monitor__Enter_Object)
 
         'Emit the code
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Info.ILGen.BeginFinallyBlock()
 
         'Exit the lock
         Emitter.EmitLoadVariable(Info, lockVariable)
         Emitter.EmitCall(Info, Compiler.TypeCache.System_Threading_Monitor__Exit_Object)
 
         Info.ILGen.EndExceptionBlock()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="124" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\RaiseEventStatement.vb" hamdist="11" pcid="9473" startline="64"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Event.Classification.IsEventAccessClassification)
 
         Dim cl As EventAccessClassification = m_Event.Classification.AsEventAccess
         Dim eventtp As Mono.Cecil.TypeReference = cl.EventType
         Dim delegatetp As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(cl.Type)
 
         Helper.Assert(delegatetp IsNot Nothing)
 
         Dim raiseMethod As Mono.Cecil.MethodReference
         raiseMethod = CecilHelper.FindDefinition(cl.EventInfo).InvokeMethod
         If raiseMethod IsNot Nothing Then
             'Call the raise method
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
         Else
             'Manually raise the event
             Dim delegateVar As Mono.Cecil.Cil.VariableDefinition
             Dim endIfLabel As Label
             Dim eventDeclaration As RegularEventDeclaration
             Dim eventdesc As Mono.Cecil.EventDefinition
             Dim invokemethod As Mono.Cecil.MethodReference
 
             delegateVar = Emitter.DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Compiler, delegatetp))
             endIfLabel = Emitter.DefineLabel(Info)
             eventdesc = CecilHelper.FindDefinition(cl.EventInfo)
             eventDeclaration = DirectCast(eventdesc.Annotations(Compiler), RegularEventDeclaration)
             invokemethod = Helper.GetInvokeMethod(Compiler, delegatetp)
 
             'Helper.Assert(eventDeclaration IsNot Nothing)
             'Helper.Assert(TypeOf cl.EventInfo Is EventDescriptor)
             'Helper.Assert(Helper.CompareType(cl.EventType, Me.FindFirstParent(Of IType).CecilType))
             Helper.Assert(invokemethod IsNot Nothing)
 
             'Load the field of the variable
             If eventDeclaration.EventField.IsStatic = False Then
                 Emitter.EmitLoadMe(Info, cl.EventType)
             End If
             Emitter.EmitLoadVariable(Info, eventDeclaration.EventField)
 
             'Test if the field is nothing
             Emitter.EmitStoreVariable(Info, delegateVar)
             Emitter.EmitLoadVariable(Info, delegateVar)
             'If the field is nothing, don't invoke anything.
             Emitter.EmitBranchIfFalse(Info, endIfLabel)
 
             'Load the field again
             Emitter.EmitLoadVariable(Info, delegateVar)
             'Load the invoke arguments
             result = m_Arguments.GenerateCode(Info.Clone(Me, True), invokemethod.Parameters) AndAlso result
             'Call the invoke method.
             Emitter.EmitCallOrCallVirt(Info, invokemethod)
 
             'End of the RaiseEvent statement.
             Emitter.MarkLabel(Info, endIfLabel)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="242" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" hamdist="13" pcid="6833" startline="187"><![CDATA[
     End Property
 
 
     ''' <summary>
     ''' Loads the value of the variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Function GenerateCodeAsValue(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         If m_InstanceExpression IsNot Nothing Then
             result = m_InstanceExpression.GenerateCode(Info) AndAlso result
         End If
 
         If FieldInfo IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, FieldInfo)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         ElseIf LocalBuilder IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, LocalBuilder)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         ElseIf ParameterInfo IsNot Nothing Then
             Helper.Assert(m_InstanceExpression Is Nothing)
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, ParameterInfo)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         ElseIf m_ArrayVariable IsNot Nothing Then
             result = Helper.EmitLoadArrayElement(Info, m_ArrayVariable, m_Arguments) AndAlso result
         ElseIf m_Expression IsNot Nothing Then
             result = m_Expression.GenerateCode(Info) AndAlso result
         Else
             Throw New InternalException(Me)
         End If
 
         If CecilHelper.IsByRef(Info.DesiredType) Then
             Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(Info.DesiredType)
             Dim local As Mono.Cecil.Cil.VariableDefinition
             local = Emitter.DeclareLocal(Info, elementType)
 
             Emitter.EmitStoreVariable(Info, local)
             Emitter.EmitLoadVariableLocation(Info, local)
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="299" nfragments="2">
<clone_fragment endline="3076" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="0" pcid="3421" startline="3042"><![CDATA[
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="1029" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="11" pcid="3343" startline="986"><![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			if (ec.Switch == null){
 				ec.Report.Error (153, loc, "A goto case is only valid inside a switch statement");
 				return false;
 			}
 
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return false;
 
 			Constant c = expr as Constant;
 			if (c == null) {
 				ec.Report.Error (150, expr.Location, "A constant value is expected");
 				return false;
 			}
 
 			TypeSpec type = ec.Switch.SwitchType;
 			Constant res = c.TryReduce (ec, type, c.Location);
 			if (res == null) {
 				c.Error_ValueCannotBeConverted (ec, loc, type, true);
 				return false;
 			}
 
 			if (!Convert.ImplicitStandardConversionExists (c, type))
 				ec.Report.Warning (469, 2, loc,
 					"The `goto case' value is not implicitly convertible to type `{0}'",
 					TypeManager.CSharpName (type));
 
 			object val = res.GetValue ();
 			if (val == null)
 				val = SwitchLabel.NullStringCase;
 					
 			if (!ec.Switch.Elements.TryGetValue (val, out sl)) {
 				FlowBranchingBlock.Error_UnknownLabel (loc, "case " + 
 					(c.GetValue () == null ? "null" 
 				return false;
 			}
 
 			return true;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="300" nfragments="3">
<clone_fragment endline="532" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" hamdist="0" pcid="3017" startline="498"><![CDATA[
 
 	static public void Reset ()
 	{
 //		object_type = null;
 	
 		// TODO
 		system_type_get_type_from_handle =
 		bool_movenext_void =
 		void_dispose_void =
 		void_monitor_enter_object =
 		void_monitor_exit_object =
 		void_initializearray_array_fieldhandle =
 		int_interlocked_compare_exchange =
 		gen_interlocked_compare_exchange =
 		methodbase_get_type_from_handle =
 		methodbase_get_type_from_handle_generic =
 		fieldinfo_get_field_from_handle =
 		fieldinfo_get_field_from_handle_generic =
 		activator_create_instance =
 		delegate_combine_delegate_delegate =
 		delegate_remove_delegate_delegate = null;
 
 		int_get_offset_to_string_data =
 		ienumerator_getcurrent = null;
 
 		void_decimal_ctor_five_args =
 		void_decimal_ctor_int_arg =
 		void_decimal_ctor_long_arg = null;
 
 		string_empty = null;
 
 		typed_reference_type = arg_iterator_type = mbr_type =
 		generic_ilist_type = generic_icollection_type = generic_ienumerator_type =
 		generic_ienumerable_type = generic_nullable_type = expression_type = null;
 	}
]]></clone_fragment>
<clone_fragment endline="241" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\rootcontext.cs" hamdist="3" pcid="6235" startline="200"><![CDATA[
 		
 		public static void Reset (bool full)
 		{
 			if (!full)
 				return;
 			
 			Checked = false;
 			Unsafe = false;
 			StdLib = true;
 			StrongNameKeyFile = null;
 			StrongNameKeyContainer = null;
 			StrongNameDelaySign = false;
 			MainClass = null;
 			OutputFile = null;
 			Target = Target.Exe;
 			SdkVersion = SdkVersion.v2;
 			TargetExt = ".exe";
 			Platform = Platform.AnyCPU;
 			Version = LanguageVersion.Default;
 			VerifyClsCompliance = true;
 			Optimize = true;
 			Encoding = Encoding.Default;
 			Documentation = null;
 			GenerateDebugInfo = false;
 			ParseOnly = false;
 			TokenizeOnly = false;
 			Win32IconFile = null;
 			Win32ResourceFile = null;
 			Resources = null;
 			LoadDefaultReferences = true;
 			AssemblyReferences = new List<string> ();
 			AssemblyReferencesAliases = new List<Tuple<string, string>> ();
 			Modules = new List<string> ();
 			ReferencesLookupPaths = new List<string> ();
 			StdLibRuntimeVersion = RuntimeVersion.v2;
 
 			//
 			// Setup default defines
 			//
 			AllDefines = new List<string> ();
 			AddConditional ("__MonoCS__");
 		}
]]></clone_fragment>
<clone_fragment endline="569" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" hamdist="13" pcid="3893" startline="534"><![CDATA[
 
 		static public byte[] ToCapiPublicKeyBlob (RSA rsa) 
 		{
 			RSAParameters p = rsa.ExportParameters (false);
 			int keyLength = p.Modulus.Length; // in bytes
 			byte[] blob = new byte [20 + keyLength];
 
 			blob [0] = 0x06;	// Type - PUBLICKEYBLOB (0x06)
 			blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
 			// [2], [3]		// RESERVED - Always 0
 			blob [5] = 0x24;	// ALGID - Always 00 24 00 00 (for CALG_RSA_SIGN)
 			blob [8] = 0x52;	// Magic - RSA1 (ASCII in hex)
 			blob [9] = 0x53;
 			blob [10] = 0x41;
 			blob [11] = 0x31;
 
 			byte[] bitlen = GetBytesLE (keyLength << 3);
 			blob [12] = bitlen [0];	// bitlen
 			blob [13] = bitlen [1];	
 			blob [14] = bitlen [2];	
 			blob [15] = bitlen [3];
 
 			// public exponent (DWORD)
 			int pos = 16;
 			int n = p.Exponent.Length;
 			while (n > 0)
 				blob [pos++] = p.Exponent [--n];
 			while (n > 0)
 				blob [pos++] = p.Exponent [--n];
 			// modulus
 			pos = 20;
 			byte[] part = p.Modulus;
 			int len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 			return blob;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="301" nfragments="5">
<clone_fragment endline="3193" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="0" pcid="9093" startline="3172"><![CDATA[
 
     Private Function ParseMultDiv(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseUnaryPlusMinus(Info)
 
         While tm.CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseUnaryPlusMinus(Info)
             If op = KS.Mult Then
                 lSide = New MultExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.RealDivision Then
                 lSide = New RealDivisionExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseUnaryPlusMinus(Info)
             If op = KS.Mult Then
                 lSide = New MultExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.RealDivision Then
                 lSide = New RealDivisionExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]></clone_fragment>
<clone_fragment endline="3277" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="3" pcid="9103" startline="3256"><![CDATA[
 
     Private Function ParseBitshift(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseConcat(Info)
 
         While tm.CurrentToken.Equals(KS.ShiftRight, KS.ShiftLeft)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseConcat(Info)
             If op = KS.ShiftRight Then
                 lSide = New RShiftExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.ShiftLeft Then
                 lSide = New LShiftExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.ShiftRight, KS.ShiftLeft)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseConcat(Info)
             If op = KS.ShiftRight Then
                 lSide = New RShiftExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.ShiftLeft Then
                 lSide = New LShiftExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]></clone_fragment>
<clone_fragment endline="3355" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="4" pcid="9109" startline="3334"><![CDATA[
 
     Private Function ParseAnd_AndAlso(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseNot(Info)
 
         While tm.CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseNot(Info)
             If op = KS.And Then
                 lSide = New AndExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.AndAlso Then
                 lSide = New AndAlsoExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseNot(Info)
             If op = KS.And Then
                 lSide = New AndExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.AndAlso Then
                 lSide = New AndAlsoExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]></clone_fragment>
<clone_fragment endline="3379" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="5" pcid="9111" startline="3356"><![CDATA[
 
     Private Function ParseOr_OrElse_Xor(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseAnd_AndAlso(Info)
 
         While tm.CurrentToken.Equals(KS.Or, KS.OrElse, KS.Xor)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseAnd_AndAlso(Info)
             If op = KS.Or Then
                 lSide = New OrExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.OrElse Then
                 lSide = New OrElseExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Xor Then
                 lSide = New XOrExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Or, KS.OrElse, KS.Xor)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             rSide = ParseAnd_AndAlso(Info)
             If op = KS.Or Then
                 lSide = New OrExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.OrElse Then
                 lSide = New OrElseExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Xor Then
                 lSide = New XOrExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]></clone_fragment>
<clone_fragment endline="3242" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Parser\Parser.vb" hamdist="4" pcid="9099" startline="3220"><![CDATA[
 
     Private Function ParsePlusMinus(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseMod(Info)
 
         While tm.CurrentToken.Equals(KS.Add, KS.Minus)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseMod(Info)
             If op = KS.Add Then
                 lSide = New BinaryAddExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Minus Then
                 lSide = New BinarySubExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Add, KS.Minus)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             rSide = ParseMod(Info)
             If op = KS.Add Then
                 lSide = New BinaryAddExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Minus Then
                 lSide = New BinarySubExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
 
         Return lSide
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="302" nfragments="4">
<clone_fragment endline="127" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MemberCache.vb" hamdist="0" pcid="7853" startline="93"><![CDATA[
 #End If
 
     Public Sub ClearAll()
         Dim tG As Mono.Cecil.GenericParameter
 
         If m_Types Is Nothing Then
             m_Types = New List(Of Mono.Cecil.TypeReference)
         Else
             m_Types.Clear()
         End If
 
         tG = TryCast(m_Type, Mono.Cecil.GenericParameter)
         If tG IsNot Nothing Then
             If tG.Constraints.Count = 0 Then
                 m_Types.Add(Compiler.TypeCache.System_Object)
             Else
                 m_Types.AddRange(tG.Constraints)
             End If
         Else
             m_Types.Add(m_Type)
         End If
 
         If m_Members Is Nothing Then
             m_Members = New List(Of Mono.Collections.Generic.Collection(Of MemberReference))
         Else
             m_Members.Clear()
         End If
         For i As Integer = 0 To m_Types.Count - 1
             m_Members.Add(CecilHelper.GetMembers(m_Types(i)))
         Next
 
         For i As Integer = 0 To MemberVisibility.All - 1
             Clear(CType(i, MemberVisibility))
         Next
     End Sub
]]></clone_fragment>
<clone_fragment endline="1339" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="13" pcid="7615" startline="1270"><![CDATA[
 
 
     ''' <summary>
     ''' Returns true if the type has a default property
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function HasDefaultProperty(ByVal Context As BaseObject, ByVal tp As Mono.Cecil.TypeReference, ByRef properties As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)) As Boolean
         Dim Compiler As Compiler = Context.Compiler
         Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim defaultName As String = Nothing
 
         If tp Is Nothing Then Return False
 
         If properties Is Nothing Then properties = New Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)
         members = Compiler.TypeManager.GetCache(tp).GetAllMembers()
 
         For i As Integer = 0 To members.Count - 1
             Dim p As Mono.Cecil.PropertyReference = TryCast(members(i), Mono.Cecil.PropertyReference)
             Dim pD As PropertyDeclaration
 
             If p Is Nothing Then Continue For
 
             If p.Annotations.Contains(Compiler) Then
                 pD = DirectCast(p.Annotations(Compiler), PropertyDeclaration)
                 If pD.Modifiers.Is(ModifierMasks.Default) Then
                     AddPropertyUnlessSignatureMatches(properties, p)
                 End If
                 Continue For
             End If
 
             Dim p2 As Mono.Cecil.PropertyReference = CecilHelper.FindDefinition(p)
             If p2.Annotations.Contains(Compiler) Then
                 pD = DirectCast(p2.Annotations(Compiler), PropertyDeclaration)
                 If pD.Modifiers.Is(ModifierMasks.Default) Then
                     AddPropertyUnlessSignatureMatches(properties, p)
                 End If
                 Continue For
             End If
 
             'OPTIMIZATION
             Dim pDef As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(p.DeclaringType)
             Dim defaultAttribute As Mono.Cecil.CustomAttribute = Helper.GetDefaultMemberAttribute(Compiler, pDef)
             If defaultAttribute Is Nothing Then Continue For
             If defaultAttribute.ConstructorArguments.Count <> 1 Then Continue For
             If TypeOf defaultAttribute.ConstructorArguments(0).Value Is String = False Then Continue For
             defaultName = DirectCast(defaultAttribute.ConstructorArguments(0).Value, String)
 
             If Helper.CompareNameOrdinal(p.Name, defaultName) Then
                 AddPropertyUnlessSignatureMatches(properties, p)
             End If
         Next
 
         If Helper.CompareType(Compiler.TypeCache.System_Object, tp) = False Then
             If CecilHelper.IsInterface(tp) Then
                 Dim interfaces As Mono.Collections.Generic.Collection(Of TypeReference) = CecilHelper.GetInterfaces(tp, False)
                 Dim result As Boolean
                 If interfaces IsNot Nothing Then
                     For i As Integer = 0 To interfaces.Count - 1
                         result = HasDefaultProperty(Context, interfaces(i), properties) OrElse result
                     Next
                 End If
                 Return properties.Count > 0
             Else
                 Return HasDefaultProperty(Context, CecilHelper.GetBaseType(tp), properties)
             End If
         End If
 
         Return properties.Count > 0
     End Function
]]></clone_fragment>
<clone_fragment endline="104" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\PropertyGroupClassification.vb" hamdist="13" pcid="6773" startline="58"><![CDATA[
     End Property
 
     Function ResolveGroup(ByVal SourceParameters As ArgumentList) As Boolean
         Dim result As Boolean = True
         Dim destinationParameterTypes()() As Mono.Cecil.TypeReference
         Dim destinationParameters() As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim sourceParameterTypes() As Mono.Cecil.TypeReference
 
         ReDim destinationParameterTypes(m_Members.Count - 1)
         ReDim destinationParameters(m_Members.Count - 1)
         For i As Integer = 0 To m_Members.Count - 1
             destinationParameters(i) = m_Members(i).Parameters
             destinationParameterTypes(i) = Helper.GetTypes(destinationParameters(i))
         Next
 
         sourceParameterTypes = SourceParameters.ToTypes
 
         Dim resolvedGroup As New Generic.List(Of Mono.Cecil.MemberReference)
         Dim inputGroup As New Generic.List(Of Mono.Cecil.MemberReference)(m_Members.Count)
         For i As Integer = 0 To m_Members.Count - 1
             inputGroup.Add(DirectCast(m_Members(i), PropertyReference))
         Next
 
         If m_Resolver Is Nothing Then m_Resolver = New MethodResolver(Parent)
         m_Resolver.ShowErrors = False
         m_Resolver.Init(inputGroup, SourceParameters, Nothing)
         result = m_Resolver.Resolve AndAlso result
 
         If result Then
             If m_Resolver.IsLateBound = False Then
                 m_FinalSourceArguments = New ArgumentList(Me.Parent, m_Resolver.ResolvedCandidate.ExactArguments)
                 resolvedGroup.Add(m_Resolver.ResolvedMember)
             End If
         End If
 
         'result = Helper.ResolveGroup(Me.Parent, inputGroup, resolvedGroup, SourceParameters, Nothing, Nothing, False)
 
         If result Then
             m_ResolvedProperty = TryCast(resolvedGroup(0), Mono.Cecil.PropertyReference)
             result = m_ResolvedProperty IsNot Nothing AndAlso result
         End If
 
         m_Parameters = SourceParameters
         m_Resolved = True
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="897" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" hamdist="15" pcid="7499" startline="814"><![CDATA[
 
     ''' <summary>
     ''' Sets the entry point / Main function of the assembly
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function SetMain() As Boolean
         Dim result As Boolean = True
 
         Try
             If CommandLine.Target = vbnc.CommandLine.Targets.Library Then Return True
             If CommandLine.Target = vbnc.CommandLine.Targets.Module Then Return True
 
             'Find the main function
             Dim lstMethods As New Generic.List(Of Mono.Cecil.MethodDefinition)
             Dim mainClass As TypeDeclaration = Nothing
             Dim mainCecil As Mono.Cecil.MethodDefinition = Nothing
             Dim hasMainMethod As Boolean
 
             result = FindMainClass(mainClass) AndAlso result
             result = FindMainMethod(mainClass, lstMethods, hasMainMethod) AndAlso result
 
             If result = False Then Return result
 
             If lstMethods.Count = 0 AndAlso CommandLine.Target = vbnc.CommandLine.Targets.Winexe AndAlso mainClass IsNot Nothing AndAlso vbnc.Helper.IsSubclassOf(TypeCache.System_Windows_Forms_Form, mainClass.CecilType) Then
                 'In this case we need to create our own main method
                 'Dim mainBuilder As MethodBuilder
                 Dim formConstructor As ConstructorDeclaration
                 'Dim ilGen As ILGenerator
 
                 formConstructor = mainClass.DefaultInstanceConstructor
 
                 If formConstructor IsNot Nothing Then
                     mainCecil = New Mono.Cecil.MethodDefinition("Main", Mono.Cecil.MethodAttributes.Public Or Mono.Cecil.MethodAttributes.Static Or Mono.Cecil.MethodAttributes.HideBySig, Helper.GetTypeOrTypeReference(Me, TypeCache.System_Void))
                     mainCecil.Body.GetILProcessor.Emit(Mono.Cecil.Cil.OpCodes.Newobj, formConstructor.CecilBuilder)
                     mainCecil.Body.GetILProcessor.Emit(Mono.Cecil.Cil.OpCodes.Call, Helper.GetMethodOrMethodReference(Me, TypeCache.System_Windows_Forms_Application__Run))
                     mainCecil.Body.GetILProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ret)
                     mainClass.CecilType.Methods.Add(mainCecil)
                     lstMethods.Add(mainCecil)
                 End If
             End If
 
             'Set the entry point of the assembly
             If lstMethods.Count > 1 Then
                 Dim name As String
                 If mainClass IsNot Nothing Then name = mainClass.Name Else name = AssemblyBuilderCecil.Name.Name
                 Report.ShowMessageNoLocation(Messages.VBNC30738, name)
                 Return False
             ElseIf lstMethods.Count = 0 Then
                 If hasMainMethod Then
                     Dim name As String
                     If mainClass IsNot Nothing Then name = mainClass.Name Else name = AssemblyBuilderCecil.Name.Name
                     Report.ShowMessageNoLocation(Messages.VBNC30737, name)
                     Return False
                 Else
                     Dim name As String
                     If mainClass IsNot Nothing Then name = mainClass.Name Else name = AssemblyBuilderCecil.Name.Name
                     Report.ShowMessageNoLocation(Messages.VBNC30420, name)
                     Return False
                 End If
             Else
                 Dim entryMethod As Mono.Cecil.MethodDefinition = lstMethods(0)
                 If mainCecil Is Nothing Then
                     mainCecil = entryMethod
                 End If
                 Dim foundSTAThreadAttribute As Boolean = False
                 For i As Integer = 0 To mainCecil.CustomAttributes.Count - 1
                     If Helper.CompareMethod(mainCecil.CustomAttributes(0).Constructor, TypeCache.System_STAThreadAttribute__ctor) = False Then
                         foundSTAThreadAttribute = True
                         Exit For
                     End If
                 Next
                 If foundSTAThreadAttribute = False Then
                     mainCecil.CustomAttributes.Add(New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, TypeCache.System_STAThreadAttribute__ctor)))
                 End If
                 AssemblyBuilderCecil.EntryPoint = entryMethod
             End If
 
         Catch ex As Exception
             Throw
         End Try
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="303" nfragments="2">
<clone_fragment endline="6926" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.cs" hamdist="0" pcid="2853" startline="1250"><![CDATA[
 
 	static int[] global_yyStates;
 	static object[] global_yyVals;
 	protected bool use_global_stacks;
 	object[] yyVals;					// value stack
 	object yyVal;						// value stack ptr
 	int yyToken;						// current input
 	int yyTop;
 
   /** the generated parser.
       Maintains a state and a value stack, currently with fixed maximum size.
       @param yyLex scanner.
       @return result of the last reduction, if any.
       @throws yyException on irrecoverable parse error.
     */
   internal Object yyparse (yyParser.yyInput yyLex)
   {
     if (yyMax <= 0) yyMax = 256;		// initial size
     int yyState = 0;                   // state stack ptr
     int [] yyStates;               	// state stack 
     yyVal = null;
     yyToken = -1;
     int yyErrorFlag = 0;				// #tks to shift
 	if (use_global_stacks && global_yyStates != null) {
 		yyVals = global_yyVals;
 		yyStates = global_yyStates;
    } else {
 		yyVals = new object [yyMax];
 		yyStates = new int [yyMax];
 		if (use_global_stacks) {
 			global_yyVals = yyVals;
 			global_yyStates = yyStates;
 		}
 	}
 
     /*yyLoop
       if (yyTop >= yyStates.Length) {			// dynamically increase
         global
         global
       }
       yyStates[yyTop] = yyState;
       yyVals[yyTop] = yyVal;
       if (debug != null) debug.push(yyState, yyVal);
 
       /*yyDiscarded
         int yyN;
         if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
               debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
           }
           if ((yyN = yySindex[yyState]) != 0 && ((yyN += yyToken) >= 0)
               && (yyN < yyTable.Length) && (yyCheck[yyN] == yyToken)) {
             if (debug != null)
               debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
             yyState = yyTable[yyN];		// shift to yyN
             yyVal = yyLex.value();
             yyToken = -1;
             if (yyErrorFlag > 0) -- yyErrorFlag;
             goto continue_yyLoop;
           }
           if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
               && yyN < yyTable.Length && yyCheck[yyN] == yyToken)
             yyN = yyTable[yyN];			// reduce (yyN)
           else
             switch (yyErrorFlag) {
   
             case 0
               yyExpectingState = yyState;
               // yyerror(String.Format ("syntax error, got token `{0}'", yyname (yyToken)), yyExpecting(yyState));
               if (debug != null) debug.error("syntax error");
               if (yyToken == 0 /*eof*/ || yyToken == eof_token) throw new yyParser.yyUnexpectedEof ();
               goto case 1;
             case 1
               yyErrorFlag = 3;
               do {
                 if ((yyN = yySindex[yyStates[yyTop]]) != 0
                     && (yyN += Token.yyErrorCode) >= 0 && yyN < yyTable.Length
                     && yyCheck[yyN] == Token.yyErrorCode) {
                   if (debug != null)
                     debug.shift(yyStates[yyTop], yyTable[yyN], 3);
                   yyState = yyTable[yyN];
                   yyVal = yyLex.value();
                   goto continue_yyLoop;
                 }
                 if (debug != null) debug.pop(yyStates[yyTop]);
               } while (-- yyTop >= 0);
               if (debug != null) debug.reject();
               throw new yyParser.yyException("irrecoverable syntax error");
   
             case 3
               if (yyToken == 0) {
                 if (debug != null) debug.reject();
                 throw new yyParser.yyException("irrecoverable syntax error at end-of-file");
               }
               if (debug != null)
                 debug.discard(yyState, yyToken, yyname(yyToken),
   							yyLex.value());
               yyToken = -1;
               goto continue_yyDiscarded;		// leave stack alone
             }
         }
         int yyV = yyTop + 1-yyLen[yyN];
         if (debug != null)
           debug.reduce(yyState, yyStates[yyV-1], yyN, YYRules.getRule (yyN), yyLen[yyN]);
         yyVal = yyV > yyTop ? null 
         switch (yyN) {
 	| interactive_parsing  { Lexer.CompleteOnEOF = false; } opt_EOF
 	;
 
 opt_EOF
 	
 	  {
 		Lexer.check_incorrect_doc_comment ();
 	  }
 	| EOF
 	  {
 		Lexer.check_incorrect_doc_comment ();
 	  }
 	;
 
 outer_declarations
 	
 	| outer_declarations outer_declaration
 	;
  
 outer_declaration
 	
 	| using_directive 
 	| namespace_member_declaration
 	;
 
 extern_alias_directives
 	
 	| extern_alias_directives extern_alias_directive
 	;
 
 extern_alias_directive
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		string s = lt.Value;
 		if (s != "alias"){
 			syntax_error (lt.Location, "`alias' expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (lt.Location, "external alias");
 		} else {
 			lt = (Tokenizer.LocatedToken) $3; 
 			current_namespace.AddUsingExternalAlias (lt.Value, lt.Location, Report);
 		}
 	  }
 	| EXTERN_ALIAS error
 	  {
 	  	syntax_error (GetLocation ($1), "`alias' expected");   // TODO
 	  }
 	;
  
 using_directives
 	
 	| using_directives using_directive
 	;
 
 using_directive
 	
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	| using_namespace_directive
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	;
 
 using_alias_directive
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		current_namespace.AddUsingAlias (lt.Value, (MemberName) $4, GetLocation ($1));
 	  }
 	| USING error
 	 {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 
 using_namespace_directive
 	
 	  {
 		current_namespace.AddUsing ((MemberName) $2, GetLocation ($1));
 	  }
 	;
 
 //
 // Strictly speaking, namespaces don't have attributes but
 // we parse global attributes along with namespace declarations and then
 // detach them
 // 
 namespace_declaration
 	
 	  {
 		MemberName name = (MemberName) $3;
 
 		if ($1 != null) {
 			Report.Error(1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
 		}
 
 		current_namespace = new NamespaceEntry (module,
 			current_namespace, file, name.GetName ());
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  } 
 	  namespace_body opt_semicolon
 	  { 
 		current_namespace = current_namespace.Parent;
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
 	;
 
 qualified_identifier
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new MemberName (lt.Value, lt.Location);
 	  }
 	| qualified_identifier DOT IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberName ((MemberName) $1, lt.Value, lt.Location);		
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = new MemberName ("<invalid>", lexer.Location);
 	  }
 	;
 
 opt_semicolon
 	
 	| SEMICOLON
 	;
 
 opt_comma
 	
 	| COMMA
 	;
 
 namespace_name
 	
 	 {
 		MemberName name = (MemberName) $1;
 
 		if (name.TypeArguments != null)
 			syntax_error (lexer.Location, "namespace name expected");
 
 		$$ = name;
 	  }
 	;
 
 namespace_body
 	
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_extern_alias_directives
 	  opt_using_directives
 	  opt_namespace_member_declarations
 	  CLOSE_BRACE
 	;
 
 opt_using_directives
 	
 	| using_directives
 	;
 
 opt_extern_alias_directives
 	
 	| extern_alias_directives
 	;
 
 opt_namespace_member_declarations
 	
 	| namespace_member_declarations
 	;
 
 namespace_member_declarations
 	
 	| namespace_member_declarations namespace_member_declaration
 	;
 
 namespace_member_declaration
 	
 	  {
 		if ($1 != null) {
 			DeclSpace ds = (DeclSpace)$1;
 
 			if ((ds.ModFlags & (Modifiers.PRIVATE|Modifiers.PROTECTED)) != 0){
 				Report.Error (1527, ds.Location, 
 				"Namespace elements cannot be explicitly declared as private, protected or protected internal");
 			}
 		}
 		current_namespace.DeclarationFound = true;
 	  }
 	| namespace_declaration
 	  {
 		current_namespace.DeclarationFound = true;
 	  }
 	| error
 	 {
 		Error_SyntaxError (yyToken);
 	 }
 	;
 
 type_declaration
 	
 	| struct_declaration
 	| interface_declaration
 	| enum_declaration		
 	| delegate_declaration
 //
 // Enable this when we have handled all errors, because this acts as a generic fallback
 //
 //	| error {
 //		Console.WriteLine ("Token=" + yyToken);
 //		Report.Error (1518, GetLocation ($1), "Expected class, struct, interface, enum or delegate");
 //	  }
 	;
 
 //
 // Attributes 17.2
 //
 
 global_attributes
 	
 	  {
 		if ($1 != null) {
 			Attributes attrs = (Attributes)$1;
 			if (global_attrs_enabled) {
 				module.AddAttributes (attrs.Attrs, current_namespace);
 			} else {
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 			}
 		}
 		$$ = $1;
 	  }
 	;
 
 opt_attributes
 	
 	  {
 		global_attrs_enabled = false;
 		$$ = null;
       }
 	| attribute_sections
 	  { 
 		global_attrs_enabled = false;
 		$$ = $1;
 	  }
     ;
  
 
 attribute_sections
 	
 	  {
 		if (current_attr_target != String.Empty) {
 			var sect = (List<Attribute>) $1;
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect, current_namespace);
 					$$ = null;
 				} else {
 					$$ = new Attributes (sect);
 				}
 				if ($$ == null) {
 					if (RootContext.Documentation != null) {
 						Lexer.check_incorrect_doc_comment ();
 						Lexer.doc_state =
 							XmlCommentState.Allowed;
 					}
 				}
 			} else {
 				$$ = new Attributes (sect);
 			}		
 		}
 		else
 			$$ = null;
 		current_attr_target = null;
 	  }
 	| attribute_sections attribute_section
 	  {
 		if (current_attr_target != String.Empty) {
 			Attributes attrs = $1 as Attributes;
 			var sect = (List<Attribute>) $2;
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect);
 					$$ = null;
 				} else {
 					if (attrs == null)
 						attrs = new Attributes (sect);
 					else
 						attrs.AddAttributes (sect);			
 				}
 			} else {
 				if (attrs == null)
 					attrs = new Attributes (sect);
 				else
 					attrs.AddAttributes (sect);
 			}		
 			$$ = attrs;
 		}
 		else
 			$$ = null;
 		current_attr_target = null;
 	  }
 	;
 
 attribute_section
 	
 	  {
 		$$ = $3;
  	  }
 	| OPEN_BRACKET attribute_list opt_comma CLOSE_BRACKET
 	  {
 		$$ = $2;
 	  }
 	;
  
 attribute_target_specifier
 	
 	  {
 		current_attr_target = (string)$1;
 		$$ = $1;
 	  }
 	;
 
 attribute_target
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = CheckAttributeTarget (lt.Value, lt.Location);
 	  }
 	| EVENT  { $$ = "event"; }
 	| RETURN { $$ = "return"; }
 	| error
 	  {
 		string name = GetTokenName (yyToken);
 		$$ = CheckAttributeTarget (name, GetLocation ($1));
 	  }
 	;
 
 attribute_list
 	
 	  {
 		$$ = new List<Attribute> (4) { (Attribute) $1 };
 	  }
 	| attribute_list COMMA attribute
 	  {
 		var attrs = (List<Attribute>) $1;
 		attrs.Add ((Attribute) $3);
 
 		$$ = attrs;
 	  }
 	;
 
 attribute
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  opt_attribute_arguments
 	  {
 		--lexer.parsing_block;
 		MemberName mname = (MemberName) $1;
 		if (mname.IsGeneric) {
 			Report.Error (404, lexer.Location,
 				      "'<' unexpected
 		}
 
 		Arguments [] arguments = (Arguments []) $3;
 		ATypeNameExpression expr = mname.GetTypeExpression ();
 
 		if (current_attr_target == String.Empty)
 			$$ = null;
 		else if (global_attrs_enabled && (current_attr_target == "assembly" || current_attr_target == "module"))
 			// FIXME
 			$$ = new GlobalAttribute (current_namespace, current_attr_target,
 						  expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 		else
 			$$ = new Attribute (current_attr_target, expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 	  }
 	;
 
 attribute_name
 	
 	;
 
 opt_attribute_arguments
 	
 	| OPEN_PARENS attribute_arguments CLOSE_PARENS
 	  {
 		$$ = $2;
 	  }
 	;
 
 
 attribute_arguments
 	
 	| positional_or_named_argument
 	  {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) $1);
 		$$ = new Arguments [] { a, null };
 	  }
 	| named_attribute_argument
 	  {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) $1);  
 		$$ = new Arguments [] { null, a };
 	  }
     | attribute_arguments COMMA positional_or_named_argument
 	  {
 		Arguments[] o = (Arguments[]) $1;
 		if (o [1] != null) {
 			Report.Error (1016, ((Argument) $3).Expr.Location, "Named attribute arguments must appear after the positional arguments");
 			o [0] = new Arguments (4);
 		}
 		
 		Arguments args = ((Arguments) o [0]);
 		if (args.Count > 0 && !($3 is NamedArgument) && args [args.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 		
 		args.Add ((Argument) $3);
 	  }
     | attribute_arguments COMMA named_attribute_argument
 	  {
 		Arguments[] o = (Arguments[]) $1;
 		if (o [1] == null) {
 			o [1] = new Arguments (4);
 		}
 
 		((Arguments) o [1]).Add ((Argument) $3);
 	  }
     ;
 
 positional_or_named_argument
 	
 	  {
 	  	$$ = new Argument ((Expression) $1);
 	  }
 	| named_argument
 	;
 
 named_attribute_argument
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  expression
 	  {
 	  	--lexer.parsing_block;
 	  	var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new NamedArgument (lt.Value, lt.Location, (Expression) $4);	  
 	  }
 	;
 	
 named_argument
 	
 	  {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "named argument");
 			
 		// Avoid boxing in common case (no modifier)
 		var arg_mod = $3 == null ? Argument.AType.None 
 			
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new NamedArgument (lt.Value, lt.Location, (Expression) $4, arg_mod);
 	  }
 	;
 	
 opt_named_modifier
 	
 	| REF
 	  { 
 		$$ = Argument.AType.Ref;
 	  }
 	| OUT
 	  { 
 		$$ = Argument.AType.Out;
 	  }
 	;
 		  
 opt_class_member_declarations
 	
 	| class_member_declarations
 	;
 
 class_member_declarations
 	
 	| class_member_declarations 
 	  class_member_declaration
 	;
 
 class_member_declaration
 	
 	| field_declaration			// done
 	| method_declaration			// done
 	| property_declaration			// done
 	| event_declaration			// done
 	| indexer_declaration			// done
 	| operator_declaration			// done
 	| constructor_declaration		// done
 	| destructor_declaration		// done
 	| type_declaration
 	| error
 	  {
 		Report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
 			GetSymbolName (yyToken));
 		$$ = null;
 		lexer.parsing_generic_declaration = false;
 	  }
 	;
 
 struct_declaration
 	
 	  opt_modifiers
 	  opt_partial
 	  STRUCT
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  type_declaration_name
 	  { 
 		MemberName name = MakeName ((MemberName) $6);
 		push_current_class (new Struct (current_namespace, current_class, name, (Modifiers) $2, (Attributes) $1), $3);
 	  }
 	  opt_class_base
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) $9);
 
 		if (RootContext.Documentation != null)
 			current_container.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (current_class, mod_locations, GetLocation ($4));
 	  }
 	  struct_body
 	  {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_semicolon
 	  {
 		lbag.AppendToMember (current_class, GetLocation ($13));
 		$$ = pop_current_class ();
 	  }
 	| opt_attributes opt_modifiers opt_partial STRUCT error
 	  {
 		Error_SyntaxError (yyToken);
 	  }
 	;
 
 struct_body
 	
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_struct_member_declarations CLOSE_BRACE
 	  {
 		lbag.AppendToMember (current_class, GetLocation ($1), GetLocation ($4));
 	  }
 	;
 
 opt_struct_member_declarations
 	
 	| struct_member_declarations
 	;
 
 struct_member_declarations
 	
 	| struct_member_declarations struct_member_declaration
 	;
 
 struct_member_declaration
 	
 	| field_declaration
 	| method_declaration
 	| property_declaration
 	| event_declaration
 	| indexer_declaration
 	| operator_declaration
 	| constructor_declaration
 	| type_declaration
 
 	/*
 	 * This is only included so we can flag error 575
 	 * destructors only allowed on class types
 	 */
 	| destructor_declaration 
 	;
 	
 constant_declaration
 	
 	  opt_modifiers
 	  CONST type IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $5;
 		var mod = (Modifiers) $2;
 		current_field = new Const (current_class, (FullNamedExpression) $4, mod, new MemberName (lt.Value, lt.Location), (Attributes) $1);
 		current_container.AddConstant ((Const) current_field);
 		
 		if ((mod & Modifiers.STATIC) != 0) {
 			Report.Error (504, current_field.Location, "The constant `{0}' cannot be marked static", current_field.GetSignatureForError ());
 		}
 		
 		$$ = current_field;
 	  }
 	  constant_initializer opt_constant_declarators SEMICOLON
 	  {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		current_field.Initializer = (ConstInitializer) $7;
 		lbag.AddMember (current_field, mod_locations, GetLocation ($3), GetLocation ($9));
 		current_field = null;
 	  }
 	;
 	
 opt_constant_declarators
 	
 	| constant_declarators
 	;
 	
 constant_declarators
 	
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $1);
 	  }
 	| constant_declarators constant_declarator
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $2);
 	  }
 	;
 	
 constant_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) $3);
 	  	lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	;		
 
 constant_initializer
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  constant_initializer_expr
 	  {
 		--lexer.parsing_block;
 		$$ = new ConstInitializer (current_field, (Expression) $3, GetLocation ($1));
 	  }
 	| error
 	  {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 		$$ = null;
 	  }	  
 	;
 	
 constant_initializer_expr
 	
 	| array_initializer
 	;
 
 field_declaration
 	
 	  opt_modifiers
 	  member_type IDENTIFIER
 	  {
 	  	lexer.parsing_generic_declaration = false;
 
 		FullNamedExpression type = (FullNamedExpression) $3;
 		if (type.Type == TypeManager.void_type)
 			Report.Error (670, GetLocation ($3), "Fields cannot have void type");
 			
 		var lt = (Tokenizer.LocatedToken) $4;
 		current_field = new Field (current_class, type, (Modifiers) $2, new MemberName (lt.Value, lt.Location), (Attributes) $1);
 		current_container.AddField (current_field);
 		$$ = current_field;
 	  }
 	  opt_field_initializer
 	  opt_field_declarators
 	  SEMICOLON
 	  { 
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 			
 		lbag.AddMember (current_field, mod_locations, GetLocation ($8));
 		$$ = current_field;
 		current_field = null;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  FIXED simple_type IDENTIFIER
 	  { 
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($3), "fixed size buffers");
 
 		var lt = (Tokenizer.LocatedToken) $5;
 		current_field = new FixedField (current_class, (FullNamedExpression) $4, (Modifiers) $2,
 			new MemberName (lt.Value, lt.Location), (Attributes) $1);
 			
 		current_container.AddField (current_field);
 	  }
 	  fixed_field_size opt_fixed_field_declarators SEMICOLON
 	  {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 	    }
 
 		current_field.Initializer = (ConstInitializer) $7;	    
 		lbag.AddMember (current_field, mod_locations, GetLocation ($9));
 		$$ = current_field;
 	    current_field = null;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  FIXED simple_type error
 	  SEMICOLON
 	  {
 		Report.Error (1641, GetLocation ($5), "A fixed size buffer field must have the array size specifier after the field name");
 	  }
 	;
 	
 opt_field_initializer
 	
 	| ASSIGN
 	  {
 	  	++lexer.parsing_block;
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	start_block (GetLocation ($1));
 	  }
 	  variable_initializer
 	  {
 	  	--lexer.parsing_block;
 		current_field.Initializer = (Expression) $3;
 		end_block (lexer.Location);
 		current_local_parameters = null;
 	  }
 	;
 	
 opt_field_declarators
 	
 	| field_declarators
 	;
 	
 field_declarators
 	
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $1);
 	  }
 	| field_declarators field_declarator
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $2);
 	  }
 	;
 	
 field_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	| COMMA IDENTIFIER ASSIGN
 	  {
 		++lexer.parsing_block;
 	  }
 	  variable_initializer
 	  {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) $2;	  
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) $5);
 	  	lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	;	
 
 opt_fixed_field_declarators
 	
 	| fixed_field_declarators
 	;
 	
 fixed_field_declarators
 	
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $1);
 	  }
 	| fixed_field_declarators fixed_field_declarator
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $2);
 	  }
 	;
 	
 fixed_field_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;	  
 		$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) $3);
 		lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	;
 
 fixed_field_size
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  expression CLOSE_BRACKET
 	  {
 		--lexer.parsing_block;
 		$$ = new ConstInitializer (current_field, (Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	| OPEN_BRACKET error
 	  {
 		Report.Error (443, lexer.Location, "Value or constant expected");
 		$$ = null;
 	  }	  
 	;
 
 variable_initializer
 	
 	| array_initializer
 	| error
 	  {
 		// It has to be here for the parent to safely restore artificial block
 	  	Error_SyntaxError (yyToken);
 	  	$$ = null;
 	  }
 	;
 
 method_declaration
 	
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
 	  method_body
 	  {
 		Method method = (Method) $1;
 		method.Block = (ToplevelBlock) $3;
 		current_container.AddMethod (method);
 		
 		if (current_container.Kind == MemberKind.Interface && method.Block != null) {
 			Report.Error (531, method.Location, "`{0}'
 		}
 
 		current_local_parameters = null;
 
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	;
 
 method_header
 	
 	  opt_modifiers
 	  member_type
 	  method_declaration_name OPEN_PARENS
 	  {
 		valid_param_mod = ParameterModifierType.All;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 		MemberName name = (MemberName) $4;
 		current_local_parameters = (ParametersCompiled) $7;
 
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 						     (FullNamedExpression) $3, current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) $10);
 		} else if ($10 != null) {
 			Report.Error (80, GetLocation ($10),
 				"Constraints are not allowed on non-generic declarations");
 		}
 
 		Method method = new Method (current_class, generic, (FullNamedExpression) $3, (Modifiers) $2,
 				     name, current_local_parameters, (Attributes) $1);
 				     
 		if ($10 != null && ((method.ModFlags & Modifiers.OVERRIDE) != 0 || method.IsExplicitImpl)) {
 			Report.Error (460, method.Location,
 				"`{0}'
 				method.GetSignatureForError ());
 		}
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (method, mod_locations, GetLocation ($5), GetLocation ($8));
 		$$ = method;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  PARTIAL
 	  VOID method_declaration_name
 	  OPEN_PARENS
 	  {
 	  	valid_param_mod = ParameterModifierType.All;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS 
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 
 		MemberName name = (MemberName) $5;
 		current_local_parameters = (ParametersCompiled) $8;
 
 		if ($10 != null && name.TypeArguments == null)
 			Report.Error (80, lexer.Location,
 				      "Constraints are not allowed on non-generic declarations");
 
 		Method method;
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 				new TypeExpression (TypeManager.void_type, GetLocation ($4)),
 				current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) $11);
 		}
 
 		var modifiers = (Modifiers) $2;
 
 
 		const Modifiers invalid_partial_mod = Modifiers.AccessibilityMask | Modifiers.ABSTRACT | Modifiers.EXTERN |
 			Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.SEALED | Modifiers.VIRTUAL;
 
 		if ((modifiers & invalid_partial_mod) != 0) {
 			Report.Error (750, name.Location, "A partial method cannot define access modifier or " +
        			"any of abstract, extern, new, override, sealed, or virtual modifiers");
 			modifiers &= ~invalid_partial_mod;
 		}
 
 		if ((current_class.ModFlags & Modifiers.PARTIAL) == 0) {
 			Report.Error (751, name.Location, "A partial method must be declared within a " +
        			"partial class or partial struct");
 		}
 		
 		modifiers |= Modifiers.PARTIAL | Modifiers.PRIVATE;
 		
 		method = new Method (current_class, generic, new TypeExpression (TypeManager.void_type, GetLocation ($4)),
 				     modifiers, name, current_local_parameters, (Attributes) $1);
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		// TODO
 		StoreModifierLocation (Modifiers.PARTIAL, GetLocation ($3));
 		lbag.AddMember (method, mod_locations, GetLocation ($6), GetLocation ($9));
 		$$ = method;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  member_type
 	  modifiers method_declaration_name OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS
 	  {
 		MemberName name = (MemberName) $5;
 		Report.Error (1585, name.Location, 
 			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) $4));
 
 		Method method = new Method (current_class, null, (FullNamedExpression) $3,
 					    0, name, (ParametersCompiled) $7, (Attributes) $1);
 
 		current_local_parameters = (ParametersCompiled) $7;
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		$$ = method;
 	  }
 	;
 
 method_body
 	
 	| SEMICOLON		{ $$ = null; }
 	;
 
 opt_formal_parameter_list
 	
 	| formal_parameter_list
 	;
 	
 formal_parameter_list
 	
 	  {
 		var pars_list = (List<Parameter>) $1;
 	  	$$ = new ParametersCompiled (pars_list.ToArray ());
 	  } 
 	| fixed_parameters COMMA parameter_array
 	  {
 		var pars_list = (List<Parameter>) $1;
 		pars_list.Add ((Parameter) $3);
 
 		$$ = new ParametersCompiled (pars_list.ToArray ()); 
 	  }
 	| fixed_parameters COMMA arglist_modifier
 	  {
 		var pars_list = (List<Parameter>) $1;
 		pars_list.Add (new ArglistParameter (GetLocation ($3)));
 		$$ = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
 	| parameter_array COMMA error
 	  {
 		if ($1 != null)
 			Report.Error (231, ((Parameter) $1).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		$$ = new ParametersCompiled (new Parameter[] { (Parameter) $1 } );			
 	  }
 	| fixed_parameters COMMA parameter_array COMMA error
 	  {
 		if ($3 != null)
 			Report.Error (231, ((Parameter) $3).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) $1;
 		pars_list.Add (new ArglistParameter (GetLocation ($3)));
 
 		$$ = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
 	| arglist_modifier COMMA error
 	  {
 		Report.Error (257, GetLocation ($1), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		$$ = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation ($1)) }, true);
 	  }
 	| fixed_parameters COMMA ARGLIST COMMA error 
 	  {
 		Report.Error (257, GetLocation ($3), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) $1;
 		pars_list.Add (new ArglistParameter (GetLocation ($3)));
 
 		$$ = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
 	| parameter_array 
 	  {
 		$$ = new ParametersCompiled (new Parameter[] { (Parameter) $1 } );
 	  }
 	| arglist_modifier
 	  {
 		$$ = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation ($1)) }, true);
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
 	;
 
 fixed_parameters
 	
 	  {
 		parameters_bucket.Clear ();
 		Parameter p = (Parameter) $1;
 		parameters_bucket.Add (p);
 		
 		default_parameter_used = p.HasDefaultValue;
 		$$ = parameters_bucket;
 	  }
 	| fixed_parameters COMMA fixed_parameter
 	  {
 		var pars = (List<Parameter>) $1;
 		Parameter p = (Parameter) $3;
 		if (p != null) {
 			if (p.HasExtensionMethodModifier)
 				Report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
 			else if (!p.HasDefaultValue && default_parameter_used)
 				Report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");
 
 			default_parameter_used |= p.HasDefaultValue;
 			pars.Add (p);
 			
 			lbag.AddLocation (p, GetLocation ($2));
 		}
 		
 		$$ = $1;
 	  }
 	;
 
 fixed_parameter
 	
 	  opt_parameter_modifier
 	  parameter_type
 	  IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $4;
 		$$ = new Parameter ((FullNamedExpression) $3, lt.Value, (Parameter.Modifier) $2, (Attributes) $1, lt.Location);
 	  }
 	| opt_attributes
 	  opt_parameter_modifier
 	  parameter_type
 	  IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
 	  {
 		var lt = (Tokenizer.LocatedToken) $4;
 		Report.Error (1552, lt.Location, "Array type specifier, [], must appear before parameter name");
 		$$ = new Parameter ((FullNamedExpression) $3, lt.Value, (Parameter.Modifier) $2, (Attributes) $1, lt.Location);
 	  }
 	| opt_attributes
 	  opt_parameter_modifier
 	  parameter_type
 	  error
 	  {
 		Error_SyntaxError (yyToken);	  
 	  	Location l = GetLocation ($4);
 		$$ = new Parameter ((FullNamedExpression) $3, "NeedSomeGeneratorHere", (Parameter.Modifier) $2, (Attributes) $1, l);
 	  }
 	| opt_attributes
 	  opt_parameter_modifier
 	  parameter_type
 	  IDENTIFIER
 	  ASSIGN
 	  {
 	  	++lexer.parsing_block;
 	  }
 	  constant_expression
 	  {
 	  	--lexer.parsing_block;
 		if (RootContext.Version <= LanguageVersion.V_3) {
 			Report.FeatureIsNotAvailable (GetLocation ($5), "optional parameter");
 		}
 		
 		Parameter.Modifier mod = (Parameter.Modifier) $2;
 		if (mod != Parameter.Modifier.NONE) {
 			switch (mod) {
 			case Parameter.Modifier.REF
 			case Parameter.Modifier.OUT
 				Report.Error (1741, GetLocation ($2), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 				
 			case Parameter.Modifier.This
 				Report.Error (1743, GetLocation ($2), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 			default
 				throw new NotImplementedException (mod.ToString ());
 			}
 				
 			mod = Parameter.Modifier.NONE;
 		}
 		
 		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
 			Report.Error (1065, GetLocation ($5), "Optional parameter is not valid in this context");
 		
 		var lt = (Tokenizer.LocatedToken) $4;
 		$$ = new Parameter ((FullNamedExpression) $3, lt.Value, mod, (Attributes) $1, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($5));
 		
 		if ($7 != null)
 			((Parameter) $$).DefaultValue = new DefaultParameterValueExpression ((Expression) $7);
 	  }
 	;
 
 opt_parameter_modifier
 	
 	| parameter_modifiers
 	;
 
 parameter_modifiers
 	
 	  {
 		$$ = $1;
 	  }
 	| parameter_modifiers parameter_modifier
 	  {
 		Parameter.Modifier p2 = (Parameter.Modifier)$2;
   		Parameter.Modifier mod = (Parameter.Modifier)$1 | p2;
   		if (((Parameter.Modifier)$1 & p2) == p2) {
   			Error_DuplicateParameterModifier (lexer.Location, p2);
   		} else {
 	  		switch (mod & ~Parameter.Modifier.This) {
   				case Parameter.Modifier.REF
 					Report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
   					break;
    				case Parameter.Modifier.OUT
 					Report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
   					break;
   				default
  					Report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
  					break;
  			}
   		}
   		$$ = mod;
 	  }
 	;
 
 parameter_modifier
 	
 	  {
 	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
 	  		Error_ParameterModifierNotValid ("ref", GetLocation ($1));
 	  		
 	  	$$ = Parameter.Modifier.REF;
 	  }
 	| OUT
 	  {
 	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
 	  		Error_ParameterModifierNotValid ("out", GetLocation ($1));
 	  
 	  	$$ = Parameter.Modifier.OUT;
 	  }
 	| THIS
 	  {
 		if ((valid_param_mod & ParameterModifierType.This) == 0)
 	  		Error_ParameterModifierNotValid ("this", GetLocation ($1));
 
 	  	if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation ($1), "extension methods");
 	  			
 		$$ = Parameter.Modifier.This;
 	  }
 	;
 
 parameter_array
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $4;
 		$$ = new ParamsParameter ((FullNamedExpression) $3, lt.Value, (Attributes) $1, lt.Location);
 	  }
 	| opt_attributes params_modifier type IDENTIFIER ASSIGN constant_expression
 	  {
 		Report.Error (1751, GetLocation ($2), "Cannot specify a default value for a parameter array");
 		
 		var lt = (Tokenizer.LocatedToken) $4;
 		$$ = new ParamsParameter ((FullNamedExpression) $3, lt.Value, (Attributes) $1, lt.Location);		
 	  }
 	| opt_attributes params_modifier type error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 	
 params_modifier
 	
 	  {
 		if ((valid_param_mod & ParameterModifierType.Params) == 0)
 			Report.Error (1670, (GetLocation ($1)), "The `params' modifier is not allowed in current context");
 	  }
 	| PARAMS parameter_modifier
 	  {
 		Parameter.Modifier mod = (Parameter.Modifier)$2;
 		if ((mod & Parameter.Modifier.This) != 0) {
 			Report.Error (1104, GetLocation ($1), "The parameter modifiers `this' and `params' cannot be used altogether");
 		} else {
 			Report.Error (1611, GetLocation ($1), "The params parameter cannot be declared as ref or out");
 		}	  
 	  }
 	| PARAMS params_modifier
 	  {
 		Error_DuplicateParameterModifier (GetLocation ($1), Parameter.Modifier.PARAMS);
 	  }
 	;
 	
 arglist_modifier
 	
 	  {
 	  	if ((valid_param_mod & ParameterModifierType.Arglist) == 0)
 	  		Report.Error (1669, GetLocation ($1), "__arglist is not valid in this context");
 	  }
 	;
 	
 property_declaration
 	
 	  opt_modifiers
 	  member_type
 	  member_declaration_name
 	  {
 		if (RootContext.Documentation != null)
 			tmpComment = Lexer.consume_doc_comment ();
 	  }
 	  OPEN_BRACE
 	  {
 		current_property = new Property (current_class, (FullNamedExpression) $3, (Modifiers) $2,
 			(MemberName) $4, (Attributes) $1);
 			
 		if (current_property.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (547, GetLocation ($3), "`{0}'
 			
 		current_container.AddProperty ((Property)current_property);
 		lbag.AddMember (current_property, mod_locations, GetLocation ($6));
 		
 		lexer.PropertyParsing = true;
 	  }
 	  accessor_declarations 
 	  {
 		lexer.PropertyParsing = false;
 		
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();				
 	  }
 	  CLOSE_BRACE
 	  {
 		lbag.AppendToMember (current_property, GetLocation ($10));
 		current_property = null;
 	  }
 	;
 
 
 indexer_declaration
 	
 	  member_type indexer_declaration_name OPEN_BRACKET
 	  {
 	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_BRACKET OPEN_BRACE
 	  {
 		valid_param_mod = 0;
 	  
 		Indexer indexer = new Indexer (current_class, (FullNamedExpression) $3,
 			(MemberName)$4, (Modifiers) $2, (ParametersCompiled) $7, (Attributes) $1);
 			
 		current_property = indexer;
 
   		current_container.AddIndexer (indexer);
 		lbag.AddMember (current_property, mod_locations, GetLocation ($5), GetLocation ($8), GetLocation ($9));
   		
 		if (indexer.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (620, GetLocation ($3), "`{0}'
 
 		if (indexer.Parameters.IsEmpty) {
 			Report.Error (1551, GetLocation ($5), "Indexers must have at least one parameter");
 		}
 
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		lexer.PropertyParsing = true;
 	  }
 	  accessor_declarations 
 	  {
 		  lexer.PropertyParsing = false;
 	  }
 	  CLOSE_BRACE
 	  { 
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();
 			
 		lbag.AppendToMember (current_property, GetLocation ($12));
 		current_property = null;		
 	  }
 	;
 
 
 accessor_declarations
 	
 	| get_accessor_declaration accessor_declarations
 	| set_accessor_declaration
 	| set_accessor_declaration accessor_declarations
 	| error
 	  {
 	  	if (yyToken == Token.CLOSE_BRACE) {
 	  		Report.Error (548, lexer.Location, "`{0}'
 		} else {
 			if (yyToken == Token.SEMICOLON)
 				Report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
 			else
 				Report.Error (1014, GetLocation ($1), "A get or set accessor expected");
 		}
 	  }
 	;
 
 get_accessor_declaration
 	
 	  {
 		if ($2 != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation ($2), "access modifiers on properties");
 		}
 	  
 		if (current_property.Get != null) {
 			Report.Error (1007, GetLocation ($3), "Property accessor already defined");
 		}
 		
 		if (current_property is Indexer) {
 			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) $2, ((Indexer)current_property).ParameterInfo.Clone (),
 				(Attributes) $1, GetLocation ($3));
 		} else {
 			current_property.Get = new Property.GetMethod (current_property,
 				(Modifiers) $2, (Attributes) $1, GetLocation ($3));
 		}	
 	  
 		current_local_parameters = current_property.Get.ParameterInfo;	  
 		lbag.AddMember (current_property.Get, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
 	  accessor_body
 	  {
 	  	if ($5 != null) {
 	  		current_property.Get.Block = (ToplevelBlock) $5;			
 	  	
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Get.Block.StartLocation,
 					"`{0}'
 			}		
 		}
 	  
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null)
 			if (Lexer.doc_state == XmlCommentState.Error)
 				Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
 	;
 
 set_accessor_declaration
 	
 	  {
 		if ($2 != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation ($2), "access modifiers on properties");
 		}
 		
 		if (current_property.Set != null) {
 			Report.Error (1007, GetLocation ($3), "Property accessor already defined");
 		}
 	  
 		if (current_property is Indexer) {
 			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) $2,
 				ParametersCompiled.MergeGenerated (compiler,
 				((Indexer)current_property).ParameterInfo, true, new Parameter (
 					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation ($3)),
 					null),
 				(Attributes) $1, GetLocation ($3));
 		} else {
 			current_property.Set = new Property.SetMethod (current_property, (Modifiers) $2, 
 				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation ($3)),
 				(Attributes) $1, GetLocation ($3));
 		}
 		
 		current_local_parameters = current_property.Set.ParameterInfo;	
 		lbag.AddMember (current_property.Set, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
 	  accessor_body
 	  {
 		if ($5 != null) {		
 			current_property.Set.Block = (ToplevelBlock) $5;
 		
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Set.Block.StartLocation,
 					"`{0}'
 			}
 		}
 		
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null
 			&& Lexer.doc_state == XmlCommentState.Error)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
 	;
 
 accessor_body
 	
 	| SEMICOLON
 	  {
 		// TODO
 	  	$$ = null;
 	  }
 	| error
 	  {
 	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
 	  	$$ = null;
 	  }
 	;
 
 interface_declaration
 	
 	  opt_modifiers
 	  opt_partial
 	  INTERFACE
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  type_declaration_name
 	  {
 		MemberName name = MakeName ((MemberName) $6);
 		push_current_class (new Interface (current_namespace, current_class, name, (Modifiers) $2, (Attributes) $1), $3);
 		lbag.AddMember (current_class, mod_locations, GetLocation ($4));		
 	  }
 	  opt_class_base
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) $9);
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
 	  OPEN_BRACE opt_interface_member_declarations CLOSE_BRACE
 	  {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_semicolon 
 	  {
 	    lbag.AppendToMember (current_class, GetLocation ($11), GetLocation ($13));
 		$$ = pop_current_class ();
 	  }
 	| opt_attributes opt_modifiers opt_partial INTERFACE error
 	  {
 		Error_SyntaxError (yyToken);	  
 	  }
 	;
 
 opt_interface_member_declarations
 	
 	| interface_member_declarations
 	;
 
 interface_member_declarations
 	
 	| interface_member_declarations interface_member_declaration
 	;
 
 interface_member_declaration
 	
 	  {
 		Report.Error (525, GetLocation ($1), "Interfaces cannot contain fields or constants");
 	  }
 	| field_declaration
 	  {
 		Report.Error (525, GetLocation ($1), "Interfaces cannot contain fields or constants");
 	  }
 	| method_declaration
 	| property_declaration
 	| event_declaration
 	| indexer_declaration
 	| operator_declaration
 	  {
 	  	Report.Error (567, GetLocation ($1), "Interfaces cannot contain operators");
 	  }
 	| constructor_declaration
 	  {
 	  	Report.Error (526, GetLocation ($1), "Interfaces cannot contain contructors");
 	  }
 	| type_declaration
 	  {
 	  	Report.Error (524, GetLocation ($1), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
 	  }
 	;
 
 operator_declaration
 	
 	  {
 	  }
 	  operator_body
 	  {
 		OperatorDeclaration decl = (OperatorDeclaration) $3;
 		if (decl != null) {
 			Operator op = new Operator (
 				current_class, decl.optype, decl.ret_type, (Modifiers) $2, 
 				current_local_parameters,
 				(ToplevelBlock) $5, (Attributes) $1, decl.location);
 
 			if (RootContext.Documentation != null) {
 				op.DocComment = tmpComment;
 				Lexer.doc_state = XmlCommentState.Allowed;
 			}
 
 			// Note again, checking is done in semantic analysis
 			current_container.AddOperator (op);
 
 			lbag.AddMember (op, mod_locations, lbag.GetLocations (decl));
 		}
 		
 		current_local_parameters = null;
 	  }
 	;
 
 operator_body 
 	
 	| SEMICOLON { $$ = null; }
 	; 
 
 operator_type
 	
 	| VOID
 	  {
 		Report.Error (590, GetLocation ($1), "User-defined operators cannot return void");
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }
 	;
 
 operator_declarator
 	
 	  {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation ($2);
 		Operator.OpType op = (Operator.OpType) $3;
 		current_local_parameters = (ParametersCompiled)$6;
 		
 		int p_count = current_local_parameters.Count;
 		if (p_count == 1) {
 			if (op == Operator.OpType.Addition)
 				op = Operator.OpType.UnaryPlus;
 			else if (op == Operator.OpType.Subtraction)
 				op = Operator.OpType.UnaryNegation;
 		}
 		
 		if (IsUnaryOperator (op)) {
 			if (p_count == 2) {
 				Report.Error (1020, loc, "Overloadable binary operator expected");
 			} else if (p_count != 1) {
 				Report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
 					Operator.GetName (op));
 			}
 		} else {
 			if (p_count > 2) {
 				Report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
 					Operator.GetName (op));
 			} else if (p_count != 2) {
 				Report.Error (1019, loc, "Overloadable unary operator expected");
 			}
 		}
 		
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		$$ = new OperatorDeclaration (op, (FullNamedExpression) $1, loc);
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($3), GetLocation ($4), GetLocation ($7));
 	  }
 	| conversion_operator_declarator
 	;
 
 overloadable_operator
 // Unary operators
 	
         | TILDE  { $$ = Operator.OpType.OnesComplement; }  
         | OP_INC { $$ = Operator.OpType.Increment; }
         | OP_DEC { $$ = Operator.OpType.Decrement; }
         | TRUE   { $$ = Operator.OpType.True; }
         | FALSE  { $$ = Operator.OpType.False; }
 // Unary and binary
         | PLUS { $$ = Operator.OpType.Addition; }
         | MINUS { $$ = Operator.OpType.Subtraction; }
 // Binary
         | STAR { $$ = Operator.OpType.Multiply; }
         | DIV {  $$ = Operator.OpType.Division; }
         | PERCENT { $$ = Operator.OpType.Modulus; }
         | BITWISE_AND { $$ = Operator.OpType.BitwiseAnd; }
         | BITWISE_OR { $$ = Operator.OpType.BitwiseOr; }
         | CARRET { $$ = Operator.OpType.ExclusiveOr; }
         | OP_SHIFT_LEFT { $$ = Operator.OpType.LeftShift; }
         | OP_SHIFT_RIGHT { $$ = Operator.OpType.RightShift; }
         | OP_EQ { $$ = Operator.OpType.Equality; }
         | OP_NE { $$ = Operator.OpType.Inequality; }
         | OP_GT { $$ = Operator.OpType.GreaterThan; }
         | OP_LT { $$ = Operator.OpType.LessThan; }
         | OP_GE { $$ = Operator.OpType.GreaterThanOrEqual; }
         | OP_LE { $$ = Operator.OpType.LessThanOrEqual; }
 	;
 
 conversion_operator_declarator
 	
 	  {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation ($2);
 		current_local_parameters = (ParametersCompiled)$6;  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		$$ = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) $3, loc);
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($2), GetLocation ($4), GetLocation ($7));
 	  }
 	| EXPLICIT OPERATOR type OPEN_PARENS
 	  {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 		
 		Location loc = GetLocation ($2);
 		current_local_parameters = (ParametersCompiled)$6;  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		$$ = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) $3, loc);
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($2), GetLocation ($4), GetLocation ($7));
 	  }
 	| IMPLICIT error 
 	  {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 		$$ = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation ($1));
 	  }
 	| EXPLICIT error 
 	  {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	$$ = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation ($1));
 	  }
 	;
 
 constructor_declaration
 	
 	  constructor_body
 	  { 
 		Constructor c = (Constructor) $1;
 		c.Block = (ToplevelBlock) $2;
 		
 		if (RootContext.Documentation != null)
 			c.DocComment = ConsumeStoredComment ();
 
 		current_container.AddConstructor (c);
 
 		current_local_parameters = null;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	;
 
 constructor_declarator
 	
 	  opt_modifiers
 	  IDENTIFIER
 	  {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		valid_param_mod = ParameterModifierType.All;
 	  }
 	  OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 		current_local_parameters = (ParametersCompiled) $6;  
 		
 		//
 		// start block here, so possible anonymous methods inside
 		// constructor initializer can get correct parent block
 		//
 	  	start_block (lexer.Location);
 	  }
 	  opt_constructor_initializer
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		var mods = (Modifiers) $2;
 		ConstructorInitializer ci = (ConstructorInitializer) $9;
 
 		Constructor c = new Constructor (current_class, lt.Value, mods,
 			(Attributes) $1, current_local_parameters, ci, lt.Location);
 		
 		if (lt.Value != current_container.MemberName.Name) {
 			Report.Error (1520, c.Location, "Class, struct, or interface method must have a return type");
 		} else if ((mods & Modifiers.STATIC) != 0) {
 			if ((mods & Modifiers.AccessibilityMask) != 0){
 				Report.Error (515, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			}
 			if (ci != null) {
 				Report.Error (514, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			
 			}
 		}
 		
 		lbag.AddMember (c, mod_locations, GetLocation ($5), GetLocation ($7));
 		$$ = c;
 	  }
 	;
 
 constructor_body
 	
 	| SEMICOLON 		{ current_block = null; $$ = null; }
 	;
 
 opt_constructor_initializer
 	
 	| constructor_initializer
 	;
 
 constructor_initializer
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  opt_argument_list CLOSE_PARENS
 	  {
 	  	--lexer.parsing_block;
 		$$ = new ConstructorBaseInitializer ((Arguments) $5, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3), GetLocation ($6));
 	  }
 	| COLON THIS OPEN_PARENS
 	  {
 		++lexer.parsing_block;
 	  }
 	  opt_argument_list CLOSE_PARENS
 	  {
 	  	--lexer.parsing_block;
 		$$ = new ConstructorThisInitializer ((Arguments) $5, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3), GetLocation ($6));
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 
 destructor_declaration
 	
 	  {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 		
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
 	  IDENTIFIER OPEN_PARENS CLOSE_PARENS method_body
 	  {
 		var lt = (Tokenizer.LocatedToken) $5;
 		if (lt.Value != current_container.MemberName.Name){
 			Report.Error (574, lt.Location, "Name of destructor must match name of class");
 		} else if (current_container.Kind != MemberKind.Class){
 			Report.Error (575, lt.Location, "Only class types can contain destructor");
 		}
 		
 		Destructor d = new Destructor (current_class, (Modifiers) $2,
 			ParametersCompiled.EmptyReadOnlyParameters, (Attributes) $1, lt.Location);
 		if (RootContext.Documentation != null)
 			d.DocComment = ConsumeStoredComment ();
 		  
 		d.Block = (ToplevelBlock) $8;
 		current_container.AddMethod (d);
 		lbag.AddMember (d, mod_locations, GetLocation ($3), GetLocation ($6), GetLocation ($7));
 
 		current_local_parameters = null;
 	  }
 	;
 
 event_declaration
 	
 	  opt_modifiers
 	  EVENT type member_declaration_name
 	  {
 		current_event_field = new EventField (current_class, (FullNamedExpression) $4, (Modifiers) $2, (MemberName) $5, (Attributes) $1);
 		current_container.AddEvent (current_event_field);
 		
 		if (current_event_field.MemberName.Left != null) {
 			Report.Error (71, current_event_field.Location, "`{0}'
 			current_event_field.GetSignatureForError ());
 		}
 		
 		$$ = current_event_field;
 	  }
 	  opt_event_initializer
 	  opt_event_declarators
 	  SEMICOLON
 	  {
 		if (RootContext.Documentation != null) {
 			current_event_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AddMember (current_event_field, mod_locations, GetLocation ($3), GetLocation ($9));
 		current_event_field = null;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  EVENT type member_declaration_name
 	  OPEN_BRACE
 	  {
 		current_event = new EventProperty (current_class, (FullNamedExpression) $4, (Modifiers) $2, (MemberName) $5, (Attributes) $1);
 		current_container.AddEvent (current_event);
 		lbag.AddMember (current_event, mod_locations, GetLocation ($3), GetLocation ($6));
 		
 		lexer.EventParsing = true;
 	  }
 	  event_accessor_declarations
 	  {
 		if (current_container.Kind == MemberKind.Interface)
 			Report.Error (69, GetLocation ($6), "Event in interface cannot have add or remove accessors");
 	  
 		lexer.EventParsing = false;
 	  }
 	  CLOSE_BRACE
 	  {
 		if (RootContext.Documentation != null) {
 			current_event.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AppendToMember (current_event, GetLocation ($9));
 	  	current_event = null;	
 		current_local_parameters = null;
 	  }
 	;
 	
 opt_event_initializer
 	
 	| ASSIGN
 	  {
 	  	++lexer.parsing_block;
 	  }
 	  event_variable_initializer
 	  {
 	  	--lexer.parsing_block;
 		current_event_field.Initializer = (Expression) $3;
 	  }
 	;
 	
 opt_event_declarators
 	
 	| event_declarators
 	;
 	
 event_declarators
 	
 	  {
 		current_event_field.AddDeclarator ((FieldDeclarator) $1);
 	  }
 	| event_declarators event_declarator
 	  {
 		current_event_field.AddDeclarator ((FieldDeclarator) $2);
 	  }
 	;
 	
 event_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	| COMMA IDENTIFIER ASSIGN
 	  {
 		++lexer.parsing_block;
 	  }
 	  event_variable_initializer
 	  {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) $2;	  
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) $5);
 	  	lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	;
 	
 event_variable_initializer
 	
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (68, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 		}
 		
 	  	if ((current_event_field.ModFlags & Modifiers.ABSTRACT) != 0) {
 			Report.Error (74, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 	  	}		
 	  }
 	  variable_initializer
 	  {
 		$$ = $2;
 	  }
 	;
 	
 event_accessor_declarations
 	
 	| remove_accessor_declaration add_accessor_declaration
 	| add_accessor_declaration
 	  {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  } 
 	| remove_accessor_declaration
 	  {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }	
 	| error
 	  { 
 		Report.Error (1055, GetLocation ($1), "An add or remove accessor expected");
 		$$ = null;
 	  }
 	;
 
 add_accessor_declaration
 	
 	  {
 	  	if ($2 != ModifierNone) {
 			Report.Error (1609, GetLocation ($2), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Add = new EventProperty.AddDelegateMethod (current_event, (Attributes) $1, GetLocation ($3));
 		current_local_parameters = current_event.Add.ParameterInfo;
 		
 		lbag.AddMember (current_event.Add, mod_locations);
 		lexer.EventParsing = false;		
 	  }
 	  event_accessor_block
 	  {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Add.Block = (ToplevelBlock) $5;
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Add.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
 	;
 	
 remove_accessor_declaration
 	
 	  {
 	  	if ($2 != ModifierNone) {
 			Report.Error (1609, GetLocation ($2), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Remove = new EventProperty.RemoveDelegateMethod (current_event, (Attributes) $1, GetLocation ($3));
 		current_local_parameters = current_event.Remove.ParameterInfo;
 
 		lbag.AddMember (current_event.Remove, mod_locations);
 		lexer.EventParsing = false;		
 	  }
 	  event_accessor_block
 	  {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Remove.Block = (ToplevelBlock) $5;
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Remove.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
 	;
 
 event_accessor_block
 	
 	  {
 		Report.Error (73, lexer.Location, "An add or remove accessor must have a body");
 		$$ = null;
 	  }
 	| block;
 	;
 
 enum_declaration
 	
 	  opt_modifiers
 	  ENUM type_declaration_name
 	  opt_enum_base
 	  {
 		if (RootContext.Documentation != null)
 			enumTypeComment = Lexer.consume_doc_comment ();
 	  }
 	  OPEN_BRACE
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 
 		MemberName name = (MemberName) $4;
 		if (name.IsGeneric) {
 			Report.Error (1675, name.Location, "Enums cannot have type parameters");
 		}
 		
 		push_current_class (new Enum (current_namespace, current_class, (TypeExpression) $5, (Modifiers) $2, MakeName (name), (Attributes) $1), null);
 	  }
 	  opt_enum_member_declarations
 	  {
 	  	// here will be evaluated after CLOSE_BLACE is consumed.
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  CLOSE_BRACE opt_semicolon
 	  {
 		if (RootContext.Documentation != null)
 			current_class.DocComment = enumTypeComment;
 			
 		--lexer.parsing_declaration;
 
 //			if (RootContext.Documentation != null)
 //				em.DocComment = ev.DocComment;
 
 		lbag.AddMember (current_class, mod_locations, GetLocation ($3), GetLocation ($7), GetLocation ($11));
 		$$ = pop_current_class ();
 	  }
 	;
 
 opt_enum_base
 	
 	| COLON type
 	 {
 	 	var te = $2 as TypeExpression;
 		if (te == null ||
 			(te.Type != TypeManager.int32_type && te.Type != TypeManager.uint32_type &&
 			te.Type != TypeManager.int64_type && te.Type != TypeManager.uint64_type &&
 			te.Type != TypeManager.short_type && te.Type != TypeManager.ushort_type &&
 			te.Type != TypeManager.byte_type && te.Type != TypeManager.sbyte_type)) {
 			Enum.Error_1008 (GetLocation ($2), Report);
 			$$ = null;
 		} else {
 			$$ = $2;
 		}
 	 }
 	| COLON error
 	 {
 	 	Error_TypeExpected (GetLocation ($1));
 		$$ = null;
 	 }
 	;
 
 opt_enum_member_declarations
 	
 	| enum_member_declarations
 	| enum_member_declarations COMMA
 	  {
 	  	lbag.AddLocation ($1, GetLocation ($2));
 	  }
 	;
 
 enum_member_declarations
 	
 	| enum_member_declarations COMMA enum_member_declaration
 	  {
 	  	lbag.AddLocation ($1, GetLocation ($2));
 	  	$$ = $3;
 	  }
 	;
 
 enum_member_declaration
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) $1);
 	  	((Enum) current_class).AddEnumMember (em);
 
 		if (RootContext.Documentation != null) {
 			em.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		$$ = em;
 	  }
 	| opt_attributes IDENTIFIER
 	  {
 	  	++lexer.parsing_block;
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 	  }
 	  ASSIGN constant_expression
 	  { 
 		--lexer.parsing_block;
 		
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) $1);
 	  	em.Initializer = new ConstInitializer (em, (Expression) $5, GetLocation ($4));
 	  	((Enum) current_class).AddEnumMember (em);
 		
 		if (RootContext.Documentation != null)
 			em.DocComment = ConsumeStoredComment ();
 
 		$$ = em;
 	  }
 	;
 
 delegate_declaration
 	
 	  opt_modifiers
 	  DELEGATE
 	  member_type type_declaration_name
 	  OPEN_PARENS
 	  {
 		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out | ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 
 		MemberName name = MakeName ((MemberName) $5);
 		ParametersCompiled p = (ParametersCompiled) $8;
 
 		Delegate del = new Delegate (current_namespace, current_class, (FullNamedExpression) $4,
 					     (Modifiers) $2, name, p, (Attributes) $1);
 
 		if (RootContext.Documentation != null) {
 			del.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		current_container.AddDelegate (del);
 		current_delegate = del;
 		lexer.ConstraintsParsing = true;
 	  }
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 	  }
 	  SEMICOLON
 	  {
 		current_delegate.SetParameterInfo ((List<Constraints>) $11);
 		lbag.AddMember (current_delegate, mod_locations, GetLocation ($3), GetLocation ($6), GetLocation ($9), GetLocation ($13));
 
 		$$ = current_delegate;
 
 		current_delegate = null;
 	  }
 	;
 
 opt_nullable
 	
 	| INTERR_NULLABLE
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "nullable types");
 	  
 	  	$$ = ComposedTypeSpecifier.CreateNullable (GetLocation ($1));
 	  }
 	;
 
 namespace_or_type_name
 	
 	| qualified_alias_member IDENTIFIER opt_type_argument_list
 	  {
 		var lt1 = (Tokenizer.LocatedToken) $1;
 		var lt2 = (Tokenizer.LocatedToken) $2;
 		
 		$$ = new MemberName (lt1.Value, lt2.Value, (TypeArguments) $3, lt1.Location);
 	  }
 	;
 
 member_name
 	
 	| namespace_or_type_name DOT IDENTIFIER opt_type_argument_list
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberName ((MemberName) $1, lt.Value, (TypeArguments) $4, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($2));		
 	  }
 	;
 
 type_name
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new MemberName (lt.Value, (TypeArguments)$2, lt.Location);	  
 	  }
 	;
 	
 //
 // Generics arguments  (any type, without attributes)
 //
 opt_type_argument_list
 	
 	| OP_GENERICS_LT type_arguments OP_GENERICS_GT
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "generics");	  
 	  
 		$$ = $2;
 	  }
 	| OP_GENERICS_LT error
 	  {
 		Error_TypeExpected (lexer.Location);
 		$$ = new TypeArguments ();
 	  }
 	;
 
 type_arguments
 	
 	  {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression) $1);
 		$$ = type_args;
 	  }
 	| type_arguments COMMA type
 	  {
 		TypeArguments type_args = (TypeArguments) $1;
 		type_args.Add ((FullNamedExpression) $3);
 		$$ = type_args;
 	  }	  
 	;
 
 //
 // Generics parameters (identifiers only, with attributes), used in type or method declarations
 //
 type_declaration_name
 	
 	  {
 		lexer.parsing_generic_declaration = true;
 	  }
 	  opt_type_parameter_list
 	  {
 		lexer.parsing_generic_declaration = false;
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new MemberName (lt.Value, (TypeArguments)$3, lt.Location);
 	  }
 	;
 
 member_declaration_name
 	
 	  {
 	  	MemberName mn = (MemberName)$1;
 	  	if (mn.TypeArguments != null)
 	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
 	  			mn.GetSignatureForError ()));
 	  }
 	;
 
 method_declaration_name
 	
 	| explicit_interface IDENTIFIER opt_type_parameter_list
 	  {
 		lexer.parsing_generic_declaration = false;	  
 		var lt = (Tokenizer.LocatedToken) $2;
 		$$ = new MemberName ((MemberName) $1, lt.Value, (TypeArguments) $3, lt.Location);
 	  }
 	;
 	
 indexer_declaration_name
 	
 	  {
 		lexer.parsing_generic_declaration = false;	  
 		$$ = new MemberName (TypeContainer.DefaultIndexerName, GetLocation ($1));
 	  }
 	| explicit_interface THIS
 	  {
 		lexer.parsing_generic_declaration = false;
 		$$ = new MemberName ((MemberName) $1, TypeContainer.DefaultIndexerName, null, GetLocation ($1));
 	  }
 	;
 
 explicit_interface
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new MemberName (lt.Value, (TypeArguments) $2, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($3));
 	  }
 	| qualified_alias_member IDENTIFIER opt_type_argument_list DOT
 	  {
 		var lt1 = (Tokenizer.LocatedToken) $1;
 		var lt2 = (Tokenizer.LocatedToken) $2;
 		
 		$$ = new MemberName (lt1.Value, lt2.Value, (TypeArguments) $3, lt1.Location);
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	| explicit_interface IDENTIFIER opt_type_argument_list DOT
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		$$ = new MemberName ((MemberName) $1, lt.Value, (TypeArguments) $3, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	;
 	
 opt_type_parameter_list
 	
 	| OP_GENERICS_LT_DECL type_parameters OP_GENERICS_GT
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "generics");
 	  
 		$$ = $2;
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	;
 
 type_parameters
 	
 	  {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression)$1);
 		$$ = type_args;
 	  }
 	| type_parameters COMMA type_parameter
 	  {
 		TypeArguments type_args = (TypeArguments) $1;
 		type_args.Add ((FullNamedExpression)$3);
 		$$ = type_args;
 		lbag.AddLocation ($3, GetLocation ($3));
 	  }	  
 	;
 
 type_parameter
 	
 	  {
 		var lt = (Tokenizer.LocatedToken)$3;
 		$$ = new TypeParameterName (lt.Value, (Attributes)$1, (Variance) $2, lt.Location);
   	  }
   	| error
   	  {
   	  	if (GetTokenName (yyToken) == "type")
 			Report.Error (81, GetLocation ($1), "Type parameter declaration must be an identifier not a type");
 		else
 			Error_SyntaxError (yyToken);
 			
   	  	$$ = new TypeParameterName ("", null, lexer.Location);
   	  }
  	;
 
 //
 // All types where void is allowed
 //
 type_and_void
 	
 	| VOID
 	  {
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }
 	;
 	
 member_type
 	
 	  {
 		lexer.parsing_generic_declaration = true;
 	  }
 	;
 	
 //
 // A type which does not allow `void' to be used
 //
 type
 	
 	| VOID
 	  {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation ($1), Report);
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }	
 	;
 	
 simple_type
 	
 	| VOID
 	  {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation ($1), Report);
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }	
 	;
 	
 parameter_type
 	
 	| VOID
 	  {
 	  	Report.Error (1536, GetLocation ($1), "Invalid parameter type `void'");
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }	
 	;
 
 type_expression_or_array
 	
 	| type_expression rank_specifiers
 	  {
 		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	;
 	
 type_expression
 	
 	  {
 		MemberName name = (MemberName) $1;
 
 		if ($2 != null) {
 			$$ = new ComposedCast (name.GetTypeExpression (), (ComposedTypeSpecifier) $2);
 		} else {
 			if (name.Left == null && name.Name == "var")
 				$$ = new VarExpr (name.Location);
 			else
 				$$ = name.GetTypeExpression ();
 		}
 	  }
 	| namespace_or_type_name pointer_stars
 	  {
 		$$ = new ComposedCast (((MemberName) $1).GetTypeExpression (), (ComposedTypeSpecifier) $2);
 	  }
 	| builtin_types opt_nullable
 	  {
 		if ($2 != null)
 			$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	| builtin_types pointer_stars
 	  {
 		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	| VOID pointer_stars
 	  {
 		$$ = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation ($1)), (ComposedTypeSpecifier) $2);
 	  }
 	;
 
 type_list
 	
 	  {
 		var types = new List<FullNamedExpression> (2);
 		types.Add ((FullNamedExpression) $1);
 		$$ = types;
 	  }
 	| type_list COMMA base_type_name
 	  {
 		var types = (List<FullNamedExpression>) $1;
 		types.Add ((FullNamedExpression) $3);
 		$$ = types;
 	  }
 	;
 
 base_type_name
 	
 	  {
 		if ($1 is ComposedCast) {
 			Report.Error (1521, GetLocation ($1), "Invalid base type `{0}'", ((ComposedCast)$1).GetSignatureForError ());
 		}
 		$$ = $1;
 	  }
 	| error
 	  {
 	  	Error_TypeExpected (lexer.Location);
 		$$ = null;
 	  }
 	;
 	
 /*
  * replaces all the productions for isolating the various
  * simple types, but we need this to reuse it easily in variable_type
  */
 builtin_types
 	
 	| STRING	{ $$ = new TypeExpression (TypeManager.string_type, GetLocation ($1)); }
 	| BOOL		{ $$ = new TypeExpression (TypeManager.bool_type, GetLocation ($1)); }
 	| DECIMAL	{ $$ = new TypeExpression (TypeManager.decimal_type, GetLocation ($1)); }
 	| FLOAT		{ $$ = new TypeExpression (TypeManager.float_type, GetLocation ($1)); }
 	| DOUBLE	{ $$ = new TypeExpression (TypeManager.double_type, GetLocation ($1)); }
 	| integral_type
 	;
 
 integral_type
 	
 	| BYTE		{ $$ = new TypeExpression (TypeManager.byte_type, GetLocation ($1)); }
 	| SHORT		{ $$ = new TypeExpression (TypeManager.short_type, GetLocation ($1)); }
 	| USHORT	{ $$ = new TypeExpression (TypeManager.ushort_type, GetLocation ($1)); }
 	| INT		{ $$ = new TypeExpression (TypeManager.int32_type, GetLocation ($1)); }
 	| UINT		{ $$ = new TypeExpression (TypeManager.uint32_type, GetLocation ($1)); }
 	| LONG		{ $$ = new TypeExpression (TypeManager.int64_type, GetLocation ($1)); }
 	| ULONG		{ $$ = new TypeExpression (TypeManager.uint64_type, GetLocation ($1)); }
 	| CHAR		{ $$ = new TypeExpression (TypeManager.char_type, GetLocation ($1)); }
 	;
 
 //
 // Expressions, section 7.5
 //
 
 
 primary_expression
 	
 	| literal
 	| array_creation_expression
 	| parenthesized_expression
 	| default_value_expression
 	| invocation_expression
 	| element_access
 	| this_access
 	| base_access
 	| post_increment_expression
 	| post_decrement_expression
 	| object_or_delegate_creation_expression
 	| anonymous_type_expression
 	| typeof_expression
 	| sizeof_expression
 	| checked_expression
 	| unchecked_expression
 	| pointer_member_access
 	| anonymous_method_expression
 	;
 
 primary_expression_or_type
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new SimpleName (lt.Value, (TypeArguments)$2, lt.Location);	  
 	  }
 	| IDENTIFIER GENERATE_COMPLETION {
 		var lt = (Tokenizer.LocatedToken) $1;
 	       $$ = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
 	  }
 	| member_access
 	;
 
 literal
 	
 	| LITERAL
 	| NULL			{ $$ = new NullLiteral (GetLocation ($1)); }
 	;
 
 boolean_literal
 	
 	| FALSE			{ $$ = new BoolLiteral (false, GetLocation ($1)); }
 	;
 
 
 //
 // Here is the trick, tokenizer may think that parens is a special but
 // parser is interested in open parens only, so we merge them.
 // Consider
 //
 open_parens_any
 	
 	| OPEN_PARENS_CAST
 	;
 
 // 
 // Use this production to accept closing parenthesis or 
 // performing completion
 //
 close_parens
 	
 	| COMPLETE_COMPLETION
 	;
 
 
 parenthesized_expression
 	
 	  {
 		$$ = new ParenthesizedExpression ((Expression) $2);
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	| OPEN_PARENS expression COMPLETE_COMPLETION
 	  {
 		$$ = new ParenthesizedExpression ((Expression) $2);
 	  }
 	;
 	
 member_access
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess ((Expression) $1, lt.Value, (TypeArguments) $4, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| builtin_types DOT IDENTIFIER opt_type_argument_list
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess ((Expression) $1, lt.Value, (TypeArguments) $4, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| BASE DOT IDENTIFIER opt_type_argument_list
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess (new BaseThis (GetLocation ($1)), lt.Value, (TypeArguments) $4, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| qualified_alias_member IDENTIFIER opt_type_argument_list
 	  {
 		var lt1 = (Tokenizer.LocatedToken) $1;
 		var lt2 = (Tokenizer.LocatedToken) $2;
 
 		$$ = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) $3, lt1.Location);
 	  }
 	| primary_expression DOT GENERATE_COMPLETION {
 		$$ = new CompletionMemberAccess ((Expression) $1, null,GetLocation ($3));
 	  }
 	| primary_expression DOT IDENTIFIER GENERATE_COMPLETION {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new CompletionMemberAccess ((Expression) $1, lt.Value, lt.Location);
 	  }
 	| builtin_types DOT GENERATE_COMPLETION
 	  {
 		$$ = new CompletionMemberAccess ((Expression) $1, null, lexer.Location);
 	  }
 	| builtin_types DOT IDENTIFIER GENERATE_COMPLETION {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new CompletionMemberAccess ((Expression) $1, lt.Value, lt.Location);
  	  }
 	;
 
 invocation_expression
 	
 	  {
 		$$ = new Invocation ((Expression) $1, (Arguments) $3);
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 opt_object_or_collection_initializer
 	
 	| object_or_collection_initializer
 	;
 
 object_or_collection_initializer
 	
 	  {
 	  	if ($2 == null) {
 	  		$$ = CollectionOrObjectInitializers.Empty;
 	  		// TODO
 	  	} else {
 	  		$$ = new CollectionOrObjectInitializers ((List<Expression>) $2, GetLocation ($1));
 	  		lbag.AddLocation ($$, GetLocation ($3));
 	  	}
 	  }
 	| OPEN_BRACE member_initializer_list COMMA CLOSE_BRACE
 	  {
 	  	$$ = new CollectionOrObjectInitializers ((List<Expression>) $2, GetLocation ($1));
 	  	lbag.AddLocation ($$, GetLocation ($3), GetLocation ($4));
 	  }
 	;
 
 opt_member_initializer_list
 	
 	| member_initializer_list
 	{
 		$$ = $1;
 	}
 	;
 
 member_initializer_list
 	
 	  {
 	  	var a = new List<Expression> ();
 	  	a.Add ((Expression) $1);
 	  	$$ = a;
 	  }
 	| member_initializer_list COMMA member_initializer
 	  {
 	  	var a = (List<Expression>)$1;
 	  	a.Add ((Expression) $3);
 	  	$$ = a;
 	  }
 	| member_initializer_list error {
 	  	Error_SyntaxError (yyToken);
 		$$ = $1;
 	  }
 	;
 
 member_initializer
 	
 	  {
 	  	var lt = (Tokenizer.LocatedToken) $1;
 	  	$$ = new ElementInitializer (lt.Value, (Expression)$3, lt.Location);
 	  	lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| GENERATE_COMPLETION 
 	  {
 		$$ = new CompletionElementInitializer (null, GetLocation ($1));
 	  }
 	| non_assignment_expression opt_COMPLETE_COMPLETION  {
 		CompletionSimpleName csn = $1 as CompletionSimpleName;
 		if (csn == null)
 			$$ = new CollectionElementInitializer ((Expression)$1);
 		else
 			$$ = new CompletionElementInitializer (csn.Prefix, csn.Location);
 	  }
 	| OPEN_BRACE expression_list CLOSE_BRACE
 	  {
 		if ($2 == null)
 			$$ = null;
 		else
 	  		$$ = new CollectionElementInitializer ((List<Expression>)$2, GetLocation ($1));
 	  }
 	| OPEN_BRACE CLOSE_BRACE
 	  {
 	  	Report.Error (1920, GetLocation ($1), "An element initializer cannot be empty");
 		$$ = null;
 	  }	  
 	;
 
 initializer_value
 	
 	| object_or_collection_initializer
 	;
 
 opt_argument_list
 	
 	| argument_list
 	;
 
 argument_list
 	
 	  { 
 		Arguments list = new Arguments (4);
 		list.Add ((Argument) $1);
 		$$ = list;
 	  }
 	| argument_list COMMA argument
 	  {
 		Arguments list = (Arguments) $1;
 		if (list [list.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
 		
 		list.Add ((Argument) $3);
 		$$ = list;
 	  }
 	| argument_list COMMA named_argument
 	  {
 		Arguments list = (Arguments) $1;
 		NamedArgument a = (NamedArgument) $3;
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		
 		list.Add (a);
 		$$ = list;
 	  }
 	| argument_list COMMA
 	  {
 	  	Report.Error (839, GetLocation ($2), "An argument is missing");
 	  	$$ = $1;
 	  }
 	| COMMA error
 	  {
 	  	Report.Error (839, GetLocation ($1), "An argument is missing");
 	  	$$ = null;
 	  }
 	;
 
 argument
 	
 	  {
 		$$ = new Argument ((Expression) $1);
 	  }
 	| non_simple_argument
 	;
 
 argument_or_named_argument
 	
 	| named_argument
 	;
 
 non_simple_argument
 	
 	  { 
 		$$ = new Argument ((Expression) $2, Argument.AType.Ref);
 		lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	| OUT variable_reference 
 	  { 
 		$$ = new Argument ((Expression) $2, Argument.AType.Out);
 		lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	| ARGLIST OPEN_PARENS argument_list CLOSE_PARENS
 	  {
 		$$ = new Argument (new Arglist ((Arguments) $3, GetLocation ($1)));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	| ARGLIST OPEN_PARENS CLOSE_PARENS
 	  {
 		$$ = new Argument (new Arglist (GetLocation ($1)));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($3));
 	  }	  
 	;
 
 variable_reference
 	
 	;
 
 element_access
 	
 	  {
 		$$ = new ElementAccess ((Expression) $1, (Arguments) $3, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	;
 
 expression_list
 	
 	  {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) $1);
 		$$ = list;
 	  }
 	| expression_list COMMA expression
 	  {
 		var list = (List<Expression>) $1;
 		list.Add ((Expression) $3);
 		$$ = list;
 	  }
 	| expression_list error {
 	  	Error_SyntaxError (yyToken);
 		$$ = $1;
 	  }
 	;
 	
 expression_list_arguments
 	
 	  {
 		Arguments args = new Arguments (4);
 		args.Add ((Argument) $1);
 		$$ = args;
 	  }
 	| expression_list_arguments COMMA expression_list_argument
 	  {
 		Arguments args = (Arguments) $1;
 		if (args [args.Count - 1] is NamedArgument && !($3 is NamedArgument))
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 	  
 		args.Add ((Argument) $3);
 		$$ = args;	  
 	  }
 	;
 	
 expression_list_argument
 	
 	  {
 	  	$$ = new Argument ((Expression) $1);
 	  }
 	| named_argument
 	;
 
 this_access
 	
 	  {
 		$$ = new This (GetLocation ($1));
 	  }
 	;
 
 base_access
 	
 	  {
 	  	$$ = new ElementAccess (new BaseThis (GetLocation ($1)), (Arguments) $3, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	| BASE OPEN_BRACKET error
 	  {
 	  	Error_SyntaxError (yyToken);
 		$$ = new ElementAccess (null, null, GetLocation ($2));
 	  }
 	;
 
 post_increment_expression
 	
 	  {
 		$$ = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) $1, GetLocation ($2));
 	  }
 	;
 
 post_decrement_expression
 	
 	  {
 		$$ = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) $1, GetLocation ($2));
 	  }
 	;
 	
 object_or_delegate_creation_expression
 	
 	  {
 		if ($6 != null) {
 			if (RootContext.Version <= LanguageVersion.ISO_2)
 				Report.FeatureIsNotAvailable (GetLocation ($1), "object initializers");
 				
 			$$ = new NewInitialize ((FullNamedExpression) $2, (Arguments) $4, (CollectionOrObjectInitializers) $6, GetLocation ($1));
 		} else {
 			$$ = new New ((FullNamedExpression) $2, (Arguments) $4, GetLocation ($1));
 		}
 		
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
 	  }
 	| NEW new_expr_type object_or_collection_initializer
 	  {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "collection initializers");
 	  
 		$$ = new NewInitialize ((FullNamedExpression) $2, null, (CollectionOrObjectInitializers) $3, GetLocation ($1));
 	  }
 	;
 
 array_creation_expression
 	
 	  opt_rank_specifier
 	  opt_array_initializer
 	  {
 		$$ = new ArrayCreation ((FullNamedExpression) $2, (List<Expression>) $4,
 				new ComposedTypeSpecifier (((List<Expression>) $4).Count, GetLocation ($3)) {
 	  				Next = (ComposedTypeSpecifier) $6
 			  	}, (ArrayInitializer) $7, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
 	  }
 	| NEW new_expr_type rank_specifiers opt_array_initializer
 	  {
 	  	if ($4 == null)
 	  		Report.Error (1586, GetLocation ($1), "Array creation must have array size or array initializer");
 
 		$$ = new ArrayCreation ((FullNamedExpression) $2, (ComposedTypeSpecifier) $3, (ArrayInitializer) $4, GetLocation ($1));
 	  }
 	| NEW rank_specifiers array_initializer
 	  {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "implicitly typed arrays");
 	  
 		$$ = new ImplicitlyTypedArrayCreation ((ComposedTypeSpecifier) $2, (ArrayInitializer) $3, GetLocation ($1));
 	  }
 	| NEW new_expr_type OPEN_BRACKET CLOSE_BRACKET OPEN_BRACKET_EXPR error CLOSE_BRACKET
 	  {
 		Report.Error (178, GetLocation ($6), "Invalid rank specifier, expecting `,' or `]'");
 		$$ = new ArrayCreation ((FullNamedExpression) $2, null, GetLocation ($1));
 	  }
 	| NEW new_expr_type error
 	  {
 		Error_SyntaxError (1526, yyToken, "Unexpected symbol");
 		$$ = new ArrayCreation ((FullNamedExpression) $2, null, GetLocation ($1));
 	  }
 	;
 
 new_expr_type
 	
 		++lexer.parsing_type;
 	  }
 	  simple_type
 	  {
 		--lexer.parsing_type;
 		$$ = $2;
 	  }
 	;
 
 anonymous_type_expression
 	
 	  {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation ($1), "anonymous types");
 
 		$$ = new NewAnonymousType ((List<AnonymousTypeParameter>) $3, current_container, GetLocation ($1));
 		
 		// TODO
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 anonymous_type_parameters_opt_comma
 	
 	| anonymous_type_parameters COMMA
 	;
 
 anonymous_type_parameters_opt
 	
 	| anonymous_type_parameters
 	;
 
 anonymous_type_parameters
 	
 	  {
 	  	var a = new List<AnonymousTypeParameter> (4);
 	  	a.Add ((AnonymousTypeParameter) $1);
 	  	$$ = a;
 	  }
 	| anonymous_type_parameters COMMA anonymous_type_parameter
 	  {
 	  	var a = (List<AnonymousTypeParameter>) $1;
 	  	a.Add ((AnonymousTypeParameter) $3);
 	  	$$ = a;
 	  }
 	;
 
 anonymous_type_parameter
 	
 	  {
 		var lt = (Tokenizer.LocatedToken)$1;
 	  	$$ = new AnonymousTypeParameter ((Expression)$3, lt.Value, lt.Location);
 	  	lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken)$1;
 	  	$$ = new AnonymousTypeParameter (new SimpleName (lt.Value, lt.Location),
 	  		lt.Value, lt.Location);
 	  }
 	| member_access
 	  {
 	  	MemberAccess ma = (MemberAccess) $1;
 	  	$$ = new AnonymousTypeParameter (ma, ma.Name, ma.Location);
 	  }
 	| error
 	  {
 		Report.Error (746, lexer.Location,
 			"Invalid anonymous type member declarator. Anonymous type members must be a member assignment, simple name or member access expression");
 		$$ = null;
 	  }
 	;
 
 opt_rank_specifier
 	
 	| rank_specifiers
 	;
 
 rank_specifiers
 	
 	| rank_specifier rank_specifiers
 	  {
 	  	((ComposedTypeSpecifier) $1).Next = (ComposedTypeSpecifier) $2;
 	  	$$ = $1;
 	  }
 	;
 
 rank_specifier
 	
 	  {
 		$$ = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation ($1));
 	  }
 	| OPEN_BRACKET dim_separators CLOSE_BRACKET
 	  {
 		$$ = ComposedTypeSpecifier.CreateArrayDimension ((int)$2, GetLocation ($1));
 	  }
 	;
 
 dim_separators
 	
 	  {
 		$$ = 2;
 	  }
 	| dim_separators COMMA
 	  {
 		$$ = ((int) $1) + 1;
 	  }
 	;
 
 opt_array_initializer
 	
 	  {
 		$$ = null;
 	  }
 	| array_initializer
 	  {
 		$$ = $1;
 	  }
 	;
 
 array_initializer
 	
 	  {
 		var ai = new ArrayInitializer (0, GetLocation ($1));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation ($2));
 		$$ = ai;
 	  }
 	| OPEN_BRACE variable_initializer_list opt_comma CLOSE_BRACE
 	  {
 		var ai = new ArrayInitializer ((List<Expression>) $2, GetLocation ($1));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation ($3));
 		$$ = ai;
 	  }
 	;
 
 variable_initializer_list
 	
 	  {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) $1);
 		$$ = list;
 	  }
 	| variable_initializer_list COMMA variable_initializer
 	  {
 		var list = (List<Expression>) $1;
 		list.Add ((Expression) $3);
 		$$ = list;
 	  }
 	;
 
 typeof_expression
 	
       {
 	  	lexer.TypeOfParsing = true;
 	  }
 	  open_parens_any typeof_type_expression CLOSE_PARENS
 	  {
 	  	lexer.TypeOfParsing = false;
 		$$ = new TypeOf ((FullNamedExpression) $4, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
 	  }
 	;
 	
 typeof_type_expression
 	
 	| unbound_type_name
 	| error
 	 {
 	 	Error_TypeExpected (lexer.Location);
 	 	$$ = null;
 	 }
 	;
 	
 unbound_type_name
 	
 	  {  
 		var lt = (Tokenizer.LocatedToken) $1;
 
 		$$ = new SimpleName (lt.Value, (int) $2, lt.Location);
 	  }
 	| qualified_alias_member IDENTIFIER generic_dimension
 	  {
 		var lt1 = (Tokenizer.LocatedToken) $1;
 		var lt2 = (Tokenizer.LocatedToken) $2;
 
 		$$ = new QualifiedAliasMember (lt1.Value, lt2.Value, (int) $3, lt1.Location);
 	  }
 	| unbound_type_name DOT IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		
 		$$ = new MemberAccess ((Expression) $1, lt.Value, lt.Location);		
 	  }
 	| unbound_type_name DOT IDENTIFIER generic_dimension
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		
 		$$ = new MemberAccess ((Expression) $1, lt.Value, (int) $4, lt.Location);		
 	  }
 	| namespace_or_type_name DOT IDENTIFIER generic_dimension
 	  {
 		var te = ((MemberName) $1).GetTypeExpression ();
 		if (te.HasTypeArguments)
 			Error_TypeExpected (GetLocation ($4));
 
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess (te, lt.Value, (int) $4, lt.Location);		
 	  }
 	;
 
 generic_dimension
 	
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "generics");
 
 		$$ = $1;
 	  }
 	;
 	
 qualified_alias_member
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		if (RootContext.Version == LanguageVersion.ISO_1)
 			Report.FeatureIsNotAvailable (lt.Location, "namespace alias qualifier");
 
 		$$ = lt;		
 	  }
 	;
 
 sizeof_expression
 	
 	  { 
 		$$ = new SizeOf ((Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 checked_expression
 	
 	  {
 		$$ = new CheckedExpr ((Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 unchecked_expression
 	
 	  {
 		$$ = new UnCheckedExpr ((Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 pointer_member_access 
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess (new Indirection ((Expression) $1, GetLocation ($2)), lt.Value, lt.Location);
 	  }
 	;
 
 anonymous_method_expression
 	
 	  {
 		start_anonymous (false, (ParametersCompiled) $2, GetLocation ($1));
 	  }
 	  block
 	  {
 		$$ = end_anonymous ((ParametersBlock) $4);
 	  }
 	;
 
 opt_anonymous_method_signature
 	
 	  {
 		$$ = ParametersCompiled.Undefined;
 	  } 
 	| anonymous_method_signature
 	;
 
 anonymous_method_signature
 	
 	  {
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 	  	$$ = $3;
 	  }
 	;
 
 default_value_expression
 	
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "default value expression");
 
 		$$ = new DefaultValueExpression ((Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 unary_expression
 	
 	| BANG prefixed_unary_expression
 	  {
 		$$ = new Unary (Unary.Operator.LogicalNot, (Expression) $2, GetLocation ($1));
 	  }
 	| TILDE prefixed_unary_expression
 	  {
 		$$ = new Unary (Unary.Operator.OnesComplement, (Expression) $2, GetLocation ($1));
 	  }
 	| cast_expression
 	;
 
 cast_expression
 	
 	  {
 		$$ = new Cast ((FullNamedExpression) $2, (Expression) $4, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($3));
 	  }
 	;
 
 	//
 	// The idea to split this out is from Rhys' grammar
 	// to solve the problem with casts.
 	//
 prefixed_unary_expression
 	
 	| PLUS prefixed_unary_expression
 	  { 
 	  	$$ = new Unary (Unary.Operator.UnaryPlus, (Expression) $2, GetLocation ($1));
 	  } 
 	| MINUS prefixed_unary_expression 
 	  { 
 		$$ = new Unary (Unary.Operator.UnaryNegation, (Expression) $2, GetLocation ($1));
 	  }
 	| OP_INC prefixed_unary_expression 
 	  {
 		$$ = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) $2, GetLocation ($1));
 	  }
 	| OP_DEC prefixed_unary_expression 
 	  {
 		$$ = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) $2, GetLocation ($1));
 	  }
 	| STAR prefixed_unary_expression
 	  {
 		$$ = new Indirection ((Expression) $2, GetLocation ($1));
 	  }
 	| BITWISE_AND prefixed_unary_expression
 	  {
 		$$ = new Unary (Unary.Operator.AddressOf, (Expression) $2, GetLocation ($1));
 	  }
 	;
 
 multiplicative_expression
 	
 	| multiplicative_expression STAR prefixed_unary_expression
 	  {
 		$$ = new Binary (Binary.Operator.Multiply, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| multiplicative_expression DIV prefixed_unary_expression
 	  {
 		$$ = new Binary (Binary.Operator.Division, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| multiplicative_expression PERCENT prefixed_unary_expression 
 	  {
 		$$ = new Binary (Binary.Operator.Modulus, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 additive_expression
 	
 	| additive_expression PLUS multiplicative_expression 
 	  {
 		$$ = new Binary (Binary.Operator.Addition, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| additive_expression MINUS multiplicative_expression
 	  {
 		$$ = new Binary (Binary.Operator.Subtraction, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
   	| parenthesized_expression MINUS multiplicative_expression
 	  {
 	  	// Shift/Reduce conflict
 		$$ = new Binary (Binary.Operator.Subtraction, (Expression) $1, (Expression) $3, GetLocation ($2));
   	  }
 	| additive_expression AS type
 	  {
 		$$ = new As ((Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| additive_expression IS type
 	  {
 		$$ = new Is ((Expression) $1, (Expression) $3, GetLocation ($2));
 	  }	  
 	;
 
 shift_expression
 	
 	| shift_expression OP_SHIFT_LEFT additive_expression
 	  {
 		$$ = new Binary (Binary.Operator.LeftShift, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| shift_expression OP_SHIFT_RIGHT additive_expression
 	  {
 		$$ = new Binary (Binary.Operator.RightShift, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	; 
 
 relational_expression
 	
 	| relational_expression OP_LT shift_expression
 	  {
 		$$ = new Binary (Binary.Operator.LessThan, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| relational_expression OP_GT shift_expression
 	  {
 		$$ = new Binary (Binary.Operator.GreaterThan, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| relational_expression OP_LE shift_expression
 	  {
 		$$ = new Binary (Binary.Operator.LessThanOrEqual, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| relational_expression OP_GE shift_expression
 	  {
 		$$ = new Binary (Binary.Operator.GreaterThanOrEqual, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 equality_expression
 	
 	| equality_expression OP_EQ relational_expression
 	  {
 		$$ = new Binary (Binary.Operator.Equality, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| equality_expression OP_NE relational_expression
 	  {
 		$$ = new Binary (Binary.Operator.Inequality, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	; 
 
 and_expression
 	
 	| and_expression BITWISE_AND equality_expression
 	  {
 		$$ = new Binary (Binary.Operator.BitwiseAnd, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 exclusive_or_expression
 	
 	| exclusive_or_expression CARRET and_expression
 	  {
 		$$ = new Binary (Binary.Operator.ExclusiveOr, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 inclusive_or_expression
 	
 	| inclusive_or_expression BITWISE_OR exclusive_or_expression
 	  {
 		$$ = new Binary (Binary.Operator.BitwiseOr, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 conditional_and_expression
 	
 	| conditional_and_expression OP_AND inclusive_or_expression
 	  {
 		$$ = new Binary (Binary.Operator.LogicalAnd, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 conditional_or_expression
 	
 	| conditional_or_expression OP_OR conditional_and_expression
 	  {
 		$$ = new Binary (Binary.Operator.LogicalOr, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 	
 null_coalescing_expression
 	
 	| conditional_or_expression OP_COALESCING null_coalescing_expression
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($2), "null coalescing operator");
 			
 		$$ = new Nullable.NullCoalescingOperator ((Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 conditional_expression
 	
 	| null_coalescing_expression INTERR expression COLON expression 
 	  {
 		$$ = new Conditional (new BooleanExpression ((Expression) $1), (Expression) $3, (Expression) $5, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	;
 
 assignment_expression
 	
 	  {
 		$$ = new SimpleAssign ((Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_MULT_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Multiply, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_DIV_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Division, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_MOD_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Modulus, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_ADD_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Addition, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_SUB_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Subtraction, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_SHIFT_LEFT_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.LeftShift, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_SHIFT_RIGHT_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.RightShift, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_AND_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.BitwiseAnd, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_OR_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.BitwiseOr, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_XOR_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.ExclusiveOr, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 lambda_parameter_list
 	
 	  {
 		var pars = new List<Parameter> (4);
 		pars.Add ((Parameter) $1);
 
 		$$ = pars;
 	  }
 	| lambda_parameter_list COMMA lambda_parameter
 	  {
 		var pars = (List<Parameter>) $1;
 		Parameter p = (Parameter)$3;
 		if (pars[0].GetType () != p.GetType ()) {
 			Report.Error (748, p.Location, "All lambda parameters must be typed either explicitly or implicitly");
 		}
 		
 		pars.Add (p);
 		$$ = pars;
 	  }
 	;
 
 lambda_parameter
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 
 		$$ = new Parameter ((FullNamedExpression) $2, lt.Value, (Parameter.Modifier) $1, null, lt.Location);
 	  }
 	| parameter_type IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 
 		$$ = new Parameter ((FullNamedExpression) $1, lt.Value, Parameter.Modifier.NONE, null, lt.Location);
 	  }
 	| IDENTIFIER
 	  {
 	  	var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new ImplicitLambdaParameter (lt.Value, lt.Location);
 	  }
 	;
 
 opt_lambda_parameter_list
 	
 	| lambda_parameter_list		{ 
 		var pars_list = (List<Parameter>) $1;
 		$$ = new ParametersCompiled (pars_list.ToArray ());
 	  }
 	;
 
 lambda_expression_body
 	
 	| block
 	;
 	
 lambda_expression_body_simple
 	
 		start_block (lexer.Location);
 	  }
 	  expression_or_error	// Have to close block when error occurs
 	  {
 		Block b = end_block (lexer.Location);
 		b.AddStatement (new ContextualReturn ((Expression) $2));
 		$$ = b;
 	  } 
 	;
 	
 expression_or_error
 	
 	| error
 	  {
 		Error_SyntaxError (yyToken);	
 		$$ = EmptyExpression.Null;
 	  }
 	;
 
 lambda_expression
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
 		start_anonymous (true, new ParametersCompiled (p), GetLocation ($1));
 	  }
 	  lambda_expression_body
 	  {
 		$$ = end_anonymous ((ParametersBlock) $4);
 		lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| OPEN_PARENS_LAMBDA
 	  {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "lambda expressions");
 	  
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
 	  opt_lambda_parameter_list CLOSE_PARENS ARROW 
 	  {
 	  	valid_param_mod = 0;
 		start_anonymous (true, (ParametersCompiled) $3, GetLocation ($1));
 	  }
 	  lambda_expression_body 
 	  {
 		$$ = end_anonymous ((ParametersBlock) $7);
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($4));
 	  }
 	;
 
 expression
 	
 	| non_assignment_expression
 	;
 	
 non_assignment_expression
 	
 	| lambda_expression
 	| query_expression
 	| ARGLIST
 	  {
 		$$ = new ArglistAccess (GetLocation ($1));
 	  }	
 	;
 
 constant_expression
 	
 	;
 
 boolean_expression
 	
 	  {
 		$$ = new BooleanExpression ((Expression) $1);
 	  }
 	;
 
 //
 // 10 classes
 //
 class_declaration
 	
 	  opt_modifiers
 	  opt_partial
 	  CLASS
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  type_declaration_name
 	  {
 		MemberName name = MakeName ((MemberName) $6);
 		push_current_class (new Class (current_namespace, current_class, name, (Modifiers) $2, (Attributes) $1), $3);
 	  }
 	  opt_class_base
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) $9);
 		lbag.AddMember (current_class, mod_locations, GetLocation ($4));
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
 	  OPEN_BRACE opt_class_member_declarations CLOSE_BRACE
 	  {
 		--lexer.parsing_declaration;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_semicolon 
 	  {
 		lbag.AppendToMember (current_class, GetLocation ($11), GetLocation ($13), GetLocation ($15));
 		$$ = pop_current_class ();
 	  }
 	;	
 
 opt_partial
 	
 	  { $$ = null; }
 	| PARTIAL
 	  { $$ = $1; } // location
 	;
 
 opt_modifiers
 	
 	  {
 	    mod_locations = null;
 		$$ = ModifierNone;
 	  }
 	| modifiers
 	;
 
 modifiers
 	
 	| modifiers modifier
 	  { 
 		var m1 = (Modifiers) $1;
 		var m2 = (Modifiers) $2;
 
 		if ((m1 & m2) != 0) {
 			Report.Error (1004, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"Duplicate `{0}' modifier", ModifiersExtensions.Name (m2));
 		} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
 			((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
 			Report.Error (107, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"More than one protection modifier specified");
 		}
 		
 		$$ = m1 | m2;
 	  }
 	;
 
 modifier
 	
 	  {
 		$$ = Modifiers.NEW;
 		StoreModifierLocation ($$, GetLocation ($1));
 		
 		if (current_container == RootContext.ToplevelTypes)
 			Report.Error (1530, GetLocation ($1), "Keyword `new' is not allowed on namespace elements");
 	  }
 	| PUBLIC
 	  {
 		$$ = Modifiers.PUBLIC;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| PROTECTED
 	  {
 		$$ = Modifiers.PROTECTED;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| INTERNAL
 	  {
 		$$ = Modifiers.INTERNAL;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| PRIVATE
 	  {
 		$$ = Modifiers.PRIVATE;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| ABSTRACT
 	  {
 		$$ = Modifiers.ABSTRACT;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| SEALED
 	  {
 		$$ = Modifiers.SEALED;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| STATIC
 	  {
 		$$ = Modifiers.STATIC;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| READONLY
 	  {
 		$$ = Modifiers.READONLY;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| VIRTUAL
 	  {
 		$$ = Modifiers.VIRTUAL;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| OVERRIDE
 	  {
 		$$ = Modifiers.OVERRIDE;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| EXTERN
 	  {
 		$$ = Modifiers.EXTERN;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| VOLATILE
 	  {
 		$$ = Modifiers.VOLATILE;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| UNSAFE
 	  {
 		$$ = Modifiers.UNSAFE;
 		StoreModifierLocation ($$, GetLocation ($1));
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation ($1));
 	  }
 	| ASYNC
 	  {
 		$$ = Modifiers.ASYNC;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	;
 
 opt_class_base
 	
 	| COLON type_list
 	 {
 		current_container.AddBasesForPart (current_class, (List<FullNamedExpression>) $2);
 	 }
 	;
 
 opt_type_parameter_constraints_clauses
 	
 	| type_parameter_constraints_clauses 
 	  {
 		$$ = $1;
 	  }
 	| error
 	 {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	 }
 	;
 
 type_parameter_constraints_clauses
 	
 	  {
 		var constraints = new List<Constraints> (1);
 		constraints.Add ((Constraints) $1);
 		$$ = constraints;
 	  }
 	| type_parameter_constraints_clauses type_parameter_constraints_clause
 	  {
 		var constraints = (List<Constraints>) $1;
 		Constraints new_constraint = (Constraints)$2;
 
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 
 		constraints.Add (new_constraint);
 		$$ = constraints;
 	  }
 	; 
 
 type_parameter_constraints_clause
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		$$ = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) $4, GetLocation ($1));
 	  }
 	; 
 
 type_parameter_constraints
 	
 	  {
 		var constraints = new List<FullNamedExpression> (1);
 		constraints.Add ((FullNamedExpression) $1);
 		$$ = constraints;
 	  }
 	| type_parameter_constraints COMMA type_parameter_constraint
 	  {
 		var constraints = (List<FullNamedExpression>) $1;
 		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
 		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
 			Report.Error (401, GetLocation ($2), "The `new()' constraint must be the last constraint specified");
 		}
 		
 		prev = $3 as SpecialContraintExpr;
 		if (prev != null) {
 			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
 				Report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
 			} else {
 			 	prev = constraints [0] as SpecialContraintExpr;
 			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
 					Report.Error (451, GetLocation ($3), "The `new()' constraint cannot be used with the `struct' constraint");
 				}
 			}
 		}
 
 		constraints.Add ((FullNamedExpression) $3);
 		$$ = constraints;
 	  }
 	;
 
 type_parameter_constraint
 	
 	  {
 		if ($1 is ComposedCast)
 			Report.Error (706, GetLocation ($1), "Invalid constraint type `{0}'", ((ComposedCast)$1).GetSignatureForError ());
 	  
 	  	$$ = $1;
 	  }
 	| NEW OPEN_PARENS CLOSE_PARENS
 	  {
 		$$ = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($3));
 	  }
 	| CLASS
 	  {
 		$$ = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation ($1));
 	  }
 	| STRUCT
 	  {
 		$$ = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation ($1));
 	  }
 	;
 
 opt_type_parameter_variance
 	
 	  {
 		$$ = Variance.None;
 	  }
 	| type_parameter_variance
 	  {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (lexer.Location, "generic type variance");
 
 		$$ = $1;
 	  }
 	;
 
 type_parameter_variance
 	
 	  {
 		$$ = Variance.Covariant;
 	  }
 	| IN
 	  {
 		$$ = Variance.Contravariant;
 	  }
 	;
 
 //
 // Statements (8.2)
 //
 
 //
 // A block is "contained" on the following places
 //	method_body
 //	property_declaration as part of the accessor body (get/set)
 //      operator_declaration
 //	constructor_declaration
 //	destructor_declaration
 //	event_declaration as part of add_accessor_declaration or remove_accessor_declaration
 //      
 block
 	
 	  {
 		++lexer.parsing_block;
 		start_block (GetLocation ($1));
 	  } 
 	  opt_statement_list block_end
 	  {
 		$$ = $4;
 	  }
 	;
 
 block_end 
 	
 	  {
 	 	--lexer.parsing_block;
 		$$ = end_block (GetLocation ($1));
 	  }
 	| COMPLETE_COMPLETION
 	  {
 	 	--lexer.parsing_block;
 		$$ = end_block (lexer.Location);
 	  }
 	;
 
 
 block_prepared
 	
 	  {
 		++lexer.parsing_block;
 		current_block.StartLocation = GetLocation ($1);
 	  }
 	  opt_statement_list CLOSE_BRACE 
 	  {
 		--lexer.parsing_block;
 		$$ = end_block (GetLocation ($4));
 	  }
 	;
 
 opt_statement_list
 	
 	| statement_list 
 	;
 
 statement_list
 	
 	| statement_list statement
 	;
 
 statement
 	
 	  {
 		current_block.AddStatement ((Statement) $1);
 	  }
 	| valid_declaration_statement
 	  {
 		current_block.AddStatement ((Statement) $1);
 	  }
 	| labeled_statement
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 
 //
 // The interactive_statement and its derivatives are only 
 // used to provide a special version of `expression_statement'
 // that has a side effect of assigning the expression to
 // $retval
 //
 interactive_statement_list
 	
 	| interactive_statement_list interactive_statement
 	;
 
 interactive_statement
 	
 	  {
 		current_block.AddStatement ((Statement) $1);
 	  }
 	| interactive_valid_declaration_statement
 	  {
 		current_block.AddStatement ((Statement) $1);
 	  }
 	| labeled_statement
 	;
 
 valid_declaration_statement
 	
 	| empty_statement
 	| expression_statement
 	| selection_statement
 	| iteration_statement
 	| jump_statement		  
 	| try_statement
 	| checked_statement
 	| unchecked_statement
 	| lock_statement
 	| using_statement
 	| unsafe_statement
 	| fixed_statement
 	;
 
 interactive_valid_declaration_statement
 	
 	| empty_statement
         | interactive_expression_statement
 	| selection_statement
 	| iteration_statement
 	| jump_statement		  
 	| try_statement
 	| checked_statement
 	| unchecked_statement
 	| lock_statement
 	| using_statement
 	| unsafe_statement
 	| fixed_statement
 	;
 
 embedded_statement
 	
 	| block_variable_declaration
 	  {
 		  Report.Error (1023, GetLocation ($1), "An embedded statement may not be a declaration or labeled statement");
 		  $$ = null;
 	  }
 	| labeled_statement
 	  {
 		  Report.Error (1023, GetLocation ($1), "An embedded statement may not be a declaration or labeled statement");
 		  $$ = null;
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = new EmptyStatement (GetLocation ($1));
 	  }
 	;
 
 empty_statement
 	
 	  {
 		// Uses lexer.Location because semicolon location is not kept in quick mode
 		$$ = new EmptyStatement (lexer.Location);
 	  }
 	;
 
 labeled_statement
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
 
 		current_block.AddLabel (labeled);
 		current_block.AddStatement (labeled);
 	  }
 	  statement
 	;
 
 variable_type
 	
 	| variable_type_simple rank_specifiers
 	  {
 		if ($1 is VarExpr)
 			$1 = new SimpleName ("var", ((VarExpr) $1).Location);
 	  
 		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	;
 
 /* 
  * The following is from Rhys' grammar
  * > Types in local variable declarations must be recognized as 
  * > expressions to prevent reduce/reduce errors in the grammar.
  * > The expressions are converted into types during semantic analysis.
  */
 variable_type_simple
 	
 	  { 
 		// Ok, the above "primary_expression" is there to get rid of
 		// both reduce/reduce and shift/reduces in the grammar, it should
 		// really just be "type_name".  If you use type_name, a reduce/reduce
 		// creeps up.  If you use namespace_or_type_name (which is all we need
 		// really) two shift/reduces appear.
 		// 
 
 		// So the super-trick is that primary_expression
 		// can only be either a SimpleName or a MemberAccess. 
 		// The MemberAccess case arises when you have a fully qualified type-name like 
 		// Foo.Bar.Blah i;
 		// SimpleName is when you have
 		// Blah i;
 		
 		Expression expr = (Expression) $1;
 		if ($2 == null) {
 			SimpleName sn = expr as SimpleName;
 			if (sn != null && sn.Name == "var")
 				$$ = new VarExpr (sn.Location);
 			else
 				$$ = $1;
 		} else if (expr is ATypeNameExpression) {
 			$$ = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) $2);
 		} else {
 			Error_ExpectingTypeName (expr);
 			$$ = null;
 		}
 	  }
 	| primary_expression_or_type pointer_stars
 	  {
 		ATypeNameExpression expr = $1 as ATypeNameExpression;
 
 		if (expr != null) {
 			$$ = new ComposedCast (expr, (ComposedTypeSpecifier) $2);
 		} else {
 			Error_ExpectingTypeName ((Expression)$1);
 			$$ = expr;
 		}
 	  }
 	| builtin_types opt_nullable
 	  {
 		if ($2 == null)
 			$$ = $1;
 		else
 			$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	| builtin_types pointer_stars
 	  {
 		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	| VOID pointer_stars
 	  {
 		$$ = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation ($1)), (ComposedTypeSpecifier) $2);
 	  }	  
 	| VOID
 	  {
 		Expression.Error_VoidInvalidInTheContext (GetLocation ($1), Report);
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }
 	;
 	
 pointer_stars
 	
 	| pointer_star pointer_stars
 	  {
 	  	((ComposedTypeSpecifier) $1).Next = (ComposedTypeSpecifier) $2;
 	  	$$ = $1;
 	  }	  
 	;
 
 pointer_star
 	
 	  {
 		$$ = ComposedTypeSpecifier.CreatePointer (GetLocation ($1));
 	  }
 	;
 
 block_variable_declaration
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) $1, li);
 	  }
 	  opt_local_variable_initializer opt_variable_declarators SEMICOLON
 	  {
 		$$ = current_variable;
 		current_variable = null;
 		lbag.AddLocation ($$, GetLocation ($6));
 	  }
 	| CONST variable_type IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockConstantDeclaration ((FullNamedExpression) $2, li);
 	  }
 	  const_variable_initializer opt_const_declarators SEMICOLON
 	  {
 		$$ = current_variable;
 		current_variable = null;
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($7));
 	  }
 	;
 
 opt_local_variable_initializer
 	
 	| ASSIGN block_variable_initializer
 	  {
 		current_variable.Initializer = (Expression) $2;
 		// TODO
 	  }
 	| error
 	  {
 	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
 			Report.Error (650, lexer.Location,
 				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 	  }
 	;
 
 opt_variable_declarators
 	
 	| variable_declarators
 	;
 	
 variable_declarators
 	
 	| variable_declarators variable_declarator
 	;
 	
 variable_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, null);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation ($1));
 	  }
 	| COMMA IDENTIFIER ASSIGN block_variable_initializer
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) $4);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation ($1), GetLocation ($3));
 	  }
 	;
 	
 const_variable_initializer
 	
 	  {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 	  }
 	| ASSIGN constant_initializer_expr 
 	  {
 		current_variable.Initializer = (Expression) $2;
 	  }
 	;
 	
 opt_const_declarators
 	
 	| const_declarators
 	;
 	
 const_declarators
 	
 	| const_declarators const_declarator
 	;
 	
 const_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;	  
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) $4);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation ($1), GetLocation ($3));
 	  }
 	;
 	
 block_variable_initializer
 	
 	| STACKALLOC simple_type OPEN_BRACKET_EXPR expression CLOSE_BRACKET
 	  {
 		$$ = new StackAlloc ((Expression) $2, (Expression) $4, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
 	  }
 	| STACKALLOC simple_type
 	  {
 		Report.Error (1575, GetLocation ($1), "A stackalloc expression requires [] after type");
 		$$ = new StackAlloc ((Expression) $2, null, GetLocation ($1));		
 	  }
 	;
 
 expression_statement
 	
 	  {
 		$$ = $1;
 		lbag.AddStatement ($$, GetLocation ($2));
 	  }
 	| statement_expression COMPLETE_COMPLETION { $$ = $1; }
 	;
 
 interactive_expression_statement
 	
 	| interactive_statement_expression COMPLETE_COMPLETION { $$ = $1; }
 	;
 
 	//
 	// We have to do the wrapping here and not in the case above,
 	// because statement_expression is used for example in for_statement
 	//
 statement_expression
 	
 	  {
 		ExpressionStatement s = $1 as ExpressionStatement;
 		if (s == null) {
 			Expression.Error_InvalidExpressionStatement (Report, GetLocation ($1));
 			s = EmptyExpressionStatement.Instance;
 		}
 
 		$$ = new StatementExpression (s);
 	  }
 	;
 
 interactive_statement_expression
 	
 	  {
 		Expression expr = (Expression) $1;
 		ExpressionStatement s;
 
 	        s = new OptionalAssign (new SimpleName ("$retval", lexer.Location), expr, lexer.Location);
 		$$ = new StatementExpression (s);
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = new EmptyStatement (GetLocation ($1));
 	  }
 	;
 	
 selection_statement
 	
 	| switch_statement
 	; 
 
 if_statement
 	
 	  embedded_statement
 	  { 
 		if ($5 is EmptyStatement)
 			Warning_EmptyStatement (GetLocation ($5));
 		
 		$$ = new If ((BooleanExpression) $3, (Statement) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	| IF open_parens_any boolean_expression CLOSE_PARENS
 	  embedded_statement ELSE embedded_statement
 	  {
 		$$ = new If ((BooleanExpression) $3, (Statement) $5, (Statement) $7, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4), GetLocation ($6));
 		
 		if ($5 is EmptyStatement)
 			Warning_EmptyStatement (GetLocation ($5));
 		if ($7 is EmptyStatement)
 			Warning_EmptyStatement (GetLocation ($7));
 	  }
 	;
 
 switch_statement
 	
 	  {
 		start_block (GetLocation ($5));
 	  }
 	  opt_switch_sections CLOSE_BRACE
 	  {
 		$$ = new Switch ((Expression) $3, (ExplicitBlock) current_block.Explicit, (List<SwitchSection>) $7, GetLocation ($1));	
 		end_block (GetLocation ($8));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 opt_switch_sections
 	
       {
 		Report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
 		$$ = new List<SwitchSection> ();
 	  }
 	| switch_sections
 	;
 
 switch_sections
 	
 	  {
 		var sections = new List<SwitchSection> (4);
 
 		sections.Add ((SwitchSection) $1);
 		$$ = sections;
 	  }
 	| switch_sections switch_section
 	  {
 		var sections = (List<SwitchSection>) $1;
 
 		sections.Add ((SwitchSection) $2);
 		$$ = sections;
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);	  
 		$$ = new List<SwitchSection> ();
 	  } 
 	;
 
 switch_section
 	
 	  {
 		current_block = current_block.CreateSwitchBlock (lexer.Location);
 	  }
  	  statement_list 
 	  {
 		$$ = new SwitchSection ((List<SwitchLabel>) $1, current_block);
 	  }
 	;
 
 switch_labels
 	
 	  {
 		var labels = new List<SwitchLabel> (4);
 
 		labels.Add ((SwitchLabel) $1);
 		$$ = labels;
 	  }
 	| switch_labels switch_label 
 	  {
 		var labels = (List<SwitchLabel>) ($1);
 		labels.Add ((SwitchLabel) $2);
 
 		$$ = labels;
 	  }
 	;
 
 switch_label
 	
 	 {
 	 	$$ = new SwitchLabel ((Expression) $2, GetLocation ($1));
 	 	lbag.AddLocation ($$, GetLocation ($3));
 	 }
 	| DEFAULT_COLON
 	  {
 		$$ = new SwitchLabel (null, GetLocation ($1));
 	  }
 	;
 
 iteration_statement
 	
 	| do_statement
 	| for_statement
 	| foreach_statement
 	;
 
 while_statement
 	
 	  {
 		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($5));
 	  
 		$$ = new While ((BooleanExpression) $3, (Statement) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 do_statement
 	
 	  WHILE open_parens_any boolean_expression CLOSE_PARENS SEMICOLON
 	  {
 		$$ = new Do ((Statement) $2, (BooleanExpression) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($3), GetLocation ($4), GetLocation ($6), GetLocation ($7));
 	  }
 	;
 
 for_statement
 	
 	  {
 		start_block (GetLocation ($2));
 		current_block.IsCompilerGenerated = true;
 	  }
 	  for_statement_cont
 	  {
 		$$ = $4;
 	  }
 	;
 	
 // Has to use be extra rule to recover started block
 for_statement_cont
 	
 	  opt_for_condition SEMICOLON
 	  opt_for_iterator CLOSE_PARENS
 	  embedded_statement
 	  {
 		if ($7 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($7));
 	  
 		For f = new For ((Statement) $1, (BooleanExpression) $3, (Statement) $5, (Statement) $7, GetLocation ($-2));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, current_block.StartLocation, GetLocation ($2), GetLocation ($4), GetLocation ($6));
 
 		$$ = end_block (GetLocation ($2));
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = end_block (current_block.StartLocation);
 	  }
 	;
 
 opt_for_initializer
 	
 	| for_initializer	
 	;
 
 for_initializer
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) $1, li);
 	  }
 	  opt_local_variable_initializer opt_variable_declarators
 	  {
 		$$ = current_variable;
 		current_variable = null;
 	  }
 	| statement_expression_list
 	;
 
 opt_for_condition
 	
 	| boolean_expression
 	;
 
 opt_for_iterator
 	
 	| for_iterator
 	;
 
 for_iterator
 	
 	;
 
 statement_expression_list
 	
 	| statement_expression_list COMMA statement_expression
 	  {
 	  	var sl = $1 as StatementList;
 	  	if (sl == null) {
 	  		sl = new StatementList ((Statement) $1, (Statement) $3);
 			lbag.AddStatement (sl, GetLocation ($2));
 	  	} else {
 	  		sl.Add ((Statement) $3);
 	  		lbag.AppendTo (sl, GetLocation ($2));
 	  	}
 	  		
 		$$ = sl;
 	  }
 	;
 
 foreach_statement
 	
 	  {
 		Report.Error (230, GetLocation ($1), "Type and identifier are both required in a foreach statement");
 		$$ = null;
 	  }
 	| FOREACH open_parens_any type IDENTIFIER IN expression CLOSE_PARENS 
 	  {
 		start_block (GetLocation ($2));
 		current_block.IsCompilerGenerated = true;
 		
 		var lt = (Tokenizer.LocatedToken) $4;
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.ForeachVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		$$ = li;
 	  } 
 	  embedded_statement
 	  {
 		if ($9 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($9));
 	  
 		Foreach f = new Foreach ((Expression) $3, (LocalVariable) $8, (Expression) $6, (Statement) $9, GetLocation ($1));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, GetLocation ($2), GetLocation ($5), GetLocation ($7));
 		$$ = end_block (GetLocation ($7));
 	  }
 	;
 
 jump_statement
 	
 	| continue_statement
 	| goto_statement
 	| return_statement
 	| throw_statement
 	| yield_statement
 	;
 
 break_statement
 	
 	  {
 		$$ = new Break (GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2));
 	  }
 	;
 
 continue_statement
 	
 	  {
 		$$ = new Continue (GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2));
 	  }
 	;
 
 goto_statement
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		$$ = new Goto (lt.Value, lt.Location);
 		lbag.AddStatement ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	| GOTO CASE constant_expression SEMICOLON
 	  {
 		$$ = new GotoCase ((Expression) $3, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	| GOTO DEFAULT SEMICOLON 
 	  {
 		$$ = new GotoDefault (GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($3));
 	  }
 	; 
 
 return_statement
 	
 	  {
 		$$ = new Return ((Expression) $2, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($3));
 	  }
 	;
 
 throw_statement
 	
 	  {
 		$$ = new Throw ((Expression) $2, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($3));
 	  }
 	;
 
 yield_statement 
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if ($3 == null) {
 			Report.Error (1627, GetLocation ($4), "Expression expected after yield return");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		$$ = new Yield ((Expression) $3, lt.Location);
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	| IDENTIFIER BREAK SEMICOLON
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		$$ = new YieldBreak (lt.Location);
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($3));
 	  }
 	;
 
 opt_expression
 	
 	| expression
 	;
 
 try_statement
 	
 	  {
 		$$ = new TryCatch ((Block) $2, (List<Catch>) $3, GetLocation ($1), false);
 	  }
 	| TRY block FINALLY block
 	  {
 		$$ = new TryFinally ((Statement) $2, (Block) $4, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($3));
 	  }
 	| TRY block catch_clauses FINALLY block
 	  {
 		$$ = new TryFinally (new TryCatch ((Block) $2, (List<Catch>) $3, GetLocation ($1), true), (Block) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($4));
 	  }
 	| TRY block error 
 	  {
 		Report.Error (1524, GetLocation ($1), "Expected catch or finally");
 		$$ = null;
 	  }
 	;
 
 catch_clauses
 	
 	  {
 		var l = new List<Catch> (2);
 
 		l.Add ((Catch) $1);
 		$$ = l;
 	  }
 	| catch_clauses catch_clause
 	  {
 		var l = (List<Catch>) $1;
 		
 		Catch c = (Catch) $2;
 		if (l [0].IsGeneral) {
 			Report.Error (1017, c.loc, "Try statement already has an empty catch block");
 		} else {
 			if (c.IsGeneral)
 				l.Insert (0, c);
 			else
 				l.Add (c);
 		}
 		
 		$$ = l;
 	  }
 	;
 
 opt_identifier
 	
 	| IDENTIFIER
 	;
 
 catch_clause 
 	
 	  {
 		$$ = new Catch ((Block) $2, GetLocation ($1));
 	  }
 	| CATCH open_parens_any type opt_identifier CLOSE_PARENS
 	  {
 		start_block (GetLocation ($2));
 		var c = new Catch (current_block, GetLocation ($1));
 		c.TypeExpression = (FullNamedExpression) $3;
 
 		if ($4 != null) {
 			var lt = (Tokenizer.LocatedToken) $4;
 			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
 			current_block.AddLocalName (c.Variable);
 		}
 		
 		lbag.AddLocation (c, GetLocation ($2), GetLocation ($5));
 		$$ = c;
 	  }
 	  block_prepared
 	  {
 		$$ = $6;
 	  }
 	| CATCH open_parens_any error
 	  {
 	  	if (yyToken == Token.CLOSE_PARENS) {
 			Report.Error (1015, lexer.Location,
 				"A type that derives from `System.Exception', `object', or `string' expected");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 		
 		$$ = new Catch (null, GetLocation ($1));
 	  }
 	;
 
 checked_statement
 	
 	  {
 		$$ = new Checked ((Block) $2, GetLocation ($1));
 	  }
 	;
 
 unchecked_statement
 	
 	  {
 		$$ = new Unchecked ((Block) $2, GetLocation ($1));
 	  }
 	;
 
 unsafe_statement
 	
 	  {
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation ($1));
 	  } block {
 		$$ = new Unsafe ((Block) $3, GetLocation ($1));
 	  } block {
 		$$ = new Unsafe ((Block) $3, GetLocation ($1));
 	  }
 	;
 
 lock_statement
 	
 	  {
 		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($5));
 	  
 		$$ = new Lock ((Expression) $3, (Statement) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 fixed_statement
 	
 	  {
 	    start_block (GetLocation ($2));
 	    
 		var lt = (Tokenizer.LocatedToken) $4;
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.FixedVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Fixed.VariableDeclaration ((FullNamedExpression) $3, li);
 	  }
 	  using_or_fixed_variable_initializer opt_variable_declarators CLOSE_PARENS
 	  {
 		$$ = current_variable;
 		current_variable = null;
 	  }
 	  embedded_statement
 	  {
 		if ($10 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($10));
 	  
 		Fixed f = new Fixed ((Fixed.VariableDeclaration) $9, (Statement) $10, GetLocation ($1));
 		current_block.AddStatement (f);
 		$$ = end_block (GetLocation ($8));
 	  }
 	;
 
 using_statement
 	
 	  {
 	    start_block (GetLocation ($2));
 	    
 		var lt = (Tokenizer.LocatedToken) $4;
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.UsingVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Using.VariableDeclaration ((FullNamedExpression) $3, li);
 	  }
 	  using_or_fixed_variable_initializer opt_variable_declarators CLOSE_PARENS
 	  {
 		$$ = current_variable;	  
 		current_variable = null;
 	  }
 	  embedded_statement
 	  {
 		if ($10 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($10));
 	  
 		Using u = new Using ((Using.VariableDeclaration) $9, (Statement) $10, GetLocation ($1));
 		current_block.AddStatement (u);
 		$$ = end_block (GetLocation ($8));
 	  }
 	| USING open_parens_any expression CLOSE_PARENS embedded_statement
 	  {
 		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($5));
 	  
 		Using u = new Using ((Expression) $3, (Statement) $5, GetLocation ($1));
 		lbag.AddStatement (u, GetLocation ($2), GetLocation ($4));
 		$$ = u;
 	  }
 	;
 	
 using_or_fixed_variable_initializer
 	
 	  {
 		Report.Error (210, lexer.Location, "You must provide an initializer in a fixed or using statement declaration");
 	  }
 	| ASSIGN variable_initializer
 	  {
 		current_variable.Initializer = (Expression) $2;
 		$$ = current_variable;
 	  }
 	;
 
 
 // LINQ
 
 query_expression
 	
 	  {
 		lexer.query_parsing = false;
 			
 		Linq.AQueryClause from = $1 as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)$2;
 		$$ = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	| nested_from_clause query_body
 	  {
 		Linq.AQueryClause from = $1 as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)$2;
 		$$ = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }	
 
 	// Bubble up COMPLETE_COMPLETION productions
 	| first_from_clause COMPLETE_COMPLETION {
 	        lexer.query_parsing = false;
 		$$ = $1;
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	| nested_from_clause COMPLETE_COMPLETION {
 	        $$ = $1;
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	;
 	
 first_from_clause
 	
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) $2;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$4, rv, GetLocation ($1)));
 	  }
 	| FROM_FIRST type IDENTIFIER IN expression
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) $3;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$5, rv, GetLocation ($1)) {
 				IdentifierType = (FullNamedExpression)$2
 			}
 		);
 	  }
 	;
 
 nested_from_clause
 	
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) $2;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$4, rv, GetLocation ($1)));
 	  }
 	| FROM type IDENTIFIER IN expression
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) $3;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$5, rv, GetLocation ($1)) {
 				IdentifierType = (FullNamedExpression)$2
 			}
 		);
 	  }
 	;
 	
 from_clause
 	
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)$5, GetLocation ($1));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }	  
 	| FROM type IDENTIFIER IN
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 
 		$$ = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)$6, GetLocation ($1)) {
 			IdentifierType = (FullNamedExpression)$2
 		};
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
 	;	
 
 query_body
 	
 	  {
 	  	Linq.AQueryClause head = (Linq.AQueryClause)$2;
 		
 		if ($3 != null)
 			head.Next = (Linq.AQueryClause)$3;
 				
 		if ($1 != null) {
 			Linq.AQueryClause clause = (Linq.AQueryClause)$1;
 			clause.Tail.Next = head;
 			head = clause;
 		}
 		
 		$$ = head;
 	  }
 	| opt_query_body_clauses COMPLETE_COMPLETION
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 	
 select_or_group_clause
 	
 	  {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		$$ = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)$3, GetLocation ($1));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	| GROUP
 	  {
 	  	if (linq_clause_blocks == null)
 	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
 	  }
 	  expression
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  BY expression
 	  {
 		$$ = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)$3, linq_clause_blocks.Pop (), (Expression)$6, GetLocation ($1));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	;
 	
 opt_query_body_clauses
 	
 	| query_body_clauses
 	;
 	
 query_body_clauses
 	
 	| query_body_clauses query_body_clause
 	  {
 		((Linq.AQueryClause)$1).Tail.Next = (Linq.AQueryClause)$2;
 		$$ = $1;
 	  }
 	;
 	
 query_body_clause
 	
 	| let_clause 
 	| where_clause
 	| join_clause
 	| orderby_clause
 	;
 	
 let_clause
 	
 	  {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 	  	$$ = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)$5, GetLocation ($1));
 	  	
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
 	;
 
 where_clause
 	
 	  {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		$$ = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)$3, GetLocation ($1));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	;
 	
 join_clause
 	
 	  {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
 	  expression ON
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
 	  expression EQUALS
 	  {
 		current_block.AddStatement (new ContextualReturn ((Expression) $8));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression opt_join_into
 	  {
 		current_block.AddStatement (new ContextualReturn ((Expression) $11));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 
 		var lt = (Tokenizer.LocatedToken) $2;	
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if ($12 == null) {
 			into = sn;
 	  		$$ = new Linq.Join (block, sn, (Expression)$5, outer_selector, (Linq.QueryBlock) current_block, GetLocation ($1));
 		} else {
 			//
 			// Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions
 			//
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 			
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) $12;
 			into = new Linq.RangeVariable (lt.Value, lt.Location);
 
 			$$ = new Linq.GroupJoin (block, sn, (Expression)$5, outer_selector, (Linq.QueryBlock) current_block, into, GetLocation ($1));	
 		}
 
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);
 	  }
 	| JOIN type IDENTIFIER IN
 	  {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
 	  expression ON
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
 	  expression EQUALS
 	  {
 		current_block.AddStatement (new ContextualReturn ((Expression) $9));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression opt_join_into
 	  {
 		current_block.AddStatement (new ContextualReturn ((Expression) $12));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 		
 		var lt = (Tokenizer.LocatedToken) $3;
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if ($13 == null) {
 			into = sn;		
 	  		$$ = new Linq.Join (block, sn, (Expression)$6, outer_selector, (Linq.QueryBlock) current_block, GetLocation ($1)) {
 	  			IdentifierType = (FullNamedExpression)$2
 	  		};
 		} else {
 			//
 			// Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions
 			//
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 		
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) $13;
 			into = new Linq.RangeVariable (lt.Value, lt.Location); // TODO
 			
 			$$ = new Linq.GroupJoin (block, sn, (Expression)$6, outer_selector, (Linq.QueryBlock) current_block, into, GetLocation ($1)) {
 	  			IdentifierType = (FullNamedExpression)$2
 	  		};			
 		}
 		
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
 	  }
 	;
 	
 opt_join_into
 	
 	| INTO IDENTIFIER
 	  {
 		$$ = $2;
 	  }
 	;
 	
 orderby_clause
 	
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  orderings
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		$$ = $3;
 	  }
 	;
 	
 orderings
 	
 	| order_by COMMA
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  orderings_then_by
 	  {
 		((Linq.AQueryClause)$1).Next = (Linq.AQueryClause)$4;
 		$$ = $1;
 	  }
 	;
 	
 orderings_then_by
 	
 	| orderings_then_by COMMA
 	 {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, (Linq.QueryBlock) current_block, lexer.Location);	 
 	 }
 	 then_by
 	 {
 		((Linq.AQueryClause)$1).Tail.Next = (Linq.AQueryClause)$4;
 		$$ = $1;
 	 }
 	;	
 	
 order_by
 	
 	  {
 		$$ = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	| expression ASCENDING
 	  {
 		$$ = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	| expression DESCENDING
 	  {
 		$$ = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	;
 
 then_by
 	
 	  {
 		$$ = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	| expression ASCENDING
 	  {
 		$$ = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	| expression DESCENDING
 	  {
 		$$ = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }	
 	;
 
 
 opt_query_continuation
 	
 	| INTO IDENTIFIER
 	  {
 		// query continuation block is not linked with query block but with block
 		// before. This means each query can use same range variable names for
 		// different identifiers.
 
 		current_block.SetEndLocation (GetLocation ($1));
 		current_block = current_block.Parent;
 	
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
 	  }
 	  query_body
 	  {
 		var current_block = linq_clause_blocks.Pop ();	  
 		var lt = (Tokenizer.LocatedToken) $2;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
   		$$ = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation ($1)) {
   			next = (Linq.AQueryClause)$4
   		};
 	  }
 	;
 	
 //
 // Support for using the compiler as an interactive parser
 //
 // The INTERACTIVE_PARSER token is first sent to parse our
 // productions;  If the result is a Statement, the parsing
 // is repeated, this time with INTERACTIVE_PARSE_WITH_BLOCK
 // to setup the blocks in advance.
 //
 // This setup is here so that in the future we can add 
 // support for other constructs (type parsing, namespaces, etc)
 // that do not require a block to be setup in advance
 //
 
 interactive_parsing
 	
 	| EVAL_USING_DECLARATIONS_UNIT_PARSER using_directives opt_COMPLETE_COMPLETION
 	| EVAL_STATEMENT_PARSER { 
 	        Evaluator.LoadAliases (current_namespace);
 
 		push_current_class (new Class (current_namespace, current_class, new MemberName ("Class" + class_count++),
 			Modifiers.PUBLIC, null), null);
 
 		var baseclass_list = new List<FullNamedExpression> ();
 		baseclass_list.Add (new TypeExpression (Evaluator.InteractiveBaseClass, lexer.Location));
 		current_container.AddBasesForPart (current_class, baseclass_list);
 
 		// (ref object retval)
 		Parameter [] mpar = new Parameter [1];
 		mpar [0] = new Parameter (new TypeExpression (TypeManager.object_type, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);
 
 		ParametersCompiled pars = new ParametersCompiled (mpar);
 		current_local_parameters = pars;
 		Method method = new Method (
 			current_class,
 			null, // generic
 			new TypeExpression (TypeManager.void_type, Location.Null),
 			Modifiers.PUBLIC | Modifiers.STATIC,
 			new MemberName ("Host"),
 			pars,
 			null /* attributes */);
 
 		oob_stack.Push (method);
 	        ++lexer.parsing_block;
 		start_block (lexer.Location);
 	  }		
 	  interactive_statement_list opt_COMPLETE_COMPLETION
 	  {
 		--lexer.parsing_block;
 		Method method = (Method) oob_stack.Pop ();
 
 		method.Block = (ToplevelBlock) end_block(lexer.Location);
 		current_container.AddMethod (method);
 
 		--lexer.parsing_declaration;
 		InteractiveResult = pop_current_class ();
 		current_local_parameters = null;
 	  } 
 	| EVAL_COMPILATION_UNIT_PARSER {
 	        Evaluator.LoadAliases (current_namespace);
 	  }
 	  interactive_compilation_unit
         yyTop -= yyLen[yyN];
         yyState = yyStates[yyTop];
         int yyM = yyLhs[yyN];
         if (yyState == 0 && yyM == 0) {
           if (debug != null) debug.shift(0, yyFinal);
           yyState = yyFinal;
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
                debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
           }
           if (yyToken == 0) {
             if (debug != null) debug.accept(yyVal);
             return yyVal;
           }
           goto continue_yyLoop;
         }
         if (((yyN = yyGindex[yyM]) != 0) && ((yyN += yyState) >= 0)
             && (yyN < yyTable.Length) && (yyCheck[yyN] == yyState))
           yyState = yyTable[yyN];
         else
           yyState = yyDgoto[yyM];
         if (debug != null) debug.shift(yyStates[yyTop], yyState);
 	 goto continue_yyLoop;
       continue_yyDiscarded
       }
       /*yyDiscarded
         int yyN;
         if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
               debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
           }
           if ((yyN = yySindex[yyState]) != 0 && ((yyN += yyToken) >= 0)
               && (yyN < yyTable.Length) && (yyCheck[yyN] == yyToken)) {
             if (debug != null)
               debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
             yyState = yyTable[yyN];		// shift to yyN
             yyVal = yyLex.value();
             yyToken = -1;
             if (yyErrorFlag > 0) -- yyErrorFlag;
             goto continue_yyLoop;
           }
           if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
               && yyN < yyTable.Length && yyCheck[yyN] == yyToken)
             yyN = yyTable[yyN];			// reduce (yyN)
           else
             switch (yyErrorFlag) {
   
             case 0
               yyExpectingState = yyState;
               // yyerror(String.Format ("syntax error, got token `{0}'", yyname (yyToken)), yyExpecting(yyState));
               if (debug != null) debug.error("syntax error");
               if (yyToken == 0 /*eof*/ || yyToken == eof_token) throw new yyParser.yyUnexpectedEof ();
               goto case 1;
             case 1
               yyErrorFlag = 3;
               do {
                 if ((yyN = yySindex[yyStates[yyTop]]) != 0
                     && (yyN += Token.yyErrorCode) >= 0 && yyN < yyTable.Length
                     && yyCheck[yyN] == Token.yyErrorCode) {
                   if (debug != null)
                     debug.shift(yyStates[yyTop], yyTable[yyN], 3);
                   yyState = yyTable[yyN];
                   yyVal = yyLex.value();
                   goto continue_yyLoop;
                 }
                 if (debug != null) debug.pop(yyStates[yyTop]);
               } while (-- yyTop >= 0);
               if (debug != null) debug.reject();
               throw new yyParser.yyException("irrecoverable syntax error");
   
             case 3
               if (yyToken == 0) {
                 if (debug != null) debug.reject();
                 throw new yyParser.yyException("irrecoverable syntax error at end-of-file");
               }
               if (debug != null)
                 debug.discard(yyState, yyToken, yyname(yyToken),
   							yyLex.value());
               yyToken = -1;
               goto continue_yyDiscarded;		// leave stack alone
             }
         }
         int yyV = yyTop + 1-yyLen[yyN];
         if (debug != null)
           debug.reduce(yyState, yyStates[yyV-1], yyN, YYRules.getRule (yyN), yyLen[yyN]);
         yyVal = yyV > yyTop ? null 
         switch (yyN) {
 case 5
 #line 375 "cs-parser.jay"
   { Lexer.CompleteOnEOF = false; }
   break;
 case 7
 #line 380 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 8
 #line 384 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 16
 #line 407 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "alias"){
 			syntax_error (lt.Location, "`alias' expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (lt.Location, "external alias");
 		} else {
 			lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop]; 
 			current_namespace.AddUsingExternalAlias (lt.Value, lt.Location, Report);
 		}
 	  }
   break;
 case 17
 #line 420 "cs-parser.jay"
   {
 	  	syntax_error (GetLocation (yyVals[-1+yyTop]), "`alias' expected");   /* TODO
 	  }
   break;
 case 20
 #line 432 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 21
 #line 437 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 22
 #line 445 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		current_namespace.AddUsingAlias (lt.Value, (MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 23
 #line 450 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 24
 #line 458 "cs-parser.jay"
   {
 		current_namespace.AddUsing ((MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 25
 #line 470 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (yyVals[-2+yyTop] != null) {
 			Report.Error(1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
 		}
 
 		current_namespace = new NamespaceEntry (module,
 			current_namespace, file, name.GetName ());
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 26
 #line 483 "cs-parser.jay"
   { 
 		current_namespace = current_namespace.Parent;
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 27
 #line 492 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName (lt.Value, lt.Location);
 	  }
   break;
 case 28
 #line 497 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 29
 #line 502 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new MemberName ("<invalid>", lexer.Location);
 	  }
   break;
 case 34
 #line 520 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (name.TypeArguments != null)
 			syntax_error (lexer.Location, "namespace name expected");
 
 		yyVal = name;
 	  }
   break;
 case 35
 #line 532 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 45
 #line 564 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			DeclSpace ds = (DeclSpace)yyVals[0+yyTop];
 
 			if ((ds.ModFlags & (Modifiers.PRIVATE|Modifiers.PROTECTED)) != 0){
 				Report.Error (1527, ds.Location, 
 				"Namespace elements cannot be explicitly declared as private, protected or protected internal");
 			}
 		}
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 46
 #line 576 "cs-parser.jay"
   {
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 47
 #line 580 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	 }
   break;
 case 53
 #line 606 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			Attributes attrs = (Attributes)yyVals[0+yyTop];
 			if (global_attrs_enabled) {
 				module.AddAttributes (attrs.Attrs, current_namespace);
 			} else {
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 			}
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 54
 #line 623 "cs-parser.jay"
   {
 		global_attrs_enabled = false;
 		yyVal = null;
       }
   break;
 case 55
 #line 628 "cs-parser.jay"
   { 
 		global_attrs_enabled = false;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 56
 #line 637 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect, current_namespace);
 					yyVal = null;
 				} else {
 					yyVal = new Attributes (sect);
 				}
 				if (yyVal == null) {
 					if (RootContext.Documentation != null) {
 						Lexer.check_incorrect_doc_comment ();
 						Lexer.doc_state =
 							XmlCommentState.Allowed;
 					}
 				}
 			} else {
 				yyVal = new Attributes (sect);
 			}		
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 57
 #line 664 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			Attributes attrs = yyVals[-1+yyTop] as Attributes;
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect);
 					yyVal = null;
 				} else {
 					if (attrs == null)
 						attrs = new Attributes (sect);
 					else
 						attrs.AddAttributes (sect);			
 				}
 			} else {
 				if (attrs == null)
 					attrs = new Attributes (sect);
 				else
 					attrs.AddAttributes (sect);
 			}		
 			yyVal = attrs;
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 58
 #line 695 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
  	  }
   break;
 case 59
 #line 699 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 60
 #line 706 "cs-parser.jay"
   {
 		current_attr_target = (string)yyVals[-1+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 61
 #line 714 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = CheckAttributeTarget (lt.Value, lt.Location);
 	  }
   break;
 case 62
 #line 718 "cs-parser.jay"
   { yyVal = "event"; }
   break;
 case 63
 #line 719 "cs-parser.jay"
   { yyVal = "return"; }
   break;
 case 64
 #line 721 "cs-parser.jay"
   {
 		string name = GetTokenName (yyToken);
 		yyVal = CheckAttributeTarget (name, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 65
 #line 729 "cs-parser.jay"
   {
 		yyVal = new List<Attribute> (4) { (Attribute) yyVals[0+yyTop] };
 	  }
   break;
 case 66
 #line 733 "cs-parser.jay"
   {
 		var attrs = (List<Attribute>) yyVals[-2+yyTop];
 		attrs.Add ((Attribute) yyVals[0+yyTop]);
 
 		yyVal = attrs;
 	  }
   break;
 case 67
 #line 743 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 68
 #line 747 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		MemberName mname = (MemberName) yyVals[-2+yyTop];
 		if (mname.IsGeneric) {
 			Report.Error (404, lexer.Location,
 				      "'<' unexpected
 		}
 
 		Arguments [] arguments = (Arguments []) yyVals[0+yyTop];
 		ATypeNameExpression expr = mname.GetTypeExpression ();
 
 		if (current_attr_target == String.Empty)
 			yyVal = null;
 		else if (global_attrs_enabled && (current_attr_target == "assembly" || current_attr_target == "module"))
 			/* FIXME
 			yyVal = new GlobalAttribute (current_namespace, current_attr_target,
 						  expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 		else
 			yyVal = new Attribute (current_attr_target, expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 	  }
   break;
 case 69
 #line 770 "cs-parser.jay"
   { /* reserved attribute name or identifier
   break;
 case 70
 #line 774 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 71
 #line 776 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 72
 #line 783 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 73
 #line 785 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = new Arguments [] { a, null };
 	  }
   break;
 case 74
 #line 791 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);  
 		yyVal = new Arguments [] { null, a };
 	  }
   break;
 case 75
 #line 797 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] != null) {
 			Report.Error (1016, ((Argument) yyVals[0+yyTop]).Expr.Location, "Named attribute arguments must appear after the positional arguments");
 			o [0] = new Arguments (4);
 		}
 		
 		Arguments args = ((Arguments) o [0]);
 		if (args.Count > 0 && !(yyVals[0+yyTop] is NamedArgument) && args [args.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 		
 		args.Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 76
 #line 811 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] == null) {
 			o [1] = new Arguments (4);
 		}
 
 		((Arguments) o [1]).Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 77
 #line 823 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 79
 #line 831 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 80
 #line 835 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop]);	  
 	  }
   break;
 case 81
 #line 844 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "named argument");
 			
 		/* Avoid boxing in common case (no modifier)*/
 		var arg_mod = yyVals[-1+yyTop] == null ? Argument.AType.None 
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop], arg_mod);
 	  }
   break;
 case 82
 #line 857 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 83
 #line 859 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Ref;
 	  }
   break;
 case 84
 #line 863 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Out;
 	  }
   break;
 case 99
 #line 891 "cs-parser.jay"
   {
 		Report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
 			GetSymbolName (yyToken));
 		yyVal = null;
 		lexer.parsing_generic_declaration = false;
 	  }
   break;
 case 100
 #line 904 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 101
 #line 908 "cs-parser.jay"
   { 
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Struct (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 102
 #line 914 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null)
 			current_container.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 103
 #line 925 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 104
 #line 931 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 105
 #line 936 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	  }
   break;
 case 106
 #line 943 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 107
 #line 948 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 122
 #line 985 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var mod = (Modifiers) yyVals[-3+yyTop];
 		current_field = new Const (current_class, (FullNamedExpression) yyVals[-1+yyTop], mod, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 		current_container.AddConstant ((Const) current_field);
 		
 		if ((mod & Modifiers.STATIC) != 0) {
 			Report.Error (504, current_field.Location, "The constant `{0}' cannot be marked static", current_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_field;
 	  }
   break;
 case 123
 #line 998 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_field = null;
 	  }
   break;
 case 126
 #line 1017 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 127
 #line 1021 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 128
 #line 1028 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 129
 #line 1037 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 130
 #line 1041 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 131
 #line 1046 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 		yyVal = null;
 	  }
   break;
 case 134
 #line 1061 "cs-parser.jay"
   {
 	  	lexer.parsing_generic_declaration = false;
 
 		FullNamedExpression type = (FullNamedExpression) yyVals[-1+yyTop];
 		if (type.Type == TypeManager.void_type)
 			Report.Error (670, GetLocation (yyVals[-1+yyTop]), "Fields cannot have void type");
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new Field (current_class, type, (Modifiers) yyVals[-2+yyTop], new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-3+yyTop]);
 		current_container.AddField (current_field);
 		yyVal = current_field;
 	  }
   break;
 case 135
 #line 1076 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 			
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 		current_field = null;
 	  }
   break;
 case 136
 #line 1089 "cs-parser.jay"
   { 
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "fixed size buffers");
 
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new FixedField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop],
 			new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 			
 		current_container.AddField (current_field);
 	  }
   break;
 case 137
 #line 1100 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 	    }
 
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];	    
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 	    current_field = null;
 	  }
   break;
 case 138
 #line 1115 "cs-parser.jay"
   {
 		Report.Error (1641, GetLocation (yyVals[-1+yyTop]), "A fixed size buffer field must have the array size specifier after the field name");
 	  }
   break;
 case 140
 #line 1123 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 141
 #line 1129 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_field.Initializer = (Expression) yyVals[0+yyTop];
 		end_block (lexer.Location);
 		current_local_parameters = null;
 	  }
   break;
 case 144
 #line 1144 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 145
 #line 1148 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 146
 #line 1155 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 147
 #line 1161 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 148
 #line 1165 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 151
 #line 1180 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 152
 #line 1184 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 153
 #line 1191 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];	  
 		yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 154
 #line 1200 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 155
 #line 1204 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 156
 #line 1210 "cs-parser.jay"
   {
 		Report.Error (443, lexer.Location, "Value or constant expected");
 		yyVal = null;
 	  }
   break;
 case 159
 #line 1220 "cs-parser.jay"
   {
 		/* It has to be here for the parent to safely restore artificial block*/
 	  	Error_SyntaxError (yyToken);
 	  	yyVal = null;
 	  }
   break;
 case 160
 #line 1228 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 161
 #line 1233 "cs-parser.jay"
   {
 		Method method = (Method) yyVals[-2+yyTop];
 		method.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (method);
 		
 		if (current_container.Kind == MemberKind.Interface && method.Block != null) {
 			Report.Error (531, method.Location, "`{0}'
 		}
 
 		current_local_parameters = null;
 
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 162
 #line 1254 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 163
 #line 1258 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 164
 #line 1262 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 						     (FullNamedExpression) yyVals[-7+yyTop], current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		} else if (yyVals[0+yyTop] != null) {
 			Report.Error (80, GetLocation (yyVals[0+yyTop]),
 				"Constraints are not allowed on non-generic declarations");
 		}
 
 		Method method = new Method (current_class, generic, (FullNamedExpression) yyVals[-7+yyTop], (Modifiers) yyVals[-8+yyTop],
 				     name, current_local_parameters, (Attributes) yyVals[-9+yyTop]);
 				     
 		if (yyVals[0+yyTop] != null && ((method.ModFlags & Modifiers.OVERRIDE) != 0 || method.IsExplicitImpl)) {
 			Report.Error (460, method.Location,
 				"`{0}'
 				method.GetSignatureForError ());
 		}
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 165
 #line 1299 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 166
 #line 1303 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 167
 #line 1307 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		if (yyVals[-1+yyTop] != null && name.TypeArguments == null)
 			Report.Error (80, lexer.Location,
 				      "Constraints are not allowed on non-generic declarations");
 
 		Method method;
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 				new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		}
 
 		var modifiers = (Modifiers) yyVals[-9+yyTop];
 
 
 		const Modifiers invalid_partial_mod = Modifiers.AccessibilityMask | Modifiers.ABSTRACT | Modifiers.EXTERN |
 			Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.SEALED | Modifiers.VIRTUAL;
 
 		if ((modifiers & invalid_partial_mod) != 0) {
 			Report.Error (750, name.Location, "A partial method cannot define access modifier or " +
        			"any of abstract, extern, new, override, sealed, or virtual modifiers");
 			modifiers &= ~invalid_partial_mod;
 		}
 
 		if ((current_class.ModFlags & Modifiers.PARTIAL) == 0) {
 			Report.Error (751, name.Location, "A partial method must be declared within a " +
        			"partial class or partial struct");
 		}
 		
 		modifiers |= Modifiers.PARTIAL | Modifiers.PRIVATE;
 		
 		method = new Method (current_class, generic, new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				     modifiers, name, current_local_parameters, (Attributes) yyVals[-10+yyTop]);
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		/* TODO
 		StoreModifierLocation (Modifiers.PARTIAL, GetLocation (yyVals[-8+yyTop]));
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 168
 #line 1362 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		Report.Error (1585, name.Location, 
 			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) yyVals[-4+yyTop]));
 
 		Method method = new Method (current_class, null, (FullNamedExpression) yyVals[-5+yyTop],
 					    0, name, (ParametersCompiled) yyVals[-1+yyTop], (Attributes) yyVals[-7+yyTop]);
 
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		yyVal = method;
 	  }
   break;
 case 170
 #line 1381 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 171
 #line 1385 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 173
 #line 1391 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 	  	yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 174
 #line 1396 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = new ParametersCompiled (pars_list.ToArray ()); 
 	  }
   break;
 case 175
 #line 1403 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[0+yyTop])));
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 176
 #line 1409 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[-2+yyTop] } );			
 	  }
   break;
 case 177
 #line 1416 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 178
 #line 1426 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[-2+yyTop])) }, true);
 	  }
   break;
 case 179
 #line 1432 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 180
 #line 1441 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[0+yyTop] } );
 	  }
   break;
 case 181
 #line 1445 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[0+yyTop])) }, true);
 	  }
   break;
 case 182
 #line 1449 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 183
 #line 1457 "cs-parser.jay"
   {
 		parameters_bucket.Clear ();
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		parameters_bucket.Add (p);
 		
 		default_parameter_used = p.HasDefaultValue;
 		yyVal = parameters_bucket;
 	  }
   break;
 case 184
 #line 1466 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		if (p != null) {
 			if (p.HasExtensionMethodModifier)
 				Report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
 			else if (!p.HasDefaultValue && default_parameter_used)
 				Report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");
 
 			default_parameter_used |= p.HasDefaultValue;
 			pars.Add (p);
 			
 			lbag.AddLocation (p, GetLocation (yyVals[-1+yyTop]));
 		}
 		
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 185
 #line 1490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 186
 #line 1498 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		Report.Error (1552, lt.Location, "Array type specifier, [], must appear before parameter name");
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Parameter.Modifier) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop], lt.Location);
 	  }
   break;
 case 187
 #line 1507 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  	Location l = GetLocation (yyVals[0+yyTop]);
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], "NeedSomeGeneratorHere", (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], l);
 	  }
   break;
 case 188
 #line 1517 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 189
 #line 1521 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		if (RootContext.Version <= LanguageVersion.V_3) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "optional parameter");
 		}
 		
 		Parameter.Modifier mod = (Parameter.Modifier) yyVals[-5+yyTop];
 		if (mod != Parameter.Modifier.NONE) {
 			switch (mod) {
 			case Parameter.Modifier.REF
 			case Parameter.Modifier.OUT
 				Report.Error (1741, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 				
 			case Parameter.Modifier.This
 				Report.Error (1743, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 			default
 				throw new NotImplementedException (mod.ToString ());
 			}
 				
 			mod = Parameter.Modifier.NONE;
 		}
 		
 		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
 			Report.Error (1065, GetLocation (yyVals[-2+yyTop]), "Optional parameter is not valid in this context");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-4+yyTop], lt.Value, mod, (Attributes) yyVals[-6+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 		
 		if (yyVals[0+yyTop] != null)
 			((Parameter) yyVal).DefaultValue = new DefaultParameterValueExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 190
 #line 1560 "cs-parser.jay"
   { yyVal = Parameter.Modifier.NONE; }
   break;
 case 192
 #line 1566 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 193
 #line 1570 "cs-parser.jay"
   {
 		Parameter.Modifier p2 = (Parameter.Modifier)yyVals[0+yyTop];
   		Parameter.Modifier mod = (Parameter.Modifier)yyVals[-1+yyTop] | p2;
   		if (((Parameter.Modifier)yyVals[-1+yyTop] & p2) == p2) {
   			Error_DuplicateParameterModifier (lexer.Location, p2);
   		} else {
 	  		switch (mod & ~Parameter.Modifier.This) {
   				case Parameter.Modifier.REF
 					Report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
   					break;
    				case Parameter.Modifier.OUT
 					Report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
   					break;
   				default
  					Report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
  					break;
  			}
   		}
   		yyVal = mod;
 	  }
   break;
 case 194
 #line 1594 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
 	  		Error_ParameterModifierNotValid ("ref", GetLocation (yyVals[0+yyTop]));
 	  		
 	  	yyVal = Parameter.Modifier.REF;
 	  }
   break;
 case 195
 #line 1601 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
 	  		Error_ParameterModifierNotValid ("out", GetLocation (yyVals[0+yyTop]));
 	  
 	  	yyVal = Parameter.Modifier.OUT;
 	  }
   break;
 case 196
 #line 1608 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.This) == 0)
 	  		Error_ParameterModifierNotValid ("this", GetLocation (yyVals[0+yyTop]));
 
 	  	if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "extension methods");
 	  			
 		yyVal = Parameter.Modifier.This;
 	  }
   break;
 case 197
 #line 1621 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 198
 #line 1626 "cs-parser.jay"
   {
 		Report.Error (1751, GetLocation (yyVals[-4+yyTop]), "Cannot specify a default value for a parameter array");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Attributes) yyVals[-5+yyTop], lt.Location);		
 	  }
   break;
 case 199
 #line 1633 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 200
 #line 1641 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.Params) == 0)
 			Report.Error (1670, (GetLocation (yyVals[0+yyTop])), "The `params' modifier is not allowed in current context");
 	  }
   break;
 case 201
 #line 1646 "cs-parser.jay"
   {
 		Parameter.Modifier mod = (Parameter.Modifier)yyVals[0+yyTop];
 		if ((mod & Parameter.Modifier.This) != 0) {
 			Report.Error (1104, GetLocation (yyVals[-1+yyTop]), "The parameter modifiers `this' and `params' cannot be used altogether");
 		} else {
 			Report.Error (1611, GetLocation (yyVals[-1+yyTop]), "The params parameter cannot be declared as ref or out");
 		}	  
 	  }
   break;
 case 202
 #line 1655 "cs-parser.jay"
   {
 		Error_DuplicateParameterModifier (GetLocation (yyVals[-1+yyTop]), Parameter.Modifier.PARAMS);
 	  }
   break;
 case 203
 #line 1662 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Arglist) == 0)
 	  		Report.Error (1669, GetLocation (yyVals[0+yyTop]), "__arglist is not valid in this context");
 	  }
   break;
 case 204
 #line 1673 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			tmpComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 205
 #line 1678 "cs-parser.jay"
   {
 		current_property = new Property (current_class, (FullNamedExpression) yyVals[-3+yyTop], (Modifiers) yyVals[-4+yyTop],
 			(MemberName) yyVals[-2+yyTop], (Attributes) yyVals[-5+yyTop]);
 			
 		if (current_property.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (547, GetLocation (yyVals[-3+yyTop]), "`{0}'
 			
 		current_container.AddProperty ((Property)current_property);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[0+yyTop]));
 		
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 206
 #line 1691 "cs-parser.jay"
   {
 		lexer.PropertyParsing = false;
 		
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();				
 	  }
   break;
 case 207
 #line 1698 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_property, GetLocation (yyVals[0+yyTop]));
 		current_property = null;
 	  }
   break;
 case 208
 #line 1708 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 209
 #line 1712 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  
 		Indexer indexer = new Indexer (current_class, (FullNamedExpression) yyVals[-6+yyTop],
 			(MemberName)yyVals[-5+yyTop], (Modifiers) yyVals[-7+yyTop], (ParametersCompiled) yyVals[-2+yyTop], (Attributes) yyVals[-8+yyTop]);
 			
 		current_property = indexer;
 
   		current_container.AddIndexer (indexer);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
   		
 		if (indexer.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (620, GetLocation (yyVals[-6+yyTop]), "`{0}'
 
 		if (indexer.Parameters.IsEmpty) {
 			Report.Error (1551, GetLocation (yyVals[-4+yyTop]), "Indexers must have at least one parameter");
 		}
 
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 210
 #line 1738 "cs-parser.jay"
   {
 		  lexer.PropertyParsing = false;
 	  }
   break;
 case 211
 #line 1742 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();
 			
 		lbag.AppendToMember (current_property, GetLocation (yyVals[-1+yyTop]));
 		current_property = null;		
 	  }
   break;
 case 216
 #line 1758 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_BRACE) {
 	  		Report.Error (548, lexer.Location, "`{0}'
 		} else {
 			if (yyToken == Token.SEMICOLON)
 				Report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
 			else
 				Report.Error (1014, GetLocation (yyVals[0+yyTop]), "A get or set accessor expected");
 		}
 	  }
   break;
 case 217
 #line 1772 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 	  
 		if (current_property.Get != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 		
 		if (current_property is Indexer) {
 			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop], ((Indexer)current_property).ParameterInfo.Clone (),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Get = new Property.GetMethod (current_property,
 				(Modifiers) yyVals[-1+yyTop], (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}	
 	  
 		current_local_parameters = current_property.Get.ParameterInfo;	  
 		lbag.AddMember (current_property.Get, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 218
 #line 1794 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] != null) {
 	  		current_property.Get.Block = (ToplevelBlock) yyVals[0+yyTop];			
 	  	
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Get.Block.StartLocation,
 					"`{0}'
 			}		
 		}
 	  
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null)
 			if (Lexer.doc_state == XmlCommentState.Error)
 				Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 219
 #line 1815 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 		
 		if (current_property.Set != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 	  
 		if (current_property is Indexer) {
 			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop],
 				ParametersCompiled.MergeGenerated (compiler,
 				((Indexer)current_property).ParameterInfo, true, new Parameter (
 					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation (yyVals[0+yyTop])),
 					null),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Set = new Property.SetMethod (current_property, (Modifiers) yyVals[-1+yyTop], 
 				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation (yyVals[0+yyTop])),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}
 		
 		current_local_parameters = current_property.Set.ParameterInfo;	
 		lbag.AddMember (current_property.Set, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 220
 #line 1842 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {		
 			current_property.Set.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Set.Block.StartLocation,
 					"`{0}'
 			}
 		}
 		
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null
 			&& Lexer.doc_state == XmlCommentState.Error)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 222
 #line 1864 "cs-parser.jay"
   {
 		/* TODO
 	  	yyVal = null;
 	  }
   break;
 case 223
 #line 1869 "cs-parser.jay"
   {
 	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
 	  	yyVal = null;
 	  }
   break;
 case 224
 #line 1880 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 225
 #line 1884 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Interface (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 226
 #line 1891 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 227
 #line 1902 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 228
 #line 1908 "cs-parser.jay"
   {
 	    lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 229
 #line 1913 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  }
   break;
 case 234
 #line 1930 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 235
 #line 1934 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 240
 #line 1942 "cs-parser.jay"
   {
 	  	Report.Error (567, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain operators");
 	  }
   break;
 case 241
 #line 1946 "cs-parser.jay"
   {
 	  	Report.Error (526, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain contructors");
 	  }
   break;
 case 242
 #line 1950 "cs-parser.jay"
   {
 	  	Report.Error (524, GetLocation (yyVals[0+yyTop]), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
 	  }
   break;
 case 243
 #line 1957 "cs-parser.jay"
   {
 	  }
   break;
 case 244
 #line 1960 "cs-parser.jay"
   {
 		OperatorDeclaration decl = (OperatorDeclaration) yyVals[-2+yyTop];
 		if (decl != null) {
 			Operator op = new Operator (
 				current_class, decl.optype, decl.ret_type, (Modifiers) yyVals[-3+yyTop], 
 				current_local_parameters,
 				(ToplevelBlock) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop], decl.location);
 
 			if (RootContext.Documentation != null) {
 				op.DocComment = tmpComment;
 				Lexer.doc_state = XmlCommentState.Allowed;
 			}
 
 			/* Note again, checking is done in semantic analysis*/
 			current_container.AddOperator (op);
 
 			lbag.AddMember (op, mod_locations, lbag.GetLocations (decl));
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 246
 #line 1985 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 248
 #line 1991 "cs-parser.jay"
   {
 		Report.Error (590, GetLocation (yyVals[0+yyTop]), "User-defined operators cannot return void");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 249
 #line 1999 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 250
 #line 2003 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		Operator.OpType op = (Operator.OpType) yyVals[-4+yyTop];
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];
 		
 		int p_count = current_local_parameters.Count;
 		if (p_count == 1) {
 			if (op == Operator.OpType.Addition)
 				op = Operator.OpType.UnaryPlus;
 			else if (op == Operator.OpType.Subtraction)
 				op = Operator.OpType.UnaryNegation;
 		}
 		
 		if (IsUnaryOperator (op)) {
 			if (p_count == 2) {
 				Report.Error (1020, loc, "Overloadable binary operator expected");
 			} else if (p_count != 1) {
 				Report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
 					Operator.GetName (op));
 			}
 		} else {
 			if (p_count > 2) {
 				Report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
 					Operator.GetName (op));
 			} else if (p_count != 2) {
 				Report.Error (1019, loc, "Overloadable unary operator expected");
 			}
 		}
 		
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (op, (FullNamedExpression) yyVals[-6+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 252
 #line 2047 "cs-parser.jay"
   { yyVal = Operator.OpType.LogicalNot; }
   break;
 case 253
 #line 2048 "cs-parser.jay"
   { yyVal = Operator.OpType.OnesComplement; }
   break;
 case 254
 #line 2049 "cs-parser.jay"
   { yyVal = Operator.OpType.Increment; }
   break;
 case 255
 #line 2050 "cs-parser.jay"
   { yyVal = Operator.OpType.Decrement; }
   break;
 case 256
 #line 2051 "cs-parser.jay"
   { yyVal = Operator.OpType.True; }
   break;
 case 257
 #line 2052 "cs-parser.jay"
   { yyVal = Operator.OpType.False; }
   break;
 case 258
 #line 2054 "cs-parser.jay"
   { yyVal = Operator.OpType.Addition; }
   break;
 case 259
 #line 2055 "cs-parser.jay"
   { yyVal = Operator.OpType.Subtraction; }
   break;
 case 260
 #line 2057 "cs-parser.jay"
   { yyVal = Operator.OpType.Multiply; }
   break;
 case 261
 #line 2058 "cs-parser.jay"
   {  yyVal = Operator.OpType.Division; }
   break;
 case 262
 #line 2059 "cs-parser.jay"
   { yyVal = Operator.OpType.Modulus; }
   break;
 case 263
 #line 2060 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseAnd; }
   break;
 case 264
 #line 2061 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseOr; }
   break;
 case 265
 #line 2062 "cs-parser.jay"
   { yyVal = Operator.OpType.ExclusiveOr; }
   break;
 case 266
 #line 2063 "cs-parser.jay"
   { yyVal = Operator.OpType.LeftShift; }
   break;
 case 267
 #line 2064 "cs-parser.jay"
   { yyVal = Operator.OpType.RightShift; }
   break;
 case 268
 #line 2065 "cs-parser.jay"
   { yyVal = Operator.OpType.Equality; }
   break;
 case 269
 #line 2066 "cs-parser.jay"
   { yyVal = Operator.OpType.Inequality; }
   break;
 case 270
 #line 2067 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThan; }
   break;
 case 271
 #line 2068 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThan; }
   break;
 case 272
 #line 2069 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThanOrEqual; }
   break;
 case 273
 #line 2070 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThanOrEqual; }
   break;
 case 274
 #line 2075 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 275
 #line 2079 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 276
 #line 2094 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 277
 #line 2098 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 278
 #line 2113 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 279
 #line 2119 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	yyVal = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 280
 #line 2129 "cs-parser.jay"
   { 
 		Constructor c = (Constructor) yyVals[-1+yyTop];
 		c.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (RootContext.Documentation != null)
 			c.DocComment = ConsumeStoredComment ();
 
 		current_container.AddConstructor (c);
 
 		current_local_parameters = null;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 281
 #line 2148 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 282
 #line 2157 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];  
 		
 		/**/
 		/* start block here, so possible anonymous methods inside*/
 		/* constructor initializer can get correct parent block*/
 		/**/
 	  	start_block (lexer.Location);
 	  }
   break;
 case 283
 #line 2168 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-6+yyTop];
 		var mods = (Modifiers) yyVals[-7+yyTop];
 		ConstructorInitializer ci = (ConstructorInitializer) yyVals[0+yyTop];
 
 		Constructor c = new Constructor (current_class, lt.Value, mods,
 			(Attributes) yyVals[-8+yyTop], current_local_parameters, ci, lt.Location);
 		
 		if (lt.Value != current_container.MemberName.Name) {
 			Report.Error (1520, c.Location, "Class, struct, or interface method must have a return type");
 		} else if ((mods & Modifiers.STATIC) != 0) {
 			if ((mods & Modifiers.AccessibilityMask) != 0){
 				Report.Error (515, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			}
 			if (ci != null) {
 				Report.Error (514, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			
 			}
 		}
 		
 		lbag.AddMember (c, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 285
 #line 2199 "cs-parser.jay"
   { current_block = null; yyVal = null; }
   break;
 case 288
 #line 2209 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 289
 #line 2213 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorBaseInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 290
 #line 2219 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 291
 #line 2223 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorThisInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 292
 #line 2229 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 293
 #line 2237 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 		
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 294
 #line 2246 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		if (lt.Value != current_container.MemberName.Name){
 			Report.Error (574, lt.Location, "Name of destructor must match name of class");
 		} else if (current_container.Kind != MemberKind.Class){
 			Report.Error (575, lt.Location, "Only class types can contain destructor");
 		}
 		
 		Destructor d = new Destructor (current_class, (Modifiers) yyVals[-6+yyTop],
 			ParametersCompiled.EmptyReadOnlyParameters, (Attributes) yyVals[-7+yyTop], lt.Location);
 		if (RootContext.Documentation != null)
 			d.DocComment = ConsumeStoredComment ();
 		  
 		d.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (d);
 		lbag.AddMember (d, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		current_local_parameters = null;
 	  }
   break;
 case 295
 #line 2271 "cs-parser.jay"
   {
 		current_event_field = new EventField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop], (MemberName) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop]);
 		current_container.AddEvent (current_event_field);
 		
 		if (current_event_field.MemberName.Left != null) {
 			Report.Error (71, current_event_field.Location, "`{0}'
 			current_event_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_event_field;
 	  }
   break;
 case 296
 #line 2285 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AddMember (current_event_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_event_field = null;
 	  }
   break;
 case 297
 #line 2298 "cs-parser.jay"
   {
 		current_event = new EventProperty (current_class, (FullNamedExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-4+yyTop], (MemberName) yyVals[-1+yyTop], (Attributes) yyVals[-5+yyTop]);
 		current_container.AddEvent (current_event);
 		lbag.AddMember (current_event, mod_locations, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		
 		lexer.EventParsing = true;
 	  }
   break;
 case 298
 #line 2306 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface)
 			Report.Error (69, GetLocation (yyVals[-2+yyTop]), "Event in interface cannot have add or remove accessors");
 	  
 		lexer.EventParsing = false;
 	  }
   break;
 case 299
 #line 2313 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AppendToMember (current_event, GetLocation (yyVals[-1+yyTop]));
 	  	current_event = null;	
 		current_local_parameters = null;
 	  }
   break;
 case 301
 #line 2328 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 302
 #line 2332 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_event_field.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 305
 #line 2345 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 306
 #line 2349 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 307
 #line 2356 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 308
 #line 2362 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 309
 #line 2366 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 310
 #line 2375 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (68, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 		}
 		
 	  	if ((current_event_field.ModFlags & Modifiers.ABSTRACT) != 0) {
 			Report.Error (74, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 	  	}		
 	  }
   break;
 case 311
 #line 2387 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 314
 #line 2396 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 315
 #line 2401 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 316
 #line 2406 "cs-parser.jay"
   { 
 		Report.Error (1055, GetLocation (yyVals[0+yyTop]), "An add or remove accessor expected");
 		yyVal = null;
 	  }
   break;
 case 317
 #line 2414 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Add = new EventProperty.AddDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Add.ParameterInfo;
 		
 		lbag.AddMember (current_event.Add, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 318
 #line 2426 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Add.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Add.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 319
 #line 2442 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Remove = new EventProperty.RemoveDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Remove.ParameterInfo;
 
 		lbag.AddMember (current_event.Remove, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 320
 #line 2454 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Remove.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Remove.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 321
 #line 2470 "cs-parser.jay"
   {
 		Report.Error (73, lexer.Location, "An add or remove accessor must have a body");
 		yyVal = null;
 	  }
   break;
 case 323
 #line 2482 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			enumTypeComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 324
 #line 2487 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		if (name.IsGeneric) {
 			Report.Error (1675, name.Location, "Enums cannot have type parameters");
 		}
 		
 		push_current_class (new Enum (current_namespace, current_class, (TypeExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-5+yyTop], MakeName (name), (Attributes) yyVals[-6+yyTop]), null);
 	  }
   break;
 case 325
 #line 2499 "cs-parser.jay"
   {
 	  	/* here will be evaluated after CLOSE_BLACE is consumed.*/
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 326
 #line 2505 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			current_class.DocComment = enumTypeComment;
 			
 		--lexer.parsing_declaration;
 
 /*			if (RootContext.Documentation != null)*/
 /*				em.DocComment = ev.DocComment;*/
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-9+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 328
 #line 2522 "cs-parser.jay"
   {
 	 	var te = yyVals[0+yyTop] as TypeExpression;
 		if (te == null ||
 			(te.Type != TypeManager.int32_type && te.Type != TypeManager.uint32_type &&
 			te.Type != TypeManager.int64_type && te.Type != TypeManager.uint64_type &&
 			te.Type != TypeManager.short_type && te.Type != TypeManager.ushort_type &&
 			te.Type != TypeManager.byte_type && te.Type != TypeManager.sbyte_type)) {
 			Enum.Error_1008 (GetLocation (yyVals[0+yyTop]), Report);
 			yyVal = null;
 		} else {
 			yyVal = yyVals[0+yyTop];
 		}
 	 }
   break;
 case 329
 #line 2536 "cs-parser.jay"
   {
 	 	Error_TypeExpected (GetLocation (yyVals[-1+yyTop]));
 		yyVal = null;
 	 }
   break;
 case 332
 #line 2546 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 334
 #line 2554 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 335
 #line 2562 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-1+yyTop]);
 	  	((Enum) current_class).AddEnumMember (em);
 
 		if (RootContext.Documentation != null) {
 			em.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		yyVal = em;
 	  }
   break;
 case 336
 #line 2575 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 	  }
   break;
 case 337
 #line 2583 "cs-parser.jay"
   { 
 		--lexer.parsing_block;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 	  	em.Initializer = new ConstInitializer (em, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	((Enum) current_class).AddEnumMember (em);
 		
 		if (RootContext.Documentation != null)
 			em.DocComment = ConsumeStoredComment ();
 
 		yyVal = em;
 	  }
   break;
 case 338
 #line 2604 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out | ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 339
 #line 2608 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		MemberName name = MakeName ((MemberName) yyVals[-4+yyTop]);
 		ParametersCompiled p = (ParametersCompiled) yyVals[-1+yyTop];
 
 		Delegate del = new Delegate (current_namespace, current_class, (FullNamedExpression) yyVals[-5+yyTop],
 					     (Modifiers) yyVals[-7+yyTop], name, p, (Attributes) yyVals[-8+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			del.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		current_container.AddDelegate (del);
 		current_delegate = del;
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 340
 #line 2627 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 	  }
   break;
 case 341
 #line 2631 "cs-parser.jay"
   {
 		current_delegate.SetParameterInfo ((List<Constraints>) yyVals[-2+yyTop]);
 		lbag.AddMember (current_delegate, mod_locations, GetLocation (yyVals[-10+yyTop]), GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[0+yyTop]));
 
 		yyVal = current_delegate;
 
 		current_delegate = null;
 	  }
   break;
 case 343
 #line 2644 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "nullable types");
 	  
 	  	yyVal = ComposedTypeSpecifier.CreateNullable (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 345
 #line 2655 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 347
 #line 2666 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 348
 #line 2675 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 350
 #line 2687 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");	  
 	  
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 351
 #line 2694 "cs-parser.jay"
   {
 		Error_TypeExpected (lexer.Location);
 		yyVal = new TypeArguments ();
 	  }
   break;
 case 352
 #line 2702 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 353
 #line 2708 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 354
 #line 2720 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 355
 #line 2724 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 356
 #line 2733 "cs-parser.jay"
   {
 	  	MemberName mn = (MemberName)yyVals[0+yyTop];
 	  	if (mn.TypeArguments != null)
 	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
 	  			mn.GetSignatureForError ()));
 	  }
   break;
 case 358
 #line 2744 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 359
 #line 2753 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		yyVal = new MemberName (TypeContainer.DefaultIndexerName, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 360
 #line 2758 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		yyVal = new MemberName ((MemberName) yyVals[-1+yyTop], TypeContainer.DefaultIndexerName, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 361
 #line 2766 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 362
 #line 2772 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[-1+yyTop], lt1.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 363
 #line 2780 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 365
 #line 2790 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");
 	  
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 366
 #line 2801 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 367
 #line 2807 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 		lbag.AddLocation (yyVals[0+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 368
 #line 2817 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 		yyVal = new TypeParameterName (lt.Value, (Attributes)yyVals[-2+yyTop], (Variance) yyVals[-1+yyTop], lt.Location);
   	  }
   break;
 case 369
 #line 2822 "cs-parser.jay"
   {
   	  	if (GetTokenName (yyToken) == "type")
 			Report.Error (81, GetLocation (yyVals[0+yyTop]), "Type parameter declaration must be an identifier not a type");
 		else
 			Error_SyntaxError (yyToken);
 			
   	  	yyVal = new TypeParameterName ("", null, lexer.Location);
   	  }
   break;
 case 371
 #line 2838 "cs-parser.jay"
   {
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 372
 #line 2845 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 374
 #line 2856 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 376
 #line 2865 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 378
 #line 2874 "cs-parser.jay"
   {
 	  	Report.Error (1536, GetLocation (yyVals[0+yyTop]), "Invalid parameter type `void'");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 380
 #line 2883 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 381
 #line 2890 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-1+yyTop];
 
 		if (yyVals[0+yyTop] != null) {
 			yyVal = new ComposedCast (name.GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			if (name.Left == null && name.Name == "var")
 				yyVal = new VarExpr (name.Location);
 			else
 				yyVal = name.GetTypeExpression ();
 		}
 	  }
   break;
 case 382
 #line 2903 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (((MemberName) yyVals[-1+yyTop]).GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 383
 #line 2907 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null)
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 384
 #line 2912 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 385
 #line 2916 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 386
 #line 2923 "cs-parser.jay"
   {
 		var types = new List<FullNamedExpression> (2);
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 387
 #line 2929 "cs-parser.jay"
   {
 		var types = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 388
 #line 2938 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast) {
 			Report.Error (1521, GetLocation (yyVals[0+yyTop]), "Invalid base type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 389
 #line 2945 "cs-parser.jay"
   {
 	  	Error_TypeExpected (lexer.Location);
 		yyVal = null;
 	  }
   break;
 case 390
 #line 2956 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.object_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 391
 #line 2957 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.string_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 392
 #line 2958 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.bool_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 393
 #line 2959 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.decimal_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 394
 #line 2960 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.float_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 395
 #line 2961 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.double_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 397
 #line 2966 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.sbyte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 398
 #line 2967 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.byte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 399
 #line 2968 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.short_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 400
 #line 2969 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.ushort_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 401
 #line 2970 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 402
 #line 2971 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 403
 #line 2972 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 404
 #line 2973 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 405
 #line 2974 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.char_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 425
 #line 3006 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new SimpleName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 426
 #line 3010 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	       yyVal = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
 	  }
   break;
 case 430
 #line 3020 "cs-parser.jay"
   { yyVal = new NullLiteral (GetLocation (yyVals[0+yyTop])); }
   break;
 case 431
 #line 3024 "cs-parser.jay"
   { yyVal = new BoolLiteral (true, GetLocation (yyVals[0+yyTop])); }
   break;
 case 432
 #line 3025 "cs-parser.jay"
   { yyVal = new BoolLiteral (false, GetLocation (yyVals[0+yyTop])); }
   break;
 case 437
 #line 3051 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 438
 #line 3056 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 	  }
   break;
 case 439
 #line 3063 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 440
 #line 3069 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 441
 #line 3075 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 442
 #line 3081 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 443
 #line 3087 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null,GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 444
 #line 3090 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
 	  }
   break;
 case 445
 #line 3095 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null, lexer.Location);
 	  }
   break;
 case 446
 #line 3098 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
  	  }
   break;
 case 447
 #line 3106 "cs-parser.jay"
   {
 		yyVal = new Invocation ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 448
 #line 3113 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 450
 #line 3119 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] == null) {
 	  		yyVal = CollectionOrObjectInitializers.Empty;
 	  		/* TODO
 	  	} else {
 	  		yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  	}
 	  }
   break;
 case 451
 #line 3129 "cs-parser.jay"
   {
 	  	yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 452
 #line 3136 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 453
 #line 3138 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	}
   break;
 case 454
 #line 3145 "cs-parser.jay"
   {
 	  	var a = new List<Expression> ();
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 455
 #line 3151 "cs-parser.jay"
   {
 	  	var a = (List<Expression>)yyVals[-2+yyTop];
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 456
 #line 3156 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 457
 #line 3164 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 	  	yyVal = new ElementInitializer (lt.Value, (Expression)yyVals[0+yyTop], lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 458
 #line 3170 "cs-parser.jay"
   {
 		yyVal = new CompletionElementInitializer (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 459
 #line 3173 "cs-parser.jay"
   {
 		CompletionSimpleName csn = yyVals[-1+yyTop] as CompletionSimpleName;
 		if (csn == null)
 			yyVal = new CollectionElementInitializer ((Expression)yyVals[-1+yyTop]);
 		else
 			yyVal = new CompletionElementInitializer (csn.Prefix, csn.Location);
 	  }
   break;
 case 460
 #line 3181 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] == null)
 			yyVal = null;
 		else
 	  		yyVal = new CollectionElementInitializer ((List<Expression>)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 461
 #line 3188 "cs-parser.jay"
   {
 	  	Report.Error (1920, GetLocation (yyVals[-1+yyTop]), "An element initializer cannot be empty");
 		yyVal = null;
 	  }
   break;
 case 464
 #line 3200 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 466
 #line 3206 "cs-parser.jay"
   { 
 		Arguments list = new Arguments (4);
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 467
 #line 3212 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		if (list [list.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
 		
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 468
 #line 3221 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		NamedArgument a = (NamedArgument) yyVals[0+yyTop];
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		
 		list.Add (a);
 		yyVal = list;
 	  }
   break;
 case 469
 #line 3235 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[0+yyTop]), "An argument is missing");
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 470
 #line 3240 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[-1+yyTop]), "An argument is missing");
 	  	yyVal = null;
 	  }
   break;
 case 471
 #line 3248 "cs-parser.jay"
   {
 		yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 475
 #line 3261 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Ref);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 476
 #line 3266 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Out);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 477
 #line 3271 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 478
 #line 3276 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist (GetLocation (yyVals[-2+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 480
 #line 3288 "cs-parser.jay"
   {
 		yyVal = new ElementAccess ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 481
 #line 3296 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 482
 #line 3302 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 483
 #line 3307 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 484
 #line 3315 "cs-parser.jay"
   {
 		Arguments args = new Arguments (4);
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;
 	  }
   break;
 case 485
 #line 3321 "cs-parser.jay"
   {
 		Arguments args = (Arguments) yyVals[-2+yyTop];
 		if (args [args.Count - 1] is NamedArgument && !(yyVals[0+yyTop] is NamedArgument))
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 	  
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;	  
 	  }
   break;
 case 486
 #line 3333 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 488
 #line 3341 "cs-parser.jay"
   {
 		yyVal = new This (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 489
 #line 3348 "cs-parser.jay"
   {
 	  	yyVal = new ElementAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 490
 #line 3353 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = new ElementAccess (null, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 491
 #line 3361 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 492
 #line 3368 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 493
 #line 3375 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			if (RootContext.Version <= LanguageVersion.ISO_2)
 				Report.FeatureIsNotAvailable (GetLocation (yyVals[-5+yyTop]), "object initializers");
 				
 			yyVal = new NewInitialize ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		} else {
 			yyVal = new New ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], GetLocation (yyVals[-5+yyTop]));
 		}
 		
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 494
 #line 3388 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "collection initializers");
 	  
 		yyVal = new NewInitialize ((FullNamedExpression) yyVals[-1+yyTop], null, (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 495
 #line 3400 "cs-parser.jay"
   {
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], (List<Expression>) yyVals[-3+yyTop],
 				new ComposedTypeSpecifier (((List<Expression>) yyVals[-3+yyTop]).Count, GetLocation (yyVals[-4+yyTop])) {
 	  				Next = (ComposedTypeSpecifier) yyVals[-1+yyTop]
 			  	}, (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 496
 #line 3408 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] == null)
 	  		Report.Error (1586, GetLocation (yyVals[-3+yyTop]), "Array creation must have array size or array initializer");
 
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-2+yyTop], (ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 497
 #line 3415 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "implicitly typed arrays");
 	  
 		yyVal = new ImplicitlyTypedArrayCreation ((ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 498
 #line 3422 "cs-parser.jay"
   {
 		Report.Error (178, GetLocation (yyVals[-1+yyTop]), "Invalid rank specifier, expecting `,' or `]'");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], null, GetLocation (yyVals[-6+yyTop]));
 	  }
   break;
 case 499
 #line 3427 "cs-parser.jay"
   {
 		Error_SyntaxError (1526, yyToken, "Unexpected symbol");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-1+yyTop], null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 500
 #line 3434 "cs-parser.jay"
   {
 		++lexer.parsing_type;
 	  }
   break;
 case 501
 #line 3438 "cs-parser.jay"
   {
 		--lexer.parsing_type;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 502
 #line 3446 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "anonymous types");
 
 		yyVal = new NewAnonymousType ((List<AnonymousTypeParameter>) yyVals[-1+yyTop], current_container, GetLocation (yyVals[-3+yyTop]));
 		
 		/* TODO
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 505
 #line 3463 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 507
 #line 3469 "cs-parser.jay"
   {
 	  	var a = new List<AnonymousTypeParameter> (4);
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 508
 #line 3475 "cs-parser.jay"
   {
 	  	var a = (List<AnonymousTypeParameter>) yyVals[-2+yyTop];
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 509
 #line 3484 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[-2+yyTop];
 	  	yyVal = new AnonymousTypeParameter ((Expression)yyVals[0+yyTop], lt.Value, lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 510
 #line 3490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (new SimpleName (lt.Value, lt.Location),
 	  		lt.Value, lt.Location);
 	  }
   break;
 case 511
 #line 3496 "cs-parser.jay"
   {
 	  	MemberAccess ma = (MemberAccess) yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (ma, ma.Name, ma.Location);
 	  }
   break;
 case 512
 #line 3501 "cs-parser.jay"
   {
 		Report.Error (746, lexer.Location,
 			"Invalid anonymous type member declarator. Anonymous type members must be a member assignment, simple name or member access expression");
 		yyVal = null;
 	  }
   break;
 case 516
 #line 3516 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 517
 #line 3524 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 518
 #line 3528 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension ((int)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 519
 #line 3535 "cs-parser.jay"
   {
 		yyVal = 2;
 	  }
   break;
 case 520
 #line 3539 "cs-parser.jay"
   {
 		yyVal = ((int) yyVals[-1+yyTop]) + 1;
 	  }
   break;
 case 521
 #line 3546 "cs-parser.jay"
   {
 		yyVal = null;
 	  }
   break;
 case 522
 #line 3550 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 523
 #line 3557 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer (0, GetLocation (yyVals[-1+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[0+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 524
 #line 3564 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[-1+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 525
 #line 3574 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 526
 #line 3580 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 527
 #line 3589 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = true;
 	  }
   break;
 case 528
 #line 3593 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = false;
 		yyVal = new TypeOf ((FullNamedExpression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 531
 #line 3604 "cs-parser.jay"
   {
 	 	Error_TypeExpected (lexer.Location);
 	 	yyVal = null;
 	 }
   break;
 case 532
 #line 3612 "cs-parser.jay"
   {  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new SimpleName (lt.Value, (int) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 533
 #line 3618 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (int) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 534
 #line 3625 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 535
 #line 3631 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 536
 #line 3637 "cs-parser.jay"
   {
 		var te = ((MemberName) yyVals[-3+yyTop]).GetTypeExpression ();
 		if (te.HasTypeArguments)
 			Error_TypeExpected (GetLocation (yyVals[0+yyTop]));
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (te, lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 537
 #line 3649 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "generics");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 538
 #line 3659 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		if (RootContext.Version == LanguageVersion.ISO_1)
 			Report.FeatureIsNotAvailable (lt.Location, "namespace alias qualifier");
 
 		yyVal = lt;		
 	  }
   break;
 case 539
 #line 3670 "cs-parser.jay"
   { 
 		yyVal = new SizeOf ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 540
 #line 3678 "cs-parser.jay"
   {
 		yyVal = new CheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 541
 #line 3686 "cs-parser.jay"
   {
 		yyVal = new UnCheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 542
 #line 3694 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberAccess (new Indirection ((Expression) yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop])), lt.Value, lt.Location);
 	  }
   break;
 case 543
 #line 3702 "cs-parser.jay"
   {
 		start_anonymous (false, (ParametersCompiled) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 544
 #line 3706 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 	  }
   break;
 case 545
 #line 3713 "cs-parser.jay"
   {
 		yyVal = ParametersCompiled.Undefined;
 	  }
   break;
 case 547
 #line 3721 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 548
 #line 3725 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 549
 #line 3733 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "default value expression");
 
 		yyVal = new DefaultValueExpression ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 551
 #line 3745 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.LogicalNot, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 552
 #line 3749 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.OnesComplement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 554
 #line 3757 "cs-parser.jay"
   {
 		yyVal = new Cast ((FullNamedExpression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 556
 #line 3770 "cs-parser.jay"
   { 
 	  	yyVal = new Unary (Unary.Operator.UnaryPlus, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 557
 #line 3774 "cs-parser.jay"
   { 
 		yyVal = new Unary (Unary.Operator.UnaryNegation, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 558
 #line 3778 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 559
 #line 3782 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 560
 #line 3786 "cs-parser.jay"
   {
 		yyVal = new Indirection ((Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 561
 #line 3790 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.AddressOf, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 563
 #line 3798 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Multiply, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 564
 #line 3803 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Division, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 565
 #line 3808 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Modulus, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 567
 #line 3817 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Addition, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 568
 #line 3822 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 569
 #line 3826 "cs-parser.jay"
   {
 	  	/* Shift/Reduce conflict*/
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
   	  }
   break;
 case 570
 #line 3831 "cs-parser.jay"
   {
 		yyVal = new As ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 571
 #line 3835 "cs-parser.jay"
   {
 		yyVal = new Is ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 573
 #line 3843 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LeftShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 574
 #line 3848 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.RightShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 576
 #line 3857 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 577
 #line 3862 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 578
 #line 3867 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 579
 #line 3872 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 581
 #line 3881 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Equality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 582
 #line 3886 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Inequality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 584
 #line 3895 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 586
 #line 3904 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.ExclusiveOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 588
 #line 3913 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 590
 #line 3922 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 592
 #line 3931 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 594
 #line 3940 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "null coalescing operator");
 			
 		yyVal = new Nullable.NullCoalescingOperator ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 596
 #line 3951 "cs-parser.jay"
   {
 		yyVal = new Conditional (new BooleanExpression ((Expression) yyVals[-4+yyTop]), (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 597
 #line 3959 "cs-parser.jay"
   {
 		yyVal = new SimpleAssign ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 598
 #line 3963 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Multiply, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 599
 #line 3968 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Division, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 600
 #line 3973 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Modulus, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 601
 #line 3978 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Addition, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 602
 #line 3983 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 603
 #line 3988 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.LeftShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 604
 #line 3993 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.RightShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 605
 #line 3998 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseAnd, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 606
 #line 4003 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 607
 #line 4008 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.ExclusiveOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 608
 #line 4016 "cs-parser.jay"
   {
 		var pars = new List<Parameter> (4);
 		pars.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = pars;
 	  }
   break;
 case 609
 #line 4023 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter)yyVals[0+yyTop];
 		if (pars[0].GetType () != p.GetType ()) {
 			Report.Error (748, p.Location, "All lambda parameters must be typed either explicitly or implicitly");
 		}
 		
 		pars.Add (p);
 		yyVal = pars;
 	  }
   break;
 case 610
 #line 4037 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], null, lt.Location);
 	  }
   break;
 case 611
 #line 4043 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, Parameter.Modifier.NONE, null, lt.Location);
 	  }
   break;
 case 612
 #line 4049 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ImplicitLambdaParameter (lt.Value, lt.Location);
 	  }
   break;
 case 613
 #line 4056 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 614
 #line 4057 "cs-parser.jay"
   { 
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 		yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 617
 #line 4069 "cs-parser.jay"
   {
 		start_block (lexer.Location);
 	  }
   break;
 case 618
 #line 4073 "cs-parser.jay"
   {
 		Block b = end_block (lexer.Location);
 		b.AddStatement (new ContextualReturn ((Expression) yyVals[0+yyTop]));
 		yyVal = b;
 	  }
   break;
 case 620
 #line 4083 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	
 		yyVal = EmptyExpression.Null;
 	  }
   break;
 case 621
 #line 4091 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
 		start_anonymous (true, new ParametersCompiled (p), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 622
 #line 4097 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 623
 #line 4102 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "lambda expressions");
 	  
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 624
 #line 4109 "cs-parser.jay"
   {
 	  	valid_param_mod = 0;
 		start_anonymous (true, (ParametersCompiled) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 625
 #line 4114 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 631
 #line 4130 "cs-parser.jay"
   {
 		yyVal = new ArglistAccess (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 633
 #line 4141 "cs-parser.jay"
   {
 		yyVal = new BooleanExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 634
 #line 4154 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 635
 #line 4158 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Class (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 636
 #line 4164 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 637
 #line 4176 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 638
 #line 4182 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 639
 #line 4190 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 640
 #line 4192 "cs-parser.jay"
   { yyVal = yyVals[0+yyTop]; }
   break;
 case 641
 #line 4197 "cs-parser.jay"
   {
 	    mod_locations = null;
 		yyVal = ModifierNone;
 	  }
   break;
 case 644
 #line 4207 "cs-parser.jay"
   { 
 		var m1 = (Modifiers) yyVals[-1+yyTop];
 		var m2 = (Modifiers) yyVals[0+yyTop];
 
 		if ((m1 & m2) != 0) {
 			Report.Error (1004, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"Duplicate `{0}' modifier", ModifiersExtensions.Name (m2));
 		} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
 			((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
 			Report.Error (107, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"More than one protection modifier specified");
 		}
 		
 		yyVal = m1 | m2;
 	  }
   break;
 case 645
 #line 4226 "cs-parser.jay"
   {
 		yyVal = Modifiers.NEW;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		
 		if (current_container == RootContext.ToplevelTypes)
 			Report.Error (1530, GetLocation (yyVals[0+yyTop]), "Keyword `new' is not allowed on namespace elements");
 	  }
   break;
 case 646
 #line 4234 "cs-parser.jay"
   {
 		yyVal = Modifiers.PUBLIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 647
 #line 4239 "cs-parser.jay"
   {
 		yyVal = Modifiers.PROTECTED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 648
 #line 4244 "cs-parser.jay"
   {
 		yyVal = Modifiers.INTERNAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 649
 #line 4249 "cs-parser.jay"
   {
 		yyVal = Modifiers.PRIVATE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 650
 #line 4254 "cs-parser.jay"
   {
 		yyVal = Modifiers.ABSTRACT;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 651
 #line 4259 "cs-parser.jay"
   {
 		yyVal = Modifiers.SEALED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 652
 #line 4264 "cs-parser.jay"
   {
 		yyVal = Modifiers.STATIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 653
 #line 4269 "cs-parser.jay"
   {
 		yyVal = Modifiers.READONLY;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 654
 #line 4274 "cs-parser.jay"
   {
 		yyVal = Modifiers.VIRTUAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 655
 #line 4279 "cs-parser.jay"
   {
 		yyVal = Modifiers.OVERRIDE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 656
 #line 4284 "cs-parser.jay"
   {
 		yyVal = Modifiers.EXTERN;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 657
 #line 4289 "cs-parser.jay"
   {
 		yyVal = Modifiers.VOLATILE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 658
 #line 4294 "cs-parser.jay"
   {
 		yyVal = Modifiers.UNSAFE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 659
 #line 4301 "cs-parser.jay"
   {
 		yyVal = Modifiers.ASYNC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 661
 #line 4310 "cs-parser.jay"
   {
 		current_container.AddBasesForPart (current_class, (List<FullNamedExpression>) yyVals[0+yyTop]);
 	 }
   break;
 case 663
 #line 4318 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 664
 #line 4322 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	 }
   break;
 case 665
 #line 4330 "cs-parser.jay"
   {
 		var constraints = new List<Constraints> (1);
 		constraints.Add ((Constraints) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 666
 #line 4336 "cs-parser.jay"
   {
 		var constraints = (List<Constraints>) yyVals[-1+yyTop];
 		Constraints new_constraint = (Constraints)yyVals[0+yyTop];
 
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 
 		constraints.Add (new_constraint);
 		yyVal = constraints;
 	  }
   break;
 case 667
 #line 4355 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 668
 #line 4363 "cs-parser.jay"
   {
 		var constraints = new List<FullNamedExpression> (1);
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 669
 #line 4369 "cs-parser.jay"
   {
 		var constraints = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
 		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
 			Report.Error (401, GetLocation (yyVals[-1+yyTop]), "The `new()' constraint must be the last constraint specified");
 		}
 		
 		prev = yyVals[0+yyTop] as SpecialContraintExpr;
 		if (prev != null) {
 			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
 				Report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
 			} else {
 			 	prev = constraints [0] as SpecialContraintExpr;
 			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
 					Report.Error (451, GetLocation (yyVals[0+yyTop]), "The `new()' constraint cannot be used with the `struct' constraint");
 				}
 			}
 		}
 
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 670
 #line 4395 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast)
 			Report.Error (706, GetLocation (yyVals[0+yyTop]), "Invalid constraint type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 	  
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 671
 #line 4402 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 672
 #line 4407 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 673
 #line 4411 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 674
 #line 4418 "cs-parser.jay"
   {
 		yyVal = Variance.None;
 	  }
   break;
 case 675
 #line 4422 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (lexer.Location, "generic type variance");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 676
 #line 4432 "cs-parser.jay"
   {
 		yyVal = Variance.Covariant;
 	  }
   break;
 case 677
 #line 4436 "cs-parser.jay"
   {
 		yyVal = Variance.Contravariant;
 	  }
   break;
 case 678
 #line 4456 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 679
 #line 4461 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 680
 #line 4468 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 681
 #line 4473 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (lexer.Location);
 	  }
   break;
 case 682
 #line 4482 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		current_block.StartLocation = GetLocation (yyVals[0+yyTop]);
 	  }
   break;
 case 683
 #line 4487 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 688
 #line 4505 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 689
 #line 4509 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 691
 #line 4514 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 694
 #line 4533 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 695
 #line 4537 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 724
 #line 4578 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 725
 #line 4583 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 726
 #line 4588 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 727
 #line 4596 "cs-parser.jay"
   {
 		/* Uses lexer.Location because semicolon location is not kept in quick mode*/
 		yyVal = new EmptyStatement (lexer.Location);
 	  }
   break;
 case 728
 #line 4604 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
 
 		current_block.AddLabel (labeled);
 		current_block.AddStatement (labeled);
 	  }
   break;
 case 731
 #line 4617 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] is VarExpr)
 			yyVals[-1+yyTop] = new SimpleName ("var", ((VarExpr) yyVals[-1+yyTop]).Location);
 	  
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 732
 #line 4633 "cs-parser.jay"
   { 
 		/* Ok, the above "primary_expression" is there to get rid of*/
 		/* both reduce/reduce and shift/reduces in the grammar, it should*/
 		/* really just be "type_name".  If you use type_name, a reduce/reduce*/
 		/* creeps up.  If you use namespace_or_type_name (which is all we need*/
 		/* really) two shift/reduces appear.*/
 		/* */
 
 		/* So the super-trick is that primary_expression*/
 		/* can only be either a SimpleName or a MemberAccess. */
 		/* The MemberAccess case arises when you have a fully qualified type-name like 
 		/* Foo.Bar.Blah i;*/
 		/* SimpleName is when you have*/
 		/* Blah i;*/
 		
 		Expression expr = (Expression) yyVals[-1+yyTop];
 		if (yyVals[0+yyTop] == null) {
 			SimpleName sn = expr as SimpleName;
 			if (sn != null && sn.Name == "var")
 				yyVal = new VarExpr (sn.Location);
 			else
 				yyVal = yyVals[-1+yyTop];
 		} else if (expr is ATypeNameExpression) {
 			yyVal = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName (expr);
 			yyVal = null;
 		}
 	  }
   break;
 case 733
 #line 4663 "cs-parser.jay"
   {
 		ATypeNameExpression expr = yyVals[-1+yyTop] as ATypeNameExpression;
 
 		if (expr != null) {
 			yyVal = new ComposedCast (expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName ((Expression)yyVals[-1+yyTop]);
 			yyVal = expr;
 		}
 	  }
   break;
 case 734
 #line 4674 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] == null)
 			yyVal = yyVals[-1+yyTop];
 		else
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 735
 #line 4681 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 736
 #line 4685 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 737
 #line 4689 "cs-parser.jay"
   {
 		Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 739
 #line 4698 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 740
 #line 4706 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreatePointer (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 741
 #line 4713 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 742
 #line 4720 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 743
 #line 4726 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockConstantDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 744
 #line 4733 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 746
 #line 4743 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		/* TODO
 	  }
   break;
 case 747
 #line 4748 "cs-parser.jay"
   {
 	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
 			Report.Error (650, lexer.Location,
 				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 	  }
   break;
 case 752
 #line 4770 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, null);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 753
 #line 4779 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 754
 #line 4791 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 	  }
   break;
 case 755
 #line 4795 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 760
 #line 4812 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 762
 #line 4825 "cs-parser.jay"
   {
 		yyVal = new StackAlloc ((Expression) yyVals[-3+yyTop], (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 763
 #line 4830 "cs-parser.jay"
   {
 		Report.Error (1575, GetLocation (yyVals[-1+yyTop]), "A stackalloc expression requires [] after type");
 		yyVal = new StackAlloc ((Expression) yyVals[0+yyTop], null, GetLocation (yyVals[-1+yyTop]));		
 	  }
   break;
 case 764
 #line 4838 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 765
 #line 4842 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 766
 #line 4846 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 767
 #line 4847 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 768
 #line 4856 "cs-parser.jay"
   {
 		ExpressionStatement s = yyVals[0+yyTop] as ExpressionStatement;
 		if (s == null) {
 			Expression.Error_InvalidExpressionStatement (Report, GetLocation (yyVals[0+yyTop]));
 			s = EmptyExpressionStatement.Instance;
 		}
 
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 769
 #line 4869 "cs-parser.jay"
   {
 		Expression expr = (Expression) yyVals[0+yyTop];
 		ExpressionStatement s;
 
 	        s = new OptionalAssign (new SimpleName ("$retval", lexer.Location), expr, lexer.Location);
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 770
 #line 4877 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 773
 #line 4891 "cs-parser.jay"
   { 
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 		
 		yyVal = new If ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 774
 #line 4900 "cs-parser.jay"
   {
 		yyVal = new If ((BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		
 		if (yyVals[-2+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[-2+yyTop]));
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 775
 #line 4913 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 776
 #line 4917 "cs-parser.jay"
   {
 		yyVal = new Switch ((Expression) yyVals[-5+yyTop], (ExplicitBlock) current_block.Explicit, (List<SwitchSection>) yyVals[-1+yyTop], GetLocation (yyVals[-7+yyTop]));	
 		end_block (GetLocation (yyVals[0+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 777
 #line 4926 "cs-parser.jay"
   {
 		Report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 779
 #line 4935 "cs-parser.jay"
   {
 		var sections = new List<SwitchSection> (4);
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 780
 #line 4942 "cs-parser.jay"
   {
 		var sections = (List<SwitchSection>) yyVals[-1+yyTop];
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 781
 #line 4949 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 782
 #line 4957 "cs-parser.jay"
   {
 		current_block = current_block.CreateSwitchBlock (lexer.Location);
 	  }
   break;
 case 783
 #line 4961 "cs-parser.jay"
   {
 		yyVal = new SwitchSection ((List<SwitchLabel>) yyVals[-2+yyTop], current_block);
 	  }
   break;
 case 784
 #line 4968 "cs-parser.jay"
   {
 		var labels = new List<SwitchLabel> (4);
 
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 		yyVal = labels;
 	  }
   break;
 case 785
 #line 4975 "cs-parser.jay"
   {
 		var labels = (List<SwitchLabel>) (yyVals[-1+yyTop]);
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 
 		yyVal = labels;
 	  }
   break;
 case 786
 #line 4985 "cs-parser.jay"
   {
 	 	yyVal = new SwitchLabel ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	 	lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	 }
   break;
 case 787
 #line 4990 "cs-parser.jay"
   {
 		yyVal = new SwitchLabel (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 792
 #line 5004 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new While ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 793
 #line 5016 "cs-parser.jay"
   {
 		yyVal = new Do ((Statement) yyVals[-5+yyTop], (BooleanExpression) yyVals[-2+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 794
 #line 5024 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 		current_block.IsCompilerGenerated = true;
 	  }
   break;
 case 795
 #line 5029 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 796
 #line 5040 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		For f = new For ((Statement) yyVals[-6+yyTop], (BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, current_block.StartLocation, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		yyVal = end_block (GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 797
 #line 5052 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = end_block (current_block.StartLocation);
 	  }
   break;
 case 798
 #line 5059 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 800
 #line 5065 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 801
 #line 5072 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 803
 #line 5080 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 805
 #line 5085 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 809
 #line 5096 "cs-parser.jay"
   {
 	  	var sl = yyVals[-2+yyTop] as StatementList;
 	  	if (sl == null) {
 	  		sl = new StatementList ((Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop]);
 			lbag.AddStatement (sl, GetLocation (yyVals[-1+yyTop]));
 	  	} else {
 	  		sl.Add ((Statement) yyVals[0+yyTop]);
 	  		lbag.AppendTo (sl, GetLocation (yyVals[-1+yyTop]));
 	  	}
 	  		
 		yyVal = sl;
 	  }
   break;
 case 810
 #line 5112 "cs-parser.jay"
   {
 		Report.Error (230, GetLocation (yyVals[-5+yyTop]), "Type and identifier are both required in a foreach statement");
 		yyVal = null;
 	  }
   break;
 case 811
 #line 5117 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-5+yyTop]));
 		current_block.IsCompilerGenerated = true;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.ForeachVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		yyVal = li;
 	  }
   break;
 case 812
 #line 5127 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Foreach f = new Foreach ((Expression) yyVals[-6+yyTop], (LocalVariable) yyVals[-1+yyTop], (Expression) yyVals[-3+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-8+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 819
 #line 5150 "cs-parser.jay"
   {
 		yyVal = new Break (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 820
 #line 5158 "cs-parser.jay"
   {
 		yyVal = new Continue (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 821
 #line 5166 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new Goto (lt.Value, lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 822
 #line 5172 "cs-parser.jay"
   {
 		yyVal = new GotoCase ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 823
 #line 5177 "cs-parser.jay"
   {
 		yyVal = new GotoDefault (GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 824
 #line 5185 "cs-parser.jay"
   {
 		yyVal = new Return ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 825
 #line 5193 "cs-parser.jay"
   {
 		yyVal = new Throw ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 826
 #line 5201 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (yyVals[-1+yyTop] == null) {
 			Report.Error (1627, GetLocation (yyVals[0+yyTop]), "Expression expected after yield return");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new Yield ((Expression) yyVals[-1+yyTop], lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 827
 #line 5217 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new YieldBreak (lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 830
 #line 5239 "cs-parser.jay"
   {
 		yyVal = new TryCatch ((Block) yyVals[-1+yyTop], (List<Catch>) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]), false);
 	  }
   break;
 case 831
 #line 5243 "cs-parser.jay"
   {
 		yyVal = new TryFinally ((Statement) yyVals[-2+yyTop], (Block) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 832
 #line 5248 "cs-parser.jay"
   {
 		yyVal = new TryFinally (new TryCatch ((Block) yyVals[-3+yyTop], (List<Catch>) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]), true), (Block) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 833
 #line 5253 "cs-parser.jay"
   {
 		Report.Error (1524, GetLocation (yyVals[-2+yyTop]), "Expected catch or finally");
 		yyVal = null;
 	  }
   break;
 case 834
 #line 5261 "cs-parser.jay"
   {
 		var l = new List<Catch> (2);
 
 		l.Add ((Catch) yyVals[0+yyTop]);
 		yyVal = l;
 	  }
   break;
 case 835
 #line 5268 "cs-parser.jay"
   {
 		var l = (List<Catch>) yyVals[-1+yyTop];
 		
 		Catch c = (Catch) yyVals[0+yyTop];
 		if (l [0].IsGeneral) {
 			Report.Error (1017, c.loc, "Try statement already has an empty catch block");
 		} else {
 			if (c.IsGeneral)
 				l.Insert (0, c);
 			else
 				l.Add (c);
 		}
 		
 		yyVal = l;
 	  }
   break;
 case 838
 #line 5292 "cs-parser.jay"
   {
 		yyVal = new Catch ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 839
 #line 5296 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-3+yyTop]));
 		var c = new Catch (current_block, GetLocation (yyVals[-4+yyTop]));
 		c.TypeExpression = (FullNamedExpression) yyVals[-2+yyTop];
 
 		if (yyVals[-1+yyTop] != null) {
 			var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
 			current_block.AddLocalName (c.Variable);
 		}
 		
 		lbag.AddLocation (c, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 840
 #line 5311 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 841
 #line 5315 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_PARENS) {
 			Report.Error (1015, lexer.Location,
 				"A type that derives from `System.Exception', `object', or `string' expected");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 		
 		yyVal = new Catch (null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 842
 #line 5329 "cs-parser.jay"
   {
 		yyVal = new Checked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 843
 #line 5336 "cs-parser.jay"
   {
 		yyVal = new Unchecked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 844
 #line 5343 "cs-parser.jay"
   {
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 845
 #line 5346 "cs-parser.jay"
   {
 		yyVal = new Unsafe ((Block) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 846
 #line 5353 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new Lock ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 847
 #line 5364 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.FixedVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Fixed.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 848
 #line 5373 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 849
 #line 5378 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Fixed f = new Fixed ((Fixed.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 850
 #line 5390 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.UsingVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Using.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 851
 #line 5399 "cs-parser.jay"
   {
 		yyVal = current_variable;	  
 		current_variable = null;
 	  }
   break;
 case 852
 #line 5404 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Using.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (u);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 853
 #line 5413 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (u, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = u;
 	  }
   break;
 case 854
 #line 5425 "cs-parser.jay"
   {
 		Report.Error (210, lexer.Location, "You must provide an initializer in a fixed or using statement declaration");
 	  }
   break;
 case 855
 #line 5429 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		yyVal = current_variable;
 	  }
   break;
 case 856
 #line 5440 "cs-parser.jay"
   {
 		lexer.query_parsing = false;
 			
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 857
 #line 5452 "cs-parser.jay"
   {
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 858
 #line 5463 "cs-parser.jay"
   {
 	        lexer.query_parsing = false;
 		yyVal = yyVals[-1+yyTop];
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 859
 #line 5470 "cs-parser.jay"
   {
 	        yyVal = yyVals[-1+yyTop];
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 860
 #line 5479 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 861
 #line 5487 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 862
 #line 5502 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 863
 #line 5510 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 864
 #line 5525 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 865
 #line 5529 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 866
 #line 5540 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 867
 #line 5544 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop])) {
 			IdentifierType = (FullNamedExpression)yyVals[-4+yyTop]
 		};
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 868
 #line 5561 "cs-parser.jay"
   {
 	  	Linq.AQueryClause head = (Linq.AQueryClause)yyVals[-1+yyTop];
 		
 		if (yyVals[0+yyTop] != null)
 			head.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 				
 		if (yyVals[-2+yyTop] != null) {
 			Linq.AQueryClause clause = (Linq.AQueryClause)yyVals[-2+yyTop];
 			clause.Tail.Next = head;
 			head = clause;
 		}
 		
 		yyVal = head;
 	  }
   break;
 case 870
 #line 5577 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 871
 #line 5585 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 872
 #line 5589 "cs-parser.jay"
   {
 		yyVal = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 873
 #line 5596 "cs-parser.jay"
   {
 	  	if (linq_clause_blocks == null)
 	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
 	  }
   break;
 case 874
 #line 5604 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 875
 #line 5611 "cs-parser.jay"
   {
 		yyVal = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)yyVals[-3+yyTop], linq_clause_blocks.Pop (), (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 879
 #line 5627 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-1+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 885
 #line 5643 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 886
 #line 5647 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 	  	yyVal = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  	
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 887
 #line 5661 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 888
 #line 5665 "cs-parser.jay"
   {
 		yyVal = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 889
 #line 5675 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 890
 #line 5683 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 891
 #line 5691 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 892
 #line 5699 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];	
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-11+yyTop]));
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 			
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location);
 
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-11+yyTop]));	
 		}
 
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);
 	  }
   break;
 case 893
 #line 5735 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 894
 #line 5743 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 895
 #line 5751 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 896
 #line 5759 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;		
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 		
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location); /* TODO
 			
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};			
 		}
 		
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
 	  }
   break;
 case 898
 #line 5803 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 899
 #line 5810 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 900
 #line 5814 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 902
 #line 5825 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 903
 #line 5832 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	  }
   break;
 case 905
 #line 5841 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, (Linq.QueryBlock) current_block, lexer.Location);	 
 	 }
   break;
 case 906
 #line 5848 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	 }
   break;
 case 907
 #line 5856 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 908
 #line 5860 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 909
 #line 5864 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 910
 #line 5871 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 911
 #line 5875 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 912
 #line 5879 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 914
 #line 5888 "cs-parser.jay"
   {
 		/* query continuation block is not linked with query block but with block*/
 		/* before. This means each query can use same range variable names for*/
 		/* different identifiers.*/
 
 		current_block.SetEndLocation (GetLocation (yyVals[-1+yyTop]));
 		current_block = current_block.Parent;
 	
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
 	  }
   break;
 case 915
 #line 5904 "cs-parser.jay"
   {
 		var current_block = linq_clause_blocks.Pop ();	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
   		yyVal = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation (yyVals[-3+yyTop])) {
   			next = (Linq.AQueryClause)yyVals[0+yyTop]
   		};
 	  }
   break;
 case 918
 #line 5930 "cs-parser.jay"
   { 
 	        Evaluator.LoadAliases (current_namespace);
 
 		push_current_class (new Class (current_namespace, current_class, new MemberName ("Class" + class_count++),
 			Modifiers.PUBLIC, null), null);
 
 		var baseclass_list = new List<FullNamedExpression> ();
 		baseclass_list.Add (new TypeExpression (Evaluator.InteractiveBaseClass, lexer.Location));
 		current_container.AddBasesForPart (current_class, baseclass_list);
 
 		/* (ref object retval)*/
 		Parameter [] mpar = new Parameter [1];
 		mpar [0] = new Parameter (new TypeExpression (TypeManager.object_type, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);
 
 		ParametersCompiled pars = new ParametersCompiled (mpar);
 		current_local_parameters = pars;
 		Method method = new Method (
 			current_class,
 			null, /* generic*/
 			new TypeExpression (TypeManager.void_type, Location.Null),
 			Modifiers.PUBLIC | Modifiers.STATIC,
 			new MemberName ("Host"),
 			pars,
 			null /* attributes */);
 
 		oob_stack.Push (method);
 	        ++lexer.parsing_block;
 		start_block (lexer.Location);
 	  }
   break;
 case 919
 #line 5960 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		Method method = (Method) oob_stack.Pop ();
 
 		method.Block = (ToplevelBlock) end_block(lexer.Location);
 		current_container.AddMethod (method);
 
 		--lexer.parsing_declaration;
 		InteractiveResult = pop_current_class ();
 		current_local_parameters = null;
 	  }
   break;
 case 920
 #line 5971 "cs-parser.jay"
   {
 	        Evaluator.LoadAliases (current_namespace);
 	  }
   break;
 #line default
         }
         yyTop -= yyLen[yyN];
         yyState = yyStates[yyTop];
         int yyM = yyLhs[yyN];
         if (yyState == 0 && yyM == 0) {
           if (debug != null) debug.shift(0, yyFinal);
           yyState = yyFinal;
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
                debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
           }
           if (yyToken == 0) {
             if (debug != null) debug.accept(yyVal);
             return yyVal;
           }
           goto continue_yyLoop;
         }
         if (((yyN = yyGindex[yyM]) != 0) && ((yyN += yyState) >= 0)
             && (yyN < yyTable.Length) && (yyCheck[yyN] == yyState))
           yyState = yyTable[yyN];
         else
           yyState = yyDgoto[yyM];
         if (debug != null) debug.shift(yyStates[yyTop], yyState);
 	 goto continue_yyLoop;
       continue_yyDiscarded
       }
     continue_yyLoop
     }
     /*yyLoop
       if (yyTop >= yyStates.Length) {			// dynamically increase
         global
         global
       }
       yyStates[yyTop] = yyState;
       yyVals[yyTop] = yyVal;
       if (debug != null) debug.push(yyState, yyVal);
 
       /*yyDiscarded
         int yyN;
         if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
               debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
           }
           if ((yyN = yySindex[yyState]) != 0 && ((yyN += yyToken) >= 0)
               && (yyN < yyTable.Length) && (yyCheck[yyN] == yyToken)) {
             if (debug != null)
               debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
             yyState = yyTable[yyN];		// shift to yyN
             yyVal = yyLex.value();
             yyToken = -1;
             if (yyErrorFlag > 0) -- yyErrorFlag;
             goto continue_yyLoop;
           }
           if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
               && yyN < yyTable.Length && yyCheck[yyN] == yyToken)
             yyN = yyTable[yyN];			// reduce (yyN)
           else
             switch (yyErrorFlag) {
   
             case 0
               yyExpectingState = yyState;
               // yyerror(String.Format ("syntax error, got token `{0}'", yyname (yyToken)), yyExpecting(yyState));
               if (debug != null) debug.error("syntax error");
               if (yyToken == 0 /*eof*/ || yyToken == eof_token) throw new yyParser.yyUnexpectedEof ();
               goto case 1;
             case 1
               yyErrorFlag = 3;
               do {
                 if ((yyN = yySindex[yyStates[yyTop]]) != 0
                     && (yyN += Token.yyErrorCode) >= 0 && yyN < yyTable.Length
                     && yyCheck[yyN] == Token.yyErrorCode) {
                   if (debug != null)
                     debug.shift(yyStates[yyTop], yyTable[yyN], 3);
                   yyState = yyTable[yyN];
                   yyVal = yyLex.value();
                   goto continue_yyLoop;
                 }
                 if (debug != null) debug.pop(yyStates[yyTop]);
               } while (-- yyTop >= 0);
               if (debug != null) debug.reject();
               throw new yyParser.yyException("irrecoverable syntax error");
   
             case 3
               if (yyToken == 0) {
                 if (debug != null) debug.reject();
                 throw new yyParser.yyException("irrecoverable syntax error at end-of-file");
               }
               if (debug != null)
                 debug.discard(yyState, yyToken, yyname(yyToken),
   							yyLex.value());
               yyToken = -1;
               goto continue_yyDiscarded;		// leave stack alone
             }
         }
         int yyV = yyTop + 1-yyLen[yyN];
         if (debug != null)
           debug.reduce(yyState, yyStates[yyV-1], yyN, YYRules.getRule (yyN), yyLen[yyN]);
         yyVal = yyV > yyTop ? null 
         switch (yyN) {
 case 5
 #line 375 "cs-parser.jay"
   { Lexer.CompleteOnEOF = false; }
   break;
 case 7
 #line 380 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 8
 #line 384 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 16
 #line 407 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "alias"){
 			syntax_error (lt.Location, "`alias' expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (lt.Location, "external alias");
 		} else {
 			lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop]; 
 			current_namespace.AddUsingExternalAlias (lt.Value, lt.Location, Report);
 		}
 	  }
   break;
 case 17
 #line 420 "cs-parser.jay"
   {
 	  	syntax_error (GetLocation (yyVals[-1+yyTop]), "`alias' expected");   /* TODO
 	  }
   break;
 case 20
 #line 432 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 21
 #line 437 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 22
 #line 445 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		current_namespace.AddUsingAlias (lt.Value, (MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 23
 #line 450 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 24
 #line 458 "cs-parser.jay"
   {
 		current_namespace.AddUsing ((MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 25
 #line 470 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (yyVals[-2+yyTop] != null) {
 			Report.Error(1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
 		}
 
 		current_namespace = new NamespaceEntry (module,
 			current_namespace, file, name.GetName ());
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 26
 #line 483 "cs-parser.jay"
   { 
 		current_namespace = current_namespace.Parent;
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 27
 #line 492 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName (lt.Value, lt.Location);
 	  }
   break;
 case 28
 #line 497 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 29
 #line 502 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new MemberName ("<invalid>", lexer.Location);
 	  }
   break;
 case 34
 #line 520 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (name.TypeArguments != null)
 			syntax_error (lexer.Location, "namespace name expected");
 
 		yyVal = name;
 	  }
   break;
 case 35
 #line 532 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 45
 #line 564 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			DeclSpace ds = (DeclSpace)yyVals[0+yyTop];
 
 			if ((ds.ModFlags & (Modifiers.PRIVATE|Modifiers.PROTECTED)) != 0){
 				Report.Error (1527, ds.Location, 
 				"Namespace elements cannot be explicitly declared as private, protected or protected internal");
 			}
 		}
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 46
 #line 576 "cs-parser.jay"
   {
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 47
 #line 580 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	 }
   break;
 case 53
 #line 606 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			Attributes attrs = (Attributes)yyVals[0+yyTop];
 			if (global_attrs_enabled) {
 				module.AddAttributes (attrs.Attrs, current_namespace);
 			} else {
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 			}
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 54
 #line 623 "cs-parser.jay"
   {
 		global_attrs_enabled = false;
 		yyVal = null;
       }
   break;
 case 55
 #line 628 "cs-parser.jay"
   { 
 		global_attrs_enabled = false;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 56
 #line 637 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect, current_namespace);
 					yyVal = null;
 				} else {
 					yyVal = new Attributes (sect);
 				}
 				if (yyVal == null) {
 					if (RootContext.Documentation != null) {
 						Lexer.check_incorrect_doc_comment ();
 						Lexer.doc_state =
 							XmlCommentState.Allowed;
 					}
 				}
 			} else {
 				yyVal = new Attributes (sect);
 			}		
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 57
 #line 664 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			Attributes attrs = yyVals[-1+yyTop] as Attributes;
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect);
 					yyVal = null;
 				} else {
 					if (attrs == null)
 						attrs = new Attributes (sect);
 					else
 						attrs.AddAttributes (sect);			
 				}
 			} else {
 				if (attrs == null)
 					attrs = new Attributes (sect);
 				else
 					attrs.AddAttributes (sect);
 			}		
 			yyVal = attrs;
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 58
 #line 695 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
  	  }
   break;
 case 59
 #line 699 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 60
 #line 706 "cs-parser.jay"
   {
 		current_attr_target = (string)yyVals[-1+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 61
 #line 714 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = CheckAttributeTarget (lt.Value, lt.Location);
 	  }
   break;
 case 62
 #line 718 "cs-parser.jay"
   { yyVal = "event"; }
   break;
 case 63
 #line 719 "cs-parser.jay"
   { yyVal = "return"; }
   break;
 case 64
 #line 721 "cs-parser.jay"
   {
 		string name = GetTokenName (yyToken);
 		yyVal = CheckAttributeTarget (name, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 65
 #line 729 "cs-parser.jay"
   {
 		yyVal = new List<Attribute> (4) { (Attribute) yyVals[0+yyTop] };
 	  }
   break;
 case 66
 #line 733 "cs-parser.jay"
   {
 		var attrs = (List<Attribute>) yyVals[-2+yyTop];
 		attrs.Add ((Attribute) yyVals[0+yyTop]);
 
 		yyVal = attrs;
 	  }
   break;
 case 67
 #line 743 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 68
 #line 747 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		MemberName mname = (MemberName) yyVals[-2+yyTop];
 		if (mname.IsGeneric) {
 			Report.Error (404, lexer.Location,
 				      "'<' unexpected
 		}
 
 		Arguments [] arguments = (Arguments []) yyVals[0+yyTop];
 		ATypeNameExpression expr = mname.GetTypeExpression ();
 
 		if (current_attr_target == String.Empty)
 			yyVal = null;
 		else if (global_attrs_enabled && (current_attr_target == "assembly" || current_attr_target == "module"))
 			/* FIXME
 			yyVal = new GlobalAttribute (current_namespace, current_attr_target,
 						  expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 		else
 			yyVal = new Attribute (current_attr_target, expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 	  }
   break;
 case 69
 #line 770 "cs-parser.jay"
   { /* reserved attribute name or identifier
   break;
 case 70
 #line 774 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 71
 #line 776 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 72
 #line 783 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 73
 #line 785 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = new Arguments [] { a, null };
 	  }
   break;
 case 74
 #line 791 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);  
 		yyVal = new Arguments [] { null, a };
 	  }
   break;
 case 75
 #line 797 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] != null) {
 			Report.Error (1016, ((Argument) yyVals[0+yyTop]).Expr.Location, "Named attribute arguments must appear after the positional arguments");
 			o [0] = new Arguments (4);
 		}
 		
 		Arguments args = ((Arguments) o [0]);
 		if (args.Count > 0 && !(yyVals[0+yyTop] is NamedArgument) && args [args.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 		
 		args.Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 76
 #line 811 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] == null) {
 			o [1] = new Arguments (4);
 		}
 
 		((Arguments) o [1]).Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 77
 #line 823 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 79
 #line 831 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 80
 #line 835 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop]);	  
 	  }
   break;
 case 81
 #line 844 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "named argument");
 			
 		/* Avoid boxing in common case (no modifier)*/
 		var arg_mod = yyVals[-1+yyTop] == null ? Argument.AType.None 
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop], arg_mod);
 	  }
   break;
 case 82
 #line 857 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 83
 #line 859 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Ref;
 	  }
   break;
 case 84
 #line 863 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Out;
 	  }
   break;
 case 99
 #line 891 "cs-parser.jay"
   {
 		Report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
 			GetSymbolName (yyToken));
 		yyVal = null;
 		lexer.parsing_generic_declaration = false;
 	  }
   break;
 case 100
 #line 904 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 101
 #line 908 "cs-parser.jay"
   { 
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Struct (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 102
 #line 914 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null)
 			current_container.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 103
 #line 925 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 104
 #line 931 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 105
 #line 936 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	  }
   break;
 case 106
 #line 943 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 107
 #line 948 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 122
 #line 985 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var mod = (Modifiers) yyVals[-3+yyTop];
 		current_field = new Const (current_class, (FullNamedExpression) yyVals[-1+yyTop], mod, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 		current_container.AddConstant ((Const) current_field);
 		
 		if ((mod & Modifiers.STATIC) != 0) {
 			Report.Error (504, current_field.Location, "The constant `{0}' cannot be marked static", current_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_field;
 	  }
   break;
 case 123
 #line 998 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_field = null;
 	  }
   break;
 case 126
 #line 1017 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 127
 #line 1021 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 128
 #line 1028 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 129
 #line 1037 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 130
 #line 1041 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 131
 #line 1046 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 		yyVal = null;
 	  }
   break;
 case 134
 #line 1061 "cs-parser.jay"
   {
 	  	lexer.parsing_generic_declaration = false;
 
 		FullNamedExpression type = (FullNamedExpression) yyVals[-1+yyTop];
 		if (type.Type == TypeManager.void_type)
 			Report.Error (670, GetLocation (yyVals[-1+yyTop]), "Fields cannot have void type");
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new Field (current_class, type, (Modifiers) yyVals[-2+yyTop], new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-3+yyTop]);
 		current_container.AddField (current_field);
 		yyVal = current_field;
 	  }
   break;
 case 135
 #line 1076 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 			
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 		current_field = null;
 	  }
   break;
 case 136
 #line 1089 "cs-parser.jay"
   { 
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "fixed size buffers");
 
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new FixedField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop],
 			new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 			
 		current_container.AddField (current_field);
 	  }
   break;
 case 137
 #line 1100 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 	    }
 
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];	    
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 	    current_field = null;
 	  }
   break;
 case 138
 #line 1115 "cs-parser.jay"
   {
 		Report.Error (1641, GetLocation (yyVals[-1+yyTop]), "A fixed size buffer field must have the array size specifier after the field name");
 	  }
   break;
 case 140
 #line 1123 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 141
 #line 1129 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_field.Initializer = (Expression) yyVals[0+yyTop];
 		end_block (lexer.Location);
 		current_local_parameters = null;
 	  }
   break;
 case 144
 #line 1144 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 145
 #line 1148 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 146
 #line 1155 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 147
 #line 1161 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 148
 #line 1165 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 151
 #line 1180 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 152
 #line 1184 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 153
 #line 1191 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];	  
 		yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 154
 #line 1200 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 155
 #line 1204 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 156
 #line 1210 "cs-parser.jay"
   {
 		Report.Error (443, lexer.Location, "Value or constant expected");
 		yyVal = null;
 	  }
   break;
 case 159
 #line 1220 "cs-parser.jay"
   {
 		/* It has to be here for the parent to safely restore artificial block*/
 	  	Error_SyntaxError (yyToken);
 	  	yyVal = null;
 	  }
   break;
 case 160
 #line 1228 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 161
 #line 1233 "cs-parser.jay"
   {
 		Method method = (Method) yyVals[-2+yyTop];
 		method.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (method);
 		
 		if (current_container.Kind == MemberKind.Interface && method.Block != null) {
 			Report.Error (531, method.Location, "`{0}'
 		}
 
 		current_local_parameters = null;
 
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 162
 #line 1254 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 163
 #line 1258 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 164
 #line 1262 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 						     (FullNamedExpression) yyVals[-7+yyTop], current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		} else if (yyVals[0+yyTop] != null) {
 			Report.Error (80, GetLocation (yyVals[0+yyTop]),
 				"Constraints are not allowed on non-generic declarations");
 		}
 
 		Method method = new Method (current_class, generic, (FullNamedExpression) yyVals[-7+yyTop], (Modifiers) yyVals[-8+yyTop],
 				     name, current_local_parameters, (Attributes) yyVals[-9+yyTop]);
 				     
 		if (yyVals[0+yyTop] != null && ((method.ModFlags & Modifiers.OVERRIDE) != 0 || method.IsExplicitImpl)) {
 			Report.Error (460, method.Location,
 				"`{0}'
 				method.GetSignatureForError ());
 		}
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 165
 #line 1299 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 166
 #line 1303 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 167
 #line 1307 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		if (yyVals[-1+yyTop] != null && name.TypeArguments == null)
 			Report.Error (80, lexer.Location,
 				      "Constraints are not allowed on non-generic declarations");
 
 		Method method;
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 				new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		}
 
 		var modifiers = (Modifiers) yyVals[-9+yyTop];
 
 
 		const Modifiers invalid_partial_mod = Modifiers.AccessibilityMask | Modifiers.ABSTRACT | Modifiers.EXTERN |
 			Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.SEALED | Modifiers.VIRTUAL;
 
 		if ((modifiers & invalid_partial_mod) != 0) {
 			Report.Error (750, name.Location, "A partial method cannot define access modifier or " +
        			"any of abstract, extern, new, override, sealed, or virtual modifiers");
 			modifiers &= ~invalid_partial_mod;
 		}
 
 		if ((current_class.ModFlags & Modifiers.PARTIAL) == 0) {
 			Report.Error (751, name.Location, "A partial method must be declared within a " +
        			"partial class or partial struct");
 		}
 		
 		modifiers |= Modifiers.PARTIAL | Modifiers.PRIVATE;
 		
 		method = new Method (current_class, generic, new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				     modifiers, name, current_local_parameters, (Attributes) yyVals[-10+yyTop]);
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		/* TODO
 		StoreModifierLocation (Modifiers.PARTIAL, GetLocation (yyVals[-8+yyTop]));
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 168
 #line 1362 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		Report.Error (1585, name.Location, 
 			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) yyVals[-4+yyTop]));
 
 		Method method = new Method (current_class, null, (FullNamedExpression) yyVals[-5+yyTop],
 					    0, name, (ParametersCompiled) yyVals[-1+yyTop], (Attributes) yyVals[-7+yyTop]);
 
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		yyVal = method;
 	  }
   break;
 case 170
 #line 1381 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 171
 #line 1385 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 173
 #line 1391 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 	  	yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 174
 #line 1396 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = new ParametersCompiled (pars_list.ToArray ()); 
 	  }
   break;
 case 175
 #line 1403 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[0+yyTop])));
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 176
 #line 1409 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[-2+yyTop] } );			
 	  }
   break;
 case 177
 #line 1416 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 178
 #line 1426 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[-2+yyTop])) }, true);
 	  }
   break;
 case 179
 #line 1432 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 180
 #line 1441 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[0+yyTop] } );
 	  }
   break;
 case 181
 #line 1445 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[0+yyTop])) }, true);
 	  }
   break;
 case 182
 #line 1449 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 183
 #line 1457 "cs-parser.jay"
   {
 		parameters_bucket.Clear ();
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		parameters_bucket.Add (p);
 		
 		default_parameter_used = p.HasDefaultValue;
 		yyVal = parameters_bucket;
 	  }
   break;
 case 184
 #line 1466 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		if (p != null) {
 			if (p.HasExtensionMethodModifier)
 				Report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
 			else if (!p.HasDefaultValue && default_parameter_used)
 				Report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");
 
 			default_parameter_used |= p.HasDefaultValue;
 			pars.Add (p);
 			
 			lbag.AddLocation (p, GetLocation (yyVals[-1+yyTop]));
 		}
 		
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 185
 #line 1490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 186
 #line 1498 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		Report.Error (1552, lt.Location, "Array type specifier, [], must appear before parameter name");
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Parameter.Modifier) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop], lt.Location);
 	  }
   break;
 case 187
 #line 1507 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  	Location l = GetLocation (yyVals[0+yyTop]);
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], "NeedSomeGeneratorHere", (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], l);
 	  }
   break;
 case 188
 #line 1517 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 189
 #line 1521 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		if (RootContext.Version <= LanguageVersion.V_3) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "optional parameter");
 		}
 		
 		Parameter.Modifier mod = (Parameter.Modifier) yyVals[-5+yyTop];
 		if (mod != Parameter.Modifier.NONE) {
 			switch (mod) {
 			case Parameter.Modifier.REF
 			case Parameter.Modifier.OUT
 				Report.Error (1741, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 				
 			case Parameter.Modifier.This
 				Report.Error (1743, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 			default
 				throw new NotImplementedException (mod.ToString ());
 			}
 				
 			mod = Parameter.Modifier.NONE;
 		}
 		
 		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
 			Report.Error (1065, GetLocation (yyVals[-2+yyTop]), "Optional parameter is not valid in this context");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-4+yyTop], lt.Value, mod, (Attributes) yyVals[-6+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 		
 		if (yyVals[0+yyTop] != null)
 			((Parameter) yyVal).DefaultValue = new DefaultParameterValueExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 190
 #line 1560 "cs-parser.jay"
   { yyVal = Parameter.Modifier.NONE; }
   break;
 case 192
 #line 1566 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 193
 #line 1570 "cs-parser.jay"
   {
 		Parameter.Modifier p2 = (Parameter.Modifier)yyVals[0+yyTop];
   		Parameter.Modifier mod = (Parameter.Modifier)yyVals[-1+yyTop] | p2;
   		if (((Parameter.Modifier)yyVals[-1+yyTop] & p2) == p2) {
   			Error_DuplicateParameterModifier (lexer.Location, p2);
   		} else {
 	  		switch (mod & ~Parameter.Modifier.This) {
   				case Parameter.Modifier.REF
 					Report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
   					break;
    				case Parameter.Modifier.OUT
 					Report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
   					break;
   				default
  					Report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
  					break;
  			}
   		}
   		yyVal = mod;
 	  }
   break;
 case 194
 #line 1594 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
 	  		Error_ParameterModifierNotValid ("ref", GetLocation (yyVals[0+yyTop]));
 	  		
 	  	yyVal = Parameter.Modifier.REF;
 	  }
   break;
 case 195
 #line 1601 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
 	  		Error_ParameterModifierNotValid ("out", GetLocation (yyVals[0+yyTop]));
 	  
 	  	yyVal = Parameter.Modifier.OUT;
 	  }
   break;
 case 196
 #line 1608 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.This) == 0)
 	  		Error_ParameterModifierNotValid ("this", GetLocation (yyVals[0+yyTop]));
 
 	  	if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "extension methods");
 	  			
 		yyVal = Parameter.Modifier.This;
 	  }
   break;
 case 197
 #line 1621 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 198
 #line 1626 "cs-parser.jay"
   {
 		Report.Error (1751, GetLocation (yyVals[-4+yyTop]), "Cannot specify a default value for a parameter array");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Attributes) yyVals[-5+yyTop], lt.Location);		
 	  }
   break;
 case 199
 #line 1633 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 200
 #line 1641 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.Params) == 0)
 			Report.Error (1670, (GetLocation (yyVals[0+yyTop])), "The `params' modifier is not allowed in current context");
 	  }
   break;
 case 201
 #line 1646 "cs-parser.jay"
   {
 		Parameter.Modifier mod = (Parameter.Modifier)yyVals[0+yyTop];
 		if ((mod & Parameter.Modifier.This) != 0) {
 			Report.Error (1104, GetLocation (yyVals[-1+yyTop]), "The parameter modifiers `this' and `params' cannot be used altogether");
 		} else {
 			Report.Error (1611, GetLocation (yyVals[-1+yyTop]), "The params parameter cannot be declared as ref or out");
 		}	  
 	  }
   break;
 case 202
 #line 1655 "cs-parser.jay"
   {
 		Error_DuplicateParameterModifier (GetLocation (yyVals[-1+yyTop]), Parameter.Modifier.PARAMS);
 	  }
   break;
 case 203
 #line 1662 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Arglist) == 0)
 	  		Report.Error (1669, GetLocation (yyVals[0+yyTop]), "__arglist is not valid in this context");
 	  }
   break;
 case 204
 #line 1673 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			tmpComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 205
 #line 1678 "cs-parser.jay"
   {
 		current_property = new Property (current_class, (FullNamedExpression) yyVals[-3+yyTop], (Modifiers) yyVals[-4+yyTop],
 			(MemberName) yyVals[-2+yyTop], (Attributes) yyVals[-5+yyTop]);
 			
 		if (current_property.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (547, GetLocation (yyVals[-3+yyTop]), "`{0}'
 			
 		current_container.AddProperty ((Property)current_property);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[0+yyTop]));
 		
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 206
 #line 1691 "cs-parser.jay"
   {
 		lexer.PropertyParsing = false;
 		
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();				
 	  }
   break;
 case 207
 #line 1698 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_property, GetLocation (yyVals[0+yyTop]));
 		current_property = null;
 	  }
   break;
 case 208
 #line 1708 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 209
 #line 1712 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  
 		Indexer indexer = new Indexer (current_class, (FullNamedExpression) yyVals[-6+yyTop],
 			(MemberName)yyVals[-5+yyTop], (Modifiers) yyVals[-7+yyTop], (ParametersCompiled) yyVals[-2+yyTop], (Attributes) yyVals[-8+yyTop]);
 			
 		current_property = indexer;
 
   		current_container.AddIndexer (indexer);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
   		
 		if (indexer.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (620, GetLocation (yyVals[-6+yyTop]), "`{0}'
 
 		if (indexer.Parameters.IsEmpty) {
 			Report.Error (1551, GetLocation (yyVals[-4+yyTop]), "Indexers must have at least one parameter");
 		}
 
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 210
 #line 1738 "cs-parser.jay"
   {
 		  lexer.PropertyParsing = false;
 	  }
   break;
 case 211
 #line 1742 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();
 			
 		lbag.AppendToMember (current_property, GetLocation (yyVals[-1+yyTop]));
 		current_property = null;		
 	  }
   break;
 case 216
 #line 1758 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_BRACE) {
 	  		Report.Error (548, lexer.Location, "`{0}'
 		} else {
 			if (yyToken == Token.SEMICOLON)
 				Report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
 			else
 				Report.Error (1014, GetLocation (yyVals[0+yyTop]), "A get or set accessor expected");
 		}
 	  }
   break;
 case 217
 #line 1772 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 	  
 		if (current_property.Get != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 		
 		if (current_property is Indexer) {
 			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop], ((Indexer)current_property).ParameterInfo.Clone (),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Get = new Property.GetMethod (current_property,
 				(Modifiers) yyVals[-1+yyTop], (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}	
 	  
 		current_local_parameters = current_property.Get.ParameterInfo;	  
 		lbag.AddMember (current_property.Get, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 218
 #line 1794 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] != null) {
 	  		current_property.Get.Block = (ToplevelBlock) yyVals[0+yyTop];			
 	  	
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Get.Block.StartLocation,
 					"`{0}'
 			}		
 		}
 	  
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null)
 			if (Lexer.doc_state == XmlCommentState.Error)
 				Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 219
 #line 1815 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 		
 		if (current_property.Set != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 	  
 		if (current_property is Indexer) {
 			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop],
 				ParametersCompiled.MergeGenerated (compiler,
 				((Indexer)current_property).ParameterInfo, true, new Parameter (
 					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation (yyVals[0+yyTop])),
 					null),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Set = new Property.SetMethod (current_property, (Modifiers) yyVals[-1+yyTop], 
 				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation (yyVals[0+yyTop])),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}
 		
 		current_local_parameters = current_property.Set.ParameterInfo;	
 		lbag.AddMember (current_property.Set, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 220
 #line 1842 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {		
 			current_property.Set.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Set.Block.StartLocation,
 					"`{0}'
 			}
 		}
 		
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null
 			&& Lexer.doc_state == XmlCommentState.Error)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 222
 #line 1864 "cs-parser.jay"
   {
 		/* TODO
 	  	yyVal = null;
 	  }
   break;
 case 223
 #line 1869 "cs-parser.jay"
   {
 	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
 	  	yyVal = null;
 	  }
   break;
 case 224
 #line 1880 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 225
 #line 1884 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Interface (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 226
 #line 1891 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 227
 #line 1902 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 228
 #line 1908 "cs-parser.jay"
   {
 	    lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 229
 #line 1913 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  }
   break;
 case 234
 #line 1930 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 235
 #line 1934 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 240
 #line 1942 "cs-parser.jay"
   {
 	  	Report.Error (567, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain operators");
 	  }
   break;
 case 241
 #line 1946 "cs-parser.jay"
   {
 	  	Report.Error (526, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain contructors");
 	  }
   break;
 case 242
 #line 1950 "cs-parser.jay"
   {
 	  	Report.Error (524, GetLocation (yyVals[0+yyTop]), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
 	  }
   break;
 case 243
 #line 1957 "cs-parser.jay"
   {
 	  }
   break;
 case 244
 #line 1960 "cs-parser.jay"
   {
 		OperatorDeclaration decl = (OperatorDeclaration) yyVals[-2+yyTop];
 		if (decl != null) {
 			Operator op = new Operator (
 				current_class, decl.optype, decl.ret_type, (Modifiers) yyVals[-3+yyTop], 
 				current_local_parameters,
 				(ToplevelBlock) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop], decl.location);
 
 			if (RootContext.Documentation != null) {
 				op.DocComment = tmpComment;
 				Lexer.doc_state = XmlCommentState.Allowed;
 			}
 
 			/* Note again, checking is done in semantic analysis*/
 			current_container.AddOperator (op);
 
 			lbag.AddMember (op, mod_locations, lbag.GetLocations (decl));
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 246
 #line 1985 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 248
 #line 1991 "cs-parser.jay"
   {
 		Report.Error (590, GetLocation (yyVals[0+yyTop]), "User-defined operators cannot return void");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 249
 #line 1999 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 250
 #line 2003 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		Operator.OpType op = (Operator.OpType) yyVals[-4+yyTop];
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];
 		
 		int p_count = current_local_parameters.Count;
 		if (p_count == 1) {
 			if (op == Operator.OpType.Addition)
 				op = Operator.OpType.UnaryPlus;
 			else if (op == Operator.OpType.Subtraction)
 				op = Operator.OpType.UnaryNegation;
 		}
 		
 		if (IsUnaryOperator (op)) {
 			if (p_count == 2) {
 				Report.Error (1020, loc, "Overloadable binary operator expected");
 			} else if (p_count != 1) {
 				Report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
 					Operator.GetName (op));
 			}
 		} else {
 			if (p_count > 2) {
 				Report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
 					Operator.GetName (op));
 			} else if (p_count != 2) {
 				Report.Error (1019, loc, "Overloadable unary operator expected");
 			}
 		}
 		
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (op, (FullNamedExpression) yyVals[-6+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 252
 #line 2047 "cs-parser.jay"
   { yyVal = Operator.OpType.LogicalNot; }
   break;
 case 253
 #line 2048 "cs-parser.jay"
   { yyVal = Operator.OpType.OnesComplement; }
   break;
 case 254
 #line 2049 "cs-parser.jay"
   { yyVal = Operator.OpType.Increment; }
   break;
 case 255
 #line 2050 "cs-parser.jay"
   { yyVal = Operator.OpType.Decrement; }
   break;
 case 256
 #line 2051 "cs-parser.jay"
   { yyVal = Operator.OpType.True; }
   break;
 case 257
 #line 2052 "cs-parser.jay"
   { yyVal = Operator.OpType.False; }
   break;
 case 258
 #line 2054 "cs-parser.jay"
   { yyVal = Operator.OpType.Addition; }
   break;
 case 259
 #line 2055 "cs-parser.jay"
   { yyVal = Operator.OpType.Subtraction; }
   break;
 case 260
 #line 2057 "cs-parser.jay"
   { yyVal = Operator.OpType.Multiply; }
   break;
 case 261
 #line 2058 "cs-parser.jay"
   {  yyVal = Operator.OpType.Division; }
   break;
 case 262
 #line 2059 "cs-parser.jay"
   { yyVal = Operator.OpType.Modulus; }
   break;
 case 263
 #line 2060 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseAnd; }
   break;
 case 264
 #line 2061 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseOr; }
   break;
 case 265
 #line 2062 "cs-parser.jay"
   { yyVal = Operator.OpType.ExclusiveOr; }
   break;
 case 266
 #line 2063 "cs-parser.jay"
   { yyVal = Operator.OpType.LeftShift; }
   break;
 case 267
 #line 2064 "cs-parser.jay"
   { yyVal = Operator.OpType.RightShift; }
   break;
 case 268
 #line 2065 "cs-parser.jay"
   { yyVal = Operator.OpType.Equality; }
   break;
 case 269
 #line 2066 "cs-parser.jay"
   { yyVal = Operator.OpType.Inequality; }
   break;
 case 270
 #line 2067 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThan; }
   break;
 case 271
 #line 2068 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThan; }
   break;
 case 272
 #line 2069 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThanOrEqual; }
   break;
 case 273
 #line 2070 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThanOrEqual; }
   break;
 case 274
 #line 2075 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 275
 #line 2079 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 276
 #line 2094 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 277
 #line 2098 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 278
 #line 2113 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 279
 #line 2119 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	yyVal = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 280
 #line 2129 "cs-parser.jay"
   { 
 		Constructor c = (Constructor) yyVals[-1+yyTop];
 		c.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (RootContext.Documentation != null)
 			c.DocComment = ConsumeStoredComment ();
 
 		current_container.AddConstructor (c);
 
 		current_local_parameters = null;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 281
 #line 2148 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 282
 #line 2157 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];  
 		
 		/**/
 		/* start block here, so possible anonymous methods inside*/
 		/* constructor initializer can get correct parent block*/
 		/**/
 	  	start_block (lexer.Location);
 	  }
   break;
 case 283
 #line 2168 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-6+yyTop];
 		var mods = (Modifiers) yyVals[-7+yyTop];
 		ConstructorInitializer ci = (ConstructorInitializer) yyVals[0+yyTop];
 
 		Constructor c = new Constructor (current_class, lt.Value, mods,
 			(Attributes) yyVals[-8+yyTop], current_local_parameters, ci, lt.Location);
 		
 		if (lt.Value != current_container.MemberName.Name) {
 			Report.Error (1520, c.Location, "Class, struct, or interface method must have a return type");
 		} else if ((mods & Modifiers.STATIC) != 0) {
 			if ((mods & Modifiers.AccessibilityMask) != 0){
 				Report.Error (515, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			}
 			if (ci != null) {
 				Report.Error (514, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			
 			}
 		}
 		
 		lbag.AddMember (c, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 285
 #line 2199 "cs-parser.jay"
   { current_block = null; yyVal = null; }
   break;
 case 288
 #line 2209 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 289
 #line 2213 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorBaseInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 290
 #line 2219 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 291
 #line 2223 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorThisInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 292
 #line 2229 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 293
 #line 2237 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 		
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 294
 #line 2246 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		if (lt.Value != current_container.MemberName.Name){
 			Report.Error (574, lt.Location, "Name of destructor must match name of class");
 		} else if (current_container.Kind != MemberKind.Class){
 			Report.Error (575, lt.Location, "Only class types can contain destructor");
 		}
 		
 		Destructor d = new Destructor (current_class, (Modifiers) yyVals[-6+yyTop],
 			ParametersCompiled.EmptyReadOnlyParameters, (Attributes) yyVals[-7+yyTop], lt.Location);
 		if (RootContext.Documentation != null)
 			d.DocComment = ConsumeStoredComment ();
 		  
 		d.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (d);
 		lbag.AddMember (d, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		current_local_parameters = null;
 	  }
   break;
 case 295
 #line 2271 "cs-parser.jay"
   {
 		current_event_field = new EventField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop], (MemberName) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop]);
 		current_container.AddEvent (current_event_field);
 		
 		if (current_event_field.MemberName.Left != null) {
 			Report.Error (71, current_event_field.Location, "`{0}'
 			current_event_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_event_field;
 	  }
   break;
 case 296
 #line 2285 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AddMember (current_event_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_event_field = null;
 	  }
   break;
 case 297
 #line 2298 "cs-parser.jay"
   {
 		current_event = new EventProperty (current_class, (FullNamedExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-4+yyTop], (MemberName) yyVals[-1+yyTop], (Attributes) yyVals[-5+yyTop]);
 		current_container.AddEvent (current_event);
 		lbag.AddMember (current_event, mod_locations, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		
 		lexer.EventParsing = true;
 	  }
   break;
 case 298
 #line 2306 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface)
 			Report.Error (69, GetLocation (yyVals[-2+yyTop]), "Event in interface cannot have add or remove accessors");
 	  
 		lexer.EventParsing = false;
 	  }
   break;
 case 299
 #line 2313 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AppendToMember (current_event, GetLocation (yyVals[-1+yyTop]));
 	  	current_event = null;	
 		current_local_parameters = null;
 	  }
   break;
 case 301
 #line 2328 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 302
 #line 2332 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_event_field.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 305
 #line 2345 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 306
 #line 2349 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 307
 #line 2356 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 308
 #line 2362 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 309
 #line 2366 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 310
 #line 2375 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (68, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 		}
 		
 	  	if ((current_event_field.ModFlags & Modifiers.ABSTRACT) != 0) {
 			Report.Error (74, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 	  	}		
 	  }
   break;
 case 311
 #line 2387 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 314
 #line 2396 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 315
 #line 2401 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 316
 #line 2406 "cs-parser.jay"
   { 
 		Report.Error (1055, GetLocation (yyVals[0+yyTop]), "An add or remove accessor expected");
 		yyVal = null;
 	  }
   break;
 case 317
 #line 2414 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Add = new EventProperty.AddDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Add.ParameterInfo;
 		
 		lbag.AddMember (current_event.Add, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 318
 #line 2426 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Add.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Add.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 319
 #line 2442 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Remove = new EventProperty.RemoveDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Remove.ParameterInfo;
 
 		lbag.AddMember (current_event.Remove, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 320
 #line 2454 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Remove.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Remove.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 321
 #line 2470 "cs-parser.jay"
   {
 		Report.Error (73, lexer.Location, "An add or remove accessor must have a body");
 		yyVal = null;
 	  }
   break;
 case 323
 #line 2482 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			enumTypeComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 324
 #line 2487 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		if (name.IsGeneric) {
 			Report.Error (1675, name.Location, "Enums cannot have type parameters");
 		}
 		
 		push_current_class (new Enum (current_namespace, current_class, (TypeExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-5+yyTop], MakeName (name), (Attributes) yyVals[-6+yyTop]), null);
 	  }
   break;
 case 325
 #line 2499 "cs-parser.jay"
   {
 	  	/* here will be evaluated after CLOSE_BLACE is consumed.*/
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 326
 #line 2505 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			current_class.DocComment = enumTypeComment;
 			
 		--lexer.parsing_declaration;
 
 /*			if (RootContext.Documentation != null)*/
 /*				em.DocComment = ev.DocComment;*/
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-9+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 328
 #line 2522 "cs-parser.jay"
   {
 	 	var te = yyVals[0+yyTop] as TypeExpression;
 		if (te == null ||
 			(te.Type != TypeManager.int32_type && te.Type != TypeManager.uint32_type &&
 			te.Type != TypeManager.int64_type && te.Type != TypeManager.uint64_type &&
 			te.Type != TypeManager.short_type && te.Type != TypeManager.ushort_type &&
 			te.Type != TypeManager.byte_type && te.Type != TypeManager.sbyte_type)) {
 			Enum.Error_1008 (GetLocation (yyVals[0+yyTop]), Report);
 			yyVal = null;
 		} else {
 			yyVal = yyVals[0+yyTop];
 		}
 	 }
   break;
 case 329
 #line 2536 "cs-parser.jay"
   {
 	 	Error_TypeExpected (GetLocation (yyVals[-1+yyTop]));
 		yyVal = null;
 	 }
   break;
 case 332
 #line 2546 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 334
 #line 2554 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 335
 #line 2562 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-1+yyTop]);
 	  	((Enum) current_class).AddEnumMember (em);
 
 		if (RootContext.Documentation != null) {
 			em.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		yyVal = em;
 	  }
   break;
 case 336
 #line 2575 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 	  }
   break;
 case 337
 #line 2583 "cs-parser.jay"
   { 
 		--lexer.parsing_block;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 	  	em.Initializer = new ConstInitializer (em, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	((Enum) current_class).AddEnumMember (em);
 		
 		if (RootContext.Documentation != null)
 			em.DocComment = ConsumeStoredComment ();
 
 		yyVal = em;
 	  }
   break;
 case 338
 #line 2604 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out | ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 339
 #line 2608 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		MemberName name = MakeName ((MemberName) yyVals[-4+yyTop]);
 		ParametersCompiled p = (ParametersCompiled) yyVals[-1+yyTop];
 
 		Delegate del = new Delegate (current_namespace, current_class, (FullNamedExpression) yyVals[-5+yyTop],
 					     (Modifiers) yyVals[-7+yyTop], name, p, (Attributes) yyVals[-8+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			del.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		current_container.AddDelegate (del);
 		current_delegate = del;
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 340
 #line 2627 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 	  }
   break;
 case 341
 #line 2631 "cs-parser.jay"
   {
 		current_delegate.SetParameterInfo ((List<Constraints>) yyVals[-2+yyTop]);
 		lbag.AddMember (current_delegate, mod_locations, GetLocation (yyVals[-10+yyTop]), GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[0+yyTop]));
 
 		yyVal = current_delegate;
 
 		current_delegate = null;
 	  }
   break;
 case 343
 #line 2644 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "nullable types");
 	  
 	  	yyVal = ComposedTypeSpecifier.CreateNullable (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 345
 #line 2655 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 347
 #line 2666 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 348
 #line 2675 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 350
 #line 2687 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");	  
 	  
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 351
 #line 2694 "cs-parser.jay"
   {
 		Error_TypeExpected (lexer.Location);
 		yyVal = new TypeArguments ();
 	  }
   break;
 case 352
 #line 2702 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 353
 #line 2708 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 354
 #line 2720 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 355
 #line 2724 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 356
 #line 2733 "cs-parser.jay"
   {
 	  	MemberName mn = (MemberName)yyVals[0+yyTop];
 	  	if (mn.TypeArguments != null)
 	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
 	  			mn.GetSignatureForError ()));
 	  }
   break;
 case 358
 #line 2744 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 359
 #line 2753 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		yyVal = new MemberName (TypeContainer.DefaultIndexerName, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 360
 #line 2758 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		yyVal = new MemberName ((MemberName) yyVals[-1+yyTop], TypeContainer.DefaultIndexerName, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 361
 #line 2766 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 362
 #line 2772 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[-1+yyTop], lt1.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 363
 #line 2780 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 365
 #line 2790 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");
 	  
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 366
 #line 2801 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 367
 #line 2807 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 		lbag.AddLocation (yyVals[0+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 368
 #line 2817 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 		yyVal = new TypeParameterName (lt.Value, (Attributes)yyVals[-2+yyTop], (Variance) yyVals[-1+yyTop], lt.Location);
   	  }
   break;
 case 369
 #line 2822 "cs-parser.jay"
   {
   	  	if (GetTokenName (yyToken) == "type")
 			Report.Error (81, GetLocation (yyVals[0+yyTop]), "Type parameter declaration must be an identifier not a type");
 		else
 			Error_SyntaxError (yyToken);
 			
   	  	yyVal = new TypeParameterName ("", null, lexer.Location);
   	  }
   break;
 case 371
 #line 2838 "cs-parser.jay"
   {
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 372
 #line 2845 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 374
 #line 2856 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 376
 #line 2865 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 378
 #line 2874 "cs-parser.jay"
   {
 	  	Report.Error (1536, GetLocation (yyVals[0+yyTop]), "Invalid parameter type `void'");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 380
 #line 2883 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 381
 #line 2890 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-1+yyTop];
 
 		if (yyVals[0+yyTop] != null) {
 			yyVal = new ComposedCast (name.GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			if (name.Left == null && name.Name == "var")
 				yyVal = new VarExpr (name.Location);
 			else
 				yyVal = name.GetTypeExpression ();
 		}
 	  }
   break;
 case 382
 #line 2903 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (((MemberName) yyVals[-1+yyTop]).GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 383
 #line 2907 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null)
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 384
 #line 2912 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 385
 #line 2916 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 386
 #line 2923 "cs-parser.jay"
   {
 		var types = new List<FullNamedExpression> (2);
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 387
 #line 2929 "cs-parser.jay"
   {
 		var types = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 388
 #line 2938 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast) {
 			Report.Error (1521, GetLocation (yyVals[0+yyTop]), "Invalid base type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 389
 #line 2945 "cs-parser.jay"
   {
 	  	Error_TypeExpected (lexer.Location);
 		yyVal = null;
 	  }
   break;
 case 390
 #line 2956 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.object_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 391
 #line 2957 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.string_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 392
 #line 2958 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.bool_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 393
 #line 2959 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.decimal_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 394
 #line 2960 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.float_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 395
 #line 2961 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.double_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 397
 #line 2966 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.sbyte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 398
 #line 2967 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.byte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 399
 #line 2968 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.short_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 400
 #line 2969 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.ushort_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 401
 #line 2970 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 402
 #line 2971 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 403
 #line 2972 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 404
 #line 2973 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 405
 #line 2974 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.char_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 425
 #line 3006 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new SimpleName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 426
 #line 3010 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	       yyVal = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
 	  }
   break;
 case 430
 #line 3020 "cs-parser.jay"
   { yyVal = new NullLiteral (GetLocation (yyVals[0+yyTop])); }
   break;
 case 431
 #line 3024 "cs-parser.jay"
   { yyVal = new BoolLiteral (true, GetLocation (yyVals[0+yyTop])); }
   break;
 case 432
 #line 3025 "cs-parser.jay"
   { yyVal = new BoolLiteral (false, GetLocation (yyVals[0+yyTop])); }
   break;
 case 437
 #line 3051 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 438
 #line 3056 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 	  }
   break;
 case 439
 #line 3063 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 440
 #line 3069 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 441
 #line 3075 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 442
 #line 3081 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 443
 #line 3087 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null,GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 444
 #line 3090 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
 	  }
   break;
 case 445
 #line 3095 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null, lexer.Location);
 	  }
   break;
 case 446
 #line 3098 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
  	  }
   break;
 case 447
 #line 3106 "cs-parser.jay"
   {
 		yyVal = new Invocation ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 448
 #line 3113 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 450
 #line 3119 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] == null) {
 	  		yyVal = CollectionOrObjectInitializers.Empty;
 	  		/* TODO
 	  	} else {
 	  		yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  	}
 	  }
   break;
 case 451
 #line 3129 "cs-parser.jay"
   {
 	  	yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 452
 #line 3136 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 453
 #line 3138 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	}
   break;
 case 454
 #line 3145 "cs-parser.jay"
   {
 	  	var a = new List<Expression> ();
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 455
 #line 3151 "cs-parser.jay"
   {
 	  	var a = (List<Expression>)yyVals[-2+yyTop];
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 456
 #line 3156 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 457
 #line 3164 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 	  	yyVal = new ElementInitializer (lt.Value, (Expression)yyVals[0+yyTop], lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 458
 #line 3170 "cs-parser.jay"
   {
 		yyVal = new CompletionElementInitializer (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 459
 #line 3173 "cs-parser.jay"
   {
 		CompletionSimpleName csn = yyVals[-1+yyTop] as CompletionSimpleName;
 		if (csn == null)
 			yyVal = new CollectionElementInitializer ((Expression)yyVals[-1+yyTop]);
 		else
 			yyVal = new CompletionElementInitializer (csn.Prefix, csn.Location);
 	  }
   break;
 case 460
 #line 3181 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] == null)
 			yyVal = null;
 		else
 	  		yyVal = new CollectionElementInitializer ((List<Expression>)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 461
 #line 3188 "cs-parser.jay"
   {
 	  	Report.Error (1920, GetLocation (yyVals[-1+yyTop]), "An element initializer cannot be empty");
 		yyVal = null;
 	  }
   break;
 case 464
 #line 3200 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 466
 #line 3206 "cs-parser.jay"
   { 
 		Arguments list = new Arguments (4);
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 467
 #line 3212 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		if (list [list.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
 		
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 468
 #line 3221 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		NamedArgument a = (NamedArgument) yyVals[0+yyTop];
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		
 		list.Add (a);
 		yyVal = list;
 	  }
   break;
 case 469
 #line 3235 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[0+yyTop]), "An argument is missing");
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 470
 #line 3240 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[-1+yyTop]), "An argument is missing");
 	  	yyVal = null;
 	  }
   break;
 case 471
 #line 3248 "cs-parser.jay"
   {
 		yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 475
 #line 3261 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Ref);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 476
 #line 3266 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Out);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 477
 #line 3271 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 478
 #line 3276 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist (GetLocation (yyVals[-2+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 480
 #line 3288 "cs-parser.jay"
   {
 		yyVal = new ElementAccess ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 481
 #line 3296 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 482
 #line 3302 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 483
 #line 3307 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 484
 #line 3315 "cs-parser.jay"
   {
 		Arguments args = new Arguments (4);
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;
 	  }
   break;
 case 485
 #line 3321 "cs-parser.jay"
   {
 		Arguments args = (Arguments) yyVals[-2+yyTop];
 		if (args [args.Count - 1] is NamedArgument && !(yyVals[0+yyTop] is NamedArgument))
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 	  
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;	  
 	  }
   break;
 case 486
 #line 3333 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 488
 #line 3341 "cs-parser.jay"
   {
 		yyVal = new This (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 489
 #line 3348 "cs-parser.jay"
   {
 	  	yyVal = new ElementAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 490
 #line 3353 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = new ElementAccess (null, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 491
 #line 3361 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 492
 #line 3368 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 493
 #line 3375 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			if (RootContext.Version <= LanguageVersion.ISO_2)
 				Report.FeatureIsNotAvailable (GetLocation (yyVals[-5+yyTop]), "object initializers");
 				
 			yyVal = new NewInitialize ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		} else {
 			yyVal = new New ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], GetLocation (yyVals[-5+yyTop]));
 		}
 		
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 494
 #line 3388 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "collection initializers");
 	  
 		yyVal = new NewInitialize ((FullNamedExpression) yyVals[-1+yyTop], null, (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 495
 #line 3400 "cs-parser.jay"
   {
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], (List<Expression>) yyVals[-3+yyTop],
 				new ComposedTypeSpecifier (((List<Expression>) yyVals[-3+yyTop]).Count, GetLocation (yyVals[-4+yyTop])) {
 	  				Next = (ComposedTypeSpecifier) yyVals[-1+yyTop]
 			  	}, (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 496
 #line 3408 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] == null)
 	  		Report.Error (1586, GetLocation (yyVals[-3+yyTop]), "Array creation must have array size or array initializer");
 
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-2+yyTop], (ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 497
 #line 3415 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "implicitly typed arrays");
 	  
 		yyVal = new ImplicitlyTypedArrayCreation ((ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 498
 #line 3422 "cs-parser.jay"
   {
 		Report.Error (178, GetLocation (yyVals[-1+yyTop]), "Invalid rank specifier, expecting `,' or `]'");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], null, GetLocation (yyVals[-6+yyTop]));
 	  }
   break;
 case 499
 #line 3427 "cs-parser.jay"
   {
 		Error_SyntaxError (1526, yyToken, "Unexpected symbol");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-1+yyTop], null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 500
 #line 3434 "cs-parser.jay"
   {
 		++lexer.parsing_type;
 	  }
   break;
 case 501
 #line 3438 "cs-parser.jay"
   {
 		--lexer.parsing_type;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 502
 #line 3446 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "anonymous types");
 
 		yyVal = new NewAnonymousType ((List<AnonymousTypeParameter>) yyVals[-1+yyTop], current_container, GetLocation (yyVals[-3+yyTop]));
 		
 		/* TODO
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 505
 #line 3463 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 507
 #line 3469 "cs-parser.jay"
   {
 	  	var a = new List<AnonymousTypeParameter> (4);
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 508
 #line 3475 "cs-parser.jay"
   {
 	  	var a = (List<AnonymousTypeParameter>) yyVals[-2+yyTop];
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 509
 #line 3484 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[-2+yyTop];
 	  	yyVal = new AnonymousTypeParameter ((Expression)yyVals[0+yyTop], lt.Value, lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 510
 #line 3490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (new SimpleName (lt.Value, lt.Location),
 	  		lt.Value, lt.Location);
 	  }
   break;
 case 511
 #line 3496 "cs-parser.jay"
   {
 	  	MemberAccess ma = (MemberAccess) yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (ma, ma.Name, ma.Location);
 	  }
   break;
 case 512
 #line 3501 "cs-parser.jay"
   {
 		Report.Error (746, lexer.Location,
 			"Invalid anonymous type member declarator. Anonymous type members must be a member assignment, simple name or member access expression");
 		yyVal = null;
 	  }
   break;
 case 516
 #line 3516 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 517
 #line 3524 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 518
 #line 3528 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension ((int)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 519
 #line 3535 "cs-parser.jay"
   {
 		yyVal = 2;
 	  }
   break;
 case 520
 #line 3539 "cs-parser.jay"
   {
 		yyVal = ((int) yyVals[-1+yyTop]) + 1;
 	  }
   break;
 case 521
 #line 3546 "cs-parser.jay"
   {
 		yyVal = null;
 	  }
   break;
 case 522
 #line 3550 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 523
 #line 3557 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer (0, GetLocation (yyVals[-1+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[0+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 524
 #line 3564 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[-1+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 525
 #line 3574 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 526
 #line 3580 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 527
 #line 3589 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = true;
 	  }
   break;
 case 528
 #line 3593 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = false;
 		yyVal = new TypeOf ((FullNamedExpression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 531
 #line 3604 "cs-parser.jay"
   {
 	 	Error_TypeExpected (lexer.Location);
 	 	yyVal = null;
 	 }
   break;
 case 532
 #line 3612 "cs-parser.jay"
   {  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new SimpleName (lt.Value, (int) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 533
 #line 3618 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (int) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 534
 #line 3625 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 535
 #line 3631 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 536
 #line 3637 "cs-parser.jay"
   {
 		var te = ((MemberName) yyVals[-3+yyTop]).GetTypeExpression ();
 		if (te.HasTypeArguments)
 			Error_TypeExpected (GetLocation (yyVals[0+yyTop]));
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (te, lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 537
 #line 3649 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "generics");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 538
 #line 3659 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		if (RootContext.Version == LanguageVersion.ISO_1)
 			Report.FeatureIsNotAvailable (lt.Location, "namespace alias qualifier");
 
 		yyVal = lt;		
 	  }
   break;
 case 539
 #line 3670 "cs-parser.jay"
   { 
 		yyVal = new SizeOf ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 540
 #line 3678 "cs-parser.jay"
   {
 		yyVal = new CheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 541
 #line 3686 "cs-parser.jay"
   {
 		yyVal = new UnCheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 542
 #line 3694 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberAccess (new Indirection ((Expression) yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop])), lt.Value, lt.Location);
 	  }
   break;
 case 543
 #line 3702 "cs-parser.jay"
   {
 		start_anonymous (false, (ParametersCompiled) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 544
 #line 3706 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 	  }
   break;
 case 545
 #line 3713 "cs-parser.jay"
   {
 		yyVal = ParametersCompiled.Undefined;
 	  }
   break;
 case 547
 #line 3721 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 548
 #line 3725 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 549
 #line 3733 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "default value expression");
 
 		yyVal = new DefaultValueExpression ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 551
 #line 3745 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.LogicalNot, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 552
 #line 3749 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.OnesComplement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 554
 #line 3757 "cs-parser.jay"
   {
 		yyVal = new Cast ((FullNamedExpression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 556
 #line 3770 "cs-parser.jay"
   { 
 	  	yyVal = new Unary (Unary.Operator.UnaryPlus, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 557
 #line 3774 "cs-parser.jay"
   { 
 		yyVal = new Unary (Unary.Operator.UnaryNegation, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 558
 #line 3778 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 559
 #line 3782 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 560
 #line 3786 "cs-parser.jay"
   {
 		yyVal = new Indirection ((Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 561
 #line 3790 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.AddressOf, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 563
 #line 3798 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Multiply, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 564
 #line 3803 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Division, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 565
 #line 3808 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Modulus, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 567
 #line 3817 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Addition, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 568
 #line 3822 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 569
 #line 3826 "cs-parser.jay"
   {
 	  	/* Shift/Reduce conflict*/
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
   	  }
   break;
 case 570
 #line 3831 "cs-parser.jay"
   {
 		yyVal = new As ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 571
 #line 3835 "cs-parser.jay"
   {
 		yyVal = new Is ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 573
 #line 3843 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LeftShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 574
 #line 3848 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.RightShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 576
 #line 3857 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 577
 #line 3862 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 578
 #line 3867 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 579
 #line 3872 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 581
 #line 3881 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Equality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 582
 #line 3886 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Inequality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 584
 #line 3895 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 586
 #line 3904 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.ExclusiveOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 588
 #line 3913 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 590
 #line 3922 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 592
 #line 3931 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 594
 #line 3940 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "null coalescing operator");
 			
 		yyVal = new Nullable.NullCoalescingOperator ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 596
 #line 3951 "cs-parser.jay"
   {
 		yyVal = new Conditional (new BooleanExpression ((Expression) yyVals[-4+yyTop]), (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 597
 #line 3959 "cs-parser.jay"
   {
 		yyVal = new SimpleAssign ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 598
 #line 3963 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Multiply, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 599
 #line 3968 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Division, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 600
 #line 3973 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Modulus, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 601
 #line 3978 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Addition, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 602
 #line 3983 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 603
 #line 3988 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.LeftShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 604
 #line 3993 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.RightShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 605
 #line 3998 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseAnd, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 606
 #line 4003 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 607
 #line 4008 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.ExclusiveOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 608
 #line 4016 "cs-parser.jay"
   {
 		var pars = new List<Parameter> (4);
 		pars.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = pars;
 	  }
   break;
 case 609
 #line 4023 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter)yyVals[0+yyTop];
 		if (pars[0].GetType () != p.GetType ()) {
 			Report.Error (748, p.Location, "All lambda parameters must be typed either explicitly or implicitly");
 		}
 		
 		pars.Add (p);
 		yyVal = pars;
 	  }
   break;
 case 610
 #line 4037 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], null, lt.Location);
 	  }
   break;
 case 611
 #line 4043 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, Parameter.Modifier.NONE, null, lt.Location);
 	  }
   break;
 case 612
 #line 4049 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ImplicitLambdaParameter (lt.Value, lt.Location);
 	  }
   break;
 case 613
 #line 4056 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 614
 #line 4057 "cs-parser.jay"
   { 
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 		yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 617
 #line 4069 "cs-parser.jay"
   {
 		start_block (lexer.Location);
 	  }
   break;
 case 618
 #line 4073 "cs-parser.jay"
   {
 		Block b = end_block (lexer.Location);
 		b.AddStatement (new ContextualReturn ((Expression) yyVals[0+yyTop]));
 		yyVal = b;
 	  }
   break;
 case 620
 #line 4083 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	
 		yyVal = EmptyExpression.Null;
 	  }
   break;
 case 621
 #line 4091 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
 		start_anonymous (true, new ParametersCompiled (p), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 622
 #line 4097 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 623
 #line 4102 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "lambda expressions");
 	  
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 624
 #line 4109 "cs-parser.jay"
   {
 	  	valid_param_mod = 0;
 		start_anonymous (true, (ParametersCompiled) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 625
 #line 4114 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 631
 #line 4130 "cs-parser.jay"
   {
 		yyVal = new ArglistAccess (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 633
 #line 4141 "cs-parser.jay"
   {
 		yyVal = new BooleanExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 634
 #line 4154 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 635
 #line 4158 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Class (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 636
 #line 4164 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 637
 #line 4176 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 638
 #line 4182 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 639
 #line 4190 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 640
 #line 4192 "cs-parser.jay"
   { yyVal = yyVals[0+yyTop]; }
   break;
 case 641
 #line 4197 "cs-parser.jay"
   {
 	    mod_locations = null;
 		yyVal = ModifierNone;
 	  }
   break;
 case 644
 #line 4207 "cs-parser.jay"
   { 
 		var m1 = (Modifiers) yyVals[-1+yyTop];
 		var m2 = (Modifiers) yyVals[0+yyTop];
 
 		if ((m1 & m2) != 0) {
 			Report.Error (1004, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"Duplicate `{0}' modifier", ModifiersExtensions.Name (m2));
 		} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
 			((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
 			Report.Error (107, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"More than one protection modifier specified");
 		}
 		
 		yyVal = m1 | m2;
 	  }
   break;
 case 645
 #line 4226 "cs-parser.jay"
   {
 		yyVal = Modifiers.NEW;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		
 		if (current_container == RootContext.ToplevelTypes)
 			Report.Error (1530, GetLocation (yyVals[0+yyTop]), "Keyword `new' is not allowed on namespace elements");
 	  }
   break;
 case 646
 #line 4234 "cs-parser.jay"
   {
 		yyVal = Modifiers.PUBLIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 647
 #line 4239 "cs-parser.jay"
   {
 		yyVal = Modifiers.PROTECTED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 648
 #line 4244 "cs-parser.jay"
   {
 		yyVal = Modifiers.INTERNAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 649
 #line 4249 "cs-parser.jay"
   {
 		yyVal = Modifiers.PRIVATE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 650
 #line 4254 "cs-parser.jay"
   {
 		yyVal = Modifiers.ABSTRACT;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 651
 #line 4259 "cs-parser.jay"
   {
 		yyVal = Modifiers.SEALED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 652
 #line 4264 "cs-parser.jay"
   {
 		yyVal = Modifiers.STATIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 653
 #line 4269 "cs-parser.jay"
   {
 		yyVal = Modifiers.READONLY;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 654
 #line 4274 "cs-parser.jay"
   {
 		yyVal = Modifiers.VIRTUAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 655
 #line 4279 "cs-parser.jay"
   {
 		yyVal = Modifiers.OVERRIDE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 656
 #line 4284 "cs-parser.jay"
   {
 		yyVal = Modifiers.EXTERN;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 657
 #line 4289 "cs-parser.jay"
   {
 		yyVal = Modifiers.VOLATILE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 658
 #line 4294 "cs-parser.jay"
   {
 		yyVal = Modifiers.UNSAFE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 659
 #line 4301 "cs-parser.jay"
   {
 		yyVal = Modifiers.ASYNC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 661
 #line 4310 "cs-parser.jay"
   {
 		current_container.AddBasesForPart (current_class, (List<FullNamedExpression>) yyVals[0+yyTop]);
 	 }
   break;
 case 663
 #line 4318 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 664
 #line 4322 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	 }
   break;
 case 665
 #line 4330 "cs-parser.jay"
   {
 		var constraints = new List<Constraints> (1);
 		constraints.Add ((Constraints) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 666
 #line 4336 "cs-parser.jay"
   {
 		var constraints = (List<Constraints>) yyVals[-1+yyTop];
 		Constraints new_constraint = (Constraints)yyVals[0+yyTop];
 
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 
 		constraints.Add (new_constraint);
 		yyVal = constraints;
 	  }
   break;
 case 667
 #line 4355 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 668
 #line 4363 "cs-parser.jay"
   {
 		var constraints = new List<FullNamedExpression> (1);
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 669
 #line 4369 "cs-parser.jay"
   {
 		var constraints = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
 		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
 			Report.Error (401, GetLocation (yyVals[-1+yyTop]), "The `new()' constraint must be the last constraint specified");
 		}
 		
 		prev = yyVals[0+yyTop] as SpecialContraintExpr;
 		if (prev != null) {
 			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
 				Report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
 			} else {
 			 	prev = constraints [0] as SpecialContraintExpr;
 			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
 					Report.Error (451, GetLocation (yyVals[0+yyTop]), "The `new()' constraint cannot be used with the `struct' constraint");
 				}
 			}
 		}
 
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 670
 #line 4395 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast)
 			Report.Error (706, GetLocation (yyVals[0+yyTop]), "Invalid constraint type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 	  
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 671
 #line 4402 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 672
 #line 4407 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 673
 #line 4411 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 674
 #line 4418 "cs-parser.jay"
   {
 		yyVal = Variance.None;
 	  }
   break;
 case 675
 #line 4422 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (lexer.Location, "generic type variance");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 676
 #line 4432 "cs-parser.jay"
   {
 		yyVal = Variance.Covariant;
 	  }
   break;
 case 677
 #line 4436 "cs-parser.jay"
   {
 		yyVal = Variance.Contravariant;
 	  }
   break;
 case 678
 #line 4456 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 679
 #line 4461 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 680
 #line 4468 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 681
 #line 4473 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (lexer.Location);
 	  }
   break;
 case 682
 #line 4482 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		current_block.StartLocation = GetLocation (yyVals[0+yyTop]);
 	  }
   break;
 case 683
 #line 4487 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 688
 #line 4505 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 689
 #line 4509 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 691
 #line 4514 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 694
 #line 4533 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 695
 #line 4537 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 724
 #line 4578 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 725
 #line 4583 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 726
 #line 4588 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 727
 #line 4596 "cs-parser.jay"
   {
 		/* Uses lexer.Location because semicolon location is not kept in quick mode*/
 		yyVal = new EmptyStatement (lexer.Location);
 	  }
   break;
 case 728
 #line 4604 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
 
 		current_block.AddLabel (labeled);
 		current_block.AddStatement (labeled);
 	  }
   break;
 case 731
 #line 4617 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] is VarExpr)
 			yyVals[-1+yyTop] = new SimpleName ("var", ((VarExpr) yyVals[-1+yyTop]).Location);
 	  
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 732
 #line 4633 "cs-parser.jay"
   { 
 		/* Ok, the above "primary_expression" is there to get rid of*/
 		/* both reduce/reduce and shift/reduces in the grammar, it should*/
 		/* really just be "type_name".  If you use type_name, a reduce/reduce*/
 		/* creeps up.  If you use namespace_or_type_name (which is all we need*/
 		/* really) two shift/reduces appear.*/
 		/* */
 
 		/* So the super-trick is that primary_expression*/
 		/* can only be either a SimpleName or a MemberAccess. */
 		/* The MemberAccess case arises when you have a fully qualified type-name like 
 		/* Foo.Bar.Blah i;*/
 		/* SimpleName is when you have*/
 		/* Blah i;*/
 		
 		Expression expr = (Expression) yyVals[-1+yyTop];
 		if (yyVals[0+yyTop] == null) {
 			SimpleName sn = expr as SimpleName;
 			if (sn != null && sn.Name == "var")
 				yyVal = new VarExpr (sn.Location);
 			else
 				yyVal = yyVals[-1+yyTop];
 		} else if (expr is ATypeNameExpression) {
 			yyVal = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName (expr);
 			yyVal = null;
 		}
 	  }
   break;
 case 733
 #line 4663 "cs-parser.jay"
   {
 		ATypeNameExpression expr = yyVals[-1+yyTop] as ATypeNameExpression;
 
 		if (expr != null) {
 			yyVal = new ComposedCast (expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName ((Expression)yyVals[-1+yyTop]);
 			yyVal = expr;
 		}
 	  }
   break;
 case 734
 #line 4674 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] == null)
 			yyVal = yyVals[-1+yyTop];
 		else
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 735
 #line 4681 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 736
 #line 4685 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 737
 #line 4689 "cs-parser.jay"
   {
 		Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 739
 #line 4698 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 740
 #line 4706 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreatePointer (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 741
 #line 4713 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 742
 #line 4720 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 743
 #line 4726 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockConstantDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 744
 #line 4733 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 746
 #line 4743 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		/* TODO
 	  }
   break;
 case 747
 #line 4748 "cs-parser.jay"
   {
 	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
 			Report.Error (650, lexer.Location,
 				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 	  }
   break;
 case 752
 #line 4770 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, null);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 753
 #line 4779 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 754
 #line 4791 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 	  }
   break;
 case 755
 #line 4795 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 760
 #line 4812 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 762
 #line 4825 "cs-parser.jay"
   {
 		yyVal = new StackAlloc ((Expression) yyVals[-3+yyTop], (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 763
 #line 4830 "cs-parser.jay"
   {
 		Report.Error (1575, GetLocation (yyVals[-1+yyTop]), "A stackalloc expression requires [] after type");
 		yyVal = new StackAlloc ((Expression) yyVals[0+yyTop], null, GetLocation (yyVals[-1+yyTop]));		
 	  }
   break;
 case 764
 #line 4838 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 765
 #line 4842 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 766
 #line 4846 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 767
 #line 4847 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 768
 #line 4856 "cs-parser.jay"
   {
 		ExpressionStatement s = yyVals[0+yyTop] as ExpressionStatement;
 		if (s == null) {
 			Expression.Error_InvalidExpressionStatement (Report, GetLocation (yyVals[0+yyTop]));
 			s = EmptyExpressionStatement.Instance;
 		}
 
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 769
 #line 4869 "cs-parser.jay"
   {
 		Expression expr = (Expression) yyVals[0+yyTop];
 		ExpressionStatement s;
 
 	        s = new OptionalAssign (new SimpleName ("$retval", lexer.Location), expr, lexer.Location);
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 770
 #line 4877 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 773
 #line 4891 "cs-parser.jay"
   { 
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 		
 		yyVal = new If ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 774
 #line 4900 "cs-parser.jay"
   {
 		yyVal = new If ((BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		
 		if (yyVals[-2+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[-2+yyTop]));
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 775
 #line 4913 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 776
 #line 4917 "cs-parser.jay"
   {
 		yyVal = new Switch ((Expression) yyVals[-5+yyTop], (ExplicitBlock) current_block.Explicit, (List<SwitchSection>) yyVals[-1+yyTop], GetLocation (yyVals[-7+yyTop]));	
 		end_block (GetLocation (yyVals[0+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 777
 #line 4926 "cs-parser.jay"
   {
 		Report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 779
 #line 4935 "cs-parser.jay"
   {
 		var sections = new List<SwitchSection> (4);
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 780
 #line 4942 "cs-parser.jay"
   {
 		var sections = (List<SwitchSection>) yyVals[-1+yyTop];
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 781
 #line 4949 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 782
 #line 4957 "cs-parser.jay"
   {
 		current_block = current_block.CreateSwitchBlock (lexer.Location);
 	  }
   break;
 case 783
 #line 4961 "cs-parser.jay"
   {
 		yyVal = new SwitchSection ((List<SwitchLabel>) yyVals[-2+yyTop], current_block);
 	  }
   break;
 case 784
 #line 4968 "cs-parser.jay"
   {
 		var labels = new List<SwitchLabel> (4);
 
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 		yyVal = labels;
 	  }
   break;
 case 785
 #line 4975 "cs-parser.jay"
   {
 		var labels = (List<SwitchLabel>) (yyVals[-1+yyTop]);
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 
 		yyVal = labels;
 	  }
   break;
 case 786
 #line 4985 "cs-parser.jay"
   {
 	 	yyVal = new SwitchLabel ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	 	lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	 }
   break;
 case 787
 #line 4990 "cs-parser.jay"
   {
 		yyVal = new SwitchLabel (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 792
 #line 5004 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new While ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 793
 #line 5016 "cs-parser.jay"
   {
 		yyVal = new Do ((Statement) yyVals[-5+yyTop], (BooleanExpression) yyVals[-2+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 794
 #line 5024 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 		current_block.IsCompilerGenerated = true;
 	  }
   break;
 case 795
 #line 5029 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 796
 #line 5040 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		For f = new For ((Statement) yyVals[-6+yyTop], (BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, current_block.StartLocation, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		yyVal = end_block (GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 797
 #line 5052 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = end_block (current_block.StartLocation);
 	  }
   break;
 case 798
 #line 5059 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 800
 #line 5065 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 801
 #line 5072 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 803
 #line 5080 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 805
 #line 5085 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 809
 #line 5096 "cs-parser.jay"
   {
 	  	var sl = yyVals[-2+yyTop] as StatementList;
 	  	if (sl == null) {
 	  		sl = new StatementList ((Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop]);
 			lbag.AddStatement (sl, GetLocation (yyVals[-1+yyTop]));
 	  	} else {
 	  		sl.Add ((Statement) yyVals[0+yyTop]);
 	  		lbag.AppendTo (sl, GetLocation (yyVals[-1+yyTop]));
 	  	}
 	  		
 		yyVal = sl;
 	  }
   break;
 case 810
 #line 5112 "cs-parser.jay"
   {
 		Report.Error (230, GetLocation (yyVals[-5+yyTop]), "Type and identifier are both required in a foreach statement");
 		yyVal = null;
 	  }
   break;
 case 811
 #line 5117 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-5+yyTop]));
 		current_block.IsCompilerGenerated = true;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.ForeachVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		yyVal = li;
 	  }
   break;
 case 812
 #line 5127 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Foreach f = new Foreach ((Expression) yyVals[-6+yyTop], (LocalVariable) yyVals[-1+yyTop], (Expression) yyVals[-3+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-8+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 819
 #line 5150 "cs-parser.jay"
   {
 		yyVal = new Break (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 820
 #line 5158 "cs-parser.jay"
   {
 		yyVal = new Continue (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 821
 #line 5166 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new Goto (lt.Value, lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 822
 #line 5172 "cs-parser.jay"
   {
 		yyVal = new GotoCase ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 823
 #line 5177 "cs-parser.jay"
   {
 		yyVal = new GotoDefault (GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 824
 #line 5185 "cs-parser.jay"
   {
 		yyVal = new Return ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 825
 #line 5193 "cs-parser.jay"
   {
 		yyVal = new Throw ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 826
 #line 5201 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (yyVals[-1+yyTop] == null) {
 			Report.Error (1627, GetLocation (yyVals[0+yyTop]), "Expression expected after yield return");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new Yield ((Expression) yyVals[-1+yyTop], lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 827
 #line 5217 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new YieldBreak (lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 830
 #line 5239 "cs-parser.jay"
   {
 		yyVal = new TryCatch ((Block) yyVals[-1+yyTop], (List<Catch>) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]), false);
 	  }
   break;
 case 831
 #line 5243 "cs-parser.jay"
   {
 		yyVal = new TryFinally ((Statement) yyVals[-2+yyTop], (Block) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 832
 #line 5248 "cs-parser.jay"
   {
 		yyVal = new TryFinally (new TryCatch ((Block) yyVals[-3+yyTop], (List<Catch>) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]), true), (Block) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 833
 #line 5253 "cs-parser.jay"
   {
 		Report.Error (1524, GetLocation (yyVals[-2+yyTop]), "Expected catch or finally");
 		yyVal = null;
 	  }
   break;
 case 834
 #line 5261 "cs-parser.jay"
   {
 		var l = new List<Catch> (2);
 
 		l.Add ((Catch) yyVals[0+yyTop]);
 		yyVal = l;
 	  }
   break;
 case 835
 #line 5268 "cs-parser.jay"
   {
 		var l = (List<Catch>) yyVals[-1+yyTop];
 		
 		Catch c = (Catch) yyVals[0+yyTop];
 		if (l [0].IsGeneral) {
 			Report.Error (1017, c.loc, "Try statement already has an empty catch block");
 		} else {
 			if (c.IsGeneral)
 				l.Insert (0, c);
 			else
 				l.Add (c);
 		}
 		
 		yyVal = l;
 	  }
   break;
 case 838
 #line 5292 "cs-parser.jay"
   {
 		yyVal = new Catch ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 839
 #line 5296 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-3+yyTop]));
 		var c = new Catch (current_block, GetLocation (yyVals[-4+yyTop]));
 		c.TypeExpression = (FullNamedExpression) yyVals[-2+yyTop];
 
 		if (yyVals[-1+yyTop] != null) {
 			var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
 			current_block.AddLocalName (c.Variable);
 		}
 		
 		lbag.AddLocation (c, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 840
 #line 5311 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 841
 #line 5315 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_PARENS) {
 			Report.Error (1015, lexer.Location,
 				"A type that derives from `System.Exception', `object', or `string' expected");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 		
 		yyVal = new Catch (null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 842
 #line 5329 "cs-parser.jay"
   {
 		yyVal = new Checked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 843
 #line 5336 "cs-parser.jay"
   {
 		yyVal = new Unchecked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 844
 #line 5343 "cs-parser.jay"
   {
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 845
 #line 5346 "cs-parser.jay"
   {
 		yyVal = new Unsafe ((Block) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 846
 #line 5353 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new Lock ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 847
 #line 5364 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.FixedVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Fixed.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 848
 #line 5373 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 849
 #line 5378 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Fixed f = new Fixed ((Fixed.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 850
 #line 5390 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.UsingVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Using.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 851
 #line 5399 "cs-parser.jay"
   {
 		yyVal = current_variable;	  
 		current_variable = null;
 	  }
   break;
 case 852
 #line 5404 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Using.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (u);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 853
 #line 5413 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (u, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = u;
 	  }
   break;
 case 854
 #line 5425 "cs-parser.jay"
   {
 		Report.Error (210, lexer.Location, "You must provide an initializer in a fixed or using statement declaration");
 	  }
   break;
 case 855
 #line 5429 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		yyVal = current_variable;
 	  }
   break;
 case 856
 #line 5440 "cs-parser.jay"
   {
 		lexer.query_parsing = false;
 			
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 857
 #line 5452 "cs-parser.jay"
   {
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 858
 #line 5463 "cs-parser.jay"
   {
 	        lexer.query_parsing = false;
 		yyVal = yyVals[-1+yyTop];
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 859
 #line 5470 "cs-parser.jay"
   {
 	        yyVal = yyVals[-1+yyTop];
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 860
 #line 5479 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 861
 #line 5487 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 862
 #line 5502 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 863
 #line 5510 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 864
 #line 5525 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 865
 #line 5529 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 866
 #line 5540 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 867
 #line 5544 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop])) {
 			IdentifierType = (FullNamedExpression)yyVals[-4+yyTop]
 		};
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 868
 #line 5561 "cs-parser.jay"
   {
 	  	Linq.AQueryClause head = (Linq.AQueryClause)yyVals[-1+yyTop];
 		
 		if (yyVals[0+yyTop] != null)
 			head.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 				
 		if (yyVals[-2+yyTop] != null) {
 			Linq.AQueryClause clause = (Linq.AQueryClause)yyVals[-2+yyTop];
 			clause.Tail.Next = head;
 			head = clause;
 		}
 		
 		yyVal = head;
 	  }
   break;
 case 870
 #line 5577 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 871
 #line 5585 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 872
 #line 5589 "cs-parser.jay"
   {
 		yyVal = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 873
 #line 5596 "cs-parser.jay"
   {
 	  	if (linq_clause_blocks == null)
 	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
 	  }
   break;
 case 874
 #line 5604 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 875
 #line 5611 "cs-parser.jay"
   {
 		yyVal = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)yyVals[-3+yyTop], linq_clause_blocks.Pop (), (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 879
 #line 5627 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-1+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 885
 #line 5643 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 886
 #line 5647 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 	  	yyVal = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  	
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 887
 #line 5661 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 888
 #line 5665 "cs-parser.jay"
   {
 		yyVal = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 889
 #line 5675 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 890
 #line 5683 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 891
 #line 5691 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 892
 #line 5699 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];	
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-11+yyTop]));
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 			
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location);
 
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-11+yyTop]));	
 		}
 
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);
 	  }
   break;
 case 893
 #line 5735 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 894
 #line 5743 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 895
 #line 5751 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 896
 #line 5759 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;		
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 		
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location); /* TODO
 			
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};			
 		}
 		
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
 	  }
   break;
 case 898
 #line 5803 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 899
 #line 5810 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 900
 #line 5814 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 902
 #line 5825 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 903
 #line 5832 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	  }
   break;
 case 905
 #line 5841 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, (Linq.QueryBlock) current_block, lexer.Location);	 
 	 }
   break;
 case 906
 #line 5848 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	 }
   break;
 case 907
 #line 5856 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 908
 #line 5860 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 909
 #line 5864 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 910
 #line 5871 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 911
 #line 5875 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 912
 #line 5879 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 914
 #line 5888 "cs-parser.jay"
   {
 		/* query continuation block is not linked with query block but with block*/
 		/* before. This means each query can use same range variable names for*/
 		/* different identifiers.*/
 
 		current_block.SetEndLocation (GetLocation (yyVals[-1+yyTop]));
 		current_block = current_block.Parent;
 	
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
 	  }
   break;
 case 915
 #line 5904 "cs-parser.jay"
   {
 		var current_block = linq_clause_blocks.Pop ();	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
   		yyVal = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation (yyVals[-3+yyTop])) {
   			next = (Linq.AQueryClause)yyVals[0+yyTop]
   		};
 	  }
   break;
 case 918
 #line 5930 "cs-parser.jay"
   { 
 	        Evaluator.LoadAliases (current_namespace);
 
 		push_current_class (new Class (current_namespace, current_class, new MemberName ("Class" + class_count++),
 			Modifiers.PUBLIC, null), null);
 
 		var baseclass_list = new List<FullNamedExpression> ();
 		baseclass_list.Add (new TypeExpression (Evaluator.InteractiveBaseClass, lexer.Location));
 		current_container.AddBasesForPart (current_class, baseclass_list);
 
 		/* (ref object retval)*/
 		Parameter [] mpar = new Parameter [1];
 		mpar [0] = new Parameter (new TypeExpression (TypeManager.object_type, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);
 
 		ParametersCompiled pars = new ParametersCompiled (mpar);
 		current_local_parameters = pars;
 		Method method = new Method (
 			current_class,
 			null, /* generic*/
 			new TypeExpression (TypeManager.void_type, Location.Null),
 			Modifiers.PUBLIC | Modifiers.STATIC,
 			new MemberName ("Host"),
 			pars,
 			null /* attributes */);
 
 		oob_stack.Push (method);
 	        ++lexer.parsing_block;
 		start_block (lexer.Location);
 	  }
   break;
 case 919
 #line 5960 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		Method method = (Method) oob_stack.Pop ();
 
 		method.Block = (ToplevelBlock) end_block(lexer.Location);
 		current_container.AddMethod (method);
 
 		--lexer.parsing_declaration;
 		InteractiveResult = pop_current_class ();
 		current_local_parameters = null;
 	  }
   break;
 case 920
 #line 5971 "cs-parser.jay"
   {
 	        Evaluator.LoadAliases (current_namespace);
 	  }
   break;
 #line default
         }
         yyTop -= yyLen[yyN];
         yyState = yyStates[yyTop];
         int yyM = yyLhs[yyN];
         if (yyState == 0 && yyM == 0) {
           if (debug != null) debug.shift(0, yyFinal);
           yyState = yyFinal;
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
                debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
           }
           if (yyToken == 0) {
             if (debug != null) debug.accept(yyVal);
             return yyVal;
           }
           goto continue_yyLoop;
         }
         if (((yyN = yyGindex[yyM]) != 0) && ((yyN += yyState) >= 0)
             && (yyN < yyTable.Length) && (yyCheck[yyN] == yyState))
           yyState = yyTable[yyN];
         else
           yyState = yyDgoto[yyM];
         if (debug != null) debug.shift(yyStates[yyTop], yyState);
 	 goto continue_yyLoop;
       continue_yyDiscarded
       }
     continue_yyLoop
     }
   }
]]></clone_fragment>
<clone_fragment endline="6154" file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" hamdist="12" pcid="2869" startline="45"><![CDATA[
 		static readonly object ModifierNone = 0;
 	
 		NamespaceEntry  current_namespace;
 		TypeContainer   current_container;
 		DeclSpace	current_class;
 		PropertyBase current_property;
 		EventProperty current_event;
 		EventField current_event_field;
 		FieldBase current_field;
 	
 		/// <summary>
 		///   Current block is used to add statements as we find
 		///   them.  
 		/// </summary>
 		Block      current_block;
 		
 		BlockVariableDeclaration current_variable;
 
 		Delegate   current_delegate;
 		
 		AnonymousMethodExpression current_anonymous_method;
 
 		/// <summary>
 		///   This is used by the unary_expression code to resolve
 		///   a name against a parameter.  
 		/// </summary>
 		
 		// FIXME
 		// on all places, especially when some parameters are autogenerated.
 		ParametersCompiled current_local_parameters;
 
 		bool parsing_anonymous_method;
 
 		///
 		/// An out-of-band stack.
 		///
 		static Stack<object> oob_stack;
 
 		///
 		/// Controls the verbosity of the errors produced by the parser
 		///
 		static public int yacc_verbose_flag;
 
 		/// 
 		/// Used by the interactive shell, flags whether EOF was reached
 		/// and an error was produced
 		///
 		public bool UnexpectedEOF;
 
 		///
 		/// The current file.
 		///
 		CompilationUnit file;
 
 		///
 		/// Temporary Xml documentation cache.
 		/// For enum types, we need one more temporary store.
 		///
 		string tmpComment;
 		string enumTypeComment;
 	       		
 		/// Current attribute target
 		string current_attr_target;
 		
 		/// assembly and module attribute definitions are enabled
 		bool global_attrs_enabled = true;
 		
 		ParameterModifierType valid_param_mod;
 		
 		bool default_parameter_used;
 
 		/// When using the interactive parser, this holds the
 		/// resulting expression
 		public object InteractiveResult;
 
 		//
 		// Keeps track of global data changes to undo on parser error
 		//
 		public Undo undo;
 		
 		Stack<Linq.QueryBlock> linq_clause_blocks;
 
 		// A counter to create new class names in interactive mode
 		static int class_count;
 		
 		ModuleContainer module;
 		
 		CompilerContext compiler;
 		
 		//
 		// Instead of allocating carrier array everytime we
 		// share the bucket for very common constructs which can never
 		// be recursive
 		//
 		static List<Parameter> parameters_bucket = new List<Parameter> (6);
   protected static  int yyFinal = 9;
  // Put this array into a separate class so it is only initialized if debugging is actually used
  // Use MarshalByRefObject to disable inlining
  class YYRules 
   public static  string [] yyRule = {
     "$accept 
     "compilation_unit 
     "compilation_unit 
     "compilation_unit 
     "compilation_unit 
     "$$1 
     "compilation_unit 
     "opt_EOF 
     "opt_EOF 
     "outer_declarations 
     "outer_declarations 
     "outer_declaration 
     "outer_declaration 
     "outer_declaration 
     "extern_alias_directives 
     "extern_alias_directives 
     "extern_alias_directive 
     "extern_alias_directive 
     "using_directives 
     "using_directives 
     "using_directive 
     "using_directive 
     "using_alias_directive 
     "using_alias_directive 
     "using_namespace_directive 
     "$$2 
     "namespace_declaration 
     "qualified_identifier 
     "qualified_identifier 
     "qualified_identifier 
     "opt_semicolon 
     "opt_semicolon 
     "opt_comma 
     "opt_comma 
     "namespace_name 
     "$$3 
     "namespace_body 
     "opt_using_directives 
     "opt_using_directives 
     "opt_extern_alias_directives 
     "opt_extern_alias_directives 
     "opt_namespace_member_declarations 
     "opt_namespace_member_declarations 
     "namespace_member_declarations 
     "namespace_member_declarations 
     "namespace_member_declaration 
     "namespace_member_declaration 
     "namespace_member_declaration 
     "type_declaration 
     "type_declaration 
     "type_declaration 
     "type_declaration 
     "type_declaration 
     "global_attributes 
     "opt_attributes 
     "opt_attributes 
     "attribute_sections 
     "attribute_sections 
     "attribute_section 
     "attribute_section 
     "attribute_target_specifier 
     "attribute_target 
     "attribute_target 
     "attribute_target 
     "attribute_target 
     "attribute_list 
     "attribute_list 
     "$$4 
     "attribute 
     "attribute_name 
     "opt_attribute_arguments 
     "opt_attribute_arguments 
     "attribute_arguments 
     "attribute_arguments 
     "attribute_arguments 
     "attribute_arguments 
     "attribute_arguments 
     "positional_or_named_argument 
     "positional_or_named_argument 
     "$$5 
     "named_attribute_argument 
     "named_argument 
     "opt_named_modifier 
     "opt_named_modifier 
     "opt_named_modifier 
     "opt_class_member_declarations 
     "opt_class_member_declarations 
     "class_member_declarations 
     "class_member_declarations 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "$$6 
     "$$7 
     "$$8 
     "$$9 
     "struct_declaration 
     "struct_declaration 
     "$$10 
     "struct_body 
     "opt_struct_member_declarations 
     "opt_struct_member_declarations 
     "struct_member_declarations 
     "struct_member_declarations 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "$$11 
     "constant_declaration 
     "opt_constant_declarators 
     "opt_constant_declarators 
     "constant_declarators 
     "constant_declarators 
     "constant_declarator 
     "$$12 
     "constant_initializer 
     "constant_initializer 
     "constant_initializer_expr 
     "constant_initializer_expr 
     "$$13 
     "field_declaration 
     "$$14 
     "field_declaration 
     "field_declaration 
     "opt_field_initializer 
     "$$15 
     "opt_field_initializer 
     "opt_field_declarators 
     "opt_field_declarators 
     "field_declarators 
     "field_declarators 
     "field_declarator 
     "$$16 
     "field_declarator 
     "opt_fixed_field_declarators 
     "opt_fixed_field_declarators 
     "fixed_field_declarators 
     "fixed_field_declarators 
     "fixed_field_declarator 
     "$$17 
     "fixed_field_size 
     "fixed_field_size 
     "variable_initializer 
     "variable_initializer 
     "variable_initializer 
     "$$18 
     "method_declaration 
     "$$19 
     "$$20 
     "method_header 
     "$$21 
     "$$22 
     "method_header 
     "method_header 
     "method_body 
     "method_body 
     "opt_formal_parameter_list 
     "opt_formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "fixed_parameters 
     "fixed_parameters 
     "fixed_parameter 
     "fixed_parameter 
     "fixed_parameter 
     "$$23 
     "fixed_parameter 
     "opt_parameter_modifier 
     "opt_parameter_modifier 
     "parameter_modifiers 
     "parameter_modifiers 
     "parameter_modifier 
     "parameter_modifier 
     "parameter_modifier 
     "parameter_array 
     "parameter_array 
     "parameter_array 
     "params_modifier 
     "params_modifier 
     "params_modifier 
     "arglist_modifier 
     "$$24 
     "$$25 
     "$$26 
     "property_declaration 
     "$$27 
     "$$28 
     "$$29 
     "indexer_declaration 
     "accessor_declarations 
     "accessor_declarations 
     "accessor_declarations 
     "accessor_declarations 
     "accessor_declarations 
     "$$30 
     "get_accessor_declaration 
     "$$31 
     "set_accessor_declaration 
     "accessor_body 
     "accessor_body 
     "accessor_body 
     "$$32 
     "$$33 
     "$$34 
     "$$35 
     "interface_declaration 
     "interface_declaration 
     "opt_interface_member_declarations 
     "opt_interface_member_declarations 
     "interface_member_declarations 
     "interface_member_declarations 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "$$36 
     "operator_declaration 
     "operator_body 
     "operator_body 
     "operator_type 
     "operator_type 
     "$$37 
     "operator_declarator 
     "operator_declarator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "$$38 
     "conversion_operator_declarator 
     "$$39 
     "conversion_operator_declarator 
     "conversion_operator_declarator 
     "conversion_operator_declarator 
     "constructor_declaration 
     "$$40 
     "$$41 
     "constructor_declarator 
     "constructor_body 
     "constructor_body 
     "opt_constructor_initializer 
     "opt_constructor_initializer 
     "$$42 
     "constructor_initializer 
     "$$43 
     "constructor_initializer 
     "constructor_initializer 
     "$$44 
     "destructor_declaration 
     "$$45 
     "event_declaration 
     "$$46 
     "$$47 
     "event_declaration 
     "opt_event_initializer 
     "$$48 
     "opt_event_initializer 
     "opt_event_declarators 
     "opt_event_declarators 
     "event_declarators 
     "event_declarators 
     "event_declarator 
     "$$49 
     "event_declarator 
     "$$50 
     "event_variable_initializer 
     "event_accessor_declarations 
     "event_accessor_declarations 
     "event_accessor_declarations 
     "event_accessor_declarations 
     "event_accessor_declarations 
     "$$51 
     "add_accessor_declaration 
     "$$52 
     "remove_accessor_declaration 
     "event_accessor_block 
     "event_accessor_block 
     "$$53 
     "$$54 
     "$$55 
     "enum_declaration 
     "opt_enum_base 
     "opt_enum_base 
     "opt_enum_base 
     "opt_enum_member_declarations 
     "opt_enum_member_declarations 
     "opt_enum_member_declarations 
     "enum_member_declarations 
     "enum_member_declarations 
     "enum_member_declaration 
     "$$56 
     "enum_member_declaration 
     "$$57 
     "$$58 
     "$$59 
     "delegate_declaration 
     "opt_nullable 
     "opt_nullable 
     "namespace_or_type_name 
     "namespace_or_type_name 
     "member_name 
     "member_name 
     "type_name 
     "opt_type_argument_list 
     "opt_type_argument_list 
     "opt_type_argument_list 
     "type_arguments 
     "type_arguments 
     "$$60 
     "type_declaration_name 
     "member_declaration_name 
     "method_declaration_name 
     "method_declaration_name 
     "indexer_declaration_name 
     "indexer_declaration_name 
     "explicit_interface 
     "explicit_interface 
     "explicit_interface 
     "opt_type_parameter_list 
     "opt_type_parameter_list 
     "type_parameters 
     "type_parameters 
     "type_parameter 
     "type_parameter 
     "type_and_void 
     "type_and_void 
     "member_type 
     "type 
     "type 
     "simple_type 
     "simple_type 
     "parameter_type 
     "parameter_type 
     "type_expression_or_array 
     "type_expression_or_array 
     "type_expression 
     "type_expression 
     "type_expression 
     "type_expression 
     "type_expression 
     "type_list 
     "type_list 
     "base_type_name 
     "base_type_name 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression_or_type 
     "primary_expression_or_type 
     "primary_expression_or_type 
     "literal 
     "literal 
     "literal 
     "boolean_literal 
     "boolean_literal 
     "open_parens_any 
     "open_parens_any 
     "close_parens 
     "close_parens 
     "parenthesized_expression 
     "parenthesized_expression 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "invocation_expression 
     "opt_object_or_collection_initializer 
     "opt_object_or_collection_initializer 
     "object_or_collection_initializer 
     "object_or_collection_initializer 
     "opt_member_initializer_list 
     "opt_member_initializer_list 
     "member_initializer_list 
     "member_initializer_list 
     "member_initializer_list 
     "member_initializer 
     "member_initializer 
     "member_initializer 
     "member_initializer 
     "member_initializer 
     "initializer_value 
     "initializer_value 
     "opt_argument_list 
     "opt_argument_list 
     "argument_list 
     "argument_list 
     "argument_list 
     "argument_list 
     "argument_list 
     "argument 
     "argument 
     "argument_or_named_argument 
     "argument_or_named_argument 
     "non_simple_argument 
     "non_simple_argument 
     "non_simple_argument 
     "non_simple_argument 
     "variable_reference 
     "element_access 
     "expression_list 
     "expression_list 
     "expression_list 
     "expression_list_arguments 
     "expression_list_arguments 
     "expression_list_argument 
     "expression_list_argument 
     "this_access 
     "base_access 
     "base_access 
     "post_increment_expression 
     "post_decrement_expression 
     "object_or_delegate_creation_expression 
     "object_or_delegate_creation_expression 
     "array_creation_expression 
     "array_creation_expression 
     "array_creation_expression 
     "array_creation_expression 
     "array_creation_expression 
     "$$61 
     "new_expr_type 
     "anonymous_type_expression 
     "anonymous_type_parameters_opt_comma 
     "anonymous_type_parameters_opt_comma 
     "anonymous_type_parameters_opt 
     "anonymous_type_parameters_opt 
     "anonymous_type_parameters 
     "anonymous_type_parameters 
     "anonymous_type_parameter 
     "anonymous_type_parameter 
     "anonymous_type_parameter 
     "anonymous_type_parameter 
     "opt_rank_specifier 
     "opt_rank_specifier 
     "rank_specifiers 
     "rank_specifiers 
     "rank_specifier 
     "rank_specifier 
     "dim_separators 
     "dim_separators 
     "opt_array_initializer 
     "opt_array_initializer 
     "array_initializer 
     "array_initializer 
     "variable_initializer_list 
     "variable_initializer_list 
     "$$62 
     "typeof_expression 
     "typeof_type_expression 
     "typeof_type_expression 
     "typeof_type_expression 
     "unbound_type_name 
     "unbound_type_name 
     "unbound_type_name 
     "unbound_type_name 
     "unbound_type_name 
     "generic_dimension 
     "qualified_alias_member 
     "sizeof_expression 
     "checked_expression 
     "unchecked_expression 
     "pointer_member_access 
     "$$63 
     "anonymous_method_expression 
     "opt_anonymous_method_signature 
     "opt_anonymous_method_signature 
     "$$64 
     "anonymous_method_signature 
     "default_value_expression 
     "unary_expression 
     "unary_expression 
     "unary_expression 
     "unary_expression 
     "cast_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "multiplicative_expression 
     "multiplicative_expression 
     "multiplicative_expression 
     "multiplicative_expression 
     "additive_expression 
     "additive_expression 
     "additive_expression 
     "additive_expression 
     "additive_expression 
     "additive_expression 
     "shift_expression 
     "shift_expression 
     "shift_expression 
     "relational_expression 
     "relational_expression 
     "relational_expression 
     "relational_expression 
     "relational_expression 
     "equality_expression 
     "equality_expression 
     "equality_expression 
     "and_expression 
     "and_expression 
     "exclusive_or_expression 
     "exclusive_or_expression 
     "inclusive_or_expression 
     "inclusive_or_expression 
     "conditional_and_expression 
     "conditional_and_expression 
     "conditional_or_expression 
     "conditional_or_expression 
     "null_coalescing_expression 
     "null_coalescing_expression 
     "conditional_expression 
     "conditional_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "lambda_parameter_list 
     "lambda_parameter_list 
     "lambda_parameter 
     "lambda_parameter 
     "lambda_parameter 
     "opt_lambda_parameter_list 
     "opt_lambda_parameter_list 
     "lambda_expression_body 
     "lambda_expression_body 
     "$$65 
     "lambda_expression_body_simple 
     "expression_or_error 
     "expression_or_error 
     "$$66 
     "lambda_expression 
     "$$67 
     "$$68 
     "lambda_expression 
     "expression 
     "expression 
     "non_assignment_expression 
     "non_assignment_expression 
     "non_assignment_expression 
     "non_assignment_expression 
     "constant_expression 
     "boolean_expression 
     "$$69 
     "$$70 
     "$$71 
     "$$72 
     "class_declaration 
     "opt_partial 
     "opt_partial 
     "opt_modifiers 
     "opt_modifiers 
     "modifiers 
     "modifiers 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "opt_class_base 
     "opt_class_base 
     "opt_type_parameter_constraints_clauses 
     "opt_type_parameter_constraints_clauses 
     "opt_type_parameter_constraints_clauses 
     "type_parameter_constraints_clauses 
     "type_parameter_constraints_clauses 
     "type_parameter_constraints_clause 
     "type_parameter_constraints 
     "type_parameter_constraints 
     "type_parameter_constraint 
     "type_parameter_constraint 
     "type_parameter_constraint 
     "type_parameter_constraint 
     "opt_type_parameter_variance 
     "opt_type_parameter_variance 
     "type_parameter_variance 
     "type_parameter_variance 
     "$$73 
     "block 
     "block_end 
     "block_end 
     "$$74 
     "block_prepared 
     "opt_statement_list 
     "opt_statement_list 
     "statement_list 
     "statement_list 
     "statement 
     "statement 
     "statement 
     "statement 
     "interactive_statement_list 
     "interactive_statement_list 
     "interactive_statement 
     "interactive_statement 
     "interactive_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "embedded_statement 
     "embedded_statement 
     "embedded_statement 
     "embedded_statement 
     "empty_statement 
     "$$75 
     "labeled_statement 
     "variable_type 
     "variable_type 
     "variable_type_simple 
     "variable_type_simple 
     "variable_type_simple 
     "variable_type_simple 
     "variable_type_simple 
     "variable_type_simple 
     "pointer_stars 
     "pointer_stars 
     "pointer_star 
     "$$76 
     "block_variable_declaration 
     "$$77 
     "block_variable_declaration 
     "opt_local_variable_initializer 
     "opt_local_variable_initializer 
     "opt_local_variable_initializer 
     "opt_variable_declarators 
     "opt_variable_declarators 
     "variable_declarators 
     "variable_declarators 
     "variable_declarator 
     "variable_declarator 
     "const_variable_initializer 
     "const_variable_initializer 
     "opt_const_declarators 
     "opt_const_declarators 
     "const_declarators 
     "const_declarators 
     "const_declarator 
     "block_variable_initializer 
     "block_variable_initializer 
     "block_variable_initializer 
     "expression_statement 
     "expression_statement 
     "interactive_expression_statement 
     "interactive_expression_statement 
     "statement_expression 
     "interactive_statement_expression 
     "interactive_statement_expression 
     "selection_statement 
     "selection_statement 
     "if_statement 
     "if_statement 
     "$$78 
     "switch_statement 
     "opt_switch_sections 
     "opt_switch_sections 
     "switch_sections 
     "switch_sections 
     "switch_sections 
     "$$79 
     "switch_section 
     "switch_labels 
     "switch_labels 
     "switch_label 
     "switch_label 
     "iteration_statement 
     "iteration_statement 
     "iteration_statement 
     "iteration_statement 
     "while_statement 
     "do_statement 
     "$$80 
     "for_statement 
     "for_statement_cont 
     "for_statement_cont 
     "opt_for_initializer 
     "opt_for_initializer 
     "$$81 
     "for_initializer 
     "for_initializer 
     "opt_for_condition 
     "opt_for_condition 
     "opt_for_iterator 
     "opt_for_iterator 
     "for_iterator 
     "statement_expression_list 
     "statement_expression_list 
     "foreach_statement 
     "$$82 
     "foreach_statement 
     "jump_statement 
     "jump_statement 
     "jump_statement 
     "jump_statement 
     "jump_statement 
     "jump_statement 
     "break_statement 
     "continue_statement 
     "goto_statement 
     "goto_statement 
     "goto_statement 
     "return_statement 
     "throw_statement 
     "yield_statement 
     "yield_statement 
     "opt_expression 
     "opt_expression 
     "try_statement 
     "try_statement 
     "try_statement 
     "try_statement 
     "catch_clauses 
     "catch_clauses 
     "opt_identifier 
     "opt_identifier 
     "catch_clause 
     "$$83 
     "catch_clause 
     "catch_clause 
     "checked_statement 
     "unchecked_statement 
     "$$84 
     "unsafe_statement 
     "lock_statement 
     "$$85 
     "$$86 
     "fixed_statement 
     "$$87 
     "$$88 
     "using_statement 
     "using_statement 
     "using_or_fixed_variable_initializer 
     "using_or_fixed_variable_initializer 
     "query_expression 
     "query_expression 
     "query_expression 
     "query_expression 
     "first_from_clause 
     "first_from_clause 
     "nested_from_clause 
     "nested_from_clause 
     "$$89 
     "from_clause 
     "$$90 
     "from_clause 
     "query_body 
     "query_body 
     "query_body 
     "$$91 
     "select_or_group_clause 
     "$$92 
     "$$93 
     "select_or_group_clause 
     "opt_query_body_clauses 
     "opt_query_body_clauses 
     "query_body_clauses 
     "query_body_clauses 
     "query_body_clause 
     "query_body_clause 
     "query_body_clause 
     "query_body_clause 
     "query_body_clause 
     "$$94 
     "let_clause 
     "$$95 
     "where_clause 
     "$$96 
     "$$97 
     "$$98 
     "join_clause 
     "$$99 
     "$$100 
     "$$101 
     "join_clause 
     "opt_join_into 
     "opt_join_into 
     "$$102 
     "orderby_clause 
     "orderings 
     "$$103 
     "orderings 
     "orderings_then_by 
     "$$104 
     "orderings_then_by 
     "order_by 
     "order_by 
     "order_by 
     "then_by 
     "then_by 
     "then_by 
     "opt_query_continuation 
     "$$105 
     "opt_query_continuation 
     "interactive_parsing 
     "interactive_parsing 
     "$$106 
     "interactive_parsing 
     "$$107 
     "interactive_parsing 
     "interactive_compilation_unit 
     "interactive_compilation_unit 
     "interactive_compilation_unit 
     "interactive_compilation_unit 
     "opt_COMPLETE_COMPLETION 
     "opt_COMPLETE_COMPLETION 
     "close_brace_or_complete_completion 
     "close_brace_or_complete_completion 
   };
  public static string getRule (int index) {
     return yyRule [index];
  }
 }
   protected static  string [] yyNames = {    
     "end-of-file",null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,"EOF","NONE","ERROR",
     "FIRST_KEYWORD","ABSTRACT","AS","ADD","BASE","BOOL","BREAK","BYTE",
     "CASE","CATCH","CHAR","CHECKED","CLASS","CONST","CONTINUE","DECIMAL",
     "DEFAULT","DELEGATE","DO","DOUBLE","ELSE","ENUM","EVENT","EXPLICIT",
     "EXTERN","FALSE","FINALLY","FIXED","FLOAT","FOR","FOREACH","GOTO",
     "IF","IMPLICIT","IN","INT","INTERFACE","INTERNAL","IS","LOCK","LONG",
     "NAMESPACE","NEW","NULL","OBJECT","OPERATOR","OUT","OVERRIDE",
     "PARAMS","PRIVATE","PROTECTED","PUBLIC","READONLY","REF","RETURN",
     "REMOVE","SBYTE","SEALED","SHORT","SIZEOF","STACKALLOC","STATIC",
     "STRING","STRUCT","SWITCH","THIS","THROW","TRUE","TRY","TYPEOF",
     "UINT","ULONG","UNCHECKED","UNSAFE","USHORT","USING","VIRTUAL","VOID",
     "VOLATILE","WHERE","WHILE","ARGLIST","PARTIAL","ARROW","FROM",
     "FROM_FIRST","JOIN","ON","EQUALS","SELECT","GROUP","BY","LET",
     "ORDERBY","ASCENDING","DESCENDING","INTO","INTERR_NULLABLE",
     "EXTERN_ALIAS","ASYNC","GET","SET","LAST_KEYWORD","OPEN_BRACE",
     "CLOSE_BRACE","OPEN_BRACKET","CLOSE_BRACKET","OPEN_PARENS",
     "CLOSE_PARENS","DOT","COMMA","COLON","SEMICOLON","TILDE","PLUS",
     "MINUS","BANG","ASSIGN","OP_LT","OP_GT","BITWISE_AND","BITWISE_OR",
     "STAR","PERCENT","DIV","CARRET","INTERR","DOUBLE_COLON","OP_INC",
     "OP_DEC","OP_SHIFT_LEFT","OP_SHIFT_RIGHT","OP_LE","OP_GE","OP_EQ",
     "OP_NE","OP_AND","OP_OR","OP_MULT_ASSIGN","OP_DIV_ASSIGN",
     "OP_MOD_ASSIGN","OP_ADD_ASSIGN","OP_SUB_ASSIGN",
     "OP_SHIFT_LEFT_ASSIGN","OP_SHIFT_RIGHT_ASSIGN","OP_AND_ASSIGN",
     "OP_XOR_ASSIGN","OP_OR_ASSIGN","OP_PTR","OP_COALESCING",
     "OP_GENERICS_LT","OP_GENERICS_LT_DECL","OP_GENERICS_GT","LITERAL",
     "IDENTIFIER","OPEN_PARENS_LAMBDA","OPEN_PARENS_CAST",
     "GENERIC_DIMENSION","DEFAULT_COLON","OPEN_BRACKET_EXPR",
     "EVAL_STATEMENT_PARSER","EVAL_COMPILATION_UNIT_PARSER",
     "EVAL_USING_DECLARATIONS_UNIT_PARSER","GENERATE_COMPLETION",
     "COMPLETE_COMPLETION","UMINUS",
   };
 
   /** index-checked interface to yyNames[].
       @param token single character or %token value.
       @return token name or [illegal] or [unknown].
     */
   public static string yyname (int token) {
     if ((token < 0) || (token > yyNames.Length)) return "[illegal]";
     string name;
     if ((name = yyNames[token]) != null) return name;
     return "[unknown]";
   }
 
   int yyExpectingState;
   /** computes list of expected tokens on error by tracing the tables.
       @param state for which to compute the list.
       @return list of token names.
     */
   protected int [] yyExpectingTokens (int state){
     int token, n, len = 0;
     bool[] ok = new bool[yyNames.Length];
     if ((n = yySindex[state]) != 0)
       for (token = n < 0 ? -n 
            (token < yyNames.Length) && (n+token < yyTable.Length); ++ token)
         if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
           ++ len;
           ok[token] = true;
         }
     if ((n = yyRindex[state]) != 0)
       for (token = n < 0 ? -n 
            (token < yyNames.Length) && (n+token < yyTable.Length); ++ token)
         if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
           ++ len;
           ok[token] = true;
         }
     int [] result = new int [len];
     for (n = token = 0; n < len;  ++ token)
       if (ok[token]) result[n++] = token;
     return result;
   }
   protected string[] yyExpecting (int state) {
     int [] tokens = yyExpectingTokens (state);
     string [] result = new string[tokens.Length];
     for (int n = 0; n < tokens.Length;  n++)
       result[n++] = yyNames[tokens [n]];
     return result;
   }
 
   /** the generated parser, with debugging messages.
       Maintains a state and a value stack, currently with fixed maximum size.
       @param yyLex scanner.
       @param yydebug debug message writer implementing yyDebug, or null.
       @return result of the last reduction, if any.
       @throws yyException on irrecoverable parse error.
     */
   internal Object yyparse (yyParser.yyInput yyLex, Object yyd)
 				 {
     this.debug = (yydebug.yyDebug)yyd;
     return yyparse(yyLex);
   }
 
   /** initial size and increment of the state/value stack [default 256].
       This is not final so that it can be overwritten outside of invocations
       of yyparse().
     */
   protected int yyMax;
 
   /** executed at the beginning of a reduce action.
       Used as $$ = yyDefault($1), prior to the user-specified action, if any.
       Can be overwritten to provide deep copy, etc.
       @param first value for $1, or null.
       @return first.
     */
   protected Object yyDefault (Object first) {
     return first;
   }
 
 	static int[] global_yyStates;
 	static object[] global_yyVals;
 	protected bool use_global_stacks;
 	object[] yyVals;					// value stack
 	object yyVal;						// value stack ptr
 	int yyToken;						// current input
 	int yyTop;
 
   /** the generated parser.
       Maintains a state and a value stack, currently with fixed maximum size.
       @param yyLex scanner.
       @return result of the last reduction, if any.
       @throws yyException on irrecoverable parse error.
     */
   internal Object yyparse (yyParser.yyInput yyLex)
   {
     if (yyMax <= 0) yyMax = 256;		// initial size
     int yyState = 0;                   // state stack ptr
     int [] yyStates;               	// state stack 
     yyVal = null;
     yyToken = -1;
     int yyErrorFlag = 0;				// #tks to shift
 	if (use_global_stacks && global_yyStates != null) {
 		yyVals = global_yyVals;
 		yyStates = global_yyStates;
    } else {
 		yyVals = new object [yyMax];
 		yyStates = new int [yyMax];
 		if (use_global_stacks) {
 			global_yyVals = yyVals;
 			global_yyStates = yyStates;
 		}
 	}
 
     /*yyLoop
       if (yyTop >= yyStates.Length) {			// dynamically increase
         global
         global
       }
       yyStates[yyTop] = yyState;
       yyVals[yyTop] = yyVal;
       if (debug != null) debug.push(yyState, yyVal);
 
       /*yyDiscarded
         int yyN;
         if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
               debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
           }
           if ((yyN = yySindex[yyState]) != 0 && ((yyN += yyToken) >= 0)
               && (yyN < yyTable.Length) && (yyCheck[yyN] == yyToken)) {
             if (debug != null)
               debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
             yyState = yyTable[yyN];		// shift to yyN
             yyVal = yyLex.value();
             yyToken = -1;
             if (yyErrorFlag > 0) -- yyErrorFlag;
             goto continue_yyLoop;
           }
           if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
               && yyN < yyTable.Length && yyCheck[yyN] == yyToken)
             yyN = yyTable[yyN];			// reduce (yyN)
           else
             switch (yyErrorFlag) {
   
             case 0
               yyExpectingState = yyState;
               // yyerror(String.Format ("syntax error, got token `{0}'", yyname (yyToken)), yyExpecting(yyState));
               if (debug != null) debug.error("syntax error");
               if (yyToken == 0 /*eof*/ || yyToken == eof_token) throw new yyParser.yyUnexpectedEof ();
               goto case 1;
             case 1
               yyErrorFlag = 3;
               do {
                 if ((yyN = yySindex[yyStates[yyTop]]) != 0
                     && (yyN += Token.yyErrorCode) >= 0 && yyN < yyTable.Length
                     && yyCheck[yyN] == Token.yyErrorCode) {
                   if (debug != null)
                     debug.shift(yyStates[yyTop], yyTable[yyN], 3);
                   yyState = yyTable[yyN];
                   yyVal = yyLex.value();
                   goto continue_yyLoop;
                 }
                 if (debug != null) debug.pop(yyStates[yyTop]);
               } while (-- yyTop >= 0);
               if (debug != null) debug.reject();
               throw new yyParser.yyException("irrecoverable syntax error");
   
             case 3
               if (yyToken == 0) {
                 if (debug != null) debug.reject();
                 throw new yyParser.yyException("irrecoverable syntax error at end-of-file");
               }
               if (debug != null)
                 debug.discard(yyState, yyToken, yyname(yyToken),
   							yyLex.value());
               yyToken = -1;
               goto continue_yyDiscarded;		// leave stack alone
             }
         }
         int yyV = yyTop + 1-yyLen[yyN];
         if (debug != null)
           debug.reduce(yyState, yyStates[yyV-1], yyN, YYRules.getRule (yyN), yyLen[yyN]);
         yyVal = yyV > yyTop ? null 
         switch (yyN) {
 case 5
 #line 375 "cs-parser.jay"
   { Lexer.CompleteOnEOF = false; }
   break;
 case 7
 #line 380 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 8
 #line 384 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 16
 #line 407 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "alias"){
 			syntax_error (lt.Location, "`alias' expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (lt.Location, "external alias");
 		} else {
 			lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop]; 
 			current_namespace.AddUsingExternalAlias (lt.Value, lt.Location, Report);
 		}
 	  }
   break;
 case 17
 #line 420 "cs-parser.jay"
   {
 	  	syntax_error (GetLocation (yyVals[-1+yyTop]), "`alias' expected");   /* TODO
 	  }
   break;
 case 20
 #line 432 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 21
 #line 437 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 22
 #line 445 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		current_namespace.AddUsingAlias (lt.Value, (MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 23
 #line 450 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 24
 #line 458 "cs-parser.jay"
   {
 		current_namespace.AddUsing ((MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 25
 #line 470 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (yyVals[-2+yyTop] != null) {
 			Report.Error(1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
 		}
 
 		current_namespace = new NamespaceEntry (module,
 			current_namespace, file, name.GetName ());
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 26
 #line 483 "cs-parser.jay"
   { 
 		current_namespace = current_namespace.Parent;
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 27
 #line 492 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName (lt.Value, lt.Location);
 	  }
   break;
 case 28
 #line 497 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 29
 #line 502 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new MemberName ("<invalid>", lexer.Location);
 	  }
   break;
 case 34
 #line 520 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (name.TypeArguments != null)
 			syntax_error (lexer.Location, "namespace name expected");
 
 		yyVal = name;
 	  }
   break;
 case 35
 #line 532 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 45
 #line 564 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			DeclSpace ds = (DeclSpace)yyVals[0+yyTop];
 
 			if ((ds.ModFlags & (Modifiers.PRIVATE|Modifiers.PROTECTED)) != 0){
 				Report.Error (1527, ds.Location, 
 				"Namespace elements cannot be explicitly declared as private, protected or protected internal");
 			}
 		}
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 46
 #line 576 "cs-parser.jay"
   {
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 47
 #line 580 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	 }
   break;
 case 53
 #line 606 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			Attributes attrs = (Attributes)yyVals[0+yyTop];
 			if (global_attrs_enabled) {
 				module.AddAttributes (attrs.Attrs, current_namespace);
 			} else {
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 			}
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 54
 #line 623 "cs-parser.jay"
   {
 		global_attrs_enabled = false;
 		yyVal = null;
       }
   break;
 case 55
 #line 628 "cs-parser.jay"
   { 
 		global_attrs_enabled = false;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 56
 #line 637 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect, current_namespace);
 					yyVal = null;
 				} else {
 					yyVal = new Attributes (sect);
 				}
 				if (yyVal == null) {
 					if (RootContext.Documentation != null) {
 						Lexer.check_incorrect_doc_comment ();
 						Lexer.doc_state =
 							XmlCommentState.Allowed;
 					}
 				}
 			} else {
 				yyVal = new Attributes (sect);
 			}		
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 57
 #line 664 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			Attributes attrs = yyVals[-1+yyTop] as Attributes;
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect);
 					yyVal = null;
 				} else {
 					if (attrs == null)
 						attrs = new Attributes (sect);
 					else
 						attrs.AddAttributes (sect);			
 				}
 			} else {
 				if (attrs == null)
 					attrs = new Attributes (sect);
 				else
 					attrs.AddAttributes (sect);
 			}		
 			yyVal = attrs;
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 58
 #line 695 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
  	  }
   break;
 case 59
 #line 699 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 60
 #line 706 "cs-parser.jay"
   {
 		current_attr_target = (string)yyVals[-1+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 61
 #line 714 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = CheckAttributeTarget (lt.Value, lt.Location);
 	  }
   break;
 case 62
 #line 718 "cs-parser.jay"
   { yyVal = "event"; }
   break;
 case 63
 #line 719 "cs-parser.jay"
   { yyVal = "return"; }
   break;
 case 64
 #line 721 "cs-parser.jay"
   {
 		string name = GetTokenName (yyToken);
 		yyVal = CheckAttributeTarget (name, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 65
 #line 729 "cs-parser.jay"
   {
 		yyVal = new List<Attribute> (4) { (Attribute) yyVals[0+yyTop] };
 	  }
   break;
 case 66
 #line 733 "cs-parser.jay"
   {
 		var attrs = (List<Attribute>) yyVals[-2+yyTop];
 		attrs.Add ((Attribute) yyVals[0+yyTop]);
 
 		yyVal = attrs;
 	  }
   break;
 case 67
 #line 743 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 68
 #line 747 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		MemberName mname = (MemberName) yyVals[-2+yyTop];
 		if (mname.IsGeneric) {
 			Report.Error (404, lexer.Location,
 				      "'<' unexpected
 		}
 
 		Arguments [] arguments = (Arguments []) yyVals[0+yyTop];
 		ATypeNameExpression expr = mname.GetTypeExpression ();
 
 		if (current_attr_target == String.Empty)
 			yyVal = null;
 		else if (global_attrs_enabled && (current_attr_target == "assembly" || current_attr_target == "module"))
 			/* FIXME
 			yyVal = new GlobalAttribute (current_namespace, current_attr_target,
 						  expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 		else
 			yyVal = new Attribute (current_attr_target, expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 	  }
   break;
 case 69
 #line 770 "cs-parser.jay"
   { /* reserved attribute name or identifier
   break;
 case 70
 #line 774 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 71
 #line 776 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 72
 #line 783 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 73
 #line 785 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = new Arguments [] { a, null };
 	  }
   break;
 case 74
 #line 791 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);  
 		yyVal = new Arguments [] { null, a };
 	  }
   break;
 case 75
 #line 797 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] != null) {
 			Report.Error (1016, ((Argument) yyVals[0+yyTop]).Expr.Location, "Named attribute arguments must appear after the positional arguments");
 			o [0] = new Arguments (4);
 		}
 		
 		Arguments args = ((Arguments) o [0]);
 		if (args.Count > 0 && !(yyVals[0+yyTop] is NamedArgument) && args [args.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 		
 		args.Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 76
 #line 811 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] == null) {
 			o [1] = new Arguments (4);
 		}
 
 		((Arguments) o [1]).Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 77
 #line 823 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 79
 #line 831 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 80
 #line 835 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop]);	  
 	  }
   break;
 case 81
 #line 844 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "named argument");
 			
 		/* Avoid boxing in common case (no modifier)*/
 		var arg_mod = yyVals[-1+yyTop] == null ? Argument.AType.None 
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop], arg_mod);
 	  }
   break;
 case 82
 #line 857 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 83
 #line 859 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Ref;
 	  }
   break;
 case 84
 #line 863 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Out;
 	  }
   break;
 case 99
 #line 891 "cs-parser.jay"
   {
 		Report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
 			GetSymbolName (yyToken));
 		yyVal = null;
 		lexer.parsing_generic_declaration = false;
 	  }
   break;
 case 100
 #line 904 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 101
 #line 908 "cs-parser.jay"
   { 
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Struct (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 102
 #line 914 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null)
 			current_container.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 103
 #line 925 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 104
 #line 931 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 105
 #line 936 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	  }
   break;
 case 106
 #line 943 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 107
 #line 948 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 122
 #line 985 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var mod = (Modifiers) yyVals[-3+yyTop];
 		current_field = new Const (current_class, (FullNamedExpression) yyVals[-1+yyTop], mod, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 		current_container.AddConstant ((Const) current_field);
 		
 		if ((mod & Modifiers.STATIC) != 0) {
 			Report.Error (504, current_field.Location, "The constant `{0}' cannot be marked static", current_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_field;
 	  }
   break;
 case 123
 #line 998 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_field = null;
 	  }
   break;
 case 126
 #line 1017 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 127
 #line 1021 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 128
 #line 1028 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 129
 #line 1037 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 130
 #line 1041 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 131
 #line 1046 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 		yyVal = null;
 	  }
   break;
 case 134
 #line 1061 "cs-parser.jay"
   {
 	  	lexer.parsing_generic_declaration = false;
 
 		FullNamedExpression type = (FullNamedExpression) yyVals[-1+yyTop];
 		if (type.Type == TypeManager.void_type)
 			Report.Error (670, GetLocation (yyVals[-1+yyTop]), "Fields cannot have void type");
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new Field (current_class, type, (Modifiers) yyVals[-2+yyTop], new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-3+yyTop]);
 		current_container.AddField (current_field);
 		yyVal = current_field;
 	  }
   break;
 case 135
 #line 1076 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 			
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 		current_field = null;
 	  }
   break;
 case 136
 #line 1089 "cs-parser.jay"
   { 
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "fixed size buffers");
 
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new FixedField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop],
 			new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 			
 		current_container.AddField (current_field);
 	  }
   break;
 case 137
 #line 1100 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 	    }
 
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];	    
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 	    current_field = null;
 	  }
   break;
 case 138
 #line 1115 "cs-parser.jay"
   {
 		Report.Error (1641, GetLocation (yyVals[-1+yyTop]), "A fixed size buffer field must have the array size specifier after the field name");
 	  }
   break;
 case 140
 #line 1123 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 141
 #line 1129 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_field.Initializer = (Expression) yyVals[0+yyTop];
 		end_block (lexer.Location);
 		current_local_parameters = null;
 	  }
   break;
 case 144
 #line 1144 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 145
 #line 1148 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 146
 #line 1155 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 147
 #line 1161 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 148
 #line 1165 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 151
 #line 1180 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 152
 #line 1184 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 153
 #line 1191 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];	  
 		yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 154
 #line 1200 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 155
 #line 1204 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 156
 #line 1210 "cs-parser.jay"
   {
 		Report.Error (443, lexer.Location, "Value or constant expected");
 		yyVal = null;
 	  }
   break;
 case 159
 #line 1220 "cs-parser.jay"
   {
 		/* It has to be here for the parent to safely restore artificial block*/
 	  	Error_SyntaxError (yyToken);
 	  	yyVal = null;
 	  }
   break;
 case 160
 #line 1228 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 161
 #line 1233 "cs-parser.jay"
   {
 		Method method = (Method) yyVals[-2+yyTop];
 		method.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (method);
 		
 		if (current_container.Kind == MemberKind.Interface && method.Block != null) {
 			Report.Error (531, method.Location, "`{0}'
 		}
 
 		current_local_parameters = null;
 
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 162
 #line 1254 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 163
 #line 1258 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 164
 #line 1262 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 						     (FullNamedExpression) yyVals[-7+yyTop], current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		} else if (yyVals[0+yyTop] != null) {
 			Report.Error (80, GetLocation (yyVals[0+yyTop]),
 				"Constraints are not allowed on non-generic declarations");
 		}
 
 		Method method = new Method (current_class, generic, (FullNamedExpression) yyVals[-7+yyTop], (Modifiers) yyVals[-8+yyTop],
 				     name, current_local_parameters, (Attributes) yyVals[-9+yyTop]);
 				     
 		if (yyVals[0+yyTop] != null && ((method.ModFlags & Modifiers.OVERRIDE) != 0 || method.IsExplicitImpl)) {
 			Report.Error (460, method.Location,
 				"`{0}'
 				method.GetSignatureForError ());
 		}
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 165
 #line 1299 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 166
 #line 1303 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 167
 #line 1307 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		if (yyVals[-1+yyTop] != null && name.TypeArguments == null)
 			Report.Error (80, lexer.Location,
 				      "Constraints are not allowed on non-generic declarations");
 
 		Method method;
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 				new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		}
 
 		var modifiers = (Modifiers) yyVals[-9+yyTop];
 
 
 		const Modifiers invalid_partial_mod = Modifiers.AccessibilityMask | Modifiers.ABSTRACT | Modifiers.EXTERN |
 			Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.SEALED | Modifiers.VIRTUAL;
 
 		if ((modifiers & invalid_partial_mod) != 0) {
 			Report.Error (750, name.Location, "A partial method cannot define access modifier or " +
        			"any of abstract, extern, new, override, sealed, or virtual modifiers");
 			modifiers &= ~invalid_partial_mod;
 		}
 
 		if ((current_class.ModFlags & Modifiers.PARTIAL) == 0) {
 			Report.Error (751, name.Location, "A partial method must be declared within a " +
        			"partial class or partial struct");
 		}
 		
 		modifiers |= Modifiers.PARTIAL | Modifiers.PRIVATE;
 		
 		method = new Method (current_class, generic, new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				     modifiers, name, current_local_parameters, (Attributes) yyVals[-10+yyTop]);
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		/* TODO
 		StoreModifierLocation (Modifiers.PARTIAL, GetLocation (yyVals[-8+yyTop]));
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 168
 #line 1362 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		Report.Error (1585, name.Location, 
 			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) yyVals[-4+yyTop]));
 
 		Method method = new Method (current_class, null, (FullNamedExpression) yyVals[-5+yyTop],
 					    0, name, (ParametersCompiled) yyVals[-1+yyTop], (Attributes) yyVals[-7+yyTop]);
 
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		yyVal = method;
 	  }
   break;
 case 170
 #line 1381 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 171
 #line 1385 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 173
 #line 1391 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 	  	yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 174
 #line 1396 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = new ParametersCompiled (pars_list.ToArray ()); 
 	  }
   break;
 case 175
 #line 1403 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[0+yyTop])));
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 176
 #line 1409 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[-2+yyTop] } );			
 	  }
   break;
 case 177
 #line 1416 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 178
 #line 1426 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[-2+yyTop])) }, true);
 	  }
   break;
 case 179
 #line 1432 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 180
 #line 1441 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[0+yyTop] } );
 	  }
   break;
 case 181
 #line 1445 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[0+yyTop])) }, true);
 	  }
   break;
 case 182
 #line 1449 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 183
 #line 1457 "cs-parser.jay"
   {
 		parameters_bucket.Clear ();
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		parameters_bucket.Add (p);
 		
 		default_parameter_used = p.HasDefaultValue;
 		yyVal = parameters_bucket;
 	  }
   break;
 case 184
 #line 1466 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		if (p != null) {
 			if (p.HasExtensionMethodModifier)
 				Report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
 			else if (!p.HasDefaultValue && default_parameter_used)
 				Report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");
 
 			default_parameter_used |= p.HasDefaultValue;
 			pars.Add (p);
 			
 			lbag.AddLocation (p, GetLocation (yyVals[-1+yyTop]));
 		}
 		
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 185
 #line 1490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 186
 #line 1498 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		Report.Error (1552, lt.Location, "Array type specifier, [], must appear before parameter name");
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Parameter.Modifier) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop], lt.Location);
 	  }
   break;
 case 187
 #line 1507 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  	Location l = GetLocation (yyVals[0+yyTop]);
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], "NeedSomeGeneratorHere", (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], l);
 	  }
   break;
 case 188
 #line 1517 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 189
 #line 1521 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		if (RootContext.Version <= LanguageVersion.V_3) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "optional parameter");
 		}
 		
 		Parameter.Modifier mod = (Parameter.Modifier) yyVals[-5+yyTop];
 		if (mod != Parameter.Modifier.NONE) {
 			switch (mod) {
 			case Parameter.Modifier.REF
 			case Parameter.Modifier.OUT
 				Report.Error (1741, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 				
 			case Parameter.Modifier.This
 				Report.Error (1743, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 			default
 				throw new NotImplementedException (mod.ToString ());
 			}
 				
 			mod = Parameter.Modifier.NONE;
 		}
 		
 		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
 			Report.Error (1065, GetLocation (yyVals[-2+yyTop]), "Optional parameter is not valid in this context");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-4+yyTop], lt.Value, mod, (Attributes) yyVals[-6+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 		
 		if (yyVals[0+yyTop] != null)
 			((Parameter) yyVal).DefaultValue = new DefaultParameterValueExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 190
 #line 1560 "cs-parser.jay"
   { yyVal = Parameter.Modifier.NONE; }
   break;
 case 192
 #line 1566 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 193
 #line 1570 "cs-parser.jay"
   {
 		Parameter.Modifier p2 = (Parameter.Modifier)yyVals[0+yyTop];
   		Parameter.Modifier mod = (Parameter.Modifier)yyVals[-1+yyTop] | p2;
   		if (((Parameter.Modifier)yyVals[-1+yyTop] & p2) == p2) {
   			Error_DuplicateParameterModifier (lexer.Location, p2);
   		} else {
 	  		switch (mod & ~Parameter.Modifier.This) {
   				case Parameter.Modifier.REF
 					Report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
   					break;
    				case Parameter.Modifier.OUT
 					Report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
   					break;
   				default
  					Report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
  					break;
  			}
   		}
   		yyVal = mod;
 	  }
   break;
 case 194
 #line 1594 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
 	  		Error_ParameterModifierNotValid ("ref", GetLocation (yyVals[0+yyTop]));
 	  		
 	  	yyVal = Parameter.Modifier.REF;
 	  }
   break;
 case 195
 #line 1601 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
 	  		Error_ParameterModifierNotValid ("out", GetLocation (yyVals[0+yyTop]));
 	  
 	  	yyVal = Parameter.Modifier.OUT;
 	  }
   break;
 case 196
 #line 1608 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.This) == 0)
 	  		Error_ParameterModifierNotValid ("this", GetLocation (yyVals[0+yyTop]));
 
 	  	if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "extension methods");
 	  			
 		yyVal = Parameter.Modifier.This;
 	  }
   break;
 case 197
 #line 1621 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 198
 #line 1626 "cs-parser.jay"
   {
 		Report.Error (1751, GetLocation (yyVals[-4+yyTop]), "Cannot specify a default value for a parameter array");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Attributes) yyVals[-5+yyTop], lt.Location);		
 	  }
   break;
 case 199
 #line 1633 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 200
 #line 1641 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.Params) == 0)
 			Report.Error (1670, (GetLocation (yyVals[0+yyTop])), "The `params' modifier is not allowed in current context");
 	  }
   break;
 case 201
 #line 1646 "cs-parser.jay"
   {
 		Parameter.Modifier mod = (Parameter.Modifier)yyVals[0+yyTop];
 		if ((mod & Parameter.Modifier.This) != 0) {
 			Report.Error (1104, GetLocation (yyVals[-1+yyTop]), "The parameter modifiers `this' and `params' cannot be used altogether");
 		} else {
 			Report.Error (1611, GetLocation (yyVals[-1+yyTop]), "The params parameter cannot be declared as ref or out");
 		}	  
 	  }
   break;
 case 202
 #line 1655 "cs-parser.jay"
   {
 		Error_DuplicateParameterModifier (GetLocation (yyVals[-1+yyTop]), Parameter.Modifier.PARAMS);
 	  }
   break;
 case 203
 #line 1662 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Arglist) == 0)
 	  		Report.Error (1669, GetLocation (yyVals[0+yyTop]), "__arglist is not valid in this context");
 	  }
   break;
 case 204
 #line 1673 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			tmpComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 205
 #line 1678 "cs-parser.jay"
   {
 		current_property = new Property (current_class, (FullNamedExpression) yyVals[-3+yyTop], (Modifiers) yyVals[-4+yyTop],
 			(MemberName) yyVals[-2+yyTop], (Attributes) yyVals[-5+yyTop]);
 			
 		if (current_property.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (547, GetLocation (yyVals[-3+yyTop]), "`{0}'
 			
 		current_container.AddProperty ((Property)current_property);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[0+yyTop]));
 		
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 206
 #line 1691 "cs-parser.jay"
   {
 		lexer.PropertyParsing = false;
 		
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();				
 	  }
   break;
 case 207
 #line 1698 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_property, GetLocation (yyVals[0+yyTop]));
 		current_property = null;
 	  }
   break;
 case 208
 #line 1708 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 209
 #line 1712 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  
 		Indexer indexer = new Indexer (current_class, (FullNamedExpression) yyVals[-6+yyTop],
 			(MemberName)yyVals[-5+yyTop], (Modifiers) yyVals[-7+yyTop], (ParametersCompiled) yyVals[-2+yyTop], (Attributes) yyVals[-8+yyTop]);
 			
 		current_property = indexer;
 
   		current_container.AddIndexer (indexer);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
   		
 		if (indexer.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (620, GetLocation (yyVals[-6+yyTop]), "`{0}'
 
 		if (indexer.Parameters.IsEmpty) {
 			Report.Error (1551, GetLocation (yyVals[-4+yyTop]), "Indexers must have at least one parameter");
 		}
 
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 210
 #line 1738 "cs-parser.jay"
   {
 		  lexer.PropertyParsing = false;
 	  }
   break;
 case 211
 #line 1742 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();
 			
 		lbag.AppendToMember (current_property, GetLocation (yyVals[-1+yyTop]));
 		current_property = null;		
 	  }
   break;
 case 216
 #line 1758 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_BRACE) {
 	  		Report.Error (548, lexer.Location, "`{0}'
 		} else {
 			if (yyToken == Token.SEMICOLON)
 				Report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
 			else
 				Report.Error (1014, GetLocation (yyVals[0+yyTop]), "A get or set accessor expected");
 		}
 	  }
   break;
 case 217
 #line 1772 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 	  
 		if (current_property.Get != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 		
 		if (current_property is Indexer) {
 			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop], ((Indexer)current_property).ParameterInfo.Clone (),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Get = new Property.GetMethod (current_property,
 				(Modifiers) yyVals[-1+yyTop], (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}	
 	  
 		current_local_parameters = current_property.Get.ParameterInfo;	  
 		lbag.AddMember (current_property.Get, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 218
 #line 1794 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] != null) {
 	  		current_property.Get.Block = (ToplevelBlock) yyVals[0+yyTop];			
 	  	
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Get.Block.StartLocation,
 					"`{0}'
 			}		
 		}
 	  
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null)
 			if (Lexer.doc_state == XmlCommentState.Error)
 				Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 219
 #line 1815 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 		
 		if (current_property.Set != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 	  
 		if (current_property is Indexer) {
 			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop],
 				ParametersCompiled.MergeGenerated (compiler,
 				((Indexer)current_property).ParameterInfo, true, new Parameter (
 					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation (yyVals[0+yyTop])),
 					null),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Set = new Property.SetMethod (current_property, (Modifiers) yyVals[-1+yyTop], 
 				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation (yyVals[0+yyTop])),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}
 		
 		current_local_parameters = current_property.Set.ParameterInfo;	
 		lbag.AddMember (current_property.Set, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 220
 #line 1842 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {		
 			current_property.Set.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Set.Block.StartLocation,
 					"`{0}'
 			}
 		}
 		
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null
 			&& Lexer.doc_state == XmlCommentState.Error)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 222
 #line 1864 "cs-parser.jay"
   {
 		/* TODO
 	  	yyVal = null;
 	  }
   break;
 case 223
 #line 1869 "cs-parser.jay"
   {
 	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
 	  	yyVal = null;
 	  }
   break;
 case 224
 #line 1880 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 225
 #line 1884 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Interface (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 226
 #line 1891 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 227
 #line 1902 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 228
 #line 1908 "cs-parser.jay"
   {
 	    lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 229
 #line 1913 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  }
   break;
 case 234
 #line 1930 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 235
 #line 1934 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 240
 #line 1942 "cs-parser.jay"
   {
 	  	Report.Error (567, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain operators");
 	  }
   break;
 case 241
 #line 1946 "cs-parser.jay"
   {
 	  	Report.Error (526, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain contructors");
 	  }
   break;
 case 242
 #line 1950 "cs-parser.jay"
   {
 	  	Report.Error (524, GetLocation (yyVals[0+yyTop]), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
 	  }
   break;
 case 243
 #line 1957 "cs-parser.jay"
   {
 	  }
   break;
 case 244
 #line 1960 "cs-parser.jay"
   {
 		OperatorDeclaration decl = (OperatorDeclaration) yyVals[-2+yyTop];
 		if (decl != null) {
 			Operator op = new Operator (
 				current_class, decl.optype, decl.ret_type, (Modifiers) yyVals[-3+yyTop], 
 				current_local_parameters,
 				(ToplevelBlock) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop], decl.location);
 
 			if (RootContext.Documentation != null) {
 				op.DocComment = tmpComment;
 				Lexer.doc_state = XmlCommentState.Allowed;
 			}
 
 			/* Note again, checking is done in semantic analysis*/
 			current_container.AddOperator (op);
 
 			lbag.AddMember (op, mod_locations, lbag.GetLocations (decl));
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 246
 #line 1985 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 248
 #line 1991 "cs-parser.jay"
   {
 		Report.Error (590, GetLocation (yyVals[0+yyTop]), "User-defined operators cannot return void");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 249
 #line 1999 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 250
 #line 2003 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		Operator.OpType op = (Operator.OpType) yyVals[-4+yyTop];
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];
 		
 		int p_count = current_local_parameters.Count;
 		if (p_count == 1) {
 			if (op == Operator.OpType.Addition)
 				op = Operator.OpType.UnaryPlus;
 			else if (op == Operator.OpType.Subtraction)
 				op = Operator.OpType.UnaryNegation;
 		}
 		
 		if (IsUnaryOperator (op)) {
 			if (p_count == 2) {
 				Report.Error (1020, loc, "Overloadable binary operator expected");
 			} else if (p_count != 1) {
 				Report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
 					Operator.GetName (op));
 			}
 		} else {
 			if (p_count > 2) {
 				Report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
 					Operator.GetName (op));
 			} else if (p_count != 2) {
 				Report.Error (1019, loc, "Overloadable unary operator expected");
 			}
 		}
 		
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (op, (FullNamedExpression) yyVals[-6+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 252
 #line 2047 "cs-parser.jay"
   { yyVal = Operator.OpType.LogicalNot; }
   break;
 case 253
 #line 2048 "cs-parser.jay"
   { yyVal = Operator.OpType.OnesComplement; }
   break;
 case 254
 #line 2049 "cs-parser.jay"
   { yyVal = Operator.OpType.Increment; }
   break;
 case 255
 #line 2050 "cs-parser.jay"
   { yyVal = Operator.OpType.Decrement; }
   break;
 case 256
 #line 2051 "cs-parser.jay"
   { yyVal = Operator.OpType.True; }
   break;
 case 257
 #line 2052 "cs-parser.jay"
   { yyVal = Operator.OpType.False; }
   break;
 case 258
 #line 2054 "cs-parser.jay"
   { yyVal = Operator.OpType.Addition; }
   break;
 case 259
 #line 2055 "cs-parser.jay"
   { yyVal = Operator.OpType.Subtraction; }
   break;
 case 260
 #line 2057 "cs-parser.jay"
   { yyVal = Operator.OpType.Multiply; }
   break;
 case 261
 #line 2058 "cs-parser.jay"
   {  yyVal = Operator.OpType.Division; }
   break;
 case 262
 #line 2059 "cs-parser.jay"
   { yyVal = Operator.OpType.Modulus; }
   break;
 case 263
 #line 2060 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseAnd; }
   break;
 case 264
 #line 2061 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseOr; }
   break;
 case 265
 #line 2062 "cs-parser.jay"
   { yyVal = Operator.OpType.ExclusiveOr; }
   break;
 case 266
 #line 2063 "cs-parser.jay"
   { yyVal = Operator.OpType.LeftShift; }
   break;
 case 267
 #line 2064 "cs-parser.jay"
   { yyVal = Operator.OpType.RightShift; }
   break;
 case 268
 #line 2065 "cs-parser.jay"
   { yyVal = Operator.OpType.Equality; }
   break;
 case 269
 #line 2066 "cs-parser.jay"
   { yyVal = Operator.OpType.Inequality; }
   break;
 case 270
 #line 2067 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThan; }
   break;
 case 271
 #line 2068 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThan; }
   break;
 case 272
 #line 2069 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThanOrEqual; }
   break;
 case 273
 #line 2070 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThanOrEqual; }
   break;
 case 274
 #line 2075 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 275
 #line 2079 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 276
 #line 2094 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 277
 #line 2098 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 278
 #line 2113 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 279
 #line 2119 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	yyVal = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 280
 #line 2129 "cs-parser.jay"
   { 
 		Constructor c = (Constructor) yyVals[-1+yyTop];
 		c.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (RootContext.Documentation != null)
 			c.DocComment = ConsumeStoredComment ();
 
 		current_container.AddConstructor (c);
 
 		current_local_parameters = null;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 281
 #line 2148 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 282
 #line 2157 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];  
 		
 		/**/
 		/* start block here, so possible anonymous methods inside*/
 		/* constructor initializer can get correct parent block*/
 		/**/
 	  	start_block (lexer.Location);
 	  }
   break;
 case 283
 #line 2168 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-6+yyTop];
 		var mods = (Modifiers) yyVals[-7+yyTop];
 		ConstructorInitializer ci = (ConstructorInitializer) yyVals[0+yyTop];
 
 		Constructor c = new Constructor (current_class, lt.Value, mods,
 			(Attributes) yyVals[-8+yyTop], current_local_parameters, ci, lt.Location);
 		
 		if (lt.Value != current_container.MemberName.Name) {
 			Report.Error (1520, c.Location, "Class, struct, or interface method must have a return type");
 		} else if ((mods & Modifiers.STATIC) != 0) {
 			if ((mods & Modifiers.AccessibilityMask) != 0){
 				Report.Error (515, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			}
 			if (ci != null) {
 				Report.Error (514, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			
 			}
 		}
 		
 		lbag.AddMember (c, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 285
 #line 2199 "cs-parser.jay"
   { current_block = null; yyVal = null; }
   break;
 case 288
 #line 2209 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 289
 #line 2213 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorBaseInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 290
 #line 2219 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 291
 #line 2223 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorThisInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 292
 #line 2229 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 293
 #line 2237 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 		
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 294
 #line 2246 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		if (lt.Value != current_container.MemberName.Name){
 			Report.Error (574, lt.Location, "Name of destructor must match name of class");
 		} else if (current_container.Kind != MemberKind.Class){
 			Report.Error (575, lt.Location, "Only class types can contain destructor");
 		}
 		
 		Destructor d = new Destructor (current_class, (Modifiers) yyVals[-6+yyTop],
 			ParametersCompiled.EmptyReadOnlyParameters, (Attributes) yyVals[-7+yyTop], lt.Location);
 		if (RootContext.Documentation != null)
 			d.DocComment = ConsumeStoredComment ();
 		  
 		d.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (d);
 		lbag.AddMember (d, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		current_local_parameters = null;
 	  }
   break;
 case 295
 #line 2271 "cs-parser.jay"
   {
 		current_event_field = new EventField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop], (MemberName) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop]);
 		current_container.AddEvent (current_event_field);
 		
 		if (current_event_field.MemberName.Left != null) {
 			Report.Error (71, current_event_field.Location, "`{0}'
 			current_event_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_event_field;
 	  }
   break;
 case 296
 #line 2285 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AddMember (current_event_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_event_field = null;
 	  }
   break;
 case 297
 #line 2298 "cs-parser.jay"
   {
 		current_event = new EventProperty (current_class, (FullNamedExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-4+yyTop], (MemberName) yyVals[-1+yyTop], (Attributes) yyVals[-5+yyTop]);
 		current_container.AddEvent (current_event);
 		lbag.AddMember (current_event, mod_locations, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		
 		lexer.EventParsing = true;
 	  }
   break;
 case 298
 #line 2306 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface)
 			Report.Error (69, GetLocation (yyVals[-2+yyTop]), "Event in interface cannot have add or remove accessors");
 	  
 		lexer.EventParsing = false;
 	  }
   break;
 case 299
 #line 2313 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AppendToMember (current_event, GetLocation (yyVals[-1+yyTop]));
 	  	current_event = null;	
 		current_local_parameters = null;
 	  }
   break;
 case 301
 #line 2328 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 302
 #line 2332 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_event_field.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 305
 #line 2345 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 306
 #line 2349 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 307
 #line 2356 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 308
 #line 2362 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 309
 #line 2366 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 310
 #line 2375 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (68, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 		}
 		
 	  	if ((current_event_field.ModFlags & Modifiers.ABSTRACT) != 0) {
 			Report.Error (74, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 	  	}		
 	  }
   break;
 case 311
 #line 2387 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 314
 #line 2396 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 315
 #line 2401 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 316
 #line 2406 "cs-parser.jay"
   { 
 		Report.Error (1055, GetLocation (yyVals[0+yyTop]), "An add or remove accessor expected");
 		yyVal = null;
 	  }
   break;
 case 317
 #line 2414 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Add = new EventProperty.AddDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Add.ParameterInfo;
 		
 		lbag.AddMember (current_event.Add, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 318
 #line 2426 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Add.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Add.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 319
 #line 2442 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Remove = new EventProperty.RemoveDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Remove.ParameterInfo;
 
 		lbag.AddMember (current_event.Remove, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 320
 #line 2454 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Remove.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Remove.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 321
 #line 2470 "cs-parser.jay"
   {
 		Report.Error (73, lexer.Location, "An add or remove accessor must have a body");
 		yyVal = null;
 	  }
   break;
 case 323
 #line 2482 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			enumTypeComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 324
 #line 2487 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		if (name.IsGeneric) {
 			Report.Error (1675, name.Location, "Enums cannot have type parameters");
 		}
 		
 		push_current_class (new Enum (current_namespace, current_class, (TypeExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-5+yyTop], MakeName (name), (Attributes) yyVals[-6+yyTop]), null);
 	  }
   break;
 case 325
 #line 2499 "cs-parser.jay"
   {
 	  	/* here will be evaluated after CLOSE_BLACE is consumed.*/
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 326
 #line 2505 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			current_class.DocComment = enumTypeComment;
 			
 		--lexer.parsing_declaration;
 
 /*			if (RootContext.Documentation != null)*/
 /*				em.DocComment = ev.DocComment;*/
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-9+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 328
 #line 2522 "cs-parser.jay"
   {
 	 	var te = yyVals[0+yyTop] as TypeExpression;
 		if (te == null ||
 			(te.Type != TypeManager.int32_type && te.Type != TypeManager.uint32_type &&
 			te.Type != TypeManager.int64_type && te.Type != TypeManager.uint64_type &&
 			te.Type != TypeManager.short_type && te.Type != TypeManager.ushort_type &&
 			te.Type != TypeManager.byte_type && te.Type != TypeManager.sbyte_type)) {
 			Enum.Error_1008 (GetLocation (yyVals[0+yyTop]), Report);
 			yyVal = null;
 		} else {
 			yyVal = yyVals[0+yyTop];
 		}
 	 }
   break;
 case 329
 #line 2536 "cs-parser.jay"
   {
 	 	Error_TypeExpected (GetLocation (yyVals[-1+yyTop]));
 		yyVal = null;
 	 }
   break;
 case 332
 #line 2546 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 334
 #line 2554 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 335
 #line 2562 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-1+yyTop]);
 	  	((Enum) current_class).AddEnumMember (em);
 
 		if (RootContext.Documentation != null) {
 			em.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		yyVal = em;
 	  }
   break;
 case 336
 #line 2575 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 	  }
   break;
 case 337
 #line 2583 "cs-parser.jay"
   { 
 		--lexer.parsing_block;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 	  	em.Initializer = new ConstInitializer (em, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	((Enum) current_class).AddEnumMember (em);
 		
 		if (RootContext.Documentation != null)
 			em.DocComment = ConsumeStoredComment ();
 
 		yyVal = em;
 	  }
   break;
 case 338
 #line 2604 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out | ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 339
 #line 2608 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		MemberName name = MakeName ((MemberName) yyVals[-4+yyTop]);
 		ParametersCompiled p = (ParametersCompiled) yyVals[-1+yyTop];
 
 		Delegate del = new Delegate (current_namespace, current_class, (FullNamedExpression) yyVals[-5+yyTop],
 					     (Modifiers) yyVals[-7+yyTop], name, p, (Attributes) yyVals[-8+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			del.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		current_container.AddDelegate (del);
 		current_delegate = del;
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 340
 #line 2627 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 	  }
   break;
 case 341
 #line 2631 "cs-parser.jay"
   {
 		current_delegate.SetParameterInfo ((List<Constraints>) yyVals[-2+yyTop]);
 		lbag.AddMember (current_delegate, mod_locations, GetLocation (yyVals[-10+yyTop]), GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[0+yyTop]));
 
 		yyVal = current_delegate;
 
 		current_delegate = null;
 	  }
   break;
 case 343
 #line 2644 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "nullable types");
 	  
 	  	yyVal = ComposedTypeSpecifier.CreateNullable (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 345
 #line 2655 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 347
 #line 2666 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 348
 #line 2675 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 350
 #line 2687 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");	  
 	  
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 351
 #line 2694 "cs-parser.jay"
   {
 		Error_TypeExpected (lexer.Location);
 		yyVal = new TypeArguments ();
 	  }
   break;
 case 352
 #line 2702 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 353
 #line 2708 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 354
 #line 2720 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 355
 #line 2724 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 356
 #line 2733 "cs-parser.jay"
   {
 	  	MemberName mn = (MemberName)yyVals[0+yyTop];
 	  	if (mn.TypeArguments != null)
 	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
 	  			mn.GetSignatureForError ()));
 	  }
   break;
 case 358
 #line 2744 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 359
 #line 2753 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		yyVal = new MemberName (TypeContainer.DefaultIndexerName, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 360
 #line 2758 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		yyVal = new MemberName ((MemberName) yyVals[-1+yyTop], TypeContainer.DefaultIndexerName, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 361
 #line 2766 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 362
 #line 2772 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[-1+yyTop], lt1.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 363
 #line 2780 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 365
 #line 2790 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");
 	  
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 366
 #line 2801 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 367
 #line 2807 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 		lbag.AddLocation (yyVals[0+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 368
 #line 2817 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 		yyVal = new TypeParameterName (lt.Value, (Attributes)yyVals[-2+yyTop], (Variance) yyVals[-1+yyTop], lt.Location);
   	  }
   break;
 case 369
 #line 2822 "cs-parser.jay"
   {
   	  	if (GetTokenName (yyToken) == "type")
 			Report.Error (81, GetLocation (yyVals[0+yyTop]), "Type parameter declaration must be an identifier not a type");
 		else
 			Error_SyntaxError (yyToken);
 			
   	  	yyVal = new TypeParameterName ("", null, lexer.Location);
   	  }
   break;
 case 371
 #line 2838 "cs-parser.jay"
   {
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 372
 #line 2845 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 374
 #line 2856 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 376
 #line 2865 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 378
 #line 2874 "cs-parser.jay"
   {
 	  	Report.Error (1536, GetLocation (yyVals[0+yyTop]), "Invalid parameter type `void'");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 380
 #line 2883 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 381
 #line 2890 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-1+yyTop];
 
 		if (yyVals[0+yyTop] != null) {
 			yyVal = new ComposedCast (name.GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			if (name.Left == null && name.Name == "var")
 				yyVal = new VarExpr (name.Location);
 			else
 				yyVal = name.GetTypeExpression ();
 		}
 	  }
   break;
 case 382
 #line 2903 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (((MemberName) yyVals[-1+yyTop]).GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 383
 #line 2907 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null)
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 384
 #line 2912 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 385
 #line 2916 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 386
 #line 2923 "cs-parser.jay"
   {
 		var types = new List<FullNamedExpression> (2);
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 387
 #line 2929 "cs-parser.jay"
   {
 		var types = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 388
 #line 2938 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast) {
 			Report.Error (1521, GetLocation (yyVals[0+yyTop]), "Invalid base type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 389
 #line 2945 "cs-parser.jay"
   {
 	  	Error_TypeExpected (lexer.Location);
 		yyVal = null;
 	  }
   break;
 case 390
 #line 2956 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.object_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 391
 #line 2957 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.string_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 392
 #line 2958 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.bool_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 393
 #line 2959 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.decimal_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 394
 #line 2960 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.float_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 395
 #line 2961 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.double_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 397
 #line 2966 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.sbyte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 398
 #line 2967 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.byte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 399
 #line 2968 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.short_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 400
 #line 2969 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.ushort_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 401
 #line 2970 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 402
 #line 2971 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 403
 #line 2972 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 404
 #line 2973 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 405
 #line 2974 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.char_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 425
 #line 3006 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new SimpleName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 426
 #line 3010 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	       yyVal = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
 	  }
   break;
 case 430
 #line 3020 "cs-parser.jay"
   { yyVal = new NullLiteral (GetLocation (yyVals[0+yyTop])); }
   break;
 case 431
 #line 3024 "cs-parser.jay"
   { yyVal = new BoolLiteral (true, GetLocation (yyVals[0+yyTop])); }
   break;
 case 432
 #line 3025 "cs-parser.jay"
   { yyVal = new BoolLiteral (false, GetLocation (yyVals[0+yyTop])); }
   break;
 case 437
 #line 3051 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 438
 #line 3056 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 	  }
   break;
 case 439
 #line 3063 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 440
 #line 3069 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 441
 #line 3075 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 442
 #line 3081 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 443
 #line 3087 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null,GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 444
 #line 3090 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
 	  }
   break;
 case 445
 #line 3095 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null, lexer.Location);
 	  }
   break;
 case 446
 #line 3098 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
  	  }
   break;
 case 447
 #line 3106 "cs-parser.jay"
   {
 		yyVal = new Invocation ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 448
 #line 3113 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 450
 #line 3119 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] == null) {
 	  		yyVal = CollectionOrObjectInitializers.Empty;
 	  		/* TODO
 	  	} else {
 	  		yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  	}
 	  }
   break;
 case 451
 #line 3129 "cs-parser.jay"
   {
 	  	yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 452
 #line 3136 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 453
 #line 3138 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	}
   break;
 case 454
 #line 3145 "cs-parser.jay"
   {
 	  	var a = new List<Expression> ();
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 455
 #line 3151 "cs-parser.jay"
   {
 	  	var a = (List<Expression>)yyVals[-2+yyTop];
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 456
 #line 3156 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 457
 #line 3164 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 	  	yyVal = new ElementInitializer (lt.Value, (Expression)yyVals[0+yyTop], lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 458
 #line 3170 "cs-parser.jay"
   {
 		yyVal = new CompletionElementInitializer (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 459
 #line 3173 "cs-parser.jay"
   {
 		CompletionSimpleName csn = yyVals[-1+yyTop] as CompletionSimpleName;
 		if (csn == null)
 			yyVal = new CollectionElementInitializer ((Expression)yyVals[-1+yyTop]);
 		else
 			yyVal = new CompletionElementInitializer (csn.Prefix, csn.Location);
 	  }
   break;
 case 460
 #line 3181 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] == null)
 			yyVal = null;
 		else
 	  		yyVal = new CollectionElementInitializer ((List<Expression>)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 461
 #line 3188 "cs-parser.jay"
   {
 	  	Report.Error (1920, GetLocation (yyVals[-1+yyTop]), "An element initializer cannot be empty");
 		yyVal = null;
 	  }
   break;
 case 464
 #line 3200 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 466
 #line 3206 "cs-parser.jay"
   { 
 		Arguments list = new Arguments (4);
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 467
 #line 3212 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		if (list [list.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
 		
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 468
 #line 3221 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		NamedArgument a = (NamedArgument) yyVals[0+yyTop];
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		
 		list.Add (a);
 		yyVal = list;
 	  }
   break;
 case 469
 #line 3235 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[0+yyTop]), "An argument is missing");
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 470
 #line 3240 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[-1+yyTop]), "An argument is missing");
 	  	yyVal = null;
 	  }
   break;
 case 471
 #line 3248 "cs-parser.jay"
   {
 		yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 475
 #line 3261 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Ref);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 476
 #line 3266 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Out);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 477
 #line 3271 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 478
 #line 3276 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist (GetLocation (yyVals[-2+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 480
 #line 3288 "cs-parser.jay"
   {
 		yyVal = new ElementAccess ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 481
 #line 3296 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 482
 #line 3302 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 483
 #line 3307 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 484
 #line 3315 "cs-parser.jay"
   {
 		Arguments args = new Arguments (4);
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;
 	  }
   break;
 case 485
 #line 3321 "cs-parser.jay"
   {
 		Arguments args = (Arguments) yyVals[-2+yyTop];
 		if (args [args.Count - 1] is NamedArgument && !(yyVals[0+yyTop] is NamedArgument))
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 	  
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;	  
 	  }
   break;
 case 486
 #line 3333 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 488
 #line 3341 "cs-parser.jay"
   {
 		yyVal = new This (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 489
 #line 3348 "cs-parser.jay"
   {
 	  	yyVal = new ElementAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 490
 #line 3353 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = new ElementAccess (null, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 491
 #line 3361 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 492
 #line 3368 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 493
 #line 3375 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			if (RootContext.Version <= LanguageVersion.ISO_2)
 				Report.FeatureIsNotAvailable (GetLocation (yyVals[-5+yyTop]), "object initializers");
 				
 			yyVal = new NewInitialize ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		} else {
 			yyVal = new New ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], GetLocation (yyVals[-5+yyTop]));
 		}
 		
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 494
 #line 3388 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "collection initializers");
 	  
 		yyVal = new NewInitialize ((FullNamedExpression) yyVals[-1+yyTop], null, (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 495
 #line 3400 "cs-parser.jay"
   {
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], (List<Expression>) yyVals[-3+yyTop],
 				new ComposedTypeSpecifier (((List<Expression>) yyVals[-3+yyTop]).Count, GetLocation (yyVals[-4+yyTop])) {
 	  				Next = (ComposedTypeSpecifier) yyVals[-1+yyTop]
 			  	}, (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 496
 #line 3408 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] == null)
 	  		Report.Error (1586, GetLocation (yyVals[-3+yyTop]), "Array creation must have array size or array initializer");
 
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-2+yyTop], (ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 497
 #line 3415 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "implicitly typed arrays");
 	  
 		yyVal = new ImplicitlyTypedArrayCreation ((ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 498
 #line 3422 "cs-parser.jay"
   {
 		Report.Error (178, GetLocation (yyVals[-1+yyTop]), "Invalid rank specifier, expecting `,' or `]'");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], null, GetLocation (yyVals[-6+yyTop]));
 	  }
   break;
 case 499
 #line 3427 "cs-parser.jay"
   {
 		Error_SyntaxError (1526, yyToken, "Unexpected symbol");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-1+yyTop], null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 500
 #line 3434 "cs-parser.jay"
   {
 		++lexer.parsing_type;
 	  }
   break;
 case 501
 #line 3438 "cs-parser.jay"
   {
 		--lexer.parsing_type;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 502
 #line 3446 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "anonymous types");
 
 		yyVal = new NewAnonymousType ((List<AnonymousTypeParameter>) yyVals[-1+yyTop], current_container, GetLocation (yyVals[-3+yyTop]));
 		
 		/* TODO
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 505
 #line 3463 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 507
 #line 3469 "cs-parser.jay"
   {
 	  	var a = new List<AnonymousTypeParameter> (4);
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 508
 #line 3475 "cs-parser.jay"
   {
 	  	var a = (List<AnonymousTypeParameter>) yyVals[-2+yyTop];
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 509
 #line 3484 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[-2+yyTop];
 	  	yyVal = new AnonymousTypeParameter ((Expression)yyVals[0+yyTop], lt.Value, lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 510
 #line 3490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (new SimpleName (lt.Value, lt.Location),
 	  		lt.Value, lt.Location);
 	  }
   break;
 case 511
 #line 3496 "cs-parser.jay"
   {
 	  	MemberAccess ma = (MemberAccess) yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (ma, ma.Name, ma.Location);
 	  }
   break;
 case 512
 #line 3501 "cs-parser.jay"
   {
 		Report.Error (746, lexer.Location,
 			"Invalid anonymous type member declarator. Anonymous type members must be a member assignment, simple name or member access expression");
 		yyVal = null;
 	  }
   break;
 case 516
 #line 3516 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 517
 #line 3524 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 518
 #line 3528 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension ((int)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 519
 #line 3535 "cs-parser.jay"
   {
 		yyVal = 2;
 	  }
   break;
 case 520
 #line 3539 "cs-parser.jay"
   {
 		yyVal = ((int) yyVals[-1+yyTop]) + 1;
 	  }
   break;
 case 521
 #line 3546 "cs-parser.jay"
   {
 		yyVal = null;
 	  }
   break;
 case 522
 #line 3550 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 523
 #line 3557 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer (0, GetLocation (yyVals[-1+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[0+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 524
 #line 3564 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[-1+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 525
 #line 3574 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 526
 #line 3580 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 527
 #line 3589 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = true;
 	  }
   break;
 case 528
 #line 3593 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = false;
 		yyVal = new TypeOf ((FullNamedExpression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 531
 #line 3604 "cs-parser.jay"
   {
 	 	Error_TypeExpected (lexer.Location);
 	 	yyVal = null;
 	 }
   break;
 case 532
 #line 3612 "cs-parser.jay"
   {  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new SimpleName (lt.Value, (int) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 533
 #line 3618 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (int) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 534
 #line 3625 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 535
 #line 3631 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 536
 #line 3637 "cs-parser.jay"
   {
 		var te = ((MemberName) yyVals[-3+yyTop]).GetTypeExpression ();
 		if (te.HasTypeArguments)
 			Error_TypeExpected (GetLocation (yyVals[0+yyTop]));
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (te, lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 537
 #line 3649 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "generics");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 538
 #line 3659 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		if (RootContext.Version == LanguageVersion.ISO_1)
 			Report.FeatureIsNotAvailable (lt.Location, "namespace alias qualifier");
 
 		yyVal = lt;		
 	  }
   break;
 case 539
 #line 3670 "cs-parser.jay"
   { 
 		yyVal = new SizeOf ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 540
 #line 3678 "cs-parser.jay"
   {
 		yyVal = new CheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 541
 #line 3686 "cs-parser.jay"
   {
 		yyVal = new UnCheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 542
 #line 3694 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberAccess (new Indirection ((Expression) yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop])), lt.Value, lt.Location);
 	  }
   break;
 case 543
 #line 3702 "cs-parser.jay"
   {
 		start_anonymous (false, (ParametersCompiled) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 544
 #line 3706 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 	  }
   break;
 case 545
 #line 3713 "cs-parser.jay"
   {
 		yyVal = ParametersCompiled.Undefined;
 	  }
   break;
 case 547
 #line 3721 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 548
 #line 3725 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 549
 #line 3733 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "default value expression");
 
 		yyVal = new DefaultValueExpression ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 551
 #line 3745 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.LogicalNot, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 552
 #line 3749 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.OnesComplement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 554
 #line 3757 "cs-parser.jay"
   {
 		yyVal = new Cast ((FullNamedExpression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 556
 #line 3770 "cs-parser.jay"
   { 
 	  	yyVal = new Unary (Unary.Operator.UnaryPlus, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 557
 #line 3774 "cs-parser.jay"
   { 
 		yyVal = new Unary (Unary.Operator.UnaryNegation, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 558
 #line 3778 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 559
 #line 3782 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 560
 #line 3786 "cs-parser.jay"
   {
 		yyVal = new Indirection ((Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 561
 #line 3790 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.AddressOf, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 563
 #line 3798 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Multiply, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 564
 #line 3803 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Division, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 565
 #line 3808 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Modulus, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 567
 #line 3817 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Addition, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 568
 #line 3822 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 569
 #line 3826 "cs-parser.jay"
   {
 	  	/* Shift/Reduce conflict*/
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
   	  }
   break;
 case 570
 #line 3831 "cs-parser.jay"
   {
 		yyVal = new As ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 571
 #line 3835 "cs-parser.jay"
   {
 		yyVal = new Is ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 573
 #line 3843 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LeftShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 574
 #line 3848 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.RightShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 576
 #line 3857 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 577
 #line 3862 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 578
 #line 3867 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 579
 #line 3872 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 581
 #line 3881 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Equality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 582
 #line 3886 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Inequality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 584
 #line 3895 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 586
 #line 3904 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.ExclusiveOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 588
 #line 3913 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 590
 #line 3922 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 592
 #line 3931 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 594
 #line 3940 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "null coalescing operator");
 			
 		yyVal = new Nullable.NullCoalescingOperator ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 596
 #line 3951 "cs-parser.jay"
   {
 		yyVal = new Conditional (new BooleanExpression ((Expression) yyVals[-4+yyTop]), (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 597
 #line 3959 "cs-parser.jay"
   {
 		yyVal = new SimpleAssign ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 598
 #line 3963 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Multiply, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 599
 #line 3968 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Division, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 600
 #line 3973 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Modulus, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 601
 #line 3978 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Addition, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 602
 #line 3983 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 603
 #line 3988 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.LeftShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 604
 #line 3993 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.RightShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 605
 #line 3998 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseAnd, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 606
 #line 4003 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 607
 #line 4008 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.ExclusiveOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 608
 #line 4016 "cs-parser.jay"
   {
 		var pars = new List<Parameter> (4);
 		pars.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = pars;
 	  }
   break;
 case 609
 #line 4023 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter)yyVals[0+yyTop];
 		if (pars[0].GetType () != p.GetType ()) {
 			Report.Error (748, p.Location, "All lambda parameters must be typed either explicitly or implicitly");
 		}
 		
 		pars.Add (p);
 		yyVal = pars;
 	  }
   break;
 case 610
 #line 4037 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], null, lt.Location);
 	  }
   break;
 case 611
 #line 4043 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, Parameter.Modifier.NONE, null, lt.Location);
 	  }
   break;
 case 612
 #line 4049 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ImplicitLambdaParameter (lt.Value, lt.Location);
 	  }
   break;
 case 613
 #line 4056 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 614
 #line 4057 "cs-parser.jay"
   { 
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 		yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 617
 #line 4069 "cs-parser.jay"
   {
 		start_block (lexer.Location);
 	  }
   break;
 case 618
 #line 4073 "cs-parser.jay"
   {
 		Block b = end_block (lexer.Location);
 		b.AddStatement (new ContextualReturn ((Expression) yyVals[0+yyTop]));
 		yyVal = b;
 	  }
   break;
 case 620
 #line 4083 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	
 		yyVal = EmptyExpression.Null;
 	  }
   break;
 case 621
 #line 4091 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
 		start_anonymous (true, new ParametersCompiled (p), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 622
 #line 4097 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 623
 #line 4102 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "lambda expressions");
 	  
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 624
 #line 4109 "cs-parser.jay"
   {
 	  	valid_param_mod = 0;
 		start_anonymous (true, (ParametersCompiled) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 625
 #line 4114 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 631
 #line 4130 "cs-parser.jay"
   {
 		yyVal = new ArglistAccess (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 633
 #line 4141 "cs-parser.jay"
   {
 		yyVal = new BooleanExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 634
 #line 4154 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 635
 #line 4158 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Class (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 636
 #line 4164 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 637
 #line 4176 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 638
 #line 4182 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 639
 #line 4190 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 640
 #line 4192 "cs-parser.jay"
   { yyVal = yyVals[0+yyTop]; }
   break;
 case 641
 #line 4197 "cs-parser.jay"
   {
 	    mod_locations = null;
 		yyVal = ModifierNone;
 	  }
   break;
 case 644
 #line 4207 "cs-parser.jay"
   { 
 		var m1 = (Modifiers) yyVals[-1+yyTop];
 		var m2 = (Modifiers) yyVals[0+yyTop];
 
 		if ((m1 & m2) != 0) {
 			Report.Error (1004, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"Duplicate `{0}' modifier", ModifiersExtensions.Name (m2));
 		} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
 			((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
 			Report.Error (107, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"More than one protection modifier specified");
 		}
 		
 		yyVal = m1 | m2;
 	  }
   break;
 case 645
 #line 4226 "cs-parser.jay"
   {
 		yyVal = Modifiers.NEW;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		
 		if (current_container == RootContext.ToplevelTypes)
 			Report.Error (1530, GetLocation (yyVals[0+yyTop]), "Keyword `new' is not allowed on namespace elements");
 	  }
   break;
 case 646
 #line 4234 "cs-parser.jay"
   {
 		yyVal = Modifiers.PUBLIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 647
 #line 4239 "cs-parser.jay"
   {
 		yyVal = Modifiers.PROTECTED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 648
 #line 4244 "cs-parser.jay"
   {
 		yyVal = Modifiers.INTERNAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 649
 #line 4249 "cs-parser.jay"
   {
 		yyVal = Modifiers.PRIVATE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 650
 #line 4254 "cs-parser.jay"
   {
 		yyVal = Modifiers.ABSTRACT;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 651
 #line 4259 "cs-parser.jay"
   {
 		yyVal = Modifiers.SEALED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 652
 #line 4264 "cs-parser.jay"
   {
 		yyVal = Modifiers.STATIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 653
 #line 4269 "cs-parser.jay"
   {
 		yyVal = Modifiers.READONLY;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 654
 #line 4274 "cs-parser.jay"
   {
 		yyVal = Modifiers.VIRTUAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 655
 #line 4279 "cs-parser.jay"
   {
 		yyVal = Modifiers.OVERRIDE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 656
 #line 4284 "cs-parser.jay"
   {
 		yyVal = Modifiers.EXTERN;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 657
 #line 4289 "cs-parser.jay"
   {
 		yyVal = Modifiers.VOLATILE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 658
 #line 4294 "cs-parser.jay"
   {
 		yyVal = Modifiers.UNSAFE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 659
 #line 4301 "cs-parser.jay"
   {
 		yyVal = Modifiers.ASYNC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 661
 #line 4310 "cs-parser.jay"
   {
 		current_container.AddBasesForPart (current_class, (List<FullNamedExpression>) yyVals[0+yyTop]);
 	 }
   break;
 case 663
 #line 4318 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 664
 #line 4322 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	 }
   break;
 case 665
 #line 4330 "cs-parser.jay"
   {
 		var constraints = new List<Constraints> (1);
 		constraints.Add ((Constraints) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 666
 #line 4336 "cs-parser.jay"
   {
 		var constraints = (List<Constraints>) yyVals[-1+yyTop];
 		Constraints new_constraint = (Constraints)yyVals[0+yyTop];
 
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 
 		constraints.Add (new_constraint);
 		yyVal = constraints;
 	  }
   break;
 case 667
 #line 4355 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 668
 #line 4363 "cs-parser.jay"
   {
 		var constraints = new List<FullNamedExpression> (1);
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 669
 #line 4369 "cs-parser.jay"
   {
 		var constraints = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
 		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
 			Report.Error (401, GetLocation (yyVals[-1+yyTop]), "The `new()' constraint must be the last constraint specified");
 		}
 		
 		prev = yyVals[0+yyTop] as SpecialContraintExpr;
 		if (prev != null) {
 			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
 				Report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
 			} else {
 			 	prev = constraints [0] as SpecialContraintExpr;
 			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
 					Report.Error (451, GetLocation (yyVals[0+yyTop]), "The `new()' constraint cannot be used with the `struct' constraint");
 				}
 			}
 		}
 
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 670
 #line 4395 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast)
 			Report.Error (706, GetLocation (yyVals[0+yyTop]), "Invalid constraint type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 	  
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 671
 #line 4402 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 672
 #line 4407 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 673
 #line 4411 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 674
 #line 4418 "cs-parser.jay"
   {
 		yyVal = Variance.None;
 	  }
   break;
 case 675
 #line 4422 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (lexer.Location, "generic type variance");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 676
 #line 4432 "cs-parser.jay"
   {
 		yyVal = Variance.Covariant;
 	  }
   break;
 case 677
 #line 4436 "cs-parser.jay"
   {
 		yyVal = Variance.Contravariant;
 	  }
   break;
 case 678
 #line 4456 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 679
 #line 4461 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 680
 #line 4468 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 681
 #line 4473 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (lexer.Location);
 	  }
   break;
 case 682
 #line 4482 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		current_block.StartLocation = GetLocation (yyVals[0+yyTop]);
 	  }
   break;
 case 683
 #line 4487 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 688
 #line 4505 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 689
 #line 4509 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 691
 #line 4514 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 694
 #line 4533 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 695
 #line 4537 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 724
 #line 4578 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 725
 #line 4583 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 726
 #line 4588 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 727
 #line 4596 "cs-parser.jay"
   {
 		/* Uses lexer.Location because semicolon location is not kept in quick mode*/
 		yyVal = new EmptyStatement (lexer.Location);
 	  }
   break;
 case 728
 #line 4604 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
 
 		current_block.AddLabel (labeled);
 		current_block.AddStatement (labeled);
 	  }
   break;
 case 731
 #line 4617 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] is VarExpr)
 			yyVals[-1+yyTop] = new SimpleName ("var", ((VarExpr) yyVals[-1+yyTop]).Location);
 	  
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 732
 #line 4633 "cs-parser.jay"
   { 
 		/* Ok, the above "primary_expression" is there to get rid of*/
 		/* both reduce/reduce and shift/reduces in the grammar, it should*/
 		/* really just be "type_name".  If you use type_name, a reduce/reduce*/
 		/* creeps up.  If you use namespace_or_type_name (which is all we need*/
 		/* really) two shift/reduces appear.*/
 		/* */
 
 		/* So the super-trick is that primary_expression*/
 		/* can only be either a SimpleName or a MemberAccess. */
 		/* The MemberAccess case arises when you have a fully qualified type-name like 
 		/* Foo.Bar.Blah i;*/
 		/* SimpleName is when you have*/
 		/* Blah i;*/
 		
 		Expression expr = (Expression) yyVals[-1+yyTop];
 		if (yyVals[0+yyTop] == null) {
 			SimpleName sn = expr as SimpleName;
 			if (sn != null && sn.Name == "var")
 				yyVal = new VarExpr (sn.Location);
 			else
 				yyVal = yyVals[-1+yyTop];
 		} else if (expr is ATypeNameExpression) {
 			yyVal = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName (expr);
 			yyVal = null;
 		}
 	  }
   break;
 case 733
 #line 4663 "cs-parser.jay"
   {
 		ATypeNameExpression expr = yyVals[-1+yyTop] as ATypeNameExpression;
 
 		if (expr != null) {
 			yyVal = new ComposedCast (expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName ((Expression)yyVals[-1+yyTop]);
 			yyVal = expr;
 		}
 	  }
   break;
 case 734
 #line 4674 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] == null)
 			yyVal = yyVals[-1+yyTop];
 		else
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 735
 #line 4681 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 736
 #line 4685 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 737
 #line 4689 "cs-parser.jay"
   {
 		Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 739
 #line 4698 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 740
 #line 4706 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreatePointer (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 741
 #line 4713 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 742
 #line 4720 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 743
 #line 4726 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockConstantDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 744
 #line 4733 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 746
 #line 4743 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		/* TODO
 	  }
   break;
 case 747
 #line 4748 "cs-parser.jay"
   {
 	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
 			Report.Error (650, lexer.Location,
 				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 	  }
   break;
 case 752
 #line 4770 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, null);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 753
 #line 4779 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 754
 #line 4791 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 	  }
   break;
 case 755
 #line 4795 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 760
 #line 4812 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 762
 #line 4825 "cs-parser.jay"
   {
 		yyVal = new StackAlloc ((Expression) yyVals[-3+yyTop], (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 763
 #line 4830 "cs-parser.jay"
   {
 		Report.Error (1575, GetLocation (yyVals[-1+yyTop]), "A stackalloc expression requires [] after type");
 		yyVal = new StackAlloc ((Expression) yyVals[0+yyTop], null, GetLocation (yyVals[-1+yyTop]));		
 	  }
   break;
 case 764
 #line 4838 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 765
 #line 4842 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 766
 #line 4846 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 767
 #line 4847 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 768
 #line 4856 "cs-parser.jay"
   {
 		ExpressionStatement s = yyVals[0+yyTop] as ExpressionStatement;
 		if (s == null) {
 			Expression.Error_InvalidExpressionStatement (Report, GetLocation (yyVals[0+yyTop]));
 			s = EmptyExpressionStatement.Instance;
 		}
 
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 769
 #line 4869 "cs-parser.jay"
   {
 		Expression expr = (Expression) yyVals[0+yyTop];
 		ExpressionStatement s;
 
 	        s = new OptionalAssign (new SimpleName ("$retval", lexer.Location), expr, lexer.Location);
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 770
 #line 4877 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 773
 #line 4891 "cs-parser.jay"
   { 
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 		
 		yyVal = new If ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 774
 #line 4900 "cs-parser.jay"
   {
 		yyVal = new If ((BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		
 		if (yyVals[-2+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[-2+yyTop]));
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 775
 #line 4913 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 776
 #line 4917 "cs-parser.jay"
   {
 		yyVal = new Switch ((Expression) yyVals[-5+yyTop], (ExplicitBlock) current_block.Explicit, (List<SwitchSection>) yyVals[-1+yyTop], GetLocation (yyVals[-7+yyTop]));	
 		end_block (GetLocation (yyVals[0+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 777
 #line 4926 "cs-parser.jay"
   {
 		Report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 779
 #line 4935 "cs-parser.jay"
   {
 		var sections = new List<SwitchSection> (4);
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 780
 #line 4942 "cs-parser.jay"
   {
 		var sections = (List<SwitchSection>) yyVals[-1+yyTop];
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 781
 #line 4949 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 782
 #line 4957 "cs-parser.jay"
   {
 		current_block = current_block.CreateSwitchBlock (lexer.Location);
 	  }
   break;
 case 783
 #line 4961 "cs-parser.jay"
   {
 		yyVal = new SwitchSection ((List<SwitchLabel>) yyVals[-2+yyTop], current_block);
 	  }
   break;
 case 784
 #line 4968 "cs-parser.jay"
   {
 		var labels = new List<SwitchLabel> (4);
 
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 		yyVal = labels;
 	  }
   break;
 case 785
 #line 4975 "cs-parser.jay"
   {
 		var labels = (List<SwitchLabel>) (yyVals[-1+yyTop]);
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 
 		yyVal = labels;
 	  }
   break;
 case 786
 #line 4985 "cs-parser.jay"
   {
 	 	yyVal = new SwitchLabel ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	 	lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	 }
   break;
 case 787
 #line 4990 "cs-parser.jay"
   {
 		yyVal = new SwitchLabel (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 792
 #line 5004 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new While ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 793
 #line 5016 "cs-parser.jay"
   {
 		yyVal = new Do ((Statement) yyVals[-5+yyTop], (BooleanExpression) yyVals[-2+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 794
 #line 5024 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 		current_block.IsCompilerGenerated = true;
 	  }
   break;
 case 795
 #line 5029 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 796
 #line 5040 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		For f = new For ((Statement) yyVals[-6+yyTop], (BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, current_block.StartLocation, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		yyVal = end_block (GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 797
 #line 5052 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = end_block (current_block.StartLocation);
 	  }
   break;
 case 798
 #line 5059 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 800
 #line 5065 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 801
 #line 5072 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 803
 #line 5080 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 805
 #line 5085 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 809
 #line 5096 "cs-parser.jay"
   {
 	  	var sl = yyVals[-2+yyTop] as StatementList;
 	  	if (sl == null) {
 	  		sl = new StatementList ((Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop]);
 			lbag.AddStatement (sl, GetLocation (yyVals[-1+yyTop]));
 	  	} else {
 	  		sl.Add ((Statement) yyVals[0+yyTop]);
 	  		lbag.AppendTo (sl, GetLocation (yyVals[-1+yyTop]));
 	  	}
 	  		
 		yyVal = sl;
 	  }
   break;
 case 810
 #line 5112 "cs-parser.jay"
   {
 		Report.Error (230, GetLocation (yyVals[-5+yyTop]), "Type and identifier are both required in a foreach statement");
 		yyVal = null;
 	  }
   break;
 case 811
 #line 5117 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-5+yyTop]));
 		current_block.IsCompilerGenerated = true;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.ForeachVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		yyVal = li;
 	  }
   break;
 case 812
 #line 5127 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Foreach f = new Foreach ((Expression) yyVals[-6+yyTop], (LocalVariable) yyVals[-1+yyTop], (Expression) yyVals[-3+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-8+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 819
 #line 5150 "cs-parser.jay"
   {
 		yyVal = new Break (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 820
 #line 5158 "cs-parser.jay"
   {
 		yyVal = new Continue (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 821
 #line 5166 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new Goto (lt.Value, lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 822
 #line 5172 "cs-parser.jay"
   {
 		yyVal = new GotoCase ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 823
 #line 5177 "cs-parser.jay"
   {
 		yyVal = new GotoDefault (GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 824
 #line 5185 "cs-parser.jay"
   {
 		yyVal = new Return ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 825
 #line 5193 "cs-parser.jay"
   {
 		yyVal = new Throw ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 826
 #line 5201 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (yyVals[-1+yyTop] == null) {
 			Report.Error (1627, GetLocation (yyVals[0+yyTop]), "Expression expected after yield return");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new Yield ((Expression) yyVals[-1+yyTop], lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 827
 #line 5217 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new YieldBreak (lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 830
 #line 5239 "cs-parser.jay"
   {
 		yyVal = new TryCatch ((Block) yyVals[-1+yyTop], (List<Catch>) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]), false);
 	  }
   break;
 case 831
 #line 5243 "cs-parser.jay"
   {
 		yyVal = new TryFinally ((Statement) yyVals[-2+yyTop], (Block) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 832
 #line 5248 "cs-parser.jay"
   {
 		yyVal = new TryFinally (new TryCatch ((Block) yyVals[-3+yyTop], (List<Catch>) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]), true), (Block) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 833
 #line 5253 "cs-parser.jay"
   {
 		Report.Error (1524, GetLocation (yyVals[-2+yyTop]), "Expected catch or finally");
 		yyVal = null;
 	  }
   break;
 case 834
 #line 5261 "cs-parser.jay"
   {
 		var l = new List<Catch> (2);
 
 		l.Add ((Catch) yyVals[0+yyTop]);
 		yyVal = l;
 	  }
   break;
 case 835
 #line 5268 "cs-parser.jay"
   {
 		var l = (List<Catch>) yyVals[-1+yyTop];
 		
 		Catch c = (Catch) yyVals[0+yyTop];
 		if (l [0].IsGeneral) {
 			Report.Error (1017, c.loc, "Try statement already has an empty catch block");
 		} else {
 			if (c.IsGeneral)
 				l.Insert (0, c);
 			else
 				l.Add (c);
 		}
 		
 		yyVal = l;
 	  }
   break;
 case 838
 #line 5292 "cs-parser.jay"
   {
 		yyVal = new Catch ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 839
 #line 5296 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-3+yyTop]));
 		var c = new Catch (current_block, GetLocation (yyVals[-4+yyTop]));
 		c.TypeExpression = (FullNamedExpression) yyVals[-2+yyTop];
 
 		if (yyVals[-1+yyTop] != null) {
 			var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
 			current_block.AddLocalName (c.Variable);
 		}
 		
 		lbag.AddLocation (c, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 840
 #line 5311 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 841
 #line 5315 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_PARENS) {
 			Report.Error (1015, lexer.Location,
 				"A type that derives from `System.Exception', `object', or `string' expected");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 		
 		yyVal = new Catch (null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 842
 #line 5329 "cs-parser.jay"
   {
 		yyVal = new Checked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 843
 #line 5336 "cs-parser.jay"
   {
 		yyVal = new Unchecked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 844
 #line 5343 "cs-parser.jay"
   {
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 845
 #line 5346 "cs-parser.jay"
   {
 		yyVal = new Unsafe ((Block) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 846
 #line 5353 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new Lock ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 847
 #line 5364 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.FixedVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Fixed.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 848
 #line 5373 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 849
 #line 5378 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Fixed f = new Fixed ((Fixed.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 850
 #line 5390 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.UsingVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Using.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 851
 #line 5399 "cs-parser.jay"
   {
 		yyVal = current_variable;	  
 		current_variable = null;
 	  }
   break;
 case 852
 #line 5404 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Using.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (u);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 853
 #line 5413 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (u, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = u;
 	  }
   break;
 case 854
 #line 5425 "cs-parser.jay"
   {
 		Report.Error (210, lexer.Location, "You must provide an initializer in a fixed or using statement declaration");
 	  }
   break;
 case 855
 #line 5429 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		yyVal = current_variable;
 	  }
   break;
 case 856
 #line 5440 "cs-parser.jay"
   {
 		lexer.query_parsing = false;
 			
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 857
 #line 5452 "cs-parser.jay"
   {
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 858
 #line 5463 "cs-parser.jay"
   {
 	        lexer.query_parsing = false;
 		yyVal = yyVals[-1+yyTop];
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 859
 #line 5470 "cs-parser.jay"
   {
 	        yyVal = yyVals[-1+yyTop];
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 860
 #line 5479 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 861
 #line 5487 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 862
 #line 5502 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 863
 #line 5510 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 864
 #line 5525 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 865
 #line 5529 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 866
 #line 5540 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 867
 #line 5544 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop])) {
 			IdentifierType = (FullNamedExpression)yyVals[-4+yyTop]
 		};
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 868
 #line 5561 "cs-parser.jay"
   {
 	  	Linq.AQueryClause head = (Linq.AQueryClause)yyVals[-1+yyTop];
 		
 		if (yyVals[0+yyTop] != null)
 			head.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 				
 		if (yyVals[-2+yyTop] != null) {
 			Linq.AQueryClause clause = (Linq.AQueryClause)yyVals[-2+yyTop];
 			clause.Tail.Next = head;
 			head = clause;
 		}
 		
 		yyVal = head;
 	  }
   break;
 case 870
 #line 5577 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 871
 #line 5585 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 872
 #line 5589 "cs-parser.jay"
   {
 		yyVal = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 873
 #line 5596 "cs-parser.jay"
   {
 	  	if (linq_clause_blocks == null)
 	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
 	  }
   break;
 case 874
 #line 5604 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 875
 #line 5611 "cs-parser.jay"
   {
 		yyVal = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)yyVals[-3+yyTop], linq_clause_blocks.Pop (), (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 879
 #line 5627 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-1+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 885
 #line 5643 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 886
 #line 5647 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 	  	yyVal = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  	
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 887
 #line 5661 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 888
 #line 5665 "cs-parser.jay"
   {
 		yyVal = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 889
 #line 5675 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 890
 #line 5683 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 891
 #line 5691 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 892
 #line 5699 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];	
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-11+yyTop]));
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 			
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location);
 
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-11+yyTop]));	
 		}
 
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);
 	  }
   break;
 case 893
 #line 5735 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 894
 #line 5743 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 895
 #line 5751 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 896
 #line 5759 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;		
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 		
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location); /* TODO
 			
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};			
 		}
 		
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
 	  }
   break;
 case 898
 #line 5803 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 899
 #line 5810 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 900
 #line 5814 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 902
 #line 5825 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 903
 #line 5832 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	  }
   break;
 case 905
 #line 5841 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, (Linq.QueryBlock) current_block, lexer.Location);	 
 	 }
   break;
 case 906
 #line 5848 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	 }
   break;
 case 907
 #line 5856 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 908
 #line 5860 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 909
 #line 5864 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 910
 #line 5871 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 911
 #line 5875 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 912
 #line 5879 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 914
 #line 5888 "cs-parser.jay"
   {
 		/* query continuation block is not linked with query block but with block*/
 		/* before. This means each query can use same range variable names for*/
 		/* different identifiers.*/
 
 		current_block.SetEndLocation (GetLocation (yyVals[-1+yyTop]));
 		current_block = current_block.Parent;
 	
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
 	  }
   break;
 case 915
 #line 5904 "cs-parser.jay"
   {
 		var current_block = linq_clause_blocks.Pop ();	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
   		yyVal = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation (yyVals[-3+yyTop])) {
   			next = (Linq.AQueryClause)yyVals[0+yyTop]
   		};
 	  }
   break;
 case 918
 #line 5930 "cs-parser.jay"
   { 
 	        Evaluator.LoadAliases (current_namespace);
 
 		push_current_class (new Class (current_namespace, current_class, new MemberName ("Class" + class_count++),
 			Modifiers.PUBLIC, null), null);
 
 		var baseclass_list = new List<FullNamedExpression> ();
 		baseclass_list.Add (new TypeExpression (Evaluator.InteractiveBaseClass, lexer.Location));
 		current_container.AddBasesForPart (current_class, baseclass_list);
 
 		/* (ref object retval)*/
 		Parameter [] mpar = new Parameter [1];
 		mpar [0] = new Parameter (new TypeExpression (TypeManager.object_type, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);
 
 		ParametersCompiled pars = new ParametersCompiled (mpar);
 		current_local_parameters = pars;
 		Method method = new Method (
 			current_class,
 			null, /* generic*/
 			new TypeExpression (TypeManager.void_type, Location.Null),
 			Modifiers.PUBLIC | Modifiers.STATIC,
 			new MemberName ("Host"),
 			pars,
 			null /* attributes */);
 
 		oob_stack.Push (method);
 	        ++lexer.parsing_block;
 		start_block (lexer.Location);
 	  }
   break;
 case 919
 #line 5960 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		Method method = (Method) oob_stack.Pop ();
 
 		method.Block = (ToplevelBlock) end_block(lexer.Location);
 		current_container.AddMethod (method);
 
 		--lexer.parsing_declaration;
 		InteractiveResult = pop_current_class ();
 		current_local_parameters = null;
 	  }
   break;
 case 920
 #line 5971 "cs-parser.jay"
   {
 	        Evaluator.LoadAliases (current_namespace);
 	  }
   break;
 #line default
         }
         yyTop -= yyLen[yyN];
         yyState = yyStates[yyTop];
         int yyM = yyLhs[yyN];
         if (yyState == 0 && yyM == 0) {
           if (debug != null) debug.shift(0, yyFinal);
           yyState = yyFinal;
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
                debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
           }
           if (yyToken == 0) {
             if (debug != null) debug.accept(yyVal);
             return yyVal;
           }
           goto continue_yyLoop;
         }
         if (((yyN = yyGindex[yyM]) != 0) && ((yyN += yyState) >= 0)
             && (yyN < yyTable.Length) && (yyCheck[yyN] == yyState))
           yyState = yyTable[yyN];
         else
           yyState = yyDgoto[yyM];
         if (debug != null) debug.shift(yyStates[yyTop], yyState);
 	 goto continue_yyLoop;
       continue_yyDiscarded
       }
     continue_yyLoop
     }
   }
 
    static  short [] yyLhs  = {              -1,
     0,    0,    0,    0,    5,    0,    2,    2,    1,    1,
     6,    6,    6,   10,   10,    7,    7,   11,   11,    8,
     8,   12,   12,   13,   20,   16,   18,   18,   18,   21,
    21,   22,   22,   15,   24,   19,   25,   25,   23,   23,
    26,   26,   27,   27,    9,    9,    9,   28,   28,   28,
    28,   28,    3,   17,   17,   34,   34,   35,   35,   36,
    38,   38,   38,   38,   37,   37,   42,   39,   40,   41,
    41,   43,   43,   43,   43,   43,   44,   44,   48,   45,
    47,   49,   49,   49,   50,   50,   51,   51,   52,   52,
    52,   52,   52,   52,   52,   52,   52,   52,   52,   65,
    67,   70,   71,   30,   30,   73,   69,   72,   72,   74,
    74,   75,   75,   75,   75,   75,   75,   75,   75,   75,
    75,   78,   53,   79,   79,   80,   80,   81,   83,   77,
    77,   82,   82,   88,   54,   92,   54,   54,   87,   95,
    87,   89,   89,   96,   96,   97,   98,   97,   93,   93,
    99,   99,  100,  101,   91,   91,   94,   94,   94,  104,
    55,  107,  108,  102,  109,  110,  102,  102,  103,  103,
   106,  106,  113,  113,  113,  113,  113,  113,  113,  113,
   113,  113,  114,  114,  117,  117,  117,  120,  117,  118,
   118,  121,  121,  122,  122,  122,  115,  115,  115,  123,
   123,  123,  116,  125,  127,  128,   56,  130,  131,  132,
    58,  126,  126,  126,  126,  126,  136,  133,  137,  134,
   135,  135,  135,  138,  139,  140,  142,   31,   31,  141,
   141,  143,  143,  144,  144,  144,  144,  144,  144,  144,
   144,  144,  147,   59,  146,  146,  148,  148,  151,  145,
   145,  150,  150,  150,  150,  150,  150,  150,  150,  150,
   150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
   150,  150,  150,  153,  152,  154,  152,  152,  152,   60,
   157,  159,  155,  156,  156,  158,  158,  163,  161,  164,
   161,  161,  165,   61,  167,   57,  170,  171,   57,  166,
   173,  166,  168,  168,  174,  174,  175,  176,  175,  177,
   172,  169,  169,  169,  169,  169,  181,  178,  182,  179,
   180,  180,  184,  186,  187,   32,  183,  183,  183,  185,
   185,  185,  188,  188,  189,  190,  189,  191,  192,  193,
    33,  194,  194,   14,   14,  195,  195,  198,  197,  197,
   197,  199,  199,  201,   64,  124,  105,  105,  129,  129,
   202,  202,  202,  200,  200,  203,  203,  204,  204,  206,
   206,   86,   76,   76,   90,   90,  119,  119,  149,  149,
   207,  207,  207,  207,  207,  211,  211,  212,  212,  210,
   210,  210,  210,  210,  210,  210,  213,  213,  213,  213,
   213,  213,  213,  213,  213,  214,  214,  214,  214,  214,
   214,  214,  214,  214,  214,  214,  214,  214,  214,  214,
   214,  214,  214,  214,  215,  215,  215,  216,  216,  216,
   235,  235,  236,  236,  237,  237,  218,  218,  234,  234,
   234,  234,  234,  234,  234,  234,  220,  238,  238,  239,
   239,  240,  240,  242,  242,  242,  243,  243,  243,  243,
   243,  244,  244,  162,  162,  248,  248,  248,  248,  248,
   250,  250,  249,  249,  251,  251,  251,  251,  252,  221,
   247,  247,  247,  253,  253,  254,  254,  222,  223,  223,
   224,  225,  226,  226,  217,  217,  217,  217,  217,  258,
   255,  227,  259,  259,  260,  260,  261,  261,  262,  262,
   262,  262,  256,  256,  208,  208,  263,  263,  264,  264,
   257,  257,   85,   85,  265,  265,  266,  228,  267,  267,
   267,  268,  268,  268,  268,  268,  269,  196,  229,  230,
   231,  232,  271,  233,  270,  270,  273,  272,  219,  274,
   274,  274,  274,  276,  275,  275,  275,  275,  275,  275,
   275,  277,  277,  277,  277,  278,  278,  278,  278,  278,
   278,  279,  279,  279,  280,  280,  280,  280,  280,  281,
   281,  281,  282,  282,  283,  283,  284,  284,  285,  285,
   286,  286,  287,  287,  288,  288,  289,  289,  289,  289,
   289,  289,  289,  289,  289,  289,  289,  290,  290,  291,
   291,  291,  292,  292,  293,  293,  296,  294,  295,  295,
   298,  297,  299,  300,  297,   46,   46,  245,  245,  245,
   245,   84,  302,  303,  304,  305,  306,   29,   63,   63,
    62,   62,  111,  111,  307,  307,  307,  307,  307,  307,
   307,  307,  307,  307,  307,  307,  307,  307,  307,   66,
    66,   68,   68,   68,  308,  308,  309,  310,  310,  311,
   311,  311,  311,  205,  205,  312,  312,  314,  112,  315,
   315,  316,  160,  313,  313,  317,  317,  318,  318,  318,
   318,  322,  322,  323,  323,  323,  320,  320,  320,  320,
   320,  320,  320,  320,  320,  320,  320,  320,  320,  324,
   324,  324,  324,  324,  324,  324,  324,  324,  324,  324,
   324,  324,  338,  338,  338,  338,  325,  339,  321,  340,
   340,  341,  341,  341,  341,  341,  341,  209,  209,  342,
   344,  319,  347,  319,  343,  343,  343,  345,  345,  350,
   350,  351,  351,  346,  346,  348,  348,  352,  352,  353,
   349,  349,  349,  326,  326,  337,  337,  354,  355,  355,
   327,  327,  356,  356,  359,  357,  358,  358,  360,  360,
   360,  363,  361,  362,  362,  364,  364,  328,  328,  328,
   328,  365,  366,  370,  367,  369,  369,  371,  371,  375,
   374,  374,  372,  372,  373,  373,  377,  376,  376,  368,
   378,  368,  329,  329,  329,  329,  329,  329,  379,  380,
   381,  381,  381,  382,  383,  384,  384,  385,  385,  330,
   330,  330,  330,  386,  386,  388,  388,  387,  389,  387,
   387,  331,  332,  390,  335,  333,  392,  393,  336,  394,
   395,  334,  334,  391,  391,  301,  301,  301,  301,  396,
   396,  398,  398,  400,  399,  401,  399,  397,  397,  397,
   405,  403,  406,  407,  403,  402,  402,  408,  408,  409,
   409,  409,  409,  409,  414,  410,  415,  411,  416,  417,
   418,  412,  420,  421,  422,  412,  419,  419,  424,  413,
   423,  427,  423,  426,  429,  426,  425,  425,  425,  428,
   428,  428,  404,  430,  404,    4,    4,  431,    4,  433,
     4,  432,  432,  432,  432,  246,  246,  241,  241,
   };
    static  short [] yyLen = {           2,
     2,    3,    2,    1,    0,    3,    0,    1,    1,    2,
     1,    1,    1,    1,    2,    4,    2,    1,    2,    1,
     1,    5,    2,    3,    0,    6,    1,    3,    1,    0,
     1,    0,    1,    1,    0,    6,    0,    1,    0,    1,
     0,    1,    1,    2,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    0,    1,    1,    2,    5,    4,    2,
     1,    1,    1,    1,    1,    3,    0,    3,    1,    0,
     3,    0,    1,    1,    3,    3,    1,    1,    0,    4,
     4,    0,    1,    1,    0,    1,    1,    2,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    0,
     0,    0,    0,   13,    5,    0,    4,    0,    1,    1,
     2,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    0,    9,    0,    1,    1,    2,    3,    0,    3,
     1,    1,    1,    0,    8,    0,    9,    6,    0,    0,
     3,    0,    1,    1,    2,    2,    0,    5,    0,    1,
     1,    2,    3,    0,    4,    2,    1,    1,    1,    0,
     3,    0,    0,   10,    0,    0,   11,    8,    1,    1,
     0,    1,    1,    3,    3,    3,    5,    3,    5,    1,
     1,    1,    1,    3,    4,    6,    4,    0,    7,    0,
     1,    1,    2,    1,    1,    1,    4,    6,    4,    1,
     2,    2,    1,    0,    0,    0,   10,    0,    0,    0,
    13,    1,    2,    1,    2,    1,    0,    5,    0,    5,
     1,    1,    1,    0,    0,    0,    0,   15,    5,    0,
     1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    0,    5,    1,    1,    1,    1,    0,    7,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    0,    7,    0,    7,    2,    2,    2,
     0,    0,    9,    1,    1,    0,    1,    0,    6,    0,
     6,    1,    0,    8,    0,    9,    0,    0,   10,    0,
     0,    3,    0,    1,    1,    2,    2,    0,    5,    0,
     2,    2,    2,    1,    1,    1,    0,    5,    0,    5,
     1,    1,    0,    0,    0,   12,    0,    2,    2,    0,
     1,    2,    1,    3,    2,    0,    5,    0,    0,    0,
    13,    0,    1,    1,    3,    1,    4,    2,    0,    3,
     2,    1,    3,    0,    3,    1,    1,    3,    1,    2,
     3,    4,    4,    0,    3,    1,    3,    3,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
     2,    2,    2,    2,    2,    1,    3,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    2,    2,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    3,    3,    4,    4,
     4,    3,    3,    4,    3,    4,    4,    0,    1,    3,
     4,    0,    1,    1,    3,    2,    3,    1,    2,    3,
     2,    1,    1,    0,    1,    1,    3,    3,    2,    2,
     1,    1,    1,    1,    2,    2,    4,    3,    1,    4,
     1,    3,    2,    1,    3,    1,    1,    1,    4,    3,
     2,    2,    6,    3,    7,    4,    3,    7,    3,    0,
     2,    4,    1,    2,    0,    1,    1,    3,    3,    1,
     1,    1,    0,    1,    1,    2,    2,    3,    1,    2,
     0,    1,    2,    4,    1,    3,    0,    5,    1,    1,
     1,    2,    3,    3,    4,    4,    1,    2,    4,    4,
     4,    3,    0,    4,    0,    1,    0,    4,    4,    1,
     2,    2,    1,    4,    1,    2,    2,    2,    2,    2,
     2,    1,    3,    3,    3,    1,    3,    3,    3,    3,
     3,    1,    3,    3,    1,    3,    3,    3,    3,    1,
     3,    3,    1,    3,    1,    3,    1,    3,    1,    3,
     1,    3,    1,    3,    1,    5,    3,    3,    3,    3,
     3,    3,    3,    3,    3,    3,    3,    1,    3,    3,
     2,    1,    0,    1,    1,    1,    0,    2,    1,    1,
     0,    4,    0,    0,    7,    1,    1,    1,    1,    1,
     1,    1,    1,    0,    0,    0,    0,   15,    0,    1,
     0,    1,    1,    2,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    0,
     2,    0,    1,    1,    1,    2,    4,    1,    3,    1,
     3,    1,    1,    0,    1,    1,    1,    0,    4,    1,
     1,    0,    4,    0,    1,    1,    2,    1,    1,    1,
     1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    0,    4,    1,
     2,    2,    2,    2,    2,    2,    1,    1,    2,    1,
     0,    6,    0,    7,    0,    2,    1,    0,    1,    1,
     2,    2,    4,    0,    2,    0,    1,    1,    2,    4,
     1,    5,    2,    2,    2,    2,    2,    1,    1,    1,
     1,    1,    5,    7,    0,    8,    0,    1,    1,    2,
     1,    0,    3,    1,    2,    3,    1,    1,    1,    1,
     1,    5,    7,    0,    4,    7,    1,    0,    1,    0,
     5,    1,    0,    1,    0,    1,    1,    1,    3,    6,
     0,    9,    1,    1,    1,    1,    1,    1,    2,    2,
     3,    4,    3,    3,    3,    4,    3,    0,    1,    3,
     4,    5,    3,    1,    2,    0,    1,    2,    0,    7,
     3,    2,    2,    0,    3,    5,    0,    0,   10,    0,
     0,   10,    5,    0,    2,    2,    2,    2,    2,    4,
     5,    4,    5,    0,    5,    0,    6,    3,    2,    1,
     0,    3,    0,    0,    6,    0,    1,    1,    2,    1,
     1,    1,    1,    1,    0,    5,    0,    3,    0,    0,
     0,   12,    0,    0,    0,   13,    0,    2,    0,    3,
     1,    0,    4,    1,    0,    4,    1,    2,    2,    1,
     2,    2,    0,    0,    4,    2,    3,    0,    4,    0,
     3,    1,    2,    1,    0,    0,    1,    1,    1,
   };
    static  short [] yyDefRed = {            0,
    47,    8,    0,    0,    0,    0,  920,    0,    0,    0,
     4,    0,    5,    9,   11,   12,   13,   20,   21,   46,
     0,   45,   48,   49,   50,   51,   52,    0,   56,   23,
     0,    0,    0,  344,    0,  346,   17,    0,   64,   62,
    63,    0,    0,    0,    0,    0,   65,   67,  916,    0,
     0,   18,    0,    1,    0,   10,    3,    0,  650,  656,
   648,    0,  645,  655,  649,  647,  646,  653,  651,  652,
   658,  654,  657,  659,    0,    0,  643,   57,    0,  538,
     0,  348,    0,   24,    0,    0,    0,    0,    0,    0,
    60,    0,  770,    0,  392,    0,  398,  405,    0,    0,
     0,  393,    0,    0,    0,  395,  432,    0,  394,    0,
     0,    0,    0,  401,    0,  403,    0,  430,  390,    0,
   397,  399,    0,  391,    0,  488,    0,  431,    0,  527,
   402,  404,    0,  844,  400,    0,    0,    0,  631,    0,
     0,  678,    0,  727,    0,    0,    0,    0,    0,    0,
     0,    0,  429,    0,  623,    0,  769,  710,    0,    0,
   396,    0,    0,  407,  408,    0,  410,  411,  412,  413,
   414,  415,  416,  417,  418,  419,  420,  421,  422,  423,
   424,  427,  428,  627,  555,    0,  553,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  628,  626,
   629,  630,  694,  696,    0,  692,  695,  711,  713,  714,
   715,  716,  717,  718,  719,  720,  721,  722,  712,    0,
     0,    0,  771,  772,  788,  789,  790,  791,  813,  814,
   815,  816,  817,  818,    0,    0,    0,  924,  921,  927,
    19,  917,    2,    6,   29,   27,    0,    0,    0,  640,
     0,  644,    0,  351,    0,    0,  352,  373,    0,    0,
     0,    0,  345,   16,    0,   66,   59,    0,   68,    0,
     0,    0,  819,  433,  434,  842,    0,    0,    0,    0,
     0,  409,    0,  820,    0,  547,  543,  546,  726,  768,
   697,  724,  723,  725,  698,  699,  700,  701,  702,  703,
   704,  705,  706,  707,  708,  709,    0,    0,    0,  794,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  829,    0,  406,    0,    0,    0,    0,
     0,    0,  843,    0,    0,    0,  740,  736,    0,    0,
     0,    0,    0,    0,    0,    0,  552,  556,  557,  551,
   561,  560,  558,  559,    0,    0,  621,  728,  426,  425,
     0,    0,    0,  343,    0,  734,  735,    0,  491,  492,
     0,    0,    0,  732,  733,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  919,
   693,  741,  731,  766,  767,  870,  887,    0,    0,    0,
   899,  858,  856,  880,    0,    0,  878,  881,  882,  883,
   884,  859,  857,  923,    0,    0,    0,    0,  370,  372,
   354,    0,  634,    0,    0,   22,  385,  381,  382,    0,
   350,  380,  383,  384,  347,   58,    0,    0,   73,   74,
    77,   78,  490,    0,    0,  486,  487,    0,  484,    0,
   743,    0,    0,    0,    0,  764,  765,    0,    0,    0,
   632,    0,  823,  821,  633,    0,    0,  512,    0,    0,
     0,  503,    0,  507,  517,  519,    0,    0,  497,  499,
     0,    0,    0,    0,    0,  494,    0,  501,  375,  516,
   824,    0,    0,  825,  833,    0,    0,    0,  834,    0,
     0,  845,    0,    0,  739,    0,    0,    0,    0,    0,
   691,    0,    0,  686,  688,  689,  690,  437,  438,  827,
     0,    0,    0,  195,  194,  196,    0,    0,    0,    0,
   377,    0,  608,    0,    0,  442,    0,  445,    0,  443,
   542,    0,    0,    0,    0,    0,  471,  474,    0,    0,
   466,  473,  472,  562,    0,  597,  598,  599,  600,  601,
   602,  603,  604,  605,  607,  606,  563,  565,  564,  570,
   571,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  594,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  871,  873,  869,    0,
   879,   28,   35,    0,    0,    0,    0,  323,    0,  229,
     0,  105,    0,  353,    0,   79,   71,    0,  441,  489,
     0,  540,    0,  549,  182,  203,    0,    0,    0,  172,
     0,    0,    0,  183,  544,    0,  847,  797,    0,  808,
   795,    0,  799,    0,    0,    0,  822,    0,    0,    0,
   502,    0,  518,  520,  159,  523,  157,  158,  525,    0,
     0,    0,  458,    0,    0,  454,    0,    0,  481,    0,
   522,  496,    0,  539,    0,  838,    0,  831,    0,  835,
   531,    0,    0,    0,  529,    0,    0,  541,    0,  850,
     0,  862,    0,  860,    0,  680,  681,  679,  687,  826,
   616,  622,  615,    0,  729,  611,    0,    0,    0,  554,
   446,  440,  444,  439,  480,  479,  476,  475,    0,  470,
   435,  436,  447,    0,    0,  747,    0,    0,  888,  864,
     0,  889,    0,  885,    0,  900,    0,    0,    0,    0,
   868,    0,   31,   26,  338,    0,  355,  329,  328,    0,
   635,  225,  101,   84,   83,    0,    0,   75,   76,  485,
     0,    0,    0,    0,    0,  192,    0,  548,    0,    0,
     0,    0,    0,  800,    0,    0,    0,    0,    0,  846,
   509,  508,    0,    0,  461,    0,    0,  928,  929,  450,
   456,    0,  459,    0,  483,    0,    0,    0,  775,  841,
     0,  832,  537,  532,    0,    0,  528,    0,  853,    0,
   792,  863,  861,  620,  619,  618,  610,  609,  624,  478,
     0,  468,  467,  596,    0,  761,  746,    0,    0,    0,
   750,    0,  866,    0,  893,    0,  908,  909,  902,  872,
   874,  914,   14,    0,    0,    0,  369,    0,    0,  366,
   324,    0,    0,    0,   81,   80,  755,  132,  133,    0,
     0,    0,  758,  201,  202,    0,  193,    0,    0,    0,
   175,  184,  176,  178,    0,    0,    0,    0,  804,    0,
   809,  810,    0,    0,  526,  524,  460,  462,  463,  457,
   451,  455,    0,  514,    0,  482,  493,  449,    0,  837,
     0,    0,  533,    0,    0,    0,  477,    0,    0,  742,
   751,  865,    0,    0,    0,  886,    0,    0,    0,   15,
     0,    0,    0,  677,  676,    0,  675,    0,  365,    0,
     0,    0,    0,    0,    0,  744,  759,  187,    0,  199,
     0,    0,    0,  793,  855,    0,    0,    0,  811,  774,
   498,  495,  781,    0,  787,    0,    0,  779,    0,  784,
   839,  536,  535,    0,  625,    0,    0,  867,  890,    0,
     0,    0,  904,    0,  915,   43,    0,    0,  339,  368,
   367,    0,  325,    0,  333,  389,  388,    0,  386,  664,
     0,  636,    0,  665,  226,  102,    0,    0,  188,    0,
   179,  177,  848,  801,    0,    0,  806,    0,    0,  776,
   780,    0,  785,    0,  851,    0,  753,    0,  894,  911,
   912,  905,  875,   36,   44,    0,    0,    0,    0,    0,
     0,    0,  666,    0,    0,  760,  186,    0,  198,    0,
     0,  812,  786,    0,  682,  840,    0,  762,    0,    0,
     0,  340,    0,    0,  334,  387,    0,    0,    0,  106,
   103,  189,  849,  796,    0,  852,  891,    0,  906,    0,
     0,  326,  672,    0,  673,  670,    0,  668,   99,    0,
    98,    0,    0,   87,   89,   90,   91,   92,   93,   94,
    95,   96,   97,  160,    0,    0,  242,  234,  235,  236,
   237,  238,  239,  240,  241,    0,    0,  232,    0,    0,
     0,    0,  895,  341,  337,    0,    0,    0,  637,   88,
     0,  285,  280,  284,    0,  227,  233,  120,  112,  113,
   114,  115,  116,  117,  118,  119,  121,    0,    0,  110,
   104,  683,    0,    0,  671,  669,    0,    0,    0,    0,
     0,    0,    0,  293,    0,    0,  243,    0,    0,  251,
     0,  170,  161,  169,    0,  107,  111,    0,  892,    0,
     0,    0,  279,    0,    0,  278,    0,    0,    0,    0,
   359,    0,  357,    0,    0,  204,    0,    0,    0,    0,
     0,  638,  228,  898,  896,  122,    0,  356,    0,    0,
     0,    0,  136,    0,    0,    0,    0,    0,    0,  162,
     0,    0,  208,    0,  360,    0,  246,  245,  244,  257,
   256,  253,  258,  259,  252,  271,  270,  263,  264,  260,
   262,  261,  265,  254,  255,  266,  267,  273,  272,  268,
   269,    0,    0,  297,    0,  276,  138,    0,  274,  165,
     0,    0,  140,    0,  361,    0,    0,  205,    0,    0,
     0,  358,  249,  131,  129,    0,    0,  301,    0,    0,
     0,    0,    0,    0,    0,  282,    0,    0,    0,    0,
   144,    0,    0,    0,    0,  362,  363,    0,    0,    0,
     0,    0,  126,  316,    0,  298,    0,    0,  310,    0,
     0,    0,  305,    0,  156,    0,    0,    0,    0,  151,
     0,    0,  294,    0,  141,    0,  135,  145,  163,  168,
   216,    0,  206,    0,    0,    0,    0,  130,    0,  123,
   127,    0,    0,    0,  312,    0,  313,  302,    0,    0,
   296,  306,  277,    0,    0,  137,  152,  275,  166,  292,
     0,  283,  287,  147,    0,    0,    0,  213,  215,  209,
   250,  128,  317,  319,  299,    0,    0,  311,  308,  155,
   153,    0,    0,    0,    0,  164,  217,  219,  207,    0,
     0,    0,  310,  167,  288,  290,  148,    0,    0,  210,
   321,  322,  318,  320,  309,    0,    0,  223,  222,  221,
   218,  220,    0,    0,    0,  211,  289,  291,
   };
   protected static  short [] yyDgoto  = {             9,
    10,   11,   12,   13,   58,   14,   15,   16,   17,  864,
    53,   18,   19,  256,   33,   20,  647,  247,  624,  436,
  1411,   90,  865,  762,  942,  997,  998,   22,   23,   24,
    25,   26,   27,  648,   29,   44,   45,   46,   47,   48,
   269,   92,  458,  459,  460,  290,  568,  777,  776, 1102,
  1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112,
  1113,   75,  251, 1203,  633,  952,  874, 1012, 1081, 1055,
  1130, 1158, 1129, 1159, 1160, 1007, 1286, 1263, 1311, 1312,
  1313,  877, 1309,  878,  678, 1176, 1274, 1228, 1299,  508,
  1292, 1268, 1328,  846, 1297, 1300, 1301, 1395, 1329, 1330,
  1326, 1114, 1183, 1141, 1204,  649, 1276, 1375, 1294, 1392,
    76,  291,  650,  651,  652,  653,  654,  784,  549, 1058,
   785,  550,  787, 1206, 1232, 1343, 1304, 1377, 1207, 1279,
  1400, 1423, 1344, 1345, 1421, 1408, 1409,  631,  873, 1054,
  1126, 1185, 1127, 1128, 1177, 1239, 1210, 1178,  258, 1262,
  1308, 1180, 1293, 1290, 1115, 1143, 1200, 1372, 1334, 1066,
  1373,  569, 1416, 1417, 1199, 1289, 1265, 1321, 1316, 1287,
  1353, 1358, 1319, 1322, 1323, 1403, 1359, 1317, 1318, 1413,
  1401, 1402,  628,  770, 1003,  950, 1048, 1004, 1005, 1073,
   866, 1046, 1090,  448,   34,  159,   82,   36,  259,  767,
   626, 1220,  869,  870,  946,  440,  260,  319,  447,  325,
  1008, 1009,  161,  162,  326,  164,  165,  166,  167,  168,
   169,  170,  171,  172,  173,  174,  175,  176,  177,  178,
   179,  180,  181,  182,  183,  277,  743,  917,  506,  684,
   810,  685,  686,  910,  184,  242,  690,  570,  571,  572,
   573,  737,  468,  469,  320,  915,  692,  321,  491,  492,
   493,  494,  322,  497,  680,  332,  706,  707,  824,  287,
   474,  288,  473,  185,  186,  187,  188,  189,  190,  191,
   192,  193,  194,  195,  196,  197,  198,  199,  200,  552,
   553,  554,  722,  723,  836,  724,  201,  542,  361,  926,
   202,  486,  629,  872, 1052, 1181,   77, 1013, 1014, 1097,
  1098,  947,  532,  345,  718, 1085,  533,  534,  292,  293,
   294,  205,  206,  207,  295,  296,  297,  298,  299,  300,
   301,  302,  303,  304,  305,  306,  219,  307,  543,  220,
   221,  339,  748,  609,  849,  782,  643,  881,  847,  850,
   851,  882,  883,  308,  222,  223,  224,  976,  919,  977,
   978,  979, 1032,  980,  225,  226,  227,  228,  661,  479,
   662,  900, 1025,  663,  898,  664, 1027, 1028,  229,  230,
   231,  232,  233,  234,  327,  518,  519,  921, 1034,  335,
   897,  793, 1060,  830, 1067,  235,  423,  236,  424,  852,
   933,  425,  620,  761,  758,  759,  938,  426,  427,  428,
   429,  430,  431,  856,  610,  854, 1038, 1132, 1189,  935,
  1070, 1164,  756,  616,  757,  992,  937,  993, 1071,  939,
    50,  239,   51,
   };
   protected static  short [] yySindex = {         -105,
     0,    0, -211, -200, -208,   37,    0,   30,    0,   96,
     0,  131,    0,    0,    0,    0,    0,    0,    0,    0,
 11915,    0,    0,    0,    0,    0,    0,   63,    0,    0,
   336,   54,  130,    0,   94,    0,    0,  169,    0,    0,
     0,  339,   54,  177,  235,   93,    0,    0,    0, 6023,
   112,    0, -248,    0,  131,    0,    0,  131,    0,    0,
     0, -197,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,   90, 9038,    0,    0,  177,    0,
   959,    0,  281,    0,  209,  340,  339,  235,  177,  382,
     0,  404,    0,  306,    0,  413,    0,    0,  208,10545,
   488,    0, -245,  527, 6176,    0,    0, -245,    0, -245,
  -245, -102, -245,    0, -245,    0, -210,    0,    0, 9672,
     0,    0, -245,    0, -245,    0, 9672,    0,  509,    0,
     0,    0,  208,    0,    0, -245,  519, -245,    0, 6805,
  7264,    0, 9672,    0,10332,10332,10332,10332,10332,10332,
 10332,10332,    0, -139,    0, 7417,    0,    0,  494,  352,
     0,  391, -219,    0,    0,  544,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  781,    0,  694,   66,  260,
   539,  489,  568,  540,  572,  586, -250,  633,    0,    0,
     0,    0,    0,    0, 2339,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  621,
   688,  -32,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0, -203, -174,  112,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  689, 7570,  647,    0,
  -156,    0,  467,    0,  519,  394,    0,    0,   99,  688,
  -219,  209,    0,    0,  705,    0,    0, 9804,    0,  830,
   677, 9936,    0,    0,    0,    0, 9672, -245, -245,  100,
   391,    0,  684,    0, 7417,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  768,  173,10545,    0,
  7417, 9672,  739,  759, 9672, 9672, 7971,  398,  780,   44,
 11061,  688,  236,    0,  793,    0,  802, 7417, 9672,  806,
   436, -245,    0, 9672,  509, 9144,    0,    0,  519, 9672,
  -205,  782,  -29,  790, 6329, -251,    0,    0,    0,    0,
     0,    0,    0,    0,  839, 9672,    0,    0,    0,    0,
 10990,  850,  209,    0,  493,    0,    0,  501,    0,    0,
   811, 9936, 8880,    0,    0,10332, 9672, 9672, 9672, 9672,
  9672, 9672, 9672, 9672, 9672, 9672, 9672,10332,10332,10332,
  7417, 7417,10332,10332,10332,10332,10332,10332,10332,10332,
 10332,10332,10332,10332,10332,10332,10332,10332, 9672,    0,
     0,    0,    0,    0,    0,    0,    0,11115,11132,  823,
     0,    0,    0,    0,    6,  771,    0,    0,    0,    0,
     0,    0,    0,    0,  826,  860,  519,  647,    0,    0,
     0,  868,    0,  985,  988,    0,    0,    0,    0, 7417,
     0,    0,    0,    0,    0,    0,  317,  590,    0,    0,
     0,    0,    0,  209,  297,    0,    0,  435,    0,  878,
     0,  880, -152,  509, -245,    0,    0,  841, 7094, -229,
     0,  881,    0,    0,    0,  884,  888,    0,  469,    0,
   893,    0,  890,    0,    0,    0,  445, 6788,    0,    0,
  7817,  487, 9672,  780, 8880,    0,  519,    0,    0,    0,
     0,  894,  896,    0,    0,  208,  509,  384,    0, 3051,
   897,    0,  898,  854,    0,  902, 9672,  964, 9672,  977,
     0,   13, 6329,    0,    0,    0,    0,    0,    0,    0,
   904,  509, 6329,    0,    0,    0,  519,  339,  865,11186,
     0,  912,    0,  906,10332,    0,  -25,    0,  377,    0,
     0,  648, 9672, 9672,  917, 1029,    0,    0,  -46,  916,
     0,    0,    0,    0,  694,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  694,  694,   66,   66,  260,  260,  260,  260,  539,
   539,  489,  568,  540,  572,  586,    0,  920, -190, 9672,
    17,  873,   32,  883,  915, 9672,    0,    0,    0,  938,
     0,    0,    0,  923,  931,  889, 3206,    0,  647,    0,
   647,    0,  647,    0,   74,    0,    0, 9804,    0,    0,
  9936,    0,  922,    0,    0,    0,  565,   63,  933,    0,
   932,  934,  936,    0,    0, 9672,    0,    0,  895,    0,
     0,  935,    0,  940, 9672, 1009,    0, 6176, 6176, 7247,
     0, 7971,    0,    0,    0,    0,    0,    0,    0,  942,
  9276,  321,    0,   25, -170,    0,  891,  901,    0,  -22,
     0,    0,  945,    0,  951,    0, 3361,    0,  509,    0,
     0,  365,  495,  903,    0,  948,  939,    0, 6176,    0,
  6176,    0, 9672,    0, 9672,    0,    0,    0,    0,    0,
     0,    0,    0, 7400,    0,    0,  907,10990,  979,    0,
     0,    0,    0,    0,    0,    0,    0,    0, 8748,    0,
     0,    0,    0, 9012, 9672,    0, 6941,  953,    0,    0,
  1032,    0, 1033,    0,  -34,    0,  958, 9672, 9672,  918,
     0,  971,    0,    0,    0, -128,    0,    0,    0,  967,
     0,    0,    0,    0,    0, 9672, 9672,    0,    0,    0,
  9408,  961,  565,11186,  464,    0, 7417,    0,  244, 1077,
  1078,  968,  960,    0, 9672, 9672,  970, 9672, 1055,    0,
     0,    0, 7247,  975,    0, -145, 9540,    0,    0,    0,
     0, 7685,    0, 1084,    0,  688, 9672,  978,    0,    0,
   928,    0,    0,    0,  929,  120,    0,  930,    0,  960,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   676,    0,    0,    0,11061,    0,    0,  937,  976,  953,
     0, 9672,    0, 9672,    0, 9672,    0,    0,    0,    0,
     0,    0,    0,  971,   30, -152,    0,  515,  226,    0,
     0,  981,  981,  981,    0,    0,    0,    0,    0,  941,
   986,  961,    0,    0,    0, -187,    0, -186,  980,  989,
     0,    0,    0,    0,  990, 7247,  953, -190,    0,  994,
     0,    0,  992, 6176,    0,    0,    0,    0,    0,    0,
     0,    0,  983,    0,  780,    0,    0,    0, -192,    0,
   993,  120,    0,  954,  953,  509,    0,  955,  995,    0,
     0,    0, 9672, 1023, 9672,    0, 9672, 1024,  303,    0,
    30, -125, 1008,    0,    0,  963,    0, -128,    0,   63,
  3516, -162, -162, -162, 1001,    0,    0,    0,  505,    0,
  1002, 1124, 1125,    0,    0, 1014,  953, 9672,    0,    0,
     0,    0,    0, 9672,    0, 1019, -155,    0, -155,    0,
     0,    0,    0, 1017,    0, 9672, 6941,    0,    0, 1039,
   641, 1018,    0, 9672,    0,    0, 1025, -125,    0,    0,
     0,  973,    0, 1020,    0,    0,    0, 1022,    0,    0,
   982,    0, 1052,    0,    0,    0, 9408, 1027,    0, 9672,
     0,    0,    0,    0, 1026,  940,    0, 6176, 1028,    0,
     0, 6329,    0, 1035,    0, 1034,    0, 9672,    0,    0,
     0,    0,    0,    0,    0, -162,    0, 1031,   63, 3516,
  1036, 1040,    0, 1041, 1042,    0,    0, 9672,    0, 6176,
  6176,    0,    0, 6329,    0,    0, 6176,    0, 1054, 9672,
  9672,    0, 1053,  923,    0,    0,11044,   35,   63,    0,
     0,    0,    0,    0, 6329,    0,    0, 1058,    0, 1059,
  9672,    0,    0, 1045,    0,    0, 1038,    0,    0, 9038,
     0, 1049,   35,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  601, 9038,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1068,   63,    0,   63,  923,
  1069, 9672,    0,    0,    0, 1066,11044,10763,    0,    0,
   631,    0,    0,    0,10795,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0, 1071,   63,    0,
     0,    0, 1080, 9672,    0,    0, 7417, 7417, -121,11061,
   -87,  519, 1100,    0,  339, 6967,    0, 1133,    0,    0,
   923,    0,    0,    0,  923,    0,    0, 1030,    0, 1080,
  1037, 1043,    0, 7417, -181,    0, 7417, 1043, 1044, 1072,
     0,  339,    0, 1074,  481,    0, 1081, 1046,  -19,  634,
 10294,    0,    0,    0,    0,    0,  339,    0, 1079, 1050,
  1082, 1073,    0, 1085, 1086, 1087, -152, 1070, 1090,    0,
  1088, 1093,    0,  209,    0,  602,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0, 1096, -179,    0, 1089,    0,    0, 1083,    0,    0,
  1097, 1099,    0, 1098,    0, -152, -152,    0, -152, 1105,
  1108,    0,    0,    0,    0, 1116,   48,    0, 1117, -152,
  1232, 1119, -152, -152,  631,    0, 7247, 1092, 1126, 1098,
     0, 1123, 1131,   57, 1136,    0,    0, -152, 9408, 1101,
  1138, 1116,    0,    0, 9038,    0,   63,   63,    0, 1102,
  1139, 1117,    0, 1135,    0, 9672, 1103, 1140, 1119,    0,
  1145, 1146,    0, -163,    0, 1141,    0,    0,    0,    0,
     0, 9038,    0,   57,   57, 1157, 1158,    0, -179,    0,
     0,  313, 1161, 9038,    0, 9038,    0,    0, 7247, 1151,
     0,    0,    0, 1175, 1083,    0,    0,    0,    0,    0,
    85,    0,    0,    0, -162,  766, 1179,    0,    0,    0,
     0,    0,    0,    0,    0, 1229, 1284,    0,    0,    0,
     0, -162, 1181, 1184, 7247,    0,    0,    0,    0,   57,
   637,  637,    0,    0,    0,    0,    0,  -54,  -54,    0,
     0,    0,    0,    0,    0, 8880, 8880,    0,    0,    0,
     0,    0, 1188, 1185, 1186,    0,    0,    0,
   };
   protected static  short [] yyRindex = {         1956,
     0,    0,    0,    0,    0, 6482,    0,    0,    0, 1956,
     0, 1555,    0,    0,    0,    0,    0,    0,    0,    0,
   663,    0,    0,    0,    0,    0,    0, 1450,    0,    0,
   658, 1187,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  685,  609,    0, 1190,    0,    0,    0,    0,    0,
  1844,    0,   42,    0, 1555,    0,    0, 1555,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  443,10477,    0,    0,    0,    0,
     0,    0,    0,    0, 2178,    0, 3822, 1190, 1191,    0,
     0,  679,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, 1195,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,11203,    0,    0, 1189,
     0,    0,    0,    0,    0,    0, 1189,    0,    0,    0,
     0,    0,    0,    0,    0,    0,   -8,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, 5700,    0,    0,    0,    0,    0,  247,
     0, 3670, 5753,    0,    0, 3515,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 4004,    0, 4068, 4354, 4546,
  4920, 5112, 5240, 5368, 5496,  479, 3757, 3634,    0,    0,
     0,    0,    0,    0,   42,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  1148,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  797,  797, 1913,    0,    0,    0,
     0,    0,    0,    0,    0,    0, 1200,    0,    0,    0,
     0,    0,    0,    0, 3901, 2439,    0,    0,    0, 2816,
  2439, 2178,    0,    0,    0,    0,    0,  735,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0, 2660,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0, 1201,    0,    0,    0,
     0, 2019, 2660,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0, 2581,    0,
   212,    0,  212,    0,   27,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1189,    0,    0,    0,    0,
  1196,    0, 2660,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  146,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,   24,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,   -9,    0,    0,    0,
     0, 1203,    0, 1153, 1156,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0, 7951,    0,    0,    0,
     0,    0,    0, 2660, 5867,    0,    0,    0,    0,    0,
     0,    0,10845,    0,    0,    0,    0,    0, 1199,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  693,  725,
     0,    0, 1209,    0,    0,    0,    0,    0,    0,    0,
   137,    0,    0, 3205, 1206,    0,  188,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0, 1205,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  139,    0,    0,    0,    0,    0,    0,    0,
     0, 7553,    0,    0,    0,    0, -173,  498,    0,    0,
     0, 1207,    0,    0,    0,    0, 2660,    0, 2660,    0,
     0,    0,    0,    0, -256,    0,    0,    0,    0,  205,
     0,    0,    0,    0, 4147,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0, 4211, 4290, 4418, 4482, 4610, 4674, 4738, 4802, 4984,
  5048, 5176, 5304, 5432, 5560, 5624,    0,    0,  750,    0,
   212,    0,  212,    0,    0,    0,    0,    0,    0, 5688,
     0,    0,    0, 1354,    0,  264,    0,    0,    0,    0,
     0,    0,    0,    0,10068,    0,    0,    0,    0,    0,
     0,    0,  762,    0,    0,    0,11257, 8116,    0,    0,
   783,  795,  809,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, 1210,    0,    0,    0,    0,    0,    0,
     0, 1219,    0,    0,    0,    0,    0,    0,    0, 1220,
     0, 4839,    0,    0,  142,    0,    2, 2895,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  545,  702,    0,    0,    0, 1218,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, -244,    0,    0,    0, 1216,    0,    0,
     0,    0,    0,    0,  197,    0,  182,    0,    0,    0,
     0,11380,    0,    0,    0, -169,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0, 1217,11274,    0,11328,    0,    0,    0,10958,    0,
     0,    0,  769,    0, 1223,    0,    0,    0, 1590,    0,
     0,    0, 1227,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 3050,    0, 3360,    0,    0,
  1224,    0,    0,    0,    0,  545,    0,    0,    0,  769,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  696,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,11451,11522,10845,    0, 1182,    0,    0,
     0,  123,  123,  123,    0,    0,    0,    0,    0,    0,
     0, 1225,    0,    0,    0,    0,    0,    0,  825,  829,
     0,    0,    0,    0,    0,    0, 1230,  750,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0, 3205,    0,    0,    0, 1235,    0,
     0,  545,    0,  853, 1230, 7553,    0,  668,  715,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  133,    0,
 11593,11717,    0,    0,    0,    0,    0, -169,    0, -268,
     0, 1237, 1237, 1237,    0,    0,    0,    0,  772,    0,
   824,    0,    0,    0,    0,    0, 1216, 1233,    0,    0,
     0,    0,    0,    0,    0,    0, 1238,    0, 6635,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   333,  547,    0,    0,    0,    0,    0,11786,    0,    0,
     0,    0,    0, 1239,    0,    0,    0,  141,    0,    0,
     0,    0,  639,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1236,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1234,  610,    0,   11,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, -206,    0,    0,    0,    0,    0,    0,
     0,    0,    0, 1754,    0,    0,    0, 8225, 8521,    0,
     0,    0,    0,    0, 1241,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  318,    0,    0,10613,
     0,    0, 8299,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,10695,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0, 8595,    0, 8373, 1754,
     0,    0,    0,    0,    0,    0,    0,  443,    0,    0,
     0,    0,    0,    0,  443,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0, 8447,    0,
     0,    0,  584,    0,    0,    0,    0,    0,    0,    0,
     0,  645,  458,    0, 8639,    0,    0,    0, 2786,    0,
  1754,    0,    0,    0, 1754,    0,    0,    0,    0,  584,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  662,    0, 1245,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  787,    0,  591,    0,
     0,    0,    0,    0,    0,    0,10845,  837,    0,    0,
     0,    0,    0, 1240,    0,  730,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  838,    0,    0,    0,    0,    0,
     0,    0,    0, 1242,    0,10845,10845,    0,10885,    0,
     0,    0,    0,    0,    0, 1244,11875,    0, 1250,10845,
 10200, 1252,10845,10845,    0,    0,    0,    0,    0, 1253,
     0,    0,    0, 8669,    0,    0,    0,10845,    0,    0,
     0, 1255,    0,    0,  329,    0,11845, 8906,    0,    0,
     0, 1256,    0,    0,    0,    0,    0,    0, 1258,    0,
     0,    0,    0,  644,    0,  844,    0,    0,    0,    0,
     0,  867,    0, 5879, 8774,    0,    0,    0,    0,    0,
     0,    0,    0, 1297,    0, 1350,    0,    0,    0,  847,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  652,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  652,    0,    0,    0,    0,    0,    0,    0, 8669,
 11652, 7843,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1206, 1206,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,
   };
   protected static  short [] yyGindex = {            0,
  1566,  608,   58,    0,    0,   40, -681,    4, -355,    0,
   767,    0,    0,   19,    0,    0,    1,    0,    0,    0,
  -601,  -70,    0,    0,    0,    0,    0, -514,    0,    0,
     0,    0,    0,   39,  -11,    0, 1589,    0, 1545,    0,
     0,    0,    0,  998,  999,  -48, -239,    0,    0,    0,
     0,  536, -605, -587, -497, -440, -386, -343, -305, -285,
  -735,-1049,    0, -215,    0,  357,    0, -917,    0,    0,
     0,    0,    0,    0,  482,  -49,  291,    0,    0,    0,
   330, -982,    0, -296, -316, 1395,    0,    0,    0, -807,
   279,    0,    0, -484,    0,    0,  345,    0,    0,  319,
     0,    0,  351,    0, -207, -781,    0,    0,    0,    0,
   471,  -45,    0,    0,  863,  864,  869,    0, -509,    0,
     0, -576,  866,  462,    0, -826,    0,    0,    0,    0,
     0,    0,    0,    0,  248,    0,    0,    0,    0,    0,
     0,    0,    0,  532,    0,    0,    0,    0, -240,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  552,
     0, -495,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  257,    0,    0,  346,    0,    0,  344,  353,  267,
     0,    0,    0,    0,    0,    0,    0,    0,  623,    0,
     0,    0,    0,  230,    0,   75,  -81,    0,    0,  437,
     0,  500,    0,  726,    0, 1159, -312, -202, -117,  656,
     0,  628,    0,  -74,    5,    0,    0,   45,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, -290,    0,  136,    0,    0, -138,    0,
     0,    0,  870,    0, -461, -180, 1000,  944,    0,  947,
     0, 1121, 1308, 1056,    0,    0,  778,    0,    0,    0,
     0, 1057,    0,    0,    0,    0,    0,    0, -479,    0,
     0,    0,    0,    0, 1021,    0,  444,  840,  803,  831,
  1283, 1290, 1293, 1289, 1292,    0, 1294,    0,    0,    0,
   972,    0,  775,    0,    0,    0,    0,    0,    0,    0,
     0, -310,    0,    0,    0,    0,  -76,    0,  690,    0,
   567,    0,  620,    0,    0,    0,  678, -512,  -44, -332,
   -43,    0, 1503,    0,   47,    0,   49,   50,   52,   65,
    73,   80,   82,   84,   92,   98,    0, -608,    0,  -53,
     0,    0,  816,    0, -309,    0,    0,    0,  722,    0,
   871,    0,  833, -451,    0,    0,    0,    0,    0,    0,
   747,    0,    0,  746,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  758,    0,    0,    0,    0,
     0,    0,    0,    0,  -83,    0, 1212,    0,    0,    0,
   905,    0,    0,    0,    0,    0, -221,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0, 1302,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  542,    0,
     0,    0,    0,    0,    0,    0,    0,  665,    0,    0,
     0,    0,    0,
   };
   protected static  short [] yyTable = {           252,
    21,  157,  499,  263,  158,  203,  204,  439,  509,  693,
    21,   52,  536,  679,  433,  482,   78,  265,  413,  338,
   719,   32,  764,   43,  410,  281,  490,  660,  462,  526,
   725,  257,  467,  442, 1056, 1015, 1016,  928,   28,  687,
   727,  926,  367,  330,   30,  375,  283,   39,   28,   56,
  1138,   21,  416,  276,  163,   37,  241,  452,  245,  799,
   800,  783,   43,  973,  665,  746, 1145,   55,  958,  960,
   786,  324,  360,   40, 1222,  974, 1284,   35,  324,   35,
   863,  416,  378,  331,  943,  811,    3,  333,  527,   28,
   342,  344, 1370, 1010,  346,  330,  208,  253,  209,  210,
   829,  211,  831,  645,  163,   41,  362,   43,  238,  163,
   815,  631,  974,  631,  212,  443,  538,  504,   35,  510,
   551,  274,  213,  469,   54,  469,  355,  867, 1072,  214,
     1,  215,  467,  216, 1193,  417,   54,  364,  449,  444,
   418,  217,  419,  454,  282,   54,  407,  218,  420,  421,
     1,    2,  317,   35,  318,   35,  157,  783,  408,  158,
   203,  204,  337,   35,  417,  312,  445,  631, 1196,  418,
   275,  419,  539,  313,  356,  240, 1011,  420,  421,  469,
   455,   80,  940, 1194,  666,  801,  747,  691,  646,  282,
   282,  282,  282,  282,  282,  282,  282, 1285,  360,  812,
   536, 1418,   31,  357,   81,   42,  884, 1371,  887,  163,
   536,  783,    5,   38,   35,   35,  246, 1197,  907,  461,
   422,  525,  625,  466,  817,  975,  959,  961,  470,    3,
    35,  358, 1223,  815,  281,  472,    5,   21,  285,    5,
   378,  360,  281,  309,   54,  310,  311,   80,  315,  432,
   316,  208,    4,  209,  210,  478,  211,  926,  328,    5,
   329,  480,  975,  481,  529, 1352,  485,  487,  334,  212,
    81,  336,  541,  340,  886,   28,   56,  213,  512,  439,
   513,  556,  524,  359,  214,  521,  215,  523,  216,  522,
  1099,  485, 1376,   49,  434,  970,  217,  373,  926,  500,
   535,  537,  218, 1314, 1386, 1235, 1387,  324,  142,  551,
   750,  314, 1341,  163,    6,    7,    8, 1419,  905,  857,
   858,  741,   35,  466,  567,  752, 1348,  391,  576,  577,
   578,  579,  580,  581,  582,  583,  584,  585,  586,  414,
   163,  590,  591,  816,  901,  792,  923,  817, 1393,  163,
   687,    1,    2,  282,  617,  618,  737,   80,  371,   35,
   608,  282, 1195,  392,    3,  926,  248,    1,  612,  614,
   249,  926,  877,  877,  332,  360,  716,  742,  660,  774,
    81,  490,  639,  360,   81,   35,  775,    2,  808,  366,
   684,  415,  374, 1157, 1236,   35,  661,  731,  462,    5,
   634,  467,   35,   80,  371,  737,  501,  360,  502, 1394,
   274,  965,    5,  771,  334,  772,  373,  773,   80, 1062,
   282,    5,   83, 1157,   54,  659,   81,    5,  655,  619,
     3,  250,  282,  282,  282,   35,  717,  282,  282,  393,
   394,   81,  982,  376,  983, 1272,    3,  877,  809,  677,
   684, 1083, 1084,    4,  689,  505,  567, 1396, 1086,  275,
     5,  660,  503,   91,  879,   35,   35,  520,  450,    4,
   696,  698, 1092, 1118, 1404,  732,    5,  734,  712,  661,
   714,  876,  876,  163,  899,  660,   80,  551,  535,  537,
   453, 1119,   35,   35, 1302, 1303,  721, 1305,  535,  537,
   452,   84,  685,  661,  842,  453,  813,   85, 1324,   81,
   451, 1331, 1332,  464,  736,  736,  660, 1378, 1379,  364,
   901, 1118,  359, 1149,   35,  901, 1347,  901, 1161,   81,
   901,  901,  509,  901,  901,  907,  823,  163,  703, 1119,
   907, 1150,  907,  551,  476,  907,  907,  163,  907,  907,
   376,  719,  376, 1149,  376,  376,  876,  376,  416,  376,
   452,  749,  685, 1101, 1117,  453,  907,  755,  349,  464,
   142, 1150,  465, 1410,  274, 1383,  349,  769,  357, 1212,
   349, 1120,   86, 1213,  889,  449,  996,  966, 1101,  461,
    87,  641,  466,  349,  704,  948,  477,  281,  691,  282,
   360,  376,  364,  376,   89,  901,  376,  485,    5,  804,
   656,  342, 1117,  914, 1148,  984,  797,   54,   81,   57,
   907,  677,   80,  275,   35,  349,  364, 1384,  465, 1120,
   364, 1151,  689,  364,  364,  364,   78,  949, 1121,  357,
   364,  417, 1045,  641, 1148,   81,  418,  821,  419,  395,
   396,  697,  516,  822,  420,  421,  667, 1024,  359,  357,
   342, 1151,  243,  357,  832,  244,  833,  635,  909,  699,
   270,  910,  163,  163,  271,  835,  910, 1029,  910,  918,
   667,  910,  910,   80,  910,  910, 1121,  635, 1152,  667,
   567,  515, 1122,  636,  262,  567,  844,  807,  677,  536,
   879,   35,  910,   80,  516,  160,   81,   80,  364,  860,
   861,  264,   79,  163,  639,  163,  282,  995, 1152,  359,
   365,  517,   80, 1059,  272,   80,   81,  875,  876,  640,
    81,  536,  481,  337,  591, 1123,  261,  888,  639,  359,
  1122,   59, 1153,  359,  263,   81,  485,  267,   81,  903,
   364,   80,  536,  640,  677,  160,  910,  274,  908,  368,
   160, 1082,   83,  495,   60,  639,  868,  496,  916,  544,
   268,   35, 1153, 1124,   81,  337,  545,   61,  369,  370,
   640,  823,   63, 1123,  273, 1154,   81,   64,  546,   65,
    66,   67,   68, 1125, 1135,  261,  261,   69,  371,  733,
   640,   70,   35,  932,  641,  934,  275,  936,  944,  372,
   673,  261, 1335,   71,  674, 1154,   72,  591,   73,  575,
   945, 1124,  591, 1155,  591,  591,  591,  591,  591,  591,
   591,  591,  591,  591,  591,   83,  592,  593,  446,   74,
   455, 1125,  591, 1156,  591,  670,  591,  677,  591,  591,
   591,  364,  688, 1155,  349,   80,  496,  509,   35,  284,
   160,   35,  349,  825,  591,  612,  349,  612,   52, 1018,
   544,  142,  783, 1156, 1388,  591,  337,  545,   81,  349,
   721, 1019,  401,  402,  988,  903,  990,  591,  991,  546,
   903,  359,  903,  286, 1217,  903,  903, 1179,  903,  903,
   337,  349,  591,  261, 1179,  371,  557,  363,  163,  349,
  1407,  349,  349,  349,  559,  558,  397,  398,  376,   35,
  1424, 1425,  897,  560,  404,  481,  349,  897,  371,  897,
   399,  400,  897,  897,  641,  897,  897, 1036,  677,  641,
   261,  371,   21,  641,  241, 1043,  371,  403,  868,  248,
  1002,  371,  405,  371,  371,  371,  371,  637,  641,  638,
   295,  371,  295, 1065,  160,  371,  261,  295,  481,  371,
   903,  481, 1142,  335,   69,   69,  261,  371,   69,  335,
   371,  406,  371,  261, 1218,  641,  336,  535,  537, 1069,
  1225,  160,  879,  142, 1040, 1041,  142, 1231,   21,  142,
   160,  663, 1182,  371,  641, 1237,  286,  897,  763,  481,
   663,   81,  766,  735,  662,  286,  261,  641,  409,  535,
   537, 1088,  991,  662,  354,   35,  349, 1096,  354,  349,
   349,  134,  163,  134,  412,  763,  163,  763,  134,  763,
   535,  537,  481,  927,   70,  744,  261,  261,   70, 1002,
   349,  349,  318,  349,  349,   61,  510,  435,  371,  349,
   441,  349,  510,  749,  163,  163,  342,  749,  163,  342,
   456,  163,  354,  261,  261,  388,  389,  390, 1100, 1116,
   349,  349,  752, 1163,  752,  463,  752, 1096,  511,  163,
   464,  427,  364,  427,  511, 1184,  364,  471,  349,  364,
   349,  364,   72, 1100,   72,  261,  364,  475,  349,  417,
   483,  349,  427,  427,  418, 1190,  419, 1191, 1192,  745,
  1229,  745,  420,  421,   35, 1397, 1398, 1116,  252, 1100,
   484,  754,  427,  754,  160, 1229,  854,  185,  854,  185,
   427,  185,  498,  427, 1221,  876,  876, 1224,  173,  354,
   173,   35, 1280,  354, 1281,  349,  354,  377,  354, 1100,
   180,  365,  180,  354, 1238,  347,  348,  349,  350,  351,
   352,  353,  354,  511,  181,  261,  181,  514,  378,  379,
   380,  381,  382,  383,  384,  385,  386,  387,  160,  197,
   203,  197,  203,  197,  174,  528,  174,  354,  160,  596,
   597,  598,  599,  530,  830,  261,  139,  300,  139,  300,
   540,   35,   35,  146,  254,  146,  307,  555,  307,   35,
   534,  534,  623,   95,  561,   97,  641,  641,   98,  953,
   954,  600,  601,  102,  594,  595,  615,  106,  627,  622,
   630,   35,   35,  632,   35,  642,  109,  644,  677, 1184,
  1208,  668,  667,  114,  657,  669,  671,  713,  116,  672,
   481,  694,  119,  695,  708,  709, 1208,  710,   35,  711,
   715,   35, 1208,  729,  121,  720,  122, 1364,  726, 1208,
   124,  728,  261,  739,  740,  744,  751, 1315,  131,  132,
   745,  754,  135,  760,  763,  255,  753,  765,  781,  766,
   788,  789,  798,  790, 1342,  791,  795,  828,  794,  796,
   677,  803,  818,  819,  240,  827,  826, 1354, 1356,  814,
   837,  839,  848,  160,  160,  853,  855,  859,    4,  871,
   880,  862,  893,  894,  904,  895,  896,  902,  906,  913,
   501,  920,  922,  924, 1342, 1342,  677,  930,  971,  962,
   929,  951,  261,   30,  955, 1412, 1412,  956,  963,  969,
   981,  964, 1420, 1420,  160,  968,  160,  567,  567,  989,
   823,  987,   87,  986,  994,  999, 1000, 1017, 1020, 1021,
  1022, 1023, 1030,  261, 1035, 1039, 1047, 1042, 1044, 1049,
  1011, 1050, 1057, 1061, 1074, 1051,  574, 1065, 1063, 1068,
  1342, 1087, 1078, 1079, 1080, 1133, 1077, 1137,  587,  588,
   589, 1136, 1139,  574,  574,  574,  574,  574,  574,  574,
   574,  574,  574,  574,  574,  574,  574,  574,  574, 1091,
  1134, 1146, 1162, 1165, 1186, 1188, 1198, 1211, 1227,  261,
  1230, 1264,  261, 1214, 1267, 1233, 1273, 1291, 1266,   53,
  1216, 1269, 1270, 1271, 1277, 1278, 1217, 1226, 1275, 1234,
   830,  830, 1283, 1236, 1295, 1288, 1296, 1298,  830,  830,
   830,  830,  830, 1306,  830,  830, 1307,  830,  830,  830,
   830,  830,  830,  830,  830, 1310, 1320, 1325, 1327,  830,
  1339,  830,  830,  830,  830,  830,  830, 1337, 1340,  830,
   261, 1346, 1363,  830,  830, 1336,  830,  830,  830, 1350,
  1361, 1366, 1368, 1369, 1349, 1360, 1365, 1374,  830, 1380,
   830,  574,  830,  830, 1385, 1381,  830, 1389,  830,  830,
   830,  830,  830,  830,  830,  830,  830,  830,  830,  830,
  1390,  830, 1399, 1384,  830,  830, 1383, 1405,  830,  830,
  1406, 1426, 1427, 1428,    7,   32,   33,  545,   34,  160,
   828,  730,   25,  613,  505,  327,  224,  830,  830,  100,
   798,  830,  506,  464,  614,  730,  830,  830,  830,  830,
   830,  802,  504,   32,  830,  530,  830,  748,  756,  773,
    33,  836,  830,  830,  803,  674,  757,  748,  777,  662,
   805,  778,  331,  807,  684,  662,  261,  356,  349,   30,
    30,  641,  641,  142,   30,  124,  237,  830,  830,  830,
   830,  303,  830,  149,  143,   30,  125,  304,  830,  150,
    30,  941,   88,  266,   30,  778,  779,   30, 1140, 1382,
  1187, 1351,  438, 1391, 1338, 1333, 1205, 1367,  885,   30,
    30,  890,  891, 1219,   30,   30, 1422,  892, 1147, 1415,
    30, 1357,   30,   30,   30,   30, 1144, 1362, 1414, 1355,
    30, 1075, 1282, 1001,   30, 1209,   30, 1076,  705,  562,
   806,  912,  841,  160,  738,  602,   30,  160,   30,   30,
   843,   30,  972,  603,  605,   30,  780,  604,  606,  838,
   985,  607, 1053, 1166, 1131,  261,   53,  411, 1037, 1064,
    55,   30,   30,  967,  957,  160,  160,   30,   30,  160,
   931,   55,  160, 1031, 1033, 1026,   55,  621,  802,  700,
    55, 1215,  261,   55,  925, 1089,    0,    0,    0,    0,
   160,    0,    0,    0,    0,   55,   55,    0,    0,    0,
    55,   55,    0,   30,    0,    0,   55,    0,   55,   55,
    55,   55,    0,    0,    0,    0,   55,    0,    0,    0,
    55,    0,   55,    0,    0,    0,    0,    0,    0,    0,
     0,    0,   55,    0,    0,   55,    0,   55,    0,    0,
     0,   55,  261,  261,    0,    0,    0,    0,    0,    0,
   261,    0,    0,    0,    0,    0,    0,    0,   55,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  261,  261,    0,  261,    0,    0,    0,    0,
     0,    0,  574,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  925,    0,  773,  773,    0,    0,  261,
     0,    0,  261,  773,  773,  773,  773,  773,    0,  773,
   773,    0,  773,  773,  773,  773,  773,  773,  773,    0,
     0,    0,    0,    0,  773,    0,  773,  773,  773,  773,
   773,  773,    0,    0,  773,    0,    0,    0,  773,  773,
     0,  773,  773,  773,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  773,    0,  773,    0,  773,  773,    0,
     0,  773,  922,  773,  773,  773,  773,  773,  773,  773,
   773,  773,  773,  773,  773,    0,  773,    0,    0,  773,
   773,    0,    0,  773,  773,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  773,  773,    0,    7,  773,    0,    0,    0,
     0,  773,  773,  773,  773,  773,    0,    0,    0,  773,
     0,  773,    0,    0,    0,    0,    0,  773,  773,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  773,  773,  773,  773,    0,  773,    0,   30,
    30,    0,    0,  773,   30,    0,    0,    0,   30,    0,
    30,    0,    0,   30,    0,   30,   30,    0,   30,    0,
    30,    0,   30,    0,   30,   30,   30,   30,    0,    0,
    30,   30,    0,    0,    0,    0,   30,    0,   30,   30,
    30,    0,    0,   30,   30,   30,    0,   30,    0,    0,
    30,    0,   30,   30,   30,   30,    0,    0,    0,   30,
    30,   30,    0,    0,   30,   30,   30,    0,    0,    0,
     0,    0,    0,   30,   30,    0,   30,   30,   30,   30,
    30,   30,    0,    0,    0,   30,    0,    0,    0,    0,
   925,    0,    0,    0,   54,    0,    0,    0,    0,    0,
     0,   30,   30,    0,    0,   54,    0,   30,   30,    0,
    54,    0,    0,    0,   54,    0,   30,   54,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,   54,
    54,    0,    0,    0,   54,   54,    0,    0,    0,    0,
    54,    0,   54,   54,   54,   54,    0,    0,    0,    0,
    54,    0,    0,    0,   54,    0,   54,   30,    0,  922,
     0,    0,    0,   54,    0,    0,   54,    0,    0,   54,
     0,   54,    0,    0,   54,   54,    0,    0,    0,   54,
     0,    0,    0,   54,    0,    0,   54,    0,    0,    0,
     0,    0,   54,    0,    0,    0,    0,    0,   54,   54,
     0,    0,    0,   54,   54,    0,   54,    0,    0,   54,
     0,   54,   54,   54,   54,    0,    0,   54,    0,   54,
     0,    0,   54,   54,    0,   54,   54,    0,    0,   54,
     0,    0,    0,    0,    0,   54,    0,    0,   54,    0,
    54,   54,   54,    0,   54,    0,   54,   54,    0,    0,
     0,    0,   54,    0,   54,   54,   54,   54,    0,    0,
     0,   54,   54,    0,  515,    0,   54,    0,   54,  515,
   515,    0,    0,    0,    0,    0,    0,    0,   54,    0,
     0,   54,    0,   54,    0,    0,    0,   54,    0,    0,
     0,    0,  515,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  515,    0,   54,  515,  515,    0,    0,    0,
   515,    0,    0,  515,    0,  515,    0,  515,  515,  515,
   515,    0,    0,    0,    0,  515,    0,    0,    0,  515,
     0,    0,    0,  515,    0,    0,    0,    0,    0,    0,
     0,  515,    0,    0,  515,    0,  515,  515,    0,    0,
     0,    0,  515,    0,  515,  515,  515,  515,  515,  515,
   515,  515,  515,  515,  515,    0,    0,  515,    0,    0,
     0,  515,  515,    0,  515,  515,  515,  515,  515,  515,
   515,    0,  515,  515,    0,  515,  515,  515,  515,  515,
   515,  515,  515,  515,  515,    0,  515,  515,  515,  515,
   515,  515,  515,  515,  515,  515,  515,  515,  515,  515,
   515,  515,  515,  515,  515,  515,  515,  515,    0,    0,
   515,    0,  515,  349,  515,    0,    0,  515,  349,  349,
     0,    0,  515,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  349,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  349,    0,    0,  349,  349,    0,    0,    0,  349,
     0,    0,  349,    0,  349,    0,  349,  349,  349,  349,
     0,    0,    0,    0,  349,    0,    0,    0,  349,    0,
     0,    0,  349,    0,    0,    0,    0,    0,    0,    0,
   349,    0,    0,  349,    0,  349,  349,    0,    0,    0,
     0,  349,    0,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,    0,  349,    0,    0,    0,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
     0,  349,  349,    0,    0,  349,  349,  349,  349,  349,
     0,    0,  349,  349,    0,    0,    0,  349,  349,  349,
   349,  349,  349,  349,  349,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  349,    0,    0,  349,
     0,  349,    0,  349,   93,    0,  349,    0,    0,    0,
     0,  349,   94,   95,   96,   97,    0,    0,   98,   99,
     0,  100,  101,  102,  103,  104,  105,  106,    0,    0,
     0,    0,    0,  107,    0,  108,  109,  110,  111,  112,
   113,    0,    0,  114,    0,    0,    0,  115,  116,    0,
   117,  118,  119,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  120,    0,  121,    0,  122,  123,    0,    0,
   124,    0,  125,  126,  127,  128,  129,  130,  131,  132,
   133,  134,  135,  136,    0,  137,    0,    0,  138,  139,
     0,    0,  140,  141,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  342,    0,    0,    0,    0,  342,
   342,  142,    0,    0,    0,  143,    0,    0,    0,    0,
   144,  145,  146,  147,  148,    0,    0,    0,  149,    0,
   150,    0,  342,    0,    0,    0,  151,  152,    0,    0,
     0,    0,  342,    0,    0,  342,  342,    0,    0,    0,
   342,    0,    0,  342,    0,  342,    0,  342,  342,  342,
   342,  153,  154,  155,  156,  342,    0,    0,    0,  342,
     0,    0,  240,  342,    0,    0,    0,    0,    0,    0,
     0,  342,    0,    0,  342,    0,  342,  342,    0,    0,
     0,    0,  342,    0,  342,  342,  342,  342,  342,  342,
   342,  342,  342,  342,  342,    0,    0,  342,    0,    0,
     0,  342,  342,  342,  342,  342,  342,    0,  342,  342,
   342,    0,  342,  342,    0,    0,  342,  342,  342,  342,
     0,    0,    0,  342,  342,    0,    0,    0,  342,  342,
   342,  342,  342,  342,  342,  342,  738,    0,    0,    0,
     0,  738,  738,    0,    0,    0,    0,  342,    0,    0,
   342,    0,  342,    0,  342,    0,    0,  342,    0,    0,
     0,    0,  342,    0,  738,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  738,    0,    0,  738,  738,    0,
     0,    0,  738,    0,    0,  738,    0,  738,    0,  738,
   738,  738,  738,    0,    0,    0,    0,  738,    0,    0,
     0,  738,    0,    0,    0,  738,    0,    0,    0,    0,
     0,    0,    0,  738,    0,  349,  738,    0,  738,  738,
     0,  349,    0,    0,  738,    0,  738,  738,  738,  738,
   738,  738,  738,  738,  738,  738,  738,    0,    0,  738,
     0,    0,    0,  738,  738,  738,  738,  738,  738,    0,
   738,  738,  738,    0,  738,  738,    0,  349,  738,  738,
   738,  738,    0,    0,    0,  738,  738,    0,    0,    0,
   738,  738,  738,  738,  738,  738,  738,  738,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  738,
     0,    0,  738,    0,  738,    0,  738,    0,  349,  738,
     0,    0,    0,  349,  738,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,    0,    0,    0,
     0,    0,    0,  349,  349,  349,  349,  349,  349,  349,
   349,  349,    0,  349,  349,    0,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  370,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  370,
     0,  379,    0,  349,    0,  349,  379,  379,  349,    0,
     0,    0,  370,  349,    0,    0,    0,  370,    0,    0,
   247,    0,  370,    0,  370,  370,  370,  370,    0,  379,
     0,    0,  370,    0,    0,    0,  370,    0,    0,  379,
   370,    0,  379,  379,    0,    0,    0,  379,  370,    0,
   379,  370,  379,  370,  379,  379,  379,  379,    0,    0,
     0,    0,  379,    0,    0,    0,  379,    0,    0,    0,
   379,    0,    0,    0,  370,    0,    0,    0,  379,    0,
   517,  379,    0,  379,  379,    0,  517,    0,    0,  379,
     0,  379,  379,  379,  379,  379,  379,  379,  379,  379,
   379,  379,    0,    0,  379,    0,    0,    0,  379,  379,
     0,  379,  379,  379,    0,  379,  379,  379,    0,  379,
   379,    0,  517,  379,  379,  379,  379,    0,    0,  370,
   379,  379,    0,    0,    0,  379,  379,  379,  379,  379,
   379,  379,  379,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  379,    0,    0,  379,    0,  379,
     0,    0,    0,  517,    0,    0,    0,    0,  517,  379,
   517,  517,  517,  517,  517,  517,  517,  517,  517,  517,
   517,    0,    0,    0,    0,    0,    0,  517,  517,  517,
   517,  517,  517,  517,  517,  517,  517,    0,  517,  517,
     0,  517,  517,  517,  517,  517,  517,  517,  517,  517,
   517,    0,  517,  517,  517,  517,  517,  517,  517,  517,
   517,  517,  517,  517,  517,  517,  517,  517,  517,  517,
   517,  517,  517,  517,    0,  513,  701,    0,    0,    0,
   517,  513,    0,    0,    0,   95,    0,   97,  517,    0,
    98,    0,    0,    0,    0,  102,    0,    0,    0,  106,
     0,    0,    0,    0,    0,    0,    0,    0,  109,    0,
     0,    0,    0,    0,    0,  114,    0,  513,    0,    0,
   116,    0,    0,    0,  119,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  121,    0,  122,    0,
     0,    0,  124,    0,    0,    0,    0,    0,    0,    0,
   131,  132,    0,    0,  135,    0,    0,  437,  513,    0,
     0,    0,    0,  513,    0,  513,  513,  513,  513,  513,
   513,  513,  513,  513,  513,  513,    0,    0,    0,    0,
     0,    0,  513,  513,    0,  513,  513,  513,  513,  513,
   513,  513,    0,  513,  513,    0,  513,  513,  513,  513,
   513,  513,  513,  513,  513,  513,    0,  513,  513,  513,
   513,  513,  513,  513,  513,  513,  513,  513,  513,  513,
   513,  513,  513,  513,  513,  513,  513,  513,  513,    0,
   521,  768,    0,    0,  702,  513,  521,    0,  513,    0,
    95,    0,   97,  513,    0,   98,    0,    0,    0,    0,
   102,    0,    0,    0,  106,    0,    0,    0,    0,    0,
     0,    0,    0,  109,    0,    0,    0,    0,    0,    0,
   114,    0,  521,    0,    0,  116,    0,    0,    0,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  121,    0,  122,    0,    0,    0,  124,    0,    0,
     0,    0,    0,    0,    0,  131,  132,    0,    0,  135,
     0,    0,  255,  521,    0,    0,    0,    0,  521,    0,
   521,  521,  521,  521,  521,  521,  521,  521,  521,  521,
   521,    0,    0,    0,    0,    0,    0,    0,  521,    0,
   521,  521,  521,  521,  521,  521,  521,    0,  521,  521,
     0,  521,  521,  521,  521,  521,  521,  521,  521,  521,
   521,    0,  521,  521,  521,  521,  521,  521,  521,  521,
   521,  521,  521,  521,  521,  521,  521,  521,  521,  521,
   521,  521,  521,  521,    0,  448,  820,    0,    0,   87,
   521,  448,    0,  521,    0,   95,    0,   97,  521,    0,
    98,    0,    0,    0,    0,  102,    0,    0,    0,  106,
     0,    0,    0,    0,    0,    0,    0,    0,  109,    0,
     0,    0,    0,    0,    0,  114,    0,  448,    0,    0,
   116,    0,    0,    0,  119,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  121,    0,  122,    0,
     0,    0,  124,    0,    0,    0,    0,    0,    0,    0,
   131,  132,    0,    0,  135,    0,    0,  255,  448,    0,
     0,    0,    0,  448,    0,  448,  448,  448,  448,  448,
   448,  448,  448,  448,  448,  448,    0,    0,    0,    0,
     0,    0,    0,  448,    0,  448,  448,  448,  448,  448,
   448,  448,    0,  448,  448,    0,  448,  448,  448,  448,
   448,  448,  448,  448,  448,  448,    0,  448,  448,  448,
   448,  448,  448,  448,  448,  448,  448,  448,  448,  448,
   448,  448,  448,  448,  448,  448,  448,  448,  448,    0,
   409, 1006,    0,    0,   87,  448,  409,    0,  448,    0,
    95,    0,   97,  448,    0,   98,    0,    0,    0,    0,
   102,    0,    0,    0,  106,    0,    0,    0,    0,    0,
     0,    0,    0,  109,    0,    0,    0,    0,    0,    0,
   114,    0,  409,    0,    0,  116,    0,    0,    0,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  121,    0,  122,    0,    0,    0,  124,    0,    0,
     0,    0,    0,    0,    0,  131,  132,    0,    0,  135,
     0,    0,  255,  409,    0,    0,    0,    0,  409,    0,
   409,  409,  409,  409,  409,  409,  409,  409,  409,  409,
   409,    0,    0,    0,    0,    0,    0,    0,  409,    0,
   409,  409,  409,  409,  409,  409,  409,    0,  409,  595,
     0,  409,  409,  409,  409,  409,  409,  409,  409,  409,
   409,    0,  409,  409,  409,  409,  409,  409,  409,  409,
   409,  409,  409,  409,  409,  409,  409,  409,  409,  409,
   409,  409,  409,  409,    0,  550,    0,    0,    0,   87,
   409,  550,    0,  409,    0,    0,    0,    0,  409,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  550,    0,    0,
     0,    0,  595,    0,    0,    0,    0,  595,    0,  595,
   595,  595,  595,  595,  595,  595,  595,  595,  595,  595,
     0,    0,    0,    0,    0,    0,    0,  595,    0,  595,
     0,  595,    0,  595,  595,  595,    0,    0,  550,    0,
     0,    0,  593,  550,    0,  550,  550,  550,  550,  550,
   550,  550,  550,  550,  550,  550,    0,    0,    0,    0,
     0,    0,    0,  550,    0,  550,    0,  550,    0,  550,
   550,  550,    0,  550,  550,    0,  550,  550,  550,  550,
   550,  550,  550,  550,  550,  550,    0,  595,    0,  550,
   550,  550,  550,  550,  550,  550,  550,  550,  550,  550,
   550,  550,  550,  550,  550,  550,  550,  349,  550,    0,
     0,    0,    0,  349,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  550,    0,  593,    0,    0,    0,    0,
   593,    0,  593,  593,  593,  593,  593,  593,  593,  593,
   593,  593,  593,    0,    0,  349,    0,    0,    0,  349,
   593,    0,  593,    0,  593,    0,  593,  593,  593,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  593,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  374,    0,    0,    0,
   349,    0,  374,    0,    0,  349,    0,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,    0,
   593,    0,    0,    0,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  374,  349,  349,    0,  374,  349,
   349,  349,  349,  349,    0,    0,  349,  349,    0,    0,
     0,  349,  349,  349,  349,  349,  349,  349,  349,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   349,    0,    0,  349,    0,  349,    0,  349,    0,  374,
   349,    0,    0,    0,  374,  349,  374,  374,  374,  374,
   374,  374,  374,  374,  374,  374,  374,    0,    0,  562,
     0,    0,    0,  374,  374,  562,  374,  374,  374,    0,
   374,  374,  374,    0,  374,  374,    0,    0,  374,  374,
   374,  374,    0,    0,    0,  374,  374,    0,    0,    0,
   374,  374,  374,  374,  374,  374,  374,  374,    0,    0,
     0,  562,    0,    0,    0,    0,    0,    0,    0,  374,
     0,    0,  374,    0,  374,    0,    0,    0,    0,    0,
     0,    0,    0,  566,  374,    0,    0,    0,    0,  566,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  562,    0,    0,    0,    0,  562,    0,  562,
   562,  562,  562,  562,  562,  562,  562,  562,  562,  562,
     0,    0,    0,    0,    0,  566,    0,  562,    0,  562,
     0,  562,    0,  562,  562,  562,    0,  562,  562,    0,
     0,  562,  562,  562,  562,  562,  562,  562,  562,  562,
     0,    0,    0,  562,  562,  562,  562,  562,  562,  562,
   562,    0,  569,    0,    0,    0,  566,    0,  569,    0,
     0,  566,  562,  566,  566,  566,  566,  566,  566,  566,
   566,  566,  566,  566,    0,    0,    0,  562,    0,    0,
     0,  566,    0,  566,    0,  566,    0,  566,  566,  566,
     0,  566,  566,    0,  569,  566,  566,  566,  566,    0,
     0,    0,  566,  566,    0,    0,    0,  566,  566,  566,
   566,  566,  566,  566,  566,    0,  567,    0,    0,    0,
     0,    0,  567,    0,    0,    0,  566,    0,    0,    0,
     0,    0,    0,    0,    0,  569,    0,    0,    0,    0,
   569,  566,  569,  569,  569,  569,  569,  569,  569,  569,
   569,  569,  569,    0,    0,    0,    0,    0,  567,    0,
   569,    0,  569,    0,  569,    0,  569,  569,  569,    0,
   569,  569,    0,    0,  569,  569,  569,  569,    0,    0,
     0,  569,  569,    0,    0,    0,  569,  569,  569,  569,
   569,  569,  569,  569,    0,  568,    0,    0,    0,  567,
     0,  568,    0,    0,  567,  569,  567,  567,  567,  567,
   567,  567,  567,  567,  567,  567,  567,    0,    0,    0,
   569,    0,    0,    0,  567,    0,  567,    0,  567,    0,
   567,  567,  567,    0,  567,  567,    0,  568,  567,  567,
   567,  567,    0,    0,    0,  567,  567,    0,    0,    0,
   567,  567,  567,  567,  567,  567,  567,  567,    0,  572,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  567,
     0,    0,    0,    0,    0,    0,    0,    0,  568,    0,
     0,    0,    0,  568,  567,  568,  568,  568,  568,  568,
   568,  568,  568,  568,  568,  568,    0,    0,    0,    0,
     0,    0,    0,  568,    0,  568,    0,  568,    0,  568,
   568,  568,    0,  568,  568,    0,    0,  568,  568,  568,
   568,    0,    0,  573,  568,  568,    0,    0,    0,  568,
   568,  568,  568,  568,  568,  568,  568,    0,    0,    0,
     0,    0,  572,    0,    0,    0,    0,  572,  568,  572,
   572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
     0,    0,    0,  568,    0,    0,    0,  572,    0,  572,
     0,  572,    0,  572,  572,  572,    0,    0,    0,    0,
     0,  572,  572,  572,  572,    0,    0,  574,  572,  572,
     0,    0,    0,  572,  572,  572,  572,  572,  572,  572,
   572,    0,    0,    0,    0,    0,  573,    0,    0,    0,
     0,  573,  572,  573,  573,  573,  573,  573,  573,  573,
   573,  573,  573,  573,    0,    0,    0,  572,    0,    0,
     0,  573,    0,  573,    0,  573,    0,  573,  573,  573,
     0,    0,    0,    0,    0,  573,  573,  573,  573,    0,
     0,  575,  573,  573,    0,    0,    0,  573,  573,  573,
   573,  573,  573,  573,  573,    0,    0,    0,    0,    0,
   574,    0,    0,    0,    0,  574,  573,  574,  574,  574,
   574,  574,  574,  574,  574,  574,  574,  574,    0,    0,
     0,  573,    0,    0,    0,  574,    0,  574,    0,  574,
     0,  574,  574,  574,    0,    0,    0,    0,    0,  574,
   574,  574,  574,    0,    0,  576,  574,  574,    0,    0,
     0,  574,  574,  574,  574,  574,  574,  574,  574,    0,
     0,    0,    0,    0,  575,    0,    0,    0,    0,  575,
   574,  575,  575,  575,  575,  575,  575,  575,  575,  575,
   575,  575,    0,    0,    0,  574,    0,    0,    0,  575,
     0,  575,    0,  575,    0,  575,  575,  575,    0,    0,
     0,    0,    0,  575,  575,  575,  575,    0,    0,  577,
   575,  575,    0,    0,    0,    0,    0,  575,  575,  575,
   575,  575,  575,    0,    0,    0,    0,    0,  576,    0,
     0,    0,    0,  576,  575,  576,  576,  576,  576,  576,
   576,  576,  576,  576,  576,  576,    0,    0,    0,  575,
     0,    0,    0,  576,    0,  576,    0,  576,    0,  576,
   576,  576,    0,    0,    0,    0,    0,  576,  576,  576,
   576,    0,    0,  578,  576,  576,    0,    0,    0,    0,
     0,  576,  576,  576,  576,  576,  576,    0,    0,    0,
     0,    0,  577,    0,    0,    0,    0,  577,  576,  577,
   577,  577,  577,  577,  577,  577,  577,  577,  577,  577,
     0,    0,    0,  576,    0,    0,    0,  577,    0,  577,
     0,  577,    0,  577,  577,  577,    0,    0,    0,    0,
     0,  577,  577,  577,  577,    0,    0,  579,  577,  577,
     0,    0,    0,    0,    0,  577,  577,  577,  577,  577,
   577,    0,    0,    0,    0,    0,  578,    0,    0,    0,
     0,  578,  577,  578,  578,  578,  578,  578,  578,  578,
   578,  578,  578,  578,  349,    0,    0,  577,    0,    0,
   349,  578,    0,  578,    0,  578,    0,  578,  578,  578,
     0,    0,    0,    0,    0,  578,  578,  578,  578,    0,
     0,    0,  578,  578,    0,    0,    0,    0,    0,  578,
   578,  578,  578,  578,  578,    0,  349,    0,    0,    0,
   579,    0,    0,    0,    0,  579,  578,  579,  579,  579,
   579,  579,  579,  579,  579,  579,  579,  579,    0,    0,
     0,  578,    0,    0,    0,  579,    0,  579,    0,  579,
     0,  579,  579,  579,    0,  580,    0,    0,    0,  579,
   579,  579,  579,    0,    0,    0,  579,  579,    0,    0,
     0,    0,    0,  579,  579,  579,  579,  579,  579,    0,
     0,    0,  349,    0,    0,  349,    0,  349,  349,    0,
   579,    0,  349,  349,    0,    0,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  579,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,    0,    0,    0,  581,
     0,    0,    0,    0,    0,    0,  349,  349,    0,    0,
     0,    0,    0,    0,  349,    0,    0,  349,  580,    0,
     0,    0,  349,  580,    0,  580,  580,  580,  580,  580,
   580,  580,  580,  580,  580,  580,    0,    0,    0,    0,
     0,    0,    0,  580,    0,  580,    0,  580,    0,  580,
   580,  580,    0,    0,    0,    0,    0,    0,    0,  580,
   580,    0,    0,  582,  580,  580,    0,    0,    0,    0,
     0,    0,    0,  580,  580,  580,  580,    0,    0,    0,
     0,    0,  581,    0,    0,    0,    0,  581,  580,  581,
   581,  581,  581,  581,  581,  581,  581,  581,  581,  581,
     0,    0,    0,  580,    0,    0,    0,  581,    0,  581,
     0,  581,    0,  581,  581,  581,    0,    0,    0,    0,
     0,    0,    0,  581,  581,    0,    0,  583,  581,  581,
     0,    0,    0,    0,    0,    0,    0,  581,  581,  581,
   581,    0,    0,    0,    0,    0,  582,    0,    0,    0,
     0,  582,  581,  582,  582,  582,  582,  582,  582,  582,
   582,  582,  582,  582,    0,    0,    0,  581,    0,    0,
     0,  582,    0,  582,    0,  582,    0,  582,  582,  582,
     0,    0,    0,    0,    0,    0,    0,  582,  582,    0,
     0,  584,  582,  582,    0,    0,    0,    0,    0,    0,
     0,  582,  582,  582,  582,    0,    0,    0,    0,    0,
   583,    0,    0,    0,    0,  583,  582,  583,  583,  583,
   583,  583,  583,  583,  583,  583,  583,  583,    0,    0,
     0,  582,    0,    0,    0,  583,    0,  583,    0,  583,
     0,  583,  583,  583,    0,    0,    0,    0,    0,    0,
     0,  583,  583,    0,    0,  585,  583,  583,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  583,  583,    0,
     0,    0,    0,    0,  584,    0,    0,    0,    0,  584,
   583,  584,  584,  584,  584,  584,  584,  584,  584,  584,
   584,  584,    0,    0,    0,  583,    0,    0,    0,  584,
     0,  584,    0,  584,    0,  584,  584,  584,    0,    0,
     0,    0,    0,    0,    0,  584,  584,    0,    0,  586,
   584,  584,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  584,  584,    0,    0,    0,    0,    0,  585,    0,
     0,    0,    0,  585,  584,  585,  585,  585,  585,  585,
   585,  585,  585,  585,  585,  585,    0,    0,    0,  584,
     0,    0,    0,  585,    0,  585,    0,  585,    0,  585,
   585,  585,    0,    0,    0,    0,    0,    0,    0,    0,
   585,    0,    0,  587,  585,  585,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  585,  585,    0,    0,    0,
     0,    0,  586,    0,    0,    0,    0,  586,  585,  586,
   586,  586,  586,  586,  586,  586,  586,  586,  586,  586,
     0,    0,    0,  585,    0,    0,    0,  586,    0,  586,
     0,  586,    0,  586,  586,  586,    0,    0,    0,    0,
     0,    0,    0,    0,  586,    0,    0,  588,  586,  586,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  586,
   586,    0,    0,    0,    0,    0,  587,    0,    0,    0,
     0,  587,  586,  587,  587,  587,  587,  587,  587,  587,
   587,  587,  587,  587,    0,    0,    0,  586,    0,    0,
     0,  587,    0,  587,    0,  587,    0,  587,  587,  587,
     0,    0,    0,    0,    0,    0,    0,    0,  587,    0,
     0,  589,    0,  587,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  587,  587,    0,    0,    0,    0,    0,
   588,    0,    0,    0,    0,  588,  587,  588,  588,  588,
   588,  588,  588,  588,  588,  588,  588,  588,    0,    0,
     0,  587,    0,    0,    0,  588,    0,  588,    0,  588,
     0,  588,  588,  588,    0,    0,    0,    0,    0,    0,
     0,    0,  588,    0,    0,  590,    0,  588,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  588,  588,    0,
     0,    0,    0,    0,  589,    0,    0,    0,    0,  589,
   588,  589,  589,  589,  589,  589,  589,  589,  589,  589,
   589,  589,    0,    0,    0,  588,    0,    0,    0,  589,
     0,  589,    0,  589,    0,  589,  589,  589,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  592,
     0,  589,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  589,  589,    0,    0,    0,    0,    0,  590,    0,
     0,    0,    0,  590,  589,  590,  590,  590,  590,  590,
   590,  590,  590,  590,  590,  590,    0,    0,    0,  589,
     0,    0,    0,  590,    0,  590,    0,  590,    0,  590,
   590,  590,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  913,    0,  590,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  590,  590,    0,    0,    0,
     0,  349,  592,    0,    0,    0,    0,  592,  590,  592,
   592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
     0,    0,    0,  590,    0,    0,    0,  592,    0,  592,
     0,  592,    0,  592,  592,  592,    0,  349,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  592,
     0,    0,    0,    0,  406,    0,    0,    0,    0,    0,
   592,    0,    0,    0,    0,    0,  913,    0,    0,    0,
     0,  913,  592,  913,  913,  913,  913,  913,  913,  913,
   913,  913,  913,    0,    0,    0,    0,  592,    0,    0,
   406,  913,    0,  913,    0,  913,  349,  913,  913,  913,
     0,    0,    0,    0,  349,    0,  349,    0,  349,    0,
     0,  349,    0,  349,  349,    0,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,    0,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,    0,
     0,  913,    0,  349,    0,  349,    0,  342,  349,  406,
   406,  406,  406,  349,  406,    0,  406,  406,  349,  406,
   406,  406,  406,  406,    0,  406,  406,  406,  406,   54,
   406,  406,  406,  406,  406,  406,  406,  406,  406,  406,
   406,  406,  406,  406,  406,  406,  406,  406,  406,  406,
   406,  406,   54,    0,  349,    0,  342,    0,  406,    0,
     0,  406,    0,    0,    0,   54,  406,    0,    0,    0,
    54,    0,    0,    0,    0,   54,    0,   54,   54,   54,
    54,    0,    0,    0,    0,   54,    0,    0,    0,   54,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,   54,    0,    0,   54,    0,   54,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  349,  349,  349,  349,  349,   54,   54,   54,
   349,  349,  212,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,    0,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,    0,    0,   93,    0,
     0,    0,  349,    0,    0,  349,   94,   95,   96,   97,
   349,    0,   98,   99,    0,  100,  101,  102,  103,  104,
   105,  106,    0,    0,    0,    0,    0,  107,    0,  108,
   109,  110,  111,  112,  113,    0,    0,  114,    0,    0,
     0,  115,  116,    0,  117,  118,  119,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  120,    0,  121,    0,
   122,  123,    0,    0,  124,    0,  125,  126,  127,  128,
   129,  130,  131,  132,  133,  134,  135,  136,    0,  137,
     0,    0,  138,  139,    0,    0,  140,  141,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  142,    0,    0,    0,  143,
     0,    0,    0,    0,  144,  145,  146,  147,  148,    0,
     0,    0,  149,    0,  150,    0,    0,    0,    0,    0,
   151,  152,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  289,    0,    0,    0,  153,  154,  155,  156,   94,
    95,   96,   97,    0,    0,   98,   99,    0,  100,  101,
   102,  103,  104,  105,  106,    0,    0,    0,    0,    0,
   107,    0,  108,  109,  110,  111,  112,  113,    0,    0,
   114,    0,    0,    0,  115,  116,    0,  117,  118,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  120,
     0,  121,    0,  122,  123,    0,    0,  124,    0,  125,
   126,  127,  128,  129,  130,  131,  132,  133,  134,  135,
   136,    0,  137,    0,    0,  138,  139,    0,    0,  140,
   141,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  142,    0,
     0,    0,  143,    0,    0,    0,    0,  144,  145,  146,
   147,  148,    0,    0,    0,  149,    0,  150,    0,    0,
     0,    0,    0,  151,  152,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  531,    0,    0,    0,  153,  154,
   155,  156,   94,   95,   96,   97,    0,    0,   98,   99,
     0,  100,  101,  102,  103,  104,  105,  106,    0,    0,
     0,    0,    0,  107,    0,  108,  109,  110,  111,  112,
   113,    0,    0,  114,    0,    0,    0,  115,  116,    0,
   117,  118,  119,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  120,    0,  121,    0,  122,  123,    0,    0,
   124,    0,  125,  126,  127,  128,  129,  130,  131,  132,
   133,  134,  135,  136,    0,  137,    0,    0,  138,  139,
     0,    0,  140,  141,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  142,    0,    0,    0,  143,    0,    0,    0,    0,
   144,  145,  146,  147,  148,    0,    0,    0,  149,    0,
   150,    0,    0,    0,    0,    0,  151,  152,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  918,    0,    0,
     0,  153,  154,  155,  156,  918,  918,  918,  918,    0,
     0,  918,  918,    0,  918,  918,  918,  918,  918,  918,
   918,    0,    0,    0,    0,    0,  918,    0,  918,  918,
   918,  918,  918,  918,    0,    0,  918,    0,    0,    0,
   918,  918,    0,  918,  918,  918,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  918,    0,  918,    0,  918,
   918,    0,    0,  918,    0,  918,  918,  918,  918,  918,
   918,  918,  918,  918,  918,  918,  918,    0,  918,    0,
     0,  918,  918,    0,    0,  918,  918,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  918,    0,    0,    0,  918,    0,
     0,    0,    0,  918,  918,  918,  918,  918,    0,    0,
     0,  918,    0,  918,    0,    0,    0,    0,    0,  918,
   918,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   782,    0,    0,    0,  918,  918,  918,  918,  782,  782,
   782,  782,    0,    0,  782,  782,    0,  782,  782,  782,
   782,  782,  782,  782,    0,    0,    0,    0,    0,  782,
     0,  782,  782,  782,  782,  782,  782,    0,    0,  782,
     0,    0,    0,  782,  782,    0,  782,  782,  782,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  782,    0,
   782,    0,  782,  782,    0,    0,  782,    0,  782,  782,
   782,  782,  782,  782,  782,  782,  782,  782,  782,  782,
     0,  782,    0,    0,  782,  782,    0,    0,  782,  782,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  782,    0,    0,
     0,  782,    0,    0,    0,    0,  782,  782,  782,  782,
   782,    0,    0,    0,  782,    0,  782,    0,    0,    0,
     0,    0,  782,  782,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  675,    0,    0,    0,  782,  782,  782,
   782,   94,   95,    0,   97,    0,    0,   98,  278,    0,
     0,    0,  102,  103,  104,    0,  106,    0,    0,   95,
     0,   97,  107,    0,   98,  109,    0,    0,    0,  102,
     0,    0,  114,  106,    0,    0,    0,  116,    0,  117,
   118,  119,  109,    0,    0,    0,    0,    0,    0,  114,
     0,    0,    0,  121,  116,  122,  123,    0,  119,  124,
     0,    0,  126,    0,  128,    0,  130,  131,  132,  279,
   121,  135,  122,    0,    0,    0,  124,    0,  139,    0,
     0,  140,  141,    0,  131,  132,    0,    0,  135,    0,
     0,  255,    0,    0,    0,    0,    0,    0,    0,    0,
   498,  676,    0,    0,  143,    0,    0,    0,    0,    0,
   145,  146,  147,  148,    0,    0,    0,  149,    0,  150,
     0,    0,    0,    0,    0,  151,  152,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  675,    0,    0,    0,
   153,  323,  155,  156,   94,   95,    0,   97,    0,    0,
    98,  278,    0,    0,    0,  102,  103,  104,  341,  106,
     0,    0,    0,    0,    0,  107,    0,   59,  109,    0,
     0,    0,    0,    0,    0,  114,    0,    0,    0,    0,
   116,    0,  117,  118,  119,    0,    0,    0,    0,    0,
    60,    0,    0,    0,    0,    0,  121,    0,  122,  123,
   845,    0,  124,   61,    0,  126,    0,  128,   63,  130,
   131,  132,  279,   64,  135,   65,   66,   67,   68,    0,
     0,  139,    0,   69,  140,  141,    0,   70,    0,    0,
     0, 1201,    0,    0,    0,    0,    0,    0,    0,   71,
     0,    0,   72,  498,   73,    0,    0,  143,    0,    0,
     0,    0,    0,  145,  146,  147,  148,    0,    0,    0,
   149,    0,  150,    0,    0,   74,    0,    0,  151,  152,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  658,
     0,    0,    0,  153,  323,  155,  156,   94,   95,    0,
    97,    0,    0,   98,  278,    0,    0,    0,  102,  103,
   104,    0,  106,    0,    0,    0,    0,    0,  107,    0,
  1202,  109,    0,    0,    0,    0,    0,    0,  114,    0,
     0,    0,    0,  116,    0,  117,  118,  119,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  121,
     0,  122,  123,    0,    0,  124,    0,    0,  126,    0,
   128,    0,  130,  131,  132,  279,    0,  135,    0,    0,
   137,    0,    0,    0,  139,    0,    0,  140,  141,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   143,    0,    0,    0,    0,    0,  145,  146,  147,  148,
     0,    0,    0,  149,    0,  150,    0,    0,    0,    0,
     0,  151,  152,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  675,    0,    0,    0,  153,  323,  155,  156,
    94,   95,    0,   97,    0,    0,   98,  278,    0,    0,
     0,  102,  103,  104,    0,  106,    0,    0,   95,    0,
    97,  107,    0,   98,  109,    0,    0,    0,  102,    0,
     0,  114,  106,    0,    0,    0,  116,    0,  117,  118,
   119,  109,    0,    0,    0,    0,    0,    0,  114,    0,
     0,    0,  121,  116,  122,  123,    0,  119,  124,    0,
     0,  126,    0,  128,    0,  130,  131,  132,  279,  121,
   135,  122,    0,    0,    0,  124,    0,  139,    0,    0,
   140,  141,    0,  131,  132,    0,    0,  135,    0,    0,
   255,    0,    0,    0,    0,    0,    0,    0,    0,  498,
     0,    0,    0,  143,    0,    0,    0,    0,    0,  145,
   146,  147,  148,    0,    0,    0,  149,    0,  150,    0,
     0,    0,    0,    0,  151,  152,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  834,    0,    0,    0,  153,
   323,  155,  156,   94,   95,    0,   97,    0,    0,   98,
   278,    0,    0,    0,  102,  103,  104,  343,  106,    0,
     0,   95,    0,   97,  107,    0,   98,  109,    0,    0,
     0,  102,    0,    0,  114,  106,    0,    0,    0,  116,
     0,  117,  118,  119,  109,    0,    0,    0,    0,    0,
     0,  114,    0,    0,    0,  121,  116,  122,  123,    0,
   119,  124,    0,    0,  126,    0,  128,    0,  130,  131,
   132,  279,  121,  135,  122,    0,    0,    0,  124,    0,
   139,    0,    0,  140,  141,    0,  131,  132,    0,    0,
   135,    0,    0,  255,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  143,    0,    0,    0,
     0,    0,  145,  146,  147,  148,    0,    0,    0,  149,
     0,  150,    0,    0,    0,    0,    0,  151,  152,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  617,    0,
     0,    0,  153,  323,  155,  156,  617,  617,    0,  617,
     0,    0,  617,  617,    0,    0,    0,  617,  617,  617,
    87,  617,    0,    0,   95,    0,   97,  617,    0,   98,
   617,    0,    0,    0,  102,    0,    0,  617,  106,    0,
     0,    0,  617,    0,  617,  617,  617,  109,    0,    0,
     0,    0,    0,    0,  114,    0,    0,    0,  617,  116,
   617,  617,    0,  119,  617,    0,    0,  617,    0,  617,
     0,  617,  617,  617,  617,  121,  617,  122,    0,    0,
     0,  124,    0,  617,    0,    0,  617,  617,    0,  131,
   132,    0,    0,  135,    0,    0,  437,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  617,
     0,    0,    0,    0,    0,  617,  617,  617,  617,    0,
     0,    0,  617,    0,  617,    0,    0,    0,    0,    0,
   617,  617,    0,    0,    0,    0,    0,    0,   94,   95,
     0,   97,    0,    0,   98,  278,    0,    0,    0,  102,
   103,  104,    0,  106,    0,  617,  617,  617,  617,  107,
     0,    0,  109,    0,    0,    0,    0,    0,    0,  114,
     0,    0,    0,   87,  116,    0,  117,  118,  119,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   121,    0,  122,  123,    0,    0,  124,    0,    0,  126,
     0,  128,    0,  130,  131,  132,  279,    0,  135,    0,
     0,    0,    0,    0,    0,  139,    0,    0,  140,  141,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  681,  911,    0,
     0,  143,    0,    0,    0,    0,    0,  145,  146,  147,
   148,    0,    0,    0,  149,    0,  150,    0,    0,    0,
     0,    0,  151,  152,    0,    0,    0,    0,    0,    0,
    94,   95,    0,   97,    0,    0,   98,  278,    0,    0,
     0,  102,  103,  104,    0,  106,    0,  153,  682,  155,
   156,  107,    0,   30,  109,   30,    0,  683,    0,    0,
     0,  114,    0,    0,    0,    0,  116,    0,  117,  118,
   119,    0,    0,    0,    0,    0,   30,    0,    0,    0,
     0,    0,  121,    0,  122,  123,    0,    0,  124,   30,
     0,  126,    0,  128,   30,  130,  131,  132,  279,   30,
   135,   30,   30,   30,   30,    0,    0,  139,    0,   30,
   140,  141,    0,   30,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,   30,    0,    0,   30,  681,
    30,    0,    0,  143,    0,    0,    0,    0,    0,  145,
   146,  147,  148,    0,    0,    0,  149,    0,  150,    0,
     0,   30,    0,    0,  151,  152,   30,   30,    0,    0,
     0,    0,  349,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  488,    0,    0,  153,
   682,  155,  156,    0,   94,   95,    0,   97,    0,  683,
    98,  278,    0,    0,    0,  102,  103,  104,  349,  106,
     0,    0,    0,    0,    0,  107,    0,    0,  109,    0,
     0,    0,    0,    0,    0,  114,    0,    0,    0,    0,
   116,    0,  117,  118,  119,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  121,    0,  122,  123,
     0,    0,  124,    0,    0,  126,    0,  128,    0,  130,
   131,  132,  279,    0,  135,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  349,  349,  349,
   349,    0,    0,    0,  349,  349,    0,    0,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  143,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
     0,    0,    0,    0,    0,    0,  349,    0,    0,  349,
     0,    0,    0,    0,    0,    0,   55,    0,   55,    0,
    55,    0,   55,  153,  489,   55,    0,   55,   55,    0,
    55,    0,   55,    0,   55,    0,   55,   55,   55,   55,
     0,    0,   55,   55,    0,    0,    0,    0,   55,   55,
    55,   55,   55,    0,    0,   55,   55,   55,    0,   55,
     0,   55,   55,   55,   55,   55,   55,   55,   55,    0,
    55,   55,   55,   55,    0,    0,   55,   55,   55,    0,
    55,    0,    0,    0,    0,   55,   55,    0,   55,   55,
     0,   55,   55,   55,    0,    0,    0,   55,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,   55,   55,   55,    0,    0,    0,
     0,    0,    0,    0,    0,   54,    0,    0,   55,   54,
     0,   54,    0,    0,   54,    0,   54,   54,    0,   54,
     0,   54,    0,   54,    0,   54,   54,   54,   54,    0,
     0,   54,   54,    0,    0,    0,    0,   54,    0,   54,
    54,   54,    0,    0,   54,    0,   54,    0,   54,   55,
     0,   54,    0,   54,   54,   54,   54,    0,    0,    0,
    54,   54,   54,    0,    0,   54,   54,   54,    0,    0,
     0,    0,    0,    0,   54,   54,    0,   54,   54,   54,
    54,   54,   54,   54,    0,   54,   54,    0,   54,    0,
    54,   54,    0,   54,    0,   54,    0,   54,    0,   54,
    54,   54,   54,   54,    0,   54,   54,    0,   85,    0,
     0,   54,    0,   54,   54,   54,    0,   54,   54,    0,
    54,    0,   54,    0,    0,   54,    0,   54,   54,   54,
    54,    0,    0,    0,   54,   54,   54,    0,    0,   54,
    54,   54,    0,    0,    0,    0,    0,    0,   54,   54,
     0,   54,   54,   54,   54,   54,   54,   54,   54,   54,
    54,    0,   54,    0,   54,   54,    0,   54,    0,   54,
     0,   54,    0,   54,   54,   54,   54,   54,    0,   54,
    54,    0,   86,    0,    0,   54,    0,   54,   54,   54,
     0,   54,   54,    0,   54,    0,   54,    0,    0,   54,
     0,   54,   54,   54,   54,    0,    0,    0,   54,   54,
    54,    0,    0,   54,   54,   54,    0,    0,    0,    0,
     0,    0,   54,   54,    0,   54,   54,   54,   54,   54,
    54,   54,   54,   54,   54,    0,   54,    0,   54,   54,
     0,   54,    0,   54,    0,   54,    0,   54,   54,   54,
    54,   54,    0,   54,   54,    0,  108,    0,    0,   54,
     0,   54,   54,   54,    0,   54,   54,    0,   54,    0,
    54,    0,    0,   54,    0,   54,   54,   54,   54,    0,
     0,    0,   54,   54,   54,    0,    0,   54,   54,   54,
     0,    0,    0,    0,    0,    0,   54,   54,    0,   54,
    54,   54,   54,   54,   54,   54,   54,   54,   54,    0,
    54,    0,   54,   54,    0,   54,    0,   54,    0,   54,
     0,   54,   54,   54,   54,   54,    0,   54,   54,    0,
   109,    0,    0,   54,    0,   54,   54,   54,    0,   54,
    54,    0,   54,    0,   54,    0,    0,   54,    0,   54,
    54,   54,   54,    0,    0,    0,   54,   54,   54,    0,
     0,   54,   54,   54,    0,    0,    0,    0,    0,    0,
    54,   54,    0,   54,   54,   54,   54,   54,   54,   54,
    54,   54,   54,    0,   54,    0,   54,   54,    0,   54,
     0,   54,    0,   54,    0,   54,   54,   54,   54,   54,
     0,   54,   54,    0,  230,    0,    0,   54,    0,   54,
    54,   54,    0,    0,   54,    0,   54,    0,   54,  349,
     0,   54,    0,   54,   54,   54,   54,    0,    0,    0,
    54,   54,   54,    0,    0,   54,   54,   54,    0,    0,
     0,    0,  349,    0,   54,   54,    0,   54,   54,   54,
    54,   54,   54,    0,   54,  349,   54,    0,    0,    0,
   349,    0,    0,  349,    0,  349,    0,  349,  349,  349,
   349,    0,   54,   54,    0,  349,    0,    0,  231,  349,
     0,    0,    0,  349,    0,   54,    0,    0,    0,    0,
    54,  349,    0,    0,  349,   54,  349,   54,   54,   54,
    54,    0,    0,    0,    0,   54,    0,    0,    0,   54,
     0,    0,    0,    0,    0,  349,    0,  349,    0,    0,
     0,   54,    0,  349,   54,  281,   54,  349,   54,    0,
     0,   94,   95,    0,   97,    0,    0,   98,  278,    0,
   349,    0,  102,  103,  104,    0,  106,   54,   54,   54,
     0,    0,  107,    0,   54,  109,    0,    0,    0,    0,
     0,    0,  114,    0,    0,    0,    0,  116,    0,  117,
   118,  119,  349,  563,    0,    0,    0,   54,    0,    0,
   564,    0,    0,  121,    0,  122,  123,    0,    0,  124,
    54,    0,  126,    0,  128,   54,  130,  131,  132,  279,
    54,  135,   54,   54,   54,   54,    0,    0,  565,    0,
    54,  140,  141,    0,   54,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,   54,    0,    0,   54,
     0,   54,    0,    0,  143,  840,    0,  566,    0,    0,
   145,  146,  147,  148,    0,    0,    0,  149,    0,  150,
     0,    0,   54,   54,   54,  151,  152,  214,    0,    0,
     0,    0,    0,   94,   95,    0,   97,    0,    0,   98,
   278,    0,    0,    0,  102,  103,  104,    0,  106,    0,
   153,  465,  155,  156,  107,    0,   54,  109,   54,    0,
     0,    0,    0,    0,  114,    0,    0,    0,    0,  116,
     0,  117,  118,  119,    0,  563,    0,    0,    0,   54,
     0,    0,  564,    0,    0,  121,    0,  122,  123,    0,
     0,  124,   54,    0,  126,    0,  128,   54,  130,  131,
   132,  279,   54,  135,   54,   54,   54,   54,    0,    0,
   565,    0,   54,  140,  141,    0,   54,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,   54,    0,
     0,   54,    0,   54,    0,    0,  143,    0,    0,  566,
     0,    0,  145,  146,  147,  148,    0,    0,    0,  149,
     0,  150,    0,    0,   54,    0,    0,  151,  152,  315,
     0,    0,    0,    0,    0,   94,   95,    0,   97,    0,
     0,   98,  278,    0,    0,    0,  102,  103,  104,    0,
   106,    0,  153,  465,  155,  156,  107,    0,   59,  109,
     0,    0,    0,    0,    0,    0,  114,    0,    0,    0,
     0,  116,    0,  117,  118,  119,    0,  563,    0,    0,
     0,   60,    0,    0,  564,    0,    0,  121,    0,  122,
   123,    0,    0,  124,   61,    0,  126,    0,  128,   63,
   130,  131,  132,  279,   64,  135,   65,   66,   67,   68,
     0,    0,  565,    0,   69,  140,  141,    0,   70,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    71,    0,    0,   72,    0,   73,    0,    0,  143,    0,
     0,    0,    0,    0,  145,  146,  147,  148,    0,    0,
     0,  149,    0,  150,    0,    0,   74,    0,    0,  151,
   152,    0,    0,    0,    0,    0,    0,   94,   95,    0,
    97,    0,    0,   98,  278,    0,    0,    0,  102,  103,
   104,    0,  106,    0,  153,  465,  155,  156,  107,    0,
     0,  109,    0,    0,    0,    0,    0,    0,  114,    0,
     0,    0,    0,  116,    0,  117,  118,  119,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  121,
     0,  122,  123,    0,    0,  124,    0,    0,  126,    0,
   128,    0,  130,  131,  132,  279,    0,  135,    0,    0,
   137,    0,    0,    0,  139,    0,    0,  140,  141,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   143,    0,    0,    0,    0,    0,  145,  146,  147,  148,
     0,    0,    0,  149,    0,  150,    0,    0,    0,    0,
     0,  151,  152,    0,    0,    0,    0,    0,    0,   94,
    95,    0,   97,    0,    0,   98,  278,    0,    0,    0,
   102,  103,  104,    0,  106,    0,  153,  323,  155,  156,
   107,    0,    0,  109,    0,    0,    0,    0,    0,    0,
   114,    0,    0,    0,    0,  116,    0,  117,  118,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  121,    0,  122,  123,    0,    0,  124,    0,    0,
   126,    0,  128,    0,  130,  131,  132,  279,    0,  135,
     0,    0,    0,    0,    0,    0,  139,    0,    0,  140,
   141,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  805,
     0,    0,  143,    0,    0,    0,    0,    0,  145,  146,
   147,  148,    0,    0,    0,  149,    0,  150,    0,    0,
     0,    0,    0,  151,  152,    0,    0,    0,    0,    0,
     0,   94,   95,    0,   97,    0,    0,   98,  278,    0,
     0,    0,  102,  103,  104,    0,  106,    0,  153,  323,
   155,  156,  107,    0,    0,  109,    0,    0,    0,    0,
     0,    0,  114,    0,    0,    0,    0,  116,    0,  117,
   118,  119,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  121,    0,  122,  123,    0,    0,  124,
     0,    0,  126,    0,  128,    0,  130,  131,  132,  279,
     0,  135,    0,    0,    0,    0,    0,    0,  139,    0,
     0,  140,  141,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   498,    0,    0,    0,  143,    0,    0,    0,    0,    0,
   145,  146,  147,  148,    0,    0,    0,  149,    0,  150,
     0,    0,    0,    0,    0,  151,  152,    0,    0,    0,
     0,    0,    0,   94,   95,    0,   97,    0,    0,   98,
   278,    0,    0,    0,  102,  103,  104,    0,  106,    0,
   153,  323,  155,  156,  107,    0,    0,  109,    0,    0,
     0,    0,    0,    0,  114,    0,    0,    0,    0,  116,
     0,  117,  118,  119,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  121,    0,  122,  123,    0,
     0,  124,    0,    0,  126,    0,  128,    0,  130,  131,
   132,  279,    0,  135,    0,    0,    0,    0,    0,    0,
   139,    0,    0,  140,  141,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  501,    0,    0,    0,  143,    0,    0,    0,
     0,    0,  145,  146,  147,  148,    0,    0,    0,  149,
     0,  150,    0,    0,    0,    0,    0,  151,  152,    0,
     0,    0,    0,    0,    0,   94,   95,    0,   97,    0,
     0,   98,  278,    0,    0,    0,  102,  103,  104,    0,
   106,    0,  153,  323,  155,  156,  107,    0,    0,  109,
     0,    0,    0,    0,    0,    0,  114,    0,    0,    0,
     0,  116,    0,  117,  118,  119,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  121,    0,  122,
   123,    0,    0,  124,    0,    0,  126,    0,  128,    0,
   130,  131,  132,  279,    0,  135,    0,    0,    0,    0,
     0,    0,  139,    0,    0,  140,  141,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  143,    0,
     0,    0,    0,    0,  145,  146,  147,  148,    0,    0,
     0,  149,    0,  150,    0,    0,    0,    0,    0,  151,
   152,    0,    0,    0,    0,    0,    0,   94,   95,    0,
    97,    0,    0,   98,  278,    0,    0,    0,  102,  103,
   104,    0,  106,    0,  153,  323,  155,  156,  107,    0,
     0,  109,    0,    0,    0,    0,    0,    0,  114,    0,
     0,    0,    0,  116,    0,  117,  118,  119,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  121,
     0,  122,  123,    0,    0,  124,    0,    0,  126,    0,
   128,    0,  130,  131,  132,  279,    0,  135,    0,    0,
     0,    0,    0,    0,  139,    0,    0,  140,  141,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   143,    0,    0,    0,    0,    0,  145,  146,  147,  148,
     0,    0,    0,  149,    0,  150,    0,    0,    0,    0,
     0,  151,  152,    0,    0,    0,    0,    0,    0,   94,
    95,    0,   97,    0,    0,   98,  278,    0,    0,    0,
   102,  103,  104,    0,  106,    0,  153,  457,  155,  156,
   107,    0,    0,  109,    0,    0,    0,    0,    0,    0,
   114,    0,    0,    0,    0,  116,    0,  117,  118,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  121,    0,  122,  123,    0,    0,  124,    0,    0,
   126,    0,  128,    0,  130,  131,  132,  279,    0,  135,
     0,    0,    0,    0,    0,    0,  139,    0,    0,  140,
   141,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  143,    0,    0,    0,    0,    0,  145,  146,
   147,  148,    0,    0,    0,  149,    0,  150,    0,    0,
     0,    0,    0,  151,  152,    0,    0,    0,    0,    0,
     0,   82,   82,    0,   82,    0,    0,   82,   82,    0,
     0,    0,   82,   82,   82,    0,   82,    0,  153,  465,
   155,  156,   82,    0,    0,   82,    0,    0,    0,    0,
     0,    0,   82,    0,    0,    0,    0,   82,    0,   82,
    82,   82,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,   82,    0,   82,   82,    0,    0,   82,
     0,    0,   82,    0,   82,    0,   82,   82,   82,   82,
     0,   82,    0,    0,    0,    0,    0,    0,   82,    0,
     0,   82,   82,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,   82,    0,    0,    0,    0,    0,
    82,   82,   82,   82,    0,    0,    0,   82,    0,   82,
     0,    0,    0,    0,    0,   82,   82,    0,    0,    0,
     0,    0,    0,  154,  154,    0,  154,    0,    0,  154,
   154,    0,    0,    0,  154,  154,  154,    0,  154,    0,
    82,   82,   82,   82,  154,    0,    0,  154,    0,    0,
     0,    0,    0,    0,  154,    0,    0,    0,    0,  154,
     0,  154,  154,  154,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  154,    0,  154,  154,    0,
     0,  154,    0,    0,  154,    0,  154,    0,  154,  154,
   154,  154,    0,  154,    0,    0,    0,    0,    0,    0,
   154,    0,    0,  154,  154,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  154,    0,    0,    0,
     0,    0,  154,  154,  154,  154,    0,    0, 1240,  154,
     0,  154,    0,    0,    0,    0,    0,  154,  154,    0,
     0,    0,    0,    0,    0,   94,   95,    0,   97,    0,
     0,   98,  278,    0,    0,    0,  102,  103,  104,    0,
   106,    0,  154,  154,  154,  154,  107,    0,    0,  109,
  1241,    0,    0,    0,    0,    0,  114,    0,    0,    0,
     0,  116,    0,  117,  118,  119,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  121,    0,  122,
   123,    0,    0,  124,    0,    0,  126,    0,  128,    0,
   130,  131,  132,  279,    0,  135, 1242, 1243, 1244, 1245,
     0, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253,    0,
     0, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  143,    0,
     0,    0,    0,    0,  145,  146,  147,  148,    0,    0,
     0,  149,    0,  150,    0,    0,    0,    0,    0,  151,
   152,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  642,
     0,  642,    0,  642,  153,  280,  642,  156,  642,  642,
     0,  642,    0,  642,    0,  642,    0,  642,  642,  642,
     0,    0,    0,  642,  642,    0,    0,    0,    0,  642,
     0,  642,  642,    0,    0,    0,  642,    0,    0,    0,
   642,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  642,  642,    0,  642,    0,    0,    0,  642,  642,
     0,    0,    0,    0,    0,    0,  642,  642,   94,   95,
   642,   97,    0,  642,   98,  278,    0,    0,  642,  102,
   103,  104,    0,  106,    0,    0,    0,    0,    0,  107,
     0,    0,  109,    0,    0,    0,  642,  642,    0,  114,
     0,    0,    0,    0,  116,    0,  117,  118,  119,  642,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   121,    0,  122,  123,    0,    0,  124,    0,    0,  126,
     0,  128,    0,  130,  131,  132,  279,  641,  135,  641,
     0,  137,  641,    0,  641,  641,    0,  641,    0,  641,
   642,  641,    0,  641,  641,  641,    0,    0,    0,  641,
   641,    0,    0,    0,    0,  641,    0,  641,  641,    0,
     0,  143,  641,    0,    0,    0,  641,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  641,    0,
   641,    0,    0,    0,  641,  641,    0,    0,    0,    0,
     0,    0,  641,  641,    0,    0,  641,    0,    0,  641,
     0,    0,    0,    0,  641,    0,    0,  153,  280,  641,
     0,  641,    0,    0,  641,    0,  641,  641,    0,  641,
     0,  641,    0,  641,    0,  641,  641,  641,    0,    0,
     0,  641,  641,    0,    0,  641,    0,  641,    0,  641,
   641,    0,    0,    0,  641,    0,    0,    0,  641,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   641,    0,  641,    0,    0,    0,  641,  641,    0,    0,
     0,    0,    0,    0,  641,  641,  641,   95,  641,   97,
     0,  641,   98,    0,    0, 1167,  641,  102,    0,  248,
     0,  106,    0,  249, 1168, 1169,    0,    0,    0, 1170,
   109,    0,    0,    0,    0, 1171,    0,  114,    0,   95,
     0,   97,  116,    0,   98,    0,  119, 1167,    0,  102,
     0,  248,    0,  106,    0,  249, 1168, 1169,  121,    0,
   122, 1170,  109,    0,  124,    0,    0, 1171,    0,  114,
     0,    0,  131,  132,  116,    0,  135,    0,  119, 1172,
     0,    0,    0,    0, 1173,    0,    0,    0,  641,   54,
   121,   54,  122,    0,   54,    0,  124,    0,    0,   54,
     0,    0,    0,   54,  131,  132,    0,    0,  135,    0,
     0, 1172,   54,    0,    0, 1174, 1173,    0,    0,   54,
     0,    0,    0,    0,   54,    0,    0,    0,   54,   54,
    54,   54,   54,    0,   54,    0,    0,   54,    0,   54,
    54,    0,   54,   54,    0,    0,   54,    0,    0,   54,
     0,    0,   54,    0,   54,   54, 1175,    0,   54,   54,
     0,   54,    0,    0,   54,    0,    0,    0,   54,    0,
    54,    0,   54,    0,    0,    0,    0,   54,    0,    0,
    54,    0,   54,    0,    0,    0,   54,    0, 1175,   54,
     0,    0,  171,    0,   54,   54,    0,    0,   54,    0,
     0,   54,   54,    0,   54,    0,    0,   54,    0,    0,
     0,    0,   54,    0,    0,    0,   54,    0,    0,    0,
     0,    0,    0,    0,    0,   54,    0,    0,    0,    0,
   171,    0,   54,    0,   95,    0,   97,   54,   54,   98,
     0,   54,    0,   54,  102,   54,    0,    0,  106,    0,
    54,    0,    0,   54,    0,   54,    0,  109,    0,   54,
     0,    0,   54,    0,  114,    0,    0,   54,   54,  116,
     0,   54,    0,  119,   54,  544,    0,    0,   54,    0,
     0,    0,  545,    0,    0,  121,    0,  122,   95,    0,
    97,  124,    0,   98,  546, 1093,    0,    0,  102,  131,
   132,    0,  106,  135,    0,   95,  547,   97,    0,    0,
    98,  109,    0,    0,    0,  102,    0,    0,  114,  106,
     0,    0,    0,  116,    0, 1094,    0,  119,  109,    0,
     0,    0,    0,    0,    0,  114,    0,    0,    0,  121,
   116,  122,    0,    0,  119,  124, 1095,    0,    0,    0,
     0,   54,    0,  131,  132,    0,  121,  135,  122,   95,
   255,   97,  124,    0,   98,    0,    0,    0,    0,  102,
   131,  132,    0,  106,  135,    0,   95,  507,   97,    0,
     0,   98,  109,  548,    0,    0,  102,    0,    0,  114,
   106,    0,    0,    0,  116,    0,    0,    0,  119,  109,
     0,    0,    0,    0,    0,    0,  114,    0,    0,    0,
   121,  116,  122,    0,    0,  119,  124,    0,    0,    0,
     0,    0,    0,    0,  131,  132,    0,  121,  135,  122,
    95,  255,   97,  124,    0,   98,    0,   87,    0,    0,
   102,  131,  132,    0,  106,  135,    0,  500,  255,  500,
     0,    0,  500,  109,   87,    0,    0,  500,    0,    0,
   114,  500,    0,    0,    0,  116,    0,    0,    0,  119,
   500,    0,    0,    0,    0,    0,    0,  500,    0,    0,
     0,  121,  500,  122,    0,    0,  500,  124,    0,    0,
     0,    0,    0,    0,    0,  131,  132,    0,  500,  135,
   500,  190,  547,  190,  500,    0,  190,    0,  611,    0,
     0,  190,  500,  500,    0,  190,  500,    0,  200,  500,
   200,    0,    0,  200,  190,  613,    0,    0,  200,    0,
     0,  190,  200,    0,    0,    0,  190,    0,    0,    0,
   190,  200,    0,    0,    0,    0,    0,    0,  200,    0,
     0,    0,  190,  200,  190,    0,    0,  200,  190,    0,
     0,    0,    0,    0,    0,    0,  190,  190,    0,  200,
   190,  200,  191,  190,  191,  200,    0,  191,    0,   87,
     0,    0,  191,  200,  200,    0,  191,  200,    0,    0,
   200,    0,    0,    0,    0,  191,  500,    0,    0,    0,
     0,    0,  191,    0,    0,    0,    0,  191,    0,    0,
     0,  191,    0,    0,    0,   39,    0,    0,    0,    0,
    39,    0,    0,  191,    0,  191,    0,    0,    0,  191,
     0,   39,    0,    0,    0,    0,   39,  191,  191,    0,
    39,  191,    0,   39,  191,    0,    0,    0,    0,    0,
   190,    0,    0,    0,    0,   39,   39,    0,    0,    0,
    39,   39,    0,    0,    0,    0,   39,  200,   39,   39,
    39,   39,    0,    0,    0,    0,   39,    0,    0,    0,
    39,    0,   39,    0,    0,    0,   40,    0,    0,    0,
     0,   40,   39,    0,   39,   39,    0,   39,    0,    0,
     0,   39,   40,    0,    0,    0,    0,   40,    0,    0,
     0,   40,    0,    0,   40,    0,    0,    0,   39,    0,
     0,  191,    0,   39,   39,    0,   40,   40,    0,    0,
     0,   40,   40,    0,    0,    0,    0,   40,    0,   40,
    40,   40,   40,    0,    0,    0,    0,   40,    0,    0,
     0,   40,    0,   40,    0,    0,    0,   37,    0,    0,
     0,    0,   37,   40,    0,   40,   40,    0,   40,    0,
     0,    0,   40,   37,    0,    0,    0,    0,   37,    0,
     0,    0,   37,    0,    0,   37,    0,    0,    0,   40,
     0,    0,    0,    0,   40,   40,    0,   37,   37,    0,
     0,    0,   37,   37,    0,    0,    0,    0,   37,    0,
    37,   37,   37,   37,    0,    0,    0,    0,   37,    0,
     0,    0,   37,    0,   37,    0,    0,    0,   38,    0,
     0,    0,    0,   38,   37,    0,    0,   37,    0,   37,
     0,    0,    0,   37,   38,    0,    0,    0,    0,   38,
     0,    0,    0,   38,    0,    0,   38,    0,    0,    0,
    37,    0,    0,    0,    0,   37,   37,    0,   38,   38,
     0,    0,    0,   38,   38,    0,    0,    0,    0,   38,
     0,   38,   38,   38,   38,    0,    0,    0,    0,   38,
     0,    0,   30,   38,    0,   38,    0,    0,    0,    0,
     0,    0,    0,    0,    0,   38,    0,    0,   38,    0,
    38,    0,    0,    0,   38,   30,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,   30,    0,
     0,   38,    0,   30,    0,    0,   38,   38,   30,    0,
    30,   30,   30,   30,    0,    0,   30,    0,   30,    0,
     0,    0,   30,    0,    0,    0,    0,   54,    0,    0,
     0,    0,    0,    0,   30,    0,    0,   30,   54,   30,
     0,    0,    0,   54,    0,    0,    0,   54,    0,    0,
    54,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    30,    0,   54,   54,    0,   30,   30,   54,   54,    0,
     0,    0,    0,   54,    0,   54,   54,   54,   54,    0,
     0,    0,    0,   54,    0,    0,    0,   54,    0,   54,
     0,    0,    0,    0,    0,    0,   54,    0,    0,   54,
     0,    0,   54,    0,   54,    0,    0,   54,   54,    0,
     0,    0,   54,    0,    0,    0,   54,    0,    0,   54,
     0,    0,    0,    0,    0,   54,    0,    0,    0,    0,
    41,   54,   54,    0,    0,    0,   54,   54,    0,    0,
     0,    0,   54,    0,   54,   54,   54,   54,    0,    0,
     0,    0,   54,    0,    0,   54,   54,    0,   54,    0,
     0,    0,    0,    0,    0,    0,    0,    0,   54,    0,
     0,   54,    0,   54,    0,    0,    0,   54,   54,    0,
     0,    0,    0,    0,    0,   54,    0,   54,    0,    0,
     0,   54,    0,    0,   54,    0,   54,    0,    0,   42,
     0,   54,    0,   54,   54,   54,   54,    0,   54,   54,
     0,   54,    0,    0,    0,   54,    0,    0,    0,    0,
     0,   54,    0,    0,    0,   59,   54,   54,    0,    0,
    54,   54,   54,   54,   54,   54,   54,    0,    0,   54,
     0,   54,    0,    0,    0,   54,    0,    0,   60,    0,
     0,    0,    0,   54,    0,    0,    0,   54,  314,    0,
    54,   61,   54,    0,    0,   62,   63,    0,    0,    0,
     0,   64,    0,   65,   66,   67,   68,    0,    0,    0,
     0,   69,    0,   54,    0,   70,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,   71,    0,    0,
    72,    0,   73,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,   74,
   };
   protected static  short [] yyCheck = {            76,
 {
 	oob_stack = new Stack<object> ();
 }
]]></clone_fragment>
</clone_group>
<clone_group groupid="304" nfragments="3">
<clone_fragment endline="1408" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" hamdist="0" pcid="2177" startline="1385"><![CDATA[
 
 		protected virtual bool DoResolveTypeParameters ()
 		{
 			if (CurrentTypeParameters == null)
 				return true;
 
 			if (PartialContainer != this)
 				throw new InternalErrorException ();
 
 			var base_context = new BaseContext (this);
 			foreach (TypeParameter type_param in CurrentTypeParameters) {
 				if (!type_param.ResolveConstraints (base_context)) {
 					error = true;
 					return false;
 				}
 			}
 			foreach (TypeParameter type_param in CurrentTypeParameters) {
 				if (!type_param.ResolveConstraints (base_context)) {
 					error = true;
 					return false;
 				}
 			}
 
 			if (partial_parts != null) {
 				foreach (TypeContainer part in partial_parts)
 					UpdateTypeParameterConstraints (part);
 				foreach (TypeContainer part in partial_parts)
 					UpdateTypeParameterConstraints (part);
 			}
 
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="1052" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" hamdist="11" pcid="6205" startline="1020"><![CDATA[
 
 		public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 		{
 			if (genericTypeArguments != null || genericMethodArguments != null)
 			{
 				throw new NotImplementedException();
 			}
 			// this method is inefficient, but since it isn't used we don't care
 			if ((metadataToken >> 24) == MemberRefTable.Index)
 			{
 				foreach (KeyValuePair<MemberInfo, int> kv in importedMembers)
 				{
 					if (kv.Value == metadataToken)
 					{
 						return (MethodBase)kv.Key;
 					}
 				}
 				foreach (KeyValuePair<MemberInfo, int> kv in importedMembers)
 				{
 					if (kv.Value == metadataToken)
 					{
 						return (MethodBase)kv.Key;
 					}
 				}
 			}
 			// HACK if we're given a SymbolToken, we need to convert back
 			if ((metadataToken & 0xFF000000) == 0x06000000)
 			{
 				metadataToken = -(metadataToken & 0x00FFFFFF);
 			}
 			foreach (Type type in types)
 			{
 				MethodBase method = ((TypeBuilder)type).LookupMethod(metadataToken);
 				if (method != null)
 				{
 					return method;
 				}
 			}
 			foreach (Type type in types)
 			{
 				MethodBase method = ((TypeBuilder)type).LookupMethod(metadataToken);
 				if (method != null)
 				{
 					return method;
 				}
 			}
 			return ((TypeBuilder)moduleType).LookupMethod(metadataToken);
 		}
]]></clone_fragment>
<clone_fragment endline="691" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" hamdist="9" pcid="5589" startline="653"><![CDATA[
 
 		private Assembly DefaultResolver(string refname, bool throwOnError)
 		{
 			Assembly asm = GetDynamicAssembly(refname);
 			if (asm != null)
 			{
 				return asm;
 			}
 			string fileName;
 			if (throwOnError)
 			{
 				try
 				{
 					fileName = System.Reflection.Assembly.ReflectionOnlyLoad(refname).Location;
 				}
 				catch (System.BadImageFormatException x)
 				{
 					throw new BadImageFormatException(x.Message, x);
 				}
 			}
 			else
 			{
 				try
 				{
 					fileName = System.Reflection.Assembly.ReflectionOnlyLoad(refname).Location;
 				}
 				catch (System.BadImageFormatException x)
 				{
 					throw new BadImageFormatException(x.Message, x);
 				}
 				catch (FileNotFoundException)
 				{
 					// we intentionally only swallow the FileNotFoundException, if the file exists but isn't a valid assembly,
 					// we should throw an exception
 					return null;
 				}
 			}
 			return LoadFile(fileName);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="305" nfragments="4">
<clone_fragment endline="78" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodPointerClassification.vb" hamdist="0" pcid="6757" startline="47"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Loads the method pointer onto the evalation stack.
     ''' Creates a new delegate of the specified type.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ResolvedMethod IsNot Nothing)
         Helper.Assert(m_DelegateType IsNot Nothing)
 
         If m_MethodGroup.InstanceExpression IsNot Nothing Then
             result = m_MethodGroup.InstanceExpression.GenerateCode(Info.Clone(Parent, True, False, m_MethodGroup.InstanceExpression.ExpressionType)) AndAlso result
             Emitter.EmitDup(Info)
         Else
             Emitter.EmitLoadNull(Info.Clone(Parent, True, False, Compiler.TypeCache.System_Object))
         End If
 
         Emitter.EmitLoadVftn(Info, m_ResolvedMethod)
 
         Dim ctor As Mono.Cecil.MethodReference
         Dim dT As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(m_DelegateType)
         ctor = CecilHelper.FindConstructor(dT.Methods, False, New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Object, Compiler.TypeCache.System_IntPtr})
         ctor = CecilHelper.GetCorrectMember(ctor, m_DelegateType)
         Emitter.EmitNew(Info, ctor)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1018" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="13" pcid="7601" startline="980"><![CDATA[
 
     ''' <summary>
     ''' Creates an integer array of the arguments.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Arguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitIntegerArray(ByVal Info As EmitInfo, ByVal Arguments As ArgumentList) As Boolean
         Dim result As Boolean = True
 
         Dim arrayType As Mono.Cecil.TypeReference = Info.Compiler.TypeCache.System_Int32_Array
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arrayType)
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, arrayType)
         Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, elementType)
 
         'Create the array.
         ArrayCreationExpression.EmitArrayCreation(Info, arrayType, New Generic.List(Of Integer)(New Integer() {Arguments.Count}))
 
         'Save it into a temporary variable.
         Emitter.EmitStoreVariable(Info, tmpVar)
 
         'Store every element into its index in the array.
         For i As Integer = 0 To Arguments.Count - 1
             'Load the array variable.
             Emitter.EmitLoadVariable(Info, tmpVar)
             Emitter.EmitLoadI4Value(Info, i)
             'Load all the indices.
             result = Arguments(i).GenerateCode(elementInfo) AndAlso result
             'Store the element in the arry.
             Emitter.EmitStoreElement(elementInfo, elementType, arrayType)
             'Increment the indices.
         Next
 
         'Load the final array onto the stack.
         Emitter.EmitLoadVariable(Info, tmpVar)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="979" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="2" pcid="7599" startline="941"><![CDATA[
 
     ''' <summary>
     ''' Creates an integer array of the arguments.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Arguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitIntegerArray(ByVal Info As EmitInfo, ByVal Arguments As Expression()) As Boolean
         Dim result As Boolean = True
 
         Dim arrayType As Mono.Cecil.TypeReference = Info.Compiler.TypeCache.System_Int32_Array
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arrayType)
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, arrayType)
         Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, elementType)
 
         'Create the array.
         ArrayCreationExpression.EmitArrayCreation(Info, arrayType, New Generic.List(Of Integer)(New Integer() {Arguments.Length}))
 
         'Save it into a temporary variable.
         Emitter.EmitStoreVariable(Info, tmpVar)
 
         'Store every element into its index in the array.
         For i As Integer = 0 To Arguments.Length - 1
             'Load the array variable.
             Emitter.EmitLoadVariable(Info, tmpVar)
             Emitter.EmitLoadI4Value(Info, i)
             'Load all the indices.
             result = Arguments(i).GenerateCode(elementInfo) AndAlso result
             'Store the element in the arry.
             Emitter.EmitStoreElement(elementInfo, elementType, arrayType)
             'Increment the indices.
         Next
 
         'Load the final array onto the stack.
         Emitter.EmitLoadVariable(Info, tmpVar)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="180" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ArrayElementInitializer.vb" hamdist="13" pcid="8307" startline="107"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim arraytype As Mono.Cecil.TypeReference = Info.DesiredType
         Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arraytype)
         Dim tmpvar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Compiler, arraytype))
         Dim elementInfo As EmitInfo = Info.Clone(Me, True, False, elementtype)
         Dim indexInfo As EmitInfo = Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)
 
         'Create the array.
         ArrayCreationExpression.EmitArrayCreation(Info, arraytype, m_Elements)
 
         'Save it into a temporary variable.
         Emitter.EmitStoreVariable(Info, tmpvar)
 
         'Calculate the total number of elements.
         Dim elements As Integer = 1
         For i As Integer = 0 To m_Elements.Count - 1
             elements *= m_Elements(i)
         Next
         If m_Elements.Count = 0 AndAlso elements = 1 Then elements = 0
 
         'Create a list of the current indices.
         Dim indices As New Generic.List(Of Integer)
         For i As Integer = 0 To m_Elements.Count - 1
             indices.Add(0)
         Next
 
         'Get the set method, if it is a multidimensional array.
         Dim method As Mono.Cecil.MethodReference = Nothing
         If m_Elements.Count > 1 Then
             method = GetSetMethod(Compiler, arraytype)
         End If
 
         'Store every element into its index in the array.
         For i As Integer = 1 To elements
             'Load the array variable.
             Emitter.EmitLoadVariable(Info, tmpvar)
             'Load all the indices.
             For j As Integer = 0 To indices.Count - 1
                 Emitter.EmitLoadI4Value(indexInfo, indices(j))
             Next
             If CecilHelper.IsValueType(elementtype) AndAlso CecilHelper.IsPrimitive(Compiler, elementtype) = False AndAlso Helper.IsEnum(Compiler, elementtype) = False Then
                 Emitter.EmitLoadElementAddress(Info, elementtype, arraytype)
             End If
             'Get the element expression.
             Dim elementExpression As Expression
             elementExpression = GetRegularInitializer(indices)
             'Generate the element expression
             result = elementExpression.GenerateCode(elementInfo) AndAlso result
             'Store the element in the arry.
             If m_Elements.Count > 1 Then
                 Emitter.EmitCallVirt(elementInfo, method)
             Else
                 Emitter.EmitStoreElement(elementInfo, elementtype, arraytype)
             End If
             'Increment the indices.
             For j As Integer = indices.Count - 1 To 0 Step -1
                 If indices(j) + 1 = m_Elements(j) Then
                     indices(j) = 0
                 Else
                     indices(j) += 1
                     Exit For
                 End If
             Next
         Next
 
         'Load the final array onto the stack.
         Emitter.EmitLoadVariable(Info, tmpvar)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="306" nfragments="2">
<clone_fragment endline="2356" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" hamdist="0" pcid="3051" startline="2328"><![CDATA[
 		{
 			var tp = t as TypeParameterSpec;
 			if (tp != null) {
 				Variance v = tp.Variance;
 				if (expected == Variance.None && v != expected ||
 					expected == Variance.Covariant && v == Variance.Contravariant ||
 					expected == Variance.Contravariant && v == Variance.Covariant) {
 					((TypeParameter)tp.MemberDefinition).ErrorInvalidVariance (member, expected);
 				}
 
 				return expected;
 			}
 
 			if (t.TypeArguments.Length > 0) {
 				var targs_definition = t.MemberDefinition.TypeParameters;
 				TypeSpec[] targs = GetTypeArguments (t);
 				for (int i = 0; i < targs.Length; ++i) {
 					Variance v = targs_definition[i].Variance;
 					CheckTypeVariance (targs[i], (Variance) ((int)v * (int)expected), member);
 				}
 				for (int i = 0; i < targs.Length; ++i) {
 					Variance v = targs_definition[i].Variance;
 					CheckTypeVariance (targs[i], (Variance) ((int)v * (int)expected), member);
 				}
 
 				return expected;
 			}
 
 			if (t.IsArray)
 				return CheckTypeVariance (GetElementType (t), expected, member);
 
 			return Variance.None;
 		}
]]></clone_fragment>
<clone_fragment endline="2376" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" hamdist="8" pcid="4173" startline="2323"><![CDATA[
 	}
 
 	public partial class TypeManager
 	{
 		public static Variance CheckTypeVariance (TypeSpec t, Variance expected, IMemberContext member)
 		{
 			var tp = t as TypeParameterSpec;
 			if (tp != null) {
 				Variance v = tp.Variance;
 				if (expected == Variance.None && v != expected ||
 					expected == Variance.Covariant && v == Variance.Contravariant ||
 					expected == Variance.Contravariant && v == Variance.Covariant) {
 					((TypeParameter)tp.MemberDefinition).ErrorInvalidVariance (member, expected);
 				}
 
 				return expected;
 			}
 
 			if (t.TypeArguments.Length > 0) {
 				var targs_definition = t.MemberDefinition.TypeParameters;
 				TypeSpec[] targs = GetTypeArguments (t);
 				for (int i = 0; i < targs.Length; ++i) {
 					Variance v = targs_definition[i].Variance;
 					CheckTypeVariance (targs[i], (Variance) ((int)v * (int)expected), member);
 				}
 
 				return expected;
 			}
 
 			if (t.IsArray)
 				return CheckTypeVariance (GetElementType (t), expected, member);
 
 			return Variance.None;
 		}
 	}
 
 	//
 	// Implements C# type inference
 	//
 	class TypeInference
 	{
 		//
 		// Tracks successful rate of type inference
 		//
 		int score = int.MaxValue;
 		readonly Arguments arguments;
 		readonly int arg_count;
 
 		public TypeInference (Arguments arguments)
 		{
 			this.arguments = arguments;
 			if (arguments != null)
 				arg_count = arguments.Count;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="307" nfragments="7">
<clone_fragment endline="1169" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="0" pcid="8189" startline="1137"><![CDATA[
 
     Public Shared Function ConvertToDouble(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 result = CDbl(DirectCast(Source, Boolean))
                 Return True
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Double")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30532, Context.Location)
             Case TypeCode.Decimal
                 result = CDbl(DirectCast(Source, Decimal))
                 Return True
             Case TypeCode.Double
                 result = Source
                 Return True
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 result = CDbl(CLng(Source))
                 Return True
             Case TypeCode.Single
                 result = CDbl(DirectCast(Source, Single))
                 Return True
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Double")
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 result = CDbl(CULng(Source))
                 Return True
             Case TypeCode.DBNull
                 result = 0.0R
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Double")
     End Function
]]></clone_fragment>
<clone_fragment endline="1422" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="6" pcid="8199" startline="1387"><![CDATA[
 
     Public Shared Function ConvertToSingle(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 result = CSng(DirectCast(Source, Boolean))
                 Return True
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Single")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "Single")
             Case TypeCode.Decimal
                 result = CSng(DirectCast(Source, Decimal))
                 Return True
             Case TypeCode.Double
                 Dim i As Double = DirectCast(Source, Double)
                 If i >= Single.MinValue AndAlso i <= Single.MaxValue Then
                     result = CSng(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 result = CSng(CLng(Source))
                 Return True
             Case TypeCode.Single
                 result = Source
                 Return True
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Single")
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 result = CSng(CULng(Source))
                 Return True
             Case TypeCode.DBNull
                 result = 0.0!
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Single")
     End Function
]]></clone_fragment>
<clone_fragment endline="1598" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="8" pcid="8207" startline="1554"><![CDATA[
 
     Public Shared Function ConvertToUInt64(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "ULong"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CULng(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0UL
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]></clone_fragment>
<clone_fragment endline="928" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="10" pcid="8179" startline="878"><![CDATA[
 
     Public Shared Function ConvertToBoolean(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 result = Source
                 Return True
             Case TypeCode.Byte
                 result = CBool(DirectCast(Source, Byte))
                 Return True
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Boolean")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "Boolean")
             Case TypeCode.Decimal
                 result = CBool(DirectCast(Source, Decimal))
                 Return True
             Case TypeCode.Double
                 result = CBool(DirectCast(Source, Double))
                 Return True
             Case TypeCode.Int16
                 result = CBool(DirectCast(Source, Short))
                 Return True
             Case TypeCode.Int32
                 result = CBool(DirectCast(Source, Integer))
                 Return True
             Case TypeCode.Int64
                 result = CBool(DirectCast(Source, Long))
                 Return True
             Case TypeCode.SByte
                 result = CBool(DirectCast(Source, SByte))
                 Return True
             Case TypeCode.Single
                 result = CBool(DirectCast(Source, Single))
                 Return True
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Byte", "String")
             Case TypeCode.UInt16
                 result = CBool(DirectCast(Source, UShort))
                 Return True
             Case TypeCode.UInt32
                 result = CBool(DirectCast(Source, UInteger))
                 Return True
             Case TypeCode.UInt64
                 result = CBool(DirectCast(Source, ULong))
                 Return True
             Case TypeCode.DBNull
                 result = CBool(Nothing)
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Boolean")
     End Function
]]></clone_fragment>
<clone_fragment endline="1259" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="9" pcid="8193" startline="1215"><![CDATA[
 
     Public Shared Function ConvertToInt32(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "Integer"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CInt(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0I
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]></clone_fragment>
<clone_fragment endline="1214" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="3" pcid="8191" startline="1170"><![CDATA[
 
     Public Shared Function ConvertToInt16(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Const DEST As String = "Short"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CShort(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0S
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]></clone_fragment>
<clone_fragment endline="1386" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="11" pcid="8197" startline="1305"><![CDATA[
 
     Public Shared Function ConvertToSByte(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CSByte(i)
                 Return True
             Case TypeCode.Byte
                 Dim i As Byte = DirectCast(Source, Byte)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, "SByte")
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "SByte")
             Case TypeCode.Decimal
                 Dim i As Decimal = DirectCast(Source, Decimal)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Double
                 Dim i As Double = DirectCast(Source, Double)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Int16
                 Dim i As Short = DirectCast(Source, Short)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Int32
                 Dim i As Integer = DirectCast(Source, Integer)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Int64
                 Dim i As Long = DirectCast(Source, Long)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.SByte
                 result = Source
                 Return True
             Case TypeCode.Single
                 Dim i As Single = DirectCast(Source, Single)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "SByte", "String")
             Case TypeCode.UInt16
                 Dim i As UShort = DirectCast(Source, UShort)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.UInt32
                 Dim i As UInteger = DirectCast(Source, UInteger)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.UInt64
                 Dim i As ULong = DirectCast(Source, ULong)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.DBNull
                 result = CSByte(0)
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "SByte")
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="308" nfragments="2">
<clone_fragment endline="421" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" hamdist="0" pcid="8269" startline="384"><![CDATA[
 
     Function TypeToKeyword(ByVal Type As Mono.Cecil.TypeReference) As KS
         If Helper.CompareType(Type, Compiler.TypeCache.System_Boolean) Then
             Return KS.Boolean
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Byte) Then
             Return KS.Byte
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Char) Then
             Return KS.Char
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_DateTime) Then
             Return KS.Date
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Decimal) Then
             Return KS.Decimal
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Double) Then
             Return KS.Double
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int32) Then
             Return KS.Integer
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int64) Then
             Return KS.Long
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Object) Then
             Return KS.Object
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int16) Then
             Return KS.Short
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Single) Then
             Return KS.Single
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_String) Then
             Return KS.String
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_SByte) Then
             Return KS.[SByte]
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) Then
             Return KS.[UShort]
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) Then
             Return KS.[UInteger]
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt64) Then
             Return KS.[ULong]
         Else
             Return KS.None
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="419" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="12" pcid="7545" startline="380"><![CDATA[
 
     Shared Function GetTypeCode(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As TypeCode
         If Helper.IsEnum(Compiler, Type) Then
             Return GetTypeCode(Compiler, Helper.GetEnumType(Compiler, Type))
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Byte) Then
             Return TypeCode.Byte
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Boolean) Then
             Return TypeCode.Boolean
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Char) Then
             Return TypeCode.Char
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_DateTime) Then
             Return TypeCode.DateTime
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_DBNull) Then
             Return TypeCode.DBNull
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Decimal) Then
             Return TypeCode.Decimal
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Double) Then
             Return TypeCode.Double
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int16) Then
             Return TypeCode.Int16
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int32) Then
             Return TypeCode.Int32
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int64) Then
             Return TypeCode.Int64
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_SByte) Then
             Return TypeCode.SByte
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Single) Then
             Return TypeCode.Single
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_String) Then
             Return TypeCode.String
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) Then
             Return TypeCode.UInt16
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) Then
             Return TypeCode.UInt32
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt64) Then
             Return TypeCode.UInt64
         Else
             Return TypeCode.Object
         End If
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="309" nfragments="2">
<clone_fragment endline="115" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\modifiers.cs" hamdist="0" pcid="155" startline="78"><![CDATA[
 
 		static public string Name (Modifiers i)
 		{
 			string s = "";
 			
 			switch (i) {
 			case Modifiers.NEW
 				s = "new"; break;
 			case Modifiers.PUBLIC
 				s = "public"; break;
 			case Modifiers.PROTECTED
 				s = "protected"; break;
 			case Modifiers.INTERNAL
 				s = "internal"; break;
 			case Modifiers.PRIVATE
 				s = "private"; break;
 			case Modifiers.ABSTRACT
 				s = "abstract"; break;
 			case Modifiers.SEALED
 				s = "sealed"; break;
 			case Modifiers.STATIC
 				s = "static"; break;
 			case Modifiers.READONLY
 				s = "readonly"; break;
 			case Modifiers.VIRTUAL
 				s = "virtual"; break;
 			case Modifiers.OVERRIDE
 				s = "override"; break;
 			case Modifiers.EXTERN
 				s = "extern"; break;
 			case Modifiers.VOLATILE
 				s = "volatile"; break;
 			case Modifiers.UNSAFE
 				s = "unsafe"; break;
 			}
 
 			return s;
 		}
]]></clone_fragment>
<clone_fragment endline="2165" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="12" pcid="3709" startline="2091"><![CDATA[
 		}
 
 		#endregion
 
 		/// <summary>
 		///   Returns a stringified representation of the Operator
 		/// </summary>
 		string OperName (Operator oper)
 		{
 			string s;
 			switch (oper){
 			case Operator.Multiply
 				s = "*";
 				break;
 			case Operator.Division
 				s = "/";
 				break;
 			case Operator.Modulus
 				s = "%";
 				break;
 			case Operator.Addition
 				s = "+";
 				break;
 			case Operator.Subtraction
 				s = "-";
 				break;
 			case Operator.LeftShift
 				s = "<<";
 				break;
 			case Operator.RightShift
 				s = ">>";
 				break;
 			case Operator.LessThan
 				s = "<";
 				break;
 			case Operator.GreaterThan
 				s = ">";
 				break;
 			case Operator.LessThanOrEqual
 				s = "<=";
 				break;
 			case Operator.GreaterThanOrEqual
 				s = ">=";
 				break;
 			case Operator.Equality
 				s = "==";
 				break;
 			case Operator.Inequality
 				s = "!=";
 				break;
 			case Operator.BitwiseAnd
 				s = "&";
 				break;
 			case Operator.BitwiseOr
 				s = "|";
 				break;
 			case Operator.ExclusiveOr
 				s = "^";
 				break;
 			case Operator.LogicalOr
 				s = "||";
 				break;
 			case Operator.LogicalAnd
 				s = "&&";
 				break;
 			default
 				s = oper.ToString ();
 				break;
 			}
 
 			if (IsCompound)
 				return s + "=";
 
 			return s;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="310" nfragments="2">
<clone_fragment endline="360" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" hamdist="0" pcid="5897" startline="323"><![CDATA[
 
 		private ExceptionBlock BeginFinallyFilterFaultBlock()
 		{
 			ExceptionBlock block = exceptionStack.Peek();
 			if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
 			{
 				Emit(OpCodes.Leave, block.labelEnd);
 			}
 			if (block.handlerOffset == 0)
 			{
 				block.tryLength = code.Position - block.tryOffset;
 			}
 			else
 			{
 				block.handlerLength = code.Position - block.handlerOffset;
 				Label labelEnd;
 				if (exceptionBlockAssistanceMode != EBAM_COMPAT)
 				{
 					labelEnd = block.labelEnd;
 				}
 				else
 				{
 					MarkLabel(block.labelEnd);
 					labelEnd = DefineLabel();
 					Emit(OpCodes.Leave, labelEnd);
 				}
 				exceptionStack.Pop();
 				ExceptionBlock newBlock = new ExceptionBlock(exceptions.Count);
 				newBlock.labelEnd = labelEnd;
 				newBlock.tryOffset = block.tryOffset;
 				newBlock.tryLength = code.Position - block.tryOffset;
 				block = newBlock;
 				exceptions.Add(block);
 				exceptionStack.Push(block);
 			}
 			stackHeight = 0;
 			return block;
 		}
]]></clone_fragment>
<clone_fragment endline="291" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" hamdist="13" pcid="5889" startline="255"><![CDATA[
 		}
 
 		public void BeginCatchBlock(Type exceptionType)
 		{
 			ExceptionBlock block = exceptionStack.Peek();
 			if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
 			{
 				if (exceptionType == null)
 				{
 					Emit(OpCodes.Endfilter);
 				}
 				else
 				{
 					Emit(OpCodes.Leave, block.labelEnd);
 				}
 			}
 			stackHeight = 0;
 			UpdateStack(1);
 			if (block.tryLength == 0)
 			{
 				block.tryLength = code.Position - block.tryOffset;
 			}
 			else if (exceptionType != null)
 			{
 				block.handlerLength = code.Position - block.handlerOffset;
 				exceptionStack.Pop();
 				ExceptionBlock newBlock = new ExceptionBlock(exceptions.Count);
 				newBlock.labelEnd = block.labelEnd;
 				newBlock.tryOffset = block.tryOffset;
 				newBlock.tryLength = block.tryLength;
 				block = newBlock;
 				exceptions.Add(block);
 				exceptionStack.Push(block);
 			}
 			block.handlerOffset = code.Position;
 			block.exceptionType = exceptionType;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="311" nfragments="4">
<clone_fragment endline="78" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" hamdist="0" pcid="7169" startline="41"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim arguments As ArgumentList = New ArgumentList(Me.Parent)
 
         If m_MethodGroup.Resolved = False Then
             result = m_MethodGroup.ResolveGroup(arguments) AndAlso result
         Else
             'm_FinalArguments = m_MethodGroup.
         End If
 
         If result = False Then
             result = m_MethodGroup.ResolveGroup(arguments, True) AndAlso result
             Return False
         End If
 
         Helper.Assert(m_MethodGroup.ResolvedMethod IsNot Nothing)
 
         If m_MethodGroup.ResolvedMethodInfo IsNot Nothing Then
             m_ExpressionType = m_MethodGroup.ResolvedMethodInfo.ReturnType
         ElseIf m_MethodGroup.ResolvedConstructor IsNot Nothing Then
             m_ExpressionType = m_MethodGroup.ResolvedConstructor.DeclaringType
         Else
             Throw New InternalException(Me)
         End If
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         If Helper.CompareType(Compiler.TypeCache.System_Void, m_ExpressionType) Then
             Me.Classification = New VoidClassification(Me)
             result = ReportReclassifyToValueErrorMessage()
         Else
             Me.Classification = New ValueClassification(Me)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="117" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\MethodPointerClassification.vb" hamdist="9" pcid="6759" startline="79"><![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Resolve(ByVal DelegateType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(DelegateType IsNot Nothing)
 
         If Helper.CompareType(DelegateType, Compiler.TypeCache.DelegateUnresolvedType) Then
             m_DelegateType = DelegateType
             Return True
         End If
 
         If Helper.IsDelegate(Compiler, DelegateType) = False Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30581, Me.Parent.Location, DelegateType.FullName) AndAlso result
         End If
 
         If result = False Then Return result
 
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition) = Helper.GetDelegateArguments(Compiler, DelegateType)
         Dim paramtypes() As Mono.Cecil.TypeReference = Helper.GetParameterTypes(params)
 
         m_ResolvedMethod = CType(Helper.ResolveGroupExact(Me.Parent, m_MethodGroup.Group, paramtypes), Mono.Cecil.MethodReference)
         m_DelegateType = DelegateType
 
         If m_ResolvedMethod Is Nothing Then
             For i As Integer = 0 To m_MethodGroup.Group.Count - 1
                 Compiler.Report.ShowMessage(Messages.VBNC30408, Me.Parent.Location, Helper.ToString(Me.Parent, m_MethodGroup.Group(i)), Helper.ToString(Me.Parent, DelegateType))
             Next
             result = False
         End If
 
         m_Resolved = True
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="222" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" hamdist="15" pcid="9949" startline="148"><![CDATA[
 
     Function Resolve() As Boolean
         Dim result As Boolean = True
         Dim tmp As TypeNameResolutionInfo
 
         Dim glob As GlobalExpression = TryCast(Name, GlobalExpression)
         Dim id As Identifier = TryCast(Name, Identifier)
         Dim qi As QualifiedIdentifier = TryCast(Name, QualifiedIdentifier)
         Dim ctn As ConstructedTypeName = TryCast(Name, ConstructedTypeName)
 
         If ctn IsNot Nothing Then
             qi = ctn.QualifiedIdentifier
             Helper.Assert(TypeArgumentCount > 0)
         End If
 
         If qi IsNot Nothing Then
             If qi.IsFirstQualifiedIdentifier Then
                 If Token.IsSomething(qi.Second) Then
                     tmp = New TypeNameResolutionInfo(qi.FirstAsQualifiedIdentifier, FromWhere, 0)
                 Else
                     tmp = New TypeNameResolutionInfo(qi.FirstAsQualifiedIdentifier, FromWhere, Me.TypeArgumentCount)
                     tmp.IsAttributeTypeName = Me.IsAttributeTypeName
                 End If
                 'Helper.Assert(qi.Second IsNot Nothing) 'A qualified identifier can perfectly be only an identifier
             ElseIf qi.IsFirstGlobal Then
                 Helper.Assert(TypeArgumentCount = 0)
                 tmp = New TypeNameResolutionInfo(qi.FirstAsGlobal, FromWhere)
                 'Helper.Assert(qi.Second IsNot Nothing)
             ElseIf qi.IsFirstIdentifier Then
                 If Token.IsSomething(qi.Second) = False Then
                     tmp = New TypeNameResolutionInfo(qi.FirstAsIdentifier, FromWhere, Me.TypeArgumentCount)
                     tmp.IsAttributeTypeName = Me.IsAttributeTypeName
                 Else
                     tmp = New TypeNameResolutionInfo(qi.FirstAsIdentifier, FromWhere, 0)
                 End If
             Else
                 Throw New InternalException(FromWhere)
             End If
 
             tmp.IsImportsResolution = Me.IsImportsResolution
             result = tmp.Resolve AndAlso result
             If result = False Then Return result
 
             If Token.IsSomething(qi.Second) = False Then
                 Me.m_FoundObjects = tmp.m_FoundObjects
             Else
                 If Me.IsAttributeTypeName Then
                     result = ResolveQualifiedName(tmp, qi.Second.IdentiferOrKeywordIdentifier & "Attribute", qi.Second.IdentiferOrKeywordIdentifier, Me.TypeArgumentCount) AndAlso result
                 Else
                     result = ResolveQualifiedName(tmp, qi.Second.IdentiferOrKeywordIdentifier, Nothing, Me.TypeArgumentCount) AndAlso result
                 End If
             End If
         ElseIf glob IsNot Nothing Then
             m_FoundObjects.Add(glob)
             result = True
         ElseIf id IsNot Nothing Then
             If Me.IsImportsResolution Then
                 result = Me.CheckOutermostNamespace(id.Name, Me.TypeArgumentCount) AndAlso result
             Else
                 Dim names() As String
                 If Me.IsAttributeTypeName Then
                     names = New String() {id.Name & "Attribute", id.Name}
                 Else
                     names = New String() {id.Name}
                 End If
                 result = ResolveUnqualifiedName(names, Me.TypeArgumentCount) AndAlso result
             End If
         ElseIf ctn IsNot Nothing Then
             Return Name.Compiler.Report.ShowMessage(Messages.VBNC99997, Name.Location)
         Else
             Return Name.Compiler.Report.ShowMessage(Messages.VBNC99997, Name.Location)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="223" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\DelegateOrObjectCreationExpression.vb" hamdist="11" pcid="7025" startline="132"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_NonArrayTypeName IsNot Nothing Then result = m_NonArrayTypeName.ResolveCode(Info) AndAlso result
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveCode(Info) AndAlso result
 
         Helper.Assert(m_ResolvedType IsNot Nothing)
         If m_IsDelegateCreationExpression = False Then
             If TypeOf m_ResolvedType Is Mono.Cecil.GenericParameter = False Then
                 m_IsDelegateCreationExpression = Helper.CompareType(CecilHelper.FindDefinition(m_ResolvedType).BaseType, Compiler.TypeCache.System_MulticastDelegate)
             End If
         End If
 
         If m_ArgumentList IsNot Nothing Then
             result = m_ArgumentList.ResolveCode(Info) AndAlso result
         Else
             m_ArgumentList = New ArgumentList(Me)
         End If
 
         If result = False Then Return result
 
         If m_IsDelegateCreationExpression Then
             Dim type As Mono.Cecil.TypeReference = m_ResolvedType
             If m_ArgumentList.Count <> 1 Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC32008, Me.Location, type.FullName) AndAlso result
             End If
             If result AndAlso m_ArgumentList(0).Expression.Classification.IsMethodPointerClassification = False Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC32008, Me.Location, type.FullName) AndAlso result
             End If
             If result Then
                 result = m_ArgumentList(0).Expression.ResolveAddressOfExpression(type) AndAlso result
                 Classification = New ValueClassification(Me, type)
             End If
         Else
             Dim resolvedType As Mono.Cecil.TypeReference = m_ResolvedType
             Dim isCoClass As Boolean = False
 
             If CecilHelper.IsInterface(resolvedType) Then
                 Dim coClass As TypeReference = Helper.GetCoClassType(Compiler, resolvedType)
                 If coClass Is Nothing Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30375, Me.Location)
                 Else
                     m_ResolvedType = coClass
                     resolvedType = m_ResolvedType
 
                     If CecilHelper.IsValueType(resolvedType) = False AndAlso CecilHelper.IsClass(resolvedType) = False Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC31094, Me.Location, resolvedType.Name)
                     End If
 
                     Dim ctors As Mono.Collections.Generic.Collection(Of MethodReference)
                     ctors = CecilHelper.GetConstructors(resolvedType)
                     If ctors Is Nothing OrElse ctors.Count = 0 Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30251, Me.Location, resolvedType.Name)
                     End If
                     isCoClass = True
                 End If
             End If
 
             If isCoClass = False AndAlso CecilHelper.IsValueType(resolvedType) AndAlso m_ArgumentList.Count = 0 Then
                 'Nothing to resolve. A structure with no parameters can always be created.
                 m_IsValueTypeInitializer = True
             ElseIf CecilHelper.IsGenericParameter(resolvedType) Then
                 If m_ArgumentList.Count > 0 Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC32085, Me.Location)
                 End If
                 If (CecilHelper.GetGenericParameterAttributes(resolvedType) And Mono.Cecil.GenericParameterAttributes.DefaultConstructorConstraint) = 0 AndAlso (CecilHelper.GetGenericParameterAttributes(resolvedType) And Mono.Cecil.GenericParameterAttributes.NotNullableValueTypeConstraint) = 0 Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC32046, Me.Location)
                 End If
                 m_IsGenericConstructor = True
             ElseIf CecilHelper.IsClass(resolvedType) OrElse CecilHelper.IsValueType(resolvedType) Then
                 Dim ctors As Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference)
 
                 ctors = CecilHelper.GetConstructors(resolvedType)
                 m_MethodClassification = New MethodGroupClassification(Me, Nothing, Nothing, Nothing, ctors)
                 result = m_MethodClassification.AsMethodGroupClassification.ResolveGroup(m_ArgumentList) AndAlso result
                 If result = False Then
                     'Show the error
                     result = m_MethodClassification.AsMethodGroupClassification.ResolveGroup(m_ArgumentList, True) AndAlso result
                 Else
                     result = m_ArgumentList.ReplaceAndVerifyArguments(m_MethodClassification.FinalArguments, m_MethodClassification.ResolvedMethod) AndAlso result
                 End If
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, String.Format("Delegate type {0} is neither ValueType, GenericParameter nor Class. This is a problem in the compiler, please file a bug report here
             End If
 
             Classification = New ValueClassification(Me, resolvedType)
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="312" nfragments="2">
<clone_fragment endline="143" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" hamdist="0" pcid="4447" startline="106"><![CDATA[
 		public int LineNumberTable_LineBase = LineNumberTable.Default_LineBase;
 		public int LineNumberTable_LineRange = LineNumberTable.Default_LineRange;
 		public int LineNumberTable_OpcodeBase = LineNumberTable.Default_OpcodeBase;
 		#endregion
 
 		internal OffsetTable ()
 		{
 			int platform = (int) Environment.OSVersion.Platform;
 			if ((platform != 4) && (platform != 128))
 				FileFlags |= Flags.WindowsFileNames;
 		}
 
 		internal OffsetTable (BinaryReader reader, int major_version, int minor_version)
 		{
 			TotalFileSize = reader.ReadInt32 ();
 			DataSectionOffset = reader.ReadInt32 ();
 			DataSectionSize = reader.ReadInt32 ();
 			CompileUnitCount = reader.ReadInt32 ();
 			CompileUnitTableOffset = reader.ReadInt32 ();
 			CompileUnitTableSize = reader.ReadInt32 ();
 			SourceCount = reader.ReadInt32 ();
 			SourceTableOffset = reader.ReadInt32 ();
 			SourceTableSize = reader.ReadInt32 ();
 			MethodCount = reader.ReadInt32 ();
 			MethodTableOffset = reader.ReadInt32 ();
 			MethodTableSize = reader.ReadInt32 ();
 			TypeCount = reader.ReadInt32 ();
 
 			AnonymousScopeCount = reader.ReadInt32 ();
 			AnonymousScopeTableOffset = reader.ReadInt32 ();
 			AnonymousScopeTableSize = reader.ReadInt32 ();
 
 			LineNumberTable_LineBase = reader.ReadInt32 ();
 			LineNumberTable_LineRange = reader.ReadInt32 ();
 			LineNumberTable_OpcodeBase = reader.ReadInt32 ();
 
 			FileFlags = (Flags) reader.ReadInt32 ();
 		}
]]></clone_fragment>
<clone_fragment endline="1069" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" hamdist="12" pcid="4525" startline="1033"><![CDATA[
 		}
 
 		[Flags]
 		public enum Flags
 		{
 			LocalNamesAmbiguous	= 1
 		}
 
 		public const int Size = 12;
 
 		internal MethodEntry (MonoSymbolFile file, MyBinaryReader reader, int index)
 		{
 			this.SymbolFile = file;
 			this.index = index;
 
 			Token = reader.ReadInt32 ();
 			DataOffset = reader.ReadInt32 ();
 			LineNumberTableOffset = reader.ReadInt32 ();
 
 			long old_pos = reader.BaseStream.Position;
 			reader.BaseStream.Position = DataOffset;
 
 			CompileUnitIndex = reader.ReadLeb128 ();
 			LocalVariableTableOffset = reader.ReadLeb128 ();
 			NamespaceID = reader.ReadLeb128 ();
 
 			CodeBlockTableOffset = reader.ReadLeb128 ();
 			ScopeVariableTableOffset = reader.ReadLeb128 ();
 
 			RealNameOffset = reader.ReadLeb128 ();
 
 			flags = (Flags) reader.ReadLeb128 ();
 
 			reader.BaseStream.Position = old_pos;
 
 			CompileUnit = file.GetCompileUnit (CompileUnitIndex);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="313" nfragments="2">
<clone_fragment endline="161" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingDeclarator.vb" hamdist="0" pcid="9531" startline="124"><![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         'TODO
         If m_ArgumentList IsNot Nothing Then
             result = m_ArgumentList.ResolveCode(Info) AndAlso result
         End If
 
         If m_TypeName IsNot Nothing Then
             UsingVariableType = m_TypeName.ResolvedType
             m_IsVariableDeclaration = True
             If m_IsNew Then
                 Dim grp As New MethodGroupClassification(Me, Nothing, Nothing, Nothing, CecilHelper.GetConstructors(CecilHelper.FindDefinition(m_TypeName.ResolvedType)))
                 result = grp.ResolveGroup(m_ArgumentList) AndAlso result
                 m_Constructor = grp.ResolvedConstructor
                 If m_Constructor Is Nothing Then
                     result = Helper.AddError(Me) AndAlso result
                 End If
             End If
         ElseIf m_VariableInitializer IsNot Nothing Then
             UsingVariableType = Compiler.TypeCache.System_Object
             m_IsVariableDeclaration = True
         Else
             Helper.Assert(m_ArgumentList Is Nothing)
             'Helper.Assert(m_Identifier IsNot Nothing)
             m_IsVariableDeclaration = False
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
 
         If m_VariableInitializer IsNot Nothing Then
             Dim expInfo As ExpressionResolveInfo
             expInfo = New ExpressionResolveInfo(Compiler, UsingVariableType)
             result = m_VariableInitializer.ResolveCode(expInfo) AndAlso result
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="268" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" hamdist="11" pcid="8435" startline="212"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If CBool(MethodImplAttributes And Mono.Cecil.MethodImplAttributes.Runtime) Then
             Return result
         End If
 
         Helper.Assert(Info Is Nothing)
         Dim parent As IType = Me.FindTypeParent
         Info = New EmitInfo(Me)
 
 #If DEBUG Then
         Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Nop)
 #End If
 
         Dim ParentType As Mono.Cecil.TypeReference
         ParentType = parent.CecilType
         If TypeOf parent Is StructureDeclaration AndAlso Me.IsShared = False Then
             Emitter.EmitLoadMe(Info, parent.CecilType)
             Emitter.EmitInitObj(Info, parent.CecilType)
         ElseIf m_DefaultBaseConstructor IsNot Nothing Then
             Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition) = m_DefaultBaseConstructor.Parameters
             Emitter.EmitLoadMe(Info, CecilHelper.FindDefinition(ParentType).BaseType)
             For i As Integer = 0 To params.Count - 1
                 Helper.Assert(params(i).IsOptional)
                 Emitter.EmitLoadValue(Info.Clone(Me, True, False, params(i).ParameterType), params(i).Constant)
             Next
 
             Emitter.EmitCall(Info, m_DefaultBaseConstructor)
         ElseIf m_BaseCtorCall IsNot Nothing Then
             result = m_BaseCtorCall.GenerateCode(Info)
         Else
             Helper.Assert(Me.IsShared)
         End If
 
         Dim exCtorCall As Mono.Cecil.MethodReference = ExplicitCtorCall
         If m_BaseCtorCall Is Nothing OrElse (exCtorCall IsNot Nothing AndAlso Helper.CompareType(exCtorCall.DeclaringType, Me.DeclaringType.CecilType) = False) Then
             result = EmitVariableInitialization(Info) AndAlso result
 
             For Each arhs As AddOrRemoveHandlerStatement In Me.DeclaringType.AddHandlers
                 result = arhs.GenerateCode(Info) AndAlso result
             Next
         End If
 
         If Me.IsShared Then
             result = EmitConstantInitialization(Info) AndAlso result
         End If
 
 #If DEBUG Then
         Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Nop)
 #End If
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="314" nfragments="2">
<clone_fragment endline="379" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" hamdist="0" pcid="4693" startline="350"><![CDATA[
 
 		public override void Emit ()
 		{
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (RootContext.Unsafe) {
 				var pa = PredefinedAttributes.UnverifiableCode;
 				if (pa.IsDefined)
 					pa.EmitAttribute (builder);
 			}
 
 			foreach (var tc in types)
 				tc.DefineConstants ();
 			foreach (var tc in types)
 				tc.DefineConstants ();
 
 			HackCorlib ();
 
 			foreach (TypeContainer tc in types)
 				tc.EmitType ();
 			foreach (TypeContainer tc in types)
 				tc.EmitType ();
 
 			if (Compiler.Report.Errors > 0)
 				return;
 
 			foreach (TypeContainer tc in types)
 				tc.VerifyMembers ();
 			foreach (TypeContainer tc in types)
 				tc.VerifyMembers ();
 
 			if (compiler_generated != null)
 				foreach (var c in compiler_generated)
 					c.EmitType ();
 				foreach (var c in compiler_generated)
 					c.EmitType ();
 		}
]]></clone_fragment>
<clone_fragment endline="349" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" hamdist="11" pcid="4691" startline="319"><![CDATA[
 
 		public new void Define ()
 		{
 			builder = assembly.CreateModuleBuilder ();
 
 			// FIXME
 			static_data = null;
 
 			// TODO
 			// but that require DefineType clean-up
 			ResolveGlobalAttributes ();
 
 			foreach (TypeContainer tc in types)
 				tc.CreateType ();
 			foreach (TypeContainer tc in types)
 				tc.CreateType ();
 
 			InitializePredefinedTypes ();
 
 			foreach (TypeContainer tc in types)
 				tc.DefineType ();
 			foreach (TypeContainer tc in types)
 				tc.DefineType ();
 
 			foreach (TypeContainer tc in types)
 				tc.ResolveTypeParameters ();
 			foreach (TypeContainer tc in types)
 				tc.ResolveTypeParameters ();
 
 			foreach (TypeContainer tc in types) {
 				try {
 					tc.Define ();
 				} catch (Exception e) {
 					throw new InternalErrorException (tc, e);
 				}
 			}
 			foreach (TypeContainer tc in types) {
 				try {
 					tc.Define ();
 				} catch (Exception e) {
 					throw new InternalErrorException (tc, e);
 				}
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="315" nfragments="2">
<clone_fragment endline="2525" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="0" pcid="3723" startline="2487"><![CDATA[
 
 		// at least one of 'left' or 'right' is an enumeration constant (EnumConstant or SideEffectConstant or ...)
 		// if 'left' is not an enumeration constant, create one from the type of 'right'
 		Constant EnumLiftUp (ResolveContext ec, Constant left, Constant right, Location loc)
 		{
 			switch (oper) {
 			case Operator.BitwiseOr
 			case Operator.BitwiseAnd
 			case Operator.ExclusiveOr
 			case Operator.Equality
 			case Operator.Inequality
 			case Operator.LessThan
 			case Operator.LessThanOrEqual
 			case Operator.GreaterThan
 			case Operator.GreaterThanOrEqual
 				if (TypeManager.IsEnumType (left.Type))
 					return left;
 				
 				if (left.IsZeroInteger)
 					return left.TryReduce (ec, right.Type, loc);
 				
 				break;
 				
 			case Operator.Addition
 			case Operator.Subtraction
 				return left;
 				
 			case Operator.Multiply
 			case Operator.Division
 			case Operator.Modulus
 			case Operator.LeftShift
 			case Operator.RightShift
 				if (TypeManager.IsEnumType (right.Type) || TypeManager.IsEnumType (left.Type))
 					break;
 				return left;
 			}
 			Error_OperatorCannotBeApplied (ec, this.left, this.right);
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="2232" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="10" pcid="3713" startline="2186"><![CDATA[
 
 		//
 		// Converts operator to System.Linq.Expressions.ExpressionType enum name
 		//
 		string GetOperatorExpressionTypeName ()
 		{
 			switch (oper) {
 			case Operator.Addition
 				return IsCompound ? "AddAssign" 
 			case Operator.BitwiseAnd
 				return IsCompound ? "AndAssign" 
 			case Operator.BitwiseOr
 				return IsCompound ? "OrAssign" 
 			case Operator.Division
 				return IsCompound ? "DivideAssign" 
 			case Operator.ExclusiveOr
 				return IsCompound ? "ExclusiveOrAssign" 
 			case Operator.Equality
 				return "Equal";
 			case Operator.GreaterThan
 				return "GreaterThan";
 			case Operator.GreaterThanOrEqual
 				return "GreaterThanOrEqual";
 			case Operator.Inequality
 				return "NotEqual";
 			case Operator.LeftShift
 				return IsCompound ? "LeftShiftAssign" 
 			case Operator.LessThan
 				return "LessThan";
 			case Operator.LessThanOrEqual
 				return "LessThanOrEqual";
 			case Operator.LogicalAnd
 				return "And";
 			case Operator.LogicalOr
 				return "Or";
 			case Operator.Modulus
 				return IsCompound ? "ModuloAssign" 
 			case Operator.Multiply
 				return IsCompound ? "MultiplyAssign" 
 			case Operator.RightShift
 				return IsCompound ? "RightShiftAssign" 
 			case Operator.Subtraction
 				return IsCompound ? "SubtractAssign" 
 			default
 				throw new NotImplementedException ("Unknown expression type operator " + oper.ToString ());
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="316" nfragments="3">
<clone_fragment endline="336" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" hamdist="0" pcid="8265" startline="298"><![CDATA[
 
     Shared Function KeywordToTypeCode(ByVal Keyword As KS) As TypeCode
         Select Case Keyword
             Case KS.Boolean
                 Return TypeCode.Boolean
             Case KS.Byte
                 Return TypeCode.Byte
             Case KS.Char
                 Return TypeCode.Char
             Case KS.Date
                 Return TypeCode.DateTime
             Case KS.Decimal
                 Return TypeCode.Decimal
             Case KS.Double
                 Return TypeCode.Double
             Case KS.Integer
                 Return TypeCode.Int32
             Case KS.Long
                 Return TypeCode.Int64
             Case KS.Object
                 Return TypeCode.Object
             Case KS.Single
                 Return TypeCode.Single
             Case KS.Short
                 Return TypeCode.Int16
             Case KS.String
                 Return TypeCode.String
             Case KS.SByte
                 Return TypeCode.SByte
             Case KS.UShort
                 Return TypeCode.UInt16
             Case KS.UInteger
                 Return TypeCode.UInt32
             Case KS.ULong
                 Return TypeCode.UInt64
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="211" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" hamdist="13" pcid="8259" startline="173"><![CDATA[
 
     Shared Function BuiltInTypeToTypeCode(ByVal Type As BuiltInDataTypes) As TypeCode
         Select Case Type
             Case BuiltInDataTypes.Boolean
                 Return TypeCode.Boolean
             Case BuiltInDataTypes.Byte
                 Return TypeCode.Byte
             Case BuiltInDataTypes.Char
                 Return TypeCode.Char
             Case BuiltInDataTypes.Date
                 Return TypeCode.DateTime
             Case BuiltInDataTypes.Decimal
                 Return TypeCode.Decimal
             Case BuiltInDataTypes.Double
                 Return TypeCode.Double
             Case BuiltInDataTypes.Integer
                 Return TypeCode.Int32
             Case BuiltInDataTypes.Long
                 Return TypeCode.Int64
             Case BuiltInDataTypes.Object
                 Return TypeCode.Object
             Case BuiltInDataTypes.SByte
                 Return TypeCode.SByte
             Case BuiltInDataTypes.Short
                 Return TypeCode.Int16
             Case BuiltInDataTypes.Single
                 Return TypeCode.Single
             Case BuiltInDataTypes.String
                 Return TypeCode.String
             Case BuiltInDataTypes.UInteger
                 Return TypeCode.UInt32
             Case BuiltInDataTypes.ULong
                 Return TypeCode.UInt64
             Case BuiltInDataTypes.UShort
                 Return TypeCode.UInt16
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="172" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" hamdist="3" pcid="8257" startline="130"><![CDATA[
 
     Shared Function TypeCodeToBuiltInType(ByVal tp As TypeCode) As BuiltInDataTypes
         Select Case tp
             Case TypeCode.Boolean
                 Return BuiltInDataTypes.Boolean
             Case TypeCode.Byte
                 Return BuiltInDataTypes.Byte
             Case TypeCode.Char
                 Return BuiltInDataTypes.Char
             Case TypeCode.DateTime
                 Return BuiltInDataTypes.Date
             Case TypeCode.DBNull
                 Throw New InternalException("")
             Case TypeCode.Decimal
                 Return BuiltInDataTypes.Decimal
             Case TypeCode.Double
                 Return BuiltInDataTypes.Double
             Case TypeCode.Empty
                 Throw New InternalException("")
             Case TypeCode.Int16
                 Return BuiltInDataTypes.Short
             Case TypeCode.Int32
                 Return BuiltInDataTypes.Integer
             Case TypeCode.Int64
                 Return BuiltInDataTypes.Long
             Case TypeCode.Object
                 Return BuiltInDataTypes.Object
             Case TypeCode.SByte
                 Return BuiltInDataTypes.SByte
             Case TypeCode.Single
                 Return BuiltInDataTypes.Single
             Case TypeCode.String
                 Return BuiltInDataTypes.String
             Case TypeCode.UInt16
                 Return BuiltInDataTypes.UShort
             Case TypeCode.UInt32
                 Return BuiltInDataTypes.UInteger
             Case TypeCode.UInt64
                 Return BuiltInDataTypes.ULong
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="317" nfragments="3">
<clone_fragment endline="2391" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="0" pcid="5419" startline="2372"><![CDATA[
 
 		internal override Type BindTypeParameters(IGenericBinder binder)
 		{
 			for (int i = 0; i < args.Length; i++)
 			{
 				Type xarg = args[i].BindTypeParameters(binder);
 				if (!ReferenceEquals(xarg, args[i]))
 				{
 					Type[] xargs = new Type[args.Length];
 					Array.Copy(args, xargs, i);
 					xargs[i++] = xarg;
 					for (; i < args.Length; i++)
 					{
 						xargs[i] = args[i].BindTypeParameters(binder);
 					}
 					for (; i < args.Length; i++)
 					{
 						xargs[i] = args[i].BindTypeParameters(binder);
 					}
 					return Make(type, xargs, null, null);
 				}
 			}
 			for (int i = 0; i < args.Length; i++)
 			{
 				Type xarg = args[i].BindTypeParameters(binder);
 				if (!ReferenceEquals(xarg, args[i]))
 				{
 					Type[] xargs = new Type[args.Length];
 					Array.Copy(args, xargs, i);
 					xargs[i++] = xarg;
 					for (; i < args.Length; i++)
 					{
 						xargs[i] = args[i].BindTypeParameters(binder);
 					}
 					return Make(type, xargs, null, null);
 				}
 			}
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="270" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" hamdist="10" pcid="4585" startline="240"><![CDATA[
 
 		private void PopulateTypeDef()
 		{
 			if (typeDefs == null)
 			{
 				typeDefs = new TypeDefImpl[TypeDef.records.Length];
 				for (int i = 0; i < typeDefs.Length; i++)
 				{
 					TypeDefImpl type = new TypeDefImpl(this, i);
 					typeDefs[i] = type;
 					if (type.IsModulePseudoType)
 					{
 						moduleType = type;
 					}
 					else
 					{
 						types.Add(type.FullName, type);
 					}
 				}
 				for (int i = 0; i < typeDefs.Length; i++)
 				{
 					TypeDefImpl type = new TypeDefImpl(this, i);
 					typeDefs[i] = type;
 					if (type.IsModulePseudoType)
 					{
 						moduleType = type;
 					}
 					else
 					{
 						types.Add(type.FullName, type);
 					}
 				}
 				// add forwarded types to forwardedTypes dictionary (because Module.GetType(string) should return them)
 				for (int i = 0; i < ExportedType.records.Length; i++)
 				{
 					int implementation = ExportedType.records[i].Implementation;
 					if (implementation >> 24 == AssemblyRefTable.Index)
 					{
 						string typeName = GetTypeName(ExportedType.records[i].TypeNamespace, ExportedType.records[i].TypeName);
 						forwardedTypes.Add(typeName, new LazyForwardedType((implementation & 0xFFFFFF) - 1));
 					}
 				}
 				for (int i = 0; i < ExportedType.records.Length; i++)
 				{
 					int implementation = ExportedType.records[i].Implementation;
 					if (implementation >> 24 == AssemblyRefTable.Index)
 					{
 						string typeName = GetTypeName(ExportedType.records[i].TypeNamespace, ExportedType.records[i].TypeName);
 						forwardedTypes.Add(typeName, new LazyForwardedType((implementation & 0xFFFFFF) - 1));
 					}
 				}
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="2577" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" hamdist="12" pcid="4181" startline="2550"><![CDATA[
 
 			#endregion
 		}
 
 		readonly TypeSpec[] tp_args;
 		readonly TypeSpec[] fixed_types;
 		readonly List<BoundInfo>[] bounds;
 		bool failed;
 
 		// TODO MemberCache
 		public TypeInferenceContext (TypeSpec[] typeArguments)
 		{
 			if (typeArguments.Length == 0)
 				throw new ArgumentException ("Empty generic arguments");
 
 			fixed_types = new TypeSpec [typeArguments.Length];
 			for (int i = 0; i < typeArguments.Length; ++i) {
 				if (typeArguments [i].IsGenericParameter) {
 					if (bounds == null) {
 						bounds = new List<BoundInfo> [typeArguments.Length];
 						tp_args = new TypeSpec [typeArguments.Length];
 					}
 					tp_args [i] = typeArguments [i];
 				} else {
 					fixed_types [i] = typeArguments [i];
 				}
 			}
 			for (int i = 0; i < typeArguments.Length; ++i) {
 				if (typeArguments [i].IsGenericParameter) {
 					if (bounds == null) {
 						bounds = new List<BoundInfo> [typeArguments.Length];
 						tp_args = new TypeSpec [typeArguments.Length];
 					}
 					tp_args [i] = typeArguments [i];
 				} else {
 					fixed_types [i] = typeArguments [i];
 				}
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="318" nfragments="2">
<clone_fragment endline="117" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\DoStatement.vb" hamdist="0" pcid="9375" startline="79"><![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim startLabel As Label = Emitter.DefineLabel(Info)
         EndLabel = Emitter.DefineLabel(Info)
         m_NextIteration = Emitter.DefineLabel(Info)
 
         Emitter.MarkLabel(Info, startLabel)
         If m_PreCondition IsNot Nothing Then
             Emitter.MarkLabel(Info, m_NextIteration)
             result = m_PreCondition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
             Emitter.EmitConversion(m_PreCondition.ExpressionType, Compiler.TypeCache.System_Boolean, Info)
             If m_IsWhile Then
                 Emitter.EmitBranchIfFalse(Info, EndLabel)
             Else
                 Emitter.EmitBranchIfTrue(Info, EndLabel)
             End If
         End If
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         If m_PostCondition IsNot Nothing Then
             Emitter.MarkLabel(Info, m_NextIteration)
             result = m_PostCondition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
             Emitter.EmitConversion(m_PostCondition.ExpressionType, Compiler.TypeCache.System_Boolean, Info)
             If m_IsWhile Then
                 Emitter.EmitBranchIfFalse(Info, EndLabel)
             Else
                 Emitter.EmitBranchIfTrue(Info, EndLabel)
             End If
         End If
         Emitter.EmitBranch(Info, startLabel)
 
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="112" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\CatchStatement.vb" hamdist="11" pcid="9361" startline="66"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_When IsNot Nothing Then
             Dim EndWhen, DoWhenComparison As Label
             EndWhen = Emitter.DefineLabel(Info)
             DoWhenComparison = Emitter.DefineLabel(Info)
 
             Emitter.EmitBeginExceptionFilter(Info)
             'Check if the exception object is of type System.Exception.
             Emitter.EmitIsInst(Info, Compiler.TypeCache.System_Object, Compiler.TypeCache.System_Exception)
             Emitter.EmitDup(Info)
             'If True, do the comparison
             Emitter.EmitBranchIfTrue(Info, DoWhenComparison, Compiler.TypeCache.System_Exception)
             'Otherwise load a false value and go to the end of the filter.
             Emitter.EmitPop(Info, Compiler.TypeCache.System_Exception)
             Emitter.EmitLoadValue(Info, False)
             Emitter.EmitBranch(Info, EndWhen)
 
             'Do the when clause.
             Emitter.MarkLabel(Info, DoWhenComparison)
             Emitter.EmitPop(Info, Compiler.TypeCache.System_Exception)
             result = m_When.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
             Emitter.MarkLabel(Info, EndWhen)
             Emitter.EmitBeginCatch(Info, Nothing)
         Else
             Helper.Assert(m_ExceptionType IsNot Nothing)
             Emitter.EmitBeginCatch(Info, m_ExceptionType)
         End If
 
         If m_VariableDeclaration Is Nothing Then
             If m_ExceptionType Is Nothing Then
                 Emitter.EmitPop(Info, Compiler.TypeCache.System_Object)
             Else
                 Emitter.EmitPop(Info, m_ExceptionType)
             End If
         Else
             result = m_VariableDeclaration.GenerateCode(Info) AndAlso result
             Emitter.EmitIsInst(Info, Compiler.TypeCache.System_Object, m_ExceptionType)
             Emitter.EmitStoreVariable(Info, m_VariableDeclaration.LocalBuilder)
         End If
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="319" nfragments="2">
<clone_fragment endline="230" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="0" pcid="8035" startline="195"><![CDATA[
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, GetCurrentLocation())
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '='")
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
]]></clone_fragment>
<clone_fragment endline="413" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="8" pcid="8051" startline="366"><![CDATA[
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="320" nfragments="4">
<clone_fragment endline="702" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" hamdist="0" pcid="2681" startline="666"><![CDATA[
 	}
 
 	//
 	// Default message recorder, it uses two types of message groups.
 	// Common messages
 	// Merged messages
 	//
 	// Used by the Lambda expressions to compile the code with various
 	// parameter values, or by attribute resolver
 	//
 	class SessionReportPrinter 
 	{
 		List<AbstractMessage> session_messages;
 		//
 		// A collection of exactly same messages reported in all sessions
 		//
 		List<AbstractMessage> common_messages;
 
 		//
 		// A collection of unique messages reported in all sessions
 		//
 		List<AbstractMessage> merged_messages;
 
 		public override void Print (AbstractMessage msg)
 		{
 			//
 			// This line is useful when debugging recorded messages
 			//
 			// Console.WriteLine ("RECORDING
 
 			if (session_messages == null)
 				session_messages = new List<AbstractMessage> ();
 
 			session_messages.Add (msg);
 
 			base.Print (msg);
 		}
]]></clone_fragment>
<clone_fragment endline="170" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\rootcontext.cs" hamdist="12" pcid="6233" startline="120"><![CDATA[
 		}
 
 
 		// 
 		// The default compiler checked state
 		//
 		static public bool Checked;
 
 		//
 		// If true, it means that the compiler is executing as
 		// in eval mode so unresolved variables are resolved in
 		// static classes maintained by the eval engine.
 		//
 		static public bool EvalMode;
 
 		//
 		// If true, the compiler is operating in statement mode,
 		// this currently turns local variable declaration into
 		// static variables of a class
 		//
 		static public bool StatementMode;
 		
 		//
 		// Whether to allow Unsafe code
 		//
 		static public bool Unsafe;
 
 		static public string Win32ResourceFile;
 		static public string Win32IconFile;
 
 		//
 		// A list of resource files for embedding
 		//
 		static public  List<AssemblyResource> Resources;
 
 		static public bool GenerateDebugInfo;
 
 		// Compiler debug flags only
 		public static bool ParseOnly, TokenizeOnly;
 
 		//
 		// Whether we are being linked against the standard libraries.
 		// This is only used to tell whether `System.Object' should
 		// have a base class or not.
 		//
 		public static bool StdLib;
 
 		public static RuntimeVersion StdLibRuntimeVersion;
 
 		public static bool NeedsEntryPoint {
 			get { return Target == Target.Exe || Target == Target.WinExe; }
]]></clone_fragment>
<clone_fragment endline="5807" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="17" pcid="4857" startline="5748"><![CDATA[
 
 		//
 		// This Emit can be invoked in two contexts
 		//    * As a mechanism that will leave a value on the stack (new object)
 		//    * As one that wont (init struct)
 		//
 		// If we are dealing with a ValueType, we have a few
 		// situations to deal with
 		//
 		//    * The target is a ValueType, and we have been provided
 		//      the instance (this is easy, we are being assigned).
 		//
 		//    * The target of New is being passed as an argument,
 		//      to a boxing operation or a function that takes a
 		//      ValueType.
 		//
 		//      In this case, we need to create a temporary variable
 		//      that is the argument of New.
 		//
 		// Returns whether a value is left on the stack
 		//
 		// *** Implementation note ***
 		//
 		// To benefit from this optimization, each assignable expression
 		// has to manually cast to New and call this Emit.
 		//
 		// TODO
 		//
 		public virtual bool Emit (EmitContext ec, IMemoryLocation target)
 		{
 			bool is_value_type = TypeManager.IsValueType (type);
 			VariableReference vr = target as VariableReference;
 
 			if (target != null && is_value_type && (vr != null || method == null)) {
 				target.AddressOf (ec, AddressOp.Store);
 			} else if (vr != null && vr.IsRef) {
 				vr.EmitLoad (ec);
 			}
 			
 			if (arguments != null)
 				arguments.Emit (ec);
 
 			if (is_value_type) {
 				if (method == null) {
 					ec.Emit (OpCodes.Initobj, type);
 					return false;
 				}
 
 				if (vr != null) {
 					ec.Emit (OpCodes.Call, method);
 					return false;
 				}
 			}
 			
 			if (type is TypeParameterSpec)
 				return DoEmitTypeParameter (ec);			
 
 			ec.Emit (OpCodes.Newobj, method);
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="1618" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" hamdist="13" pcid="4131" startline="1544"><![CDATA[
 
 		protected override void InitializeMemberCache (bool onlyTypes)
 		{
 			if (cache == null)
 				cache = new MemberCache (onlyTypes ? open_type.MemberCacheTypes 
 
 			var inflator = CreateLocalInflator ();
 
 			//
 			// Two stage inflate due to possible nested types recursive
 			// references
 			//
 			// class A<T> {
 			//    B b;
 			//    class B {
 			//      T Value;
 			//    }
 			// }
 			//
 			// When resolving type of `b' members of `B' cannot be 
 			// inflated because are not yet available in membercache
 			//
 			if ((state & StateFlags.PendingMemberCacheMembers) == 0) {
 				open_type.MemberCacheTypes.InflateTypes (cache, inflator);
 
 				//
 				// Inflate any implemented interfaces
 				//
 				if (open_type.Interfaces != null) {
 					ifaces = new List<TypeSpec> (open_type.Interfaces.Count);
 					foreach (var iface in open_type.Interfaces) {
 						var iface_inflated = inflator.Inflate (iface);
 						AddInterface (iface_inflated);
 					}
 					foreach (var iface in open_type.Interfaces) {
 						var iface_inflated = inflator.Inflate (iface);
 						AddInterface (iface_inflated);
 					}
 				}
 
 				//
 				// Handles the tricky case of recursive nested base generic type
 				//
 				// class A<T> 
 				//    class Nested {}
 				// }
 				//
 				// When inflating A<T>. base type is not yet known, secondary
 				// inflation is required (not common case) once base scope
 				// is known
 				//
 				if (open_type.BaseType == null) {
 					if (IsClass)
 						state |= StateFlags.PendingBaseTypeInflate;
 				} else {
 					BaseType = inflator.Inflate (open_type.BaseType);
 				}
 			} else if ((state & StateFlags.PendingBaseTypeInflate) != 0) {
 				BaseType = inflator.Inflate (open_type.BaseType);
 				state &= ~StateFlags.PendingBaseTypeInflate;
 			}
 
 			if (onlyTypes) {
 				state |= StateFlags.PendingMemberCacheMembers;
 				return;
 			}
 
 			var tc = open_type.MemberDefinition as TypeContainer;
 			if (tc != null && !tc.HasMembersDefined)
 				throw new InternalErrorException ("Inflating MemberCache with undefined members");
 
 			if ((state & StateFlags.PendingBaseTypeInflate) != 0) {
 				BaseType = inflator.Inflate (open_type.BaseType);
 				state &= ~StateFlags.PendingBaseTypeInflate;
 			}
 
 			state &= ~StateFlags.PendingMemberCacheMembers;
 			open_type.MemberCache.InflateMembers (cache, open_type, inflator);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="321" nfragments="2">
<clone_fragment endline="194" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="0" pcid="7317" startline="158"><![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As Mono.Cecil.TypeDefinition, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.GenericInstanceType = Nothing
         Dim args As New Generic.List(Of Mono.Cecil.TypeReference)
         Dim any_change As Boolean
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
 
         If genericType Is Nothing Then Return Member
 
         result = New Mono.Cecil.GenericInstanceType(Member)
         result.DeclaringType = FindDefinition(Type)
 
         Dim tGI As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         If Member.DeclaringType IsNot Nothing AndAlso tGI IsNot Nothing AndAlso Helper.CompareType(Member.DeclaringType, tGI.ElementType) Then
             'Nested generic type
             For i As Integer = 0 To tGI.GenericArguments.Count - 1
                 result.GenericArguments.Add(Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, tGI.GenericArguments(i)))
             Next
             Return result
         End If
 
         For i As Integer = 0 To Member.GenericParameters.Count - 1
             Dim found As Boolean = False
             For j As Integer = 0 To genericType.ElementType.GenericParameters.Count - 1
                 If genericType.ElementType.GenericParameters(j).Name = Member.GenericParameters(i).Name Then
                     result.GenericArguments.Add(Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, genericType.GenericArguments(j)))
                     found = True
                     any_change = True
                     Exit For
                 End If
             Next
 
             If Not found Then Throw New NotImplementedException
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1045" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="10" pcid="7375" startline="982"><![CDATA[
 
     Public Shared Function GetInterfaces(ByVal Type As Mono.Cecil.TypeReference, ByVal checkBase As Boolean) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         Dim result As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim tmp As Mono.Cecil.TypeReference
         Dim tD As Mono.Cecil.TypeDefinition
         Dim tG As Mono.Cecil.GenericParameter = TryCast(Type, Mono.Cecil.GenericParameter)
 
         If tG IsNot Nothing Then
             If tG.Constraints.Count = 0 Then Return Nothing
             result = New Mono.Collections.Generic.Collection(Of TypeReference)
             For i As Integer = 0 To tG.Constraints.Count - 1
                 For Each t As TypeReference In GetInterfaces(tG.Constraints(i), checkBase)
                     result.Add(t)
                 Next
             Next
             Return result
         End If
 
         Dim arrD As Mono.Cecil.ArrayType = TryCast(Type, Mono.Cecil.ArrayType)
         If arrD IsNot Nothing Then
             result = New Mono.Collections.Generic.Collection(Of TypeReference)
             For Each tp As TypeReference In GetInterfaces(BaseObject.m_Compiler.TypeCache.System_Array, False)
                 result.Add(tp)
             Next
             For Each tp As TypeDefinition In New TypeDefinition() {BaseObject.m_Compiler.TypeCache.System_Collections_Generic_ICollection1, BaseObject.m_Compiler.TypeCache.System_Collections_Generic_IEnumerable1, BaseObject.m_Compiler.TypeCache.System_Collections_Generic_IList1}
                 Dim newTP As New GenericInstanceType(tp)
                 newTP.GenericArguments.Add(arrD.ElementType)
                 result.Add(newTP)
             Next
             Return result
         End If
 
         tD = FindDefinition(Type)
 
         result = New Mono.Collections.Generic.Collection(Of TypeReference)
         For i As Integer = 0 To tD.Interfaces.Count - 1
             result.Add(InflateType(tD.Interfaces(i), Type))
         Next
 
         If genericType IsNot Nothing Then
             For i As Integer = 0 To result.Count - 1
                 tmp = CecilHelper.ResolveType(result(i), CecilHelper.FindDefinition(genericType).GenericParameters, genericType.GenericArguments)
                 result.Item(i) = tmp
             Next
         End If
 
         If checkBase Then
             Dim bT As Mono.Cecil.TypeReference
 
             bT = tD.BaseType
             If bT IsNot Nothing Then
                 If genericType IsNot Nothing Then
                     bT = CecilHelper.GetCorrectMember(bT, genericType)
                 End If
 
                 For Each t As Mono.Cecil.TypeReference In GetInterfaces(bT, checkBase)
                     result.Add(t)
                 Next
             End If
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="322" nfragments="2">
<clone_fragment endline="74" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertyGetDeclaration.vb" hamdist="0" pcid="8759" startline="33"><![CDATA[
 
     Public Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal ImplementsClause As MemberImplementsClause, ByVal Block As CodeBlock)
 
         Dim mySignature As FunctionSignature
 
         mySignature = New FunctionSignature(Me)
 
         Dim typeParams As TypeParameters
         Dim retTypeAttributes As Attributes
         Dim name As String
         Dim params As ParameterList
         Dim typename As TypeName
 
         If PropertySignature.TypeParameters IsNot Nothing Then
             typeParams = PropertySignature.TypeParameters.Clone()
             typeParams.Initialize(mySignature)
         Else
             typeParams = Nothing
         End If
         If PropertySignature.ReturnTypeAttributes IsNot Nothing Then
             retTypeAttributes = PropertySignature.ReturnTypeAttributes.Clone(mySignature)
         Else
             retTypeAttributes = Nothing
         End If
         If PropertySignature.Parameters IsNot Nothing Then
             params = PropertySignature.Parameters.Clone(Me)
         Else
             params = Nothing
         End If
         If PropertySignature.TypeName IsNot Nothing Then
             typename = PropertySignature.TypeName.Clone(mySignature)
         ElseIf PropertySignature.ReturnType IsNot Nothing Then
             typename = New TypeName(mySignature, PropertySignature.ReturnType)
         Else
             typename = Nothing
         End If
         name = "get_" & PropertySignature.Name
 
         mySignature.Init(New Identifier(mySignature, name, PropertySignature.Location, PropertySignature.Identifier.TypeCharacter), typeParams, params, retTypeAttributes, typename, PropertySignature.Location)
 
         MyBase.Init(Modifiers, mySignature, ImplementsClause, Block)
     End Sub
]]></clone_fragment>
<clone_fragment endline="110" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" hamdist="10" pcid="8763" startline="36"><![CDATA[
 
     Public Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal ImplementsClause As MemberImplementsClause, ByVal Block As CodeBlock, ByVal SetParameters As ParameterList)
         Dim mySignature As SubSignature
         Dim name As String
         Dim typeParams As TypeParameters
         Dim params As ParameterList
         Dim manualValue As Boolean
 
         mySignature = New SubSignature(Me)
 
         If PropertySignature.TypeParameters IsNot Nothing Then
             typeParams = PropertySignature.TypeParameters.Clone()
             typeParams.Initialize(mySignature)
         Else
             typeParams = Nothing
         End If
         If SetParameters IsNot Nothing Then
             params = SetParameters
         Else
             params = New ParameterList(Me)
         End If
 
         Helper.Assert(CecilBuilder.Parameters.Count = params.Count)
 
         If params.Count = 1 Then
             manualValue = True
         Else
             manualValue = False
             If params.Count > 1 Then
                 Helper.AddError(Compiler, Me.Location, "Invalid set parameters, there should be only 0 or 1 parameters")
                 params.Clear()
             End If
         End If
 
         If PropertySignature.Parameters IsNot Nothing Then
             Dim tmp As Parameter = Nothing
             Dim ctmp As Mono.Cecil.ParameterDefinition = Nothing
 
             'The 'value' parameter should go at the end, so take it out of the list, add the other parameters, and add it back again
             If manualValue Then
                 tmp = params(0)
                 ctmp = CecilBuilder.Parameters(0)
                 params.Clear()
                 CecilBuilder.Parameters.Clear()
             End If
 
             For i As Integer = 0 To PropertySignature.Parameters.Count - 1
                 params.Add(PropertySignature.Parameters(i).Clone(params))
             Next
             If manualValue Then
                 params.Add(tmp)
                 CecilBuilder.Parameters.Add(ctmp)
                 ctmp.Sequence = CecilBuilder.Parameters.Count
             End If
         End If
 
         ' Setter without a 'value', create it automatically
         If manualValue = False Then
             Dim valueName As String = "value"
             Dim param As Parameter
             If PropertySignature.ReturnType IsNot Nothing Then
                 param = New Parameter(params, valueName, PropertySignature.ReturnType)
             Else
                 param = New Parameter(params, valueName, PropertySignature.TypeName)
                 param.ParameterIdentifier.Identifier.TypeCharacter = PropertySignature.Identifier.TypeCharacter
             End If
             params.Add(param)
         End If
 
         name = "set_" & PropertySignature.Name
 
         mySignature.Init(New Identifier(mySignature, name, PropertySignature.Location, PropertySignature.Identifier.TypeCharacter), typeParams, params)
 
         MyBase.Init(Modifiers, mySignature, ImplementsClause, Block)
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="323" nfragments="2">
<clone_fragment endline="90" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" hamdist="0" pcid="1325" startline="49"><![CDATA[
 
 		internal void Read(BinaryReader br)
 		{
 			Signature = br.ReadUInt32();
 			if (Signature != IMAGE_NT_HEADERS.MAGIC_SIGNATURE)
 			{
 				throw new BadImageFormatException();
 			}
 			FileHeader.Read(br);
 			OptionalHeader.Read(br);
 		}
 	}
 
 	sealed class IMAGE_FILE_HEADER
 	{
 		public const WORD IMAGE_FILE_MACHINE_I386 = 0x014c;
 		public const WORD IMAGE_FILE_MACHINE_IA64 = 0x0200;
 		public const WORD IMAGE_FILE_MACHINE_AMD64 = 0x8664;
 
 		public const WORD IMAGE_FILE_32BIT_MACHINE = 0x0100;
 		public const WORD IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002;
 		public const WORD IMAGE_FILE_LARGE_ADDRESS_AWARE = 0x0020;
 		public const WORD IMAGE_FILE_DLL = 0x2000;
 
 		public WORD Machine;
 		public WORD NumberOfSections;
 		public DWORD TimeDateStamp;
 		public DWORD PointerToSymbolTable;
 		public DWORD NumberOfSymbols;
 		public WORD SizeOfOptionalHeader;
 		public WORD Characteristics;
 
 		internal void Read(BinaryReader br)
 		{
 			Machine = br.ReadUInt16();
 			NumberOfSections = br.ReadUInt16();
 			TimeDateStamp = br.ReadUInt32();
 			PointerToSymbolTable = br.ReadUInt32();
 			NumberOfSymbols = br.ReadUInt32();
 			SizeOfOptionalHeader = br.ReadUInt16();
 			Characteristics = br.ReadUInt16();
 		}
]]></clone_fragment>
<clone_fragment endline="255" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" hamdist="13" pcid="1329" startline="210"><![CDATA[
 	}
 
 	class SectionHeader
 	{
 		public const DWORD IMAGE_SCN_CNT_CODE = 0x00000020;
 		public const DWORD IMAGE_SCN_CNT_INITIALIZED_DATA = 0x00000040;
 		public const DWORD IMAGE_SCN_MEM_DISCARDABLE = 0x02000000;
 		public const DWORD IMAGE_SCN_MEM_EXECUTE = 0x20000000;
 		public const DWORD IMAGE_SCN_MEM_READ = 0x40000000;
 		public const DWORD IMAGE_SCN_MEM_WRITE = 0x80000000;
 
 		public string Name;		// 8 byte UTF8 encoded 0-padded
 		public DWORD VirtualSize;
 		public DWORD VirtualAddress;
 		public DWORD SizeOfRawData;
 		public DWORD PointerToRawData;
 		public DWORD PointerToRelocations;
 		public DWORD PointerToLinenumbers;
 		public WORD NumberOfRelocations;
 		public WORD NumberOfLinenumbers;
 		public DWORD Characteristics;
 
 		internal void Read(BinaryReader br)
 		{
 			char[] name = new char[8];
 			int len = 8;
 			for (int i = 0; i < 8; i++)
 			{
 				byte b = br.ReadByte();
 				name[i] = (char)b;
 				if (b == 0 && len == 8)
 				{
 					len = i;
 				}
 			}
 			for (int i = 0; i < 8; i++)
 			{
 				byte b = br.ReadByte();
 				name[i] = (char)b;
 				if (b == 0 && len == 8)
 				{
 					len = i;
 				}
 			}
 			Name = new String(name, 0, len);
 			VirtualSize = br.ReadUInt32();
 			VirtualAddress = br.ReadUInt32();
 			SizeOfRawData = br.ReadUInt32();
 			PointerToRawData = br.ReadUInt32();
 			PointerToRelocations = br.ReadUInt32();
 			PointerToLinenumbers = br.ReadUInt32();
 			NumberOfRelocations = br.ReadUInt16();
 			NumberOfLinenumbers = br.ReadUInt16();
 			Characteristics = br.ReadUInt32();
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="324" nfragments="2">
<clone_fragment endline="5576" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="0" pcid="4847" startline="5535"><![CDATA[
 		}
 
 		#endregion
 
 		/// <summary>
 		/// Converts complex core type syntax like 'new int ()' to simple constant
 		/// </summary>
 		public static Constant Constantify (TypeSpec t, Location loc)
 		{
 			if (t == TypeManager.int32_type)
 				return new IntConstant (0, loc);
 			if (t == TypeManager.uint32_type)
 				return new UIntConstant (0, loc);
 			if (t == TypeManager.int64_type)
 				return new LongConstant (0, loc);
 			if (t == TypeManager.uint64_type)
 				return new ULongConstant (0, loc);
 			if (t == TypeManager.float_type)
 				return new FloatConstant (0, loc);
 			if (t == TypeManager.double_type)
 				return new DoubleConstant (0, loc);
 			if (t == TypeManager.short_type)
 				return new ShortConstant (0, loc);
 			if (t == TypeManager.ushort_type)
 				return new UShortConstant (0, loc);
 			if (t == TypeManager.sbyte_type)
 				return new SByteConstant (0, loc);
 			if (t == TypeManager.byte_type)
 				return new ByteConstant (0, loc);
 			if (t == TypeManager.char_type)
 				return new CharConstant ('\0', loc);
 			if (t == TypeManager.bool_type)
 				return new BoolConstant (false, loc);
 			if (t == TypeManager.decimal_type)
 				return new DecimalConstant (0, loc);
 			if (TypeManager.IsEnumType (t))
 				return new EnumConstant (Constantify (EnumSpec.GetUnderlyingType (t), loc), t);
 			if (TypeManager.IsNullableType (t))
 				return Nullable.LiftedNull.Create (t, loc);
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="158" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" hamdist="12" pcid="2265" startline="113"><![CDATA[
 
 		public static Constant CreateConstantFromValue (TypeSpec t, object v, Location loc)
 		{
 			if (t == TypeManager.int32_type)
 				return new IntConstant ((int) v, loc);
 			if (t == TypeManager.string_type)
 				return new StringConstant ((string) v, loc);
 			if (t == TypeManager.uint32_type)
 				return new UIntConstant ((uint) v, loc);
 			if (t == TypeManager.int64_type)
 				return new LongConstant ((long) v, loc);
 			if (t == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) v, loc);
 			if (t == TypeManager.float_type)
 				return new FloatConstant ((float) v, loc);
 			if (t == TypeManager.double_type)
 				return new DoubleConstant ((double) v, loc);
 			if (t == TypeManager.short_type)
 				return new ShortConstant ((short)v, loc);
 			if (t == TypeManager.ushort_type)
 				return new UShortConstant ((ushort)v, loc);
 			if (t == TypeManager.sbyte_type)
 				return new SByteConstant ((sbyte)v, loc);
 			if (t == TypeManager.byte_type)
 				return new ByteConstant ((byte)v, loc);
 			if (t == TypeManager.char_type)
 				return new CharConstant ((char)v, loc);
 			if (t == TypeManager.bool_type)
 				return new BoolConstant ((bool) v, loc);
 			if (t == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) v, loc);
 			if (TypeManager.IsEnumType (t)) {
 				var real_type = EnumSpec.GetUnderlyingType (t);
 				return new EnumConstant (CreateConstantFromValue (real_type, v, loc).Resolve (null), t);
 			}
 			if (v == null) {
 				if (TypeManager.IsNullableType (t))
 					return Nullable.LiftedNull.Create (t, loc);
 
 				if (TypeManager.IsReferenceType (t))
 					return new NullConstant (t, loc);
 			}
 
 			throw new InternalErrorException ("Constant value `{0}' has unexpected underlying type `{1}'",
 				v, TypeManager.CSharpName (t));
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="325" nfragments="2">
<clone_fragment endline="528" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" hamdist="0" pcid="9959" startline="487"><![CDATA[
 
     Private Function CheckOutermostNamespace(ByVal R As String, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* (...)
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         '*
         '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
         '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
         '*
         '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
         '** error occurs.
         '--------------------------------------------------------------------------------------------------------- 
 
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         Dim types As TypeDictionary = Nothing
         Dim modules As TypeList
         Dim foundType As Mono.Cecil.TypeReference
 
         Dim RName As String = Helper.CreateGenericTypename(R, TypeArgumentCount)
         foundType = FromWhere.Compiler.TypeManager.TypesByNamespace("").Item(RName)
         If foundType IsNot Nothing Then
             m_FoundObjects.Add(foundType)
         End If
         If TypeArgumentCount = 0 AndAlso FromWhere.Compiler.TypeManager.Namespaces.IsNamespace(R, True) Then
             m_FoundObjects.Add(FromWhere.Compiler.TypeManager.Namespaces.Item(R))
         End If
 
         If m_FoundObjects.Count > 0 Then Return True
 
         '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
         '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
 
         If types Is Nothing Then Return False 'There are no types (nor modules) in the outermost namespace.
 
         modules = FromWhere.Compiler.TypeManager.GetModulesByNamespace("").ToTypeList
 
         If CheckModules(modules, R, TypeArgumentCount) Then Return True
 
         Return False
     End Function
]]></clone_fragment>
<clone_fragment endline="615" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Types\TypeNameResolutionInfo.vb" hamdist="7" pcid="9963" startline="560"><![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="R"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function CheckNamespace(ByVal R As String, ByVal Types As TypeDictionary, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* (...)
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         '*
         '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
         '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
         '*
         '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
         '** error occurs.
         '---------------------------------------------------------------------------------------------------------
 
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         Dim RName As String = vbnc.Helper.CreateGenericTypename(R, TypeArgumentCount)
 
         Dim foundType As Mono.Cecil.TypeReference
 
         foundType = Types.Item(RName)
         If foundType IsNot Nothing Then
             m_FoundObjects.Add(foundType)
             Return True
         End If
 
         '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
         '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
         Dim foundModules As Generic.List(Of Mono.Cecil.TypeReference)
         foundModules = Helper.FilterToModules(FromWhere.Compiler, Types)
         If foundModules.Count > 0 Then
             Dim typesInAllModules As New Generic.List(Of Mono.Cecil.TypeReference)
             For Each [module] As Mono.Cecil.TypeReference In foundModules
                 Dim typeInCurrentModule As Mono.Cecil.TypeReference
                 typeInCurrentModule = CecilHelper.GetNestedType([module], RName)
                 If typeInCurrentModule IsNot Nothing Then typesInAllModules.Add(typeInCurrentModule)
             Next
             If typesInAllModules.Count = 1 Then
                 m_FoundObjects.AddRange(typesInAllModules.ToArray)
                 Return True
             ElseIf typesInAllModules.Count > 1 Then
                 '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
                 '** error occurs.
                 Helper.AddError(Name)
                 Return False
             End If
         End If
 
         Return False
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="326" nfragments="2">
<clone_fragment endline="574" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="0" pcid="7335" startline="532"><![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodDefinition, ByVal Arguments As Mono.Collections.Generic.Collection(Of TypeReference), Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter) = Member.GenericParameters
         Dim returnType As Mono.Cecil.TypeReference
         Dim reflectableMember As Mono.Cecil.MethodReference
 
         If Member.GenericParameters.Count = 0 Then Return Member
 
         returnType = CecilHelper.ResolveType(Member.ReturnType, parameters, Arguments)
         returnType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, returnType)
         result = New Mono.Cecil.MethodReference(Member.Name, Member.DeclaringType, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember = New Mono.Cecil.MethodReference(Member.Name, Member.DeclaringType, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember.OriginalMethod = Member
         result.OriginalMethod = Member
 
         For i As Integer = 0 To Member.GenericParameters.Count - 1
             result.GenericParameters.Add(Member.GenericParameters(i))
             reflectableMember.GenericParameters.Add(Member.GenericParameters(i))
         Next
 
         For i As Integer = 0 To Member.Parameters.Count - 1
             Dim pD As Mono.Cecil.ParameterDefinition = Member.Parameters(i)
             Dim pDType As Mono.Cecil.TypeReference
             pDType = InflateType(pD.ParameterType, parameters, Arguments)
             If pDType IsNot pD.ParameterType Then
                 Dim newPD As Mono.Cecil.ParameterDefinition
                 Dim pd2 As Mono.Cecil.TypeReference
                 pDType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pDType)
                 newPD = New ParameterDefinition(pD.Name, pD.Attributes, pDType)
                 result.Parameters.Add(newPD)
                 pd2 = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pD.ParameterType)
                 reflectableMember.Parameters.Add(New ParameterDefinition(pD.Name, pD.Attributes, pd2))
             Else
                 result.Parameters.Add(pD)
                 reflectableMember.Parameters.Add(pD)
             End If
         Next
 
         result.Annotations.Add("MemberInReflection", reflectableMember)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="647" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="10" pcid="7337" startline="575"><![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodDefinition, ByVal Type As Mono.Cecil.TypeReference, Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim tD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(Type)
         Dim genericArguments As Mono.Collections.Generic.Collection(Of TypeReference) = Nothing
         Dim genericParameters As Mono.Collections.Generic.Collection(Of GenericParameter) = Nothing
         Dim returnType As Mono.Cecil.TypeReference
         Dim reflectableMember As Mono.Cecil.MethodReference
         Dim declType As TypeReference = Nothing
 
         GetGenericArgsAndParams(Type, genericParameters, genericArguments)
 
         'If genericType Is Nothing Then
         '    Dim declType As TypeReference = Type
         '    While declType.IsNested
         '        Dim genType As GenericInstanceType = TryCast(declType, Mono.Cecil.GenericInstanceType)
         '        If genType IsNot Nothing Then
         '            If genericArguments Is Nothing Then genericArguments = New GenericArgumentCollection(Nothing)
         '            For Each arg As TypeReference In genType.GenericArguments
         '                genericArguments.Add(arg)
         '            Next
         '        End If
         '    End While
         '    Return Member
         'Else
         '    genericArguments = genericType.GenericArguments
         '    genericParameters = tD.GenericParameters
         'End If
 
         If genericParameters Is Nothing AndAlso genericArguments Is Nothing AndAlso tD Is Type AndAlso tD.Module Is Compiler.CurrentCompiler.ModuleBuilderCecil Then
             Return Member
         End If
 
         If Emittable Then
             returnType = Member.ReturnType
         Else
             returnType = CecilHelper.InflateType(Member.ReturnType, genericParameters, genericArguments)
         End If
         result = New Mono.Cecil.MethodReference(Member.Name, Type, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember = New Mono.Cecil.MethodReference(Member.Name, Type, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember.OriginalMethod = Member
         result.OriginalMethod = Member
 
         'If Member.DeclaringType.GenericParameters.Count > 0 AndAlso Not False Then
         '    Dim tmp As New GenericInstanceType(Member.DeclaringType)
         '    For i As Integer = 0 To Member.DeclaringType.GenericParameters.Count - 1
         '        tmp.GenericArguments.Add(Member.DeclaringType.GenericParameters(i))
         '    Next
         '    result.DeclaringType = tmp
         'End If
 
         For i As Integer = 0 To Member.Parameters.Count - 1
             Dim pD As Mono.Cecil.ParameterDefinition = Member.Parameters(i)
             Dim pDType As Mono.Cecil.TypeReference
             pDType = InflateType(pD.ParameterType, genericParameters, genericArguments)
             If pDType IsNot pD.ParameterType Then
                 Dim newPD As Mono.Cecil.ParameterDefinition
                 Dim pd2 As Mono.Cecil.TypeReference
                 pDType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pDType)
                 newPD = New ParameterDefinition(pD.Name, pD.Attributes, pDType)
                 result.Parameters.Add(newPD)
                 pd2 = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pD.ParameterType)
                 reflectableMember.Parameters.Add(New ParameterDefinition(pD.Name, pD.Attributes, pd2))
             Else
                 result.Parameters.Add(pD)
                 reflectableMember.Parameters.Add(pD)
             End If
         Next
 
         result.Annotations.Add("MemberInReflection", reflectableMember)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="327" nfragments="2">
<clone_fragment endline="462" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" hamdist="0" pcid="7063" startline="420"><![CDATA[
 
     ''' <summary>
     ''' Reclassifies an expression.
     ''' The resulting expression is NOT resolved.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ReclassifyToValueExpression() As Expression
         Dim result As Expression = Nothing
         Select Case m_Classification.Classification
             Case ExpressionClassification.Classifications.Value
                 Return Me 'This expression is already a value expression.
             Case ExpressionClassification.Classifications.Variable
                 result = New VariableToValueExpression(Me, Me.Classification.AsVariableClassification)
             Case ExpressionClassification.Classifications.MethodGroup
                 result = New MethodGroupToValueExpression(Me, Me.Classification.AsMethodGroupClassification)
             Case ExpressionClassification.Classifications.PropertyAccess
                 result = New PropertyAccessToValueExpression(Me, Me.Classification.AsPropertyAccess)
             Case ExpressionClassification.Classifications.PropertyGroup
                 result = New PropertyGroupToValueExpression(Me, Me.Classification.AsPropertyGroup)
             Case ExpressionClassification.Classifications.LateBoundAccess
                 result = New LateBoundAccessToValueExpression(Me, Me.Classification.AsLateBoundAccess)
             Case ExpressionClassification.Classifications.MethodPointer
                 Throw New InternalException(Me, "Use the other overload.")
             Case ExpressionClassification.Classifications.EventAccess
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.Void
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.Type
                 Dim exp As Expression = Nothing
                 If m_Classification.AsTypeClassification.CreateAliasExpression(Me, exp) = False Then
                     Throw New InternalException(Me)
                 End If
                 Return exp
             Case ExpressionClassification.Classifications.Namespace
                 Throw New InternalException(Me)
             Case Else
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 Return Nothing
         End Select
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="408" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Expression.vb" hamdist="11" pcid="7059" startline="360"><![CDATA[
 
     ''' <summary>
     ''' The resulting expression is NOT resolved.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ReclassifyToPropertyAccessExpression() As Expression
         Dim result As Expression
         Select Case m_Classification.Classification
             Case ExpressionClassification.Classifications.PropertyGroup
                 Dim pgClass As PropertyGroupClassification = Me.Classification.AsPropertyGroup
                 result = New PropertyGroupToPropertyAccessExpression(Me, pgClass)
             Case ExpressionClassification.Classifications.Value
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.Variable
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.EventAccess
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.LateBoundAccess
                 Return New LateBoundAccessToPropertyAccessExpression(Me, Me.Classification.AsLateBoundAccess)
             Case ExpressionClassification.Classifications.MethodGroup
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.MethodPointer
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.PropertyAccess
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.Void
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.Type
                 Dim exp As Expression = Nothing
                 If m_Classification.AsTypeClassification.CreateAliasExpression(Me, exp) = False Then
                     Throw New InternalException(Me)
                 End If
                 If exp.Classification.IsPropertyGroupClassification Then
                     exp = exp.ReclassifyToPropertyAccessExpression
                     If exp.ResolveExpression(ResolveInfo.Default(Compiler)) = False Then
                         Throw New InternalException(Me)
                     End If
                 End If
                 Helper.Assert(exp.Classification.IsPropertyAccessClassification)
                 Return exp
             Case ExpressionClassification.Classifications.Namespace
                 Throw New InternalException(Me)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="328" nfragments="2">
<clone_fragment endline="258" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" hamdist="0" pcid="8261" startline="216"><![CDATA[
 
     Function TypeCodeToType(ByVal Code As TypeCode) As Mono.Cecil.TypeReference
         Select Case Code
             Case TypeCode.Boolean
                 Return Compiler.TypeCache.System_Boolean
             Case TypeCode.Byte
                 Return Compiler.TypeCache.System_Byte
             Case TypeCode.Char
                 Return Compiler.TypeCache.System_Char
             Case TypeCode.DateTime
                 Return Compiler.TypeCache.System_DateTime
             Case TypeCode.DBNull
                 Throw New InternalException("")
             Case TypeCode.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case TypeCode.Double
                 Return Compiler.TypeCache.System_Double
             Case TypeCode.Empty
                 Throw New InternalException("")
             Case TypeCode.Int16
                 Return Compiler.TypeCache.System_Int16
             Case TypeCode.Int32
                 Return Compiler.TypeCache.System_Int32
             Case TypeCode.Int64
                 Return Compiler.TypeCache.System_Int64
             Case TypeCode.Object
                 Return Compiler.TypeCache.System_Object
             Case TypeCode.SByte
                 Return Compiler.TypeCache.System_SByte
             Case TypeCode.Single
                 Return Compiler.TypeCache.System_Single
             Case TypeCode.String
                 Return Compiler.TypeCache.System_String
             Case TypeCode.UInt16
                 Return Compiler.TypeCache.System_UInt16
             Case TypeCode.UInt32
                 Return Compiler.TypeCache.System_UInt32
             Case TypeCode.UInt64
                 Return Compiler.TypeCache.System_UInt64
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="826" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="0" pcid="7349" startline="787"><![CDATA[
 
     Public Overloads Shared Function [GetType](ByVal Compiler As Compiler, ByVal value As Object) As Mono.Cecil.TypeReference
         If value Is Nothing Then Throw New InternalException("'Nothing' doesn't have a type")
         Select Case Type.GetTypeCode(value.GetType)
             Case TypeCode.Boolean
                 Return Compiler.TypeCache.System_Boolean
             Case TypeCode.Byte
                 Return Compiler.TypeCache.System_Byte
             Case TypeCode.Char
                 Return Compiler.TypeCache.System_Char
             Case TypeCode.DateTime
                 Return Compiler.TypeCache.System_DateTime
             Case TypeCode.DBNull
                 Return Compiler.TypeCache.System_DBNull
             Case TypeCode.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case TypeCode.Double
                 Return Compiler.TypeCache.System_Double
             Case TypeCode.Int16
                 Return Compiler.TypeCache.System_Int16
             Case TypeCode.Int32
                 Return Compiler.TypeCache.System_Int32
             Case TypeCode.Int64
                 Return Compiler.TypeCache.System_Int64
             Case TypeCode.SByte
                 Return Compiler.TypeCache.System_SByte
             Case TypeCode.Single
                 Return Compiler.TypeCache.System_Single
             Case TypeCode.String
                 Return Compiler.TypeCache.System_String
             Case TypeCode.UInt16
                 Return Compiler.TypeCache.System_UInt16
             Case TypeCode.UInt32
                 Return Compiler.TypeCache.System_UInt32
             Case TypeCode.UInt64
                 Return Compiler.TypeCache.System_UInt64
             Case Else
                 Throw New InternalException(String.Format("No constant value can be of the type '{0}'", value.GetType.FullName))
         End Select
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="329" nfragments="2">
<clone_fragment endline="559" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" hamdist="0" pcid="3605" startline="528"><![CDATA[
 
 		Module LoadModuleFile (AssemblyDefinitionDynamic assembly, string module)
 		{
 			string total_log = "";
 
 			try {
 				try {
 					return assembly.IncludeModule (module);
 				} catch (FileNotFoundException) {
 					bool err = true;
 					foreach (string dir in paths) {
 						string full_path = Path.Combine (dir, module);
 						if (!module.EndsWith (".netmodule"))
 							full_path += ".netmodule";
 
 						try {
 							return assembly.IncludeModule (full_path);
 						} catch (FileNotFoundException ff) {
 							total_log += ff.FusionLog;
 						}
 					}
 					foreach (string dir in paths) {
 						string full_path = Path.Combine (dir, module);
 						if (!module.EndsWith (".netmodule"))
 							full_path += ".netmodule";
 
 						try {
 							return assembly.IncludeModule (full_path);
 						} catch (FileNotFoundException ff) {
 							total_log += ff.FusionLog;
 						}
 					}
 					if (err) {
 						Error_FileNotFound (module);
 						return null;
 					}
 				}
 			} catch (BadImageFormatException) {
 				Error_FileCorrupted (module);
 			}
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="522" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" hamdist="13" pcid="3603" startline="480"><![CDATA[
 
 		Assembly LoadAssemblyFile (string assembly, bool soft)
 		{
 			Assembly a = null;
 
 			try {
 				try {
 					char[] path_chars = { '/', '\\' };
 
 					if (assembly.IndexOfAny (path_chars) != -1) {
 						a = Assembly.LoadFrom (assembly);
 					} else {
 						string ass = assembly;
 						if (ass.EndsWith (".dll") || ass.EndsWith (".exe"))
 							ass = assembly.Substring (0, assembly.Length - 4);
 						a = Assembly.Load (ass);
 					}
 				} catch (FileNotFoundException) {
 					bool err = !soft;
 					foreach (string dir in paths) {
 						string full_path = Path.Combine (dir, assembly);
 						if (!assembly.EndsWith (".dll") && !assembly.EndsWith (".exe"))
 							full_path += ".dll";
 
 						try {
 							a = Assembly.LoadFrom (full_path);
 							err = false;
 							break;
 						} catch (FileNotFoundException) {
 						}
 					}
 					foreach (string dir in paths) {
 						string full_path = Path.Combine (dir, assembly);
 						if (!assembly.EndsWith (".dll") && !assembly.EndsWith (".exe"))
 							full_path += ".dll";
 
 						try {
 							a = Assembly.LoadFrom (full_path);
 							err = false;
 							break;
 						} catch (FileNotFoundException) {
 						}
 					}
 
 					if (err) {
 						Error_FileNotFound (assembly);
 						return a;
 					}
 				}
 			} catch (BadImageFormatException) {
 				Error_FileCorrupted (assembly);
 			}
 
 			return a;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="330" nfragments="2">
<clone_fragment endline="238" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" hamdist="0" pcid="8227" startline="196"><![CDATA[
 
     ''' <summary>
     ''' Loads all the referenced assemblies.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function LoadReferencedAssemblies() As Boolean
         Dim result As Boolean = True
         Dim refAssembly As Mono.Cecil.AssemblyDefinition
         Dim loadedFiles As New Generic.List(Of String)
         Dim loaded As Boolean
         Dim fullPath As String = Nothing
 
         For Each strFile As String In Compiler.CommandLine.References
             If loadedFiles.Contains(strFile) Then Continue For
             loadedFiles.Add(strFile)
 
             refAssembly = LoadAssembly(strFile, fullPath)
             If refAssembly Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC2017, Span.CommandLineSpan, strFile)
                 Return False
             End If
 
             loaded = False
             For a As Integer = 0 To CecilAssemblies.Count - 1
                 If Helper.CompareNameOrdinal(CecilAssemblies(a).Name.FullName, refAssembly.Name.FullName) Then
                     loaded = True
                     Exit For
                 End If
             Next
             If loaded Then Continue For
 
             If Compiler.CommandLine.Verbose Then
                 Compiler.Report.WriteLine(String.Format("Loaded {0} => {1}", fullPath, refAssembly.Name))
             End If
             m_CecilAssemblies.Add(refAssembly)
             Compiler.AssemblyResolver.RegisterAssembly(refAssembly)
         Next
 
         Compiler.TypeCache.Init()
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="282" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeManager.vb" hamdist="13" pcid="8229" startline="239"><![CDATA[
 
     ''' <summary>
     ''' Loads all the types (referenced and compiled) and all the namespaces as well.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function LoadReferenced() As Boolean
         Dim result As Boolean = True
 
         result = LoadReferencedAssemblies() AndAlso result
         If result = False Then Return result
 
         For Each ass As Mono.Cecil.AssemblyDefinition In CecilAssemblies
             If Helper.CompareNameOrdinal(ass.Name.Name, "Microsoft.VisualBasic") Then
                 Compiler.TypeCache.InitInternalVB()
                 Exit For
             End If
         Next
 
         result = LoadReferencedTypes() AndAlso result
 
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine(String.Format("{0} assemblies were loaded.", Assemblies.Count.ToString))
         If Compiler.CommandLine.Verbose Then
             For i As Integer = 0 To Assemblies.Count - 1
                 Compiler.Report.WriteLine("#" & (i + 1).ToString & "
             Next
         End If
         Compiler.Report.WriteLine(String.Format("{0} namespaces were loaded.", Namespaces.Count))
         If Compiler.CommandLine.Verbose Then
             Dim ns As String() = Namespaces.NamespacesAsString
             For i As Integer = 0 To ns.Length - 1
                 Compiler.Report.WriteLine("#" & (i + 1).ToString & "
             Next
         End If
         Compiler.Report.WriteLine(String.Format("{0} types were loaded.", Types.Count))
         If Compiler.CommandLine.Verbose Then
             For i As Integer = 0 To Types.Count - 1
                 'Compiler.Report.WriteLine("#" & (i + 1).ToString & "
             Next
         End If
 #End If
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="331" nfragments="3">
<clone_fragment endline="1096" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="0" pcid="8185" startline="1057"><![CDATA[
 
     Public Shared Function ConvertToDateTime(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Boolean", "Date")
             Case TypeCode.Byte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Byte", "Date")
             Case TypeCode.Char
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Date")
             Case TypeCode.DateTime
                 result = Source
                 Return True
             Case TypeCode.Decimal
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Decimal", "Date")
             Case TypeCode.Double
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30533, Context.Location)
             Case TypeCode.Int16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Short", "Date")
             Case TypeCode.Int32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Integer", "Date")
             Case TypeCode.Int64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Long", "Date")
             Case TypeCode.SByte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "SByte", "Date")
             Case TypeCode.Single
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Single", "Date")
             Case TypeCode.String
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Date")
             Case TypeCode.UInt16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "UShort", "Date")
             Case TypeCode.UInt32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "UInteger", "Date")
             Case TypeCode.UInt64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "ULong", "Date")
             Case TypeCode.DBNull
                 result = New Date()
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Date")
     End Function
]]></clone_fragment>
<clone_fragment endline="1463" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="10" pcid="8201" startline="1423"><![CDATA[
 
     Public Shared Function ConvertToString(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Boolean", "String")
             Case TypeCode.Byte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Byte", "String")
             Case TypeCode.Char
                 result = CStr(DirectCast(Source, Char))
                 Return True
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Date", "String")
             Case TypeCode.Decimal
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Decimal", "String")
             Case TypeCode.Double
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Double", "String")
             Case TypeCode.Int16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Short", "String")
             Case TypeCode.Int32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Integer", "String")
             Case TypeCode.Int64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Long", "String")
             Case TypeCode.SByte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "SByte", "String")
             Case TypeCode.Single
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Single", "String")
             Case TypeCode.String
                 result = Source
                 Return True
             Case TypeCode.UInt16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "UShort", "String")
             Case TypeCode.UInt32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "UInteger", "String")
             Case TypeCode.UInt64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "ULong", "String")
             Case TypeCode.DBNull
                 result = Nothing
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "String")
     End Function
]]></clone_fragment>
<clone_fragment endline="1056" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="8" pcid="8183" startline="1011"><![CDATA[
 
     Public Shared Function ConvertToChar(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Boolean", "Char")
             Case TypeCode.Byte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Byte")
             Case TypeCode.Char
                 result = Source
                 Return True
             Case TypeCode.DateTime
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "DateTime", "Char")
             Case TypeCode.Decimal
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Decimal", "Char")
             Case TypeCode.Double
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Double", "Char")
             Case TypeCode.Int16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Short")
             Case TypeCode.Int32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Integer")
             Case TypeCode.Int64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Long")
             Case TypeCode.SByte
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "SByte")
             Case TypeCode.Single
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Single", "Char")
             Case TypeCode.String
                 Dim str As String = DirectCast(Source, String)
                 If str.Length >= 1 Then
                     result = str(0)
                 Else
                     result = CChar(Nothing)
                 End If
                 Return True
             Case TypeCode.UInt16
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "UShort")
             Case TypeCode.UInt32
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "UInteger")
             Case TypeCode.UInt64
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "ULong")
             Case TypeCode.DBNull
                 result = VB.Chr(0)
                 Return True
         End Select
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Char")
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="332" nfragments="10">
<clone_fragment endline="925" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="0" pcid="8091" startline="885"><![CDATA[
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case """"c '
                     'If " followed by a ", output one "
                     If NextChar() = """" Then
                         StringBuilderAppend(""""c)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     'vbc accepts this...
                     Compiler.Report.ShowMessage(Messages.VBNC90003, GetCurrentLocation())
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC90004, GetCurrentLocation())
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
]]></clone_fragment>
<clone_fragment endline="233" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" hamdist="11" pcid="6303" startline="200"><![CDATA[
 
     Function RuleIntegerDivision(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleMultiplicationAndRealDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.IntDivision)
             NextToken()
             RuleMultiplicationAndRealDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf CLng(op2) = 0 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                 LSide = CDbl(0)
             Else
                 LSide = CDbl(CLng(op1) \ CLng(op2))
             End If
         End While
         While CurrentToken.Equals(KS.IntDivision)
             NextToken()
             RuleMultiplicationAndRealDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf CLng(op2) = 0 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                 LSide = CDbl(0)
             Else
                 LSide = CDbl(CLng(op1) \ CLng(op2))
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="547" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" hamdist="8" pcid="6321" startline="517"><![CDATA[
 
     Function RuleXor(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleOr_OrElse(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Xor)
             NextToken()
             RuleOr_OrElse(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             Else
                 LSide = op1 Xor op2
             End If
         End While
         While CurrentToken.Equals(KS.Xor)
             NextToken()
             RuleOr_OrElse(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             Else
                 LSide = op1 Xor op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="264" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" hamdist="6" pcid="6305" startline="234"><![CDATA[
 
     Function RuleMod(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIntegerDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="135" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" hamdist="1" pcid="6297" startline="105"><![CDATA[
 
     Function RuleExponent(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIdentifier(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Power)
             NextToken()
             RuleIdentifier(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             Else
                 LSide = op1 ^ op2
             End If
         End While
         While CurrentToken.Equals(KS.Power)
             NextToken()
             RuleIdentifier(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             Else
                 LSide = op1 ^ op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="174" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" hamdist="16" pcid="7903" startline="109"><![CDATA[
     End Property
 
     Private Function DefineSecurityDeclarations() As Boolean
         Dim result As Boolean = True
         Dim checkedAll As Boolean = True
 
         If m_DefinedSecurityDeclarations Then Return True
 
         If CustomAttributes Is Nothing Then Return True
 
 
         For i As Integer = 0 To CustomAttributes.Count - 1
             If CustomAttributes(i).ResolvedType Is Nothing Then
                 checkedAll = False
                 Exit For
             End If
         Next
 
         If Not checkedAll Then Return True
 
         For i As Integer = CustomAttributes.Count - 1 To 0 Step -1
             Dim attrib As Attribute = CustomAttributes(i)
 
             If Not Helper.IsSubclassOf(Compiler.TypeCache.System_Security_Permissions_SecurityAttribute, attrib.ResolvedType) Then Continue For
 
             Try
                 Dim sec As Mono.Cecil.SecurityDeclaration
                 Dim secAtt As Mono.Cecil.SecurityAttribute
                 Dim attribInstantiation As Object = Nothing
                 Dim attribInstance As SecurityAttribute
                 Dim attribAction As Mono.Cecil.SecurityAction
                 Dim attribPermissionSetAttribute As PermissionSetAttribute
 
                 If attrib.Instantiate(Messages.VBNC30128, attribInstantiation) = False Then
                     'Attribute.Instantiate prints an error message
                     result = False
                     Continue For
                 End If
 
                 attribInstance = TryCast(attribInstantiation, SecurityAttribute)
                 If attribInstance Is Nothing Then
                     Compiler.Report.ShowMessage(Messages.VBNC30128, attrib.Location, "Security attribute does not inherit from System.Security.Permissions.SecurityAttribute")
                     result = False
                     Continue For
                 End If
 
                 attribAction = CType(attribInstance.Action, Mono.Cecil.SecurityAction)
                 attribPermissionSetAttribute = TryCast(attribInstance, PermissionSetAttribute)
 
                 sec = New Mono.Cecil.SecurityDeclaration(attribAction)
                 secAtt = attrib.GetSecurityAttribute()
                 sec.SecurityAttributes.Add(secAtt)
                 CecilBuilder.SecurityDeclarations.Add(sec)
                 CustomAttributes.Remove(attrib)
                 CecilBuilder.CustomAttributes.Remove(attrib.CecilBuilder)
             Catch ex As Exception
                 Compiler.Report.ShowMessage(Messages.VBNC30128, attrib.Location, ex.Message)
                 result = False
             End Try
 
         Next
 
         m_DefinedSecurityDeclarations = True
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="385" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" hamdist="12" pcid="6311" startline="346"><![CDATA[
 
     Function RuleArithmeticBitshift(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleStringConcat(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.ShiftLeft, KS.ShiftRight)
             Dim DoLeft As Boolean
             DoLeft = CurrentToken.Equals(KS.ShiftLeft)
             NextToken()
             RuleStringConcat(RSide)
 
             Dim op1 As Double, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Integer.ToString)
                 bErr = True
             End If
             If op1 < Long.MinValue OrElse op1 > Long.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Long.ToString)
             ElseIf op2 < Integer.MinValue OrElse op2 > Integer.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Integer.ToString)
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoLeft Then
                 LSide = CLng(op1) << CInt(op2)
             Else
                 LSide = CLng(op1) >> CInt(op2)
             End If
         End While
         While CurrentToken.Equals(KS.ShiftLeft, KS.ShiftRight)
             Dim DoLeft As Boolean
             DoLeft = CurrentToken.Equals(KS.ShiftLeft)
             NextToken()
             RuleStringConcat(RSide)
 
             Dim op1 As Double, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Integer.ToString)
                 bErr = True
             End If
             If op1 < Long.MinValue OrElse op1 > Long.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Long.ToString)
             ElseIf op2 < Integer.MinValue OrElse op2 > Integer.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Integer.ToString)
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoLeft Then
                 LSide = CLng(op1) << CInt(op2)
             Else
                 LSide = CLng(op1) >> CInt(op2)
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="199" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" hamdist="5" pcid="6301" startline="159"><![CDATA[
 
     Function RuleMultiplicationAndRealDivision(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleUnaryNegation(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim DoMult As Boolean
             DoMult = CurrentToken.Equals(KS.Mult)
             NextToken()
 
             RuleUnaryNegation(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoMult Then
                 LSide = op1 * op2
             Else
                 If op2 = 0 Then
                     Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                     LSide = CDbl(0)
                 Else
                     LSide = op1 / op2
                 End If
             End If
         End While
         While CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim DoMult As Boolean
             DoMult = CurrentToken.Equals(KS.Mult)
             NextToken()
 
             RuleUnaryNegation(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoMult Then
                 LSide = op1 * op2
             Else
                 If op2 = 0 Then
                     Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                     LSide = CDbl(0)
                 Else
                     LSide = op1 / op2
                 End If
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="516" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" hamdist="13" pcid="6319" startline="482"><![CDATA[
 
     Function RuleOr_OrElse(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleAnd_AndAlso(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Or, KS.OrElse)
             Dim DoElse As Boolean
             DoElse = CurrentToken.Equals(KS.OrElse)
             NextToken()
             RuleAnd_AndAlso(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoElse Then
                 LSide = op1 OrElse op2 'Since its a constant expression, there's no difference between Or & OrElse
             Else
                 LSide = op1 Or op2
             End If
         End While
         While CurrentToken.Equals(KS.Or, KS.OrElse)
             Dim DoElse As Boolean
             DoElse = CurrentToken.Equals(KS.OrElse)
             NextToken()
             RuleAnd_AndAlso(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoElse Then
                 LSide = op1 OrElse op2 'Since its a constant expression, there's no difference between Or & OrElse
             Else
                 LSide = op1 Or op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="481" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\ConditionalCompilation\ConditionalExpression.vb" hamdist="6" pcid="6317" startline="447"><![CDATA[
 
     Function RuleAnd_AndAlso(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleNot(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim DoAlso As Boolean
             DoAlso = CurrentToken.Equals(KS.AndAlso)
             NextToken()
             RuleNot(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoAlso Then
                 LSide = op1 AndAlso op2 'Since its a constant expression, there's no difference between And & AndAlso
             Else
                 LSide = op1 And op2
             End If
         End While
         While CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim DoAlso As Boolean
             DoAlso = CurrentToken.Equals(KS.AndAlso)
             NextToken()
             RuleNot(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoAlso Then
                 LSide = op1 AndAlso op2 'Since its a constant expression, there's no difference between And & AndAlso
             Else
                 LSide = op1 And op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="333" nfragments="2">
<clone_fragment endline="2208" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="0" pcid="1951" startline="2175"><![CDATA[
 		}
 
 		public virtual void Emit (DeclSpace parent)
 		{
 			method_data.Emit (parent);
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (method_data.MethodBuilder);
 			if (((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0))
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (method_data.MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					method_data.MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					method_data.MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 				foreach (var de in declarative_security) {
 #if STATIC
 					method_data.MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					method_data.MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			block = null;
 		}
]]></clone_fragment>
<clone_fragment endline="637" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="8" pcid="1251" startline="601"><![CDATA[
 
 		public override void Emit ()
 		{
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (MethodBuilder);
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			if (MethodData != null)
 				MethodData.Emit (Parent);
 
 			base.Emit ();
 
 			Block = null;
 			MethodData = null;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="334" nfragments="2">
<clone_fragment endline="265" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7525" startline="225"><![CDATA[
 
 
     Public Shared Function GetAttributes(ByVal Compiler As Compiler, ByVal m_Declaration As IFieldMember) As Mono.Cecil.FieldAttributes
         Dim result As Mono.Cecil.FieldAttributes
 
         If m_Declaration.Modifiers.Is(ModifierMasks.WithEvents) Then
             result = Mono.Cecil.FieldAttributes.Private
         Else
             result = m_Declaration.Modifiers.GetFieldAttributeScope(DirectCast(m_Declaration, BaseObject).FindFirstParent(Of TypeDeclaration))
         End If
 
         If m_Declaration.Modifiers.Is(ModifierMasks.Static) Then
             result = result Or Mono.Cecil.FieldAttributes.SpecialName
             If DirectCast(m_Declaration, BaseObject).FindFirstParent(Of IMethod).IsShared Then
                 result = result Or Mono.Cecil.FieldAttributes.Static
             End If
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.Shared) OrElse m_Declaration.IsShared Then
             result = result Or Mono.Cecil.FieldAttributes.Static
         End If
         If TypeOf m_Declaration Is EnumMemberDeclaration Then
             result = result Or Mono.Cecil.FieldAttributes.Static Or Mono.Cecil.FieldAttributes.Literal
         End If
         If TypeOf m_Declaration Is ConstantDeclaration Then
             result = result Or Mono.Cecil.FieldAttributes.Static
             If m_Declaration.FieldType IsNot Nothing Then
                 If Helper.CompareType(m_Declaration.FieldType, Compiler.TypeCache.System_Decimal) Then
                     result = result Or Mono.Cecil.FieldAttributes.InitOnly
                 ElseIf Helper.CompareType(m_Declaration.FieldType, Compiler.TypeCache.System_DateTime) Then
                     result = result Or Mono.Cecil.FieldAttributes.InitOnly
                 Else
                     result = result Or Mono.Cecil.FieldAttributes.Literal Or Mono.Cecil.FieldAttributes.HasDefault
                 End If
             End If
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.ReadOnly) Then
             result = result Or Mono.Cecil.FieldAttributes.InitOnly
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="224" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="12" pcid="7523" startline="146"><![CDATA[
 
     Public Shared Function GetAttributes(ByVal m_Declaration As MethodBaseDeclaration) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
 
         result = m_Declaration.Modifiers.GetMethodAttributeScope
 
         'If Modifiers.IsNothing(m_Declaration.Modifiers) = False Then
         If m_Declaration.IsShared Then
             result = result Or Mono.Cecil.MethodAttributes.Static
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.MustOverride) Then
             If m_Declaration.Modifiers.Is(ModifierMasks.Overrides) = False Then
                 result = result Or Mono.Cecil.MethodAttributes.NewSlot
             End If
             result = result Or Mono.Cecil.MethodAttributes.Abstract Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.NotOverridable) Then
             result = result Or Mono.Cecil.MethodAttributes.Final
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.Overridable) Then
             result = result Or Mono.Cecil.MethodAttributes.NewSlot Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.Overrides) Then
             result = result Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.Overloads) Then
             result = result Or Mono.Cecil.MethodAttributes.HideBySig
         End If
         'End If
 
         If TypeOf m_Declaration.Parent Is PropertyDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.SpecialName
         End If
 
         If TypeOf m_Declaration Is ExternalSubDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.Static
         End If
 
         If m_Declaration.HandlesOrImplements IsNot Nothing Then
             If m_Declaration.HandlesOrImplements.ImplementsClause IsNot Nothing Then
                 result = result Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride
                 If m_Declaration.Modifiers.Is(ModifierMasks.Overrides) = False Then
                     result = result Or Mono.Cecil.MethodAttributes.NewSlot
                 End If
                 If m_Declaration.Modifiers.Is(ModifierMasks.Overridable) = False AndAlso m_Declaration.Modifiers.Is(ModifierMasks.MustOverride) = False AndAlso m_Declaration.Modifiers.Is(ModifierMasks.Overrides) = False Then
                     result = result Or Mono.Cecil.MethodAttributes.Final
                 End If
             End If
         End If
 
         If TypeOf m_Declaration.Parent Is EventDeclaration Then
             If DirectCast(m_Declaration.Parent, EventDeclaration).ImplementsClause IsNot Nothing Then
                 result = result Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.NewSlot Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride Or Mono.Cecil.MethodAttributes.Final
             End If
         End If
 
         If m_Declaration.DeclaringType.IsInterface Then
             result = result Or Mono.Cecil.MethodAttributes.Abstract Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride Or Mono.Cecil.MethodAttributes.NewSlot
         End If
         If TypeOf m_Declaration Is OperatorDeclaration OrElse TypeOf m_Declaration Is ConversionOperatorDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.SpecialName
         ElseIf TypeOf m_Declaration Is EventHandlerDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.SpecialName
         End If
 
         If m_Declaration.CustomAttributes IsNot Nothing AndAlso m_Declaration.CustomAttributes.IsDefined(m_Declaration.Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute) Then
             result = result Or Mono.Cecil.MethodAttributes.PInvokeImpl
         End If
 
         If TypeOf m_Declaration Is ExternalSubDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.PInvokeImpl
         End If
 
         If m_Declaration.HasSecurityCustomAttribute Then
             result = result Or Mono.Cecil.MethodAttributes.HasSecurity
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="335" nfragments="2">
<clone_fragment endline="344" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="0" pcid="5465" startline="301"><![CDATA[
 
 		public MethodBase GetMetaInfo ()
 		{
 			//
 			// inflatedMetaInfo is extra field needed for cases where we
 			// inflate method but another nested type can later inflate
 			// again (the cache would be build with inflated metaInfo) and
 			// TypeBuilder can work with method definitions only
 			//
 			if (inflatedMetaInfo == null) {
 				if ((state & StateFlags.PendingMetaInflate) != 0) {
 					var dt_meta = DeclaringType.GetMetaInfo ();
 
 					if (DeclaringType.IsTypeBuilder) {
 						if (IsConstructor)
 							inflatedMetaInfo = TypeBuilder.GetConstructor (dt_meta, (ConstructorInfo) metaInfo);
 						else
 							inflatedMetaInfo = TypeBuilder.GetMethod (dt_meta, (MethodInfo) metaInfo);
 					} else {
 #if STATIC
 						// it should not be reached
 						throw new NotImplementedException ();
 #else
 						inflatedMetaInfo = MethodInfo.GetMethodFromHandle (metaInfo.MethodHandle, dt_meta.TypeHandle);
 #endif
 					}
 
 					state &= ~StateFlags.PendingMetaInflate;
 				} else {
 					inflatedMetaInfo = metaInfo;
 				}
 			}
 
 			if ((state & StateFlags.PendingMakeMethod) != 0) {
 				var sre_targs = new MetaType[targs.Length];
 				for (int i = 0; i < sre_targs.Length; ++i)
 					sre_targs[i] = targs[i].GetMetaInfo ();
 				for (int i = 0; i < sre_targs.Length; ++i)
 					sre_targs[i] = targs[i].GetMetaInfo ();
 
 				inflatedMetaInfo = ((MethodInfo) inflatedMetaInfo).MakeGenericMethod (sre_targs);
 				state &= ~StateFlags.PendingMakeMethod;
 			}
 
 			return inflatedMetaInfo;
 		}
]]></clone_fragment>
<clone_fragment endline="2110" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="11" pcid="4399" startline="2052"><![CDATA[
 
 		//
 		// When any element of the type is a dynamic type
 		//
 		// This method builds a transformation array for dynamic types
 		// used in places where DynamicAttribute cannot be applied to.
 		// It uses bool flag when type is of dynamic type and each
 		// section always starts with "false" for some reason.
 		//
 		// LAMESPEC
 		// 
 		// Example
 		// Transformation
 		//
 		static bool[] GetTransformationFlags (TypeSpec t)
 		{
 			bool[] element;
 			var ac = t as ArrayContainer;
 			if (ac != null) {
 				element = GetTransformationFlags (ac.Element);
 				if (element == null)
 					return null;
 
 				bool[] res = new bool[element.Length + 1];
 				res[0] = false;
 				Array.Copy (element, 0, res, 1, element.Length);
 				return res;
 			}
 
 			if (t == null)
 				return null;
 
 			if (t.IsGeneric) {
 				List<bool> transform = null;
 				var targs = t.TypeArguments;
 				for (int i = 0; i < targs.Length; ++i) {
 					element = GetTransformationFlags (targs[i]);
 					if (element != null) {
 						if (transform == null) {
 							transform = new List<bool> ();
 							for (int ii = 0; ii <= i; ++ii)
 								transform.Add (false);
 							for (int ii = 0; ii <= i; ++ii)
 								transform.Add (false);
 						}
 
 						transform.AddRange (element);
 					} else if (transform != null) {
 						transform.Add (false);
 					}
 				}
 				for (int i = 0; i < targs.Length; ++i) {
 					element = GetTransformationFlags (targs[i]);
 					if (element != null) {
 						if (transform == null) {
 							transform = new List<bool> ();
 							for (int ii = 0; ii <= i; ++ii)
 								transform.Add (false);
 						}
 
 						transform.AddRange (element);
 					} else if (transform != null) {
 						transform.Add (false);
 					}
 				}
 
 				if (transform != null)
 					return transform.ToArray ();
 			}
 
 			if (t == InternalType.Dynamic)
 				return new bool[] { true };
 
 			return null;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="336" nfragments="2">
<clone_fragment endline="3962" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7821" startline="3917"><![CDATA[
 
     Shared Function GetDominantType(ByVal Compiler As Compiler, ByVal types As Generic.List(Of TypeReference)) As TypeReference
         Dim implicit() As Boolean
         Dim count As Integer
         Dim index As Integer
 
         'Given a set of types, it is often necessary in situations such as type inference to determine the dominant type of the set. 
 
         If types Is Nothing OrElse types.Count = 0 Then Return Nothing
         If types.Count = 1 Then Return types(0)
 
         ReDim implicit(types.Count - 1)
 
         For i As Integer = 0 To implicit.Length - 1
             implicit(i) = True
         Next
 
         'The dominant type of a set of types is determined by first removing any types that one or more other types do not have an implicit conversion to. 
         For i As Integer = 0 To types.Count - 1
             For j As Integer = 0 To types.Count - 1
                 If i = j Then Continue For
                 If Compiler.TypeResolution.IsImplicitlyConvertible(Compiler, types(i), types(j)) = False Then
                     implicit(j) = False
                     Exit For
                 End If
             Next
         Next
 
         count = 0
         For i As Integer = 0 To implicit.Length - 1
             If implicit(i) Then
                 index = i
                 count += 1
             End If
         Next
 
         'If there are no types left at this point, there is no dominant type. 
         If count = 0 Then Return Nothing
 
         'The dominant type is then the most encompassed of the remaining types. 
         If count = 1 Then Return types(index)
 
         'The dominant type is then the most encompassed of the remaining types. 
         'If there is more than one type that is most encompassed, then there is no dominant type. 
         Return GetMostEncompassedType(Compiler, types)
     End Function
]]></clone_fragment>
<clone_fragment endline="2730" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="13" pcid="7733" startline="2687"><![CDATA[
 
     Shared Function GetMostEncompassedType(ByVal Compiler As Compiler, ByVal Types As Generic.List(Of TypeReference)) As TypeReference
         Dim result() As Boolean
 
         '?	If an intrinsic widening conversion exists from a type A to a type B, and if neither A nor B are interfaces, then A is encompassed by B, and B encompasses A.
         '?	The most encompassing type in a set of types is the one type that encompasses all other types in the set. 
         '   If no single type encompasses all other types, then the set has no most encompassing type. 
         '   In intuitive terms, the most encompassing type is the ?largest? type in the set?the one type to 
         '   which each of the other types can be converted through a widening conversion.
         '?	The most encompassed type in a set of types is the one type that is encompassed by all other types in the set. 
         '   If no single type is encompassed by all other types, then the set has no most encompassed type. 
         '   In intuitive terms, the most encompassed type is the ?smallest? type in the set?the one type that 
         '   can be converted to each of the other types through a narrowing conversion.
 
         If Types Is Nothing OrElse Types.Count = 0 Then Return Nothing
         If Types.Count = 1 Then Return Types(0)
 
         ReDim result(Types.Count - 1)
         For i As Integer = 0 To result.Length - 1
             result(i) = True
         Next
 
         For i As Integer = 0 To result.Length - 1
             For j As Integer = i + 1 To result.Length - 1
                 If result(j) AndAlso IsFirstEncompassingSecond(Compiler, Types(i), Types(j)) Then
                     result(j) = False
                 ElseIf result(i) AndAlso IsFirstEncompassingSecond(Compiler, Types(j), Types(i)) Then
                     result(i) = False
                 End If
             Next
         Next
 
         Dim count As Integer
         Dim index As Integer
         For i As Integer = 0 To result.Length - 1
             If result(i) Then
                 count += 1
                 index = i
             End If
         Next
 
         If count <> 1 Then Return Nothing
         Return Types(index)
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="337" nfragments="2">
<clone_fragment endline="253" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" hamdist="0" pcid="9707" startline="208"><![CDATA[
 
     Private Function CreateImplicitMembers() As Boolean Implements IHasImplicitMembers.CreateImplicitMembers
         Dim result As Boolean = True
 
         If m_CreatedImplicitMembers Then Return True
 
         result = CreateBaseImplicitMembers() AndAlso result
 
         If result = False Then Return result
 
         'If a type contains no instance constructor declarations, a default constructor 
         'is automatically provided. The default constructor simply invokes the 
         'parameterless constructor of the direct base type. If the direct 
         'base type does not have an accessible parameterless constructor, 
         'a compile-time error occurs. 
         'The declared access type for the default constructor is always Public. 
         If HasInstanceConstructors = False Then
             Dim baseDefaultCtor As Mono.Cecil.MethodReference
             baseDefaultCtor = Me.GetBaseDefaultConstructor()
 
             If baseDefaultCtor IsNot Nothing Then
                 If Helper.IsPrivate(baseDefaultCtor) Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30387, Location, Name, BaseType.Name) AndAlso result
                 Else
                     DefaultInstanceConstructor = ConstructorDeclaration.CreateDefaultConstructor(Me)
                     Members.Add(DefaultInstanceConstructor)
 
                     result = AddInitializeComponentCall(DefaultInstanceConstructor) AndAlso result
                 End If
             Else
                 result = Compiler.Report.ShowMessage(Messages.VBNC30387, Location, Name, BaseType.Name) AndAlso result
             End If
         End If
 
         If DefaultSharedConstructor Is Nothing AndAlso Me.HasSharedFieldsWithInitializers Then
             DefaultSharedConstructor = ConstructorDeclaration.CreateTypeConstructor(Me)
             Members.Add(DefaultSharedConstructor)
             BeforeFieldInit = True
         End If
 
         result = CreateMyGroupMembers() AndAlso result
 
         m_CreatedImplicitMembers = True
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="579" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" hamdist="13" pcid="7117" startline="500"><![CDATA[
 
     Private Function ResolveMethodInvocation() As Boolean
         Dim result As Boolean = True
         Dim mgc As MethodGroupClassification = m_Expression.Classification.AsMethodGroupClassification
 
         'If the method group only contains one method and that method takes no arguments and is a function, 
         'then the method group is interpreted as an invocation expression 
         'with an empty argument list and the result is used as the target of an index expression.
 
         Dim reclassifyToIndex As Boolean
         If mgc.Group.Count = 1 AndAlso m_ArgumentList.Count > 0 Then
             Dim method As Mono.Cecil.MethodReference = TryCast(mgc.Group(0), Mono.Cecil.MethodReference)
 
             reclassifyToIndex = method IsNot Nothing
             reclassifyToIndex = reclassifyToIndex AndAlso method.ReturnType IsNot Nothing
             reclassifyToIndex = reclassifyToIndex AndAlso Helper.CompareType(method.ReturnType, Compiler.TypeCache.System_Void) = False
             reclassifyToIndex = reclassifyToIndex AndAlso Helper.GetParameters(Compiler, method).Count = 0
 
         End If
 
         If reclassifyToIndex Then
             Return ResolveReclassifyToValueThenIndex()
         Else
             result = mgc.ResolveGroup(m_ArgumentList)
             If result Then
                 If mgc.IsLateBound = False Then
                     m_ArgumentList.ReplaceAndVerifyArguments(mgc.FinalArguments, mgc.ResolvedMethod)
                 End If
                 result = mgc.VerifyConstraints AndAlso result
                 If result = False Then Return False
             Else
                 mgc.ResolveGroup(m_ArgumentList, True)
                 Return False
             End If
         End If
 
         Helper.StopIfDebugging(result = False)
 
         If mgc.IsLateBound Then
             Dim lba As LateBoundAccessClassification = New LateBoundAccessClassification(Me, mgc.InstanceExpression, Nothing, mgc.Resolver.MethodName)
             lba.LateBoundType = mgc.Resolver.MethodDeclaringType
             lba.Arguments = m_ArgumentList
             Classification = lba
         ElseIf mgc.ResolvedMethodInfo IsNot Nothing Then
             Dim methodInfo As Mono.Cecil.MethodReference = mgc.ResolvedMethodInfo
 
             If String.IsNullOrEmpty(Compiler.CommandLine.VBRuntime) AndAlso Compiler.Assembly.IsDefinedHere(methodInfo) AndAlso CecilHelper.FindDefinition(methodInfo).IsStatic AndAlso Helper.CompareName(methodInfo.Name, "AscW") Then
                 Dim methodParameters As Mono.Collections.Generic.Collection(Of ParameterDefinition) = Helper.GetParameters(Compiler, methodInfo)
 
                 If methodParameters.Count <> 0 AndAlso Helper.CompareType(methodParameters(0).ParameterType, Compiler.TypeCache.System_Char) Then
                     m_AscWExpression = ArgumentList(0).Expression
                     m_ExpressionType = Compiler.TypeCache.System_Int32
                     Classification = New ValueClassification(Me, m_ExpressionType)
 
                     Return result
                 End If
             End If
 
             If mgc.InstanceExpression Is Nothing AndAlso CecilHelper.IsStatic(methodInfo) = False Then
                 Dim mae As MemberAccessExpression = TryCast(m_Expression, MemberAccessExpression)
                 If mae IsNot Nothing AndAlso mae.FirstExpression.Classification.IsTypeClassification AndAlso mae.FirstExpression.Classification.AsTypeClassification.CanBeExpression Then
                     Dim exp As Expression = Nothing
                     result = mae.FirstExpression.Classification.AsTypeClassification.CreateAliasExpression(mae.FirstExpression, exp) AndAlso result
                     mgc.InstanceExpression = exp
                 End If
             End If
 
             If methodInfo.ReturnType Is Nothing OrElse Helper.CompareType(methodInfo.ReturnType, Compiler.TypeCache.System_Void) Then
                 Classification = New VoidClassification(Me)
             Else
                 Classification = New ValueClassification(Me, methodInfo.ReturnType)
             End If
         ElseIf mgc.ResolvedConstructor IsNot Nothing Then
             Classification = New VoidClassification(Me)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="338" nfragments="2">
<clone_fragment endline="140" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberImplementsClause.vb" hamdist="0" pcid="8599" startline="95"><![CDATA[
 
     Function DefineImplements(ByVal Method As Mono.Cecil.MethodDefinition) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Method IsNot Nothing)
 
         For i As Integer = 0 To m_ImplementsList.Count - 1
             Dim ispec As InterfaceMemberSpecifier = Me.m_ImplementsList(i)
             Dim methodI As Mono.Cecil.MethodReference = Nothing
             Dim propertyI As Mono.Cecil.PropertyReference = Nothing
             Dim propertyDef As Mono.Cecil.PropertyDefinition = Nothing
 
             If ispec.ResolvedMethodInfo IsNot Nothing Then
                 methodI = Helper.GetMethodOrMethodReference(Compiler, ispec.ResolvedMethodInfo)
             End If
 
             If ispec.ResolvedPropertyInfo IsNot Nothing Then
                 propertyI = Helper.GetPropertyOrPropertyBuilder(Compiler, ispec.ResolvedPropertyInfo)
                 propertyDef = CecilHelper.FindDefinition(propertyI)
             End If
 
             Helper.Assert(propertyI Is Nothing Xor methodI Is Nothing)
 
             If propertyI IsNot Nothing Then
                 'This is a property
                 If Method.Name.StartsWith("get_") Then
                     methodI = CecilHelper.GetCorrectMember(propertyDef.GetMethod, propertyI.DeclaringType)
                 ElseIf Method.Name.StartsWith("set_") Then
                     methodI = CecilHelper.GetCorrectMember(propertyDef.SetMethod, propertyI.DeclaringType)
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
                 End If
                 methodI = Helper.GetMethodOrMethodReference(Compiler, methodI)
             End If
 
 
             Helper.Assert(methodI IsNot Nothing)
 
             Method.Overrides.Add(CecilHelper.MakeEmittable(methodI))
 
 #If EXTENDEDDEBUG Then
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Defined method override '" & Builder.FullName & "
 #End If
         Next
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="94" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MemberImplementsClause.vb" hamdist="13" pcid="8597" startline="41"><![CDATA[
 
     Function DefineImplements(ByVal Declaration As EventDeclaration) As Boolean
         Dim result As Boolean = True
         Dim declType As Mono.Cecil.TypeDefinition
 
         Helper.Assert(Declaration IsNot Nothing)
 
         declType = Declaration.DeclaringType.CecilType
 
         For i As Integer = 0 To m_ImplementsList.Count - 1
             Dim ispec As InterfaceMemberSpecifier = m_ImplementsList(i)
             Dim eventI As Mono.Cecil.EventDefinition
 
             eventI = CecilHelper.FindDefinition(ispec.ResolvedEventInfo)
 
             Helper.Assert(eventI IsNot Nothing)
 
             Dim addMethodI, removeMethodI As Mono.Cecil.MethodReference
             Dim addMethod, removeMethod As Mono.Cecil.MethodReference
             Dim raiseMethod As Mono.Cecil.MethodReference = Nothing
             Dim raiseMethodI As Mono.Cecil.MethodReference = Nothing
 
             addMethodI = Helper.GetMethodOrMethodReference(Compiler, eventI.AddMethod)
             removeMethodI = Helper.GetMethodOrMethodReference(Compiler, eventI.RemoveMethod)
             If eventI.InvokeMethod IsNot Nothing Then
                 raiseMethodI = Helper.GetMethodOrMethodReference(Compiler, eventI.InvokeMethod)
             End If
 
             addMethod = Helper.GetMethodOrMethodReference(Compiler, Declaration.AddDefinition)
             removeMethod = Helper.GetMethodOrMethodReference(Compiler, Declaration.RemoveDefinition)
             If Declaration.RaiseDefinition IsNot Nothing Then
                 raiseMethod = Helper.GetMethodOrMethodReference(Compiler, Declaration.RaiseDefinition)
             End If
 
             Helper.Assert((addMethodI Is Nothing Xor addMethod Is Nothing) = False)
             Helper.Assert((removeMethodI Is Nothing Xor removeMethod Is Nothing) = False)
             Helper.Assert((raiseMethodI Is Nothing Xor raiseMethod Is Nothing) = False)
 
             If addMethod IsNot Nothing AndAlso addMethodI IsNot Nothing Then
                 Dim methodDef As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(addMethod)
                 methodDef.Overrides.Add(CecilHelper.MakeEmittable(addMethodI))
             End If
             If removeMethod IsNot Nothing AndAlso removeMethodI IsNot Nothing Then
                 Dim methodDef As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(removeMethod)
                 methodDef.Overrides.Add(CecilHelper.MakeEmittable(removeMethodI))
             End If
             If raiseMethod IsNot Nothing AndAlso raiseMethodI IsNot Nothing Then
                 Dim methodDef As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(raiseMethod)
                 methodDef.Overrides.Add(CecilHelper.MakeEmittable(raiseMethodI))
             End If
         Next
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="339" nfragments="2">
<clone_fragment endline="1977" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Emit\Emitter.vb" hamdist="0" pcid="6483" startline="1931"><![CDATA[
 
     Shared Function SwitchVersionedMethods(ByVal Info As EmitInfo, ByVal UnversionedMethod As Mono.Cecil.MethodReference) As Mono.Cecil.MethodReference
         If Info.Compiler.CommandLine.VBVersion <> CommandLine.VBVersions.V8 Then Return UnversionedMethod
 
         Dim tc As CecilTypeCache = Info.Compiler.TypeCache
         Dim check(4) As Mono.Cecil.MethodDefinition
         Dim replace(4) As Mono.Cecil.MethodDefinition
         Dim unv(4) As Mono.Cecil.MethodDefinition
 
         check(0) = tc.MS_VB_Information__IsNumeric
         check(1) = tc.MS_VB_Information__SystemTypeName
         check(2) = tc.MS_VB_Information__TypeName
         check(3) = tc.MS_VB_Information__VbTypeName
         check(4) = tc.MS_VB_Interaction__CallByName
 
         replace(0) = tc.MS_VB_CS_Versioned__IsNumeric
         replace(1) = tc.MS_VB_CS_Versioned__SystemTypeName
         replace(2) = tc.MS_VB_CS_Versioned__TypeName
         replace(3) = tc.MS_VB_CS_Versioned__VbTypeName
         replace(4) = tc.MS_VB_CS_Versioned__CallByName
 
         For i As Integer = 0 To check.Length - 1
             If check(i) Is UnversionedMethod Then Return replace(i)
         Next
 
         For i As Integer = 0 To check.Length - 1
             unv(i) = CecilHelper.FindDefinition(UnversionedMethod)
             If check(i) Is unv(i) Then Return replace(i)
         Next
 
         For i As Integer = 0 To check.Length - 1
             If unv(i) Is Nothing Then Continue For
             If check(i) Is Nothing Then Continue For
             If Helper.CompareName(unv(i).Name, check(i).Name) = False Then Continue For
             If Helper.CompareName(unv(i).DeclaringType.Name, check(i).DeclaringType.Name) = False Then Continue For
             If Helper.CompareName(unv(i).DeclaringType.Namespace, check(i).DeclaringType.Namespace) = False Then Continue For
             'There shouldn't be any need to check parameters, since these methods aren't overloaded
             Return replace(i)
         Next
 
 
         'Check if the object comparison above is true for cecil as well (that is if same method may have multiple object references)
         'This will assert while compiling the compiler if object comparison doesn't hold for cecil.
         Helper.Assert(UnversionedMethod.Name <> "IsNumeric")
 
         Return UnversionedMethod
     End Function
]]></clone_fragment>
<clone_fragment endline="4054" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="12" pcid="7823" startline="3963"><![CDATA[
 
     Public Shared Function VerifyConstraints(ByVal Context As ParsedObject, ByVal parameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal arguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Math.Min(parameters.Count, arguments.Count) - 1
             Dim param As GenericParameter = parameters(i)
             Dim arg As TypeReference = arguments(i)
             Dim gt As GenericParameter = TryCast(arg, GenericParameter)
 
             If param.HasDefaultConstructorConstraint Then
                 If gt IsNot Nothing Then
                     If gt.HasDefaultConstructorConstraint = False AndAlso gt.HasNotNullableValueTypeConstraint = False Then
                         Dim tr As TypeReference = TryCast(param.Owner, TypeReference)
                         If Helper.CompareType(tr, Context.Compiler.TypeCache.System_Nullable1) Then
                             result = Context.Compiler.Report.ShowMessage(Messages.VBNC33101, Context.Location, Helper.ToString(Context, arg))
                         Else
                             result = Context.Compiler.Report.ShowMessage(Messages.VBNC32084, Context.Location, Helper.ToString(Context, arg), param.Name)
                         End If
                         Continue For
                     End If
                 Else
                     Dim ctor As MethodReference = Helper.GetDefaultConstructor(arg)
                     If (ctor Is Nothing OrElse Helper.IsPublic(ctor) = False) AndAlso CecilHelper.IsValueType(arg) = False Then
                         result = Context.Compiler.Report.ShowMessage(Messages.VBNC32083, Context.Location, Helper.ToString(Context, arg), param.Name)
                         Continue For
                     End If
                 End If
             End If
 
             If param.HasNotNullableValueTypeConstraint Then
                 If gt Is Nothing Then
                     If CecilHelper.IsValueType(arg) = False Then
                         result = Context.Compiler.Report.ShowMessage(Messages.VBNC32105, Context.Location, Helper.ToString(Context, arg), param.Name)
                     End If
                 Else
                     If gt.HasNotNullableValueTypeConstraint = False Then
                         result = Context.Compiler.Report.ShowMessage(Messages.VBNC32105, Context.Location, Helper.ToString(Context, arg), param.Name)
                     End If
                 End If
             End If
 
             If param.HasReferenceTypeConstraint Then
                 If gt IsNot Nothing Then
                     If gt.HasReferenceTypeConstraint = False Then
                         result = Context.Compiler.Report.ShowMessage(Messages.VBNC32106, Context.Location, Helper.ToString(Context, arg), param.Name)
                     End If
                 Else
                     If CecilHelper.IsClass(arg) = False Then
                         result = Context.Compiler.Report.ShowMessage(Messages.VBNC32106, Context.Location, Helper.ToString(Context, arg), param.Name)
                     End If
                 End If
             End If
 
             If param.HasConstraints Then
                 For c As Integer = 0 To param.Constraints.Count - 1
                     Dim constr As TypeReference = param.Constraints(i)
 
                     If param.HasNotNullableValueTypeConstraint AndAlso Helper.CompareType(constr, Context.Compiler.TypeCache.System_ValueType) Then Continue For
                     If Helper.CompareType(constr, arg) Then Continue For
 
                     If gt Is Nothing Then
                         If Helper.IsInterface(Context, constr) Then
                             If Helper.DoesTypeImplementInterface(Context, arg, constr) = False Then
                                 result = Context.Compiler.Report.ShowMessage(Messages.VBNC32044, Context.Location, Helper.ToString(Context, arg), Helper.ToString(Context, constr))
                             End If
                         Else
                             If Helper.IsSubclassOf(constr, arg) = False Then
                                 result = Context.Compiler.Report.ShowMessage(Messages.VBNC32044, Context.Location, Helper.ToString(Context, arg), Helper.ToString(Context, constr))
                             End If
                         End If
                     Else
                         Dim found As Boolean = False
 
                         For c2 As Integer = 0 To gt.Constraints.Count - 1
                             If Helper.CompareType(constr, gt.Constraints(c2)) Then
                                 found = True
                                 Exit For
                             End If
                             If Helper.DoesTypeImplementInterface(Context, gt.Constraints(c2), constr) Then
                                 found = True
                                 Exit For
                             End If
                         Next
                         If found = False Then
                             result = Context.Compiler.Report.ShowMessage(Messages.VBNC32044, Context.Location, Helper.ToString(Context, arg), Helper.ToString(Context, constr))
                         End If
                     End If
                 Next
             End If
         Next
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="340" nfragments="2">
<clone_fragment endline="1779" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" hamdist="0" pcid="1101" startline="1750"><![CDATA[
 
 		int TokenizePreprocessorIdentifier (out int c)
 		{
 			// skip over white space
 			do {
 				c = get_char ();
 			} while (c == '\r' || c == ' ' || c == '\t');
 
 
 			int pos = 0;
 			while (c != -1 && c >= 'a' && c <= 'z') {
 				id_builder[pos++] = (char) c;
 				c = get_char ();
 				if (c == '\\') {
 					int peek = peek_char ();
 					if (peek == 'U' || peek == 'u') {
 						int surrogate;
 						c = EscapeUnicode (c, out surrogate);
 						if (surrogate != 0) {
 							if (is_identifier_part_character ((char) c)) {
 								id_builder[pos++] = (char) c;
 							}
 							c = surrogate;
 						}
 					}
 				}
 			}
 			while (c != -1 && c >= 'a' && c <= 'z') {
 				id_builder[pos++] = (char) c;
 				c = get_char ();
 				if (c == '\\') {
 					int peek = peek_char ();
 					if (peek == 'U' || peek == 'u') {
 						int surrogate;
 						c = EscapeUnicode (c, out surrogate);
 						if (surrogate != 0) {
 							if (is_identifier_part_character ((char) c)) {
 								id_builder[pos++] = (char) c;
 							}
 							c = surrogate;
 						}
 					}
 				}
 			}
 
 			return pos;
 		}
]]></clone_fragment>
<clone_fragment endline="1835" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" hamdist="13" pcid="1103" startline="1780"><![CDATA[
 
 		PreprocessorDirective get_cmd_arg (out string arg)
 		{
 			int c;		
 
 			tokens_seen = false;
 			arg = "";
 
 			var cmd = GetPreprocessorDirective (id_builder, TokenizePreprocessorIdentifier (out c));
 
 			if ((cmd & PreprocessorDirective.CustomArgumentsParsing) != 0)
 				return cmd;
 
 			// skip over white space
 			while (c == '\r' || c == ' ' || c == '\t')
 				c = get_char ();
 			while (c == '\r' || c == ' ' || c == '\t')
 				c = get_char ();
 
 			static_cmd_arg.Length = 0;
 			int has_identifier_argument = (int)(cmd & PreprocessorDirective.RequiresArgument);
 
 			while (c != -1 && c != '\n' && c != '\r') {
 				if (c == '\\' && has_identifier_argument >= 0) {
 					if (has_identifier_argument != 0) {
 						has_identifier_argument = 1;
 
 						int peek = peek_char ();
 						if (peek == 'U' || peek == 'u') {
 							int surrogate;
 							c = EscapeUnicode (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									static_cmd_arg.Append ((char) c);
 								c = surrogate;
 							}
 						}
 					} else {
 						has_identifier_argument = -1;
 					}
 				}
 				static_cmd_arg.Append ((char) c);
 				c = get_char ();
 			}
 			while (c != -1 && c != '\n' && c != '\r') {
 				if (c == '\\' && has_identifier_argument >= 0) {
 					if (has_identifier_argument != 0) {
 						has_identifier_argument = 1;
 
 						int peek = peek_char ();
 						if (peek == 'U' || peek == 'u') {
 							int surrogate;
 							c = EscapeUnicode (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									static_cmd_arg.Append ((char) c);
 								c = surrogate;
 							}
 						}
 					} else {
 						has_identifier_argument = -1;
 					}
 				}
 				static_cmd_arg.Append ((char) c);
 				c = get_char ();
 			}
 
 			if (static_cmd_arg.Length != 0) {
 				arg = static_cmd_arg.ToString ();
 
 				// Eat any trailing whitespaces and single-line comments
 				if (arg.IndexOf ("//") != -1) {
 					arg = arg.Substring (0, arg.IndexOf ("//"));
 				}
 
 				arg = arg.Trim (simple_whitespaces);
 			}
 
 			return cmd;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="341" nfragments="3">
<clone_fragment endline="122" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForEachStatement.vb" hamdist="0" pcid="9403" startline="79"><![CDATA[
     End Property
 
     Function GenerateCode_LoadCurrentLoopVariable(ByVal Info As EmitInfo) As Boolean
         Dim varType As Mono.Cecil.TypeReference = m_LoopControlVariable.VariableType
         Dim isGenericParameter As Boolean = CecilHelper.IsGenericParameter(varType)
         Dim isValueType As Boolean = isGenericParameter = False AndAlso CecilHelper.IsValueType(varType)
         Dim isClass As Boolean = isGenericParameter = False AndAlso CecilHelper.IsClass(varType)
 
         Emitter.EmitLoadVariable(Info, m_Enumerator)
         Emitter.EmitCallVirt(Info, Compiler.TypeCache.System_Collections_IEnumerator__get_Current)
 
         Dim valueTPLoad As Label = Nothing
         Dim valueTPLoaded As Label = Nothing
 
         If isValueType Then
             Dim tmpStructureVariable As Mono.Cecil.Cil.VariableDefinition
 
             valueTPLoad = Emitter.DefineLabel(Info)
             valueTPLoaded = Emitter.DefineLabel(Info)
             tmpStructureVariable = Emitter.DeclareLocal(Info, varType)
             Emitter.EmitDup(Info)
             Emitter.EmitBranchIfTrue(Info, valueTPLoad)
             Emitter.EmitPop(Info, Compiler.TypeCache.System_Object)
             Emitter.EmitLoadVariable(Info, tmpStructureVariable)
             Emitter.EmitBranch(Info, valueTPLoaded)
             Emitter.FreeLocal(tmpStructureVariable)
         Else
             Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
         End If
 
         If isGenericParameter Then
             Emitter.EmitUnbox_Any(Info, varType)
         ElseIf isClass Then
             Emitter.EmitCastClass(Info, Compiler.TypeCache.System_Object, varType)
         ElseIf isValueType Then
             Emitter.MarkLabel(Info, valueTPLoad)
             Emitter.EmitUnbox(Info, varType)
             Emitter.EmitLoadObject(Info, varType)
             Emitter.MarkLabel(Info, valueTPLoaded)
         Else
             Emitter.EmitConversion(Compiler.TypeCache.System_Object, varType, Info.Clone(Me, True, True, varType))
         End If
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="290" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\LateBoundAccessToExpression.vb" hamdist="9" pcid="7125" startline="241"><![CDATA[
 
     Private Shared Function EmitStoreBacks(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification, ByVal CopyBacks As Boolean(), ByVal array As Mono.Cecil.Cil.VariableDefinition, ByVal arguments As Mono.Cecil.Cil.VariableDefinition) As Boolean
         Dim result As Boolean = True
         Dim args As ArgumentList
 
         If CopyBacks Is Nothing OrElse CopyBacks.Length = 0 Then Return result
 
         args = LateBoundAccess.Arguments
 
         For i As Integer = 0 To CopyBacks.Length - 1
             Dim branch As Label
 
             If CopyBacks(i) = False Then Continue For
 
             Dim arg As Argument
             Dim exp As Expression
 
             arg = args.Arguments(i)
             exp = arg.Expression
 
             branch = Emitter.DefineLabel(Info)
             Emitter.EmitLoadVariable(Info, array)
             Emitter.EmitLoadI4Value(Info, i)
             Emitter.EmitLoadElement(Info, Info.Compiler.TypeCache.System_Boolean_Array)
             Emitter.EmitBranchIfFalse(Info, branch)
 
             Dim tmpVar As Mono.Cecil.Cil.VariableDefinition
             tmpVar = Emitter.DeclareLocal(Info, exp.ExpressionType)
 
             Emitter.EmitLoadVariable(Info, arguments)
             Emitter.EmitLoadI4Value(Info, i)
             Emitter.EmitLoadElement(Info, Info.Compiler.TypeCache.System_Object_Array)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
             Emitter.EmitLoadToken(Info, exp.ExpressionType)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ChangeType_Object_Type)
 
             Dim vosExp As New ValueOnStackExpression(exp, Info.Compiler.TypeCache.System_Object)
             Dim convExp As DirectCastExpression
             convExp = New DirectCastExpression(exp)
             convExp.Init(vosExp, exp.ExpressionType)
             result = convExp.GenerateCode(Info) AndAlso result
             Emitter.EmitStoreVariable(Info, tmpVar)
             result = exp.GenerateCode(Info.Clone(Info.Context, New LoadLocalExpression(exp, tmpVar))) AndAlso result
 
             Emitter.MarkLabel(Info, branch)
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="107" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\UsingStatement.vb" hamdist="10" pcid="9535" startline="61"><![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim usingDecls As UsingDeclarators = TryCast(m_UsingResources, UsingDeclarators)
         Dim usingExp As Expression = TryCast(m_UsingResources, Expression)
         Dim usingVars As New Generic.Stack(Of Mono.Cecil.Cil.VariableDefinition)
         Dim exceptionEnds As New Generic.Stack(Of Label)
         Dim exceptionEnds2 As New Generic.Stack(Of Label)
 
         If usingDecls IsNot Nothing Then
             For i As Integer = 0 To usingDecls.Count - 1
                 Dim tmpDecl As UsingDeclarator = usingDecls(i)
                 result = usingDecls(i).GenerateCode(Info) AndAlso result
                 usingVars.Push(tmpDecl.UsingVariable)
                 exceptionEnds.Push(Emitter.EmitBeginExceptionBlock(Info))
                 exceptionEnds2.Push(Emitter.DefineLabel(Info))
             Next
         ElseIf usingExp IsNot Nothing Then
             Dim local As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, usingExp.ExpressionType)
             result = usingExp.GenerateCode(Info.Clone(Me, True, False, usingExp.ExpressionType)) AndAlso result
             Emitter.EmitStoreVariable(Info, local)
             usingVars.Push(local)
             exceptionEnds.Push(Emitter.EmitBeginExceptionBlock(Info))
             exceptionEnds2.Push(Emitter.DefineLabel(Info))
         Else
             Throw New InternalException(Me)
         End If
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         Do Until usingVars.Count = 0
             Dim tmpvar As Mono.Cecil.Cil.VariableDefinition = usingVars.Pop
             Dim endblock As Label = exceptionEnds.Pop
             Dim endblock2 As Label = exceptionEnds2.Pop
 
             Info.ILGen.BeginFinallyBlock()
             Emitter.EmitLoadVariable(Info, tmpvar)
             Emitter.EmitBranchIfFalse(Info, endblock2)
             Emitter.EmitLoadVariable(Info, tmpvar)
             Emitter.EmitCallVirt(Info, Compiler.TypeCache.System_IDisposable__Dispose)
             Emitter.MarkLabel(Info, endblock2)
             Info.ILGen.EndExceptionBlock()
         Loop
         Do Until usingVars.Count = 0
             Dim tmpvar As Mono.Cecil.Cil.VariableDefinition = usingVars.Pop
             Dim endblock As Label = exceptionEnds.Pop
             Dim endblock2 As Label = exceptionEnds2.Pop
 
             Info.ILGen.BeginFinallyBlock()
             Emitter.EmitLoadVariable(Info, tmpvar)
             Emitter.EmitBranchIfFalse(Info, endblock2)
             Emitter.EmitLoadVariable(Info, tmpvar)
             Emitter.EmitCallVirt(Info, Compiler.TypeCache.System_IDisposable__Dispose)
             Emitter.MarkLabel(Info, endblock2)
             Info.ILGen.EndExceptionBlock()
         Loop
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="342" nfragments="2">
<clone_fragment endline="67" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrElseExpression.vb" hamdist="0" pcid="6665" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadtrue, endexp As Label
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
           
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="70" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndAlsoExpression.vb" hamdist="2" pcid="6567" startline="23"><![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="343" nfragments="12">
<clone_fragment endline="114" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\ModExpression.vb" hamdist="0" pcid="6655" startline="64"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
 
             If lvalue Is Nothing Then lvalue = 0
             If rvalue Is Nothing Then rvalue = 0
 
             Dim tlvalue, trvalue As Mono.Cecil.TypeReference
             Dim clvalue, crvalue As TypeCode
             tlvalue = CecilHelper.GetType(Compiler, lvalue)
             clvalue = Helper.GetTypeCode(Compiler, tlvalue)
             trvalue = CecilHelper.GetType(Compiler, rvalue)
             crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
             Dim smallest As Mono.Cecil.TypeReference
             Dim csmallest As TypeCode
             smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
             Helper.Assert(smallest IsNot Nothing)
             csmallest = Helper.GetTypeCode(Compiler, smallest)
 
             Select Case csmallest
                 Case TypeCode.Byte
                     Return CByte(lvalue) Mod CByte(rvalue)
                 Case TypeCode.SByte
                     Return CSByte(lvalue) Mod CSByte(rvalue)
                 Case TypeCode.Int16
                     Return CShort(lvalue) Mod CShort(rvalue)
                 Case TypeCode.UInt16
                     Return CUShort(lvalue) Mod CUShort(rvalue)
                 Case TypeCode.Int32
                     Return CInt(lvalue) Mod CInt(rvalue)
                 Case TypeCode.UInt32
                     Return CUInt(lvalue) Mod CUInt(rvalue)
                 Case TypeCode.Int64
                     Return CLng(lvalue) Mod CLng(rvalue)
                 Case TypeCode.UInt64
                     Return CULng(lvalue) Mod CULng(rvalue)
                 Case TypeCode.Double
                     Return CDbl(lvalue) Mod CDbl(rvalue)
                 Case TypeCode.Single
                     Return CSng(lvalue) Mod CSng(rvalue)
                 Case TypeCode.Decimal
                     Return CDec(lvalue) Mod CDec(rvalue)
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End Get
]]></clone_fragment>
<clone_fragment endline="135" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\RShiftExpression.vb" hamdist="11" pcid="6683" startline="84"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim shifts As Integer 'This needs to be an integer.
                 Dim tmpShifts As Object = Nothing
                 If Compiler.TypeResolution.CheckNumericRange(rvalue, tmpShifts, Compiler.TypeCache.System_Int32) = False Then
                     Helper.Stop() 'Add error.
                 Else
                     shifts = CInt(tmpShifts)
                 End If
 
                 Dim tlvalue As Mono.Cecil.TypeReference
                 Dim clvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
 
                 Select Case clvalue
                     Case TypeCode.Byte
                         Return CByte(lvalue) >> shifts
                     Case TypeCode.SByte
                         Return CSByte(lvalue) >> shifts
                     Case TypeCode.Int16
                         Return CShort(lvalue) >> shifts
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) >> shifts
                     Case TypeCode.Int32
                         Return CInt(lvalue) >> shifts
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) >> shifts
                     Case TypeCode.Int64
                         Return CLng(lvalue) >> shifts
                     Case TypeCode.UInt64
                         Return CULng(lvalue) >> shifts
                     Case TypeCode.Double
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="136" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\AndExpression.vb" hamdist="15" pcid="6575" startline="78"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) AndAlso CBool(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) And CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) And CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) And CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) And CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) And CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) And CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) And CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) And CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) And CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) And CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) And CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="118" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\XorExpression.vb" hamdist="7" pcid="6687" startline="60"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) Xor CBool(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) Xor CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) Xor CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) Xor CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) Xor CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) Xor CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) Xor CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) Xor CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) Xor CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) xor CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) xor CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) Xor CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="148" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LEExpression.vb" hamdist="12" pcid="6639" startline="84"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) <= CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) <= CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) <= CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <= CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <= CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) <= CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) <= CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) <= CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) <= CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) <= CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) <= CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) <= CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) <= CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) <= CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) <= CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) <= CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="135" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\OrExpression.vb" hamdist="9" pcid="6673" startline="78"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) OrElse CBool(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) Or CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) Or CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) Or CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) Or CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) Or CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) Or CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) Or CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) Or CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) Or CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) Or CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) Or CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="135" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\IntDivisionExpression.vb" hamdist="11" pcid="6627" startline="60"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
                 If CDbl(rvalue) = 0 Then
                     Helper.Stop() 'TODO
                 End If
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) \ CByte(rvalue)
                     Case TypeCode.SByte
                         If CSByte(lvalue) = SByte.MinValue AndAlso CSByte(rvalue) = -1 Then
                             Return CShort(lvalue) \ CShort(rvalue)
                         Else
                             Return CSByte(lvalue) \ CSByte(rvalue)
                         End If
                     Case TypeCode.Int16
                         If CShort(lvalue) = Short.MinValue AndAlso CShort(rvalue) = -1 Then
                             Return CInt(lvalue) \ CInt(rvalue)
                         Else
                             Return CShort(lvalue) \ CShort(rvalue)
                         End If
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) \ CUShort(rvalue)
                     Case TypeCode.Int32
                         If CInt(lvalue) = Integer.MinValue AndAlso CInt(rvalue) = -1 Then
                             Return CLng(lvalue) \ CLng(rvalue)
                         Else
                             Return CInt(lvalue) \ CInt(rvalue)
                         End If
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) / CUInt(rvalue)
                     Case TypeCode.Int64
                         If CLng(lvalue) = Long.MinValue AndAlso CLng(rvalue) = -1 Then
                             'Return CDec(lvalue) \ CDec(rvalue)
                             Throw New InternalException(Me)
                         Else
                             Return CLng(lvalue) \ CLng(rvalue)
                         End If
                     Case TypeCode.UInt64
                         Return CULng(lvalue) \ CULng(rvalue)
                     Case TypeCode.Double
                         'Return CDbl(lvalue) \ CDbl(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Single
                         'Return CSng(lvalue) \ CSng(rvalue)
                         Throw New InternalException(Me)
                     Case TypeCode.Decimal
                         'Return CDec(lvalue) \ CDec(rvalue)
                         Throw New InternalException(Me)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="136" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\NotEqualsExpression.vb" hamdist="12" pcid="6663" startline="75"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) <> CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) <> CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) <> CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <> CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) <> CStr(rvalue)
                 End If
 
                 Dim csmallest As TypeCode
                 csmallest = TypeConverter.GetNotEqualsOperandType(clvalue, crvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) <> CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) <> CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) <> CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) <> CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) <> CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) <> CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) <> CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) <> CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) <> CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) <> CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) <> CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="142" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GEExpression.vb" hamdist="9" pcid="6619" startline="78"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) >= CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) >= CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) >= CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) >= CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) >= CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) >= CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) >= CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) >= CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) >= CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) >= CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) >= CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) >= CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) >= CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) >= CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) >= CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) >= CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="142" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\GTExpression.vb" hamdist="4" pcid="6623" startline="78"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) > CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) > CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) > CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) > CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) > CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) > CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) > CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) > CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) > CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) > CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) > CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) > CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) > CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) > CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) > CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) > CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="144" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\EqualsExpression.vb" hamdist="4" pcid="6611" startline="80"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) = CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) = CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) = CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) = CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) = CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) = CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) = CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) = CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) = CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) = CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) = CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) = CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) = CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) = CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) = CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) = CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="142" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\LTExpression.vb" hamdist="8" pcid="6651" startline="78"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
                     Return CBool(lvalue) < CBool(rvalue)
                 ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
                     Return CDate(lvalue) < CDate(rvalue)
                 ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
                     Return CChar(lvalue) < CChar(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) < CStr(rvalue)
                 ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
                  clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
                     Return CStr(lvalue) < CStr(rvalue)
                 End If
 
                 Dim smallest As Mono.Cecil.TypeReference
                 Dim csmallest As TypeCode
                 smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
                 Helper.Assert(smallest IsNot Nothing)
                 csmallest = Helper.GetTypeCode(Compiler, smallest)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Return CByte(lvalue) < CByte(rvalue)
                     Case TypeCode.SByte
                         Return CSByte(lvalue) < CSByte(rvalue)
                     Case TypeCode.Int16
                         Return CShort(lvalue) < CShort(rvalue)
                     Case TypeCode.UInt16
                         Return CUShort(lvalue) < CUShort(rvalue)
                     Case TypeCode.Int32
                         Return CInt(lvalue) < CInt(rvalue)
                     Case TypeCode.UInt32
                         Return CUInt(lvalue) < CUInt(rvalue)
                     Case TypeCode.Int64
                         Return CLng(lvalue) < CLng(rvalue)
                     Case TypeCode.UInt64
                         Return CULng(lvalue) < CULng(rvalue)
                     Case TypeCode.Double
                         Return CDbl(lvalue) < CDbl(rvalue)
                     Case TypeCode.Single
                         Return CSng(lvalue) < CSng(rvalue)
                     Case TypeCode.Decimal
                         Return CDec(lvalue) < CDec(rvalue)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="344" nfragments="3">
<clone_fragment endline="485" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" hamdist="0" pcid="7943" startline="435"><![CDATA[
 
     Sub GenerateGroupCollectionClass(ByVal TypeName As String, ByVal TypeToCollect As String)
         Dim code As String = VB.vbNewLine & _
         "        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
         "        <Global.Microsoft.VisualBasic.MyGroupCollection(""{1}"", ""Create__Instance__"", ""Dispose__Instance__"", """")> _" & VB.vbNewLine & _
         "        Friend NotInheritable Class {0}" & VB.vbNewLine & _
         "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
         "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
         "            Public Sub New()" & VB.vbNewLine & _
         "            End Sub" & VB.vbNewLine & _
         "            " & VB.vbNewLine & _
         "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
         "            Private Shared Function Create__Instance__(Of T As New)(ByVal instance As T) As T" & VB.vbNewLine & _
         "                If (instance Is Nothing) Then" & VB.vbNewLine & _
         "                    Return Global.System.Activator.CreateInstance(Of T)" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "                Return instance" & VB.vbNewLine & _
         "            End Function" & VB.vbNewLine & _
         "            " & VB.vbNewLine & _
         "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
         "            Private Sub Dispose__Instance__(Of T)(ByRef instance As T)" & VB.vbNewLine & _
         "                instance = CType(Nothing, T)" & VB.vbNewLine & _
         "            End Sub" & VB.vbNewLine & _
         "            " & VB.vbNewLine & _
         "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
         "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
         "            Public Overrides Function Equals(ByVal o As Object) As Boolean" & VB.vbNewLine & _
         "                Return MyBase.Equals(Global.System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(o))" & VB.vbNewLine & _
         "            End Function" & VB.vbNewLine & _
         "            " & VB.vbNewLine & _
         "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
         "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
         "            Public Overrides Function GetHashCode() As Integer" & VB.vbNewLine & _
         "             Return MyBase.GetHashCode" & VB.vbNewLine & _
         "            End Function" & VB.vbNewLine & _
         "            " & VB.vbNewLine & _
         "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
         "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
         "            Friend Overloads Function [GetType]() As Type" & VB.vbNewLine & _
         "                Return GetType(MyWebServices)" & VB.vbNewLine & _
         "            End Function" & VB.vbNewLine & _
         "            " & VB.vbNewLine & _
         "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
         "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
         "            Public Overrides Function ToString() As String" & VB.vbNewLine & _
         "                Return MyBase.ToString" & VB.vbNewLine & _
         "            End Function" & VB.vbNewLine & _
         "        End Class" & VB.vbNewLine & _
         ""
         ProjectCode.Append(String.Format(code, TypeName, TypeToCollect))
     End Sub
]]></clone_fragment>
<clone_fragment endline="434" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" hamdist="3" pcid="7941" startline="355"><![CDATA[
 
     Function GenerateMyWebServices() As Boolean
         Dim result As Boolean = True
         Dim _MyWebServicesDefine As Define
         Dim _MyWebServices As Boolean
 
         _MyWebServicesDefine = Compiler.CommandLine.Define("_MYWEBSERVICES")
         If _MyWebServicesDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain, MyTypes.Windows, MyTypes.WindowsForms, MyTypes.WebControl
                     _MyWebServices = True
                 Case Else
                     _MyWebServices = False
             End Select
         Else
             _MyWebServices = CBool(_MyWebServicesDefine.Value)
         End If
 
         If Not _MyWebServices Then Return True
 
         Dim code As String = VB.vbNewLine & _
        "        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "        <Global.Microsoft.VisualBasic.MyGroupCollection(""System.Web.Services.Protocols.SoapHttpClientProtocol"", ""Create__Instance__"", ""Dispose__Instance__"", """")> _" & VB.vbNewLine & _
        "        Friend NotInheritable Class MyWebServices" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Public Sub New()" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Shared Function Create__Instance__(Of T As New)(ByVal instance As T) As T" & VB.vbNewLine & _
        "                If (instance Is Nothing) Then" & VB.vbNewLine & _
        "                    Return Global.System.Activator.CreateInstance(Of T)" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                Return instance" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Sub Dispose__Instance__(Of T)(ByRef instance As T)" & VB.vbNewLine & _
        "                instance = CType(Nothing, T)" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function Equals(ByVal o As Object) As Boolean" & VB.vbNewLine & _
        "                Return MyBase.Equals(Global.System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(o))" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function GetHashCode() As Integer" & VB.vbNewLine & _
        "             Return MyBase.GetHashCode" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Friend Overloads Function [GetType]() As Type" & VB.vbNewLine & _
        "                Return GetType(MyWebServices)" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function ToString() As String" & VB.vbNewLine & _
        "                Return MyBase.ToString" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "        End Class" & VB.vbNewLine & _
        ""
         ProjectCode.Append(code)
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_MyWebServicesObjectProvider As ThreadSafeObjectProvider(Of MyWebServices) = New ThreadSafeObjectProvider(Of MyWebServices)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.WebServices"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property WebServices As MyWebServices")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_MyWebServicesObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="354" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" hamdist="5" pcid="7939" startline="257"><![CDATA[
 
     Function GenerateMyForms() As Boolean
         Dim result As Boolean = True
         Dim _MyFormsDefine As Define
         Dim _MyForms As Boolean
 
         _MyFormsDefine = Compiler.CommandLine.Define("_MYFORMS")
         If _MyFormsDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.WindowsFormsWithCustomSubMain, MyTypes.WindowsForms
                     _MyForms = True
                 Case Else
                     _MyForms = False
             End Select
         Else
             _MyForms = CBool(_MyFormsDefine.Value)
         End If
 
         If Not _MyForms Then Return True
 
         Compiler.CommandLine.References.Add("System.Windows.Forms.dll")
 
         Dim code As String = VB.vbNewLine & _
        "        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "        <Global.Microsoft.VisualBasic.MyGroupCollection(""System.Windows.Forms.Form"", ""Create__Instance__"", ""Dispose__Instance__"", ""My.MyProject.Forms"")> _" & VB.vbNewLine & _
        "        Friend NotInheritable Class MyForms" & VB.vbNewLine & _
        "            <Global.System.ThreadStatic> _" & VB.vbNewLine & _
        "            Private Shared m_FormBeingCreated As Global.System.Collections.Hashtable" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Public Sub New()" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Shared Function Create__Instance__(Of T As {Global.System.Windows.Forms.Form, New})(ByVal Instance As T) As T" & VB.vbNewLine & _
        "                If Instance IsNot Nothing AndAlso Instance.IsDisposed = False" & VB.vbNewLine & _
        "                    Return Instance" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                " & VB.vbNewLine & _
        "                Dim TType As Type = GetType(T)" & VB.vbNewLine & _
        "                If m_FormBeingCreated Is Nothing Then" & VB.vbNewLine & _
        "                    m_FormBeingCreated = New Global.System.Collections.Hashtable()" & VB.vbNewLine & _
        "                ElseIf m_FormBeingCreated.ContainsKey(TType) Then" & VB.vbNewLine & _
        "                    Throw New InvalidOperationException(""There is a reference to a default instance from the constructor of a form, which leads to infinite recursion. Please refer to the form itself using 'Me' from within the constructor."")" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                " & VB.vbNewLine & _
        "                m_FormBeingCreated.Add(TType, Nothing)" & VB.vbNewLine & _
        "                Try" & VB.vbNewLine & _
        "                    Return Global.System.Activator.CreateInstance(Of T)()" & VB.vbNewLine & _
        "                Catch ex As Global.System.Reflection.TargetInvocationException" & VB.vbNewLine & _
        "                    Throw New Global.System.InvalidOperationException(""See inner exception"", ex.InnerException)" & VB.vbNewLine & _
        "                Finally" & VB.vbNewLine & _
        "                    m_FormBeingCreated.Remove(TType)" & VB.vbNewLine & _
        "                End Try" & VB.vbNewLine & _
        "                Return Nothing" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Sub Dispose__Instance__(Of T As Global.System.Windows.Forms.Form)(ByRef instance As T)" & VB.vbNewLine & _
        "                instance.Dispose()" & VB.vbNewLine & _
        "                instance = CType(Nothing, T)" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function Equals(ByVal o As Object) As Boolean" & VB.vbNewLine & _
        "                Return MyBase.Equals(Global.System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(o))" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function GetHashCode() As Integer" & VB.vbNewLine & _
        "             Return MyBase.GetHashCode" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Friend Overloads Function [GetType]() As Type" & VB.vbNewLine & _
        "                Return GetType(MyForms)" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function ToString() As String" & VB.vbNewLine & _
        "                Return MyBase.ToString" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "        End Class" & VB.vbNewLine & _
        ""
         ProjectCode.Append(code)
 
         ProjectCode.AppendLine("        Private Shared m_MyFormsObjectProvider As ThreadSafeObjectProvider(Of MyForms) = New ThreadSafeObjectProvider(Of MyForms)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Forms"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Forms As MyForms")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_MyFormsObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="345" nfragments="3">
<clone_fragment endline="723" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="0" pcid="8169" startline="673"><![CDATA[
 
     Shared Function GetBinaryOperandDefinedTypes(ByVal op As KS) As String
         Select Case op
             Case KS.And
                 Return LogicalDefinedTypes
             Case KS.AndAlso
                 Return ShortcircuitDefinedTypes
             Case KS.Or
                 Return LogicalDefinedTypes
             Case KS.OrElse
                 Return ShortcircuitDefinedTypes
             Case KS.Xor
                 Return LogicalDefinedTypes
             Case KS.Add
                 Return AddDefinedTypes
             Case KS.Minus
                 Return SubDefinedTypes
             Case KS.Mult
                 Return MultDefinedTypes
             Case KS.RealDivision
                 Return RealDivDefinedTypes
             Case KS.IntDivision
                 Return IntDivDefinedTypes
             Case KS.Power
                 Return ExponentDefinedTypes
             Case KS.Concat
                 Return ConcatDefinedTypes
             Case KS.GE
                 Return RelationalDefinedTypes
             Case KS.GT
                 Return RelationalDefinedTypes
             Case KS.LE
                 Return RelationalDefinedTypes
             Case KS.LT
                 Return RelationalDefinedTypes
             Case KS.Equals
                 Return RelationalDefinedTypes
             Case KS.NotEqual
                 Return RelationalDefinedTypes
             Case KS.ShiftLeft, KS.ShiftRight
                 Return ShiftDefinedTypes
             Case KS.Mod
                 Return ModDefinedTypes
             Case KS.Like
                 Return LikeDefinedTypes
             Case KS.Is, KS.IsNot
                 Return String.Empty
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="611" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="9" pcid="8163" startline="561"><![CDATA[
 
     Shared Function GetBinaryResultType(ByVal op As KS, ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Select Case op
             Case KS.And
                 Return GetAndResultType(op1, op2)
             Case KS.AndAlso
                 Return GetAndAlsoResultType(op1, op2)
             Case KS.Or
                 Return GetOrResultType(op1, op2)
             Case KS.OrElse
                 Return GetOrElseResultType(op1, op2)
             Case KS.Xor
                 Return GetXorResultType(op1, op2)
             Case KS.Add
                 Return GetBinaryAddResultType(op1, op2)
             Case KS.Minus
                 Return GetBinarySubResultType(op1, op2)
             Case KS.Mult
                 Return GetMultResultType(op1, op2)
             Case KS.RealDivision
                 Return GetRealDivResultType(op1, op2)
             Case KS.IntDivision
                 Return GetIntDivResultType(op1, op2)
             Case KS.Power
                 Return GetExpOperandType(op1, op2)
             Case KS.Concat
                 Return GetConcatResultType(op1, op2)
             Case KS.GE
                 Return GetGEResultType(op1, op2)
             Case KS.GT
                 Return GetGTResultType(op1, op2)
             Case KS.LE
                 Return GetLEResultType(op1, op2)
             Case KS.LT
                 Return GetLTResultType(op1, op2)
             Case KS.Equals
                 Return GetEqualsResultType(op1, op2)
             Case KS.NotEqual
                 Return GetNotEqualsResultType(op1, op2)
             Case KS.ShiftLeft, KS.ShiftRight
                 Return GetShiftResultType(op1, op2)
             Case KS.Mod
                 Return GetModResultType(op1, op2)
             Case KS.Like
                 Return GetLikeResultType(op1, op2)
             Case KS.Is, KS.IsNot
                 Return GetIsIsNotResultType(op1, op2)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]></clone_fragment>
<clone_fragment endline="774" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeConverter.vb" hamdist="2" pcid="8171" startline="724"><![CDATA[
 
     Private Shared Function GetBinaryOperandType(ByVal op As KS, ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Select Case op
             Case KS.And
                 Return GetAndResultType(op1, op2)
             Case KS.AndAlso
                 Return GetAndAlsoResultType(op1, op2)
             Case KS.Or
                 Return GetOrResultType(op1, op2)
             Case KS.OrElse
                 Return GetOrElseResultType(op1, op2)
             Case KS.Xor
                 Return GetXorResultType(op1, op2)
             Case KS.Add
                 Return GetBinaryAddResultType(op1, op2)
             Case KS.Minus
                 Return GetBinarySubResultType(op1, op2)
             Case KS.Mult
                 Return GetMultResultType(op1, op2)
             Case KS.RealDivision
                 Return GetRealDivResultType(op1, op2)
             Case KS.IntDivision
                 Return GetIntDivResultType(op1, op2)
             Case KS.Power
                 Return GetExpOperandType(op1, op2)
             Case KS.Concat
                 Return GetConcatOperandType(op1, op2)
             Case KS.GE
                 Return GetGEOperandType(op1, op2)
             Case KS.GT
                 Return GetGTOperandType(op1, op2)
             Case KS.LE
                 Return GetLEOperandType(op1, op2)
             Case KS.LT
                 Return GetLTOperandType(op1, op2)
             Case KS.Equals
                 Return GetEqualsOperandType(op1, op2)
             Case KS.NotEqual
                 Return GetNotEqualsOperandType(op1, op2)
             Case KS.ShiftLeft, KS.ShiftRight
                 Return GetShiftResultType(op1, op2)
             Case KS.Mod
                 Return GetModResultType(op1, op2)
             Case KS.Like
                 Return GetLikeOperandType(op1, op2)
             Case KS.Is, KS.IsNot
                 Return GetIsIsNotOperandType(op1, op2)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="346" nfragments="2">
<clone_fragment endline="558" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" hamdist="0" pcid="7947" startline="508"><![CDATA[
 
     Function GenerateMyComputer() As Boolean
         Dim result As Boolean = True
         Dim _MyComputerDefine As Define
         Dim _MyComputer As String
 
         _MyComputerDefine = Compiler.CommandLine.Define("_MYCOMPUTERTYPE")
         If _MyComputerDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain, MyTypes.Windows, MyTypes.WindowsForms
                     _MyComputer = "Windows"
                 Case MyTypes.Web, MyTypes.WebControl
                     _MyComputer = "Web"
                 Case Else
                     _MyComputer = String.Empty
             End Select
         Else
             _MyComputer = _MyComputerDefine.Value
         End If
 
         Dim baseClass As String
         Select Case _MyComputer
             Case "Web"
                 baseClass = "Global.Microsoft.VisualBasic.Devices.ServerComputer"
             Case "Windows"
                 baseClass = "Global.Microsoft.VisualBasic.Devices.Computer"
             Case Else
                 Return True
         End Select
 
         Code.AppendLine("    <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
         Code.AppendLine("    <Global.System.CodeDom.Compiler.GeneratedCode(""MyTemplate"", ""10.0.0.0"")> _")
         Code.AppendLine("    Friend Class MyComputer")
         Code.Append("        Inherits ") 
         Code.AppendLine("        <Global.System.Diagnostics.DebuggerHidden()> _")
         Code.AppendLine("        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
         Code.AppendLine("        Public Sub New()")
         Code.AppendLine("        End Sub")
         Code.AppendLine("    End Class")
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_ComputerObjectProvider As ThreadSafeObjectProvider(Of $GLOBALMY$.MyComputer) = New ThreadSafeObjectProvider(Of $GLOBALMY$.MyComputer)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Computer"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Computer As $GLOBALMY$.MyComputer")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_ComputerObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="216" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\MyGenerator.vb" hamdist="4" pcid="7935" startline="155"><![CDATA[
 
     Function GenerateMyApplication() As Boolean
         Dim result As Boolean = True
         Dim _MyApplicationDefine As Define
         Dim _MyApplication As String
 
         _MyApplicationDefine = Compiler.CommandLine.Define("_MYAPPLICATIONTYPE")
         If _MyApplicationDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain
                     _MyApplication = "Console"
                 Case MyTypes.Windows
                     _MyApplication = "Windows"
                 Case MyTypes.WindowsForms
                     _MyApplication = "WindowsForms"
                 Case Else
                     _MyApplication = String.Empty
             End Select
         Else
             _MyApplication = _MyApplicationDefine.Value
         End If
 
         Dim baseClass As String
         Select Case _MyApplication
             Case "Console"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase"
             Case "Windows"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.ApplicationBase"
             Case "WindowsForms"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase"
             Case Else
                 Return True
         End Select
 
         Code.AppendLine("    <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
         Code.AppendLine("    <Global.System.CodeDom.Compiler.GeneratedCode(""MyTemplate"", ""10.0.0.0"")> _")
         Code.AppendLine("    Friend Class MyApplication")
         Code.Append("        Inherits ") 
         'Code.AppendLine("        Public Sub New()")
         'Code.AppendLine("        End Sub")
         If Compiler.CommandLine.Target = CommandLine.Targets.Winexe AndAlso baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase" Then
             Code.AppendLine("        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _")
             Code.AppendLine("        <Global.System.Diagnostics.DebuggerHidden()> _")
             Code.AppendLine("        <Global.System.STAThread()> _")
             Code.AppendLine("        Friend Shared Sub Main(ByVal Args As String())")
             Code.AppendLine("            Global.System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(Global.Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering)")
             Code.AppendLine("            $GLOBALMY$.MyProject.Application.Run(Args)")
             Code.AppendLine("        End Sub")
         End If
         Code.AppendLine("    End Class")
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_AppObjectProvider As ThreadSafeObjectProvider(Of $GLOBALMY$.MyApplication) = New ThreadSafeObjectProvider(Of $GLOBALMY$.MyApplication)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Application"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Application As $GLOBALMY$.MyApplication")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_AppObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="347" nfragments="3">
<clone_fragment endline="791" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" hamdist="0" pcid="7233" startline="742"><![CDATA[
 
     Private Function CheckOutermostNamespace(ByVal R As String) As Boolean
 
         '---------------------------------------------------------------------------------------------------------
         '* For each nested namespace, starting from the innermost and going to the outermost namespace, 
         '  do the following
         '** If the namespace contains an accessible namespace member with the given name, then the identifier
         '   refers to that member and, depending on the member, is classified as a namespace or a type.
         '** Otherwise, if the namespace contains one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then the 
         '   result is exactly the same as a member access of the form M.E, where M is the standard module 
         '   containing the matching member and E is the identifier. If the identifier matches accessible type 
         '   members in more than one standard module, a compile-time error occurs.
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         '---------------------------------------------------------------------------------------------------------
         Dim foundNamespace As [Namespace] = Nothing
         Dim foundType As Mono.Cecil.TypeReference
 
         foundType = Compiler.TypeManager.TypesByNamespace("").Item(R)
         If foundType Is Nothing AndAlso Compiler.Assembly.Name <> "" Then
             foundType = Compiler.TypeManager.TypesByNamespace(Compiler.Assembly.Name).Item(R)
         End If
 
         foundNamespace = Compiler.TypeManager.Namespaces(R)
         If foundNamespace IsNot Nothing AndAlso foundType Is Nothing Then
             Classification = New NamespaceClassification(Me, foundNamespace)
             Return True
         ElseIf foundNamespace Is Nothing AndAlso foundType IsNot Nothing Then
             Classification = New TypeClassification(Me, foundType)
             Return True
         ElseIf foundNamespace IsNot Nothing AndAlso foundType IsNot Nothing Then
             Return Helper.AddError(Me)
         End If
 
         If foundNamespace Is Nothing Then Return False
 
         Dim modules As TypeDictionary
         Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         modules = Compiler.TypeManager.GetModulesByNamespace(foundNamespace.ToString)
         members = Helper.GetMembersOfTypes(Compiler, modules, R)
         If members.Count = 1 Then
             Helper.Assert(Helper.IsTypeDeclaration(members(0)))
             Classification = New TypeClassification(Me, members(0))
         ElseIf members.Count > 1 Then
             Return Helper.AddError(Me)
         End If
 
         Return False
     End Function
]]></clone_fragment>
<clone_fragment endline="897" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" hamdist="9" pcid="7237" startline="810"><![CDATA[
 
     Private Function ResolveImports(ByVal imps As ImportsClauses, ByVal Name As String) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* If the (source file / compilation environment) containing the name reference has one or more imports
         '** If the identifier matches the name of an accessible type or type member in exactly one import, 
         '   then the identifier refers to that type or type member. If the identifier matches the name of 
         '   an accessible type or type member in more than one import, a compile-time error occurs.
         '** If the identifier matches the name of a namespace in exactly one import, then the identifier 
         '   refers to that namespace. If the identifier matches the name of a namespace in more than one import, 
         '   a compile-time error occurs.
         '** Otherwise, if the imports contain one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then 
         '   the result is exactly the same as a member access of the form M.E, where M is the standard 
         '   module containing the matching member and E is the identifier. If the identifier matches 
         '   accessible type members in more than one standard module, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         Dim impmembers As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
         For Each imp As ImportsClause In imps
             If imp.IsNamespaceClause Then
                 If imp.AsNamespaceClause.IsNamespaceImport Then
                     'The specified name can only be a type.
                     If Compiler.TypeManager.TypesByNamespace.ContainsKey(imp.AsNamespaceClause.Name) Then
                         result = Compiler.TypeManager.GetTypesByNamespaceAndName(imp.AsNamespaceClause.Name, Name)
                         'Helper.FilterByName(Compiler.TypeManager.TypesByNamespace(imp.AsNamespaceClause.Name).ToTypeList, Name, result)
                     End If
                 ElseIf imp.AsNamespaceClause.IsTypeImport Then
                     'result.AddRange(Helper.FilterByName(imp.AsNamespaceClause.TypeImported.GetMembers, Name))
                     'result.AddRange(Compiler.TypeManager.GetCache(imp.AsNamespaceClause.TypeImported).LookupMembersFlattened(Name))
                     result = Compiler.TypeManager.GetCache(imp.AsNamespaceClause.TypeImported).LookupMembersFlattened(Name)
                 Else
                     Continue For 'This import was not resolved correctly, so don't use it.
                 End If
             End If
             If result IsNot Nothing AndAlso result.Count > 0 Then
                 If impmembers.Count > 0 Then
                     Return Helper.AddError(Me, "If the identifier matches the name of an accessible type or type member in more than one import, a compile-time error occurs.")
                 End If
                 impmembers.AddRange(result)
                 result = Nothing
             End If
         Next
 
         If impmembers.Count > 0 Then
             'If the identifier matches the name of an accessible type or type member in exactly one import, 
             'then the identifier refers to that type or type member. If the identifier matches the name of 
             'an accessible type or type member in more than one import, a compile-time error occurs.
             If Helper.IsMethodDeclaration(impmembers(0)) Then
                 Classification = New MethodGroupClassification(Me, Nothing, m_TypeArgumentList, Nothing, impmembers)
                 Return True
             End If
             If Helper.IsTypeDeclaration(impmembers(0)) Then
                 Classification = New TypeClassification(Me, impmembers(0))
                 Return True
             End If
             If Helper.IsFieldDeclaration(impmembers(0)) Then
                 Classification = New ValueClassification(Me, DirectCast(impmembers(0), Mono.Cecil.FieldReference), Nothing)
                 Return True
             End If
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
         End If
 
         Dim nsmembers As Generic.List(Of [Namespace])
         nsmembers = imps.GetNamespaces(Me, Name)
         If nsmembers.Count = 1 Then
             'If the identifier matches the name of a namespace in exactly one import, then the identifier 
             'refers to that namespace. If the identifier matches the name of a namespace in more than one import, 
             'a compile-time error occurs.
             Classification = New NamespaceClassification(Me, nsmembers(0))
             Return True
         ElseIf nsmembers.Count > 1 Then
             Return Helper.AddError(Me)
         End If
 
         'Otherwise, if the imports contain one or more accessible standard modules, and a member name 
         'lookup of the identifier produces an accessible match in exactly one standard module, then 
         'the result is exactly the same as a member access of the form M.E, where M is the standard 
         'module containing the matching member and E is the identifier. If the identifier matches 
         'accessible type members in more than one standard module, a compile-time error occurs.
         Dim modules As TypeList = imps.GetModules(Me)
         Dim found As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         found = Helper.GetMembersOfTypes(Compiler, modules, Name)
         If SetClassificationOfModuleMembers(found) Then
             Return True
         End If
 
         Return False
     End Function
]]></clone_fragment>
<clone_fragment endline="331" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" hamdist="12" pcid="7103" startline="237"><![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(New ResolveInfo(Info.Compiler, True, , False)) AndAlso result
         If result = False Then Return False
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveCode(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
         If result = False Then Return False
         'Check the classification of the arguments, can be value, variable, propertyaccess
         For i As Integer = 0 To m_ArgumentList.Count - 1
             If m_ArgumentList(i).Expression IsNot Nothing Then
                 Select Case m_ArgumentList(i).Expression.Classification.Classification
                     Case ExpressionClassification.Classifications.Value
                         'ok
                     Case ExpressionClassification.Classifications.Variable
                         'ok
                     Case ExpressionClassification.Classifications.PropertyAccess
                         'ok
                     Case ExpressionClassification.Classifications.MethodPointer
                         'ok?
                     Case ExpressionClassification.Classifications.PropertyGroup
                         m_ArgumentList(i).Expression = m_ArgumentList(i).Expression.ReclassifyToPropertyAccessExpression
                         result = m_ArgumentList(i).Expression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                     Case Else
                         'reclassify to value
                         If m_ArgumentList(i).Expression.Classification.CanBeValueClassification Then
                             m_ArgumentList(i).Expression = m_ArgumentList(i).Expression.ReclassifyToValueExpression
                             result = m_ArgumentList(i).Expression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                         Else
                             Helper.AddError(Me)
                         End If
                 End Select
             End If
         Next
 
         If result = False Then Return result
 
         Select Case m_Expression.Classification.Classification
             Case ExpressionClassification.Classifications.LateBoundAccess
                 Dim lae As LateBoundAccessClassification = m_Expression.Classification.AsLateBoundAccess
                 lae.Arguments = m_ArgumentList
                 Classification = lae
             Case ExpressionClassification.Classifications.MethodGroup
                 'This is an invocation expression.
                 result = ResolveMethodInvocation() AndAlso result
 
             Case ExpressionClassification.Classifications.Value
                 If CecilHelper.IsArray(m_Expression.ExpressionType) Then
                     result = ResolveArrayInvocation(Me, m_Expression.ExpressionType) AndAlso result
                 Else
                     result = ResolveIndexInvocation(Me, m_Expression.ExpressionType) AndAlso result
                 End If
             Case ExpressionClassification.Classifications.PropertyAccess
                 If CecilHelper.IsArray(m_Expression.ExpressionType) Then
                     result = ResolveArrayInvocation(Me, m_Expression.ExpressionType) AndAlso result
                 Else
                     result = ResolveIndexInvocation(Me, m_Expression.ExpressionType) AndAlso result
                 End If
             Case ExpressionClassification.Classifications.PropertyGroup
                 result = ResolvePropertyGroupInvocation() AndAlso result
             Case ExpressionClassification.Classifications.Variable
                 'This is an index expression.
 
                 '                An index expression results in an array element or reclassifies a property group into a property access. An index expression consists of, in order, an expression, an opening parenthesis, an index argument list, and a closing parenthesis. The target of the index expression must be classified as either a property group or a value. An index expression is processed as follows
                 '	If the target expression is classified as a value and if its type is not an array type, Object, or System.Array, the type must have a default property. The index is performed on a property group that represents all of the default properties of the type. Although it is not valid to declare a parameterless default property in Visual Basic, other languages may allow declaring such a property. Consequently, indexing a property with no arguments is allowed.
                 '	If the expression results in a value of an array type, the number of arguments in the argument list must be the same as the rank of the array type and may not include named arguments. If any of the indexes are invalid at run time, a System.IndexOutOfRangeException exception is thrown. Each expression must be implicitly convertible to type Integer. The result of the index expression is the variable at the specified index and is classified as a variable.
                 '	If the expression is classified as a property group, overload resolution is used to determine whether one of the properties is applicable to the index argument list. If the property group only contains one property that has a Get accessor and if that accessor takes no arguments, then the property group is interpreted as an index expression with an empty argument list. The result is used as the target of the current index expression. If no properties are applicable, then a compile-time error occurs. Otherwise, the expression results in a property access with the associated instance expression (if any) of the property group.
                 '	If the expression is classified as a late-bound property group or as a value whose type is Object or System.Array, the processing of the index expression is deferred until run time and the indexing is late-bound. The expression results in a late-bound property access typed as Object. The associated instance expression is either the target expression, if it is a value, or the associated instance expression of the property group. At run time the expression is processed as follows
                 '	If the expression is classified as a late-bound property group, the expression may result in a method group, a property group, or a value (if the member is an instance or shared variable). If the result is a method group or property group, overload resolution is applied to the group to determine the correct method for the argument list. If overload resolution fails, a System.Reflection.AmbiguousMatchException exception is thrown. Then the result is processed either as a property access or as an invocation and the result is returned. If the invocation is of a subroutine, the result is Nothing.
                 '	If the run-time type of the target expression is an array type or System.Array, the result of the index expression is the value of the variable at the specified index. 
                 '	Otherwise, the run-time type of the expression must have a default property and the index is performed on the property group that represents all of the default properties on the type. If the type has no default property, then a System.MissingMemberException exception is thrown.
 
                 Dim varexp As VariableClassification = m_Expression.Classification.AsVariableClassification
                 Dim expType As Mono.Cecil.TypeReference = varexp.Type
                 If CecilHelper.IsByRef(expType) Then
                     m_Expression = m_Expression.DereferenceByRef
                     expType = m_Expression.ExpressionType
                 End If
 
                 result = ResolveIndexInvocation(Me, expType) AndAlso result
             Case Else
                 Helper.AddError(Me, "Some error...")
         End Select
 
         If result = False Then Return result
 
         If m_ExpressionType Is Nothing Then
             m_ExpressionType = Classification.GetType(True)
         End If
 
         Helper.Assert(m_ExpressionType IsNot Nothing)
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="348" nfragments="3">
<clone_fragment endline="268" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" hamdist="0" pcid="639" startline="221"><![CDATA[
 	}
 
 	public sealed class TypeBuilder 
 	{
 		public const int UnspecifiedTypeSize = 0;
 		private readonly ITypeOwner owner;
 		private readonly int token;
 		private int extends;
 		private Type baseType;
 		private readonly int typeName;
 		private readonly int typeNameSpace;
 		private readonly string nameOrFullName;
 		private readonly List<MethodBuilder> methods = new List<MethodBuilder>();
 		private readonly List<FieldBuilder> fields = new List<FieldBuilder>();
 		private List<PropertyBuilder> properties;
 		private List<EventBuilder> events;
 		private TypeAttributes attribs;
 		private TypeFlags typeFlags;
 		private GenericTypeParameterBuilder[] gtpb;
 		private List<CustomAttributeBuilder> declarativeSecurity;
 		private List<Type> interfaces;
 
 		[Flags]
 		private enum TypeFlags
 		{
 			IsGenericTypeDefinition = 1,
 			HasNestedTypes = 2,
 			Baked = 4,
 		}
 
 		internal TypeBuilder(ITypeOwner owner, string name, Type baseType, TypeAttributes attribs)
 		{
 			this.owner = owner;
 			this.token = this.ModuleBuilder.TypeDef.AllocToken();
 			this.nameOrFullName = TypeNameParser.Escape(name);
 			SetParent(baseType);
 			this.attribs = attribs;
 			if (!this.IsNested)
 			{
 				int lastdot = name.LastIndexOf('.');
 				if (lastdot > 0)
 				{
 					this.typeNameSpace = this.ModuleBuilder.Strings.Add(name.Substring(0, lastdot));
 					name = name.Substring(lastdot + 1);
 				}
 			}
 			this.typeName = this.ModuleBuilder.Strings.Add(name);
 		}
]]></clone_fragment>
<clone_fragment endline="112" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" hamdist="10" pcid="4573" startline="60"><![CDATA[
 		private readonly PEReader peFile = new PEReader();
 		private readonly CliHeader cliHeader = new CliHeader();
 		private string imageRuntimeVersion;
 		private int metadataStreamVersion;
 		private byte[] stringHeap;
 		private byte[] blobHeap;
 		private byte[] userStringHeap;
 		private byte[] guidHeap;
 		private TypeDefImpl[] typeDefs;
 		private TypeDefImpl moduleType;
 		private Assembly[] assemblyRefs;
 		private Type[] typeRefs;
 		private Type[] typeSpecs;
 		private FieldInfo[] fields;
 		private MethodBase[] methods;
 		private MemberInfo[] memberRefs;
 		private Dictionary<int, string> strings = new Dictionary<int, string>();
 		private Dictionary<string, Type> types = new Dictionary<string, Type>();
 		private Dictionary<string, LazyForwardedType> forwardedTypes = new Dictionary<string, LazyForwardedType>();
 
 		private sealed class LazyForwardedType
 		{
 			private readonly int assemblyRef;
 			private Type type;
 
 			internal LazyForwardedType(int assemblyRef)
 			{
 				this.assemblyRef = assemblyRef;
 			}
 
 			internal Type GetType(ModuleReader module, string typeName)
 			{
 				if (type == null)
 				{
 					Assembly asm = module.ResolveAssemblyRef(assemblyRef);
 					type = asm.GetType(typeName, true);
 				}
 				return type;
 			}
 		}
 
 		internal ModuleReader(AssemblyReader assembly, Universe universe, Stream stream, string location)
 			
 		{
 			this.stream = stream;
 			this.location = location;
 			Read();
 			if (assembly == null && AssemblyTable.records.Length != 0)
 			{
 				assembly = new AssemblyReader(location, this);
 			}
 			this.assembly = assembly;
 		}
]]></clone_fragment>
<clone_fragment endline="115" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" hamdist="12" pcid="5961" startline="54"><![CDATA[
 		private PEFileKinds fileKind = PEFileKinds.Dll;
 		private MethodInfo entryPoint;
 		private VersionInfo versionInfo;
 		private ResourceSection unmanagedResources;
 		private string imageRuntimeVersion;
 		internal int mdStreamVersion = 0x20000;
 		private Module pseudoManifestModule;
 		private readonly List<ResourceFile> resourceFiles = new List<ResourceFile>();
 		private readonly List<ModuleBuilder> modules = new List<ModuleBuilder>();
 		private readonly List<Module> addedModules = new List<Module>();
 		private readonly List<CustomAttributeBuilder> customAttributes = new List<CustomAttributeBuilder>();
 		private readonly List<CustomAttributeBuilder> declarativeSecurity = new List<CustomAttributeBuilder>();
 		private readonly List<Type> typeForwarders = new List<Type>();
 
 		private struct ResourceFile
 		{
 			internal string Name;
 			internal string FileName;
 			internal ResourceAttributes Attributes;
 		}
 
 		internal AssemblyBuilder(Universe universe, AssemblyName name, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
 			
 		{
 			this.name = name.Name;
 			SetVersionHelper(name.Version);
 			if (name.CultureInfo != null && !string.IsNullOrEmpty(name.CultureInfo.Name))
 			{
 				this.culture = name.CultureInfo.Name;
 			}
 			this.flags = name.Flags;
 			this.hashAlgorithm = name.HashAlgorithm;
 			if (this.hashAlgorithm == AssemblyHashAlgorithm.None)
 			{
 				this.hashAlgorithm = AssemblyHashAlgorithm.SHA1;
 			}
 			this.keyPair = name.KeyPair;
 			if (this.keyPair != null)
 			{
 				this.publicKey = this.keyPair.PublicKey;
 			}
 			else
 			{
 				byte[] publicKey = name.GetPublicKey();
 				if (publicKey != null && publicKey.Length != 0)
 				{
 					this.publicKey = (byte[])publicKey.Clone();
 				}
 			}
 			this.dir = dir ?? ".";
 			this.requiredPermissions = requiredPermissions;
 			this.optionalPermissions = optionalPermissions;
 			this.refusedPermissions = refusedPermissions;
 			if (universe.HasMscorlib && universe.Mscorlib.ImageRuntimeVersion != null)
 			{
 				this.imageRuntimeVersion = universe.Mscorlib.ImageRuntimeVersion;
 			}
 			else
 			{
 				this.imageRuntimeVersion = typeof(object).Assembly.ImageRuntimeVersion;
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="349" nfragments="2">
<clone_fragment endline="926" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\AssemblyDeclaration.vb" hamdist="0" pcid="9679" startline="872"><![CDATA[
 
     Private Function SetVersion(ByVal Name As Mono.Cecil.AssemblyNameDefinition, ByVal Attribute As Attribute, ByVal Location As Span) As Boolean
         Dim result As Version
         Dim version As String = ""
 
         If Attribute.Arguments IsNot Nothing AndAlso Attribute.Arguments.Length = 1 Then
             version = TryCast(Attribute.Arguments()(0), String)
         Else
             Return ShowInvalidVersionMessage(version, Location)
         End If
 
         Try
             Dim parts() As String
             Dim major, minor, build, revision As UShort
             parts = version.Split("."c)
 
             If parts.Length > 4 Then
                 Return ShowInvalidVersionMessage(version, Location)
             End If
 
             If Not UShort.TryParse(parts(0), major) Then
                 Return ShowInvalidVersionMessage(version, Location)
             End If
 
             If Not UShort.TryParse(parts(1), minor) Then
                 Return ShowInvalidVersionMessage(version, Location)
             End If
 
             If parts.Length < 3 Then
                 'Use 0
             ElseIf parts(2) = "*" Then
                 build = CUShort((Date.Now - New Date(2000, 1, 1)).TotalDays)
                 revision = CUShort((Date.Now.Hour * 3600 + Date.Now.Minute * 60 + Date.Now.Second) / 2)
             ElseIf Not UShort.TryParse(parts(2), build) Then
                 Return ShowInvalidVersionMessage(version, Location)
             End If
 
             If parts.Length < 4 Then
                 'Use 0
             ElseIf parts.Length > 3 Then
                 If parts(3) = "*" Then
                     revision = CUShort((Date.Now.Hour * 3600 + Date.Now.Minute * 60 + Date.Now.Second) / 2)
                 ElseIf Not UShort.TryParse(parts(3), revision) Then
                     Return ShowInvalidVersionMessage(version, Location)
                 End If
             End If
 
             result = New Version(major, minor, build, revision)
         Catch ex As Exception
             Return ShowInvalidVersionMessage(version, Location)
         End Try
 
         Name.Version = result
         Return True
     End Function
]]></clone_fragment>
<clone_fragment endline="118" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\Classifications\VariableClassification.vb" hamdist="13" pcid="6823" startline="66"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Helper.Assert(IsConstant)
             If Me.FieldInfo IsNot Nothing Then
                 If Me.FieldDefinition.IsLiteral Then
                     If Me.FieldDefinition.HasConstant = False OrElse Me.FieldDefinition.Constant Is Nothing Then
                         Dim field As IFieldMember = TryCast(Me.FieldInfo.Annotations(Compiler), IFieldMember)
                         Dim value As Object = Nothing
                         If field Is Nothing Then
                             'A field from an external assembly
                             Return Me.FieldDefinition.Constant
                         End If
                         If field.ResolveAndGetConstantValue(value) Then
                             Return value
                         Else
                             Helper.Stop()
                             Return Nothing
                         End If
                         Helper.Stop() 'Constant value hasn't been set yet
                         Return Nothing
                     Else
                         Return Me.FieldDefinition.Constant
                     End If
                 ElseIf Me.FieldDefinition.IsInitOnly Then
                     Dim dec As Decimal, dt As Date
                     Dim constant As ConstantDeclaration
                     Dim attrib As Object
 
                     attrib = FieldDefinition.Annotations(Compiler)
                     If attrib IsNot Nothing Then
                         constant = TryCast(attrib, ConstantDeclaration)
                         Return constant.ConstantValue
                     End If
 
                     If ConstantDeclaration.GetDecimalConstant(Compiler, FieldDefinition, dec) Then
                         Return dec
                     ElseIf ConstantDeclaration.GetDateConstant(Compiler, FieldDefinition, dt) Then
                         Return dt
                     Else
                         Helper.Stop() 'This shouldn't really happen (IsConstant should return false)
                         Return Nothing
                     End If
                 Else
                     Helper.Stop() 'This shouldn't really happen (IsConstant should return false)
                     Return Nothing
                 End If
             Else
                 Helper.Stop() 'This shouldn't really happen (IsConstant should return false)
                 Return Nothing
             End If
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="350" nfragments="3">
<clone_fragment endline="406" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" hamdist="0" pcid="3887" startline="353"><![CDATA[
 
 		static public byte[] ToCapiPrivateKeyBlob (DSA dsa)
 		{
 			DSAParameters p = dsa.ExportParameters (true);
 			int keyLength = p.P.Length; // in bytes
 
 			// header + P + Q + G + X + count + seed
 			byte[] blob = new byte [16 + keyLength + 20 + keyLength + 20 + 4 + 20];
 
 			blob [0] = 0x07;	// Type - PRIVATEKEYBLOB (0x07)
 			blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
 			// [2], [3]		// RESERVED - Always 0
 			blob [5] = 0x22;	// ALGID
 			blob [8] = 0x44;	// Magic
 			blob [9] = 0x53;
 			blob [10] = 0x53;
 			blob [11] = 0x32;
 
 			byte[] bitlen = GetBytesLE (keyLength << 3);
 			blob [12] = bitlen [0];
 			blob [13] = bitlen [1];
 			blob [14] = bitlen [2];
 			blob [15] = bitlen [3];
 
 			int pos = 16;
 			byte[] part = p.P;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.Q;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 			pos += 20;
 
 			part = p.G;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.X;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 			pos += 20;
 
 			Buffer.BlockCopy (GetBytesLE (p.Counter), 0, blob, pos, 4);
 			pos += 4;
 
 			part = p.Seed;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 
 			return blob;
 		}
]]></clone_fragment>
<clone_fragment endline="625" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" hamdist="1" pcid="3895" startline="570"><![CDATA[
 
 		static public byte[] ToCapiPublicKeyBlob (DSA dsa)
 		{
 			DSAParameters p = dsa.ExportParameters (false);
 			int keyLength = p.P.Length; // in bytes
 
 			// header + P + Q + G + Y + count + seed
 			byte[] blob = new byte [16 + keyLength + 20 + keyLength + keyLength + 4 + 20];
 
 			blob [0] = 0x06;	// Type - PUBLICKEYBLOB (0x06)
 			blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
 			// [2], [3]		// RESERVED - Always 0
 			blob [5] = 0x22;	// ALGID
 			blob [8] = 0x44;	// Magic
 			blob [9] = 0x53;
 			blob [10] = 0x53;
 			blob [11] = 0x31;
 
 			byte[] bitlen = GetBytesLE (keyLength << 3);
 			blob [12] = bitlen [0];
 			blob [13] = bitlen [1];
 			blob [14] = bitlen [2];
 			blob [15] = bitlen [3];
 
 			int pos = 16;
 			byte[] part;
 
 			part = p.P;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.Q;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 			pos += 20;
 
 			part = p.G;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.Y;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			Buffer.BlockCopy (GetBytesLE (p.Counter), 0, blob, pos, 4);
 			pos += 4;
 
 			part = p.Seed;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 
 			return blob;
 		}
]]></clone_fragment>
<clone_fragment endline="352" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" hamdist="7" pcid="3885" startline="281"><![CDATA[
 
 		static public byte[] ToCapiPrivateKeyBlob (RSA rsa) 
 		{
 			RSAParameters p = rsa.ExportParameters (true);
 			int keyLength = p.Modulus.Length; // in bytes
 			byte[] blob = new byte [20 + (keyLength << 2) + (keyLength >> 1)];
 
 			blob [0] = 0x07;	// Type - PRIVATEKEYBLOB (0x07)
 			blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
 			// [2], [3]		// RESERVED - Always 0
 			blob [5] = 0x24;	// ALGID - Always 00 24 00 00 (for CALG_RSA_SIGN)
 			blob [8] = 0x52;	// Magic - RSA2 (ASCII in hex)
 			blob [9] = 0x53;
 			blob [10] = 0x41;
 			blob [11] = 0x32;
 
 			byte[] bitlen = GetBytesLE (keyLength << 3);
 			blob [12] = bitlen [0];	// bitlen
 			blob [13] = bitlen [1];	
 			blob [14] = bitlen [2];	
 			blob [15] = bitlen [3];
 
 			// public exponent (DWORD)
 			int pos = 16;
 			int n = p.Exponent.Length;
 			while (n > 0)
 				blob [pos++] = p.Exponent [--n];
 			while (n > 0)
 				blob [pos++] = p.Exponent [--n];
 			// modulus
 			pos = 20;
 			byte[] part = p.Modulus;
 			int len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 			// private key
 			part = p.P;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.Q;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.DP;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.DQ;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.InverseQ;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.D;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 
 			return blob;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="351" nfragments="2">
<clone_fragment endline="620" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\TypeResolution.vb" hamdist="0" pcid="8289" startline="568"><![CDATA[
 
     Public Function GetWidestType(ByVal tp1 As TypeReference, ByVal tp2 As TypeReference, ByVal tp3 As TypeReference) As TypeReference
         Dim cont1(), cont2(), cont3() As Mono.Cecil.TypeReference
 
         Helper.Assert(tp1 IsNot Nothing, "tp1 Is Nothing")
         Helper.Assert(tp2 IsNot Nothing, "tp2 Is Nothing")
 
         If tp1 Is tp2 Then
             If tp3 Is Nothing Then Return tp1
             If tp1 Is tp3 Then Return tp2
         End If
 
         Dim itp1, itp2, itp3 As Mono.Cecil.TypeReference
         itp1 = GetIntegralType(Compiler, tp1)
         itp2 = GetIntegralType(Compiler, tp2)
 
         cont1 = valCanBeContainBy(getTypeIndex(CType(TypeToKeyword(itp1), BuiltInDataTypes)))
         cont2 = valCanBeContainBy(getTypeIndex(CType(TypeToKeyword(itp2), BuiltInDataTypes)))
 
         If tp3 Is Nothing Then
             itp3 = Nothing
             cont3 = Nothing
         Else
             itp3 = GetIntegralType(Compiler, tp3)
             cont3 = valCanBeContainBy(getTypeIndex(CType(TypeToKeyword(itp3), BuiltInDataTypes)))
         End If
 
         If cont1 Is Nothing Or cont2 Is Nothing Then Return Nothing
 
         For i As Integer = 0 To cont1.Length - 1
             For j As Integer = 0 To cont2.Length - 1
                 If Not cont2(j) Is cont1(i) Then Continue For
 
                 If itp3 Is Nothing Then
                     'We've found a type that can contain both input types
                     If cont2(j) Is itp1 Then Return tp1
                     If cont2(j) Is itp2 Then Return tp2
                     'Continue looking, the type we want is neither of the two input types
                 Else
                     For k As Integer = 0 To cont3.Length - 1
                         If Not cont3(k) Is cont2(j) Then Continue For
                         'We've found a type that can contain all three input types
                         If cont3(k) Is itp1 Then Return tp1
                         If cont3(k) Is itp2 Then Return tp2
                         If cont3(k) Is itp3 Then Return tp3
                         'Continue looking, the type we want is neither of the three input types
                     Next
                 End If
             Next
         Next
 
         Return Nothing
     End Function
]]></clone_fragment>
<clone_fragment endline="2686" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="13" pcid="7731" startline="2591"><![CDATA[
 
     Shared Function IsAssignable(ByVal Context As BaseObject, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference) As Boolean
         Dim Compiler As Compiler = Context.Compiler
         'If TypeOf FromType Is TypeDescriptor Then FromType = FromType.UnderlyingSystemType
         'If TypeOf ToType Is TypeDescriptor Then ToType = ToType.UnderlyingSystemType
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine("IsAssignable (FromType 
 #End If
         If FromType Is ToType Then
             Return True
         ElseIf Helper.CompareType(FromType, Compiler.TypeCache.Nothing) Then
             Return True
         ElseIf Helper.CompareType(FromType, ToType) Then
             Return True
         ElseIf CecilHelper.IsArray(FromType) = True AndAlso CecilHelper.IsArray(ToType) = True AndAlso FromType.FullName Is Nothing AndAlso ToType.FullName Is Nothing AndAlso FromType.Name.Equals(ToType.Name, StringComparison.Ordinal) Then
             Return True
         ElseIf CompareType(ToType, Compiler.TypeCache.System_Object) Then
             Return True
             'ElseIf TypeOf ToType Is GenericTypeParameterBuilder AndAlso TypeOf FromType Is Type Then
             '    Return ToType.Name = FromType.Name
             'ElseIf ToType.GetType Is Compiler.TypeCache.System_Reflection_Emit_TypeBuilderInstantiation Then
             '    'ElseIf ToType.GetType.Name = "TypeBuilderInstantiation" Then
             '    If Helper.CompareType(Helper.GetTypeOrTypeBuilder(FromType), ToType) Then
             '        Return True
             '    Else
             '        Return False
             '    End If
             '    Return True
             '    'ElseIf TypeOf ToType Is TypeDescriptor = False AndAlso TypeOf FromType Is TypeDescriptor = False AndAlso ToType.IsAssignableFrom(FromType) Then
             '    '    Return True
         ElseIf TypeOf FromType Is GenericParameter Then
             Dim gp As GenericParameter = DirectCast(FromType, GenericParameter)
             If gp.HasConstraints Then
                 For i As Integer = 0 To gp.Constraints.Count - 1
                     If Helper.IsAssignable(Context, gp.Constraints(i), ToType) Then Return True
                 Next
             End If
             Return False
         ElseIf IsInterface(Context, ToType) Then
             Dim ifaces As Mono.Collections.Generic.Collection(Of TypeReference) = CecilHelper.GetInterfaces(FromType, True)
             If ifaces IsNot Nothing Then
                 For i As Integer = 0 To ifaces.Count - 1
                     Dim iface As Mono.Cecil.TypeReference = ifaces(i)
                     If Helper.CompareType(iface, ToType) Then Return True
                     If Helper.IsAssignable(Context, iface, ToType) Then Return True
                     If Helper.IsSubclassOf(ToType, iface) Then Return True
                 Next
             End If
             If IsInterface(Context, FromType) AndAlso CecilHelper.IsGenericType(FromType) AndAlso CecilHelper.IsGenericType(ToType) Then
                 Dim baseFromI, baseToI As Mono.Cecil.TypeReference
                 baseFromI = CecilHelper.GetGenericTypeDefinition(FromType)
                 baseToI = CecilHelper.GetGenericTypeDefinition(ToType)
                 If Helper.CompareType(baseFromI, baseToI) Then
                     Dim fromArgs, toArgs As Mono.Collections.Generic.Collection(Of TypeReference)
                     fromArgs = CecilHelper.GetGenericArguments(FromType)
                     toArgs = CecilHelper.GetGenericArguments(ToType)
                     If fromArgs.Count = toArgs.Count Then
                         For i As Integer = 0 To toArgs.Count - 1
                             If Helper.IsAssignable(Context, fromArgs(i), toArgs(i)) = False Then Return False
                         Next
                         Return True
                     End If
                 End If
             End If
             Return False
         ElseIf Helper.IsEnum(Compiler, FromType) AndAlso Compiler.TypeResolution.IsImplicitlyConvertible(Context, GetEnumType(Compiler, FromType), ToType) Then
             Return True
         ElseIf ToType.FullName IsNot Nothing AndAlso FromType.FullName IsNot Nothing AndAlso ToType.FullName.Equals(FromType.FullName, StringComparison.Ordinal) Then
             Return True
         ElseIf Helper.CompareType(Compiler.TypeCache.System_UInt32, ToType) AndAlso Helper.CompareType(Compiler.TypeCache.System_UInt16, FromType) Then
             Return True
         ElseIf Helper.CompareType(FromType, Compiler.TypeCache.System_Object) Then
             Return False
         ElseIf TypeOf FromType Is Mono.Cecil.ArrayType AndAlso Helper.Compare(ToType, Compiler.TypeCache.System_Array) Then
             Return True
         ElseIf CecilHelper.IsArray(FromType) AndAlso CecilHelper.IsArray(ToType) Then
             Dim fromArray As ArrayType = DirectCast(FromType, ArrayType)
             Dim toArray As ArrayType = DirectCast(ToType, ArrayType)
             Dim fromElement As Mono.Cecil.TypeReference = CecilHelper.GetElementType(FromType)
             Dim toElement As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ToType)
             If CecilHelper.IsValueType(fromElement) Xor CecilHelper.IsValueType(toElement) Then
                 Return False
             ElseIf fromArray.Rank <> toArray.Rank Then
                 Return False
             Else
                 Return Helper.IsAssignable(Context, fromElement, toElement)
             End If
         ElseIf Helper.IsSubclassOf(ToType, FromType) Then
             Return True
         ElseIf Helper.IsSubclassOf(FromType, ToType) Then
             Return False
         Else
             'Helper.NotImplementedYet("Don't know if it possible to convert from " & FromType.Name & " to " & ToType.Name)
             Return False
         End If
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="352" nfragments="2">
<clone_fragment endline="823" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" hamdist="0" pcid="3189" startline="789"><![CDATA[
 
 		/// <summary>
 		///  Finds "most encompassed type" according to the spec (13.4.2)
 		///  amongst the methods in the MethodGroupExpr
 		/// </summary>
 		public static TypeSpec FindMostEncompassedType (IEnumerable<TypeSpec> types)
 		{
 			TypeSpec best = null;
 			EmptyExpression expr = EmptyExpression.Grab ();
 
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (t);
 				if (ImplicitStandardConversionExists (expr, best))
 					best = t;
 			}
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (t);
 				if (ImplicitStandardConversionExists (expr, best))
 					best = t;
 			}
 
 			expr.SetType (best);
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				if (!ImplicitStandardConversionExists (expr, t)) {
 					best = null;
 					break;
 				}
 			}
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				if (!ImplicitStandardConversionExists (expr, t)) {
 					best = null;
 					break;
 				}
 			}
 
 			EmptyExpression.Release (expr);
 
 			return best;
 		}
]]></clone_fragment>
<clone_fragment endline="865" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" hamdist="4" pcid="3191" startline="824"><![CDATA[
 
 		/// <summary>
 		///  Finds "most encompassing type" according to the spec (13.4.2)
 		///  amongst the types in the given set
 		/// </summary>
 		static TypeSpec FindMostEncompassingType (IList<TypeSpec> types)
 		{
 			TypeSpec best = null;
 
 			if (types.Count == 0)
 				return null;
 
 			if (types.Count == 1)
 				return types [0];
 
 			EmptyExpression expr = EmptyExpression.Grab ();
 
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (best);
 				if (ImplicitStandardConversionExists (expr, t))
 					best = t;
 			}
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (best);
 				if (ImplicitStandardConversionExists (expr, t))
 					best = t;
 			}
 
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				expr.SetType (t);
 				if (!ImplicitStandardConversionExists (expr, best)) {
 					best = null;
 					break;
 				}
 			}
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				expr.SetType (t);
 				if (!ImplicitStandardConversionExists (expr, best)) {
 					best = null;
 					break;
 				}
 			}
 
 			EmptyExpression.Release (expr);
 
 			return best;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="353" nfragments="2">
<clone_fragment endline="479" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="0" pcid="7327" startline="428"><![CDATA[
 
     Public Shared Function ResolveType(ByVal original As TypeReference, ByVal parameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal arguments As Mono.Collections.Generic.Collection(Of TypeReference)) As TypeReference
         Dim spec As TypeSpecification = TryCast(original, TypeSpecification)
         Dim array As ArrayType = TryCast(original, ArrayType)
         Dim reference As ByReferenceType = TryCast(original, ByReferenceType)
         Dim genericType As GenericInstanceType = TryCast(original, GenericInstanceType)
 
         If parameters.Count <> arguments.Count Then
             Throw New System.ArgumentException("Parameters and Arguments must have the same number of elements.")
         End If
 
         If spec IsNot Nothing Then
             Dim resolved As TypeReference = ResolveType(spec.ElementType, parameters, arguments)
 
             If genericType IsNot Nothing Then
                 Dim result As GenericInstanceType = New GenericInstanceType(genericType.ElementType)
                 For i As Integer = 0 To genericType.GenericArguments.Count - 1
                     Dim tg As Mono.Cecil.TypeReference = ResolveType(genericType.GenericArguments(i), parameters, arguments)
                     result.GenericArguments.Add(tg)
                 Next
                 Return result
             End If
 
             If resolved Is spec.ElementType Then
                 Return spec
             End If
 
 
             If array IsNot Nothing Then
                 Return New ArrayType(resolved, array.Dimensions.Count)
             ElseIf (reference IsNot Nothing) Then
                 Return New ByReferenceType(resolved)
             Else
                 Throw New System.NotImplementedException()
             End If
         End If
 
         For i As Integer = 0 To parameters.Count - 1
             If parameters(i) Is original Then
                 Return arguments(i)
             End If
         Next
 
         If original.IsNested Then
             Dim parentType As TypeReference = InflateType(original.DeclaringType, parameters, arguments)
             If parentType IsNot original Then
                 Return Compiler.CurrentCompiler.ModuleBuilderCecil.Import(FindDefinition(original))
             End If
         End If
 
         Return original
     End Function
]]></clone_fragment>
<clone_fragment endline="612" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" hamdist="13" pcid="8643" startline="549"><![CDATA[
 
     Sub SelectMostApplicable()
         'Find most applicable methods.
         Dim expandedArgumentTypes(m_Candidates.Count - 1)() As Mono.Cecil.TypeReference
 
         For i As Integer = 0 To m_Candidates.Count - 1
             If m_Candidates(i) Is Nothing Then Continue For
 
             For j As Integer = i + 1 To m_Candidates.Count - 1
                 If m_Candidates(j) Is Nothing Then Continue For
 
                 Dim candidateI As MemberCandidate = m_Candidates(i)
                 Dim candidateJ As MemberCandidate = m_Candidates(j)
 
                 Helper.Assert(candidateI.ExactArguments IsNot Nothing)
                 Helper.Assert(candidateJ.ExactArguments IsNot Nothing)
 
                 Dim a, b As Boolean
 
                 If expandedArgumentTypes(i) Is Nothing Then
                     expandedArgumentTypes(i) = candidateI.TypesInInvokedOrder() ' Helper.GetExpandedTypes(Compiler, candidateI.InputParameters, Arguments.Count)
                 End If
                 If expandedArgumentTypes(j) Is Nothing Then
                     expandedArgumentTypes(j) = candidateJ.TypesInInvokedOrder() 'Helper.GetExpandedTypes(Compiler, candidateJ.InputParameters, Arguments.Count)
                 End If
 
                 a = Helper.IsFirstMoreApplicable(m_Parent, Arguments.Arguments, expandedArgumentTypes(i), expandedArgumentTypes(j))
                 b = Helper.IsFirstMoreApplicable(m_Parent, Arguments.Arguments, expandedArgumentTypes(j), expandedArgumentTypes(i))
 
                 If a = b Then ' AndAlso b = False Then
                     'It is possible for M and N to have the same signature if one or both contains an expanded 
                     'paramarray parameter. In that case, the member with the fewest number of arguments matching
                     'expanded paramarray parameters is considered more applicable. 
                     Dim iParamArgs, jParamArgs As Integer
 
                     If candidateI.IsParamArrayCandidate Then
                         iParamArgs = candidateI.ParamArrayExpression.ArrayElementInitalizer.Initializers.Count + 1
                     End If
                     If candidateJ.IsParamArrayCandidate Then
                         jParamArgs = candidateJ.ParamArrayExpression.ArrayElementInitalizer.Initializers.Count + 1
                     End If
                     If jParamArgs > iParamArgs Then
                         a = True 
                     ElseIf iParamArgs > jParamArgs Then
                         b = True 
                     End If
                     Helper.Assert(iParamArgs <> jParamArgs OrElse (iParamArgs = 0 AndAlso jParamArgs = 0), MethodName)
                 End If
 
                 If a Xor b Then
                     If a = False Then
                         Log("NOT MOST APPLICABLE
                         m_Candidates(i) = Nothing
                         Exit For
                     Else
                         Log("NOT MOST APPLICABLE
                         m_Candidates(j) = Nothing
                     End If
                 Else
                     Log("EQUALLY APPLICABLE
                 End If
             Next
         Next
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="354" nfragments="2">
<clone_fragment endline="1942" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="0" pcid="7657" startline="1891"><![CDATA[
 
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal CalledMethodAccessability As Mono.Cecil.MethodAttributes, ByVal CalledType As Mono.Cecil.TypeReference, ByVal CallerType As Mono.Cecil.TypeReference) As Boolean
         'If both types are equal everything is accessible.
         If CompareType(CalledType, CallerType) Then Return True
 
         'If the callertype is a nested class of the called type, then everything is accessible as well.
         If IsNested(CalledType, CallerType) Then Return True
 
         'If the called type is not accessible from the caller, the member cannot be accessible either.
         If IsAccessible(Context.Compiler, CalledType, CallerType) = False Then Return False
 
         Dim ac As Mono.Cecil.MethodAttributes = (CalledMethodAccessability And Mono.Cecil.MethodAttributes.MemberAccessMask)
         Dim isPrivate As Boolean = ac = Mono.Cecil.MethodAttributes.Private
         Dim isFriend As Boolean = ac = Mono.Cecil.MethodAttributes.Assembly OrElse ac = Mono.Cecil.MethodAttributes.FamORAssem
         Dim isProtected As Boolean = ac = Mono.Cecil.MethodAttributes.Family OrElse ac = Mono.Cecil.MethodAttributes.FamORAssem
         Dim isPublic As Boolean = ac = Mono.Cecil.MethodAttributes.Public
 
         'Public members are always accessible!
         If isPublic Then Return True
 
         'If the member is private, the member is not accessible
         '(to be accessible the types must be equal or the caller type must
         'be a nested type of the called type, cases already covered).
         'Catch
         If isPrivate Then Return Helper.IsEnum(Context.Compiler, CalledType)
 
         If isFriend AndAlso isProtected Then
             'Friend and Protected
             'Both types must be in the same assembly or CallerType must inherit from CalledType.
             Return Context.Compiler.Assembly.IsDefinedHere(CalledType) OrElse (Helper.IsSubclassOf(CalledType, CallerType))
         ElseIf isFriend Then
             'Friend, but not Protected
             'Both types must be in the same assembly
             Return Context.Compiler.Assembly.IsDefinedHere(CalledType)
         ElseIf isProtected Then
             'Protected, but not Friend
             'CallerType must inherit from CalledType.
             Return Helper.IsSubclassOf(CalledType, CallerType)
         End If
 
         Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location) '("No accessibility??")
 
         'private 	    = 1	= 0001
         'famandassembly = 2 = 0010
         'Assembly       = 3 = 0011
         'family         = 4 = 0100
         'famorassembly  = 5 = 0101
         'public 	    = 6	= 0110
 
         Return False
     End Function
]]></clone_fragment>
<clone_fragment endline="1890" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="10" pcid="7655" startline="1832"><![CDATA[
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal CalledMethodAccessability As Mono.Cecil.MethodAttributes, ByVal CalledType As Mono.Cecil.TypeReference) As Boolean
         Dim Compiler As Compiler = Context.Compiler
 
         Helper.Assert(Compiler IsNot Nothing)
         Helper.Assert(CalledType IsNot Nothing)
 
         'Checks it the accessed method / type is accessible from the current compiling code
         '(for attributes that is not contained within a type)
 
         Dim testNested As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(CalledType)
         Dim compiledType As Boolean = Compiler.Assembly.IsDefinedHere(CalledType)
         Dim mostDeclaredType As Mono.Cecil.TypeDefinition = Nothing
 
         Do Until testNested Is Nothing
             mostDeclaredType = testNested
             'If it is a nested private type, it is not accessible.
             If testNested.IsNestedPrivate Then Return False
             'If it is not a nested public type in an external assembly, it is not accessible.
             If compiledType = False AndAlso testNested.IsNestedPublic = False AndAlso testNested.IsNested Then Return False
             testNested = CecilHelper.FindDefinition(testNested.DeclaringType)
         Loop
         Do Until testNested Is Nothing
             mostDeclaredType = testNested
             'If it is a nested private type, it is not accessible.
             If testNested.IsNestedPrivate Then Return False
             'If it is not a nested public type in an external assembly, it is not accessible.
             If compiledType = False AndAlso testNested.IsNestedPublic = False AndAlso testNested.IsNested Then Return False
             testNested = CecilHelper.FindDefinition(testNested.DeclaringType)
         Loop
 
         'If the most external type is not public then it is not accessible.
         If compiledType = False AndAlso mostDeclaredType.IsPublic = False Then Return False
 
         'The type is at least accessible now, check the method.
 
         Dim ac As Mono.Cecil.MethodAttributes = (CalledMethodAccessability And Mono.Cecil.MethodAttributes.MemberAccessMask)
         Dim isPrivate As Boolean = ac = Mono.Cecil.MethodAttributes.Private
         Dim isFriend As Boolean = ac = Mono.Cecil.MethodAttributes.Assembly OrElse ac = Mono.Cecil.MethodAttributes.FamORAssem
         Dim isProtected As Boolean = ac = Mono.Cecil.MethodAttributes.Family OrElse ac = Mono.Cecil.MethodAttributes.FamORAssem
         Dim isPublic As Boolean = ac = Mono.Cecil.MethodAttributes.Public
 
         'If the member is private, the member is not accessible
         '(to be accessible the types must be equal or the caller type must
         'be a nested type of the called type, cases already covered).
         If isPrivate Then Return False
 
         If isFriend AndAlso isProtected Then
             'Friend and Protected
             'If it is an external type it is not accessible.
             Return compiledType
         ElseIf isFriend Then
             'Friend, but not Protected
             'If it is an external type it is not accessible.
             Return compiledType
         ElseIf isProtected Then
             'Protected, but not Friend
             'It is not accessible.
             Return False
         ElseIf isPublic Then
             Return True
         End If
 
         Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location) '("No accessibility??")
 
         Return False
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="355" nfragments="2">
<clone_fragment endline="3885" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="0" pcid="3449" startline="3827"><![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			//
 			// Needed to emit anonymous storey initialization
 			// Otherwise it does not contain any statements for now
 			//
 			block.Emit (ec);
 
 			default_target = ec.DefineLabel ();
 			null_target = ec.DefineLabel ();
 
 			// Store variable for comparission purposes
 			// TODO
 			LocalTemporary value;
 			if (HaveUnwrap) {
 				value = new LocalTemporary (SwitchType);
 				unwrap.EmitCheck (ec);
 				ec.Emit (OpCodes.Brfalse, null_target);
 				new_expr.Emit (ec);
 				value.Store (ec);
 			} else if (!is_constant) {
 				value = new LocalTemporary (SwitchType);
 				new_expr.Emit (ec);
 				value.Store (ec);
 			} else
 				value = null;
 
 			//
 			// Setup the codegen context
 			//
 			Label old_end = ec.LoopEnd;
 			Switch old_switch = ec.Switch;
 			
 			ec.LoopEnd = ec.DefineLabel ();
 			ec.Switch = this;
 
 			// Emit Code.
 			if (is_constant) {
 				if (constant_section != null)
 					constant_section.Block.Emit (ec);
 			} else if (string_dictionary != null) {
 				DoEmitStringSwitch (value, ec);
 			} else {
 				TableSwitchEmit (ec, value);
 			}
 
 			if (value != null)
 				value.Release (ec);
 
 			// Restore context state. 
 			ec.MarkLabel (ec.LoopEnd);
 
 			//
 			// Restore the previous context
 			//
 			ec.LoopEnd = old_end;
 			ec.Switch = old_switch;
 		}
]]></clone_fragment>
<clone_fragment endline="1332" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="13" pcid="5485" startline="1275"><![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Value;
 
 			// FIXME
 			var caller_builder = (Constructor) ec.MemberContext;
 
 			//
 			// Spec mandates that constructor initializer will not have `this' access
 			//
 			using (ec.Set (ResolveContext.Options.BaseInitializer)) {
 				if (argument_list != null) {
 					bool dynamic;
 					argument_list.Resolve (ec, out dynamic);
 
 					if (dynamic) {
 						ec.Report.Error (1975, loc,
 							"The constructor call cannot be dynamically dispatched within constructor initializer");
 
 						return null;
 					}
 				}
 
 				type = ec.CurrentType;
 				if (this is ConstructorBaseInitializer) {
 					if (ec.CurrentType.BaseType == null)
 						return this;
 
 					type = ec.CurrentType.BaseType;
 					if (ec.CurrentType.IsStruct) {
 						ec.Report.Error (522, loc,
 							"`{0}'
 						return this;
 					}
 				} else {
 					//
 					// It is legal to have "this" initializers that take no arguments
 					// in structs, they are just no-ops.
 					//
 					// struct D { public D (int a) 
 					//
 					if (TypeManager.IsStruct (ec.CurrentType) && argument_list == null)
 						return this;
 				}
 
 				base_ctor = ConstructorLookup (ec, type, ref argument_list, loc);
 			}
 	
 			// TODO MemberCache
 			if (base_ctor == caller_builder.Spec){
 				ec.Report.Error (516, loc, "Constructor `{0}' cannot call itself",
 					caller_builder.GetSignatureForError ());
 			}
 						
 			return this;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="356" nfragments="3">
<clone_fragment endline="207" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" hamdist="0" pcid="9705" startline="150"><![CDATA[
 
     Private Function AddInitializeComponentCall(ByVal Ctor As ConstructorDeclaration) As Boolean
         Dim result As Boolean = True
 
         'If the class has the Microsoft.VisualBasic.CompilerServices.DesignerGeneratedAttribute, we call InitializeComponent.
         'InitializeComponent must be correctly spelled (case-sensitive), have no parameters (not even optional) and must be private
         Dim attribs As Generic.List(Of Attribute)
         attribs = Me.CustomAttributes.FindAttributes(Compiler.TypeCache.MS_VB_CS_DesignerGeneratedAttribute)
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return result
 
         Dim methods As Generic.List(Of INameable)
 
         methods = Members.Index.Item("InitializeComponent")
 
         If methods Is Nothing OrElse methods.Count = 0 Then Return result
 
         methods = New Generic.List(Of INameable)(methods)
 
         For i As Integer = methods.Count - 1 To 0 Step -1
             Dim subD As SubDeclaration
             subD = TryCast(methods(i), SubDeclaration)
             If subD Is Nothing Then
                 methods.RemoveAt(i)
                 Continue For
             End If
 
             If subD.Signature.ReturnType IsNot Nothing AndAlso Helper.CompareType(subD.Signature.ReturnType, Compiler.TypeCache.System_Void) = False Then
                 methods.RemoveAt(i)
                 Continue For
             End If
 
             If subD.Signature.Parameters.Count <> 0 Then
                 methods.RemoveAt(i)
                 Continue For
             End If
 
             If subD.Modifiers.Is(ModifierMasks.Private) = False Then
                 methods.RemoveAt(i)
                 Continue For
             End If
         Next
 
         If methods.Count = 0 Then Return result
 
         If methods.Count > 1 Then
             'Huh?
             Helper.StopIfDebugging(True)
         Else
             Dim callStmt As New CallStatement(Me)
             Dim sExp As New SimpleNameExpression(callStmt)
             sExp.Init(New Identifier(Me, "InitializeComponent", Me.Location, TypeCharacters.Characters.None), Nothing)
             callStmt.Init(sExp)
             Ctor.Code.AddStatement(callStmt)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1563" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="12" pcid="7635" startline="1504"><![CDATA[
 
     Shared Function ApplyTypeArguments(ByVal Parent As ParsedObject, ByVal OpenType As Mono.Cecil.TypeReference, ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = Nothing
 
         If OpenType Is Nothing Then Return Nothing
 
         Helper.Assert(TypeParameters IsNot Nothing AndAlso TypeArguments IsNot Nothing)
         Helper.Assert(TypeParameters.Count = TypeArguments.Count)
 
         If CecilHelper.IsGenericParameter(OpenType) Then
             For i As Integer = 0 To TypeParameters.Count - 1
                 If Helper.CompareName(TypeParameters(i).Name, OpenType.Name) Then
                     result = TypeArguments(i)
                     Exit For
                 End If
             Next
             Helper.Assert(result IsNot Nothing)
         ElseIf CecilHelper.IsGenericType(OpenType) Then
             Dim typeParams As Mono.Collections.Generic.Collection(Of TypeReference)
             Dim typeArgs As New Mono.Collections.Generic.Collection(Of TypeReference)(Nothing)
 
             typeParams = CecilHelper.GetGenericArguments(OpenType)
 
             For i As Integer = 0 To typeParams.Count - 1
                 For j As Integer = 0 To TypeParameters.Count - 1
                     If Helper.CompareName(typeParams(i).Name, TypeParameters(j).Name) Then
                         typeArgs.Add(TypeArguments(j))
                         Exit For
                     End If
                 Next
                 If typeArgs.Count - 1 < i Then typeArgs.Add(typeParams(i))
             Next
 
             Helper.Assert(typeArgs.Count = typeParams.Count AndAlso typeArgs.Count > 0)
 
             result = Parent.Compiler.TypeManager.MakeGenericType(Parent, OpenType, typeArgs)
         ElseIf CecilHelper.IsGenericTypeDefinition(OpenType) Then
             Parent.Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
         ElseIf CecilHelper.ContainsGenericParameters(OpenType) Then
             If CecilHelper.IsArray(OpenType) Then
                 Dim elementType As Mono.Cecil.TypeReference
                 elementType = CecilHelper.GetElementType(OpenType)
                 elementType = ApplyTypeArguments(Parent, elementType, TypeParameters, TypeArguments)
                 result = New Mono.Cecil.ArrayType(elementType, CecilHelper.GetArrayRank(OpenType))
             ElseIf CecilHelper.IsByRef(OpenType) Then
                 Dim elementType As Mono.Cecil.TypeReference
                 elementType = CecilHelper.GetElementType(OpenType)
                 elementType = ApplyTypeArguments(Parent, elementType, TypeParameters, TypeArguments)
                 result = Parent.Compiler.TypeManager.MakeByRefType(Parent, elementType)
             Else
                 Parent.Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         Else
             result = OpenType
         End If
 
         Helper.Assert(result IsNot Nothing)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="723" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CecilHelper.vb" hamdist="11" pcid="7339" startline="648"><![CDATA[
 
     Public Shared Function MakeEmittable(ByVal Method As MethodReference) As MethodReference
         Dim result As MethodReference
         Dim genM As GenericInstanceMethod = TryCast(Method, GenericInstanceMethod)
         Dim tG As GenericInstanceType = TryCast(Method.DeclaringType, GenericInstanceType)
 
         If genM Is Nothing AndAlso tG Is Nothing Then
             If Method.DeclaringType.GenericParameters.Count > 0 Then
                 tG = New GenericInstanceType(Method.DeclaringType)
                 For i As Integer = 0 To Method.DeclaringType.GenericParameters.Count - 1
                     tG.GenericArguments.Add(Method.DeclaringType.GenericParameters(i))
                 Next
 
                 Dim mR As New Mono.Cecil.MethodReference(Method.Name, tG, Method.ReturnType, Method.HasThis, Method.ExplicitThis, Method.CallingConvention)
                 For i As Integer = 0 To Method.Parameters.Count - 1
                     Dim param As Mono.Cecil.ParameterDefinition
                     param = New Mono.Cecil.ParameterDefinition(Method.Parameters(i).ParameterType)
                     mR.Parameters.Add(param)
                 Next
                 Return mR
             End If
         End If
 
         Dim mD As MethodDefinition = FindDefinition(Method)
 
         If mD Is Nothing Then
             If TypeOf Method.DeclaringType Is ArrayType Then
                 Dim arrayType As TypeReference
                 arrayType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.DeclaringType)
                 result = New MethodReference(Method.Name, Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.DeclaringType), Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.ReturnType), Method.HasThis, Method.ExplicitThis, Method.CallingConvention)
                 For i As Integer = 0 To Method.Parameters.Count - 1
                     Dim pType As Mono.Cecil.TypeReference
                     pType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.Parameters(i).ParameterType)
                     If pType Is Method.Parameters(i).ParameterType Then
                         result.Parameters.Add(Method.Parameters(i))
                     Else
                         result.Parameters.Add(New ParameterDefinition(pType))
                     End If
                 Next
                 Return result
             End If
             Helper.Assert(mD IsNot Nothing)
             Return Nothing
         End If
 
         If mD Is Method AndAlso mD.DeclaringType.Module Is Compiler.CurrentCompiler.ModuleBuilderCecil Then
             Return mD
         End If
 
         If genM IsNot Nothing Then
             Dim gimResult As New GenericInstanceMethod(Helper.GetMethodOrMethodReference(BaseObject.m_Compiler, mD))
             gimResult.OriginalMethod = mD
             gimResult.ReturnType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, mD.ReturnType)
             For i As Integer = 0 To genM.GenericArguments.Count - 1
                 gimResult.GenericArguments.Add(Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, genM.GenericArguments(i)))
             Next
             Return gimResult
         End If
 
         result = New MethodReference(Method.Name, Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.DeclaringType), Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, mD.ReturnType), Method.HasThis, Method.ExplicitThis, Method.CallingConvention)
         For i As Integer = 0 To mD.Parameters.Count - 1
             Dim pType As Mono.Cecil.TypeReference
             pType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, mD.Parameters(i).ParameterType)
             If pType Is mD.Parameters(i).ParameterType Then
                 result.Parameters.Add(mD.Parameters(i))
             Else
                 result.Parameters.Add(New ParameterDefinition(pType))
             End If
         Next
         If mD.GenericParameters IsNot Nothing AndAlso mD.GenericParameters.Count > 0 Then
             For i As Integer = 0 To mD.GenericParameters.Count - 1
                 result.GenericParameters.Add(mD.GenericParameters(i))
             Next
         End If
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="357" nfragments="2">
<clone_fragment endline="561" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="0" pcid="557" startline="532"><![CDATA[
 
 		public FieldInfo[] GetFields(BindingFlags bindingAttr)
 		{
 			List<FieldInfo> list = new List<FieldInfo>();
 			CheckBaked();
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (BindingFlagsMatch(field.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(field);
 				}
 			}
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (BindingFlagsMatch(field.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(field);
 				}
 			}
 			if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 			{
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (FieldInfo field in type.__GetDeclaredFields())
 					{
 						if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
 							&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
 						{
 							list.Add(field);
 						}
 					}
 					foreach (FieldInfo field in type.__GetDeclaredFields())
 					{
 						if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
 							&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
 						{
 							list.Add(field);
 						}
 					}
 				}
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (FieldInfo field in type.__GetDeclaredFields())
 					{
 						if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
 							&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
 						{
 							list.Add(field);
 						}
 					}
 				}
 			}
 			return list.ToArray();
 		}
]]></clone_fragment>
<clone_fragment endline="620" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="10" pcid="563" startline="585"><![CDATA[
 
 		public MethodInfo[] GetMethods(BindingFlags bindingAttr)
 		{
 			CheckBaked();
 			List<MethodInfo> list = new List<MethodInfo>();
 			foreach (MethodBase mb in __GetDeclaredMethods())
 			{
 				MethodInfo mi = mb as MethodInfo;
 				if (mi != null
 					&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(mi);
 				}
 			}
 			foreach (MethodBase mb in __GetDeclaredMethods())
 			{
 				MethodInfo mi = mb as MethodInfo;
 				if (mi != null
 					&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(mi);
 				}
 			}
 			if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 			{
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (MethodBase mb in type.__GetDeclaredMethods())
 					{
 						MethodInfo mi = mb as MethodInfo;
 						if (mi != null
 							&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
 							&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 							&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
 							&& !FindMethod(list, mi))
 						{
 							list.Add(mi);
 						}
 					}
 					foreach (MethodBase mb in type.__GetDeclaredMethods())
 					{
 						MethodInfo mi = mb as MethodInfo;
 						if (mi != null
 							&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
 							&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 							&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
 							&& !FindMethod(list, mi))
 						{
 							list.Add(mi);
 						}
 					}
 				}
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (MethodBase mb in type.__GetDeclaredMethods())
 					{
 						MethodInfo mi = mb as MethodInfo;
 						if (mi != null
 							&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
 							&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 							&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
 							&& !FindMethod(list, mi))
 						{
 							list.Add(mi);
 						}
 					}
 				}
 			}
 			return list.ToArray();
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="358" nfragments="2">
<clone_fragment endline="533" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" hamdist="0" pcid="3891" startline="477"><![CDATA[
 
 		static public DSA FromCapiPublicKeyBlobDSA (byte[] blob, int offset)
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			try {
 				if ((blob [offset] != 0x06) ||				// PUBLICKEYBLOB (0x06)
 				    (blob [offset + 1] != 0x02) ||			// Version (0x02)
 				    (blob [offset + 2] != 0x00) ||			// Reserved (word)
 				    (blob [offset + 3] != 0x00) ||
 				    (ToUInt32LE (blob, offset + 8) != 0x31535344))	// DWORD magic
 					throw new CryptographicException ("Invalid blob header");
 
 				int bitlen = ToInt32LE (blob, offset + 12);
 				DSAParameters dsap = new DSAParameters ();
 				int bytelen = bitlen >> 3;
 				int pos = offset + 16;
 
 				dsap.P = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.P, 0, bytelen);
 				Array.Reverse (dsap.P);
 				pos += bytelen;
 
 				dsap.Q = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Q, 0, 20);
 				Array.Reverse (dsap.Q);
 				pos += 20;
 
 				dsap.G = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.G, 0, bytelen);
 				Array.Reverse (dsap.G);
 				pos += bytelen;
 
 				dsap.Y = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.Y, 0, bytelen);
 				Array.Reverse (dsap.Y);
 				pos += bytelen;
 
 				dsap.Counter = ToInt32LE (blob, pos);
 				pos += 4;
 
 				dsap.Seed = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Seed, 0, 20);
 				Array.Reverse (dsap.Seed);
 				pos += 20;
 
 				DSA dsa = (DSA)DSA.Create ();
 				dsa.ImportParameters (dsap);
 				return dsa;
 			}
 			catch (Exception e) {
 				throw new CryptographicException ("Invalid blob.", e);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="280" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" hamdist="5" pcid="3883" startline="201"><![CDATA[
 
 		static public DSA FromCapiPrivateKeyBlobDSA (byte[] blob, int offset)
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			DSAParameters dsap = new DSAParameters ();
 			try {
 				if ((blob [offset] != 0x07) ||				// PRIVATEKEYBLOB (0x07)
 				    (blob [offset + 1] != 0x02) ||			// Version (0x02)
 				    (blob [offset + 2] != 0x00) ||			// Reserved (word)
 				    (blob [offset + 3] != 0x00) ||
 				    (ToUInt32LE (blob, offset + 8) != 0x32535344))	// DWORD magic
 					throw new CryptographicException ("Invalid blob header");
 
 				int bitlen = ToInt32LE (blob, offset + 12);
 				int bytelen = bitlen >> 3;
 				int pos = offset + 16;
 
 				dsap.P = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.P, 0, bytelen);
 				Array.Reverse (dsap.P);
 				pos += bytelen;
 
 				dsap.Q = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Q, 0, 20);
 				Array.Reverse (dsap.Q);
 				pos += 20;
 
 				dsap.G = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.G, 0, bytelen);
 				Array.Reverse (dsap.G);
 				pos += bytelen;
 
 				dsap.X = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.X, 0, 20);
 				Array.Reverse (dsap.X);
 				pos += 20;
 
 				dsap.Counter = ToInt32LE (blob, pos);
 				pos += 4;
 
 				dsap.Seed = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Seed, 0, 20);
 				Array.Reverse (dsap.Seed);
 				pos += 20;
 			}
 			catch (Exception e) {
 				throw new CryptographicException ("Invalid blob.", e);
 			}
 
 #if NET_2_1
 			DSA dsa = (DSA)DSA.Create ();
 			dsa.ImportParameters (dsap);
 #else
 			DSA dsa = null;
 			try {
 				dsa = (DSA)DSA.Create ();
 				dsa.ImportParameters (dsap);
 			}
 			catch (CryptographicException ce) {
 				// this may cause problem when this code is run under
 				// the SYSTEM identity on Windows (e.g. ASP.NET). See
 				// http
 				try {
 					CspParameters csp = new CspParameters ();
 					csp.Flags = CspProviderFlags.UseMachineKeyStore;
 					dsa = new DSACryptoServiceProvider (csp);
 					dsa.ImportParameters (dsap);
 				}
 				catch {
 					// rethrow original, not the later, exception if this fails
 					throw ce;
 				}
 			}
 #endif
 			return dsa;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="359" nfragments="3">
<clone_fragment endline="200" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\VariableDeclaration.vb" hamdist="0" pcid="8845" startline="144"><![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         If m_VariableInitializer IsNot Nothing Then result = m_VariableInitializer.ResolveTypeReferences() AndAlso result
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         If m_VariableType Is Nothing Then 'the declaration might have been created with the type already.
             If m_TypeName IsNot Nothing Then
                 m_VariableType = m_TypeName.ResolvedType
 
                 If m_IsNew Then
                     If m_TypeName.IsNonArrayTypeName = False Then
                         result = Helper.AddError(Me) AndAlso result
                     End If
                     m_NewExpression = New DelegateOrObjectCreationExpression(Me, m_TypeName.AsNonArrayTypeName, m_ArgumentList)
                 End If
             ElseIf m_VariableIdentifier.Identifier.HasTypeCharacter Then
                 m_VariableType = TypeCharacters.TypeCharacterToType(Compiler, m_VariableIdentifier.Identifier.TypeCharacter)
             Else
                 If Me.Location.File(Compiler).IsOptionStrictOn Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30209, Me.Location) AndAlso result
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC42020, Me.Location) AndAlso result
                 End If
                 m_VariableType = Compiler.TypeCache.System_Object
             End If
         End If
 
         If m_VariableIdentifier IsNot Nothing AndAlso m_VariableIdentifier.HasArrayNameModifier Then
             If CecilHelper.IsArray(m_VariableType) Then
                 result = Helper.AddError(Me, "Cannot specify array modifier on both type name and on variable name.") AndAlso result
             Else
                 If m_VariableIdentifier.ArrayNameModifier.IsArraySizeInitializationModifier Then
                     m_VariableType = m_VariableIdentifier.ArrayNameModifier.AsArraySizeInitializationModifier.CreateArrayType(m_VariableType)
                 ElseIf m_VariableIdentifier.ArrayNameModifier.IsArrayTypeModifiers Then
                     m_VariableType = m_VariableIdentifier.ArrayNameModifier.AsArrayTypeModifiers.CreateArrayType(m_VariableType)
                 Else
                     Throw New InternalException(Me)
                 End If
             End If
         End If
 
         If m_NewExpression IsNot Nothing Then result = m_NewExpression.ResolveTypeReferences AndAlso result
 
         'Helper.Assert(m_FieldType IsNot Nothing)
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="219" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\InvocationOrIndexExpression.vb" hamdist="6" pcid="7099" startline="141"><![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_AscWExpression IsNot Nothing Then
             result = m_AscWExpression.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Char)) AndAlso result
          
             Return result
         End If
 
         If m_InvocationMethod IsNot Nothing Then
             result = Helper.EmitArgumentsAndCallOrCallVirt(Info, m_Expression, m_ArgumentList, m_InvocationMethod) AndAlso result
             Return True
         End If
 
         If m_IsLateBoundArray Then
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             Return True
         End If
 
         If Classification.IsLateBoundClassification Then
             result = LateBoundAccessToExpression.EmitLateCall(Info, Classification.AsLateBoundAccess) AndAlso result
         Else
             Select Case m_Expression.Classification.Classification
                 Case ExpressionClassification.Classifications.MethodGroup
                     With m_Expression.Classification.AsMethodGroupClassification
                         result = Helper.EmitArgumentsAndCallOrCallVirt(Info, .InstanceExpression, m_ArgumentList, .ResolvedMethod)
                     End With
                 Case ExpressionClassification.Classifications.Value
                     If Info.IsRHS Then
                         If Me.Classification.IsVariableClassification Then
                             result = Me.Classification.GenerateCode(Info) AndAlso result
                         ElseIf Me.Classification.IsPropertyAccessClassification Then
                             result = Me.Classification.AsPropertyAccess.GenerateCode(Info) AndAlso result
                         Else
                             result = m_Expression.GenerateCode(Info) AndAlso result
                         End If
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                 Case ExpressionClassification.Classifications.PropertyAccess
                     If Info.IsRHS Then
                         If Me.Classification.IsVariableClassification Then
                             result = Me.Classification.GenerateCode(Info) AndAlso result
                         Else
                             result = m_Expression.GenerateCode(Info) AndAlso result
                         End If
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                 Case ExpressionClassification.Classifications.PropertyGroup
                     'Helper.NotImplemented()
                     Dim pgC As PropertyGroupClassification
                     pgC = m_Expression.Classification.AsPropertyGroup
                     result = pgC.GenerateCodeAsValue(Info) AndAlso result
                 Case ExpressionClassification.Classifications.Variable
                     If Info.IsRHS Then
                         If Classification.IsValueClassification Then
                             result = Classification.AsValueClassification.GenerateCode(Info) AndAlso result
                         ElseIf Classification.IsPropertyGroupClassification Then
                             result = Classification.AsPropertyGroup.GenerateCodeAsValue(Info) AndAlso result
                         ElseIf Classification.IsPropertyAccessClassification Then
                             result = Classification.AsPropertyAccess.GenerateCode(Info) AndAlso result
                         Else
                             result = Classification.AsVariableClassification.GenerateCodeAsValue(Info) AndAlso result
                         End If
                     Else
                         result = Classification.GenerateCode(Info) AndAlso result
                     End If
                 Case ExpressionClassification.Classifications.LateBoundAccess
                     result = LateBoundAccessToExpression.EmitLateCall(Info, Classification.AsLateBoundAccess) AndAlso result
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="137" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\IfExpression.vb" hamdist="12" pcid="7085" startline="46"><![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Condition.ResolveExpression(Info) AndAlso result
         result = SecondPart.ResolveExpression(Info) AndAlso result
 
         If ThirdPart IsNot Nothing Then
             result = ThirdPart.ResolveExpression(Info) AndAlso result
         End If
 
         If Not result Then Return result
 
         If ThirdPart IsNot Nothing Then
             If Compiler.TypeResolution.IsImplicitlyConvertible(Me, Condition.ExpressionType, Compiler.TypeCache.System_Boolean) = False AndAlso Location.File(Compiler).IsOptionStrictOn Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30512, Condition.Location, Condition.ExpressionType.Name, Compiler.TypeCache.System_Boolean.Name) AndAlso result
             Else
                 Condition = Helper.CreateTypeConversion(Me, Condition, Compiler.TypeCache.System_Boolean, result)
             End If
 
             If Helper.CompareType(SecondPart.ExpressionType, ThirdPart.ExpressionType) = False Then
                 If Compiler.TypeResolution.IsImplicitlyConvertible(Me, SecondPart.ExpressionType, ThirdPart.ExpressionType) Then
                     m_ExpressionType = ThirdPart.ExpressionType
                     SecondPart = Helper.CreateTypeConversion(Me, SecondPart, m_ExpressionType, result)
                 ElseIf Compiler.TypeResolution.IsImplicitlyConvertible(Me, ThirdPart.ExpressionType, SecondPart.ExpressionType) Then
                     m_ExpressionType = SecondPart.ExpressionType
                     ThirdPart = Helper.CreateTypeConversion(Me, ThirdPart, m_ExpressionType, result)
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC33106, Me.Location) AndAlso result
                 End If
             Else
                 m_ExpressionType = SecondPart.ExpressionType
             End If
 
             If Condition.IsConstant AndAlso SecondPart.IsConstant AndAlso ThirdPart.IsConstant Then
                 m_ConstantValue = If(CBool(Condition.ConstantValue), SecondPart.ConstantValue, ThirdPart.ConstantValue)
                 'We checked that the conversion is possible above
                 result = TypeConverter.ConvertTo(Me, m_ConstantValue, m_ExpressionType, m_ConstantValue) AndAlso result
             End If
         Else
             If Condition.ExpressionType.IsValueType AndAlso CecilHelper.IsNullable(Condition.ExpressionType) = False Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC33107, Condition.Location) AndAlso result
             End If
 
             If TypeOf SecondPart Is NothingConstantExpression Then
                 If TypeOf Condition Is NothingConstantExpression Then
                     m_ConstantValue = Nothing
                     m_ExpressionType = Compiler.TypeCache.System_Object
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC30512, Condition.Location, Condition.ExpressionType.Name, "Integer")
                 End If
             ElseIf TypeOf Condition Is NothingConstantExpression Then
                 If Helper.CompareType(SecondPart.ExpressionType, Compiler.TypeCache.System_Int32) Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC33110, Me.Location)
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC30512, Condition.Location, SecondPart.ExpressionType.Name, "Integer")
                 End If
             Else
                 If Helper.CompareType(SecondPart.ExpressionType, Condition.ExpressionType) = False Then
                     Dim condType As TypeReference = Condition.ExpressionType
 
                     If CecilHelper.IsNullable(Condition.ExpressionType) AndAlso Not CecilHelper.IsNullable(SecondPart.ExpressionType) Then
                         condType = CecilHelper.GetNulledType(condType)
                     End If
 
                     If Compiler.TypeResolution.IsImplicitlyConvertible(Me, SecondPart.ExpressionType, condType) Then
                         m_ExpressionType = condType
                         SecondPart = Helper.CreateTypeConversion(Me, SecondPart, m_ExpressionType, result)
                     ElseIf Compiler.TypeResolution.IsImplicitlyConvertible(Me, condType, SecondPart.ExpressionType) Then
                         m_ExpressionType = SecondPart.ExpressionType
                     Else
                         result = Compiler.Report.ShowMessage(Messages.VBNC33110, Me.Location) AndAlso result
                     End If
                 Else
                     m_ExpressionType = SecondPart.ExpressionType
                 End If
 
                 If Condition.IsConstant AndAlso SecondPart.IsConstant Then
                     m_ConstantValue = If(Condition.ConstantValue, SecondPart.ConstantValue)
                     'We checked that the conversion is possible above
                     result = TypeConverter.ConvertTo(Me, m_ConstantValue, m_ExpressionType, m_ConstantValue) AndAlso result
                 End If
             End If
         End If
 
         If result Then
             Me.Classification = New ValueClassification(Me, Me)
         End If
 
         Return result
     End Function
]]></clone_fragment>
</clone_group>
<clone_group groupid="360" nfragments="2">
<clone_fragment endline="809" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="0" pcid="579" startline="779"><![CDATA[
 
 		public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
 		{
 			List<PropertyInfo> list = new List<PropertyInfo>();
 			Type type = this;
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return list.ToArray();
 		}
]]></clone_fragment>
<clone_fragment endline="509" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="3" pcid="553" startline="479"><![CDATA[
 
 		public EventInfo[] GetEvents(BindingFlags bindingAttr)
 		{
 			List<EventInfo> list = new List<EventInfo>();
 			Type type = this;
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return list.ToArray();
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="361" nfragments="2">
<clone_fragment endline="242" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" hamdist="0" pcid="175" startline="209"><![CDATA[
 
 		//
 		// For cases where we need to union cache members
 		//
 		public void AddBaseType (TypeSpec baseType)
 		{
 			var cache = baseType.MemberCache;
 
 			IList<MemberSpec> list;
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (list is MemberSpec[]) {
 						list = new List<MemberSpec> () { list [0] };
 						member_hash[entry.Key] = list;
 					}
 
 					list.Add (ce);
 				}
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (list is MemberSpec[]) {
 						list = new List<MemberSpec> () { list [0] };
 						member_hash[entry.Key] = list;
 					}
 
 					list.Add (ce);
 				}
 			}
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (list is MemberSpec[]) {
 						list = new List<MemberSpec> () { list [0] };
 						member_hash[entry.Key] = list;
 					}
 
 					list.Add (ce);
 				}
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="280" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" hamdist="10" pcid="177" startline="243"><![CDATA[
 
 		//
 		// Member-cache does not contain base members but it does
 		// contain all base interface members, so the Lookup code
 		// can use simple inheritance rules.
 		//
 		public void AddInterface (TypeSpec iface)
 		{
 			var cache = iface.MemberCache;
 
 			IList<MemberSpec> list;
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (AddInterfaceMember (ce, ref list))
 						member_hash[entry.Key] = list;
 				}
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (AddInterfaceMember (ce, ref list))
 						member_hash[entry.Key] = list;
 				}
 			}
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (AddInterfaceMember (ce, ref list))
 						member_hash[entry.Key] = list;
 				}
 			}
 
 			// Add also all base interfaces
 			if (iface.Interfaces != null) {
 				foreach (var base_iface in iface.Interfaces)
 					AddInterface (base_iface);
 				foreach (var base_iface in iface.Interfaces)
 					AddInterface (base_iface);
 			}
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="362" nfragments="3">
<clone_fragment endline="7292" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="0" pcid="4955" startline="7220"><![CDATA[
 	}
 
 	class TypeOfMethod 
 	{
 		public TypeOfMethod (MethodSpec method, Location loc)
 			
 		{
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (member.IsConstructor) {
 				type = ec.Module.PredefinedTypes.ConstructorInfo.Resolve (loc);
 			} else {
 				type = ec.Module.PredefinedTypes.MethodInfo.Resolve (loc);
 			}
 
 			if (type == null)
 				return null;
 
 			return base.DoResolve (ec);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldtoken, member);
 
 			base.Emit (ec);
 			ec.Emit (OpCodes.Castclass, type);
 		}
 
 		protected override string GetMethodName {
 			get { return "GetMethodFromHandle"; }
 		}
 
 		protected override PredefinedType GetDeclaringType (PredefinedTypes types)
 		{
 			return types.MethodBase;
 		}
 
 		protected override PredefinedType GetRuntimeHandle (PredefinedTypes types)
 		{
 			return types.RuntimeMethodHandle;
 		}
 
 		protected override MethodSpec TypeFromHandle {
 			get {
 				return TypeManager.methodbase_get_type_from_handle;
 			}
 			set {
 				TypeManager.methodbase_get_type_from_handle = value;
 			}
 		}
 
 		protected override MethodSpec TypeFromHandleGeneric {
 			get {
 				return TypeManager.methodbase_get_type_from_handle_generic;
 			}
 			set {
 				TypeManager.methodbase_get_type_from_handle_generic = value;
 			}
 		}
 	}
 
 	abstract class TypeOfMember<T> 
 	{
 		protected readonly T member;
 
 		protected TypeOfMember (T member, Location loc)
 		{
 			this.member = member;
 			this.loc = loc;
 		}
]]></clone_fragment>
<clone_fragment endline="1958" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" hamdist="10" pcid="5381" startline="1886"><![CDATA[
 		}
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly MethodInfo method;
 			private readonly Type type;
 			private readonly int pos;
 
 			internal ParameterInfoImpl(MethodInfo method, Type type, int pos)
 			{
 				this.method = method;
 				this.type = type;
 				this.pos = pos;
 			}
 
 			public override Type ParameterType
 			{
 				get { return type; }
 			}
 
 			public override string Name
 			{
 				get { return null; }
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get { return ParameterAttributes.None; }
 			}
 
 			public override int Position
 			{
 				get { return pos; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get { return null; }
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return Empty<Type>.Array;
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return Empty<Type>.Array;
 			}
 
 			public override MemberInfo Member
 			{
 				get { return method.IsConstructor ? (MethodBase)new ConstructorInfoImpl(method) 
 			}
 
 			public override int MetadataToken
 			{
 				get { return 0x8000000; }
 			}
 
 			internal override Module Module
 			{
 				get { return method.Module; }
 			}
 		}
 	}
 
 	sealed class ByRefType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new ByRefType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]></clone_fragment>
<clone_fragment endline="116" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertyInfo.cs" hamdist="8" pcid="2989" startline="33"><![CDATA[
 		}
 
 		public abstract PropertyAttributes Attributes { get; }
 		public abstract bool CanRead { get; }
 		public abstract bool CanWrite { get; }
 		public abstract MethodInfo GetGetMethod(bool nonPublic);
 		public abstract MethodInfo GetSetMethod(bool nonPublic);
 		public abstract MethodInfo[] GetAccessors(bool nonPublic);
 		public abstract object GetRawConstantValue();
 		internal abstract bool IsPublic { get; }
 		internal abstract bool IsStatic { get; }
 		internal abstract PropertySignature PropertySignature { get; }
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly PropertyInfo property;
 			private readonly int parameter;
 
 			internal ParameterInfoImpl(PropertyInfo property, int parameter)
 			{
 				this.property = property;
 				this.parameter = parameter;
 			}
 
 			public override string Name
 			{
 				get { return null; }
 			}
 
 			public override Type ParameterType
 			{
 				get { return property.PropertySignature.GetParameter(parameter); }
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get { return ParameterAttributes.None; }
 			}
 
 			public override int Position
 			{
 				get { return parameter; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return property.PropertySignature.GetOptionalCustomModifiers(parameter);
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return property.PropertySignature.GetRequiredCustomModifiers(parameter);
 			}
 
 			public override MemberInfo Member
 			{
 				get { return property; }
 			}
 
 			public override int MetadataToken
 			{
 				get { return 0x08000000; }
 			}
 
 			internal override Module Module
 			{
 				get { return property.Module; }
 			}
 		}
 
 		public ParameterInfo[] GetIndexParameters()
 		{
 			ParameterInfo[] parameters = new ParameterInfo[this.PropertySignature.ParameterCount];
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			return parameters;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="363" nfragments="2">
<clone_fragment endline="155" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\BinarySubExpression.vb" hamdist="0" pcid="6599" startline="70"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim rvalue, lvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing Or rvalue Is Nothing Then
                 Return Nothing
             Else
 
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 Dim csmallest As TypeCode
                 csmallest = vbnc.TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, tlvalue, trvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         If CByte(lvalue) < CByte(rvalue) Then
                             Return CSByte(lvalue) - CSByte(rvalue)
                         Else
                             Return CByte(lvalue) - CByte(rvalue)
                         End If
                     Case TypeCode.SByte
                         Dim tmp As Short = CShort(lvalue) - CShort(rvalue)
                         If tmp < SByte.MinValue OrElse tmp > SByte.MaxValue Then
                             Return tmp
                         Else
                             Return CSByte(tmp)
                         End If
                     Case TypeCode.Int16
                         Dim tmp As Integer = CInt(lvalue) - CInt(rvalue)
                         If tmp > Short.MaxValue OrElse tmp < Short.MinValue Then
                             Return tmp
                         Else
                             Return CShort(tmp)
                         End If
                     Case TypeCode.UInt16
                         If CUShort(lvalue) < CUShort(rvalue) Then
                             Return CShort(lvalue) - CShort(rvalue)
                         Else
                             Return CUShort(lvalue) - CUShort(rvalue)
                         End If
                     Case TypeCode.Int32
                         Dim tmp As Long = CLng(lvalue) - CLng(rvalue)
                         If tmp > Integer.MaxValue OrElse tmp < Integer.MinValue Then
                             Return tmp
                         Else
                             Return CInt(tmp)
                         End If
                     Case TypeCode.UInt32
                         If CUInt(lvalue) < CUInt(rvalue) Then
                             Return CInt(lvalue) - CInt(rvalue)
                         Else
                             Return CUInt(lvalue) - CUInt(rvalue)
                         End If
                     Case TypeCode.Int64
                         Dim tmp As Double = CLng(lvalue) - CLng(rvalue)
                         If tmp < Long.MinValue OrElse tmp > Long.MaxValue Then
                             Return tmp
                         Else
                             Return CLng(tmp)
                         End If
                     Case TypeCode.UInt64
                         If CULng(lvalue) < CULng(rvalue) Then
                             Return CLng(lvalue) - CLng(rvalue)
                         Else
                             Return CULng(lvalue) - CULng(rvalue)
                         End If
                     Case TypeCode.Double
                         Return CDbl(lvalue) - CDbl(rvalue) 'No overflow possible
                     Case TypeCode.Single
                         Return CSng(lvalue) - CSng(rvalue) 'No overflow possible
                     Case TypeCode.Decimal
                         Return CDec(lvalue) - CDec(rvalue)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></clone_fragment>
<clone_fragment endline="156" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Expressions\BinaryExpressions\MultExpression.vb" hamdist="8" pcid="6659" startline="64"><![CDATA[
     End Property
 
     Public Overrides ReadOnly Property ConstantValue() As Object
         Get
             Dim lvalue, rvalue As Object
             lvalue = m_LeftExpression.ConstantValue
             rvalue = m_RightExpression.ConstantValue
             If lvalue Is Nothing OrElse rvalue Is Nothing Then
                 Return Nothing
             Else
                 Dim tlvalue, trvalue As Mono.Cecil.TypeReference
                 Dim clvalue, crvalue As TypeCode
                 tlvalue = CecilHelper.GetType(Compiler, lvalue)
                 clvalue = Helper.GetTypeCode(Compiler, tlvalue)
                 trvalue = CecilHelper.GetType(Compiler, rvalue)
                 crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
                 Dim csmallest As TypeCode
                 csmallest = TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, tlvalue, trvalue)
 
                 Select Case csmallest
                     Case TypeCode.Byte
                         Dim tmp As UShort = CUShort(lvalue) * CUShort(rvalue)
                         If tmp < Byte.MinValue OrElse tmp > Byte.MaxValue Then
                             Return tmp
                         Else
                             Return CByte(lvalue) * CByte(rvalue)
                         End If
                     Case TypeCode.SByte
                         Dim tmp As Short = CShort(lvalue) * CShort(rvalue)
                         If tmp < SByte.MinValue OrElse tmp > SByte.MaxValue Then
                             Return tmp
                         Else
                             Return CSByte(lvalue) * CSByte(rvalue)
                         End If
                     Case TypeCode.Int16
                         Dim tmp As Integer = CInt(lvalue) * CInt(rvalue)
                         If tmp > Short.MaxValue OrElse tmp < Short.MinValue Then
                             Return tmp
                         Else
                             Return CShort(lvalue) * CShort(rvalue)
                         End If
                     Case TypeCode.UInt16
                         Dim tmp As UInteger = CUInt(lvalue) * CUInt(rvalue)
                         If tmp > UShort.MaxValue Then
                             Return tmp
                         Else
                             Return CUShort(lvalue) * CUShort(rvalue)
                         End If
                     Case TypeCode.Int32
                         Dim tmp As Long = CLng(lvalue) * CLng(rvalue)
                         If tmp > Integer.MaxValue OrElse tmp < Integer.MinValue Then
                             Return tmp
                         Else
                             Return CInt(lvalue) * CInt(rvalue)
                         End If
                     Case TypeCode.UInt32
                         Dim tmp As ULong = CULng(lvalue) * CULng(rvalue)
                         If tmp > UInteger.MaxValue Then
                             Return tmp
                         Else
                             Return CUInt(lvalue) * CUInt(rvalue)
                         End If
                     Case TypeCode.Int64
                         Dim tmp As Double
                         If CLng(rvalue) < 0 Then
                             tmp = Long.MaxValue / -CLng(rvalue)
                         Else
                             tmp = Long.MaxValue / CLng(rvalue)
                         End If
                         If CLng(lvalue) < 0 AndAlso -CLng(lvalue) > tmp OrElse CLng(lvalue) > tmp Then
                             Return CDec(lvalue) * CDec(rvalue)
                         Else
                             Return CLng(lvalue) * CLng(rvalue)
                         End If
                     Case TypeCode.UInt64
                         If CULng(lvalue) > ULong.MaxValue / CULng(rvalue) Then
                             Return CDec(lvalue) * CDec(rvalue)
                         Else
                             Return CULng(lvalue) * CULng(rvalue)
                         End If
                     Case TypeCode.Double
                         Return CDbl(lvalue) * CDbl(rvalue) 'No overflow possible
                     Case TypeCode.Single
                         Return CSng(lvalue) * CSng(rvalue) 'No overflow possible
                     Case TypeCode.Decimal
                         Return CDec(lvalue) * CDec(rvalue)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException(Me)
                 End Select
             End If
         End Get
]]></clone_fragment>
</clone_group>
<clone_group groupid="364" nfragments="85">
<clone_fragment endline="1638" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" hamdist="0" pcid="3979" startline="44"><![CDATA[
 
 		private Driver (CompilerContext ctx)
 		{
 			this.ctx = ctx;
 		}
 
 		public static Driver Create (string[] args, bool require_files, Func<string [], int, int> unknown_option_parser, ReportPrinter printer)
 		{
 			Driver d = new Driver (new CompilerContext (new Report (printer)));
 
 			if (!d.ParseArguments (args, require_files, unknown_option_parser))
 				return null;
 
 			return d;
 		}
 
 		Report Report {
 			get { return ctx.Report; }
 		}
 
 		void ShowTime (string msg)
 		{
 			if (!timestamps)
 				return;
 
 			stopwatch.Stop ();
 
 			Console.WriteLine ("{0,5}ms {1}", stopwatch.ElapsedMilliseconds, msg);
 
 			stopwatch = Stopwatch.StartNew ();
 		}
 
 		void ShowTotalTime (string msg)
 		{
 			if (!timestamps)
 				return;
 
 			DateTime now = DateTime.Now;
 			TimeSpan span = now - first_time;
 
 			Console.WriteLine (
 				"[{0
 				(int) span.TotalSeconds, span.Milliseconds, msg);
 		}	       
 	       
 		void tokenize_file (CompilationUnit file, CompilerContext ctx)
 		{
 			Stream input;
 
 			try {
 				input = File.OpenRead (file.Name);
 			} catch {
 				Report.Error (2001, "Source file `" + file.Name + "' could not be found");
 				return;
 			}
 
 			using (input){
 				SeekableStreamReader reader = new SeekableStreamReader (input, RootContext.Encoding);
 				Tokenizer lexer = new Tokenizer (reader, file, ctx);
 				int token, tokens = 0, errors = 0;
 
 				while ((token = lexer.token ()) != Token.EOF){
 					tokens++;
 					if (token == Token.ERROR)
 						errors++;
 				}
 				Console.WriteLine ("Tokenized
 			}
 			
 			return;
 		}
 
 		void Parse (CompilationUnit file, ModuleContainer module)
 		{
 			Stream input;
 
 			try {
 				input = File.OpenRead (file.Name);
 			} catch {
 				Report.Error (2001, "Source file `{0}' could not be found", file.Name);
 				return;
 			}
 
 			// Check 'MZ' header
 			if (input.ReadByte () == 77 && input.ReadByte () == 90) {
 				Report.Error (2015, "Source file `{0}' is a binary file and not a text file", file.Name);
 				input.Close ();
 				return;
 			}
 
 			input.Position = 0;
 			SeekableStreamReader reader = new SeekableStreamReader (input, RootContext.Encoding);
 
 			Parse (reader, file, module);
 			reader.Dispose ();
 			input.Close ();
 		}	
 		
 		void Parse (SeekableStreamReader reader, CompilationUnit file, ModuleContainer module)
 		{
 			CSharpParser parser = new CSharpParser (reader, file, module);
 			parser.parse ();
 		}
 
 		static void OtherFlags ()
 		{
 			Console.WriteLine (
 				"Other flags in the compiler\n" +
 				"   --fatal[=COUNT]    Makes errors after COUNT fatal\n" +
 				"   --lint             Enhanced warnings\n" +
 				"   --parse            Only parses the source file\n" +
 				"   --runtime
 				"   --stacktrace       Shows stack trace at error location\n" +
 				"   --timestamp        Displays time stamps of various compiler events\n" +
 				"   -v                 Verbose parsing (for debugging the parser)\n" + 
 				"   --mcs-debug X      Sets MCS debugging level to X\n");
 		}
 		
 		static void Usage ()
 		{
 			Console.WriteLine (
 				"Mono C# compiler, Copyright 2001 - 2011 Novell, Inc.\n" +
 				"mcs [options] source-files\n" +
 				"   --about              About the Mono C# compiler\n" +
 				"   -addmodule
 				"   -checked[+|-]        Sets default aritmetic overflow context\n" +
 				"   -clscheck[+|-]       Disables CLS Compliance verifications\n" +
 				"   -codepage
 				"   -define
 				"   -debug[+|-], -g      Generate debugging information\n" + 
 				"   -delaysign[+|-]      Only insert the public key into the assembly (no signing)\n" +
 				"   -doc
 				"   -help                Lists all compiler options (short
 				"   -keycontainer
 				"   -keyfile
 				"   -langversion
 				"   -lib
 				"   -main
 				"   -noconfig            Disables implicitly referenced assemblies\n" +
 				"   -nostdlib[+|-]       Does not reference mscorlib.dll library\n" +
 				"   -nowarn
 				"   -optimize[+|-]       Enables advanced compiler optimizations (short
 				"   -out
 #if !SMCS_SOURCE
 				"   -pkg
 #endif
 				"   -platform
 				"                        ARCH can be one of
 				"   -recurse
 				"   -reference
 				"   -reference
 				"   -sdk
 				"                        VERSION can be one of
 				"   -target
 				"                        KIND can be one of
 				"   -unsafe[+|-]         Allows to compile code which uses unsafe keyword\n" +
 				"   -warnaserror[+|-]    Treats all warnings as errors\n" +
 				"   -warnaserror[+|-]
 				"   -warn
 				"   -helpinternal        Shows internal and advanced compiler options\n" + 
 				"\n" +
 				"Resources
 				"   -linkresource
 				"   -resource
 				"   -win32res
 				"   -win32icon
                                 "   @file                   Read response file for more options\n\n" +
 				"Options can be of the form -option or /option");
 		}
 
 		void TargetUsage ()
 		{
 			Report.Error (2019, "Invalid target type for -target. Valid options are `exe', `winexe', `library' or `module'");
 		}
 		
 		static void About ()
 		{
 			Console.WriteLine (
 				"The Mono C# compiler is Copyright 2001-2011, Novell, Inc.\n\n" +
 				"The compiler source code is released under the terms of the \n"+
 				"MIT X11 or GNU GPL licenses\n\n" +
 
 				"For more information on Mono, visit the project Web site\n" +
 				"   http
 
 				"The compiler was written by Miguel de Icaza, Ravi Pratap, Martin Baulig, Marek Safar, Raja R Harinath, Atushi Enomoto");
 			Environment.Exit (0);
 		}
 
 		public static int Main (string[] args)
 		{
 			Location.InEmacs = Environment.GetEnvironmentVariable ("EMACS") == "t";
 			var crp = new ConsoleReportPrinter ();
 			Driver d = Driver.Create (args, true, null, crp);
 			if (d == null)
 				return 1;
 
 			crp.Fatal = d.fatal_errors;
 
 			if (d.Compile () && d.Report.Errors == 0) {
 				if (d.Report.Warnings > 0) {
 					Console.WriteLine ("Compilation succeeded - {0} warning(s)", d.Report.Warnings);
 				}
 				Environment.Exit (0);
 				return 0;
 			}
 			
 			
 			Console.WriteLine("Compilation failed
 				d.Report.Errors, d.Report.Warnings);
 			Environment.Exit (1);
 			return 1;
 		}
 
 		static string [] LoadArgs (string file)
 		{
 			StreamReader f;
 			var args = new List<string> ();
 			string line;
 			try {
 				f = new StreamReader (file);
 			} catch {
 				return null;
 			}
 
 			StringBuilder sb = new StringBuilder ();
 			
 			while ((line = f.ReadLine ()) != null){
 				int t = line.Length;
 
 				for (int i = 0; i < t; i++){
 					char c = line [i];
 					
 					if (c == '"' || c == '\''){
 						char end = c;
 						
 						for (i++; i < t; i++){
 							c = line [i];
 
 							if (c == end)
 								break;
 							sb.Append (c);
 						}
 					} else if (c == ' '){
 						if (sb.Length > 0){
 							args.Add (sb.ToString ());
 							sb.Length = 0;
 						}
 					} else
 						sb.Append (c);
 				}
 				if (sb.Length > 0){
 					args.Add (sb.ToString ());
 					sb.Length = 0;
 				}
 			}
 
 			return args.ToArray ();
 		}
 
 		//
 		// Given a path specification, splits the path from the file/pattern
 		//
 		static void SplitPathAndPattern (string spec, out string path, out string pattern)
 		{
 			int p = spec.LastIndexOf ('/');
 			if (p != -1){
 				//
 				// Windows does not like /file.cs, switch that to
 				// "\", "file.cs"
 				//
 				if (p == 0){
 					path = "\\";
 					pattern = spec.Substring (1);
 				} else {
 					path = spec.Substring (0, p);
 					pattern = spec.Substring (p + 1);
 				}
 				return;
 			}
 
 			p = spec.LastIndexOf ('\\');
 			if (p != -1){
 				path = spec.Substring (0, p);
 				pattern = spec.Substring (p + 1);
 				return;
 			}
 
 			path = ".";
 			pattern = spec;
 		}
 
 		void AddSourceFile (string f)
 		{
 			if (first_source == null)
 				first_source = f;
 
 			Location.AddFile (Report, f);
 		}
 
 		bool ParseArguments (string[] args, bool require_files, Func<string [], int, int> unknown_option_parser)
 		{
 			List<string> response_file_list = null;
 			bool parsing_options = true;
 
 			for (int i = 0; i < args.Length; i++) {
 				string arg = args [i];
 				if (arg.Length == 0)
 					continue;
 
 				if (arg [0] == '@') {
 					string [] extra_args;
 					string response_file = arg.Substring (1);
 
 					if (response_file_list == null)
 						response_file_list = new List<string> ();
 
 					if (response_file_list.Contains (response_file)) {
 						Report.Error (
 							1515, "Response file `" + response_file +
 							"' specified multiple times");
 						return false;
 					}
 
 					response_file_list.Add (response_file);
 
 					extra_args = LoadArgs (response_file);
 					if (extra_args == null) {
 						Report.Error (2011, "Unable to open response file
 								  response_file);
 						return false;
 					}
 
 					args = AddArgs (args, extra_args);
 					continue;
 				}
 
 				if (parsing_options) {
 					if (arg == "--") {
 						parsing_options = false;
 						continue;
 					}
 
 					if (arg [0] == '-') {
 						if (UnixParseOption (arg, ref args, ref i))
 							continue;
 
 						// Try a -CSCOPTION
 						string csc_opt = "/" + arg.Substring (1);
 						if (CSCParseOption (csc_opt, ref args))
 							continue;
 
 						if (unknown_option_parser != null){
 							var ret = unknown_option_parser (args, i);
 							if (ret != -1){
 								i = ret;
 								return true;
 							}
 						}
 						
 						Error_WrongOption (arg);
 						return false;
 					}
 					if (arg [0] == '/') {
 						if (CSCParseOption (arg, ref args))
 							continue;
 
 						// Need to skip `/home/test.cs' however /test.cs is considered as error
 						if (arg.Length < 2 || arg.IndexOf ('/', 2) == -1) {
 							Error_WrongOption (arg);
 							return false;
 						}
 					}
 				}
 
 				ProcessSourceFiles (arg, false);
 			}
 
 			if (require_files == false)
 				return true;
 					
 			//
 			// If we are an exe, require a source file for the entry point
 			//
 			if (RootContext.Target == Target.Exe || RootContext.Target == Target.WinExe || RootContext.Target == Target.Module) {
 				if (first_source == null) {
 					Report.Error (2008, "No files to compile were specified");
 					return false;
 				}
 
 			}
 
 			//
 			// If there is nothing to put in the assembly, and we are not a library
 			//
 			if (first_source == null && RootContext.Resources == null) {
 				Report.Error (2008, "No files to compile were specified");
 				return false;
 			}
 
 			return true;
 		}
 
 		public void Parse (ModuleContainer module)
 		{
 			Location.Initialize ();
 
 			var cu = Location.SourceFiles;
 			for (int i = 0; i < cu.Count; ++i) {
 				if (RootContext.TokenizeOnly) {
 					tokenize_file (cu [i], ctx);
 				} else {
 					Parse (cu [i], module);
 				}
 			}
 		}
 
 		void ProcessSourceFiles (string spec, bool recurse)
 		{
 			string path, pattern;
 
 			SplitPathAndPattern (spec, out path, out pattern);
 			if (pattern.IndexOf ('*') == -1){
 				AddSourceFile (spec);
 				return;
 			}
 
 			string [] files = null;
 			try {
 				files = Directory.GetFiles (path, pattern);
 			} catch (System.IO.DirectoryNotFoundException) {
 				Report.Error (2001, "Source file `" + spec + "' could not be found");
 				return;
 			} catch (System.IO.IOException){
 				Report.Error (2001, "Source file `" + spec + "' could not be found");
 				return;
 			}
 			foreach (string f in files) {
 				AddSourceFile (f);
 			}
 
 			if (!recurse)
 				return;
 			
 			string [] dirs = null;
 
 			try {
 				dirs = Directory.GetDirectories (path);
 			} catch {
 			}
 			
 			foreach (string d in dirs) {
 					
 				// Don't include path in this string, as each
 				// directory entry already does
 				ProcessSourceFiles (d + "/" + pattern, true);
 			}
 		}
 
 		void SetWarningLevel (string s)
 		{
 			int level = -1;
 
 			try {
 				level = Int32.Parse (s);
 			} catch {
 			}
 			if (level < 0 || level > 4){
 				Report.Error (1900, "Warning level must be in the range 0-4");
 				return;
 			}
 			Report.WarningLevel = level;
 		}
 
 		static void Version ()
 		{
 			string version = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString ();
 			Console.WriteLine ("Mono C# compiler version {0}", version);
 			Environment.Exit (0);
 		}
 		
 		//
 		// Currently handles the Unix-like command line options, but will be
 		// deprecated in favor of the CSCParseOption, which will also handle the
 		// options that start with a dash in the future.
 		//
 		bool UnixParseOption (string arg, ref string [] args, ref int i)
 		{
 			switch (arg){
 			case "-v"
 				CSharpParser.yacc_verbose_flag++;
 				return true;
 
 			case "--version"
 				Version ();
 				return true;
 				
 			case "--parse"
 				RootContext.ParseOnly = true;
 				return true;
 				
 			case "--main"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.MainClass = args [++i];
 				return true;
 				
 			case "--unsafe"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.Unsafe = true;
 				return true;
 				
 			case "/?"
 			case "--help"
 				Usage ();
 				Environment.Exit (0);
 				return true;
 
 			case "--define"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.AddConditional (args [++i]);
 				return true;
 
 			case "--tokenize"
 				RootContext.TokenizeOnly = true;
 				return true;
 				
 			case "-o"
 			case "--output"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.OutputFile = args [++i];
 				return true;
 
 			case "--checked"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.Checked = true;
 				return true;
 				
 			case "--stacktrace"
 				Report.Printer.Stacktrace = true;
 				return true;
 				
 			case "--linkresource"
 			case "--linkres"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Report.Error (5, "Missing argument to --linkres"); 
 					Environment.Exit (1);
 				}
 
 				AddResource (new AssemblyResource (args[++i], args[i]));
 				return true;
 				
 			case "--resource"
 			case "--res"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Report.Error (5, "Missing argument to --resource"); 
 					Environment.Exit (1);
 				}
 
 				AddResource (new AssemblyResource (args[++i], args[i], true));
 				return true;
 				
 			case "--target"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Environment.Exit (1);
 					return true;
 				}
 				
 				string type = args [++i];
 				switch (type){
 				case "library"
 					RootContext.Target = Target.Library;
 					RootContext.TargetExt = ".dll";
 					break;
 					
 				case "exe"
 					RootContext.Target = Target.Exe;
 					break;
 					
 				case "winexe"
 					RootContext.Target = Target.WinExe;
 					break;
 					
 				case "module"
 					RootContext.Target = Target.Module;
 					RootContext.TargetExt = ".dll";
 					break;
 				default
 					TargetUsage ();
 					break;
 				}
 				return true;
 				
 			case "-r"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				
 				string val = args [++i];
 				int idx = val.IndexOf ('=');
 				if (idx > -1) {
 					string alias = val.Substring (0, idx);
 					string assembly = val.Substring (idx + 1);
 					AddAssemblyReference (alias, assembly);
 					return true;
 				}
 
 				AddAssemblyReference (val);
 				return true;
 				
 			case "-L"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();	
 					Environment.Exit (1);
 				}
 				RootContext.ReferencesLookupPaths.Add (args [++i]);
 				return true;
 
 			case "--lint"
 				RootContext.EnhancedWarnings = true;
 				return true;
 				
 			case "--nostdlib"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.StdLib = false;
 				return true;
 				
 			case "--nowarn"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				int warn = 0;
 				
 				try {
 					warn = Int32.Parse (args [++i]);
 				} catch {
 					Usage ();
 					Environment.Exit (1);
 				}
 				Report.SetIgnoreWarning (warn);
 				return true;
 
 			case "--wlevel"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Report.Error (
 						1900,
 						"--wlevel requires a value from 0 to 4");
 					Environment.Exit (1);
 				}
 
 				SetWarningLevel (args [++i]);
 				return true;
 
 			case "--mcs-debug"
 				if ((i + 1) >= args.Length){
 					Report.Error (5, "--mcs-debug requires an argument");
 					Environment.Exit (1);
 				}
 
 				try {
 					Report.DebugFlags = Int32.Parse (args [++i]);
 				} catch {
 					Report.Error (5, "Invalid argument to --mcs-debug");
 					Environment.Exit (1);
 				}
 				return true;
 				
 			case "--about"
 				About ();
 				return true;
 				
 			case "--recurse"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Report.Error (5, "--recurse requires an argument");
 					Environment.Exit (1);
 				}
 				ProcessSourceFiles (args [++i], true); 
 				return true;
 				
 			case "--timestamp"
 				timestamps = true;
 				return true;
 
 			case "--debug"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.GenerateDebugInfo = true;
 				return true;
 				
 			case "--noconfig"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.LoadDefaultReferences = false;
 				return true;
 
 			default
 				if (arg.StartsWith ("--fatal")){
 					if (arg.StartsWith ("--fatal=")){
 						if (!Int32.TryParse (arg.Substring (8), out fatal_errors))
 							fatal_errors = 1;
 					} else
 						fatal_errors = 1;
 					return true;
 				}
 				if (arg.StartsWith ("--runtime
 					string version = arg.Substring (10);
 
 					switch (version) {
 					case "v1"
 					case "V1"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v1;
 						break;
 					case "v2"
 					case "V2"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v2;
 						return true;
 					case "v4"
 					case "V4"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v4;
 						return true;
 					}
 					return true;
 				}
 
 				break;
 			}
 
 			return false;
 		}
 
 #if !SMCS_SOURCE
 		public static string GetPackageFlags (string packages, bool fatal, Report report)
 		{
 			ProcessStartInfo pi = new ProcessStartInfo ();
 			pi.FileName = "pkg-config";
 			pi.RedirectStandardOutput = true;
 			pi.UseShellExecute = false;
 			pi.Arguments = "--libs " + packages;
 			Process p = null;
 			try {
 				p = Process.Start (pi);
 			} catch (Exception e) {
 				report.Error (-27, "Couldn't run pkg-config
 				if (fatal)
 					Environment.Exit (1);
 				p.Close ();
 				return null;
 			}
 			
 			if (p.StandardOutput == null){
 				report.Warning (-27, 1, "Specified package did not return any information");
 				p.Close ();
 				return null;
 			}
 			string pkgout = p.StandardOutput.ReadToEnd ();
 			p.WaitForExit ();
 			if (p.ExitCode != 0) {
 				report.Error (-27, "Error running pkg-config. Check the above output.");
 				if (fatal)
 					Environment.Exit (1);
 				p.Close ();
 				return null;
 			}
 			p.Close ();
 
 			return pkgout;
 		}
 #endif
 
 		//
 		// This parses the -arg and /arg options to the compiler, even if the strings
 		// in the following text use "/arg" on the strings.
 		//
 		bool CSCParseOption (string option, ref string [] args)
 		{
 			int idx = option.IndexOf ('
 			string arg, value;
 
 			if (idx == -1){
 				arg = option;
 				value = "";
 			} else {
 				arg = option.Substring (0, idx);
 
 				value = option.Substring (idx + 1);
 			}
 
 			switch (arg.ToLowerInvariant ()){
 			case "/nologo"
 				return true;
 
 			case "/t"
 			case "/target"
 				switch (value){
 				case "exe"
 					RootContext.Target = Target.Exe;
 					break;
 
 				case "winexe"
 					RootContext.Target = Target.WinExe;
 					break;
 
 				case "library"
 					RootContext.Target = Target.Library;
 					RootContext.TargetExt = ".dll";
 					break;
 
 				case "module"
 					RootContext.Target = Target.Module;
 					RootContext.TargetExt = ".netmodule";
 					break;
 
 				default
 					TargetUsage ();
 					break;
 				}
 				return true;
 
 			case "/out"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				RootContext.OutputFile = value;
 				return true;
 
 			case "/o"
 			case "/o+"
 			case "/optimize"
 			case "/optimize+"
 				RootContext.Optimize = true;
 				return true;
 
 			case "/o-"
 			case "/optimize-"
 				RootContext.Optimize = false;
 				return true;
 
 			// TODO
 			case "/incremental"
 			case "/incremental+"
 			case "/incremental-"
 				// nothing.
 				return true;
 
 			case "/d"
 			case "/define"
 				if (value.Length == 0){
 					Usage ();
 					Environment.Exit (1);
 				}
 
 				foreach (string d in value.Split (argument_value_separator)) {
 					string conditional = d.Trim ();
 					if (!Tokenizer.IsValidIdentifier (conditional)) {
 						Report.Warning (2029, 1, "Invalid conditional define symbol `{0}'", conditional);
 						continue;
 					}
 					RootContext.AddConditional (conditional);
 				}
 				return true;
 			}
 
 			case "/bugreport"
 				//
 				// We should collect data, runtime, etc and store in the file specified
 				//
 				Console.WriteLine ("To file bug reports, please visit
 				return true;
 #if !SMCS_SOURCE
 			case "/pkg"
 				string packages;
 
 				if (value.Length == 0){
 					Usage ();
 					Environment.Exit (1);
 				}
 				packages = String.Join (" ", value.Split (new Char [] { ';', ',', '\n', '\r'}));
 				string pkgout = GetPackageFlags (packages, true, Report);
 				
 				if (pkgout != null){
 					string [] xargs = pkgout.Trim (new Char [] {' ', '\n', '\r', '\t'}).
 						Split (new Char [] { ' ', '\t'});
 					args = AddArgs (args, xargs);
 				}
 				
 				return true;
 			}
 #endif
 			case "/linkres"
 			case "/linkresource"
 			case "/res"
 			case "/resource"
 				AssemblyResource res = null;			
 				string[] s = value.Split (argument_value_separator, StringSplitOptions.RemoveEmptyEntries);
 				switch (s.Length) {
 				case 1
 					if (s[0].Length == 0)
 						goto default;
 					res = new AssemblyResource (s [0], Path.GetFileName (s[0]));
 					break;
 				case 2
 					res = new AssemblyResource (s [0], s [1]);
 					break;
 				case 3
 					if (s [2] != "public" && s [2] != "private") {
 						Report.Error (1906, "Invalid resource visibility option `{0}'. Use either `public' or `private' instead", s [2]);
 						return true;
 					}
 					res = new AssemblyResource (s[0], s[1], s[2] == "private");
 					break;
 				default
 					Report.Error (-2005, "Wrong number of arguments for option `{0}'", option);
 					break;
 				}
 
 				if (res != null) {
 					res.IsEmbeded = arg [1] == 'r' || arg [1] == 'R';
 					AddResource (res);
 				}
 
 				return true;
 				
 			case "/recurse"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				ProcessSourceFiles (value, true); 
 				return true;
 
 			case "/r"
 			case "/reference"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				string[] refs = value.Split (argument_value_separator);
 				foreach (string r in refs){
 					if (r.Length == 0)
 						continue;
 
 					string val = r;
 					int index = val.IndexOf ('=');
 					if (index > -1) {
 						string alias = r.Substring (0, index);
 						string assembly = r.Substring (index + 1);
 						AddAssemblyReference (alias, assembly);
 						if (refs.Length != 1) {
 							Report.Error (2034, "Cannot specify multiple aliases using single /reference option");
 							break;
 						}
 					} else {
 						AddAssemblyReference (val);
 					}
 				}
 				return true;
 			}
 			case "/addmodule"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				string[] refs = value.Split (argument_value_separator);
 				foreach (string r in refs){
 					RootContext.Modules.Add (r);
 				}
 				return true;
 			}
 			case "/win32res"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				
 				if (RootContext.Win32IconFile != null)
 					Report.Error (1565, "Cannot specify the `win32res' and the `win32ico' compiler option at the same time");
 
 				RootContext.Win32ResourceFile = value;
 				return true;
 			}
 			case "/win32icon"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				if (RootContext.Win32ResourceFile != null)
 					Report.Error (1565, "Cannot specify the `win32res' and the `win32ico' compiler option at the same time");
 
 				RootContext.Win32IconFile = value;
 				return true;
 			}
 			case "/doc"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				RootContext.Documentation = new Documentation (value);
 				return true;
 			}
 			case "/lib"
 				string [] libdirs;
 				
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				libdirs = value.Split (argument_value_separator);
 				foreach (string dir in libdirs)
 					RootContext.ReferencesLookupPaths.Add (dir);
 				return true;
 			}
 
 			case "/debug-"
 				RootContext.GenerateDebugInfo = false;
 				return true;
 				
 			case "/debug"
 				if (value == "full" || value == "")
 					RootContext.GenerateDebugInfo = true;
 
 				return true;
 				
 			case "/debug+"
 				RootContext.GenerateDebugInfo = true;
 				return true;
 
 			case "/checked"
 			case "/checked+"
 				RootContext.Checked = true;
 				return true;
 
 			case "/checked-"
 				RootContext.Checked = false;
 				return true;
 
 			case "/clscheck"
 			case "/clscheck+"
 				RootContext.VerifyClsCompliance = true;
 				return true;
 
 			case "/clscheck-"
 				RootContext.VerifyClsCompliance = false;
 				return true;
 
 			case "/unsafe"
 			case "/unsafe+"
 				RootContext.Unsafe = true;
 				return true;
 
 			case "/unsafe-"
 				RootContext.Unsafe = false;
 				return true;
 
 			case "/warnaserror"
 			case "/warnaserror+"
 				if (value.Length == 0) {
 					Report.WarningsAreErrors = true;
 				} else {
 					foreach (string wid in value.Split (argument_value_separator))
 						Report.AddWarningAsError (wid);
 				}
 				return true;
 
 			case "/warnaserror-"
 				if (value.Length == 0) {
 					Report.WarningsAreErrors = false;
 				} else {
 					foreach (string wid in value.Split (argument_value_separator))
 						Report.RemoveWarningAsError (wid);
 				}
 				return true;
 
 			case "/warn"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				SetWarningLevel (value);
 				return true;
 
 			case "/nowarn"
 				if (value.Length == 0){
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				var warns = value.Split (argument_value_separator);
 				foreach (string wc in warns){
 					try {
 						if (wc.Trim ().Length == 0)
 							continue;
 
 						int warn = Int32.Parse (wc);
 						if (warn < 1) {
 							throw new ArgumentOutOfRangeException("warn");
 						}
 						Report.SetIgnoreWarning (warn);
 					} catch {
 						Report.Error (1904, "`{0}' is not a valid warning number", wc);
 					}
 				}
 				return true;
 			}
 
 			case "/noconfig"
 				RootContext.LoadDefaultReferences = false;
 				return true;
 
 			case "/platform"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLower (CultureInfo.InvariantCulture)) {
 				case "anycpu"
 					RootContext.Platform = Platform.AnyCPU;
 					break;
 				case "x86"
 					RootContext.Platform = Platform.X86;
 					break;
 				case "x64"
 					RootContext.Platform = Platform.X64;
 					break;
 				case "itanium"
 					RootContext.Platform = Platform.IA64;
 					break;
 				default
 					Report.Error (1672, "Invalid platform type for -platform. Valid options are `anycpu', `x86', `x64' or `itanium'");
 					break;
 				}
 
 				return true;
 
 			case "/sdk"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLowerInvariant ()) {
 					case "2"
 						RootContext.SdkVersion = SdkVersion.v2;
 						break;
 					case "4"
 						RootContext.SdkVersion = SdkVersion.v4;
 						break;
 					default
 						Report.Error (-26, "Invalid sdk version name");
 						break;
 				}
 
 				return true;
 
 				// We just ignore this.
 			case "/errorreport"
 			case "/filealign"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				return true;
 				
 			case "/helpinternal"
 				OtherFlags ();
 				Environment.Exit(0);
 				return true;
 				
 			case "/help"
 			case "/?"
 				Usage ();
 				Environment.Exit (0);
 				return true;
 
 			case "/main"
 			case "/m"
 				if (value.Length == 0){
 					Error_RequiresArgument (option);
 					break;
 				}
 				RootContext.MainClass = value;
 				return true;
 
 			case "/nostdlib"
 			case "/nostdlib+"
 				RootContext.StdLib = false;
 				return true;
 
 			case "/nostdlib-"
 				RootContext.StdLib = true;
 				return true;
 
 			case "/fullpaths"
 				return true;
 
 			case "/keyfile"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				RootContext.StrongNameKeyFile = value;
 				return true;
 
 			case "/keycontainer"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				RootContext.StrongNameKeyContainer = value;
 				return true;
 			case "/delaysign+"
 			case "/delaysign"
 				RootContext.StrongNameDelaySign = true;
 				return true;
 			case "/delaysign-"
 				RootContext.StrongNameDelaySign = false;
 				return true;
 
 			case "/langversion"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLowerInvariant ()) {
 				case "iso-1"
 					RootContext.Version = LanguageVersion.ISO_1;
 					return true;	
 				case "default"
 					RootContext.Version = LanguageVersion.Default;
 					RootContext.AddConditional ("__V2__");
 					return true;
 				case "iso-2"
 					RootContext.Version = LanguageVersion.ISO_2;
 					return true;
 				case "3"
 					RootContext.Version = LanguageVersion.V_3;
 					return true;
 				case "future"
 					RootContext.Version = LanguageVersion.Future;
 					return true;
 				}
 
 				Report.Error (1617, "Invalid -langversion option `{0}'. It must be `ISO-1', `ISO-2', `3' or `Default'", value);
 				return true;
 
 			case "/codepage"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value) {
 				case "utf8"
 					RootContext.Encoding = new UTF8Encoding();
 					break;
 				case "reset"
 					RootContext.Encoding = Encoding.Default;
 					break;
 				default
 					try {
 						RootContext.Encoding = Encoding.GetEncoding (Int32.Parse (value));
 					} catch {
 						Report.Error (2016, "Code page `{0}' is invalid or not installed", value);
 					}
 					break;
 				}
 				return true;
 
 			default
 				return false;
 			}
 
 			return true;
 		}
 
 		void Error_WrongOption (string option)
 		{
 			Report.Error (2007, "Unrecognized command-line option
 		}
 
 		void Error_RequiresFileName (string option)
 		{
 			Report.Error (2005, "Missing file specification for `{0}' option", option);
 		}
 
 		void Error_RequiresArgument (string option)
 		{
 			Report.Error (2006, "Missing argument for `{0}' option", option);
 		}
 
 		static string [] AddArgs (string [] args, string [] extra_args)
 		{
 			string [] new_args;
 			new_args = new string [extra_args.Length + args.Length];
 
 			// if args contains '--' we have to take that into account
 			// split args into first half and second half based on '--'
 			// and add the extra_args before --
 			int split_position = Array.IndexOf (args, "--");
 			if (split_position != -1)
 			{
 				Array.Copy (args, new_args, split_position);
 				extra_args.CopyTo (new_args, split_position);
 				Array.Copy (args, split_position, new_args, split_position + extra_args.Length, args.Length - split_position);
 			}
 			else
 			{
 				args.CopyTo (new_args, 0);
 				extra_args.CopyTo (new_args, args.Length);
 			}
 
 			return new_args;
 		}
 
 		void AddAssemblyReference (string assembly)
 		{
 			RootContext.AssemblyReferences.Add (assembly);
 		}
 
 		void AddAssemblyReference (string alias, string assembly)
 		{
 			if (assembly.Length == 0) {
 				Report.Error (1680, "Invalid reference alias `{0}='. Missing filename", alias);
 				return;
 			}
 
 			if (!IsExternAliasValid (alias)) {
 				Report.Error (1679, "Invalid extern alias for -reference. Alias `{0}' is not a valid identifier", alias);
 				return;
 			}
 
 			RootContext.AssemblyReferencesAliases.Add (Tuple.Create (alias, assembly));
 		}
 
 		void AddResource (AssemblyResource res)
 		{
 			if (RootContext.Resources == null) {
 				RootContext.Resources = new List<AssemblyResource> ();
 				RootContext.Resources.Add (res);
 				return;
 			}
 
 			if (RootContext.Resources.Contains (res)) {
 				ctx.Report.Error (1508, "The resource identifier `{0}' has already been used in this assembly", res.Name);
 				return;
 			}
 
 			RootContext.Resources.Add (res);
 		}
 		
 		static bool IsExternAliasValid (string identifier)
 		{
 			if (identifier.Length == 0)
 				return false;
 			if (identifier [0] != '_' && !Char.IsLetter (identifier [0]))
 				return false;
 
 			for (int i = 1; i < identifier.Length; i++) {
 				char c = identifier [i];
 				if (Char.IsLetter (c) || Char.IsDigit (c))
 					continue;
 
 				UnicodeCategory category = Char.GetUnicodeCategory (c);
 				if (category != UnicodeCategory.Format || category != UnicodeCategory.NonSpacingMark ||
 						category != UnicodeCategory.SpacingCombiningMark ||
 						category != UnicodeCategory.ConnectorPunctuation)
 					return false;
 			}
 			
 			return true;
 		}
 
 		//
 		// Main compilation method
 		//
 		public bool Compile ()
 		{
 			var module = new ModuleContainer (ctx);
 			RootContext.ToplevelTypes = module;
 
 			if (timestamps) {
 				stopwatch = Stopwatch.StartNew ();
 				first_time = DateTime.Now;
 			}
 
 			Parse (module);
 			ShowTime ("Parsing source files");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (RootContext.TokenizeOnly || RootContext.ParseOnly)
 				return true;
 
 			if (RootContext.ToplevelTypes.NamespaceEntry != null)
 				throw new InternalErrorException ("who set it?");
 
 			//
 			// Quick hack
 			//
 			var output_file = RootContext.OutputFile;
 			string output_file_name;
 			if (output_file == null) {
 				if (first_source == null) {
 					Report.Error (1562, "If no source files are specified you must specify the output file with -out
 					return false;
 				}
 
 				int pos = first_source.LastIndexOf ('.');
 
 				if (pos > 0)
 					output_file = first_source.Substring (0, pos) + RootContext.TargetExt;
 				else
 					output_file = first_source + RootContext.TargetExt;
 
 				output_file_name = output_file;
 			} else {
 				output_file_name = Path.GetFileName (output_file);
 			}
 
 			//
 			// Load assemblies required
 			//
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 #if STATIC
 			var assembly = new AssemblyDefinitionStatic (module, output_file_name, output_file);
 			module.SetDeclaringAssembly (assembly);
 
 			var importer = new StaticImporter ();
 			assembly.Importer = importer;
 
 			var loader = new StaticLoader (importer, ctx);
 			loader.LoadReferences (module);
 
 			ShowTime ("Imporing referenced assemblies");
 
 			if (!ctx.BuildinTypes.CheckDefinitions (module))
 				return false;
 
 			ShowTime ("Initializing predefined types");
 
 			if (!assembly.Create (loader))
 				return false;
 
 			// System.Object was not loaded, use compiled assembly as corlib
 			if (loader.Corlib == null)
 				loader.Corlib = assembly.Builder;
 
 			loader.LoadModules (assembly, module.GlobalRootNamespace);
 #else
 			var assembly = new AssemblyDefinitionDynamic (module, output_file_name, output_file);
 			module.SetDeclaringAssembly (assembly);
 
 			var importer = new ReflectionImporter (ctx.BuildinTypes);
 			assembly.Importer = importer;
 
 			var loader = new DynamicLoader (importer, ctx);
 			loader.LoadReferences (module);
 
 			ShowTime ("Imporing referenced assemblies");
 
 			if (!ctx.BuildinTypes.CheckDefinitions (module))
 				return false;
 
 			ShowTime ("Initializing predefined types");
 
 			if (!assembly.Create (AppDomain.CurrentDomain, AssemblyBuilderAccess.Save))
 				return false;
 
 			loader.LoadModules (assembly, module.GlobalRootNamespace);
 #endif
 			module.Define ();
 
 			ShowTime ("Types definition");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (Report.Errors == 0 &&
 				RootContext.Documentation != null &&
 				!RootContext.Documentation.OutputDocComment (
 					output_file, Report))
 				return false;
 
 			//
 			// Verify using aliases now
 			//
 			NamespaceEntry.VerifyAllUsing ();
 			
 			if (Report.Errors > 0){
 				return false;
 			}
 
 			assembly.Resolve ();
 			
 			if (Report.Errors > 0)
 				return false;
 			
 			//
 			// The code generator
 			//
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 			assembly.Emit ();
 
 			ShowTime ("Resolving and emitting members blocks");
 
 			if (Report.Errors > 0){
 				return false;
 			}
 
 			module.CloseType ();
 
 			ShowTime ("Closing types");
 
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 			assembly.EmbedResources ();
 			ShowTime ("Embedding resources");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 			
 			assembly.Save ();
 
 #if STATIC
 			loader.Dispose ();
 #endif
 
 			ShowTime ("Saving output assembly");
 
 			ShowTotalTime ("Total");
 
 			Timer.ShowTimers ();
 
 			return (Report.Errors == 0);
 		}
 	}
 
 	//
 	// This is the only public entry point
 	//
 	public class CompilerCallableEntryPoint 
 		public static bool InvokeCompiler (string [] args, TextWriter error)
 		{
 			try {
 				StreamReportPrinter srp = new StreamReportPrinter (error);
 				Driver d = Driver.Create (args, true, null, srp);
 				if (d == null)
 					return false;
 
 				return d.Compile () && srp.ErrorsCount == 0;
 			} finally {
 				Reset ();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="709" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" hamdist="8" pcid="447" startline="610"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			right = right.Resolve (ec);
 			if (right == null)
 				return null;
 
 			MemberAccess ma = target as MemberAccess;
 			using (ec.Set (ResolveContext.Options.CompoundAssignmentScope)) {
 				target = target.Resolve (ec);
 			}
 			
 			if (target == null)
 				return null;
 
 			if (target is MethodGroupExpr){
 				ec.Report.Error (1656, loc,
 					"Cannot assign to `{0}' because it is a `{1}'",
 					((MethodGroupExpr)target).Name, target.ExprClassName);
 				return null;
 			}
 
 			var event_expr = target as EventExpr;
 			if (event_expr != null) {
 				source = Convert.ImplicitConversionRequired (ec, right, target.Type, loc);
 				if (source == null)
 					return null;
 
 				Expression rside;
 				if (op == Binary.Operator.Addition)
 					rside = EmptyExpression.EventAddition;
 				else if (op == Binary.Operator.Subtraction)
 					rside = EmptyExpression.EventSubtraction;
 				else
 					rside = null;
 
 				target = target.ResolveLValue (ec, rside);
 				if (target == null)
 					return null;
 
 				eclass = ExprClass.Value;
 				type = event_expr.Operator.ReturnType;
 				return this;
 			}
 
 			//
 			// Only now we can decouple the original source/target
 			// into a tree, to guarantee that we do not have side
 			// effects.
 			//
 			if (left == null)
 				left = new TargetExpression (target);
 
 			source = new Binary (op, left, right, true, loc);
 
 			if (target is DynamicMemberAssignable) {
 				Arguments targs = ((DynamicMemberAssignable) target).Arguments;
 				source = source.Resolve (ec);
 
 				Arguments args = new Arguments (targs.Count + 1);
 				args.AddRange (targs);
 				args.Add (new Argument (source));
 
 				var binder_flags = CSharpBinderFlags.ValueFromCompoundAssignment;
 
 				//
 				// Compound assignment does target conversion using additional method
 				// call, set checked context as the binary operation can overflow
 				//
 				if (ec.HasSet (ResolveContext.Options.CheckedScope))
 					binder_flags |= CSharpBinderFlags.CheckedContext;
 
 				if (target is DynamicMemberBinder) {
 					source = new DynamicMemberBinder (ma.Name, binder_flags, args, loc).Resolve (ec);
 
 					// Handles possible event addition/subtraction
 					if (op == Binary.Operator.Addition || op == Binary.Operator.Subtraction) {
 						args = new Arguments (targs.Count + 1);
 						args.AddRange (targs);
 						args.Add (new Argument (right));
 						string method_prefix = op == Binary.Operator.Addition ?
 							Event.AEventAccessor.AddPrefix 
 
 						var invoke = DynamicInvocation.CreateSpecialNameInvoke (
 							new MemberAccess (right, method_prefix + ma.Name, loc), args, loc).Resolve (ec);
 
 						args = new Arguments (targs.Count);
 						args.AddRange (targs);
 						source = new DynamicEventCompoundAssign (ma.Name, args,
 							(ExpressionStatement) source, (ExpressionStatement) invoke, loc).Resolve (ec);
 					}
 				} else {
 					source = new DynamicIndexBinder (binder_flags, args, loc).Resolve (ec);
 				}
 
 				return source;
 			}
 
 			return base.DoResolve (ec);
 		}
]]></clone_fragment>
<clone_fragment endline="1215" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" hamdist="7" pcid="1963" startline="1116"><![CDATA[
 
 			public const string AddPrefix = "add_";
 			public const string RemovePrefix = "remove_";
 
 			protected AEventAccessor (Event method, string prefix, Attributes attrs, Location loc)
 				
 			{
 				this.method = method;
 				this.ModFlags = method.ModFlags;
 				this.parameters = ParametersCompiled.CreateImplicitParameter (method.TypeExpression, loc);
 			}
 
 			public bool IsInterfaceImplementation {
 				get { return method_data.implementing != null; }
 			}
 
 			public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Type == pa.MethodImpl) {
 					method.is_external_implementation = a.IsInternalCall ();
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			protected override void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Target == AttributeTargets.Parameter) {
 					parameters[0].ApplyAttributeBuilder (a, ctor, cdata, pa);
 					return;
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override AttributeTargets AttributeTargets {
 				get {
 					return AttributeTargets.Method;
 				}
 			}
 
 			public override bool IsClsComplianceRequired ()
 			{
 				return method.IsClsComplianceRequired ();
 			}
 
 			public virtual MethodBuilder Define (DeclSpace parent)
 			{
 				parameters.Resolve (this);
 
 				method_data = new MethodData (method, method.ModFlags,
 					method.flags | MethodAttributes.HideBySig | MethodAttributes.SpecialName, this);
 
 				if (!method_data.Define (parent, method.GetFullName (MemberName), Report))
 					return null;
 
 				MethodBuilder mb = method_data.MethodBuilder;
 
 				Spec = new MethodSpec (MemberKind.Method, parent.PartialContainer.Definition, this, ReturnType, mb, ParameterInfo, method.ModFlags);
 				Spec.IsAccessor = true;
 
 				return mb;
 			}
 
 			public override TypeSpec ReturnType {
 				get {
 					return TypeManager.void_type;
 				}
 			}
 
 			public override ObsoleteAttribute GetAttributeObsolete ()
 			{
 				return method.GetAttributeObsolete ();
 			}
 
 			public override string[] ValidAttributeTargets {
 				get {
 					return attribute_targets;
 				}
 			}
 
 			public override ParametersCompiled ParameterInfo {
 				get {
 					return parameters;
 				}
 			}
 		}
 
 		AEventAccessor add, remove;
 		EventBuilder EventBuilder;
 		protected EventSpec spec;
 
 		protected Event (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs)
 		{
 		}
]]></clone_fragment>
<clone_fragment endline="1049" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" hamdist="6" pcid="3201" startline="976"><![CDATA[
 
 		static void FindApplicableUserDefinedConversionOperators (IList<MemberSpec> operators, Expression source, TypeSpec target, bool implicitOnly, ref List<MethodSpec> candidates)
 		{
 			//
 			// LAMESPEC
 			// IntPtr -> uint uses int
 			// UIntPtr -> long uses ulong
 			//
 			if (source.Type == TypeManager.intptr_type) {
 				if (target == TypeManager.uint32_type)
 					target = TypeManager.int32_type;
 			} else if (source.Type == TypeManager.uintptr_type) {
 				if (target == TypeManager.int64_type)
 					target = TypeManager.uint64_type;
 			}
 
 			// Neither A nor B are interface-types
 			if (source.Type.IsInterface)
 				return;
 
 			// For a conversion operator to be applicable, it must be possible
 			// to perform a standard conversion from the source type to
 			// the operand type of the operator, and it must be possible
 			// to perform a standard conversion from the result type of
 			// the operator to the target type.
 
 			Expression texpr = null;
 
 			foreach (MethodSpec op in operators) {
 				
 				// Can be null because MemberCache.GetUserOperator does not resize the array
 				if (op == null)
 					continue;
 
 				var t = op.Parameters.Types[0];
 				if (source.Type != t && !ImplicitStandardConversionExists (source, t)) {
 					if (implicitOnly)
 						continue;
 
 					if (!ImplicitStandardConversionExists (new EmptyExpression (t), source.Type))
 						continue;
 				}
 
 				t = op.ReturnType;
 
 				// LAMESPEC
 				if (t == TypeManager.uint32_type && source.Type == TypeManager.uintptr_type)
 					continue;
 
 				if (t.IsInterface)
 					continue;
 
 				if (target != t) {
 					if (TypeManager.IsNullableType (t))
 						t = Nullable.NullableInfo.GetUnderlyingType (t);
 
 					if (!ImplicitStandardConversionExists (new EmptyExpression (t), target)) {
 						if (implicitOnly)
 							continue;
 
 						if (texpr == null)
 							texpr = new EmptyExpression (target);
 
 						if (!ImplicitStandardConversionExists (texpr, t))
 							continue;
 					}
 				}
 
 				if (candidates == null)
 					candidates = new List<MethodSpec> ();
 
 				candidates.Add (op);
 			}
 			foreach (MethodSpec op in operators) {
 				
 				// Can be null because MemberCache.GetUserOperator does not resize the array
 				if (op == null)
 					continue;
 
 				var t = op.Parameters.Types[0];
 				if (source.Type != t && !ImplicitStandardConversionExists (source, t)) {
 					if (implicitOnly)
 						continue;
 
 					if (!ImplicitStandardConversionExists (new EmptyExpression (t), source.Type))
 						continue;
 				}
 
 				t = op.ReturnType;
 
 				// LAMESPEC
 				if (t == TypeManager.uint32_type && source.Type == TypeManager.uintptr_type)
 					continue;
 
 				if (t.IsInterface)
 					continue;
 
 				if (target != t) {
 					if (TypeManager.IsNullableType (t))
 						t = Nullable.NullableInfo.GetUnderlyingType (t);
 
 					if (!ImplicitStandardConversionExists (new EmptyExpression (t), target)) {
 						if (implicitOnly)
 							continue;
 
 						if (texpr == null)
 							texpr = new EmptyExpression (target);
 
 						if (!ImplicitStandardConversionExists (texpr, t))
 							continue;
 					}
 				}
 
 				if (candidates == null)
 					candidates = new List<MethodSpec> ();
 
 				candidates.Add (op);
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="244" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" hamdist="5" pcid="2103" startline="122"><![CDATA[
 
 			#endregion
 		}
 
 		[Flags]
 		enum CachedMethods
 		{
 			Equals				= 1,
 			GetHashCode			= 1 << 1,
 			HasStaticFieldInitializer	= 1 << 2
 		}
 
 
 		// Whether this is a struct, class or interface
 		public readonly MemberKind Kind;
 
 		// Holds a list of classes and structures
 		protected List<TypeContainer> types;
 
 		List<MemberCore> ordered_explicit_member_list;
 		List<MemberCore> ordered_member_list;
 
 		// Holds the list of properties
 		List<MemberCore> properties;
 
 		// Holds the list of constructors
 		protected List<Constructor> instance_constructors;
 
 		// Holds the list of fields
 		protected List<FieldBase> fields;
 
 		// Holds a list of fields that have initializers
 		protected List<FieldInitializer> initialized_fields;
 
 		// Holds a list of static fields that have initializers
 		protected List<FieldInitializer> initialized_static_fields;
 
 		// Holds the list of constants
 		protected List<MemberCore> constants;
 
 		// Holds the methods.
 		List<MemberCore> methods;
 
 		// Holds the events
 		protected List<MemberCore> events;
 
 		// Holds the indexers
 		List<MemberCore> indexers;
 
 		// Holds the operators
 		List<MemberCore> operators;
 
 		// Holds the compiler generated classes
 		protected List<CompilerGeneratedClass> compiler_generated;
 
 		Dictionary<MethodSpec, Method> hoisted_base_call_proxies;
 
 		Dictionary<string, FullNamedExpression> Cache = new Dictionary<string, FullNamedExpression> ();
 
 		//
 		// Pointers to the default constructor and the default static constructor
 		//
 		protected Constructor default_constructor;
 		protected Constructor default_static_constructor;
 
 		//
 		// Points to the first non-static field added to the container.
 		//
 		// This is an arbitrary choice.  We are interested in looking at _some_ non-static field,
 		// and the first one's as good as any.
 		//
 		FieldBase first_nonstatic_field;
 
 		//
 		// This one is computed after we can distinguish interfaces
 		// from classes from the arraylist `type_bases' 
 		//
 		protected TypeSpec base_type;
 		protected TypeExpr base_type_expr;
 		protected TypeExpr[] iface_exprs;
 
 		protected List<FullNamedExpression> type_bases;
 
 		bool members_defined;
 		bool members_defined_ok;
 		bool type_defined;
 
 		TypeContainer InTransit;
 
 		GenericTypeParameterBuilder[] all_tp_builders;
 
 		public const string DefaultIndexerName = "Item";
 
 		private bool seen_normal_indexers = false;
 		private string indexer_name = DefaultIndexerName;
 		protected bool requires_delayed_unmanagedtype_check;
 		bool error;
 
 		private CachedMethods cached_method;
 
 		protected TypeSpec spec;
 		TypeSpec current_type;
 
 		List<TypeContainer> partial_parts;
 
 		public int DynamicSitesCounter;
 
 		/// <remarks>
 		///  The pending methods that need to be implemented
 		//   (interfaces or abstract methods)
 		/// </remarks>
 		PendingImplementation pending;
 
 		public TypeContainer (NamespaceEntry ns, DeclSpace parent, MemberName name,
 				      Attributes attrs, MemberKind kind)
 			
 		{
 			if (parent != null && parent.NamespaceEntry != ns)
 				throw new InternalErrorException ("A nested type should be in the same NamespaceEntry as its enclosing class");
 
 			this.Kind = kind;
 			this.PartialContainer = this;
 		}
]]></clone_fragment>
<clone_fragment endline="339" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" hamdist="4" pcid="3177" startline="220"><![CDATA[
 
 		//
 		// 6.1.6 Implicit reference conversions
 		//
 		public static bool ImplicitReferenceConversionExists (Expression expr, TypeSpec target_type)
 		{
 			if (TypeManager.IsStruct (target_type))
 				return false;
 
 			TypeSpec expr_type = expr.Type;
 
 			// from the null type to any reference-type.
 			if (expr_type == InternalType.Null)
 				return target_type != InternalType.AnonymousMethod;
 
 			if (TypeManager.IsGenericParameter (expr_type))
 				return ImplicitTypeParameterConversion (expr, target_type) != null;
 
 			// This code is kind of mirrored inside ImplicitStandardConversionExists
 			// with the small distinction that we only probe there
 			//
 			// Always ensure that the code here and there is in sync
 
 			// from any class-type S to any interface-type T.
 			if (target_type.IsInterface) {
 				if (expr_type.ImplementsInterface (target_type, true)){
 					return !TypeManager.IsValueType (expr_type);
 				}
 			}
 
 			//
 			// Implicit reference conversions (no-boxing) to object or dynamic
 			//
 			if (target_type == TypeManager.object_type || target_type == InternalType.Dynamic) {
 				switch (expr_type.Kind) {
 				case MemberKind.Class
 				case MemberKind.Interface
 				case MemberKind.Delegate
 				case MemberKind.ArrayType
 					return true;
 				}
 
 				return expr_type == InternalType.Dynamic;
 			}
 
 			if (target_type == TypeManager.value_type) {
 				return expr_type == TypeManager.enum_type;
 			} else if (expr_type == target_type || TypeSpec.IsBaseClass (expr_type, target_type, true)) {
 				//
 				// Special case
 				// System.Enum is not a value type, it is a class, so we need
 				// a boxing conversion
 				//
 				if (target_type == TypeManager.enum_type || TypeManager.IsGenericParameter (expr_type))
 					return false;
 
 				if (TypeManager.IsValueType (expr_type))
 					return false;
 
 				// Array type variance conversion
 				//if (target_type.IsArray != expr_type.IsArray)
 				//	return false;
 
 				return true;
 			}
 
 			var expr_type_array = expr_type as ArrayContainer;
 			if (expr_type_array != null) {
 				var target_type_array = target_type as ArrayContainer;
 				// from an array-type S to an array-type of type T
 				if (target_type_array != null && expr_type_array.Rank == target_type_array.Rank) {
 
 					//
 					// Both SE and TE are reference-types
 					//
 					TypeSpec expr_element_type = expr_type_array.Element;
 					if (!TypeManager.IsReferenceType (expr_element_type))
 						return false;
 
 					TypeSpec target_element_type = target_type_array.Element;
 					if (!TypeManager.IsReferenceType (target_element_type))
 						return false;
 
 					if (MyEmptyExpr == null)
 						MyEmptyExpr = new EmptyExpression (expr_element_type);
 					else
 						MyEmptyExpr.SetType (expr_element_type);
 
 					return ImplicitStandardConversionExists (MyEmptyExpr, target_element_type);
 				}
 
 				// from an array-type to System.Array
 				if (target_type == TypeManager.array_type)
 					return true;
 
 				// from an array-type of type T to IList<T>
 				if (ArrayToIList (expr_type_array, target_type, false))
 					return true;
 
 				return false;
 			}
 
 			if (TypeSpecComparer.IsEqual (expr_type, target_type))
 				return true;
 
 			if (TypeSpecComparer.Variant.IsEqual (expr_type, target_type))
 				return true;
 
 			// from any interface type S to interface-type T.
 			if (expr_type.IsInterface && target_type.IsInterface) {
 				return expr_type.ImplementsInterface (target_type, true);
 			}
 
 			// from any delegate type to System.Delegate
 			if (target_type == TypeManager.delegate_type &&
 				(expr_type == TypeManager.delegate_type || expr_type.IsDelegate))
 				return true;
 
 			return false;
 		}
]]></clone_fragment>
<clone_fragment endline="1230" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\MethodResolver.vb" hamdist="11" pcid="8667" startline="1093"><![CDATA[
 
     Class TypeHint
         Public Hint As TypeReference
         Public ArrayElementRestriction As Boolean
         Public GenericArgumentRestriction As Boolean
     End Class
 
     Class TypeHints
         Private m_Candidate As MemberCandidate
         Private m_Hints As New Generic.List(Of TypeHint)
 
         ReadOnly Property Hints As Generic.List(Of TypeHint)
             Get
                 Return m_Hints
             End Get
         End Property
 
         Public Sub New(ByVal Candidate As MemberCandidate)
             m_Candidate = Candidate
         End Sub
 
         Private Function InvolvesMethodTypeParameters(ByVal GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal type As TypeReference) As Boolean
             Dim elementType As GenericInstanceType
             Dim genericParam As GenericParameter
             Dim git As GenericInstanceType
 
             If type Is Nothing Then Return False
 
             genericParam = TryCast(type, GenericParameter)
             If genericParam IsNot Nothing AndAlso GenericParameters.Contains(genericParam) Then Return True
 
             git = TryCast(type, GenericInstanceType)
             If git Is Nothing Then Return False
 
             For i As Integer = 0 To GenericParameters.Count - 1
                 If git.GenericArguments.Contains(GenericParameters(i)) Then Return True
             Next
 
             elementType = TryCast(type.GetElementType(), GenericInstanceType)
             If elementType IsNot type Then Return InvolvesMethodTypeParameters(GenericParameters, elementType)
 
             Return False
         End Function
 
         Public Function GenerateHint(ByVal GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal argument_type As TypeReference, ByVal parameter As ParameterDefinition) As Boolean
             Return GenerateHint(GenericParameters, argument_type, parameter.ParameterType, parameter, False, False)
         End Function
 
         Private Function GenerateHint(ByVal GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal argument_type As TypeReference, ByVal parameter_type As TypeReference, ByVal parameter As ParameterDefinition, ByVal array_element_restriction As Boolean, ByVal generic_argument_restriction As Boolean) As Boolean
 
             'Given an argument type TA for an argument A and a parameter type TP for a parameter P, type hints are generated as follows
             '?	If TP does not involve any method type parameters then no hints are generated.
             If InvolvesMethodTypeParameters(GenericParameters, parameter_type) = False Then Return True
 
             '?	If TP and TA are array types of the same rank, then replace TA and TP with the element types of 
             '   TA and TP and restart this process with an array element restriction.
             Dim arrayA As ArrayType = TryCast(argument_type, ArrayType)
             Dim arrayP As ArrayType = TryCast(parameter_type, ArrayType)
             If arrayA IsNot Nothing AndAlso arrayP IsNot Nothing Then
                 If arrayA.Rank = arrayP.Rank Then
                     Return GenerateHint(GenericParameters, arrayA.ElementType, arrayP.ElementType, parameter, True, generic_argument_restriction)
                 End If
             End If
 
             '?	If TP is a method type parameter, then TA is added as a type hint with the current restriction, if any.
             Dim gp As GenericParameter = TryCast(parameter_type, GenericParameter)
             If gp IsNot Nothing AndAlso GenericParameters.Contains(gp) Then
                 Dim hint As TypeHint = New TypeHint()
                 hint.ArrayElementRestriction = array_element_restriction
                 hint.GenericArgumentRestriction = generic_argument_restriction
                 hint.Hint = argument_type
                 m_Hints.Add(hint)
                 Return True
             End If
 
             '?	If A is a lambda method and TP is a constructed delegate type or System.Linq.Expressions.Expression(Of T), 
             '   where T is a constructed delegate type, for each lambda method parameter type TL and corresponding 
             '   delegate parameter type TD, replace TA with TL and TP with TD and restart the process with no restriction. 
             '   Then replace TA with the return type of the lambda method and TP with the return type of the delegate type 
             '   and restart the process with no restriction.
             '* no lambda support yet *
 
             '?	If A is a method pointer and TP is a constructed delegate type, use the parameter types of TP to determine 
             '   which method pointed is most applicable to TP. If there is a method that is most applicable, replace TA with 
             '   the return type of the method and TP with the return type of the delegate type and restart the process with 
             '   no restriction.
             '* TODO *
 
             '?	Otherwise, TP must be a constructed type. Given TG, the generic type of TP,
             '   ?	If TA is TG, inherits from TG, or implements the type TG exactly once, then for each matching 
             '       type argument TAX from TA and TPX from TP, replace TA with TAX and TP with TPX and restart 
             '       the process with a generic argument restriction.
             Dim tp_git As GenericInstanceType = TryCast(parameter_type, GenericInstanceType)
             Dim ta_git As GenericInstanceType = TryCast(argument_type, GenericInstanceType)
             If tp_git IsNot Nothing AndAlso ta_git IsNot Nothing Then
                 Dim restart As Boolean
                 Dim implement_count As Integer
                 Dim tp_td As TypeDefinition = CecilHelper.FindDefinition(tp_git)
                 Dim ta_td As TypeDefinition = CecilHelper.FindDefinition(ta_git)
                 Dim base As TypeReference = ta_td
                 Dim base_td As TypeDefinition
                 While base IsNot Nothing AndAlso restart = False
                     If base Is tp_td Then restart = True
                     base_td = CecilHelper.FindDefinition(base)
                     If base_td.HasInterfaces Then
                         For i As Integer = 0 To base_td.Interfaces.Count - 1
                             If base_td.Interfaces(i) Is tp_git Then implement_count += 1
                         Next
                     End If
 
                     base = base_td.BaseType
                 End While
                 If restart = False Then
                     restart = implement_count = 1
                 End If
                 If restart Then
                     For i As Integer = 0 To ta_git.GenericArguments.Count - 1
                         If GenerateHint(GenericParameters, ta_git.GenericArguments(i), tp_git.GenericArguments(i), parameter, array_element_restriction, True) = False Then
                             Return False
                         End If
                     Next
                 End If
                 Return True
             End If
 
             '?	Otherwise, type inference fails for the generic method.
             Return False
         End Function
     End Class
 
     Sub ExpandParamArray()
         If DefinedParameters.Count = 0 Then Return
         If Helper.IsParamArrayParameter(Compiler, DefinedParameters(DefinedParameters.Count - 1)) = False Then Return
 
         Dim candidate As New MemberCandidate(Resolver, m_Member)
         candidate.m_IsParamArray = True
         Resolver.Candidates.Add(candidate)
     End Sub
]]></clone_fragment>
<clone_fragment endline="267" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" hamdist="12" pcid="2237" startline="139"><![CDATA[
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE;
 
 		public Enum (NamespaceEntry ns, DeclSpace parent, TypeExpression type,
 			     Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			base_type_expr = type;
 			var accmods = IsTopLevel ? Modifiers.INTERNAL 
 			ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod_flags, accmods, Location, Report);
 			spec = new EnumSpec (null, this, null, null, ModFlags);
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Enum;
 			}
 		}
 
 		public TypeExpr BaseTypeExpression {
 			get {
 				return base_type_expr;
 			}
 		}
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed | base.TypeAttr;
 			}
 		}
 
 		public TypeSpec UnderlyingType {
 			get {
 				return ((EnumSpec) spec).UnderlyingType;
 			}
 		}
 
 		#endregion
 
 		public void AddEnumMember (EnumMember em)
 		{
 			if (em.Name == UnderlyingValueField) {
 				Report.Error (76, em.Location, "An item in an enumeration cannot have an identifier `{0}'",
 					UnderlyingValueField);
 				return;
 			}
 
 			AddConstant (em);
 		}
 
 		public static void Error_1008 (Location loc, Report Report)
 		{
 			Report.Error (1008, loc,
 				"Type byte, sbyte, short, ushort, int, uint, long or ulong expected");
 		}
 
 		protected override bool DefineNestedTypes ()
 		{
 			((EnumSpec) spec).UnderlyingType = base_type_expr == null ? TypeManager.int32_type 
 
 			TypeBuilder.DefineField (UnderlyingValueField, UnderlyingType.GetMetaInfo (),
 				FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
 
 			if (!RootContext.StdLib)
 				Module.hack_corlib_enums.Add (this);
 
 			return true;
 		}
 
 		protected override bool DoDefineMembers ()
 		{
 			if (constants != null) {
 				for (int i = 0; i < constants.Count; ++i) {
 					EnumMember em = (EnumMember) constants [i];
 					if (em.Initializer == null) {
 						em.Initializer = new ImplicitInitializer (em, i == 0 ? null 
 					}
 
 					em.Define ();
 				}
 			}
 
 			return true;
 		}
 
 		public override bool IsUnmanagedType ()
 		{
 			return true;
 		}
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			base_type = TypeManager.enum_type;
 			base_class = base_type_expr;
 			return null;
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (UnderlyingType == TypeManager.uint32_type ||
 				UnderlyingType == TypeManager.uint64_type ||
 				UnderlyingType == TypeManager.ushort_type) {
 				Report.Warning (3009, 1, Location, "`{0}'
 			}
 
 			return true;
 		}	
 	}
 
 	class EnumSpec 
 	{
 		TypeSpec underlying;
 
 		public EnumSpec (TypeSpec declaringType, ITypeDefinition definition, TypeSpec underlyingType, MetaType info, Modifiers modifiers)
 			
 		{
 			this.underlying = underlyingType;
 		}
]]></clone_fragment>
<clone_fragment endline="3005" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="5" pcid="2351" startline="2878"><![CDATA[
 
 		public abstract void SetTypeArguments (ResolveContext ec, TypeArguments ta);
 	}
 
 	// 
 	// Represents a group of extension method candidates for whole namespace
 	// 
 	class ExtensionMethodGroupExpr 
 	{
 		NamespaceEntry namespace_entry;
 		public readonly Expression ExtensionExpression;
 
 		public ExtensionMethodGroupExpr (IList<MethodSpec> list, NamespaceEntry n, Expression extensionExpr, Location l)
 			
 		{
 			this.namespace_entry = n;
 			this.ExtensionExpression = extensionExpr;
 		}
 
 		public override bool IsStatic {
 			get { return true; }
 		}
 
 		public override IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			if (namespace_entry == null)
 				return null;
 
 			//
 			// For extension methodgroup we are not looking for base members but parent
 			// namespace extension methods
 			//
 			int arity = type_arguments == null ? 0 
 			var found = namespace_entry.LookupExtensionMethod (DeclaringType, Name, arity, ref namespace_entry);
 			if (found == null)
 				return null;
 
 			return found.Cast<MemberSpec> ().ToList ();
 		}
 
 		public override MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 		{
 			// We are already here
 			return null;
 		}
 
 		public override MethodGroupExpr OverloadResolve (ResolveContext ec, ref Arguments arguments, OverloadResolver.IErrorHandler ehandler, OverloadResolver.Restrictions restr)
 		{
 			if (arguments == null)
 				arguments = new Arguments (1);
 
 			arguments.Insert (0, new Argument (ExtensionExpression, Argument.AType.ExtensionType));
 			var res = base.OverloadResolve (ec, ref arguments, ehandler ?? this, restr);
 
 			// Store resolved argument and restore original arguments
 			if (res == null) {
 				// Clean-up modified arguments for error reporting
 				arguments.RemoveAt (0);
 				return null;
 			}
 
 			var me = ExtensionExpression as MemberExpr;
 			if (me != null)
 				me.ResolveInstanceExpression (ec, null);
 
 			InstanceExpression = null;
 			return this;
 		}
 
 		#region IErrorHandler Members
 
 		bool OverloadResolver.IErrorHandler.AmbiguousCandidates (ResolveContext rc, MemberSpec best, MemberSpec ambiguous)
 		{
 			return false;
 		}
 
 		bool OverloadResolver.IErrorHandler.ArgumentMismatch (ResolveContext rc, MemberSpec best, Argument arg, int index)
 		{
 			rc.Report.SymbolRelatedToPreviousError (best);
 			rc.Report.Error (1928, loc,
 				"Type `{0}' does not contain a member `{1}' and the best extension method overload `{2}' has some invalid arguments",
 				queried_type.GetSignatureForError (), Name, best.GetSignatureForError ());
 
 			if (index == 0) {
 				rc.Report.Error (1929, loc,
 					"Extension method instance type `{0}' cannot be converted to `{1}'",
 					arg.Type.GetSignatureForError (), ((MethodSpec)best).Parameters.ExtensionMethodType.GetSignatureForError ());
 			}
 
 			return true;
 		}
 
 		bool OverloadResolver.IErrorHandler.NoArgumentMatch (ResolveContext rc, MemberSpec best)
 		{
 			return false;
 		}
 
 		bool OverloadResolver.IErrorHandler.TypeInferenceFailed (ResolveContext rc, MemberSpec best)
 		{
 			return false;
 		}
 
 		#endregion
 	}
 
 	/// <summary>
 	///   MethodGroupExpr represents a group of method candidates which
 	///   can be resolved to the best method overload
 	/// </summary>
 	public class MethodGroupExpr 
 	{
 		protected IList<MemberSpec> Methods;
 		MethodSpec best_candidate;
 		TypeSpec best_candidate_return;
 		protected TypeArguments type_arguments;
 
  		SimpleName simple_name;
 		protected TypeSpec queried_type;
 
 		public MethodGroupExpr (IList<MemberSpec> mi, TypeSpec type, Location loc)
 		{
 			Methods = mi;
 			this.loc = loc;
 			this.type = InternalType.MethodGroup;
 
 			eclass = ExprClass.MethodGroup;
 			queried_type = type;
 		}
]]></clone_fragment>
<clone_fragment endline="1381" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" hamdist="7" pcid="3209" startline="1247"><![CDATA[
 
 		static Expression ImplicitConversionStandard (ResolveContext ec, Expression expr, TypeSpec target_type, Location loc, bool explicit_cast)
 		{
 			if (expr.eclass == ExprClass.MethodGroup){
 				if (!TypeManager.IsDelegateType (target_type)){
 					return null;
 				}
 
 				//
 				// Only allow anonymous method conversions on post ISO_1
 				//
 				if (RootContext.Version != LanguageVersion.ISO_1){
 					MethodGroupExpr mg = expr as MethodGroupExpr;
 					if (mg != null)
 						return ImplicitDelegateCreation.Create (
 							ec, mg, target_type, loc);
 				}
 			}
 
 			TypeSpec expr_type = expr.Type;
 			Expression e;
 
 			if (expr_type == target_type) {
 				if (expr_type != InternalType.Null && expr_type != InternalType.AnonymousMethod)
 					return expr;
 				return null;
 			}
 
 			if (expr_type == InternalType.Dynamic) {
 				switch (target_type.Kind) {
 				case MemberKind.ArrayType
 				case MemberKind.Class
 					if (target_type == TypeManager.object_type)
 						return EmptyCast.Create (expr, target_type);
 
 					goto case MemberKind.Struct;
 				case MemberKind.Struct
 					// TODO
 					if (target_type == TypeManager.void_type)
 						return null;
 
 					goto case MemberKind.Enum;
 				case MemberKind.Delegate
 				case MemberKind.Enum
 				case MemberKind.Interface
 				case MemberKind.TypeParameter
 					Arguments args = new Arguments (1);
 					args.Add (new Argument (expr));
 					return new DynamicConversion (target_type, explicit_cast ? CSharpBinderFlags.ConvertExplicit 
 				}
 
 				return null;
 			}
 
 			if (TypeManager.IsNullableType (target_type))
 				return ImplicitNulableConversion (ec, expr, target_type);
 
 			//
 			// Attempt to do the implicit constant expression conversions
 			//
 			Constant c = expr as Constant;
 			if (c != null) {
 				try {
 					c = c.ConvertImplicitly (ec, target_type);
 				} catch {
 					Console.WriteLine ("Conversion error happened in line {0}", loc);
 					throw;
 				}
 				if (c != null)
 					return c;
 			}
 
 			e = ImplicitNumericConversion (expr, expr_type, target_type);
 			if (e != null)
 				return e;
 
 			e = ImplicitReferenceConversion (expr, target_type, explicit_cast);
 			if (e != null)
 				return e;
 
 			if (expr is IntegralConstant && TypeManager.IsEnumType (target_type)){
 				var i = (IntegralConstant) expr;
 				//
 				// LAMESPEC
 				//
 				// An implicit enumeration conversion permits the decimal-integer-literal 0
 				// to be converted to any enum-type and to any nullable-type whose underlying
 				// type is an enum-type
 				//
 				if (i.IsZeroInteger) {
 					// Recreate 0 literal to remove any collected conversions
 					return new EnumConstant (new IntLiteral (0, i.Location), target_type).Resolve (ec);
 				}
 			}
 
 			if (ec.IsUnsafe) {
 				var target_pc = target_type as PointerContainer;
 				if (target_pc != null) {
 					if (expr_type.IsPointer) {
 						//
 						// Pointer types are same when they have same element types
 						//
 						if (expr_type == target_pc)
 							return expr;
 
 						if (target_pc.Element.BuildinType == BuildinTypeSpec.Type.Void)
 							return EmptyCast.Create (expr, target_type);
 
 						//return null;
 					}
 
 					if (expr_type == InternalType.Null)
 						return EmptyCast.Create (new NullPointer (loc), target_type);
 				}
 			}
 
 			if (expr_type == InternalType.AnonymousMethod){
 				AnonymousMethodExpression ame = (AnonymousMethodExpression) expr;
 				Expression am = ame.Compatible (ec, target_type);
 				if (am != null)
 					return am.Resolve (ec);
 			}
 
 			if (expr_type == InternalType.Arglist && target_type == TypeManager.arg_iterator_type)
 				return expr;
 
 			if (TypeSpecComparer.IsEqual (expr_type, target_type)) {
 				if (expr_type == target_type)
 					return expr;
 
 				return EmptyCast.Create (expr, target_type);
 			}
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="2880" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="6" pcid="3735" startline="2728"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (left == null)
 				return null;
 
 			if ((oper == Operator.Subtraction) && (left is ParenthesizedExpression)) {
 				left = ((ParenthesizedExpression) left).Expr;
 				left = left.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.Type);
 				if (left == null)
 					return null;
 
 				if (left.eclass == ExprClass.Type) {
 					ec.Report.Error (75, loc, "To cast a negative value, you must enclose the value in parentheses");
 					return null;
 				}
 			} else
 				left = left.Resolve (ec);
 
 			if (left == null)
 				return null;
 
 			Constant lc = left as Constant;
 
 			if (lc != null && lc.Type == TypeManager.bool_type &&
 				((oper == Operator.LogicalAnd && lc.IsDefaultValue) ||
 				 (oper == Operator.LogicalOr && !lc.IsDefaultValue))) {
 
 				// FIXME
 				// right.Resolve (ec);
 
 				ec.Report.Warning (429, 4, loc, "Unreachable expression code detected");
 				return left;
 			}
 
 			right = right.Resolve (ec);
 			if (right == null)
 				return null;
 
 			eclass = ExprClass.Value;
 			Constant rc = right as Constant;
 
 			// The conversion rules are ignored in enum context but why
 			if (!ec.HasSet (ResolveContext.Options.EnumScope) && lc != null && rc != null && (TypeManager.IsEnumType (left.Type) || TypeManager.IsEnumType (right.Type))) {
 				lc = EnumLiftUp (ec, lc, rc, loc);
 				if (lc != null)
 					rc = EnumLiftUp (ec, rc, lc, loc);
 			}
 
 			if (rc != null && lc != null) {
 				int prev_e = ec.Report.Errors;
 				Expression e = ConstantFold.BinaryFold (ec, oper, lc, rc, loc);
 				if (e != null)
 					e = e.Resolve (ec);
 
 				if (e != null || ec.Report.Errors != prev_e)
 					return e;
 			}
 
 			// Comparison warnings
 			if ((oper & Operator.ComparisonMask) != 0) {
 				if (left.Equals (right)) {
 					ec.Report.Warning (1718, 3, loc, "A comparison made to same variable. Did you mean to compare something else?");
 				}
 				CheckUselessComparison (ec, lc, right.Type);
 				CheckUselessComparison (ec, rc, left.Type);
 			}
 
 			if (left.Type == InternalType.Dynamic || right.Type == InternalType.Dynamic) {
 				var lt = left.Type;
 				var rt = right.Type;
 				if (lt == TypeManager.void_type || lt == InternalType.MethodGroup || lt == InternalType.AnonymousMethod ||
 					rt == TypeManager.void_type || rt == InternalType.MethodGroup || rt == InternalType.AnonymousMethod) {
 					Error_OperatorCannotBeApplied (ec, left, right);
 					return null;
 				}
 
 				Arguments args;
 
 				//
 				// Special handling for logical boolean operators which require rhs not to be
 				// evaluated based on lhs value
 				//
 				if ((oper & Operator.LogicalMask) != 0) {
 					Expression cond_left, cond_right, expr;
 
 					args = new Arguments (2);
 
 					if (lt == InternalType.Dynamic) {
 						LocalVariable temp = LocalVariable.CreateCompilerGenerated (lt, ec.CurrentBlock, loc);
 
 						var cond_args = new Arguments (1);
 						cond_args.Add (new Argument (new SimpleAssign (temp.CreateReferenceExpression (ec, loc), left).Resolve (ec)));
 
 						//
 						// dynamic && bool => IsFalse (temp = left) ? temp 
 						// dynamic || bool => IsTrue (temp = left) ? temp 
 						//
 						left = temp.CreateReferenceExpression (ec, loc);
 						if (oper == Operator.LogicalAnd) {
 							expr = DynamicUnaryConversion.CreateIsFalse (cond_args, loc);
 							cond_left = left;
 						} else {
 							expr = DynamicUnaryConversion.CreateIsTrue (cond_args, loc);
 							cond_left = left;
 						}
 
 						args.Add (new Argument (left));
 						args.Add (new Argument (right));
 						cond_right = new DynamicExpressionStatement (this, args, loc);
 					} else {
 						LocalVariable temp = LocalVariable.CreateCompilerGenerated (TypeManager.bool_type, ec.CurrentBlock, loc);
 
 						args.Add (new Argument (temp.CreateReferenceExpression (ec, loc).Resolve (ec)));
 						args.Add (new Argument (right));
 						right = new DynamicExpressionStatement (this, args, loc);
 
 						//
 						// bool && dynamic => (temp = left) ? temp && right 
 						// bool || dynamic => (temp = left) ? temp 
 						//
 						if (oper == Operator.LogicalAnd) {
 							cond_left = right;
 							cond_right = temp.CreateReferenceExpression (ec, loc);
 						} else {
 							cond_left = temp.CreateReferenceExpression (ec, loc);
 							cond_right = right;
 						}
 
 						expr = new BooleanExpression (new SimpleAssign (temp.CreateReferenceExpression (ec, loc), left));
 					}
 
 					return new Conditional (expr, cond_left, cond_right, loc).Resolve (ec);
 				}
 
 				args = new Arguments (2);
 				args.Add (new Argument (left));
 				args.Add (new Argument (right));
 				return new DynamicExpressionStatement (this, args, loc).Resolve (ec);
 			}
 
 			if (RootContext.Version >= LanguageVersion.ISO_2 &&
 				((TypeManager.IsNullableType (left.Type) && (right is NullLiteral || TypeManager.IsNullableType (right.Type) || TypeManager.IsValueType (right.Type))) ||
 				(TypeManager.IsValueType (left.Type) && right is NullLiteral) ||
 				(TypeManager.IsNullableType (right.Type) && (left is NullLiteral || TypeManager.IsNullableType (left.Type) || TypeManager.IsValueType (left.Type))) ||
 				(TypeManager.IsValueType (right.Type) && left is NullLiteral))) {
 				var lifted = new Nullable.LiftedBinaryOperator (oper, left, right, loc);
 				lifted.state = state;
 				return lifted.Resolve (ec);
 			}
 
 			return DoResolveCore (ec, left, right);
 		}
]]></clone_fragment>
<clone_fragment endline="1123" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" hamdist="11" pcid="123" startline="978"><![CDATA[
 
 		readonly string name;
 
 		InternalType (string name, MemberCache cache)
 			
 		{
 			this.cache = cache;
 		}
 
 		InternalType (string name)
 			
 		{
 			this.name = name;
 			this.definition = this;
 			cache = MemberCache.Empty;
 
 			// Make all internal types CLS-compliant, non-obsolete
 			state = (state & ~(StateFlags.CLSCompliant_Undetected | StateFlags.Obsolete_Undetected)) | StateFlags.CLSCompliant;
 		}
 
 		#region Properties
 
 		public override int Arity {
 			get {
 				return 0;
 			}
 		}
 
 		IAssemblyDefinition ITypeDefinition.DeclaringAssembly {
 			get {
 				throw new NotImplementedException ();
 			}
 		}
 
 		bool IMemberDefinition.IsImported {
 			get {
 				return false;
 			}
 		}
 
 		public override string Name {
 			get {
 				return name;
 			}
 		}
 
 		string ITypeDefinition.Namespace {
 			get {
 				return null;
 			}
 		}
 
 		int ITypeDefinition.TypeParametersCount {
 			get {
 				return 0;
 			}
 		}
 
 		TypeParameterSpec[] ITypeDefinition.TypeParameters {
 			get {
 				return null;
 			}
 		}
 
 		#endregion
 
 		public override string GetSignatureForError ()
 		{
 			return name;
 		}
 
 		#region ITypeDefinition Members
 
 		TypeSpec ITypeDefinition.GetAttributeCoClass ()
 		{
 			return null;
 		}
 
 		string ITypeDefinition.GetAttributeDefaultMember ()
 		{
 			return null;
 		}
 
 		AttributeUsageAttribute ITypeDefinition.GetAttributeUsage (PredefinedAttribute pa)
 		{
 			return null;
 		}
 
 		bool ITypeDefinition.IsInternalAsPublic (IAssemblyDefinition assembly)
 		{
 			throw new NotImplementedException ();
 		}
 
 		void ITypeDefinition.LoadMembers (TypeSpec declaringType, bool onlyTypes, ref MemberCache cache)
 		{
 			throw new NotImplementedException ();
 		}
 
 		string[] IMemberDefinition.ConditionalConditions ()
 		{
 			return null;
 		}
 
 		ObsoleteAttribute IMemberDefinition.GetAttributeObsolete ()
 		{
 			return null;
 		}
 
 		bool IMemberDefinition.IsNotCLSCompliant ()
 		{
 			return false;
 		}
 
 		void IMemberDefinition.SetIsAssigned ()
 		{
 		}
 
 		void IMemberDefinition.SetIsUsed ()
 		{
 		}
 
 		#endregion
 	}
 
 	public abstract class ElementTypeSpec 
 	{
 		protected ElementTypeSpec (MemberKind kind, TypeSpec element, MetaType info)
 			
 		{
 			this.Element = element;
 
 			// Some flags can be copied directly from the element
 			const StateFlags shared_flags = StateFlags.CLSCompliant | StateFlags.CLSCompliant_Undetected
 				| StateFlags.Obsolete | StateFlags.Obsolete_Undetected | StateFlags.HasDynamicElement;
 			state &= ~shared_flags;
 			state |= (element.state & shared_flags);
 
 			if (element == InternalType.Dynamic)
 				state |= StateFlags.HasDynamicElement;
 
 			// Has to use its own type definition instead of just element definition to
 			// correctly identify itself for cases like x.MemberDefininition == predefined.MemberDefinition
 			this.definition = this;
 
 			cache = MemberCache.Empty;
 		}
]]></clone_fragment>
<clone_fragment endline="552" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Compiler.vb" hamdist="11" pcid="7487" startline="407"><![CDATA[
 
     ''' <summary>
     ''' Compile with the current options.
     ''' </summary>
     ''' <remarks></remarks>
     Function Compile() As Integer
         Dim result As Boolean = True
         BaseObject.ClearCache()
         Try
             'Show help if asked to
             If CommandLine.Help = True Then
                 If CommandLine.NoLogo = False Then
                     ShowLogo()
                 End If
                 ShowHelp()
                 Return 0
             End If
 
             'Show logo, unless asked not to
             If CommandLine.NoLogo = False Then ShowLogo()
 
             If Report.ShowSavedMessages Then
                 Return 1
             End If
 
             'Set the culture to en-us to enable correct parsing of numbers, dates, etc.
             Threading.Thread.CurrentThread.CurrentCulture = Globalization.CultureInfo.GetCultureInfo("en-us")
 
             'Exit if no source files were specified
             If m_CommandLine.Files.Count = 0 Then
                 Report.ShowMessage(Messages.VBNC2011, Span.CommandLineSpan)
                 Return 1
             End If
 
             'Set the library of the .net system dir
             m_CommandLine.LibPath.Add(GetSystemDir)
 
             'Load the referenced assemblies
             If Not CommandLine.References.Contains("mscorlib.dll") Then
                 CommandLine.References.Add("mscorlib.dll")
             End If
 
             If Not String.IsNullOrEmpty(CommandLine.VBRuntime) Then
                 CommandLine.References.Add(CommandLine.VBRuntime)
             End If
 
             m_Helper = New Helper(Me)
             m_Helper = New Helper(Me)
 
             'Calculate the output filename
             result = Compile_CalculateOutputFilename() AndAlso result
 
             'Load all the referenced assemblies and load all the types and namespaces into the type manager
             m_TypeCache = New CecilTypeCache(Me)
 
             result = GenerateMy() AndAlso result
 
             result = m_TypeManager.LoadReferenced AndAlso result
             If Report.Errors > 0 Then GoTo ShowErrors
 
             m_TypeResolver = New TypeResolution(Me)
 
             'Create the assembly and module builders
             result = Compile_CreateAssemblyAndModuleBuilders() AndAlso result
             VerifyConsistency(result, "CreateAssemblyAndModuleBuilders")
 
             'Parse the code into the type tree
             result = Compile_Parse() AndAlso result
             If Report.Errors > 0 Then GoTo ShowErrors
 
             m_TypeManager.LoadCompiledTypes()
 
             If String.IsNullOrEmpty(CommandLine.VBRuntime) Then
                 m_TypeCache.InitInternalVB()
             End If
 
             result = Compile_Resolve() AndAlso result
             If Report.Errors > 0 Then GoTo ShowErrors
 
             result = Me.Assembly.SetCecilName(AssemblyBuilderCecil.Name) AndAlso result
 
             result = AddResources() AndAlso result
             If result = False Then GoTo ShowErrors
 
             'Passed this step no errors should be found...
 
             result = theAss.DefineTypes AndAlso result
             VerifyConsistency(result, "DefineTypes")
 
             result = theAss.DefineTypeHierarchy AndAlso result
             VerifyConsistency(result, "DefineTypeHierarchy")
 
             result = theAss.DefineMembers AndAlso result
             VerifyConsistency(result, "DefineMembers")
 
             result = theAss.Emit AndAlso result
             VerifyConsistency(result, "Emit")
 
             'Set the main function / entry point
             result = SetMain() AndAlso result
             If result = False Then GoTo ShowErrors
 
             If result = False Then
                 Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Error creating the assembly!")
                 GoTo ShowErrors
             End If
 
             Dim writerParameters As New WriterParameters()
             writerParameters.WriteSymbols = EmittingDebugInfo
             AssemblyBuilderCecil.Write(m_OutFilename, writerParameters)
 
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, String.Format("Assembly '{0}' saved successfully to '{1}'.", AssemblyBuilderCecil.Name.FullName, m_OutFilename))
 
 ShowErrors
             VerifyConsistency(result, "ShowErrors")
 
             If Report.Errors > 0 Or Report.Warnings > 0 Then
                 Compiler.Report.WriteLine("There were " & Report.Errors.ToString & " errors and " & Report.Warnings.ToString & " warnings.")
             End If
             If Report.Errors = 0 Then
                 Compiler.Report.WriteLine("Compilation successful")
                 result = True
             Else
                 result = False
             End If
 
 EndOfCompilation
             result = Report.Errors = 0 AndAlso result
 
             If result Then
                 Return 0
             Else
                 Return 1
             End If
         Catch ex As TooManyErrorsException
             Report.ShowMessage(Messages.VBNC30041, Span.CommandLineSpan)
             Return 1
         Catch ex As Exception
             ShowExceptionInfo(ex)
             Return -1
         Finally
             BaseObject.ClearCache()
         End Try
         vbnc.Helper.Assert(False, "End of program reached!")
         Return 1
     End Function
]]></clone_fragment>
<clone_fragment endline="1573" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" hamdist="9" pcid="2185" startline="1469"><![CDATA[
 
 		protected virtual bool DoDefineMembers ()
 		{
 			if (iface_exprs != null) {
 				foreach (TypeExpr iface in iface_exprs) {
 					if (iface == null)
 						continue;
 
 					var iface_type = iface.Type;
 
 					// Ensure the base is always setup
 					var compiled_iface = iface_type.MemberDefinition as Interface;
 					if (compiled_iface != null)
 						compiled_iface.Define ();
 
 					if (Kind == MemberKind.Interface)
 						MemberCache.AddInterface (iface_type);
 
 					ObsoleteAttribute oa = iface_type.GetAttributeObsolete ();
 					if (oa != null && !IsObsolete)
 						AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 
 					GenericTypeExpr ct = iface as GenericTypeExpr;
 					if (ct != null) {
 						// TODO
 						TypeManager.CheckTypeVariance (ct.Type, Variance.Covariant, this);
 
 						ct.CheckConstraints (this);
 
 						if (ct.HasDynamicArguments () && !IsCompilerGenerated) {
 							Report.Error (1966, iface.Location,
 								"`{0}'
 								GetSignatureForError (), iface.GetSignatureForError ());
 							return false;
 						}
 					}
 				}
 				foreach (TypeExpr iface in iface_exprs) {
 					if (iface == null)
 						continue;
 
 					var iface_type = iface.Type;
 
 					// Ensure the base is always setup
 					var compiled_iface = iface_type.MemberDefinition as Interface;
 					if (compiled_iface != null)
 						compiled_iface.Define ();
 
 					if (Kind == MemberKind.Interface)
 						MemberCache.AddInterface (iface_type);
 
 					ObsoleteAttribute oa = iface_type.GetAttributeObsolete ();
 					if (oa != null && !IsObsolete)
 						AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 
 					GenericTypeExpr ct = iface as GenericTypeExpr;
 					if (ct != null) {
 						// TODO
 						TypeManager.CheckTypeVariance (ct.Type, Variance.Covariant, this);
 
 						ct.CheckConstraints (this);
 
 						if (ct.HasDynamicArguments () && !IsCompilerGenerated) {
 							Report.Error (1966, iface.Location,
 								"`{0}'
 								GetSignatureForError (), iface.GetSignatureForError ());
 							return false;
 						}
 					}
 				}
 			}
 
 			if (base_type != null) {
 				ObsoleteAttribute obsolete_attr = base_type.GetAttributeObsolete ();
 				if (obsolete_attr != null && !IsObsolete)
 					AttributeTester.Report_ObsoleteMessage (obsolete_attr, base_type.GetSignatureForError (), Location, Report);
 
 				var ct = base_type_expr as GenericTypeExpr;
 				if (ct != null)
 					ct.CheckConstraints (this);
 
 				if (base_type.Interfaces != null) {
 					foreach (var iface in base_type.Interfaces)
 						spec.AddInterface (iface);
 					foreach (var iface in base_type.Interfaces)
 						spec.AddInterface (iface);
 				}
 
 				var baseContainer = base_type.MemberDefinition as ClassOrStruct;
 				if (baseContainer != null) {
 					baseContainer.Define ();
 
 					//
 					// It can trigger define of this type (for generic types only)
 					//
 					if (HasMembersDefined)
 						return true;
 				}
 			}
 
 			if (type_params != null) {
 				foreach (var tp in type_params) {
 					tp.CheckGenericConstraints ();
 				}
 				foreach (var tp in type_params) {
 					tp.CheckGenericConstraints ();
 				}
 			}
 
 			DefineContainerMembers (constants);
 			DefineContainerMembers (fields);
 
 			if (Kind == MemberKind.Struct || Kind == MemberKind.Class) {
 				pending = PendingImplementation.GetPendingImplementations (this);
 
 				if (requires_delayed_unmanagedtype_check) {
 					requires_delayed_unmanagedtype_check = false;
 					foreach (FieldBase f in fields) {
 						if (f.MemberType != null && f.MemberType.IsPointer)
 							TypeManager.VerifyUnmanaged (Compiler, f.MemberType, f.Location);
 					}
 					foreach (FieldBase f in fields) {
 						if (f.MemberType != null && f.MemberType.IsPointer)
 							TypeManager.VerifyUnmanaged (Compiler, f.MemberType, f.Location);
 					}
 				}
 			}
 		
 			//
 			// Constructors are not in the defined_names array
 			//
 			DefineContainerMembers (instance_constructors);
 		
 			DefineContainerMembers (events);
 			DefineContainerMembers (ordered_explicit_member_list);
 			DefineContainerMembers (ordered_member_list);
 
 			if (operators != null) {
 				DefineContainerMembers (operators);
 				CheckPairedOperators ();
 			}
 
 			ComputeIndexerName();
 			CheckEqualsAndGetHashCode();
 
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="519" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" hamdist="10" pcid="1025" startline="349"><![CDATA[
 
 		TypeBuilder fixed_buffer_type;
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.UNSAFE;
 
 		public FixedField (DeclSpace parent, FullNamedExpression type, Modifiers mod, MemberName name, Attributes attrs)
 			
 		{
 		}
 
 		#region Properties
 
 		//
 		// Explicit struct layout set by parent
 		//
 		public CharSet? CharSet {
 			get; set;
 		}		
 
 		#endregion
 
 		public override Constant ConvertInitializer (ResolveContext rc, Constant expr)
 		{
 			return expr.ImplicitConversionRequired (rc, TypeManager.int32_type, Location);
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!TypeManager.IsPrimitiveType (MemberType)) {
 				Report.Error (1663, Location,
 					"`{0}'
 					GetSignatureForError ());
 			} else if (declarators != null) {
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Fields.IndexOf (this);
 				foreach (var d in declarators) {
 					var f = new FixedField (Parent, t, ModFlags, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					f.initializer = d.Initializer;
 					((ConstInitializer) f.initializer).Name = d.Name.Value;
 					Parent.PartialContainer.Fields.Insert (++index, f);
 				}
 			}
 			
 			// Create nested fixed buffer container
 			string name = String.Format ("<{0}>__FixedBuffer{1}", Name, GlobalCounter++);
 			fixed_buffer_type = Parent.TypeBuilder.DefineNestedType (name, Parent.Module.DefaultCharSetType |
 				TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit, TypeManager.value_type.GetMetaInfo ());
 
 			fixed_buffer_type.DefineField (FixedElementName, MemberType.GetMetaInfo (), FieldAttributes.Public);
 			
 			FieldBuilder = Parent.TypeBuilder.DefineField (Name, fixed_buffer_type, ModifiersExtensions.FieldAttr (ModFlags));
 			var element_spec = new FieldSpec (null, this, MemberType, FieldBuilder, ModFlags);
 			spec = new FixedFieldSpec (Parent.Definition, this, FieldBuilder, element_spec, ModFlags);
 
 			Parent.MemberCache.AddMember (spec);
 			return true;
 		}
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			if (!IsUnsafe)
 				Expression.UnsafeError (Report, Location);
 
 			if (Parent.PartialContainer.Kind != MemberKind.Struct) {
 				Report.Error (1642, Location, "`{0}'
 					GetSignatureForError ());
 			}
 		}
 
 		public override void Emit()
 		{
 			ResolveContext rc = new ResolveContext (this);
 			IntConstant buffer_size_const = initializer.Resolve (rc) as IntConstant;
 			if (buffer_size_const == null)
 				return;
 
 			int buffer_size = buffer_size_const.Value;
 
 			if (buffer_size <= 0) {
 				Report.Error (1665, Location, "`{0}'
 				return;
 			}
 
 			int type_size = Expression.GetTypeSize (MemberType);
 
 			if (buffer_size > int.MaxValue / type_size) {
 				Report.Error (1664, Location, "Fixed size buffer `{0}' of length `{1}' and type `{2}' exceeded 2^31 limit",
 					GetSignatureForError (), buffer_size.ToString (), TypeManager.CSharpName (MemberType));
 				return;
 			}
 
 			EmitFieldSize (buffer_size);
 
 			Module.PredefinedAttributes.UnsafeValueType.EmitAttribute (fixed_buffer_type);
 			Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (fixed_buffer_type);
 			fixed_buffer_type.CreateType ();
 
 			base.Emit ();
 		}
 
 		void EmitFieldSize (int buffer_size)
 		{
 			PredefinedAttribute pa;
 			AttributeEncoder encoder;
 
 			pa = Module.PredefinedAttributes.StructLayout;
 			if (pa.Constructor == null && !pa.ResolveConstructor (Location, TypeManager.short_type))
 				return;
 
 			var char_set_type = Module.PredefinedTypes.CharSet.Resolve (Location);
 			if (char_set_type == null)
 				return;
 
 			var field_size = pa.GetField ("Size", TypeManager.int32_type, Location);
 			var field_charset = pa.GetField ("CharSet", char_set_type, Location);
 			if (field_size == null || field_charset == null)
 				return;
 
 			var char_set = CharSet ?? Module.DefaultCharSet;
 
 			encoder = new AttributeEncoder ();
 			encoder.Encode ((short)LayoutKind.Sequential);
 			encoder.EncodeNamedArguments (
 				new [] { field_size, field_charset },
 				new Constant [] { new IntConstant (buffer_size, Location), new IntConstant ((int) char_set, Location) }
 			);
 
 			pa.EmitAttribute (fixed_buffer_type, encoder);
 
 			//
 			// Don't emit FixedBufferAttribute attribute for private types
 			//
 			if ((ModFlags & Modifiers.PRIVATE) != 0)
 				return;
 
 			pa = Module.PredefinedAttributes.FixedBuffer;
 			if (pa.Constructor == null && !pa.ResolveConstructor (Location, TypeManager.type_type, TypeManager.int32_type))
 				return;
 
 			encoder = new AttributeEncoder ();
 			encoder.EncodeTypeName (MemberType);
 			encoder.Encode (buffer_size);
 			encoder.EncodeEmptyNamedArguments ();
 
 			pa.EmitAttribute (FieldBuilder, encoder);
 		}
 	}
 
 	class FixedFieldSpec 
 	{
 		readonly FieldSpec element;
 
 		public FixedFieldSpec (TypeSpec declaringType, IMemberDefinition definition, FieldInfo info, FieldSpec element, Modifiers modifiers)
 			
 		{
 			this.element = element;
 
 			// It's never CLS-Compliant
 			state &= ~StateFlags.CLSCompliant_Undetected;
 		}
]]></clone_fragment>
<clone_fragment endline="414" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" hamdist="7" pcid="1923" startline="242"><![CDATA[
 
 			internal const string Prefix = "set_";
 
 			protected ParametersCompiled parameters;
 
 			public SetMethod (PropertyBase method, Modifiers modifiers, ParametersCompiled parameters, Attributes attrs, Location loc)
 				
 			{
 				this.parameters = parameters;
 			}
 
 			protected override void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Target == AttributeTargets.Parameter) {
 					parameters[0].ApplyAttributeBuilder (a, ctor, cdata, pa);
 					return;
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override ParametersCompiled ParameterInfo {
 			    get {
 			        return parameters;
 			    }
 			}
 
 			public override MethodBuilder Define (DeclSpace parent)
 			{
 				parameters.Resolve (this);
 				
 				base.Define (parent);
 
 				Spec = new MethodSpec (MemberKind.Method, parent.PartialContainer.Definition, this, ReturnType, null, ParameterInfo, ModFlags);
 
 				method_data = new MethodData (method, ModFlags, flags, this);
 
 				if (!method_data.Define (parent, method.GetFullName (MemberName), Report))
 					return null;
 
 				Spec.SetMetaInfo (method_data.MethodBuilder);
 
 				return method_data.MethodBuilder;
 			}
 
 			public override TypeSpec ReturnType {
 				get {
 					return TypeManager.void_type;
 				}
 			}
 
 			public override string[] ValidAttributeTargets {
 				get {
 					return attribute_targets;
 				}
 			}
 		}
 
 		static string[] attribute_targets = new string [] { "property" };
 
 		public abstract class PropertyMethod 
 		{
 			public const Modifiers AllowedModifiers =
 				Modifiers.PUBLIC |
 				Modifiers.PROTECTED |
 				Modifiers.INTERNAL |
 				Modifiers.PRIVATE;
 		
 			protected readonly PropertyBase method;
 			protected MethodAttributes flags;
 
 			public PropertyMethod (PropertyBase method, string prefix, Modifiers modifiers, Attributes attrs, Location loc)
 				
 			{
 				this.method = method;
 				this.ModFlags = modifiers | (method.ModFlags & (Modifiers.STATIC | Modifiers.UNSAFE));
 			}
 
 			public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Type == pa.MethodImpl) {
 					method.is_external_implementation = a.IsInternalCall ();
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override AttributeTargets AttributeTargets {
 				get {
 					return AttributeTargets.Method;
 				}
 			}
 
 			public override bool IsClsComplianceRequired ()
 			{
 				return method.IsClsComplianceRequired ();
 			}
 
 			public virtual MethodBuilder Define (DeclSpace parent)
 			{
 				TypeContainer container = parent.PartialContainer;
 
 				//
 				// Check for custom access modifier
 				//
 				if ((ModFlags & Modifiers.AccessibilityMask) == 0) {
 					ModFlags |= method.ModFlags;
 					flags = method.flags;
 				} else {
 					if (container.Kind == MemberKind.Interface)
 						Report.Error (275, Location, "`{0}'
 							GetSignatureForError ());
 
 					if ((method.ModFlags & Modifiers.ABSTRACT) != 0 && (ModFlags & Modifiers.PRIVATE) != 0) {
 						Report.Error (442, Location, "`{0}'
 					}
 
 					CheckModifiers (ModFlags);
 					ModFlags |= (method.ModFlags & (~Modifiers.AccessibilityMask));
 					ModFlags |= Modifiers.PROPERTY_CUSTOM;
 					flags = ModifiersExtensions.MethodAttr (ModFlags);
 					flags |= (method.flags & (~MethodAttributes.MemberAccessMask));
 				}
 
 				CheckAbstractAndExtern (block != null);
 				CheckProtectedModifier ();
 
 				if (block != null && block.IsIterator)
 					Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 
 				return null;
 			}
 
 			public bool HasCustomAccessModifier {
 				get {
 					return (ModFlags & Modifiers.PROPERTY_CUSTOM) != 0;
 				}
 			}
 
 			public PropertyBase Property {
 				get {
 					return method;
 				}
 			}
 
 			public override ObsoleteAttribute GetAttributeObsolete ()
 			{
 				return method.GetAttributeObsolete ();
 			}
 
 			public override string GetSignatureForError()
 			{
 				return method.GetSignatureForError () + "." + prefix.Substring (0, 3);
 			}
 
 			void CheckModifiers (Modifiers modflags)
 			{
 				if (!ModifiersExtensions.IsRestrictedModifier (modflags & Modifiers.AccessibilityMask, method.ModFlags & Modifiers.AccessibilityMask)) {
 					Report.Error (273, Location,
 						"The accessibility modifier of the `{0}' accessor must be more restrictive than the modifier of the property or indexer `{1}'",
 						GetSignatureForError (), method.GetSignatureForError ());
 				}
 			}
 		}
 
 		PropertyMethod get, set, first;
 		PropertyBuilder PropertyBuilder;
 
 		public PropertyBase (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags,
 				     Modifiers allowed_mod, MemberName name, Attributes attrs)
 			
 		{
 		}
]]></clone_fragment>
<clone_fragment endline="1619" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" hamdist="5" pcid="3977" startline="1447"><![CDATA[
 
 		//
 		// Main compilation method
 		//
 		public bool Compile ()
 		{
 			var module = new ModuleContainer (ctx);
 			RootContext.ToplevelTypes = module;
 
 			if (timestamps) {
 				stopwatch = Stopwatch.StartNew ();
 				first_time = DateTime.Now;
 			}
 
 			Parse (module);
 			ShowTime ("Parsing source files");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (RootContext.TokenizeOnly || RootContext.ParseOnly)
 				return true;
 
 			if (RootContext.ToplevelTypes.NamespaceEntry != null)
 				throw new InternalErrorException ("who set it?");
 
 			//
 			// Quick hack
 			//
 			var output_file = RootContext.OutputFile;
 			string output_file_name;
 			if (output_file == null) {
 				if (first_source == null) {
 					Report.Error (1562, "If no source files are specified you must specify the output file with -out
 					return false;
 				}
 
 				int pos = first_source.LastIndexOf ('.');
 
 				if (pos > 0)
 					output_file = first_source.Substring (0, pos) + RootContext.TargetExt;
 				else
 					output_file = first_source + RootContext.TargetExt;
 
 				output_file_name = output_file;
 			} else {
 				output_file_name = Path.GetFileName (output_file);
 			}
 
 			//
 			// Load assemblies required
 			//
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 #if STATIC
 			var assembly = new AssemblyDefinitionStatic (module, output_file_name, output_file);
 			module.SetDeclaringAssembly (assembly);
 
 			var importer = new StaticImporter ();
 			assembly.Importer = importer;
 
 			var loader = new StaticLoader (importer, ctx);
 			loader.LoadReferences (module);
 
 			ShowTime ("Imporing referenced assemblies");
 
 			if (!ctx.BuildinTypes.CheckDefinitions (module))
 				return false;
 
 			ShowTime ("Initializing predefined types");
 
 			if (!assembly.Create (loader))
 				return false;
 
 			// System.Object was not loaded, use compiled assembly as corlib
 			if (loader.Corlib == null)
 				loader.Corlib = assembly.Builder;
 
 			loader.LoadModules (assembly, module.GlobalRootNamespace);
 #else
 			var assembly = new AssemblyDefinitionDynamic (module, output_file_name, output_file);
 			module.SetDeclaringAssembly (assembly);
 
 			var importer = new ReflectionImporter (ctx.BuildinTypes);
 			assembly.Importer = importer;
 
 			var loader = new DynamicLoader (importer, ctx);
 			loader.LoadReferences (module);
 
 			ShowTime ("Imporing referenced assemblies");
 
 			if (!ctx.BuildinTypes.CheckDefinitions (module))
 				return false;
 
 			ShowTime ("Initializing predefined types");
 
 			if (!assembly.Create (AppDomain.CurrentDomain, AssemblyBuilderAccess.Save))
 				return false;
 
 			loader.LoadModules (assembly, module.GlobalRootNamespace);
 #endif
 			module.Define ();
 
 			ShowTime ("Types definition");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (Report.Errors == 0 &&
 				RootContext.Documentation != null &&
 				!RootContext.Documentation.OutputDocComment (
 					output_file, Report))
 				return false;
 
 			//
 			// Verify using aliases now
 			//
 			NamespaceEntry.VerifyAllUsing ();
 			
 			if (Report.Errors > 0){
 				return false;
 			}
 
 			assembly.Resolve ();
 			
 			if (Report.Errors > 0)
 				return false;
 			
 			//
 			// The code generator
 			//
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 			assembly.Emit ();
 
 			ShowTime ("Resolving and emitting members blocks");
 
 			if (Report.Errors > 0){
 				return false;
 			}
 
 			module.CloseType ();
 
 			ShowTime ("Closing types");
 
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 			assembly.EmbedResources ();
 			ShowTime ("Embedding resources");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 			
 			assembly.Save ();
 
 #if STATIC
 			loader.Dispose ();
 #endif
 
 			ShowTime ("Saving output assembly");
 
 			ShowTotalTime ("Total");
 
 			Timer.ShowTimers ();
 
 			return (Report.Errors == 0);
 		}
]]></clone_fragment>
<clone_fragment endline="246" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" hamdist="7" pcid="1809" startline="69"><![CDATA[
 	}
 
 	/// <summary>
 	/// Class for applying custom attributes on the return type
 	/// </summary>
 	public class ReturnParameter 
 	{
 		MemberCore method;
 
 		// TODO
 		public ReturnParameter (MemberCore method, MethodBuilder mb, Location location)
 		{
 			this.method = method;
 			try {
 				builder = mb.DefineParameter (0, ParameterAttributes.None, "");			
 			}
 			catch (ArgumentOutOfRangeException) {
 				method.Compiler.Report.RuntimeMissingSupport (location, "custom attributes on the return type");
 			}
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant) {
 				method.Compiler.Report.Warning (3023, 1, a.Location,
 					"CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead");
 			}
 
 			// This occurs after Warning -28
 			if (builder == null)
 				return;
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.ReturnValue;
 			}
 		}
 
 		/// <summary>
 		/// Is never called
 		/// </summary>
 		public override string[] ValidAttributeTargets {
 			get {
 				return null;
 			}
 		}
 	}
 
 	public class ImplicitLambdaParameter 
 	{
 		public ImplicitLambdaParameter (string name, Location loc)
 			
 		{
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (parameter_type == null)
 				throw new InternalErrorException ("A type of implicit lambda parameter `{0}' is not set",
 					Name);
 
 			base.idx = index;
 			return parameter_type;
 		}
 
 		public void SetParameterType (TypeSpec type)
 		{
 			parameter_type = type;
 		}
 	}
 
 	public class ParamsParameter 
 		public ParamsParameter (FullNamedExpression type, string name, Attributes attrs, Location loc)
 			base (type, name, Parameter.Modifier.PARAMS, attrs, loc)
 		{
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (base.Resolve (ec, index) == null)
 				return null;
 
 			var ac = parameter_type as ArrayContainer;
 			if (ac == null || ac.Rank != 1) {
 				ec.Compiler.Report.Error (225, Location, "The params parameter must be a single dimensional array");
 				return null;
 			}
 
 			return parameter_type;
 		}
 
 		public override void ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			base.ApplyAttributes (mb, cb, index, pa);
 			pa.ParamArray.EmitAttribute (builder);
 		}
 	}
 
 	public class ArglistParameter 
 		// Doesn't have proper type because it's never chosen for better conversion
 		public ArglistParameter (Location loc) 
 			base (null, String.Empty, Parameter.Modifier.NONE, null, loc)
 		{
 			parameter_type = InternalType.Arglist;
 		}
 
 		public override void  ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			// Nothing to do
 		}
 
 		public override bool CheckAccessibility (InterfaceMemberBase member)
 		{
 			return true;
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			return parameter_type;
 		}
 	}
 
 	public interface IParameterData
 	{
 		Expression DefaultValue { get; }
 		bool HasExtensionMethodModifier { get; }
 		bool HasDefaultValue { get; }
 		Parameter.Modifier ModFlags { get; }
 		string Name { get; }
 	}
 
 	//
 	// Parameter information created by parser
 	//
 	public class Parameter 
 	{
 		[Flags]
 		public enum Modifier 
 			NONE    = 0,
 			REF     = REFMASK | ISBYREF,
 			OUT     = OUTMASK | ISBYREF,
 			PARAMS  = 4,
 			// This is a flag which says that it's either REF or OUT.
 			ISBYREF = 8,
 			REFMASK	= 32,
 			OUTMASK = 64,
 			This	= 128
 		}
 
 		static string[] attribute_targets = new string [] { "param" };
 
 		FullNamedExpression texpr;
 		readonly Modifier modFlags;
 		string name;
 		Expression default_expr;
 		protected TypeSpec parameter_type;
 		readonly Location loc;
 		protected int idx;
 		public bool HasAddressTaken;
 
 		TemporaryVariableReference expr_tree_variable;
 		static TypeExpr parameter_expr_tree_type;
 
 		HoistedVariable hoisted_variant;
 
 		public Parameter (FullNamedExpression type, string name, Modifier mod, Attributes attrs, Location loc)
 		{
 			this.name = name;
 			modFlags = mod;
 			this.loc = loc;
 			texpr = type;
 
 			// Only assign, attributes will be attached during resolve
 			base.attributes = attrs;
 		}
]]></clone_fragment>
<clone_fragment endline="4867" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="3" pcid="1701" startline="4689"><![CDATA[
 		}
 	}
 
 	//
 	// Resolved reference to a local variable
 	//
 	public class LocalVariableReference 
 	{
 		public LocalVariable local_info;
 
 		public LocalVariableReference (LocalVariable li, Location l)
 		{
 			this.local_info = li;
 			loc = l;
 		}
 
 		public override VariableInfo VariableInfo {
 			get { return local_info.VariableInfo; }
 		}
 
 		public override HoistedVariable GetHoistedVariable (AnonymousExpression ae)
 		{
 			return local_info.HoistedVariant;
 		}
 
 		#region Properties
 
 		//		
 		// A local variable is always fixed
 		//
 		public override bool IsFixed {
 			get {
 				return true;
 			}
 		}
 
 		public override bool IsLockedByStatement {
 			get {
 				return local_info.IsLocked;
 			}
 			set {
 				local_info.IsLocked = value;
 			}
 		}
 
 		public override bool IsRef {
 			get { return false; }
 		}
 
 		public override string Name {
 			get { return local_info.Name; }
 		}
 
 		#endregion
 
 		public bool VerifyAssigned (ResolveContext ec)
 		{
 			VariableInfo variable_info = local_info.VariableInfo;
 			return variable_info == null || variable_info.IsAssigned (ec, loc);
 		}
 
 		public override void SetHasAddressTaken ()
 		{
 			local_info.AddressTaken = true;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			Arguments arg = new Arguments (1);
 			arg.Add (new Argument (this));
 			return CreateExpressionFactoryCall (ec, "Constant", arg);
 		}
 
 		void DoResolveBase (ResolveContext ec)
 		{
 			VerifyAssigned (ec);
 
 			//
 			// If we are referencing a variable from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (local_info)) {
 				if (local_info.AddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (ec.IsVariableCapturingRequired) {
 					AnonymousMethodStorey storey = local_info.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureLocalVariable (ec, local_info);
 				}
 			}
 
 			eclass = ExprClass.Variable;
 			type = local_info.Type;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			local_info.SetIsUsed ();
 
 			DoResolveBase (ec);
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			// is out param
 			if (right_side == EmptyExpression.OutAccess.Instance)
 				local_info.SetIsUsed ();
 
 			if (local_info.IsReadonly && !ec.HasAny (ResolveContext.Options.FieldInitializerScope | ResolveContext.Options.UsingInitializerScope)) {
 				int code;
 				string msg;
 				if (right_side == EmptyExpression.OutAccess.Instance) {
 					code = 1657; msg = "Cannot pass `{0}' as a ref or out argument because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberAccess) {
 					code = 1654; msg = "Cannot assign to members of `{0}' because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberOutAccess) {
 					code = 1655; msg = "Cannot pass members of `{0}' as ref or out arguments because it is a `{1}'";
 				} else if (right_side == EmptyExpression.UnaryAddress) {
 					code = 459; msg = "Cannot take the address of {1} `{0}'";
 				} else {
 					code = 1656; msg = "Cannot assign to `{0}' because it is a `{1}'";
 				}
 				ec.Report.Error (code, loc, msg, Name, local_info.GetReadOnlyContext ());
 			} else if (VariableInfo != null) {
 				VariableInfo.SetAssigned (ec);
 			}
 
 			DoResolveBase (ec);
 
 			return base.DoResolveLValue (ec, right_side);
 		}
 
 		public override int GetHashCode ()
 		{
 			return local_info.GetHashCode ();
 		}
 
 		public override bool Equals (object obj)
 		{
 			LocalVariableReference lvr = obj as LocalVariableReference;
 			if (lvr == null)
 				return false;
 
 			return local_info == lvr.local_info;
 		}
 
 		protected override ILocalVariable Variable {
 			get { return local_info; }
 		}
 
 		public override string ToString ()
 		{
 			return String.Format ("{0} ({1}
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			// Nothing
 		}
 	}
 
 	/// <summary>
 	///   This represents a reference to a parameter in the intermediate
 	///   representation.
 	/// </summary>
 	public class ParameterReference 
 	{
 		protected ParametersBlock.ParameterInfo pi;
 
 		public ParameterReference (ParametersBlock.ParameterInfo pi, Location loc)
 		{
 			this.pi = pi;
 			this.loc = loc;
 		}
]]></clone_fragment>
<clone_fragment endline="4703" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="3" pcid="4829" startline="4527"><![CDATA[
 	}
 
 	public abstract class VariableReference 
 		LocalTemporary temp;
 
 		#region Abstract
 		public abstract HoistedVariable GetHoistedVariable (AnonymousExpression ae);
 
 		public abstract bool IsLockedByStatement { get; set; }
 
 		public abstract bool IsFixed { get; }
 		public abstract bool IsRef { get; }
 		public abstract string Name { get; }
 		public abstract void SetHasAddressTaken ();
 
 		//
 		// Variable IL data, it has to be protected to encapsulate hoisted variables
 		//
 		protected abstract ILocalVariable Variable { get; }
 		
 		//
 		// Variable flow-analysis data
 		//
 		public abstract VariableInfo VariableInfo { get; }
 		#endregion
 
 		public virtual void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.AddressOf (ec, mode);
 				return;
 			}
 
 			Variable.EmitAddressOf (ec);
 		}
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			if (IsLockedByStatement) {
 				rc.Report.Warning (728, 2, loc,
 					"Possibly incorrect assignment to `{0}' which is the argument to a using or lock statement",
 					Name);
 			}
 
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			Emit (ec, false);
 		}
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			// do nothing
 		}
 
 		//
 		// This method is used by parameters that are references, that are
 		// being passed as references
 		// is already stored in the parameter, not the address of the pointer,
 		// and not the value of the variable).
 		//
 		public void EmitLoad (EmitContext ec)
 		{
 			Variable.Emit (ec);
 		}
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Report.Debug (64, "VARIABLE EMIT", this, Variable, type, IsRef, loc);
 
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.Emit (ec, leave_copy);
 				return;
 			}
 
 			EmitLoad (ec);
 
 			if (IsRef) {
 				//
 				// If we are a reference, we loaded on the stack a pointer
 				// Now lets load the real value
 				//
 				ec.EmitLoadFromPtr (type);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 		}
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy,
 					bool prepare_for_load)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.EmitAssign (ec, source, leave_copy, prepare_for_load);
 				return;
 			}
 
 			New n_source = source as New;
 			if (n_source != null) {
 				if (!n_source.Emit (ec, this)) {
 					if (leave_copy) {
 						EmitLoad (ec);
 						if (IsRef)
 							ec.EmitLoadFromPtr (type);
 					}
 					return;
 				}
 			} else {
 				if (IsRef)
 					EmitLoad (ec);
 
 				source.Emit (ec);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 
 			if (IsRef)
 				ec.EmitStoreFromPtr (type);
 			else
 				Variable.EmitAssign (ec);
 
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
 
 
 		public HoistedVariable GetHoistedVariable (ResolveContext rc)
 		{
 			return GetHoistedVariable (rc.CurrentAnonymousMethod);
 		}
 
 		public HoistedVariable GetHoistedVariable (EmitContext ec)
 		{
 			return GetHoistedVariable (ec.CurrentAnonymousMethod);
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return Name;
 		}
 
 		public bool IsHoisted {
 			get { return GetHoistedVariable ((AnonymousExpression) null) != null; }
 		}
 	}
 
 	//
 	// Resolved reference to a local variable
 	//
 	public class LocalVariableReference 
 	{
 		public LocalVariable local_info;
 
 		public LocalVariableReference (LocalVariable li, Location l)
 		{
 			this.local_info = li;
 			loc = l;
 		}
]]></clone_fragment>
<clone_fragment endline="750" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" hamdist="10" pcid="5743" startline="558"><![CDATA[
 	}
 
 	class DynamicIndexBinder 
 	{
 		bool can_be_mutator;
 
 		public DynamicIndexBinder (Arguments args, Location loc)
 			
 		{
 		}
 
 		public DynamicIndexBinder (CSharpBinderFlags flags, Arguments args, Location loc)
 			
 		{
 			base.flags = flags;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			can_be_mutator = true;
 			return base.DoResolve (ec);
 		}
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetIndex" 
 		}
 
 		protected override Arguments CreateSetterArguments (ResolveContext rc, Expression rhs)
 		{
 			//
 			// Indexer has arguments which complicates things as the setter and getter
 			// are called in two steps when unary mutator is used. We have to make a
 			// copy of all variable arguments to not duplicate any side effect.
 			//
 			// ++d[++arg, Foo ()]
 			//
 
 			if (!can_be_mutator)
 				return base.CreateSetterArguments (rc, rhs);
 
 			var setter_args = new Arguments (Arguments.Count + 1);
 			for (int i = 0; i < Arguments.Count; ++i) {
 				var expr = Arguments[i].Expr;
 
 				if (expr is Constant || expr is VariableReference || expr is This) {
 					setter_args.Add (Arguments [i]);
 					continue;
 				}
 
 				LocalVariable temp = LocalVariable.CreateCompilerGenerated (expr.Type, rc.CurrentBlock, loc);
 				expr = new SimpleAssign (temp.CreateReferenceExpression (rc, expr.Location), expr).Resolve (rc);
 				Arguments[i].Expr = temp.CreateReferenceExpression (rc, expr.Location).Resolve (rc);
 				setter_args.Add (Arguments [i].Clone (expr));
 			}
 
 			setter_args.Add (new Argument (rhs));
 			return setter_args;
 		}
 	}
 
 	class DynamicInvocation 
 	{
 		ATypeNameExpression member;
 
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 			this.member = member;
 		}
 
 		//
 		// When a return type is known not to be dynamic
 		//
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, TypeSpec type, Location loc)
 			
 		{
 			this.type = type;
 		}
 
 		public static DynamicInvocation CreateSpecialNameInvoke (ATypeNameExpression member, Arguments args, Location loc)
 		{
 			return new DynamicInvocation (member, args, loc) {
 				flags = CSharpBinderFlags.InvokeSpecialName
 			};
 		}
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (member != null ? 5 
 			bool is_member_access = member is MemberAccess;
 
 			CSharpBinderFlags call_flags;
 			if (!is_member_access && member is SimpleName) {
 				call_flags = CSharpBinderFlags.InvokeSimpleName;
 				is_member_access = true;
 			} else {
 				call_flags = 0;
 			}
 
 			binder_args.Add (new Argument (new BinderFlags (call_flags, this)));
 
 			if (is_member_access)
 				binder_args.Add (new Argument (new StringLiteral (member.Name, member.Location)));
 
 			if (member != null && member.HasTypeArguments) {
 				TypeArguments ta = member.TypeArguments;
 				if (ta.Resolve (ec)) {
 					var targs = new ArrayInitializer (ta.Count, loc);
 					foreach (TypeSpec t in ta.Arguments)
 						targs.Add (new TypeOf (new TypeExpression (t, loc), loc));
 
 					binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (targs, loc)));
 				}
 			} else if (is_member_access) {
 				binder_args.Add (new Argument (new NullLiteral (loc)));
 			}
 
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 
 			Expression real_args;
 			if (args == null) {
 				// Cannot be null because .NET trips over
 				real_args = new ArrayCreation (
 					new MemberAccess (GetBinderNamespace (loc), "CSharpArgumentInfo", loc),
 					new ArrayInitializer (0, loc), loc);
 			} else {
 				real_args = new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc);
 			}
 
 			binder_args.Add (new Argument (real_args));
 
 			return new Invocation (GetBinder (is_member_access ? "InvokeMember" 
 		}
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			flags |= CSharpBinderFlags.ResultDiscarded;
 			base.EmitStatement (ec);
 		}
 	}
 
 	class DynamicMemberBinder 
 	{
 		readonly string name;
 
 		public DynamicMemberBinder (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 		}
 
 		public DynamicMemberBinder (string name, CSharpBinderFlags flags, Arguments args, Location loc)
 			
 		{
 			base.flags = flags;
 		}
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (4);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new StringLiteral (name, loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetMember" 
 		}
 	}
 
 	//
 	// Any member binder which can be source and target of assignment
 	//
 	abstract class DynamicMemberAssignable 
 	{
 		Expression setter;
 		Arguments setter_args;
 
 		protected DynamicMemberAssignable (Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 		}
]]></clone_fragment>
<clone_fragment endline="4697" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="8" pcid="2383" startline="2979"><![CDATA[
 
 		#endregion
 	}
 
 	/// <summary>
 	///   MethodGroupExpr represents a group of method candidates which
 	///   can be resolved to the best method overload
 	/// </summary>
 	public class MethodGroupExpr 
 	{
 		protected IList<MemberSpec> Methods;
 		MethodSpec best_candidate;
 		TypeSpec best_candidate_return;
 		protected TypeArguments type_arguments;
 
  		SimpleName simple_name;
 		protected TypeSpec queried_type;
 
 		public MethodGroupExpr (IList<MemberSpec> mi, TypeSpec type, Location loc)
 		{
 			Methods = mi;
 			this.loc = loc;
 			this.type = InternalType.MethodGroup;
 
 			eclass = ExprClass.MethodGroup;
 			queried_type = type;
 		}
 
 		public MethodGroupExpr (MethodSpec m, TypeSpec type, Location loc)
 			
 		{
 		}
 
 		#region Properties
 
 		public MethodSpec BestCandidate {
 			get {
 				return best_candidate;
 			}
 		}
 
 		public TypeSpec BestCandidateReturnType {
 			get {
 				return best_candidate_return;
 			}
 		}
 
 		protected override TypeSpec DeclaringType {
 			get {
 				return queried_type;
 			}
 		}
 
 		public override bool IsInstance {
 			get {
 				if (best_candidate != null)
 					return !best_candidate.IsStatic;
 
 				return false;
 			}
 		}
 
 		public override bool IsStatic {
 			get {
 				if (best_candidate != null)
 					return best_candidate.IsStatic;
 
 				return false;
 			}
 		}
 
 		public override string Name {
 			get {
 				if (best_candidate != null)
 					return best_candidate.Name;
 
 				// TODO
 				return Methods.First ().Name;
 			}
 		}
 
 		#endregion
 
 		//
 		// When best candidate is already know this factory can be used
 		// to avoid expensive overload resolution to be called
 		//
 		// NOTE
 		//
 		public static MethodGroupExpr CreatePredefined (MethodSpec best, TypeSpec queriedType, Location loc)
 		{
 			return new MethodGroupExpr (best, queriedType, loc) {
 				best_candidate = best,
 				best_candidate_return = best.ReturnType
 			};
 		}
 
 		public override string GetSignatureForError ()
 		{
 			if (best_candidate != null)
 				return best_candidate.GetSignatureForError ();
 
 			return Methods.First ().GetSignatureForError ();
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (best_candidate == null) {
 				ec.Report.Error (1953, loc, "An expression tree cannot contain an expression with method group");
 				return null;
 			}
 
 			if (best_candidate.IsConditionallyExcluded (loc))
 				ec.Report.Error (765, loc,
 					"Partial methods with only a defining declaration or removed conditional methods cannot be used in an expression tree");
 			
 			return new TypeOfMethod (best_candidate, loc);
 		}
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			this.eclass = ExprClass.MethodGroup;
 
 			if (InstanceExpression != null) {
 				InstanceExpression = InstanceExpression.Resolve (ec);
 				if (InstanceExpression == null)
 					return null;
 			}
 
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			throw new NotSupportedException ();
 		}
 		
 		public void EmitCall (EmitContext ec, Arguments arguments)
 		{
 			Invocation.EmitCall (ec, InstanceExpression, best_candidate, arguments, loc);			
 		}
 
 		public override void Error_ValueCannotBeConverted (ResolveContext ec, Location loc, TypeSpec target, bool expl)
 		{
 			ec.Report.Error (428, loc, "Cannot convert method group `{0}' to non-delegate type `{1}'. Consider using parentheses to invoke the method",
 				Name, TypeManager.CSharpName (target));
 		}
 
 		public static bool IsExtensionMethodArgument (Expression expr)
 		{
 			//
 			// LAMESPEC
 			//
 			return !(expr is TypeExpr) && !(expr is BaseThis);
 		}
 
 		/// <summary>
 		///   Find the Applicable Function Members (7.4.2.1)
 		///
 		///   me
 		///       it might contain constructors or methods (or anything
 		///       that maps to a method).
 		///
 		///   Arguments
 		///
 		///   loc
 		///        location for "probing" purposes.
 		///
 		///   Returns
 		///            that is the best match of me on Arguments.
 		///
 		/// </summary>
 		public virtual MethodGroupExpr OverloadResolve (ResolveContext ec, ref Arguments args, OverloadResolver.IErrorHandler cerrors, OverloadResolver.Restrictions restr)
 		{
 			// TODO
 			if (best_candidate != null && best_candidate.Kind == MemberKind.Destructor)
 				return this;
 
 			var r = new OverloadResolver (Methods, type_arguments, restr, loc);
 			if ((restr & OverloadResolver.Restrictions.NoBaseMembers) == 0) {
 				r.BaseMembersProvider = this;
 			}
 
 			if (cerrors != null)
 				r.CustomErrors = cerrors;
 
 			// TODO
 			best_candidate = r.ResolveMember<MethodSpec> (ec, ref args);
 			if (best_candidate == null)
 				return r.BestCandidateIsDynamic ? this 
 
 			// Overload resolver had to create a new method group, all checks bellow have already been executed
 			if (r.BestCandidateNewMethodGroup != null)
 				return r.BestCandidateNewMethodGroup;
 
 			if (best_candidate.Kind == MemberKind.Method && (restr & OverloadResolver.Restrictions.ProbingOnly) == 0) {
 				if (InstanceExpression != null) {
 					if (best_candidate.IsExtensionMethod && args[0].Expr == InstanceExpression) {
 						InstanceExpression = null;
 					} else {
 						if (best_candidate.IsStatic && simple_name != null) {
 							InstanceExpression = ProbeIdenticalTypeName (ec, InstanceExpression, simple_name);
 						}
 
 						InstanceExpression.Resolve (ec);
 					}
 				}
 
 				ResolveInstanceExpression (ec, null);
 				if (InstanceExpression != null)
 					CheckProtectedMemberAccess (ec, best_candidate);
 			}
 
 			var base_override = CandidateToBaseOverride (ec, best_candidate);
 			if (base_override == best_candidate) {
 				best_candidate_return = r.BestCandidateReturnType;
 			} else {
 				best_candidate = base_override;
 				best_candidate_return = best_candidate.ReturnType;
 			}
 
 			return this;
 		}
 
 		public override MemberExpr ResolveMemberAccess (ResolveContext ec, Expression left, SimpleName original)
 		{
 			simple_name = original;
 			return base.ResolveMemberAccess (ec, left, original);
 		}
 
 		public override void SetTypeArguments (ResolveContext ec, TypeArguments ta)
 		{
 			type_arguments = ta;
 		}
 
 		#region IBaseMembersProvider Members
 
 		public virtual IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			return baseType == null ? null 
 		}
 
 		public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 		{
 			if (queried_type == member.DeclaringType)
 				return null;
 
 			return MemberCache.FindMember (queried_type, new MemberFilter ((MethodSpec) member),
 				BindingRestriction.InstanceOnly | BindingRestriction.OverrideOnly) as IParametersMember;
 		}
 
 		//
 		// Extension methods lookup after ordinary methods candidates failed to apply
 		//
 		public virtual MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 		{
 			if (InstanceExpression == null)
 				return null;
 
 			InstanceExpression = InstanceExpression.Resolve (rc);
 			if (!IsExtensionMethodArgument (InstanceExpression))
 				return null;
 
 			int arity = type_arguments == null ? 0 
 			NamespaceEntry methods_scope = null;
 			var methods = rc.LookupExtensionMethod (InstanceExpression.Type, Methods[0].Name, arity, ref methods_scope);
 			if (methods == null)
 				return null;
 
 			var emg = new ExtensionMethodGroupExpr (methods, methods_scope, InstanceExpression, loc);
 			emg.SetTypeArguments (rc, type_arguments);
 			return emg;
 		}
 
 		#endregion
 	}
 
 	public struct OverloadResolver
 	{
 		[Flags]
 		public enum Restrictions
 		{
 			None = 0,
 			DelegateInvoke = 1,
 			ProbingOnly	= 1 << 1,
 			CovariantDelegate = 1 << 2,
 			NoBaseMembers = 1 << 3,
 			BaseMembersIncluded = 1 << 4
 		}
 
 		public interface IBaseMembersProvider
 		{
 			IList<MemberSpec> GetBaseMembers (TypeSpec baseType);
 			IParametersMember GetOverrideMemberParameters (MemberSpec member);
 			MethodGroupExpr LookupExtensionMethod (ResolveContext rc);
 		}
 
 		public interface IErrorHandler
 		{
 			bool AmbiguousCandidates (ResolveContext rc, MemberSpec best, MemberSpec ambiguous);
 			bool ArgumentMismatch (ResolveContext rc, MemberSpec best, Argument a, int index);
 			bool NoArgumentMatch (ResolveContext rc, MemberSpec best);
 			bool TypeInferenceFailed (ResolveContext rc, MemberSpec best);
 		}
 
 		sealed class NoBaseMembers 
 		{
 			public static readonly IBaseMembersProvider Instance = new NoBaseMembers ();
 
 			public IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 			{
 				return null;
 			}
 
 			public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 			{
 				return null;
 			}
 
 			public MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 			{
 				return null;
 			}
 		}
 
 		struct AmbiguousCandidate
 		{
 			public readonly MemberSpec Member;
 			public readonly bool Expanded;
 			public readonly AParametersCollection Parameters;
 
 			public AmbiguousCandidate (MemberSpec member, AParametersCollection parameters, bool expanded)
 			{
 				Member = member;
 				Parameters = parameters;
 				Expanded = expanded;
 			}
 		}
 
 		Location loc;
 		IList<MemberSpec> members;
 		TypeArguments type_arguments;
 		IBaseMembersProvider base_provider;
 		IErrorHandler custom_errors;
 		Restrictions restrictions;
 		MethodGroupExpr best_candidate_extension_group;
 		TypeSpec best_candidate_return_type;
 
 		SessionReportPrinter lambda_conv_msgs;
 		ReportPrinter prev_recorder;
 
 		public OverloadResolver (IList<MemberSpec> members, Restrictions restrictions, Location loc)
 			
 		{
 		}
 
 		public OverloadResolver (IList<MemberSpec> members, TypeArguments targs, Restrictions restrictions, Location loc)
 			
 		{
 			if (members == null || members.Count == 0)
 				throw new ArgumentException ("empty members set");
 
 			this.members = members;
 			this.loc = loc;
 			type_arguments = targs;
 			this.restrictions = restrictions;
 			if (IsDelegateInvoke)
 				this.restrictions |= Restrictions.NoBaseMembers;
 
 			base_provider = NoBaseMembers.Instance;
 		}
 
 		#region Properties
 
 		public IBaseMembersProvider BaseMembersProvider {
 			get {
 				return base_provider;
 			}
 			set {
 				base_provider = value;
 			}
 		}
 
 		public bool BestCandidateIsDynamic { get; set; }
 
 		//
 		// Best candidate was found in newly created MethodGroupExpr, used by extension methods
 		//
 		public MethodGroupExpr BestCandidateNewMethodGroup {
 			get {
 				return best_candidate_extension_group;
 			}
 		}
 
 		//
 		// Return type can be different between best candidate and closest override
 		//
 		public TypeSpec BestCandidateReturnType {
 			get {
 				return best_candidate_return_type;
 			}
 		}
 
 		public IErrorHandler CustomErrors {
 			get {
 				return custom_errors;
 			}
 			set {
 				custom_errors = value;
 			}
 		}
 
 		TypeSpec DelegateType {
 			get {
 				if ((restrictions & Restrictions.DelegateInvoke) == 0)
 					throw new InternalErrorException ("Not running in delegate mode", loc);
 
 				return members [0].DeclaringType;
 			}
 		}
 
 		bool IsProbingOnly {
 			get {
 				return (restrictions & Restrictions.ProbingOnly) != 0;
 			}
 		}
 
 		bool IsDelegateInvoke {
 			get {
 				return (restrictions & Restrictions.DelegateInvoke) != 0;
 			}
 		}
 
 		#endregion
 
 		//
 		//  7.4.3.3  Better conversion from expression
 		//  Returns 
 		//              2    if a->q is better,
 		//              0 if neither is better
 		//
 		static int BetterExpressionConversion (ResolveContext ec, Argument a, TypeSpec p, TypeSpec q)
 		{
 			TypeSpec argument_type = a.Type;
 
 			//
 			// If argument is an anonymous function
 			//
 			if (argument_type == InternalType.AnonymousMethod && RootContext.Version > LanguageVersion.ISO_2) {
 				//
 				// p and q are delegate types or expression tree types
 				//
 				if (p.GetDefinition () == TypeManager.expression_type || q.GetDefinition () == TypeManager.expression_type) {
 					if (q.MemberDefinition != p.MemberDefinition) {
 						return 0;
 					}
 
 					//
 					// Uwrap delegate from Expression<T>
 					//
 					q = TypeManager.GetTypeArguments (q)[0];
 					p = TypeManager.GetTypeArguments (p)[0];
 				}
 
 				var p_m = Delegate.GetInvokeMethod (ec.Compiler, p);
 				var q_m = Delegate.GetInvokeMethod (ec.Compiler, q);
 
 				//
 				// With identical parameter lists
 				//
 				if (!TypeSpecComparer.Equals (p_m.Parameters.Types,q_m.Parameters.Types))
 					return 0;
 
 				p = p_m.ReturnType;
 				q = q_m.ReturnType;
 
 				//
 				// if p is void returning, and q has a return type Y, then C2 is the better conversion.
 				//
 				if (p == TypeManager.void_type) {
 					return q != TypeManager.void_type ? 2 
 				}
 
 				//
 				// if p has a return type Y, and q is void returning, then C1 is the better conversion.
 				//
 				if (q == TypeManager.void_type) {
 					return p != TypeManager.void_type ? 1
 				}
 			} else {
 				if (argument_type == p)
 					return 1;
 
 				if (argument_type == q)
 					return 2;
 			}
 
 			return BetterTypeConversion (ec, p, q);
 		}
 
 		//
 		// 7.4.3.4  Better conversion from type
 		//
 		public static int BetterTypeConversion (ResolveContext ec, TypeSpec p, TypeSpec q)
 		{
 			if (p == null || q == null)
 				throw new InternalErrorException ("BetterTypeConversion got a null conversion");
 
 			if (p == TypeManager.int32_type) {
 				if (q == TypeManager.uint32_type || q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.int64_type) {
 				if (q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.sbyte_type) {
 				if (q == TypeManager.byte_type || q == TypeManager.ushort_type ||
 					q == TypeManager.uint32_type || q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.short_type) {
 				if (q == TypeManager.ushort_type || q == TypeManager.uint32_type ||
 					q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == InternalType.Dynamic) {
 				// Dynamic is never better
 				return 2;
 			}
 
 			if (q == TypeManager.int32_type) {
 				if (p == TypeManager.uint32_type || p == TypeManager.uint64_type)
 					return 2;
 			} if (q == TypeManager.int64_type) {
 				if (p == TypeManager.uint64_type)
 					return 2;
 			} else if (q == TypeManager.sbyte_type) {
 				if (p == TypeManager.byte_type || p == TypeManager.ushort_type ||
 					p == TypeManager.uint32_type || p == TypeManager.uint64_type)
 					return 2;
 			} if (q == TypeManager.short_type) {
 				if (p == TypeManager.ushort_type || p == TypeManager.uint32_type ||
 					p == TypeManager.uint64_type)
 					return 2;
 			} else if (q == InternalType.Dynamic) {
 				// Dynamic is never better
 				return 1;
 			}
 
 			// FIXME
 
 			// TODO
 			Expression p_tmp = new EmptyExpression (p);
 			Expression q_tmp = new EmptyExpression (q);
 
 			bool p_to_q = Convert.ImplicitConversionExists (ec, p_tmp, q);
 			bool q_to_p = Convert.ImplicitConversionExists (ec, q_tmp, p);
 
 			if (p_to_q && !q_to_p)
 				return 1;
 
 			if (q_to_p && !p_to_q)
 				return 2;
 
 			return 0;
 		}
 
 		/// <summary>
 		///   Determines "Better function" between candidate
 		///   and the current best match
 		/// </summary>
 		/// <remarks>
 		///    Returns a boolean indicating 
 		///     false if candidate ain't better
 		///     true  if candidate is better than the current best match
 		/// </remarks>
 		static bool BetterFunction (ResolveContext ec, Arguments args, MemberSpec candidate, AParametersCollection cparam, bool candidate_params,
 			MemberSpec best, AParametersCollection bparam, bool best_params)
 		{
 			AParametersCollection candidate_pd = ((IParametersMember) candidate).Parameters;
 			AParametersCollection best_pd = ((IParametersMember) best).Parameters;
 
 			bool better_at_least_one = false;
 			bool same = true;
 			int args_count = args == null ? 0 
 			int j = 0;
 			Argument a = null;
 			TypeSpec ct, bt;
 			for (int c_idx = 0, b_idx = 0; j < args_count; ++j, ++c_idx, ++b_idx) {
 				a = args[j];
 
 				// Default arguments are ignored for better decision
 				if (a.IsDefaultArgument)
 					break;
 
 				//
 				// When comparing named argument the parameter type index has to be looked up
 				// in original parameter set (override version for virtual members)
 				//
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int idx = cparam.GetParameterIndexByName (na.Name);
 					ct = candidate_pd.Types[idx];
 					if (candidate_params && candidate_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						ct = TypeManager.GetElementType (ct);
 
 					idx = bparam.GetParameterIndexByName (na.Name);
 					bt = best_pd.Types[idx];
 					if (best_params && best_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						bt = TypeManager.GetElementType (bt);
 				} else {
 					ct = candidate_pd.Types[c_idx];
 					bt = best_pd.Types[b_idx];
 
 					if (candidate_params && candidate_pd.FixedParameters[c_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						ct = TypeManager.GetElementType (ct);
 						--c_idx;
 					}
 
 					if (best_params && best_pd.FixedParameters[b_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						bt = TypeManager.GetElementType (bt);
 						--b_idx;
 					}
 				}
 
 				if (TypeSpecComparer.IsEqual (ct, bt))
 					continue;
 
 				same = false;
 				int result = BetterExpressionConversion (ec, a, ct, bt);
 
 				// for each argument, the conversion to 'ct' should be no worse than 
 				// the conversion to 'bt'.
 				if (result == 2)
 					return false;
 
 				// for at least one argument, the conversion to 'ct' should be better than 
 				// the conversion to 'bt'.
 				if (result != 0)
 					better_at_least_one = true;
 			}
 
 			if (better_at_least_one)
 				return true;
 
 			//
 			// This handles the case
 			//
 			//   Add (float f1, float f2, float f3);
 			//   Add (params decimal [] foo);
 			//
 			// The call Add (3, 4, 5) should be ambiguous.  Without this check, the
 			// first candidate would've chosen as better.
 			//
 			if (!same && !a.IsDefaultArgument)
 				return false;
 
 			//
 			// The two methods have equal non-optional parameter types, apply tie-breaking rules
 			//
 
 			//
 			// This handles the following cases
 			//
 			//  Foo (int i) is better than Foo (int i, long l = 0)
 			//  Foo (params int[] args) is better than Foo (int i = 0, params int[] args)
 			//
 			// Prefer non-optional version
 			//
 			// LAMESPEC
 			//
 			if (candidate_params == best_params && candidate_pd.Count != best_pd.Count) {
 				if (candidate_pd.Count >= best_pd.Count)
 					return false;
 
 				if (j < candidate_pd.Count && candidate_pd.FixedParameters[j].HasDefaultValue)
 					return false;
 
 				return true;
 			}
 
 			//
 			// One is a non-generic method and second is a generic method, then non-generic is better
 			//
 			if (best.IsGeneric != candidate.IsGeneric)
 				return best.IsGeneric;
 
 			//
 			// This handles the following cases
 			//
 			//   Trim () is better than Trim (params char[] chars)
 			//   Concat (string s1, string s2, string s3) is better than
 			//     Concat (string s1, params string [] srest)
 			//   Foo (int, params int [] rest) is better than Foo (params int [] rest)
 			//
 			// Prefer non-expanded version
 			//
 			if (candidate_params != best_params)
 				return best_params;
 
 			int candidate_param_count = candidate_pd.Count;
 			int best_param_count = best_pd.Count;
 
 			if (candidate_param_count != best_param_count)
 				// can only happen if (candidate_params && best_params)
 				return candidate_param_count > best_param_count && best_pd.HasParams;
 
 			//
 			// Both methods have the same number of parameters, and the parameters have equal types
 			// Pick the "more specific" signature using rules over original (non-inflated) types
 			//
 			var candidate_def_pd = ((IParametersMember) candidate.MemberDefinition).Parameters;
 			var best_def_pd = ((IParametersMember) best.MemberDefinition).Parameters;
 
 			bool specific_at_least_once = false;
 			for (j = 0; j < args_count; ++j) {
 				NamedArgument na = args_count == 0 ? null 
 				if (na != null) {
 					ct = candidate_def_pd.Types[cparam.GetParameterIndexByName (na.Name)];
 					bt = best_def_pd.Types[bparam.GetParameterIndexByName (na.Name)];
 				} else {
 					ct = candidate_def_pd.Types[j];
 					bt = best_def_pd.Types[j];
 				}
 
 				if (ct == bt)
 					continue;
 				TypeSpec specific = MoreSpecific (ct, bt);
 				if (specific == bt)
 					return false;
 				if (specific == ct)
 					specific_at_least_once = true;
 			}
 
 			if (specific_at_least_once)
 				return true;
 
 			return false;
 		}
 
 		public static void Error_ConstructorMismatch (ResolveContext rc, TypeSpec type, int argCount, Location loc)
 		{
 			rc.Report.Error (1729, loc,
 				"The type `{0}' does not contain a constructor that takes `{1}' arguments",
 				type.GetSignatureForError (), argCount.ToString ());
 		}
 
 		//
 		// Determines if the candidate method is applicable to the given set of arguments
 		// There could be two different set of parameters for same candidate where one
 		// is the closest override for default values and named arguments checks and second
 		// one being the virtual base for the parameter types and modifiers.
 		//
 		// A return value rates candidate method compatibility,
 		// 0 = the best, int.MaxValue = the worst
 		//
 		int IsApplicable (ResolveContext ec, ref Arguments arguments, int arg_count, ref MemberSpec candidate, IParametersMember pm, ref bool params_expanded_form, ref bool dynamicArgument, ref TypeSpec returnType)
 		{
 			// Parameters of most-derived type used mainly for named and optional parameters
 			var pd = pm.Parameters;
 
 			// Used for params modifier only, that's legacy of C# 1.0 which uses base type for
 			// params modifier instead of most-derived type
 			var cpd = ((IParametersMember) candidate).Parameters;
 			int param_count = pd.Count;
 			int optional_count = 0;
 			int score;
 			Arguments orig_args = arguments;
 
 			if (arg_count != param_count) {
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 
 				if (optional_count != 0) {
 					// Readjust expected number when params used
 					if (cpd.HasParams) {
 						optional_count--;
 						if (arg_count < param_count)
 							param_count--;
 					} else if (arg_count > param_count) {
 						int args_gap = System.Math.Abs (arg_count - param_count);
 						return int.MaxValue - 10000 + args_gap;
 					}
 				} else if (arg_count != param_count) {
 					int args_gap = System.Math.Abs (arg_count - param_count);
 					if (!cpd.HasParams)
 						return int.MaxValue - 10000 + args_gap;
 					if (arg_count < param_count - 1)
 						return int.MaxValue - 10000 + args_gap;
 				}
 
 				// Resize to fit optional arguments
 				if (optional_count != 0) {
 					if (arguments == null) {
 						arguments = new Arguments (optional_count);
 					} else {
 						// Have to create a new container, so the next run can do same
 						var resized = new Arguments (param_count);
 						resized.AddRange (arguments);
 						arguments = resized;
 					}
 
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 				}
 			}
 
 			if (arg_count > 0) {
 				//
 				// Shuffle named arguments to the right positions if there are any
 				//
 				if (arguments[arg_count - 1] is NamedArgument) {
 					arg_count = arguments.Count;
 
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 				} else {
 					arg_count = arguments.Count;
 				}
 			} else if (arguments != null) {
 				arg_count = arguments.Count;
 			}
 
 			//
 			// 1. Handle generic method using type arguments when specified or type inference
 			//
 			TypeSpec[] ptypes;
 			var ms = candidate as MethodSpec;
 			if (ms != null && ms.IsGeneric) {
 				// Setup constraint checker for probing only
 				ConstraintChecker cc = new ConstraintChecker (null);
 
 				if (type_arguments != null) {
 					var g_args_count = ms.Arity;
 					if (g_args_count != type_arguments.Count)
 						return int.MaxValue - 20000 + System.Math.Abs (type_arguments.Count - g_args_count);
 
 					ms = ms.MakeGenericMethod (type_arguments.Arguments);
 				} else {
 					// TODO
 					// for now it simplifies things. I should probably add a callback to ResolveContext
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 
 					var ti = new TypeInference (arguments);
 					TypeSpec[] i_args = ti.InferMethodArguments (ec, ms);
 					lambda_conv_msgs.EndSession ();
 
 					if (i_args == null)
 						return ti.InferenceScore - 20000;
 
 					if (i_args.Length != 0) {
 						ms = ms.MakeGenericMethod (i_args);
 					}
 
 					cc.IgnoreInferredDynamic = true;
 				}
 
 				//
 				// Type arguments constraints have to match for the method to be applicable
 				//
 				if (!cc.CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc)) {
 					candidate = ms;
 					return int.MaxValue - 25000;
 				}
 
 				//
 				// We have a generic return type and at same time the method is override which
 				// means we have to also inflate override return type in case the candidate is
 				// best candidate and override return type is different to base return type.
 				// 
 				// virtual Foo<T, object> with override Foo<T, dynamic>
 				//
 				if (candidate != pm) {
 					MethodSpec override_ms = (MethodSpec) pm;
 					var inflator = new TypeParameterInflator (ms.DeclaringType, override_ms.GenericDefinition.TypeParameters, ms.TypeArguments);
 					returnType = inflator.Inflate (returnType);
 				} else {
 					returnType = ms.ReturnType;
 				}
 
 				candidate = ms;
 				ptypes = ms.Parameters.Types;
 			} else {
 				if (type_arguments != null)
 					return int.MaxValue - 15000;
 
 				ptypes = cpd.Types;
 			}
 
 			//
 			// 2. Each argument has to be implicitly convertible to method parameter
 			//
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 
 			//
 			// When params parameter has no argument it will be provided later if the method is the best candidate
 			//
 			if (arg_count + 1 == pd.Count && (cpd.FixedParameters [arg_count].ModFlags & Parameter.Modifier.PARAMS) != 0)
 				params_expanded_form = true;
 
 			//
 			// Restore original arguments for dynamic binder to keep the intention of original source code
 			//
 			if (dynamicArgument)
 				arguments = orig_args;
 
 			return 0;
 		}
 
 		//
 		// Tests argument compatibility with the parameter
 		// The possible return values are
 		// 0 - success
 		// 1 - modifier mismatch
 		// 2 - type mismatch
 		// -1 - dynamic binding required
 		//
 		int IsArgumentCompatible (ResolveContext ec, Argument argument, Parameter.Modifier param_mod, TypeSpec parameter)
 		{
 			//
 			// Types have to be identical when ref or out modifer
 			// is used and argument is not of dynamic type
 			//
 			if ((argument.Modifier | param_mod) != 0) {
 				if (argument.Type != parameter) {
 					//
 					// Do full equality check after quick path
 					//
 					if (!TypeSpecComparer.IsEqual (argument.Type, parameter)) {
 						//
 						// Using dynamic for ref/out parameter can still succeed at runtime
 						//
 						if (argument.Type == InternalType.Dynamic && argument.Modifier == 0 && (restrictions & Restrictions.CovariantDelegate) == 0)
 							return -1;
 
 						return 2;
 					}
 				}
 
 				if (argument.Modifier != param_mod) {
 					//
 					// Using dynamic for ref/out parameter can still succeed at runtime
 					//
 					if (argument.Type == InternalType.Dynamic && argument.Modifier == 0 && (restrictions & Restrictions.CovariantDelegate) == 0)
 						return -1;
 
 					return 1;
 				}
 
 			} else {
 				if (argument.Type == InternalType.Dynamic && (restrictions & Restrictions.CovariantDelegate) == 0)
 					return -1;
 
 				//
 				// Deploy custom error reporting for lambda methods. When probing lambda methods
 				// keep all errors reported in separate set and once we are done and no best
 				// candidate found, this set is used to report more details about what was wrong
 				// with lambda body
 				//
 				if (argument.Expr.Type == InternalType.AnonymousMethod) {
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 				}
 
 				if (!Convert.ImplicitConversionExists (ec, argument.Expr, parameter)) {
 					if (lambda_conv_msgs != null) {
 						lambda_conv_msgs.EndSession ();
 					}
 
 					return 2;
 				}
 			}
 
 			return 0;
 		}
 
 		static TypeSpec MoreSpecific (TypeSpec p, TypeSpec q)
 		{
 			if (TypeManager.IsGenericParameter (p) && !TypeManager.IsGenericParameter (q))
 				return q;
 			if (!TypeManager.IsGenericParameter (p) && TypeManager.IsGenericParameter (q))
 				return p;
 
 			var ac_p = p as ArrayContainer;
 			if (ac_p != null) {
 				var ac_q = ((ArrayContainer) q);
 				TypeSpec specific = MoreSpecific (ac_p.Element, ac_q.Element);
 				if (specific == ac_p.Element)
 					return p;
 				if (specific == ac_q.Element)
 					return q;
 			} else if (TypeManager.IsGenericType (p)) {
 				var pargs = TypeManager.GetTypeArguments (p);
 				var qargs = TypeManager.GetTypeArguments (q);
 
 				bool p_specific_at_least_once = false;
 				bool q_specific_at_least_once = false;
 
 				for (int i = 0; i < pargs.Length; i++) {
 					TypeSpec specific = MoreSpecific (pargs[i], qargs[i]);
 					if (specific == pargs[i])
 						p_specific_at_least_once = true;
 					if (specific == qargs[i])
 						q_specific_at_least_once = true;
 				}
 
 				if (p_specific_at_least_once && !q_specific_at_least_once)
 					return p;
 				if (!p_specific_at_least_once && q_specific_at_least_once)
 					return q;
 			}
 
 			return null;
 		}
 
 		//
 		// Find the best method from candidate list
 		//
 		public T ResolveMember<T> (ResolveContext rc, ref Arguments args) where T 
 		{
 			List<AmbiguousCandidate> ambiguous_candidates = null;
 
 			MemberSpec best_candidate;
 			Arguments best_candidate_args = null;
 			bool best_candidate_params = false;
 			bool best_candidate_dynamic = false;
 			int best_candidate_rate;
 			IParametersMember best_parameter_member = null;
 
 			int args_count = args != null ? args.Count 
 
 			Arguments candidate_args = args;
 			bool error_mode = false;
 			var current_type = rc.CurrentType;
 			MemberSpec invocable_member = null;
 
 			// Be careful, cannot return until error reporter is restored
 			while (true) {
 				best_candidate = null;
 				best_candidate_rate = int.MaxValue;
 
 				var type_members = members;
 				try {
 
 					do {
 						for (int i = 0; i < type_members.Count; ++i) {
 							var member = type_members[i];
 
 							//
 							// Methods in a base class are not candidates if any method in a derived
 							// class is applicable
 							//
 							if ((member.Modifiers & Modifiers.OVERRIDE) != 0)
 								continue;
 
 							if (!error_mode) {
 								if (!member.IsAccessible (current_type))
 									continue;
 
 								if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (current_type))
 									continue;
 							}
 
 							IParametersMember pm = member as IParametersMember;
 							if (pm == null) {
 								//
 								// Will use it later to report ambiguity between best method and invocable member
 								//
 								if (Invocation.IsMemberInvocable (member))
 									invocable_member = member;
 
 								continue;
 							}
 
 							//
 							// Overload resolution is looking for base member but using parameter names
 							// and default values from the closest member. That means to do expensive lookup
 							// for the closest override for virtual or abstract members
 							//
 							if ((member.Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 								var override_params = base_provider.GetOverrideMemberParameters (member);
 								if (override_params != null)
 									pm = override_params;
 							}
 
 							//
 							// Check if the member candidate is applicable
 							//
 							bool params_expanded_form = false;
 							bool dynamic_argument = false;
 							TypeSpec rt = pm.MemberType;
 							int candidate_rate = IsApplicable (rc, ref candidate_args, args_count, ref member, pm, ref params_expanded_form, ref dynamic_argument, ref rt);
 
 							//
 							// How does it score compare to others
 							//
 							if (candidate_rate < best_candidate_rate) {
 								best_candidate_rate = candidate_rate;
 								best_candidate = member;
 								best_candidate_args = candidate_args;
 								best_candidate_params = params_expanded_form;
 								best_candidate_dynamic = dynamic_argument;
 								best_parameter_member = pm;
 								best_candidate_return_type = rt;
 							} else if (candidate_rate == 0) {
 								//
 								// The member look is done per type for most operations but sometimes
 								// it's not possible like for binary operators overload because they
 								// are unioned between 2 sides
 								//
 								if ((restrictions & Restrictions.BaseMembersIncluded) != 0) {
 									if (TypeSpec.IsBaseClass (best_candidate.DeclaringType, member.DeclaringType, true))
 										continue;
 								}
 
 								bool is_better;
 								if (best_candidate.DeclaringType.IsInterface && member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 									//
 									// We pack all interface members into top level type which makes the overload resolution
 									// more complicated for interfaces. We accomodate for this by removing methods with same
 									// signature when building the cache hence this path should not really be hit often
 									//
 									// Example
 									// interface IA { void Foo (int arg); }
 									// interface IB 
 									//
 									// IB
 									//
 									is_better = true;
 									if (ambiguous_candidates != null) {
 										foreach (var amb_cand in ambiguous_candidates) {
 											if (member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 												continue;
 											}
 
 											is_better = false;
 											break;
 										}
 
 										if (is_better)
 											ambiguous_candidates = null;
 									}
 								} else {
 									// Is the new candidate better
 									is_better = BetterFunction (rc, candidate_args, member, pm.Parameters, params_expanded_form, best_candidate, best_parameter_member.Parameters, best_candidate_params);
 								}
 
 								if (is_better) {
 									best_candidate = member;
 									best_candidate_args = candidate_args;
 									best_candidate_params = params_expanded_form;
 									best_candidate_dynamic = dynamic_argument;
 									best_parameter_member = pm;
 									best_candidate_return_type = rt;
 								} else {
 									// It's not better but any other found later could be but we are not sure yet
 									if (ambiguous_candidates == null)
 										ambiguous_candidates = new List<AmbiguousCandidate> ();
 
 									ambiguous_candidates.Add (new AmbiguousCandidate (member, pm.Parameters, params_expanded_form));
 								}
 							}
 
 							// Restore expanded arguments
 							if (candidate_args != args)
 								candidate_args = args;
 						}
 					} while (best_candidate_rate != 0 && (type_members = base_provider.GetBaseMembers (type_members[0].DeclaringType.BaseType)) != null);
 				} finally {
 					if (prev_recorder != null)
 						rc.Report.SetPrinter (prev_recorder);
 				}
 
 				//
 				// We've found exact match
 				//
 				if (best_candidate_rate == 0)
 					break;
 
 				//
 				// Try extension methods lookup when no ordinary method match was found and provider enables it
 				//
 				if (!error_mode) {
 					var emg = base_provider.LookupExtensionMethod (rc);
 					if (emg != null) {
 						emg = emg.OverloadResolve (rc, ref args, null, restrictions);
 						if (emg != null) {
 							best_candidate_extension_group = emg;
 							return (T) (MemberSpec) emg.BestCandidate;
 						}
 					}
 				}
 
 				// Don't run expensive error reporting mode for probing
 				if (IsProbingOnly)
 					return null;
 
 				if (error_mode)
 					break;
 
 				lambda_conv_msgs = null;
 				error_mode = true;
 			}
 
 			//
 			// No best member match found, report an error
 			//
 			if (best_candidate_rate != 0 || error_mode) {
 				ReportOverloadError (rc, best_candidate, best_parameter_member, best_candidate_args, best_candidate_params);
 				return null;
 			}
 
 			if (best_candidate_dynamic) {
 				if (args[0].ArgType == Argument.AType.ExtensionType) {
 					rc.Report.Error (1973, loc,
 						"Type `{0}' does not contain a member `{1}' and the best extension method overload `{2}' cannot be dynamically dispatched. Consider calling the method without the extension method syntax",
 						args [0].Type.GetSignatureForError (), best_candidate.Name, best_candidate.GetSignatureForError ());
 				}
 
 				BestCandidateIsDynamic = true;
 				return null;
 			}
 
 			if (ambiguous_candidates != null) {
 				//
 				// Now check that there are no ambiguities i.e the selected method
 				// should be better than all the others
 				//
 				for (int ix = 0; ix < ambiguous_candidates.Count; ix++) {
 					var candidate = ambiguous_candidates [ix];
 
 					if (!BetterFunction (rc, best_candidate_args, best_candidate, best_parameter_member.Parameters, best_candidate_params, candidate.Member, candidate.Parameters, candidate.Expanded)) {
 						var ambiguous = candidate.Member;
 						if (custom_errors == null || !custom_errors.AmbiguousCandidates (rc, best_candidate, ambiguous)) {
 							rc.Report.SymbolRelatedToPreviousError (best_candidate);
 							rc.Report.SymbolRelatedToPreviousError (ambiguous);
 							rc.Report.Error (121, loc, "The call is ambiguous between the following methods or properties
 								best_candidate.GetSignatureForError (), ambiguous.GetSignatureForError ());
 						}
 
 						return (T) best_candidate;
 					}
 				}
 			}
 
 			if (invocable_member != null) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.SymbolRelatedToPreviousError (invocable_member);
 				rc.Report.Warning (467, 2, loc, "Ambiguity between method `{0}' and invocable non-method `{1}'. Using method group",
 					best_candidate.GetSignatureForError (), invocable_member.GetSignatureForError ());
 			}
 
 			//
 			// And now check if the arguments are all
 			// compatible, perform conversions if
 			// necessary etc. and return if everything is
 			// all right
 			//
 			if (!VerifyArguments (rc, ref best_candidate_args, best_candidate, best_parameter_member, best_candidate_params))
 				return null;
 
 			if (best_candidate == null)
 				return null;
 
 			//
 			// Check ObsoleteAttribute on the best method
 			//
 			ObsoleteAttribute oa = best_candidate.GetAttributeObsolete ();
 			if (oa != null && !rc.IsObsolete)
 				AttributeTester.Report_ObsoleteMessage (oa, best_candidate.GetSignatureForError (), loc, rc.Report);
 
 			var dep = best_candidate.GetMissingDependencies ();
 			if (dep != null) {
 				ImportedTypeDefinition.Error_MissingDependency (rc, dep, loc);
 			}
 
 			best_candidate.MemberDefinition.SetIsUsed ();
 
 			args = best_candidate_args;
 			return (T) best_candidate;
 		}
 
 		public MethodSpec ResolveOperator (ResolveContext rc, ref Arguments args)
 		{
 			return ResolveMember<MethodSpec> (rc, ref args);
 		}
 
 		void ReportArgumentMismatch (ResolveContext ec, int idx, MemberSpec method,
 													Argument a, AParametersCollection expected_par, TypeSpec paramType)
 		{
 			if (custom_errors != null && custom_errors.ArgumentMismatch (ec, method, a, idx))
 				return;
 
 			if (a is CollectionElementInitializer.ElementInitializerArgument) {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				if ((expected_par.FixedParameters[idx].ModFlags & Parameter.Modifier.ISBYREF) != 0) {
 					ec.Report.Error (1954, loc, "The best overloaded collection initalizer method `{0}' cannot have 'ref', or `out' modifier",
 						TypeManager.CSharpSignature (method));
 					return;
 				}
 				ec.Report.Error (1950, loc, "The best overloaded collection initalizer method `{0}' has some invalid arguments",
 					  TypeManager.CSharpSignature (method));
 			} else if (IsDelegateInvoke) {
 				ec.Report.Error (1594, loc, "Delegate `{0}' has some invalid arguments",
 					DelegateType.GetSignatureForError ());
 			} else {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				ec.Report.Error (1502, loc, "The best overloaded method match for `{0}' has some invalid arguments",
 					method.GetSignatureForError ());
 			}
 
 			Parameter.Modifier mod = idx >= expected_par.Count ? 0 
 
 			string index = (idx + 1).ToString ();
 			if (((mod & (Parameter.Modifier.REF | Parameter.Modifier.OUT)) ^
 				(a.Modifier & (Parameter.Modifier.REF | Parameter.Modifier.OUT))) != 0) {
 				if ((mod & Parameter.Modifier.ISBYREF) == 0)
 					ec.Report.Error (1615, loc, "Argument `#{0}' does not require `{1}' modifier. Consider removing `{1}' modifier",
 						index, Parameter.GetModifierSignature (a.Modifier));
 				else
 					ec.Report.Error (1620, loc, "Argument `#{0}' is missing `{1}' modifier",
 						index, Parameter.GetModifierSignature (mod));
 			} else {
 				string p1 = a.GetSignatureForError ();
 				string p2 = TypeManager.CSharpName (paramType);
 
 				if (p1 == p2) {
 					ec.Report.ExtraInformation (loc, "(equally named types possibly from different assemblies in previous ");
 					ec.Report.SymbolRelatedToPreviousError (a.Expr.Type);
 					ec.Report.SymbolRelatedToPreviousError (paramType);
 				}
 
 				ec.Report.Error (1503, loc,
 					"Argument `#{0}' cannot convert `{1}' expression to type `{2}'", index, p1, p2);
 			}
 		}
 
 		//
 		// We have failed to find exact match so we return error info about the closest match
 		//
 		void ReportOverloadError (ResolveContext rc, MemberSpec best_candidate, IParametersMember pm, Arguments args, bool params_expanded)
 		{
 			int ta_count = type_arguments == null ? 0 
 			int arg_count = args == null ? 0 
 
 			if (ta_count != best_candidate.Arity && (ta_count > 0 || ((IParametersMember) best_candidate).Parameters.IsEmpty)) {
 				var mg = new MethodGroupExpr (new [] { best_candidate }, best_candidate.DeclaringType, loc);
 				mg.Error_TypeArgumentsCannotBeUsed (rc.Report, loc, best_candidate, ta_count);
 				return;
 			}
 
 			if (lambda_conv_msgs != null) {
 				if (lambda_conv_msgs.Merge (rc.Report.Printer))
 					return;
 			}
 
 			//
 			// For candidates which match on parameters count report more details about incorrect arguments
 			//
 			if (pm != null) {
 				int unexpanded_count = ((IParametersMember) best_candidate).Parameters.HasParams ? pm.Parameters.Count - 1 
 				if (pm.Parameters.Count == arg_count || params_expanded || unexpanded_count == arg_count) {
 					// Reject any inaccessible member
 					if (!best_candidate.IsAccessible (rc.CurrentType) || !best_candidate.DeclaringType.IsAccessible (rc.CurrentType)) {
 						rc.Report.SymbolRelatedToPreviousError (best_candidate);
 						Expression.ErrorIsInaccesible (rc, best_candidate.GetSignatureForError (), loc);
 						return;
 					}
 
 					var ms = best_candidate as MethodSpec;
 					if (ms != null && ms.IsGeneric) {
 						bool constr_ok = true;
 						if (ms.TypeArguments != null)
 							constr_ok = new ConstraintChecker (rc.MemberContext).CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc);
 
 						if (ta_count == 0) {
 							if (custom_errors != null && custom_errors.TypeInferenceFailed (rc, best_candidate))
 								return;
 
 							if (constr_ok) {
 								rc.Report.Error (411, loc,
 									"The type arguments for method `{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly",
 									ms.GetGenericMethodDefinition ().GetSignatureForError ());
 							}
 
 							return;
 						}
 					}
 
 					VerifyArguments (rc, ref args, best_candidate, pm, params_expanded);
 					return;
 				}
 			}
 
 			//
 			// We failed to find any method with correct argument count, report best candidate
 			//
 			if (custom_errors != null && custom_errors.NoArgumentMatch (rc, best_candidate))
 				return;
 
 			if (best_candidate.Kind == MemberKind.Constructor) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				Error_ConstructorMismatch (rc, best_candidate.DeclaringType, arg_count, loc);
 			} else if (IsDelegateInvoke) {
 				rc.Report.SymbolRelatedToPreviousError (DelegateType);
 				rc.Report.Error (1593, loc, "Delegate `{0}' does not take `{1}' arguments",
 					DelegateType.GetSignatureForError (), arg_count.ToString ());
 			} else {
 				string name = best_candidate.Kind == MemberKind.Indexer ? "this" 
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.Error (1501, loc, "No overload for method `{0}' takes `{1}' arguments",
 					name, arg_count.ToString ());
 			}
 		}
 
 		bool VerifyArguments (ResolveContext ec, ref Arguments args, MemberSpec member, IParametersMember pm, bool chose_params_expanded)
 		{
 			var pd = pm.Parameters;
 			TypeSpec[] ptypes = ((IParametersMember) member).Parameters.Types;
 
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 			int a_idx = 0, a_pos = 0;
 			Argument a = null;
 			ArrayInitializer params_initializers = null;
 			bool has_unsafe_arg = pm.MemberType.IsPointer;
 			int arg_count = args == null ? 0 
 
 			for (; a_idx < arg_count; a_idx++, ++a_pos) {
 				a = args[a_idx];
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = pd.FixedParameters[a_idx].ModFlags;
 					pt = ptypes[a_idx];
 					has_unsafe_arg |= pt.IsPointer;
 
 					if (p_mod == Parameter.Modifier.PARAMS) {
 						if (chose_params_expanded) {
 							params_initializers = new ArrayInitializer (arg_count - a_idx, a.Expr.Location);
 							pt = TypeManager.GetElementType (pt);
 						}
 					}
 				}
 
 				//
 				// Types have to be identical when ref or out modifer is used 
 				//
 				if (a.Modifier != 0 || (p_mod & ~Parameter.Modifier.PARAMS) != 0) {
 					if ((p_mod & ~Parameter.Modifier.PARAMS) != a.Modifier)
 						break;
 
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt))
 						continue;
 
 					break;
 				}
 
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int name_index = pd.GetParameterIndexByName (na.Name);
 					if (name_index < 0 || name_index >= pd.Count) {
 						if (IsDelegateInvoke) {
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 							ec.Report.Error (1746, na.Location,
 								"The delegate `{0}' does not contain a parameter named `{1}'",
 								DelegateType.GetSignatureForError (), na.Name);
 						} else {
 							ec.Report.SymbolRelatedToPreviousError (member);
 							ec.Report.Error (1739, na.Location,
 								"The best overloaded method match for `{0}' does not contain a parameter named `{1}'",
 								TypeManager.CSharpSignature (member), na.Name);
 						}
 					} else if (args[name_index] != a) {
 						if (IsDelegateInvoke)
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 						else
 							ec.Report.SymbolRelatedToPreviousError (member);
 
 						ec.Report.Error (1744, na.Location,
 							"Named argument `{0}' cannot be used for a parameter which has positional argument specified",
 							na.Name);
 					}
 				}
 				
 				if (a.Expr.Type == InternalType.Dynamic)
 					continue;
 
 				if ((restrictions & Restrictions.CovariantDelegate) != 0 && !Delegate.IsTypeCovariant (a.Expr, pt)) {
 					custom_errors.NoArgumentMatch (ec, member);
 					return false;
 				}
 
 				Expression conv = null;
 				if (a.ArgType == Argument.AType.ExtensionType) {
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt)) {
 						conv = a.Expr;
 					} else {
 						conv = Convert.ImplicitReferenceConversion (a.Expr, pt, false);
 						if (conv == null)
 							conv = Convert.ImplicitBoxingConversion (a.Expr, a.Expr.Type, pt);
 					}
 				} else {
 					conv = Convert.ImplicitConversion (ec, a.Expr, pt, loc);
 				}
 
 				if (conv == null)
 					break;
 
 				//
 				// Convert params arguments to an array initializer
 				//
 				if (params_initializers != null) {
 					// we choose to use 'a.Expr' rather than 'conv' so that
 					// we don't hide the kind of expression we have (esp. CompoundAssign.Helper)
 					params_initializers.Add (a.Expr);
 					args.RemoveAt (a_idx--);
 					--arg_count;
 					continue;
 				}
 
 				// Update the argument with the implicit conversion
 				a.Expr = conv;
 			}
 
 			if (a_idx != arg_count) {
 				ReportArgumentMismatch (ec, a_pos, member, a, pd, pt);
 				return false;
 			}
 
 			//
 			// Fill not provided arguments required by params modifier
 			//
 			if (params_initializers == null && pd.HasParams && arg_count + 1 == pd.Count) {
 				if (args == null)
 					args = new Arguments (1);
 
 				pt = ptypes[pd.Count - 1];
 				pt = TypeManager.GetElementType (pt);
 				has_unsafe_arg |= pt.IsPointer;
 				params_initializers = new ArrayInitializer (0, loc);
 			}
 
 			//
 			// Append an array argument with all params arguments
 			//
 			if (params_initializers != null) {
 				args.Add (new Argument (
 					new ArrayCreation (new TypeExpression (pt, loc), params_initializers, loc).Resolve (ec)));
 				arg_count++;
 			}
 
 			if (has_unsafe_arg && !ec.IsUnsafe) {
 				Expression.UnsafeError (ec, loc);
 			}
 
 			//
 			// We could infer inaccesible type arguments
 			//
 			if (type_arguments == null && member.IsGeneric) {
 				var ms = (MethodSpec) member;
 				foreach (var ta in ms.TypeArguments) {
 					if (!ta.IsAccessible (ec.CurrentType)) {
 						ec.Report.SymbolRelatedToPreviousError (ta);
 						Expression.ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						break;
 					}
 				}
 			}
 
 			return true;
 		}
 	}
 
 	public class ConstantExpr 
 	{
 		ConstSpec constant;
 
 		public ConstantExpr (ConstSpec constant, Location loc)
 		{
 			this.constant = constant;
 			this.loc = loc;
 		}
]]></clone_fragment>
<clone_fragment endline="276" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" hamdist="10" pcid="1003" startline="63"><![CDATA[
 
 		protected FieldBase (DeclSpace parent, FullNamedExpression type, Modifiers mod,
 				     Modifiers allowed_mod, MemberName name, Attributes attrs)
 			
 				name, attrs)
 		{
 			if ((mod & Modifiers.ABSTRACT) != 0)
 				Report.Error (681, Location, "The modifier 'abstract' is not valid on fields. Try using a property instead");
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Field;
 			}
 		}
 
 		public Expression Initializer {
 			get {
 				return initializer;
 			}
 			set {
 				this.initializer = value;
 			}
 		}
 
 		public FieldSpec Spec {
 			get {
 				return spec;
 			}
 		}
 
 		public override string[] ValidAttributeTargets  {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.FieldOffset) {
 				status |= Status.HAS_OFFSET;
 
 				if (!Parent.PartialContainer.HasExplicitLayout) {
 					Report.Error (636, Location, "The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)");
 					return;
 				}
 
 				if ((ModFlags & Modifiers.STATIC) != 0 || this is Const) {
 					Report.Error (637, Location, "The FieldOffset attribute is not allowed on static or const fields");
 					return;
 				}
 			}
 
 			if (a.Type == pa.FixedBuffer) {
 				Report.Error (1716, Location, "Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead");
 				return;
 			}
 
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					FieldBuilder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			FieldBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public void SetCustomAttribute (MethodSpec ctor, byte[] data)
 		{
 			FieldBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), data);
 		}
 
  		protected override bool CheckBase ()
 		{
  			if (!base.CheckBase ())
  				return false;
 
 			MemberSpec candidate;
 			var conflict_symbol = MemberCache.FindBaseMember (this, out candidate);
 			if (conflict_symbol == null)
 				conflict_symbol = candidate;
 
  			if (conflict_symbol == null) {
  				if ((ModFlags & Modifiers.NEW) != 0) {
  					Report.Warning (109, 4, Location, "The member `{0}' does not hide an inherited member. The new keyword is not required",
 						GetSignatureForError ());
  				}
  			} else {
 				if ((ModFlags & (Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.BACKING_FIELD)) == 0) {
 					Report.SymbolRelatedToPreviousError (conflict_symbol);
 					Report.Warning (108, 2, Location, "`{0}' hides inherited member `{1}'. Use the new keyword if hiding was intended",
 						GetSignatureForError (), conflict_symbol.GetSignatureForError ());
 				}
 
 				if (conflict_symbol.IsAbstract) {
 					Report.SymbolRelatedToPreviousError (conflict_symbol);
 					Report.Error (533, Location, "`{0}' hides inherited abstract member `{1}'",
 						GetSignatureForError (), conflict_symbol.GetSignatureForError ());
 				}
 			}
  
  			return true;
  		}
 
 		public virtual Constant ConvertInitializer (ResolveContext rc, Constant expr)
 		{
 			return expr.ConvertImplicitly (rc, MemberType);
 		}
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			if (MemberType.IsGenericParameter)
 				return;
 
 			if (MemberType.IsStatic)
 				Error_VariableOfStaticClass (Location, GetSignatureForError (), MemberType, Report);
 
 			CheckBase ();
 			IsTypePermitted ();
 		}
 
 		//
 		//   Represents header string for documentation comment.
 		//
 		public override string DocCommentHeader {
 			get { return "F
 		}
 
 		public override void Emit ()
 		{
 			if (member_type == InternalType.Dynamic) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (FieldBuilder);
 			} else if (!(Parent is CompilerGeneratedClass) && member_type.HasDynamicElement) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (FieldBuilder, member_type, Location);
 			}
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (FieldBuilder);
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			if (((status & Status.HAS_OFFSET) == 0) && (ModFlags & (Modifiers.STATIC | Modifiers.BACKING_FIELD)) == 0 && Parent.PartialContainer.HasExplicitLayout) {
 				Report.Error (625, Location, "`{0}'
 			}
 
 			base.Emit ();
 		}
 
 		public static void Error_VariableOfStaticClass (Location loc, string variable_name, TypeSpec static_class, Report Report)
 		{
 			Report.SymbolRelatedToPreviousError (static_class);
 			Report.Error (723, loc, "`{0}'
 				variable_name);
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (!MemberType.IsCLSCompliant () || this is FixedField) {
 				Report.Warning (3003, 1, Location, "Type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
 	}
 
 	//
 	// Field specification
 	//
 	public class FieldSpec 
 	{
 		FieldInfo metaInfo;
 		TypeSpec memberType;
 
 		public FieldSpec (TypeSpec declaringType, IMemberDefinition definition, TypeSpec memberType, FieldInfo info, Modifiers modifiers)
 			
 		{
 			this.metaInfo = info;
 			this.memberType = memberType;
 		}
]]></clone_fragment>
<clone_fragment endline="253" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" hamdist="5" pcid="5563" startline="44"><![CDATA[
 
 		bool is_double_colon;
 
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    Location loc)
 		{
 			this.Name = name;
 			this.Location = loc;
 			this.is_double_colon = is_double_colon;
 			this.Left = left;
 		}
 
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    TypeArguments args, Location loc)
 			
 		{
 			if (args != null && args.Count > 0)
 				this.TypeArguments = args;
 		}
 
 		public MemberName (string name)
 			
 		{ }
 
 		public MemberName (string name, Location loc)
 			
 		{ }
 
 		public MemberName (string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, string name)
 			
 		{ }
 
 		public MemberName (MemberName left, string name, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (string alias, string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, MemberName right)
 			
 		{ }
 
 		public MemberName (MemberName left, MemberName right, Location loc)
 			
 		{
 			if (right.is_double_colon)
 				throw new InternalErrorException ("Cannot append double_colon member name");
 			this.Left = (right.Left == null) ? left 
 		}
 
 		// TODO
 		public string GetName ()
 		{
 			return GetName (false);
 		}
 
 		public int Arity {
 			get {
 				return TypeArguments == null ? 0 
 			}
 		}
 
 		public bool IsGeneric {
 			get {
 				if (TypeArguments != null)
 					return true;
 				else if (Left != null)
 					return Left.IsGeneric;
 				else
 					return false;
 			}
 		}
 
 		public string GetName (bool is_generic)
 		{
 			string name = is_generic ? Basename 
 			if (Left != null)
 				return Left.GetName (is_generic) + (is_double_colon ? "
 
 			return name;
 		}
 
 		public ATypeNameExpression GetTypeExpression ()
 		{
 			if (Left == null) {
 				if (TypeArguments != null)
 					return new SimpleName (Name, TypeArguments, Location);
 				
 				return new SimpleName (Name, Location);
 			}
 
 			if (is_double_colon) {
 				if (Left.Left != null)
 					throw new InternalErrorException ("The left side of a 
 				return new QualifiedAliasMember (Left.Name, Name, TypeArguments, Location);
 			}
 
 			Expression lexpr = Left.GetTypeExpression ();
 			return new MemberAccess (lexpr, Name, TypeArguments, Location);
 		}
 
 		public MemberName Clone ()
 		{
 			MemberName left_clone = Left == null ? null 
 			return new MemberName (left_clone, Name, is_double_colon, TypeArguments, Location);
 		}
 
 		public string Basename {
 			get {
 				if (TypeArguments != null)
 					return MakeName (Name, TypeArguments);
 				return Name;
 			}
 		}
 
 		public string GetSignatureForError ()
 		{
 			string append = TypeArguments == null ? "" 
 			if (Left == null)
 				return Name + append;
 			string connect = is_double_colon ? "
 			return Left.GetSignatureForError () + connect + Name + append;
 		}
 
 		public override bool Equals (object other)
 		{
 			return Equals (other as MemberName);
 		}
 
 		public bool Equals (MemberName other)
 		{
 			if (this == other)
 				return true;
 			if (other == null || Name != other.Name)
 				return false;
 			if (is_double_colon != other.is_double_colon)
 				return false;
 
 			if ((TypeArguments != null) &&
 			    (other.TypeArguments == null || TypeArguments.Count != other.TypeArguments.Count))
 				return false;
 
 			if ((TypeArguments == null) && (other.TypeArguments != null))
 				return false;
 
 			if (Left == null)
 				return other.Left == null;
 
 			return Left.Equals (other.Left);
 		}
 
 		public override int GetHashCode ()
 		{
 			int hash = Name.GetHashCode ();
 			for (MemberName n = Left; n != null; n = n.Left)
 				hash ^= n.Name.GetHashCode ();
 			if (is_double_colon)
 				hash ^= 0xbadc01d;
 
 			if (TypeArguments != null)
 				hash ^= TypeArguments.Count << 5;
 
 			return hash & 0x7FFFFFFF;
 		}
 
 		public int CountTypeArguments {
 			get {
 				if (TypeArguments != null)
 					return TypeArguments.Count;
 				else if (Left != null)
 					return Left.CountTypeArguments; 
 				else
 					return 0;
 			}
 		}
 
 		public static string MakeName (string name, TypeArguments args)
 		{
 			if (args == null)
 				return name;
 
 			return name + "`" + args.Count;
 		}
 
 		public static string MakeName (string name, int count)
 		{
 			return name + "`" + count;
 		}
 	}
 
 	public class SimpleMemberName
 	{
 		public string Value;
 		public Location Location;
 
 		public SimpleMemberName (string name, Location loc)
 		{
 			this.Value = name;
 			this.Location = loc;
 		}
]]></clone_fragment>
<clone_fragment endline="7794" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="6" pcid="1621" startline="7619"><![CDATA[
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			var sn = expr as SimpleName;
 			const ResolveFlags flags = ResolveFlags.VariableOrValue | ResolveFlags.Type;
 
 			//
 			// Resolve the expression with flow analysis turned off, we'll do the definite
 			// assignment checks later.  This is because we don't know yet what the expression
 			// will resolve to - it may resolve to a FieldExpr and in this case we must do the
 			// definite assignment check on the actual field and not on the whole struct.
 			//
 			using (rc.Set (ResolveContext.Options.OmitStructFlowAnalysis)) {
 				if (sn != null) {
 					expr = sn.LookupNameExpression (rc, MemberLookupRestrictions.ReadAccess | MemberLookupRestrictions.ExactArity);
 
 					// Call resolve on expression which does have type set as we need expression type
 					// TODO
 					if (expr is VariableReference || expr is ConstantExpr || expr is Linq.TransparentMemberAccess) {
 						using (rc.With (ResolveContext.Options.DoFlowAnalysis, false)) {
 							expr = expr.Resolve (rc);
 						}
 					} else if (expr is TypeParameterExpr) {
 						expr.Error_UnexpectedKind (rc, flags, sn.Location);
 						expr = null;
 					}
 				} else {
 					expr = expr.Resolve (rc, flags);
 				}
 			}
 
 			if (expr == null)
 				return null;
 
 			Namespace ns = expr as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 					return null;
 				}
 
 				if (HasTypeArguments)
 					return new GenericTypeExpr (retval.Type, targs, loc);
 
 				return retval;
 			}
 
 			MemberExpr me;
 			TypeSpec expr_type = expr.Type;
 			if (expr_type == InternalType.Dynamic) {
 				me = expr as MemberExpr;
 				if (me != null)
 					me.ResolveInstanceExpression (rc, null);
 
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return new DynamicMemberBinder (Name, args, loc);
 			}
 
 			const MemberKind dot_kinds = MemberKind.Class | MemberKind.Struct | MemberKind.Delegate | MemberKind.Enum |
 				MemberKind.Interface | MemberKind.TypeParameter | MemberKind.ArrayType;
 
 			if ((expr_type.Kind & dot_kinds) == 0 || expr_type == TypeManager.void_type) {
 				if (expr_type == InternalType.Null && rc.Compiler.IsRuntimeBinder)
 					rc.Report.Error (Report.RuntimeErrorId, loc, "Cannot perform member binding on `null' value");
 				else
 					Unary.Error_OperatorCannotBeApplied (rc, loc, ".", expr_type);
 				return null;
 			}
 
 			var current_type = rc.CurrentType;
 			var lookup_arity = Arity;
 			bool errorMode = false;
 			Expression member_lookup;
 			while (true) {
 				member_lookup = MemberLookup (errorMode ? null 
 				if (member_lookup == null) {
 					//
 					// Try to look for extension method when member lookup failed
 					//
 					if (MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 						NamespaceEntry scope = null;
 						var methods = rc.LookupExtensionMethod (expr_type, Name, lookup_arity, ref scope);
 						if (methods != null) {
 							var emg = new ExtensionMethodGroupExpr (methods, scope, expr, loc);
 							if (HasTypeArguments) {
 								if (!targs.Resolve (rc))
 									return null;
 
 								emg.SetTypeArguments (rc, targs);
 							}
 
 							// TODO
 							return emg.Resolve (rc);
 						}
 					}
 				}
 
 				if (errorMode) {
 					if (member_lookup == null) {
 						if (expr is TypeExpr)
 							base.Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 						else
 							Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 
 						return null;
 					}
 
 					if (member_lookup is MethodGroupExpr) {
 						// Leave it to overload resolution to report correct error
 					} else {
 						// TODO
 						ErrorIsInaccesible (rc, member_lookup.GetSignatureForError (), loc);
 					}
 					break;
 				}
 
 				if (member_lookup != null)
 					break;
 
 				current_type = null;
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 			while (true) {
 				member_lookup = MemberLookup (errorMode ? null 
 				if (member_lookup == null) {
 					//
 					// Try to look for extension method when member lookup failed
 					//
 					if (MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 						NamespaceEntry scope = null;
 						var methods = rc.LookupExtensionMethod (expr_type, Name, lookup_arity, ref scope);
 						if (methods != null) {
 							var emg = new ExtensionMethodGroupExpr (methods, scope, expr, loc);
 							if (HasTypeArguments) {
 								if (!targs.Resolve (rc))
 									return null;
 
 								emg.SetTypeArguments (rc, targs);
 							}
 
 							// TODO
 							return emg.Resolve (rc);
 						}
 					}
 				}
 
 				if (errorMode) {
 					if (member_lookup == null) {
 						if (expr is TypeExpr)
 							base.Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 						else
 							Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 
 						return null;
 					}
 
 					if (member_lookup is MethodGroupExpr) {
 						// Leave it to overload resolution to report correct error
 					} else {
 						// TODO
 						ErrorIsInaccesible (rc, member_lookup.GetSignatureForError (), loc);
 					}
 					break;
 				}
 
 				if (member_lookup != null)
 					break;
 
 				current_type = null;
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 
 			TypeExpr texpr = member_lookup as TypeExpr;
 			if (texpr != null) {
 				if (!(expr is TypeExpr)) {
 					me = expr as MemberExpr;
 					if (me == null || me.ProbeIdenticalTypeName (rc, expr, sn) == expr) {
 						rc.Report.Error (572, loc, "`{0}'
 							Name, member_lookup.GetSignatureForError ());
 						return null;
 					}
 				}
 
 				if (!texpr.Type.IsAccessible (rc.CurrentType)) {
 					rc.Report.SymbolRelatedToPreviousError (member_lookup.Type);
 					ErrorIsInaccesible (rc, member_lookup.Type.GetSignatureForError (), loc);
 					return null;
 				}
 
 				if (HasTypeArguments) {
 					return new GenericTypeExpr (member_lookup.Type, targs, loc);
 				}
 
 				return member_lookup;
 			}
 
 			me = member_lookup as MemberExpr;
 
 			if (sn != null && me.IsStatic)
 				expr = me.ProbeIdenticalTypeName (rc, expr, sn);
 
 			me = me.ResolveMemberAccess (rc, expr, sn);
 
 			if (Arity > 0) {
 				if (!targs.Resolve (rc))
 					return null;
 
 				me.SetTypeArguments (rc, targs);
 			}
 
 			if (sn != null && (!TypeManager.IsValueType (expr_type) || me is PropertyExpr)) {
 				if (me.IsInstance) {
 					LocalVariableReference var = expr as LocalVariableReference;
 					if (var != null && !var.VerifyAssigned (rc))
 						return null;
 				}
 			}
 
 			return me;
 		}
]]></clone_fragment>
<clone_fragment endline="736" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="6" pcid="5477" startline="459"><![CDATA[
 	}
 
 	public abstract class MethodOrOperator 
 	{
 		public MethodBuilder MethodBuilder;
 		ReturnParameter return_attributes;
 		SecurityType declarative_security;
 		protected MethodData MethodData;
 
 		static string[] attribute_targets = new string [] { "method", "return" };
 
 		protected MethodOrOperator (DeclSpace parent, GenericMethod generic, FullNamedExpression type, Modifiers mod,
 				Modifiers allowed_mod, MemberName name,
 				Attributes attrs, ParametersCompiled parameters)
 			
 					attrs, parameters)
 		{
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			if (a.Type == pa.DllImport) {
 				const Modifiers extern_static = Modifiers.EXTERN | Modifiers.STATIC;
 				if ((ModFlags & extern_static) != extern_static) {
 					Report.Error (601, a.Location, "The DllImport attribute must be specified on a method marked `static' and `extern'");
 				}
 				is_external_implementation = true;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (MethodBuilder != null)
 				MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Method; 
 			}
 		}
 
 		protected override bool CheckForDuplications ()
 		{
 			return Parent.MemberCache.CheckExistingMembersOverloads (this, parameters);
 		}
 
 		public virtual EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			return new EmitContext (this, ig, MemberType);
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!CheckBase ())
 				return false;
 
 			MemberKind kind;
 			if (this is Operator)
 				kind = MemberKind.Operator;
 			else if (this is Destructor)
 				kind = MemberKind.Destructor;
 			else
 				kind = MemberKind.Method;
 
 			if (IsPartialDefinition) {
 				caching_flags &= ~Flags.Excluded_Undetected;
 				caching_flags |= Flags.Excluded;
 
 				// Add to member cache only when a partial method implementation has not been found yet
 				if ((caching_flags & Flags.PartialDefinitionExists) == 0) {
 //					MethodBase mb = new PartialMethodDefinitionInfo (this);
 
 					spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, null, parameters, ModFlags);
 					Parent.MemberCache.AddMember (spec);
 				}
 
 				return true;
 			}
 
 			MethodData = new MethodData (
 				this, ModFlags, flags, this, MethodBuilder, GenericMethod, base_method);
 
 			if (!MethodData.Define (Parent.PartialContainer, GetFullName (MemberName), Report))
 				return false;
 					
 			MethodBuilder = MethodData.MethodBuilder;
 
 			spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, MethodBuilder, parameters, ModFlags);
 			if (MemberName.Arity > 0)
 				spec.IsGeneric = true;
 			
 			Parent.MemberCache.AddMember (this, MethodBuilder.Name, spec);
 
 			return true;
 		}
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			CheckAbstractAndExtern (block != null);
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0) {
 				for (int i = 0; i < parameters.Count; ++i) {
 					IParameterData p = parameters.FixedParameters [i];
 					if (p.ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (752, Location, "`{0}'
 							GetSignatureForError ());
 					}
 
 					if (p.HasDefaultValue && IsPartialImplementation)
 						((Parameter) p).Warning_UselessOptionalParameter (Report);
 				}
 			}
 		}
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			if (MemberType.IsStatic) {
 				Error_StaticReturnType ();
 			}
 		}
 
 		public override void Emit ()
 		{
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (MethodBuilder);
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			if (MethodData != null)
 				MethodData.Emit (Parent);
 
 			base.Emit ();
 
 			Block = null;
 			MethodData = null;
 		}
 
 		protected void Error_ConditionalAttributeIsNotValid ()
 		{
 			Report.Error (577, Location,
 				"Conditional not valid on `{0}' because it is a constructor, destructor, operator or explicit interface implementation",
 				GetSignatureForError ());
 		}
 
 		public bool IsPartialDefinition {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block == null;
 			}
 		}
 
 		public bool IsPartialImplementation {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block != null;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#region IMethodData Members
 
 		public TypeSpec ReturnType {
 			get {
 				return MemberType;
 			}
 		}
 
 		public MemberName MethodName {
 			get {
 				return MemberName;
 			}
 		}
 
 		/// <summary>
 		/// Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
 		/// </summary>
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.Excluded) != 0)
 				return new string [0];
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 			string[] conditions;
 
 			if (base_method == null) {
 				if (OptAttributes == null)
 					return null;
 
 				Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 				if (attrs == null)
 					return null;
 
 				conditions = new string[attrs.Length];
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			} else {
 				conditions = base_method.MemberDefinition.ConditionalConditions();
 			}
 
 			if (conditions != null)
 				caching_flags |= Flags.Excluded;
 
 			return conditions;
 		}
 
 		GenericMethod IMethodData.GenericMethod {
 			get {
 				return GenericMethod;
 			}
 		}
 
 		public virtual void EmitExtraSymbolInfo (SourceMethod source)
 		{ }
 
 		#endregion
 
 	}
 
 	public class SourceMethod 
 	{
 		MethodBase method;
 		SourceMethodBuilder builder;
 
 		protected SourceMethod (DeclSpace parent, MethodBase method, ICompileUnit file)
 		{
 			this.method = method;
 			
 			builder = SymbolWriter.OpenMethod (file, parent.NamespaceEntry.SymbolFileID, this);
 		}
]]></clone_fragment>
<clone_fragment endline="381" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" hamdist="7" pcid="225" startline="96"><![CDATA[
 
 		// <summary>
 		//   The type of this flow branching.
 		// </summary>
 		public readonly BranchingType Type;
 
 		// <summary>
 		//   The block this branching is contained in.  This may be null if it's not
 		//   a top-level block and it doesn't declare any local variables.
 		// </summary>
 		public readonly Block Block;
 
 		// <summary>
 		//   The parent of this branching or null if this is the top-block.
 		// </summary>
 		public readonly FlowBranching Parent;
 
 		// <summary>
 		//   Start-Location of this flow branching.
 		// </summary>
 		public readonly Location Location;
 
 		static int next_id = 0;
 		int id;
 
 		// <summary>
 		//   The vector contains a BitArray with information about which local variables
 		//   and parameters are already initialized at the current code position.
 		// </summary>
 		public class UsageVector {
 			// <summary>
 			//   The type of this branching.
 			// </summary>
 			public readonly SiblingType Type;
 
 			// <summary>
 			//   Start location of this branching.
 			// </summary>
 			public Location Location;
 
 			// <summary>
 			//   This is only valid for SwitchSection, Try, Catch and Finally.
 			// </summary>
 			public readonly Block Block;
 
 			// <summary>
 			//   The number of locals in this block.
 			// </summary>
 			public readonly int CountLocals;
 
 			// <summary>
 			//   If not null, then we inherit our state from this vector and do a
 			//   copy-on-write.  If null, then we're the first sibling in a top-level
 			//   block and inherit from the empty vector.
 			// </summary>
 			public readonly UsageVector InheritsFrom;
 
 			// <summary>
 			//   This is used to construct a list of UsageVector's.
 			// </summary>
 			public UsageVector Next;
 
 			//
 			// Private.
 			//
 			MyBitVector locals;
 			bool is_unreachable;
 
 			static int next_id = 0;
 			int id;
 
 			//
 			// Normally, you should not use any of these constructors.
 			//
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc, int num_locals)
 			{
 				this.Type = type;
 				this.Block = block;
 				this.Location = loc;
 				this.InheritsFrom = parent;
 				this.CountLocals = num_locals;
 
 				locals = num_locals == 0 
 					? MyBitVector.Empty
 					
 
 				if (parent != null)
 					is_unreachable = parent.is_unreachable;
 
 				id = ++next_id;
 
 			}
 
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc)
 				
 			{ }
 
 			private UsageVector (MyBitVector locals, bool is_unreachable, Block block, Location loc)
 			{
 				this.Type = SiblingType.Block;
 				this.Location = loc;
 				this.Block = block;
 
 				this.is_unreachable = is_unreachable;
 
 				this.locals = locals;
 
 				id = ++next_id;
 
 			}
 
 			// <summary>
 			//   This does a deep copy of the usage vector.
 			// </summary>
 			public UsageVector Clone ()
 			{
 				UsageVector retval = new UsageVector (Type, null, Block, Location, CountLocals);
 
 				retval.locals = locals.Clone ();
 				retval.is_unreachable = is_unreachable;
 
 				return retval;
 			}
 
 			public bool IsAssigned (VariableInfo var, bool ignoreReachability)
 			{
 				if (!ignoreReachability && !var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsAssigned (locals);
 			}
 
 			public void SetAssigned (VariableInfo var)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetAssigned (locals);
 			}
 
 			public bool IsFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsFieldAssigned (locals, name);
 			}
 
 			public void SetFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetFieldAssigned (locals, name);
 			}
 
 			public bool IsUnreachable {
 				get { return is_unreachable; }
 			}
 
 			public void ResetBarrier ()
 			{
 				is_unreachable = false;
 			}
 
 			public void Goto ()
 			{
 				is_unreachable = true;
 			}
 
 			public static UsageVector MergeSiblings (UsageVector sibling_list, Location loc)
 			{
 				if (sibling_list.Next == null)
 					return sibling_list;
 
 				MyBitVector locals = null;
 				bool is_unreachable = sibling_list.is_unreachable;
 
 				if (!sibling_list.IsUnreachable)
 					locals &= sibling_list.locals;
 
 				for (UsageVector child = sibling_list.Next; child != null; child = child.Next) {
 					is_unreachable &= child.is_unreachable;
 
 					if (!child.IsUnreachable)
 						locals &= child.locals;
 				}
 
 				return new UsageVector (locals, is_unreachable, null, loc);
 			}
 
 			// <summary>
 			//   Merges a child branching.
 			// </summary>
 			public UsageVector MergeChild (UsageVector child, bool overwrite)
 			{
 				Report.Debug (2, "    MERGING CHILD EFFECTS", this, child, Type);
 
 				bool new_isunr = child.is_unreachable;
 
 				//
 				// We've now either reached the point after the branching or we will
 				// never get there since we always return or always throw an exception.
 				//
 				// If we can reach the point after the branching, mark all locals and
 				// parameters as initialized which have been initialized in all branches
 				// we need to look at (see above).
 				//
 
 				if ((Type == SiblingType.SwitchSection) && !new_isunr) {
 					Report.Error (163, Location,
 						      "Control cannot fall through from one " +
 						      "case label to another");
 					return child;
 				}
 
 				locals |= child.locals;
 
 				// throw away un-necessary information about variables in child blocks
 				if (locals.Count != CountLocals)
 					locals = new MyBitVector (locals, CountLocals);
 
 				if (overwrite)
 					is_unreachable = new_isunr;
 				else
 					is_unreachable |= new_isunr;
 
 				return child;
 			}
 
 			public void MergeOrigins (UsageVector o_vectors)
 			{
 				Report.Debug (1, "  MERGING BREAK ORIGINS", this);
 
 				if (o_vectors == null)
 					return;
 
 				if (IsUnreachable && locals != null)
 					locals.SetAll (true);
 
 				for (UsageVector vector = o_vectors; vector != null; vector = vector.Next) {
 					Report.Debug (1, "    MERGING BREAK ORIGIN", vector);
 					if (vector.IsUnreachable)
 						continue;
 					locals &= vector.locals;
 					is_unreachable &= vector.is_unreachable;
 				}
 
 				Report.Debug (1, "  MERGING BREAK ORIGINS DONE", this);
 			}
 
 			//
 			// Debugging stuff.
 			//
 
 			public override string ToString ()
 			{
 				return String.Format ("Vector ({0},{1},{2}-{3})", Type, id, is_unreachable, locals);
 			}
 		}
 
 		// <summary>
 		//   Creates a new flow branching which is contained in `parent'.
 		//   You should only pass non-null for the `block' argument if this block
 		//   introduces any new variables - in this case, we need to create a new
 		//   usage vector with a different size than our parent's one.
 		// </summary>
 		protected FlowBranching (FlowBranching parent, BranchingType type, SiblingType stype,
 					 Block block, Location loc)
 		{
 			Parent = parent;
 			Block = block;
 			Location = loc;
 			Type = type;
 			id = ++next_id;
 
 			UsageVector vector;
 			if (Block != null) {
 				UsageVector parent_vector = parent != null ? parent.CurrentUsageVector 
 				vector = new UsageVector (stype, parent_vector, Block, loc, Block.AssignableSlots);
 			} else {
 				vector = new UsageVector (stype, Parent.CurrentUsageVector, null, loc);
 			}
 
 			AddSibling (vector);
 		}
]]></clone_fragment>
<clone_fragment endline="476" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="7" pcid="1241" startline="186"><![CDATA[
 	}
 
 	public interface IGenericMethodDefinition 
 	{
 		TypeParameterSpec[] TypeParameters { get; }
 		int TypeParametersCount { get; }
 
 //		MethodInfo MakeGenericMethod (TypeSpec[] targs);
 	}
 
 	public sealed class MethodSpec 
 	{
 		MethodBase metaInfo, inflatedMetaInfo;
 		AParametersCollection parameters;
 		TypeSpec returnType;
 
 		TypeSpec[] targs;
 		TypeParameterSpec[] constraints;
 
 		public MethodSpec (MemberKind kind, TypeSpec declaringType, IMemberDefinition details, TypeSpec returnType,
 			MethodBase info, AParametersCollection parameters, Modifiers modifiers)
 			
 		{
 			this.metaInfo = info;
 			this.parameters = parameters;
 			this.returnType = returnType;
 		}
 
 		#region Properties
 
 		public override int Arity {
 			get {
 				return IsGeneric ? GenericDefinition.TypeParametersCount 
 			}
 		}
 
 		public TypeParameterSpec[] Constraints {
 			get {
 				if (constraints == null && IsGeneric)
 					constraints = GenericDefinition.TypeParameters;
 
 				return constraints;
 			}
 		}
 
 		public bool IsConstructor {
 			get {
 				return Kind == MemberKind.Constructor;
 			}
 		}
 
 		public IGenericMethodDefinition GenericDefinition {
 			get {
 				return (IGenericMethodDefinition) definition;
 			}
 		}
 
 		public bool IsExtensionMethod {
 			get {
 				return IsStatic && parameters.HasExtensionMethodType;
 			}
 		}
 
 		public bool IsSealed {
 			get {
 				return (Modifiers & Modifiers.SEALED) != 0;
 			}
 		}
 
 		// When is virtual or abstract
 		public bool IsVirtual {
 			get {
 				return (Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT | Modifiers.OVERRIDE)) != 0;
 			}
 		}
 
 		public bool IsReservedMethod {
 			get {
 				return Kind == MemberKind.Operator || IsAccessor;
 			}
 		}
 
 		TypeSpec IInterfaceMemberSpec.MemberType {
 			get {
 				return returnType;
 			}
 		}
 
 		public AParametersCollection Parameters {
 			get { 
 				return parameters;
 			}
 		}
 
 		public TypeSpec ReturnType {
 			get {
 				return returnType;
 			}
 		}
 
 		public TypeSpec[] TypeArguments {
 			get {
 				return targs;
 			}
 		}
 
 		#endregion
 
 		public MethodSpec GetGenericMethodDefinition ()
 		{
 			if (!IsGeneric && !DeclaringType.IsGeneric)
 				return this;
 
 			return MemberCache.GetMember (declaringType, this);
 		}
 
 		public MethodBase GetMetaInfo ()
 		{
 			//
 			// inflatedMetaInfo is extra field needed for cases where we
 			// inflate method but another nested type can later inflate
 			// again (the cache would be build with inflated metaInfo) and
 			// TypeBuilder can work with method definitions only
 			//
 			if (inflatedMetaInfo == null) {
 				if ((state & StateFlags.PendingMetaInflate) != 0) {
 					var dt_meta = DeclaringType.GetMetaInfo ();
 
 					if (DeclaringType.IsTypeBuilder) {
 						if (IsConstructor)
 							inflatedMetaInfo = TypeBuilder.GetConstructor (dt_meta, (ConstructorInfo) metaInfo);
 						else
 							inflatedMetaInfo = TypeBuilder.GetMethod (dt_meta, (MethodInfo) metaInfo);
 					} else {
 #if STATIC
 						// it should not be reached
 						throw new NotImplementedException ();
 #else
 						inflatedMetaInfo = MethodInfo.GetMethodFromHandle (metaInfo.MethodHandle, dt_meta.TypeHandle);
 #endif
 					}
 
 					state &= ~StateFlags.PendingMetaInflate;
 				} else {
 					inflatedMetaInfo = metaInfo;
 				}
 			}
 
 			if ((state & StateFlags.PendingMakeMethod) != 0) {
 				var sre_targs = new MetaType[targs.Length];
 				for (int i = 0; i < sre_targs.Length; ++i)
 					sre_targs[i] = targs[i].GetMetaInfo ();
 
 				inflatedMetaInfo = ((MethodInfo) inflatedMetaInfo).MakeGenericMethod (sre_targs);
 				state &= ~StateFlags.PendingMakeMethod;
 			}
 
 			return inflatedMetaInfo;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			string name;
 			if (IsConstructor) {
 				name = DeclaringType.GetSignatureForError () + "." + DeclaringType.Name;
 			} else if (Kind == MemberKind.Operator) {
 				var op = Operator.GetType (Name).Value;
 				if (op == Operator.OpType.Implicit || op == Operator.OpType.Explicit) {
 					name = DeclaringType.GetSignatureForError () + "." + Operator.GetName (op) + " operator " + returnType.GetSignatureForError ();
 				} else {
 					name = DeclaringType.GetSignatureForError () + ".operator " + Operator.GetName (op);
 				}
 			} else if (IsAccessor) {
 				int split = Name.IndexOf ('_');
 				name = Name.Substring (split + 1);
 				var postfix = Name.Substring (0, split);
 				if (split == 3) {
 					var pc = parameters.Count;
 					if (pc > 0 && postfix == "get") {
 						name = "this" + parameters.GetSignatureForError ("[", "]", pc);
 					} else if (pc > 1 && postfix == "set") {
 						name = "this" + parameters.GetSignatureForError ("[", "]", pc - 1);
 					}
 				}
 
 				return DeclaringType.GetSignatureForError () + "." + name + "." + postfix;
 			} else {
 				name = base.GetSignatureForError ();
 				if (targs != null)
 					name += "<" + TypeManager.CSharpName (targs) + ">";
 				else if (IsGeneric)
 					name += "<" + TypeManager.CSharpName (GenericDefinition.TypeParameters) + ">";
 			}
 
 			return name + parameters.GetSignatureForError ();
 		}
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var ms = (MethodSpec) base.InflateMember (inflator);
 			ms.inflatedMetaInfo = null;
 			ms.returnType = inflator.Inflate (returnType);
 			ms.parameters = parameters.Inflate (inflator);
 			if (IsGeneric)
 				ms.constraints = TypeParameterSpec.InflateConstraints (inflator, Constraints);
 
 			return ms;
 		}
 
 		public MethodSpec MakeGenericMethod (params TypeSpec[] targs)
 		{
 			if (targs == null)
 				throw new ArgumentNullException ();
 // TODO MemberCache
 //			if (generic_intances != null && generic_intances.TryGetValue (targs, out ginstance))
 //				return ginstance;
 
 			//if (generic_intances == null)
 			//    generic_intances = new Dictionary<TypeSpec[], Method> (TypeSpecArrayComparer.Default);
 
 			var inflator = new TypeParameterInflator (DeclaringType, GenericDefinition.TypeParameters, targs);
 
 			var inflated = (MethodSpec) MemberwiseClone ();
 			inflated.declaringType = inflator.TypeInstance;
 			inflated.returnType = inflator.Inflate (returnType);
 			inflated.parameters = parameters.Inflate (inflator);
 			inflated.targs = targs;
 			inflated.constraints = TypeParameterSpec.InflateConstraints (inflator, constraints ?? GenericDefinition.TypeParameters);
 			inflated.state |= StateFlags.PendingMakeMethod;
 
 			//			if (inflated.parent == null)
 			//				inflated.parent = parent;
 
 			//generic_intances.Add (targs, inflated);
 			return inflated;
 		}
 
 		public MethodSpec Mutate (TypeParameterMutator mutator)
 		{
 			var targs = TypeArguments;
 			if (targs != null)
 				targs = mutator.Mutate (targs);
 
 			var decl = DeclaringType;
 			if (DeclaringType.IsGenericOrParentIsGeneric) {
 				decl = mutator.Mutate (decl);
 			}
 
 			if (targs == TypeArguments && decl == DeclaringType)
 				return this;
 
 			var ms = (MethodSpec) MemberwiseClone ();
 			if (decl != DeclaringType) {
 				ms.inflatedMetaInfo = null;
 				ms.declaringType = decl;
 				ms.state |= StateFlags.PendingMetaInflate;
 			}
 
 			if (targs != null) {
 				ms.targs = targs;
 				ms.state |= StateFlags.PendingMakeMethod;
 			}
 
 			return ms;
 		}
 
 		public void SetMetaInfo (MethodInfo info)
 		{
 			if (this.metaInfo != null)
 				throw new InternalErrorException ("MetaInfo reset");
 
 			this.metaInfo = info;
 		}
 	}
 
 	public abstract class MethodOrOperator 
 	{
 		public MethodBuilder MethodBuilder;
 		ReturnParameter return_attributes;
 		SecurityType declarative_security;
 		protected MethodData MethodData;
 
 		static string[] attribute_targets = new string [] { "method", "return" };
 
 		protected MethodOrOperator (DeclSpace parent, GenericMethod generic, FullNamedExpression type, Modifiers mod,
 				Modifiers allowed_mod, MemberName name,
 				Attributes attrs, ParametersCompiled parameters)
 			
 					attrs, parameters)
 		{
 		}
]]></clone_fragment>
<clone_fragment endline="629" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" hamdist="7" pcid="4061" startline="327"><![CDATA[
 		
 		Constraints constraints;
 		GenericTypeParameterBuilder builder;
 		TypeParameterSpec spec;
 
 		public TypeParameter (DeclSpace parent, int index, MemberName name, Constraints constraints, Attributes attrs, Variance variance)
 			
 		{
 			this.constraints = constraints;
 			this.spec = new TypeParameterSpec (null, index, this, SpecialConstraint.None, variance, null);
 		}
 
 		public TypeParameter (TypeParameterSpec spec, DeclSpace parent, TypeSpec parentSpec, MemberName name, Attributes attrs)
 			
 		{
 			this.spec = new TypeParameterSpec (parentSpec, spec.DeclaredPosition, spec.MemberDefinition, spec.SpecialConstraint, spec.Variance, null) {
 				BaseType = spec.BaseType,
 				InterfacesDefined = spec.InterfacesDefined,
 				TypeArguments = spec.TypeArguments
 			};
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.GenericParameter;
 			}
 		}
 
 		public IAssemblyDefinition DeclaringAssembly {
 			get	{
 				return Module.DeclaringAssembly;
 			}
 		}
 
 		public override string DocCommentHeader {
 			get {
 				throw new InvalidOperationException (
 					"Unexpected attempt to get doc comment from " + this.GetType ());
 			}
 		}
 
 		public bool IsMethodTypeParameter {
 			get {
 				return spec.IsMethodOwned;
 			}
 		}
 
 		public string Namespace {
 			get {
 				return null;
 			}
 		}
 
 		public TypeParameterSpec Type {
 			get {
 				return spec;
 			}
 		}
 
 		public int TypeParametersCount {
 			get {
 				return 0;
 			}
 		}
 
 		public TypeParameterSpec[] TypeParameters {
 			get {
 				return null;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_target;
 			}
 		}
 
 		public Variance Variance {
 			get {
 				return spec.Variance;
 			}
 		}
 
 		#endregion
 
 		//
 		// This is called for each part of a partial generic type definition.
 		//
 		// If partial type parameters constraints are not null and we don't
 		// already have constraints they become our constraints. If we already
 		// have constraints, we must check that they're the same.
 		//
 		public bool AddPartialConstraints (TypeContainer part, TypeParameter tp)
 		{
 			if (builder == null)
 				throw new InvalidOperationException ();
 
 			var new_constraints = tp.constraints;
 			if (new_constraints == null)
 				return true;
 
 			// TODO
 			//tp.Define (null, -1, part.Definition);
 			tp.spec.DeclaringType = part.Definition;
 			if (!tp.ResolveConstraints (part))
 				return false;
 
 			if (constraints != null)
 				return spec.HasSameConstraintsDefinition (tp.Type);
 
 			// Copy constraint from resolved part to partial container
 			spec.SpecialConstraint = tp.spec.SpecialConstraint;
 			spec.InterfacesDefined = tp.spec.InterfacesDefined;
 			spec.TypeArguments = tp.spec.TypeArguments;
 			spec.BaseType = tp.spec.BaseType;
 			
 			return true;
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public void CheckGenericConstraints ()
 		{
 			if (constraints != null)
 				constraints.CheckGenericConstraints (this);
 		}
 
 		public TypeParameter CreateHoistedCopy (TypeContainer declaringType, TypeSpec declaringSpec)
 		{
 			return new TypeParameter (spec, declaringType, declaringSpec, MemberName, null);
 		}
 
 		public override bool Define ()
 		{
 			return true;
 		}
 
 		//
 		// This is the first method which is called during the resolving
 		// process; we're called immediately after creating the type parameters
 		// with SRE (by calling `DefineGenericParameters()' on the TypeBuilder /
 		// MethodBuilder).
 		//
 		public void Define (GenericTypeParameterBuilder type, TypeSpec declaringType)
 		{
 			if (builder != null)
 				throw new InternalErrorException ();
 
 			this.builder = type;
 			spec.DeclaringType = declaringType;
 			spec.SetMetaInfo (type);
 		}
 
 		public void EmitConstraints (GenericTypeParameterBuilder builder)
 		{
 			var attr = GenericParameterAttributes.None;
 			if (spec.Variance == Variance.Contravariant)
 				attr |= GenericParameterAttributes.Contravariant;
 			else if (spec.Variance == Variance.Covariant)
 				attr |= GenericParameterAttributes.Covariant;
 
 			if (spec.HasSpecialClass)
 				attr |= GenericParameterAttributes.ReferenceTypeConstraint;
 			else if (spec.HasSpecialStruct)
 				attr |= GenericParameterAttributes.NotNullableValueTypeConstraint | GenericParameterAttributes.DefaultConstructorConstraint;
 
 			if (spec.HasSpecialConstructor)
 				attr |= GenericParameterAttributes.DefaultConstructorConstraint;
 
 			if (spec.BaseType != TypeManager.object_type)
 				builder.SetBaseTypeConstraint (spec.BaseType.GetMetaInfo ());
 
 			if (spec.InterfacesDefined != null)
 				builder.SetInterfaceConstraints (spec.InterfacesDefined.Select (l => l.GetMetaInfo ()).ToArray ());
 
 			if (spec.TypeArguments != null)
 				builder.SetInterfaceConstraints (spec.TypeArguments.Select (l => l.GetMetaInfo ()).ToArray ());
 
 			builder.SetGenericParameterAttributes (attr);
 		}
 
 		public override void Emit ()
 		{
 			EmitConstraints (builder);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			base.Emit ();
 		}
 
 		public void ErrorInvalidVariance (IMemberContext mc, Variance expected)
 		{
 			Report.SymbolRelatedToPreviousError (mc.CurrentMemberDefinition);
 			string input_variance = Variance == Variance.Contravariant ? "contravariant" 
 			string gtype_variance;
 			switch (expected) {
 			case Variance.Contravariant
 			case Variance.Covariant
 			default
 			}
 
 			Delegate d = mc as Delegate;
 			string parameters = d != null ? d.Parameters.GetSignatureForError () 
 
 			Report.Error (1961, Location,
 				"The {2} type parameter `{0}' must be {3} valid on `{1}{4}'",
 					GetSignatureForError (), mc.GetSignatureForError (), input_variance, gtype_variance, parameters);
 		}
 
 		public TypeSpec GetAttributeCoClass ()
 		{
 			return null;
 		}
 
 		public string GetAttributeDefaultMember ()
 		{
 			throw new NotSupportedException ();
 		}
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			throw new NotSupportedException ();
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return MemberName.Name;
 		}
 
 		bool ITypeDefinition.IsInternalAsPublic (IAssemblyDefinition assembly)
 		{
 			throw new NotImplementedException ();
 		}
 
 		public void LoadMembers (TypeSpec declaringType, bool onlyTypes, ref MemberCache cache)
 		{
 			throw new NotSupportedException ("Not supported for compiled definition");
 		}
 
 		//
 		// Resolves all type parameter constraints
 		//
 		public bool ResolveConstraints (IMemberContext context)
 		{
 			if (constraints != null)
 				return constraints.Resolve (context, this);
 
 			if (spec.BaseType == null)
 				spec.BaseType = TypeManager.object_type;
 
 			return true;
 		}
 
 		public static TypeParameter FindTypeParameter (TypeParameter[] tparams, string name)
 		{
 			foreach (var tp in tparams) {
 				if (tp.Name == name)
 					return tp;
 			}
 
 			return null;
 		}
 
 		public override bool IsClsComplianceRequired ()
 		{
 			return false;
 		}
 
 		public new void VerifyClsCompliance ()
 		{
 			if (constraints != null)
 				constraints.VerifyClsCompliance (Report);
 		}
 	}
 
 	[System.Diagnostics.DebuggerDisplay ("{DisplayDebugInfo()}")]
 	public class TypeParameterSpec 
 	{
 		public static readonly new TypeParameterSpec[] EmptyTypes = new TypeParameterSpec[0];
 
 		Variance variance;
 		SpecialConstraint spec;
 		readonly int tp_pos;
 		TypeSpec[] targs;
 		TypeSpec[] ifaces_defined;
 
 		//
 		// Creates type owned type parameter
 		//
 		public TypeParameterSpec (TypeSpec declaringType, int index, ITypeDefinition definition, SpecialConstraint spec, Variance variance, MetaType info)
 			
 		{
 			this.variance = variance;
 			this.spec = spec;
 			state &= ~StateFlags.Obsolete_Undetected;
 			tp_pos = index;
 		}
]]></clone_fragment>
<clone_fragment endline="2325" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="9" pcid="5519" startline="1985"><![CDATA[
 
 		public Destructor (DeclSpace parent, Modifiers mod, ParametersCompiled parameters, Attributes attrs, Location l)
 			
 				new MemberName (MetadataName, l), attrs, parameters)
 		{
 			ModFlags &= ~Modifiers.PRIVATE;
 			ModFlags |= Modifiers.PROTECTED | Modifiers.OVERRIDE;
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				Error_ConditionalAttributeIsNotValid ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		protected override bool CheckBase ()
 		{
 			// Don't check base, destructors have special syntax
 			return true;
 		}
 
 		public override void Emit()
 		{
 			var base_type = Parent.PartialContainer.BaseType;
 			if (base_type != null && Block != null) {
 				var base_dtor = MemberCache.FindMember (base_type,
 					new MemberFilter (MetadataName, 0, MemberKind.Destructor, null, null), BindingRestriction.InstanceOnly) as MethodSpec;
 
 				if (base_dtor == null)
 					throw new NotImplementedException ();
 
 				MethodGroupExpr method_expr = MethodGroupExpr.CreatePredefined (base_dtor, base_type, Location);
 				method_expr.InstanceExpression = new BaseThis (base_type, Location);
 
 				var try_block = new ExplicitBlock (block, block.StartLocation, block.EndLocation);
 				var finaly_block = new ExplicitBlock (block, Location, Location);
 
 				//
 				// 0-size arguments to avoid CS0250 error
 				// TODO
 				// debugger scope
 				//
 				finaly_block.AddStatement (new StatementExpression (new Invocation (method_expr, new Arguments (0))));
 
 				var tf = new TryFinally (try_block, finaly_block, Location);
 				block.WrapIntoDestructor (tf, try_block);
 			}
 
 			base.Emit ();
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return Parent.GetSignatureForError () + ".~" + Parent.MemberName.Name + "()";
 		}
 
 		protected override bool ResolveMemberType ()
 		{
 			member_type = TypeManager.void_type;
 			return true;
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 	}
 
 	// Ooouh Martin, templates are missing here.
 	// When it will be possible move here a lot of child code and template method type.
 	public abstract class AbstractPropertyEventMethod 
 		protected MethodData method_data;
 		protected ToplevelBlock block;
 		protected SecurityType declarative_security;
 
 		protected readonly string prefix;
 
 		ReturnParameter return_attributes;
 
 		public AbstractPropertyEventMethod (InterfaceMemberBase member, string prefix, Attributes attrs, Location loc)
 			
 		{
 			this.prefix = prefix;
 		}
 
 		static MemberName SetupName (string prefix, InterfaceMemberBase member, Location loc)
 		{
 			return new MemberName (member.MemberName.Left, prefix + member.ShortName, loc);
 		}
 
 		public void UpdateName (InterfaceMemberBase member)
 		{
 			SetMemberName (SetupName (prefix, member, Location));
 		}
 
 		#region IMethodData Members
 
 		public ToplevelBlock Block {
 			get {
 				return block;
 			}
 
 			set {
 				block = value;
 			}
 		}
 
 		public CallingConventions CallingConventions {
 			get {
 				return CallingConventions.Standard;
 			}
 		}
 
 		public EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			return new EmitContext (this, ig, ReturnType);
 		}
 
 		public bool IsExcluded ()
 		{
 			return false;
 		}
 
 		GenericMethod IMethodData.GenericMethod {
 			get {
 				return null;
 			}
 		}
 
 		public MemberName MethodName {
 			get {
 				return MemberName;
 			}
 		}
 
 		public TypeSpec[] ParameterTypes { 
 			get {
 				return ParameterInfo.Types;
 			}
 		}
 
 		public abstract ParametersCompiled ParameterInfo { get ; }
 		public abstract TypeSpec ReturnType { get; }
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant || a.Type == pa.Obsolete || a.Type == pa.Conditional) {
 				Report.Error (1667, a.Location,
 					"Attribute `{0}' is not valid on property or event accessors. It is valid on `{1}' declarations only",
 					TypeManager.CSharpName (a.Type), a.GetValidTargets ());
 				return;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				method_data.MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			ApplyToExtraTarget (a, ctor, cdata, pa);
 		}
 
 		protected virtual void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			throw new NotSupportedException ("You forgot to define special attribute target handling");
 		}
 
 		// It is not supported for the accessors
 		public sealed override bool Define()
 		{
 			throw new NotSupportedException ();
 		}
 
 		public virtual void Emit (DeclSpace parent)
 		{
 			method_data.Emit (parent);
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (method_data.MethodBuilder);
 			if (((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0))
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (method_data.MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					method_data.MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					method_data.MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			block = null;
 		}
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			if (overload is MethodCore) {
 				caching_flags |= Flags.MethodOverloadsExist;
 				return true;
 			}
 
 			// This can only happen with indexers and it will
 			// be catched as indexer difference
 			if (overload is AbstractPropertyEventMethod)
 				return true;
 
 			return false;
 		}
 
 		public override bool IsClsComplianceRequired()
 		{
 			return false;
 		}
 
 		public MethodSpec Spec { get; protected set; }
 
 		//
 		//   Represents header string for documentation comment.
 		//
 		public override string DocCommentHeader {
 			get { throw new InvalidOperationException ("Unexpected attempt to get doc comment from " + this.GetType () + "."); }
 		}
 
 		void IMethodData.EmitExtraSymbolInfo (SourceMethod source)
 		{ }
 	}
 
 	public class Operator 
 
 		const Modifiers AllowedModifiers =
 			Modifiers.PUBLIC |
 			Modifiers.UNSAFE |
 			Modifiers.EXTERN |
 			Modifiers.STATIC;
 
 		public enum OpType 
 
 			// Unary operators
 			LogicalNot,
 			OnesComplement,
 			Increment,
 			Decrement,
 			True,
 			False,
 
 			// Unary and Binary operators
 			Addition,
 			Subtraction,
 
 			UnaryPlus,
 			UnaryNegation,
 			
 			// Binary operators
 			Multiply,
 			Division,
 			Modulus,
 			BitwiseAnd,
 			BitwiseOr,
 			ExclusiveOr,
 			LeftShift,
 			RightShift,
 			Equality,
 			Inequality,
 			GreaterThan,
 			LessThan,
 			GreaterThanOrEqual,
 			LessThanOrEqual,
 
 			// Implicit and Explicit
 			Implicit,
 			Explicit,
 
 			// Just because of enum
 			TOP
 		};
 
 		public readonly OpType OperatorType;
 
 		static readonly string [] [] names;
 
 		static Operator ()
 		{
 			names = new string[(int)OpType.TOP][];
 			names [(int) OpType.LogicalNot] = new string [] { "!", "op_LogicalNot" };
 			names [(int) OpType.OnesComplement] = new string [] { "~", "op_OnesComplement" };
 			names [(int) OpType.Increment] = new string [] { "++", "op_Increment" };
 			names [(int) OpType.Decrement] = new string [] { "--", "op_Decrement" };
 			names [(int) OpType.True] = new string [] { "true", "op_True" };
 			names [(int) OpType.False] = new string [] { "false", "op_False" };
 			names [(int) OpType.Addition] = new string [] { "+", "op_Addition" };
 			names [(int) OpType.Subtraction] = new string [] { "-", "op_Subtraction" };
 			names [(int) OpType.UnaryPlus] = new string [] { "+", "op_UnaryPlus" };
 			names [(int) OpType.UnaryNegation] = new string [] { "-", "op_UnaryNegation" };
 			names [(int) OpType.Multiply] = new string [] { "*", "op_Multiply" };
 			names [(int) OpType.Division] = new string [] { "/", "op_Division" };
 			names [(int) OpType.Modulus] = new string [] { "%", "op_Modulus" };
 			names [(int) OpType.BitwiseAnd] = new string [] { "&", "op_BitwiseAnd" };
 			names [(int) OpType.BitwiseOr] = new string [] { "|", "op_BitwiseOr" };
 			names [(int) OpType.ExclusiveOr] = new string [] { "^", "op_ExclusiveOr" };
 			names [(int) OpType.LeftShift] = new string [] { "<<", "op_LeftShift" };
 			names [(int) OpType.RightShift] = new string [] { ">>", "op_RightShift" };
 			names [(int) OpType.Equality] = new string [] { "==", "op_Equality" };
 			names [(int) OpType.Inequality] = new string [] { "!=", "op_Inequality" };
 			names [(int) OpType.GreaterThan] = new string [] { ">", "op_GreaterThan" };
 			names [(int) OpType.LessThan] = new string [] { "<", "op_LessThan" };
 			names [(int) OpType.GreaterThanOrEqual] = new string [] { ">=", "op_GreaterThanOrEqual" };
 			names [(int) OpType.LessThanOrEqual] = new string [] { "<=", "op_LessThanOrEqual" };
 			names [(int) OpType.Implicit] = new string [] { "implicit", "op_Implicit" };
 			names [(int) OpType.Explicit] = new string [] { "explicit", "op_Explicit" };
 		}
]]></clone_fragment>
<clone_fragment endline="1338" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" hamdist="5" pcid="1987" startline="992"><![CDATA[
 
 		Expression initializer;
 		Field backing_field;
 		List<FieldDeclarator> declarators;
 
 		public EventField (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			Add = new AddDelegateMethod (this);
 			Remove = new RemoveDelegateMethod (this);
 		}
 
 		#region Properties
 
 		bool HasBackingField {
 			get {
 				return !IsInterface && (ModFlags & Modifiers.ABSTRACT) == 0;
 			}
 		}
 
 		public Expression Initializer {
 			get {
 				return initializer;
 			}
 			set {
 				initializer = value;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return HasBackingField ? attribute_targets 
 			}
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.Field) {
 				backing_field.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				int errors = Report.Errors;
 				Add.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				if (errors == Report.Errors)
 					Remove.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		public override bool Define()
 		{
 			var mod_flags_src = ModFlags;
 
 			if (!base.Define ())
 				return false;
 
 			if (declarators != null) {
 				if ((mod_flags_src & Modifiers.DEFAULT_ACCESS_MODIFER) != 0)
 					mod_flags_src &= ~(Modifiers.AccessibilityMask | Modifiers.DEFAULT_ACCESS_MODIFER);
 
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Events.IndexOf (this);
 				foreach (var d in declarators) {
 					var ef = new EventField (Parent, t, mod_flags_src, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 
 					if (d.Initializer != null)
 						ef.initializer = d.Initializer;
 
 					Parent.PartialContainer.Events.Insert (++index, ef);
 				}
 			}
 
 			if (!HasBackingField) {
 				SetIsUsed ();
 				return true;
 			}
 
 			if (Add.IsInterfaceImplementation)
 				SetIsUsed ();
 
 			backing_field = new Field (Parent,
 				new TypeExpression (MemberType, Location),
 				Modifiers.BACKING_FIELD | Modifiers.COMPILER_GENERATED | Modifiers.PRIVATE | (ModFlags & (Modifiers.STATIC | Modifiers.UNSAFE)),
 				MemberName, null);
 
 			Parent.PartialContainer.AddField (backing_field);
 			backing_field.Initializer = Initializer;
 			backing_field.ModFlags &= ~Modifiers.COMPILER_GENERATED;
 
 			// Call define because we passed fields definition
 			backing_field.Define ();
 
 			// Set backing field for event fields
 			spec.BackingField = backing_field.Spec;
 
 			return true;
 		}
 	}
 
 	public abstract class Event 
 	{
 		public abstract class AEventAccessor 
 		{
 			protected readonly Event method;
 			ParametersCompiled parameters;
 
 			static readonly string[] attribute_targets = new string [] { "method", "param", "return" };
 
 			public const string AddPrefix = "add_";
 			public const string RemovePrefix = "remove_";
 
 			protected AEventAccessor (Event method, string prefix, Attributes attrs, Location loc)
 				
 			{
 				this.method = method;
 				this.ModFlags = method.ModFlags;
 				this.parameters = ParametersCompiled.CreateImplicitParameter (method.TypeExpression, loc);
 			}
 
 			public bool IsInterfaceImplementation {
 				get { return method_data.implementing != null; }
 			}
 
 			public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Type == pa.MethodImpl) {
 					method.is_external_implementation = a.IsInternalCall ();
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			protected override void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Target == AttributeTargets.Parameter) {
 					parameters[0].ApplyAttributeBuilder (a, ctor, cdata, pa);
 					return;
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override AttributeTargets AttributeTargets {
 				get {
 					return AttributeTargets.Method;
 				}
 			}
 
 			public override bool IsClsComplianceRequired ()
 			{
 				return method.IsClsComplianceRequired ();
 			}
 
 			public virtual MethodBuilder Define (DeclSpace parent)
 			{
 				parameters.Resolve (this);
 
 				method_data = new MethodData (method, method.ModFlags,
 					method.flags | MethodAttributes.HideBySig | MethodAttributes.SpecialName, this);
 
 				if (!method_data.Define (parent, method.GetFullName (MemberName), Report))
 					return null;
 
 				MethodBuilder mb = method_data.MethodBuilder;
 
 				Spec = new MethodSpec (MemberKind.Method, parent.PartialContainer.Definition, this, ReturnType, mb, ParameterInfo, method.ModFlags);
 				Spec.IsAccessor = true;
 
 				return mb;
 			}
 
 			public override TypeSpec ReturnType {
 				get {
 					return TypeManager.void_type;
 				}
 			}
 
 			public override ObsoleteAttribute GetAttributeObsolete ()
 			{
 				return method.GetAttributeObsolete ();
 			}
 
 			public override string[] ValidAttributeTargets {
 				get {
 					return attribute_targets;
 				}
 			}
 
 			public override ParametersCompiled ParameterInfo {
 				get {
 					return parameters;
 				}
 			}
 		}
 
 		AEventAccessor add, remove;
 		EventBuilder EventBuilder;
 		protected EventSpec spec;
 
 		protected Event (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs)
 		{
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Event;
 			}
 		}
 
 		public AEventAccessor Add {
 			get {
 				return this.add;
 			}
 			set {
 				add = value;
 				Parent.AddMember (value);
 			}
 		}
 
 		public AEventAccessor Remove {
 			get {
 				return this.remove;
 			}
 			set {
 				remove = value;
 				Parent.AddMember (value);
 			}
 		}
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			EventBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			var ok = base.CheckOverrideAgainstBase (base_member);
 
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				ok = false;
 			}
 
 			return ok;
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!TypeManager.IsDelegateType (MemberType)) {
 				Report.Error (66, Location, "`{0}'
 			}
 
 			if (!CheckBase ())
 				return false;
 
 			//
 			// Now define the accessors
 			//
 			var AddBuilder = Add.Define (Parent);
 			if (AddBuilder == null)
 				return false;
 
 			var RemoveBuilder = remove.Define (Parent);
 			if (RemoveBuilder == null)
 				return false;
 
 			EventBuilder = Parent.TypeBuilder.DefineEvent (GetFullName (MemberName), EventAttributes.None, MemberType.GetMetaInfo ());
 			EventBuilder.SetAddOnMethod (AddBuilder);
 			EventBuilder.SetRemoveOnMethod (RemoveBuilder);
 
 			spec = new EventSpec (Parent.Definition, this, MemberType, ModFlags, Add.Spec, remove.Spec);
 
 			Parent.MemberCache.AddMember (this, Name, spec);
 			Parent.MemberCache.AddMember (this, AddBuilder.Name, Add.Spec);
 			Parent.MemberCache.AddMember (this, RemoveBuilder.Name, remove.Spec);
 
 			return true;
 		}
 
 		public override void Emit ()
 		{
 			CheckReservedNameConflict (null, add.Spec);
 			CheckReservedNameConflict (null, remove.Spec);
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			Add.Emit (Parent);
 			Remove.Emit (Parent);
 
 			base.Emit ();
 		}
 
 		//
 		//   Represents header string for documentation comment.
 		//
 		public override string DocCommentHeader {
 			get { return "E
 		}
 	}
 
 	public class EventSpec 
 	{
 		MethodSpec add, remove;
 		FieldSpec backing_field;
 
 		public EventSpec (TypeSpec declaringType, IMemberDefinition definition, TypeSpec eventType, Modifiers modifiers, MethodSpec add, MethodSpec remove)
 			
 		{
 			this.AccessorAdd = add;
 			this.AccessorRemove = remove;
 			this.MemberType = eventType;
 		}
]]></clone_fragment>
<clone_fragment endline="1943" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" hamdist="4" pcid="823" startline="1746"><![CDATA[
 
 		public void LoadMembers (TypeSpec declaringType, bool onlyTypes, ref MemberCache cache)
 		{
 			//
 			// Not interested in members of nested private types unless the importer needs them
 			//
 			if (declaringType.IsPrivate && importer.IgnorePrivateMembers) {
 				cache = MemberCache.Empty;
 				return;
 			}
 
 			var loading_type = (MetaType) provider;
 			const BindingFlags all_members = BindingFlags.DeclaredOnly |
 				BindingFlags.Static | BindingFlags.Instance |
 				BindingFlags.Public | BindingFlags.NonPublic;
 
 			const MethodAttributes explicit_impl = MethodAttributes.NewSlot |
 					MethodAttributes.Virtual | MethodAttributes.HideBySig |
 					MethodAttributes.Final;
 
 			Dictionary<MethodBase, MethodSpec> possible_accessors = null;
 			List<EventSpec> imported_events = null;
 			EventSpec event_spec;
 			MemberSpec imported;
 			MethodInfo m;
 			MemberInfo[] all;
 			try {
 				all = loading_type.GetMembers (all_members);
 			} catch (Exception e) {
 				throw new InternalErrorException (e, "Could not import type `{0}' from `{1}'",
 					declaringType.GetSignatureForError (), declaringType.MemberDefinition.DeclaringAssembly.FullName);
 			}
 
 			if (cache == null) {
 				cache = new MemberCache (all.Length);
 
 				//
 				// Do the types first as they can be referenced by the members before
 				// they are found or inflated
 				//
 				foreach (var member in all) {
 					if (member.MemberType != MemberTypes.NestedType)
 						continue;
 
 					var t = (MetaType) member;
 
 					// Ignore compiler generated types, mostly lambda containers
 					if ((t.Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate && importer.IgnorePrivateMembers)
 						continue;
 
 					imported = importer.CreateNestedType (t, declaringType);
 					cache.AddMember (imported);
 				}
 				foreach (var member in all) {
 					if (member.MemberType != MemberTypes.NestedType)
 						continue;
 
 					var t = (MetaType) member;
 
 					// Ignore compiler generated types, mostly lambda containers
 					if ((t.Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate && importer.IgnorePrivateMembers)
 						continue;
 
 					imported = importer.CreateNestedType (t, declaringType);
 					cache.AddMember (imported);
 				}
 
 				foreach (var member in all) {
 					if (member.MemberType != MemberTypes.NestedType)
 						continue;
 
 					var t = (MetaType) member;
 
 					if ((t.Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate && importer.IgnorePrivateMembers)
 						continue;
 
 					importer.ImportTypeBase (t);
 				}
 				foreach (var member in all) {
 					if (member.MemberType != MemberTypes.NestedType)
 						continue;
 
 					var t = (MetaType) member;
 
 					if ((t.Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate && importer.IgnorePrivateMembers)
 						continue;
 
 					importer.ImportTypeBase (t);
 				}
 			}
 
 			if (!onlyTypes) {
 				//
 				// The logic here requires methods to be returned first which seems to work for both Mono and .NET
 				//
 				foreach (var member in all) {
 					switch (member.MemberType) {
 					case MemberTypes.Constructor
 					case MemberTypes.Method
 						MethodBase mb = (MethodBase) member;
 						var attrs = mb.Attributes;
 
 						if ((attrs & MethodAttributes.MemberAccessMask) == MethodAttributes.Private) {
 							if (importer.IgnorePrivateMembers)
 								continue;
 
 							// Ignore explicitly implemented members
 							if ((attrs & explicit_impl) == explicit_impl)
 								continue;
 
 							// Ignore compiler generated methods
 							if (importer.HasAttribute (CustomAttributeData.GetCustomAttributes (mb), "CompilerGeneratedAttribute", MetadataImporter.CompilerServicesNamespace))
 								continue;
 						}
 
 						imported = importer.CreateMethod (mb, declaringType);
 						if (imported.Kind == MemberKind.Method && !imported.IsGeneric) {
 							if (possible_accessors == null)
 								possible_accessors = new Dictionary<MethodBase, MethodSpec> (ReferenceEquality<MethodBase>.Default);
 
 							// There are no metadata rules for accessors, we have to consider any method as possible candidate
 							possible_accessors.Add (mb, (MethodSpec) imported);
 						}
 
 						break;
 					case MemberTypes.Property
 						if (possible_accessors == null)
 							continue;
 
 						var p = (PropertyInfo) member;
 						//
 						// Links possible accessors with property
 						//
 						MethodSpec get, set;
 						m = p.GetGetMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out get))
 							get = null;
 
 						m = p.GetSetMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out set))
 							set = null;
 
 						// No accessors registered (e.g. explicit implementation)
 						if (get == null && set == null)
 							continue;
 
 						imported = importer.CreateProperty (p, declaringType, get, set);
 						if (imported == null)
 							continue;
 
 						break;
 					case MemberTypes.Event
 						if (possible_accessors == null)
 							continue;
 
 						var e = (EventInfo) member;
 						//
 						// Links accessors with event
 						//
 						MethodSpec add, remove;
 						m = e.GetAddMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out add))
 							add = null;
 
 						m = e.GetRemoveMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out remove))
 							remove = null;
 
 						// Both accessors are required
 						if (add == null || remove == null)
 							continue;
 
 						event_spec = importer.CreateEvent (e, declaringType, add, remove);
 						if (!importer.IgnorePrivateMembers) {
 							if (imported_events == null)
 								imported_events = new List<EventSpec> ();
 
 							imported_events.Add (event_spec);
 						}
 
 						imported = event_spec;
 						break;
 					case MemberTypes.Field
 						var fi = (FieldInfo) member;
 
 						imported = importer.CreateField (fi, declaringType);
 						if (imported == null)
 							continue;
 
 						//
 						// For dynamic binder event has to be fully restored to allow operations
 						// within the type container to work correctly
 						//
 						if (imported_events != null) {
 							// The backing event field should be private but it may not
 							int index = imported_events.FindIndex (l => l.Name == fi.Name);
 							if (index >= 0) {
 								event_spec = imported_events[index];
 								event_spec.BackingField = (FieldSpec) imported;
 								imported_events.RemoveAt (index);
 								continue;
 							}
 						}
 
 						break;
 					case MemberTypes.NestedType
 						// Already in the cache from the first pass
 						continue;
 					default
 						throw new NotImplementedException (member.ToString ());
 					}
 
 					cache.AddMember (imported);
 				}
 				foreach (var member in all) {
 					switch (member.MemberType) {
 					case MemberTypes.Constructor
 					case MemberTypes.Method
 						MethodBase mb = (MethodBase) member;
 						var attrs = mb.Attributes;
 
 						if ((attrs & MethodAttributes.MemberAccessMask) == MethodAttributes.Private) {
 							if (importer.IgnorePrivateMembers)
 								continue;
 
 							// Ignore explicitly implemented members
 							if ((attrs & explicit_impl) == explicit_impl)
 								continue;
 
 							// Ignore compiler generated methods
 							if (importer.HasAttribute (CustomAttributeData.GetCustomAttributes (mb), "CompilerGeneratedAttribute", MetadataImporter.CompilerServicesNamespace))
 								continue;
 						}
 
 						imported = importer.CreateMethod (mb, declaringType);
 						if (imported.Kind == MemberKind.Method && !imported.IsGeneric) {
 							if (possible_accessors == null)
 								possible_accessors = new Dictionary<MethodBase, MethodSpec> (ReferenceEquality<MethodBase>.Default);
 
 							// There are no metadata rules for accessors, we have to consider any method as possible candidate
 							possible_accessors.Add (mb, (MethodSpec) imported);
 						}
 
 						break;
 					case MemberTypes.Property
 						if (possible_accessors == null)
 							continue;
 
 						var p = (PropertyInfo) member;
 						//
 						// Links possible accessors with property
 						//
 						MethodSpec get, set;
 						m = p.GetGetMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out get))
 							get = null;
 
 						m = p.GetSetMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out set))
 							set = null;
 
 						// No accessors registered (e.g. explicit implementation)
 						if (get == null && set == null)
 							continue;
 
 						imported = importer.CreateProperty (p, declaringType, get, set);
 						if (imported == null)
 							continue;
 
 						break;
 					case MemberTypes.Event
 						if (possible_accessors == null)
 							continue;
 
 						var e = (EventInfo) member;
 						//
 						// Links accessors with event
 						//
 						MethodSpec add, remove;
 						m = e.GetAddMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out add))
 							add = null;
 
 						m = e.GetRemoveMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out remove))
 							remove = null;
 
 						// Both accessors are required
 						if (add == null || remove == null)
 							continue;
 
 						event_spec = importer.CreateEvent (e, declaringType, add, remove);
 						if (!importer.IgnorePrivateMembers) {
 							if (imported_events == null)
 								imported_events = new List<EventSpec> ();
 
 							imported_events.Add (event_spec);
 						}
 
 						imported = event_spec;
 						break;
 					case MemberTypes.Field
 						var fi = (FieldInfo) member;
 
 						imported = importer.CreateField (fi, declaringType);
 						if (imported == null)
 							continue;
 
 						//
 						// For dynamic binder event has to be fully restored to allow operations
 						// within the type container to work correctly
 						//
 						if (imported_events != null) {
 							// The backing event field should be private but it may not
 							int index = imported_events.FindIndex (l => l.Name == fi.Name);
 							if (index >= 0) {
 								event_spec = imported_events[index];
 								event_spec.BackingField = (FieldSpec) imported;
 								imported_events.RemoveAt (index);
 								continue;
 							}
 						}
 
 						break;
 					case MemberTypes.NestedType
 						// Already in the cache from the first pass
 						continue;
 					default
 						throw new NotImplementedException (member.ToString ());
 					}
 
 					cache.AddMember (imported);
 				}
 			}
 
 			if (declaringType.IsInterface && declaringType.Interfaces != null) {
 				foreach (var iface in declaringType.Interfaces) {
 					cache.AddInterface (iface);
 				}
 				foreach (var iface in declaringType.Interfaces) {
 					cache.AddInterface (iface);
 				}
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="801" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="5" pcid="1257" startline="469"><![CDATA[
 
 		protected MethodOrOperator (DeclSpace parent, GenericMethod generic, FullNamedExpression type, Modifiers mod,
 				Modifiers allowed_mod, MemberName name,
 				Attributes attrs, ParametersCompiled parameters)
 			
 					attrs, parameters)
 		{
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			if (a.Type == pa.DllImport) {
 				const Modifiers extern_static = Modifiers.EXTERN | Modifiers.STATIC;
 				if ((ModFlags & extern_static) != extern_static) {
 					Report.Error (601, a.Location, "The DllImport attribute must be specified on a method marked `static' and `extern'");
 				}
 				is_external_implementation = true;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (MethodBuilder != null)
 				MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Method; 
 			}
 		}
 
 		protected override bool CheckForDuplications ()
 		{
 			return Parent.MemberCache.CheckExistingMembersOverloads (this, parameters);
 		}
 
 		public virtual EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			return new EmitContext (this, ig, MemberType);
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!CheckBase ())
 				return false;
 
 			MemberKind kind;
 			if (this is Operator)
 				kind = MemberKind.Operator;
 			else if (this is Destructor)
 				kind = MemberKind.Destructor;
 			else
 				kind = MemberKind.Method;
 
 			if (IsPartialDefinition) {
 				caching_flags &= ~Flags.Excluded_Undetected;
 				caching_flags |= Flags.Excluded;
 
 				// Add to member cache only when a partial method implementation has not been found yet
 				if ((caching_flags & Flags.PartialDefinitionExists) == 0) {
 //					MethodBase mb = new PartialMethodDefinitionInfo (this);
 
 					spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, null, parameters, ModFlags);
 					Parent.MemberCache.AddMember (spec);
 				}
 
 				return true;
 			}
 
 			MethodData = new MethodData (
 				this, ModFlags, flags, this, MethodBuilder, GenericMethod, base_method);
 
 			if (!MethodData.Define (Parent.PartialContainer, GetFullName (MemberName), Report))
 				return false;
 					
 			MethodBuilder = MethodData.MethodBuilder;
 
 			spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, MethodBuilder, parameters, ModFlags);
 			if (MemberName.Arity > 0)
 				spec.IsGeneric = true;
 			
 			Parent.MemberCache.AddMember (this, MethodBuilder.Name, spec);
 
 			return true;
 		}
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			CheckAbstractAndExtern (block != null);
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0) {
 				for (int i = 0; i < parameters.Count; ++i) {
 					IParameterData p = parameters.FixedParameters [i];
 					if (p.ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (752, Location, "`{0}'
 							GetSignatureForError ());
 					}
 
 					if (p.HasDefaultValue && IsPartialImplementation)
 						((Parameter) p).Warning_UselessOptionalParameter (Report);
 				}
 			}
 		}
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			if (MemberType.IsStatic) {
 				Error_StaticReturnType ();
 			}
 		}
 
 		public override void Emit ()
 		{
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (MethodBuilder);
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			if (MethodData != null)
 				MethodData.Emit (Parent);
 
 			base.Emit ();
 
 			Block = null;
 			MethodData = null;
 		}
 
 		protected void Error_ConditionalAttributeIsNotValid ()
 		{
 			Report.Error (577, Location,
 				"Conditional not valid on `{0}' because it is a constructor, destructor, operator or explicit interface implementation",
 				GetSignatureForError ());
 		}
 
 		public bool IsPartialDefinition {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block == null;
 			}
 		}
 
 		public bool IsPartialImplementation {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block != null;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#region IMethodData Members
 
 		public TypeSpec ReturnType {
 			get {
 				return MemberType;
 			}
 		}
 
 		public MemberName MethodName {
 			get {
 				return MemberName;
 			}
 		}
 
 		/// <summary>
 		/// Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
 		/// </summary>
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.Excluded) != 0)
 				return new string [0];
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 			string[] conditions;
 
 			if (base_method == null) {
 				if (OptAttributes == null)
 					return null;
 
 				Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 				if (attrs == null)
 					return null;
 
 				conditions = new string[attrs.Length];
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			} else {
 				conditions = base_method.MemberDefinition.ConditionalConditions();
 			}
 
 			if (conditions != null)
 				caching_flags |= Flags.Excluded;
 
 			return conditions;
 		}
 
 		GenericMethod IMethodData.GenericMethod {
 			get {
 				return GenericMethod;
 			}
 		}
 
 		public virtual void EmitExtraSymbolInfo (SourceMethod source)
 		{ }
 
 		#endregion
 
 	}
 
 	public class SourceMethod 
 	{
 		MethodBase method;
 		SourceMethodBuilder builder;
 
 		protected SourceMethod (DeclSpace parent, MethodBase method, ICompileUnit file)
 		{
 			this.method = method;
 			
 			builder = SymbolWriter.OpenMethod (file, parent.NamespaceEntry.SymbolFileID, this);
 		}
 
 		public string Name {
 			get { return method.Name; }
 		}
 
 		public int Token {
 			get {
 				MethodToken token;
 				var mb = method as MethodBuilder;
 				if (mb != null)
 					token = mb.GetToken ();
 				else
 					token = ((ConstructorBuilder) method).GetToken ();
 #if STATIC
 				if (token.IsPseudoToken)
 					return ((ModuleBuilder) method.Module).ResolvePseudoToken (token.Token);
 #endif
 				return token.Token;
 			}
 		}
 
 		public void CloseMethod ()
 		{
 			SymbolWriter.CloseMethod ();
 		}
 
 		public void SetRealMethodName (string name)
 		{
 			if (builder != null)
 				builder.SetRealMethodName (name);
 		}
 
 		public static SourceMethod Create (DeclSpace parent, MethodBase method, Block block)
 		{
 			if (!SymbolWriter.HasSymbolWriter)
 				return null;
 			if (block == null)
 				return null;
 
 			Location start_loc = block.StartLocation;
 			if (start_loc.IsNull)
 				return null;
 
 			ICompileUnit compile_unit = start_loc.CompilationUnit;
 			if (compile_unit == null)
 				return null;
 
 			return new SourceMethod (parent, method, compile_unit);
 		}
 	}
 
 	public class Method 
 	{
 		Method partialMethodImplementation;
 
 		public Method (DeclSpace parent, GenericMethod generic,
 			       FullNamedExpression return_type, Modifiers mod,
 			       MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs, parameters)
 		{
 		}
]]></clone_fragment>
<clone_fragment endline="423" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" hamdist="5" pcid="2579" startline="156"><![CDATA[
 		List<MethodEntry> methods = new List<MethodEntry> ();
 		List<SourceFileEntry> sources = new List<SourceFileEntry> ();
 		List<CompileUnitEntry> comp_units = new List<CompileUnitEntry> ();
 		Dictionary<Type, int> type_hash = new Dictionary<Type, int> ();
 		Dictionary<int, AnonymousScopeEntry> anonymous_scopes;
 
 		OffsetTable ot;
 		int last_type_index;
 		int last_method_index;
 		int last_namespace_index;
 
 		public readonly string FileName = "<dynamic>";
 		public readonly int MajorVersion = OffsetTable.MajorVersion;
 		public readonly int MinorVersion = OffsetTable.MinorVersion;
 
 		public int NumLineNumbers;
 
 		internal MonoSymbolFile ()
 		{
 			ot = new OffsetTable ();
 		}
 
 		internal int AddSource (SourceFileEntry source)
 		{
 			sources.Add (source);
 			return sources.Count;
 		}
 
 		internal int AddCompileUnit (CompileUnitEntry entry)
 		{
 			comp_units.Add (entry);
 			return comp_units.Count;
 		}
 
 		internal int DefineType (Type type)
 		{
 			int index;
 			if (type_hash.TryGetValue (type, out index))
 				return index;
 
 			index = ++last_type_index;
 			type_hash.Add (type, index);
 			return index;
 		}
 
 		internal void AddMethod (MethodEntry entry)
 		{
 			methods.Add (entry);
 		}
 
 		public MethodEntry DefineMethod (CompileUnitEntry comp_unit, int token,
 						 ScopeVariable[] scope_vars, LocalVariableEntry[] locals,
 						 LineNumberEntry[] lines, CodeBlockEntry[] code_blocks,
 						 string real_name, MethodEntry.Flags flags,
 						 int namespace_id)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			MethodEntry method = new MethodEntry (
 				this, comp_unit, token, scope_vars, locals, lines, code_blocks, 
 				real_name, flags, namespace_id);
 			AddMethod (method);
 			return method;
 		}
 
 		internal void DefineAnonymousScope (int id)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			if (anonymous_scopes == null)
 				anonymous_scopes = new Dictionary<int, AnonymousScopeEntry>  ();
 
 			anonymous_scopes.Add (id, new AnonymousScopeEntry (id));
 		}
 
 		internal void DefineCapturedVariable (int scope_id, string name, string captured_name,
 						      CapturedVariable.CapturedKind kind)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedVariable (name, captured_name, kind);
 		}
 
 		internal void DefineCapturedScope (int scope_id, int id, string captured_name)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedScope (id, captured_name);
 		}
 
 		internal int GetNextTypeIndex ()
 		{
 			return ++last_type_index;
 		}
 
 		internal int GetNextMethodIndex ()
 		{
 			return ++last_method_index;
 		}
 
 		internal int GetNextNamespaceIndex ()
 		{
 			return ++last_namespace_index;
 		}
 		
 		void Write (MyBinaryWriter bw, Guid guid)
 		{
 			// Magic number and file version.
 			bw.Write (OffsetTable.Magic);
 			bw.Write (MajorVersion);
 			bw.Write (MinorVersion);
 
 			bw.Write (guid.ToByteArray ());
 
 			//
 			// Offsets of file sections; we must write this after we're done
 			// writing the whole file, so we just reserve the space for it here.
 			//
 			long offset_table_offset = bw.BaseStream.Position;
 			ot.Write (bw, MajorVersion, MinorVersion);
 
 			//
 			// Sort the methods according to their tokens and update their index.
 			//
 			methods.Sort ();
 			for (int i = 0; i < methods.Count; i++)
 				((MethodEntry) methods [i]).Index = i + 1;
 
 			//
 			// Write data sections.
 			//
 			ot.DataSectionOffset = (int) bw.BaseStream.Position;
 			foreach (SourceFileEntry source in sources)
 				source.WriteData (bw);
 			foreach (CompileUnitEntry comp_unit in comp_units)
 				comp_unit.WriteData (bw);
 			foreach (MethodEntry method in methods)
 				method.WriteData (this, bw);
 			ot.DataSectionSize = (int) bw.BaseStream.Position - ot.DataSectionOffset;
 
 			//
 			// Write the method index table.
 			//
 			ot.MethodTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < methods.Count; i++) {
 				MethodEntry entry = (MethodEntry) methods [i];
 				entry.Write (bw);
 			}
 			ot.MethodTableSize = (int) bw.BaseStream.Position - ot.MethodTableOffset;
 
 			//
 			// Write source table.
 			//
 			ot.SourceTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < sources.Count; i++) {
 				SourceFileEntry source = (SourceFileEntry) sources [i];
 				source.Write (bw);
 			}
 			ot.SourceTableSize = (int) bw.BaseStream.Position - ot.SourceTableOffset;
 
 			//
 			// Write compilation unit table.
 			//
 			ot.CompileUnitTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < comp_units.Count; i++) {
 				CompileUnitEntry unit = (CompileUnitEntry) comp_units [i];
 				unit.Write (bw);
 			}
 			ot.CompileUnitTableSize = (int) bw.BaseStream.Position - ot.CompileUnitTableOffset;
 
 			//
 			// Write anonymous scope table.
 			//
 			ot.AnonymousScopeCount = anonymous_scopes != null ? anonymous_scopes.Count 
 			ot.AnonymousScopeTableOffset = (int) bw.BaseStream.Position;
 			if (anonymous_scopes != null) {
 				foreach (AnonymousScopeEntry scope in anonymous_scopes.Values)
 					scope.Write (bw);
 			}
 			ot.AnonymousScopeTableSize = (int) bw.BaseStream.Position - ot.AnonymousScopeTableOffset;
 
 			//
 			// Fixup offset table.
 			//
 			ot.TypeCount = last_type_index;
 			ot.MethodCount = methods.Count;
 			ot.SourceCount = sources.Count;
 			ot.CompileUnitCount = comp_units.Count;
 
 			//
 			// Write offset table.
 			//
 			ot.TotalFileSize = (int) bw.BaseStream.Position;
 			bw.Seek ((int) offset_table_offset, SeekOrigin.Begin);
 			ot.Write (bw, MajorVersion, MinorVersion);
 			bw.Seek (0, SeekOrigin.End);
 
 #if false
 			Console.WriteLine ("TOTAL
 					   "{3} methods.", NumLineNumbers, LineNumberSize,
 					   ExtendedLineNumberSize, methods.Count);
 #endif
 		}
 
 		public void CreateSymbolFile (Guid guid, FileStream fs)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			Write (new MyBinaryWriter (fs), guid);
 		}
 
 		MyBinaryReader reader;
 		Dictionary<int, SourceFileEntry> source_file_hash;
 		Dictionary<int, CompileUnitEntry> compile_unit_hash;
 
 		List<MethodEntry> method_list;
 		Dictionary<int, MethodEntry> method_token_hash;
 		Dictionary<string, int> source_name_hash;
 
 		Guid guid;
 
 		MonoSymbolFile (string filename)
 		{
 			this.FileName = filename;
 			FileStream stream = new FileStream (filename, FileMode.Open, FileAccess.Read);
 			reader = new MyBinaryReader (stream);
 
 			try {
 				long magic = reader.ReadInt64 ();
 				int major_version = reader.ReadInt32 ();
 				int minor_version = reader.ReadInt32 ();
 
 				if (magic != OffsetTable.Magic)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' is not a valid " +
 						"Mono symbol file", filename);
 				if (major_version != OffsetTable.MajorVersion)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' has version {1}, " +
 						"but expected {2}", filename, major_version,
 						OffsetTable.MajorVersion);
 				if (minor_version != OffsetTable.MinorVersion)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' has version {1}.{2}, " +
 						"but expected {3}.{4}", filename, major_version,
 						minor_version, OffsetTable.MajorVersion,
 						OffsetTable.MinorVersion);
 
 				MajorVersion = major_version;
 				MinorVersion = minor_version;
 				guid = new Guid (reader.ReadBytes (16));
 
 				ot = new OffsetTable (reader, major_version, minor_version);
 			} catch {
 				throw new MonoSymbolFileException (
 					"Cannot read symbol file `{0}'", filename);
 			}
 
 			source_file_hash = new Dictionary<int, SourceFileEntry> ();
 			compile_unit_hash = new Dictionary<int, CompileUnitEntry> ();
 		}
 
 		void CheckGuidMatch (Guid other, string filename, string assembly)
 		{
 			if (other == guid)
 				return;
 
 			throw new MonoSymbolFileException (
 				"Symbol file `{0}' does not match assembly `{1}'",
 				filename, assembly);
 		}
 
 #if CECIL
 		protected MonoSymbolFile (string filename, Mono.Cecil.ModuleDefinition module)
 			
 		{
 			CheckGuidMatch (module.Mvid, filename, module.FullyQualifiedName);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Mono.Cecil.ModuleDefinition module)
 		{
 			return ReadSymbolFile (module, module.FullyQualifiedName);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Mono.Cecil.ModuleDefinition module, string filename)
 		{
 			string name = filename + ".mdb";
 
 			return new MonoSymbolFile (name, module);
 		}
 #else
 		protected MonoSymbolFile (string filename, Assembly assembly) 
 		{
 			// Check that the MDB file matches the assembly, if we have been
 			// passed an assembly.
 			if (assembly == null)
 				return;
 			
 			Module[] modules = assembly.GetModules ();
 			Guid assembly_guid = MonoDebuggerSupport.GetGuid (modules [0]);
 
 			CheckGuidMatch (assembly_guid, filename, assembly.Location);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Assembly assembly)
 		{
 			string filename = assembly.Location;
 			string name = filename + ".mdb";
 
 			return new MonoSymbolFile (name, assembly);
 		}
 #endif
 
 		public static MonoSymbolFile ReadSymbolFile (string mdbFilename)
 		{
 			return new MonoSymbolFile (mdbFilename, null);
 		}
 
 		public int CompileUnitCount {
 			get { return ot.CompileUnitCount; }
 		}
 
 		public int SourceCount {
 			get { return ot.SourceCount; }
 		}
 
 		public int MethodCount {
 			get { return ot.MethodCount; }
 		}
 
 		public int TypeCount {
 			get { return ot.TypeCount; }
 		}
 
 		public int AnonymousScopeCount {
 			get { return ot.AnonymousScopeCount; }
 		}
 
 		public int NamespaceCount {
 			get { return last_namespace_index; }
 		}
 
 		public Guid Guid {
 			get { return guid; }
 		}
 
 		public OffsetTable OffsetTable {
 			get { return ot; }
 		}
 
 		internal int LineNumberCount = 0;
 		internal int LocalCount = 0;
 		internal int StringSize = 0;
 
 		internal int LineNumberSize = 0;
 		internal int ExtendedLineNumberSize = 0;
 		MonoSymbolFile (string filename)
 		{
 			this.FileName = filename;
 			FileStream stream = new FileStream (filename, FileMode.Open, FileAccess.Read);
 			reader = new MyBinaryReader (stream);
 
 			try {
 				long magic = reader.ReadInt64 ();
 				int major_version = reader.ReadInt32 ();
 				int minor_version = reader.ReadInt32 ();
 
 				if (magic != OffsetTable.Magic)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' is not a valid " +
 						"Mono symbol file", filename);
 				if (major_version != OffsetTable.MajorVersion)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' has version {1}, " +
 						"but expected {2}", filename, major_version,
 						OffsetTable.MajorVersion);
 				if (minor_version != OffsetTable.MinorVersion)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' has version {1}.{2}, " +
 						"but expected {3}.{4}", filename, major_version,
 						minor_version, OffsetTable.MajorVersion,
 						OffsetTable.MinorVersion);
 
 				MajorVersion = major_version;
 				MinorVersion = minor_version;
 				guid = new Guid (reader.ReadBytes (16));
 
 				ot = new OffsetTable (reader, major_version, minor_version);
 			} catch {
 				throw new MonoSymbolFileException (
 					"Cannot read symbol file `{0}'", filename);
 			}
 
 			source_file_hash = new Dictionary<int, SourceFileEntry> ();
 			compile_unit_hash = new Dictionary<int, CompileUnitEntry> ();
 		}
]]></clone_fragment>
<clone_fragment endline="508" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" hamdist="6" pcid="233" startline="119"><![CDATA[
 		int id;
 
 		// <summary>
 		//   The vector contains a BitArray with information about which local variables
 		//   and parameters are already initialized at the current code position.
 		// </summary>
 		public class UsageVector {
 			// <summary>
 			//   The type of this branching.
 			// </summary>
 			public readonly SiblingType Type;
 
 			// <summary>
 			//   Start location of this branching.
 			// </summary>
 			public Location Location;
 
 			// <summary>
 			//   This is only valid for SwitchSection, Try, Catch and Finally.
 			// </summary>
 			public readonly Block Block;
 
 			// <summary>
 			//   The number of locals in this block.
 			// </summary>
 			public readonly int CountLocals;
 
 			// <summary>
 			//   If not null, then we inherit our state from this vector and do a
 			//   copy-on-write.  If null, then we're the first sibling in a top-level
 			//   block and inherit from the empty vector.
 			// </summary>
 			public readonly UsageVector InheritsFrom;
 
 			// <summary>
 			//   This is used to construct a list of UsageVector's.
 			// </summary>
 			public UsageVector Next;
 
 			//
 			// Private.
 			//
 			MyBitVector locals;
 			bool is_unreachable;
 
 			static int next_id = 0;
 			int id;
 
 			//
 			// Normally, you should not use any of these constructors.
 			//
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc, int num_locals)
 			{
 				this.Type = type;
 				this.Block = block;
 				this.Location = loc;
 				this.InheritsFrom = parent;
 				this.CountLocals = num_locals;
 
 				locals = num_locals == 0 
 					? MyBitVector.Empty
 					
 
 				if (parent != null)
 					is_unreachable = parent.is_unreachable;
 
 				id = ++next_id;
 
 			}
 
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc)
 				
 			{ }
 
 			private UsageVector (MyBitVector locals, bool is_unreachable, Block block, Location loc)
 			{
 				this.Type = SiblingType.Block;
 				this.Location = loc;
 				this.Block = block;
 
 				this.is_unreachable = is_unreachable;
 
 				this.locals = locals;
 
 				id = ++next_id;
 
 			}
 
 			// <summary>
 			//   This does a deep copy of the usage vector.
 			// </summary>
 			public UsageVector Clone ()
 			{
 				UsageVector retval = new UsageVector (Type, null, Block, Location, CountLocals);
 
 				retval.locals = locals.Clone ();
 				retval.is_unreachable = is_unreachable;
 
 				return retval;
 			}
 
 			public bool IsAssigned (VariableInfo var, bool ignoreReachability)
 			{
 				if (!ignoreReachability && !var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsAssigned (locals);
 			}
 
 			public void SetAssigned (VariableInfo var)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetAssigned (locals);
 			}
 
 			public bool IsFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsFieldAssigned (locals, name);
 			}
 
 			public void SetFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetFieldAssigned (locals, name);
 			}
 
 			public bool IsUnreachable {
 				get { return is_unreachable; }
 			}
 
 			public void ResetBarrier ()
 			{
 				is_unreachable = false;
 			}
 
 			public void Goto ()
 			{
 				is_unreachable = true;
 			}
 
 			public static UsageVector MergeSiblings (UsageVector sibling_list, Location loc)
 			{
 				if (sibling_list.Next == null)
 					return sibling_list;
 
 				MyBitVector locals = null;
 				bool is_unreachable = sibling_list.is_unreachable;
 
 				if (!sibling_list.IsUnreachable)
 					locals &= sibling_list.locals;
 
 				for (UsageVector child = sibling_list.Next; child != null; child = child.Next) {
 					is_unreachable &= child.is_unreachable;
 
 					if (!child.IsUnreachable)
 						locals &= child.locals;
 				}
 
 				return new UsageVector (locals, is_unreachable, null, loc);
 			}
 
 			// <summary>
 			//   Merges a child branching.
 			// </summary>
 			public UsageVector MergeChild (UsageVector child, bool overwrite)
 			{
 				Report.Debug (2, "    MERGING CHILD EFFECTS", this, child, Type);
 
 				bool new_isunr = child.is_unreachable;
 
 				//
 				// We've now either reached the point after the branching or we will
 				// never get there since we always return or always throw an exception.
 				//
 				// If we can reach the point after the branching, mark all locals and
 				// parameters as initialized which have been initialized in all branches
 				// we need to look at (see above).
 				//
 
 				if ((Type == SiblingType.SwitchSection) && !new_isunr) {
 					Report.Error (163, Location,
 						      "Control cannot fall through from one " +
 						      "case label to another");
 					return child;
 				}
 
 				locals |= child.locals;
 
 				// throw away un-necessary information about variables in child blocks
 				if (locals.Count != CountLocals)
 					locals = new MyBitVector (locals, CountLocals);
 
 				if (overwrite)
 					is_unreachable = new_isunr;
 				else
 					is_unreachable |= new_isunr;
 
 				return child;
 			}
 
 			public void MergeOrigins (UsageVector o_vectors)
 			{
 				Report.Debug (1, "  MERGING BREAK ORIGINS", this);
 
 				if (o_vectors == null)
 					return;
 
 				if (IsUnreachable && locals != null)
 					locals.SetAll (true);
 
 				for (UsageVector vector = o_vectors; vector != null; vector = vector.Next) {
 					Report.Debug (1, "    MERGING BREAK ORIGIN", vector);
 					if (vector.IsUnreachable)
 						continue;
 					locals &= vector.locals;
 					is_unreachable &= vector.is_unreachable;
 				}
 
 				Report.Debug (1, "  MERGING BREAK ORIGINS DONE", this);
 			}
 
 			//
 			// Debugging stuff.
 			//
 
 			public override string ToString ()
 			{
 				return String.Format ("Vector ({0},{1},{2}-{3})", Type, id, is_unreachable, locals);
 			}
 		}
 
 		// <summary>
 		//   Creates a new flow branching which is contained in `parent'.
 		//   You should only pass non-null for the `block' argument if this block
 		//   introduces any new variables - in this case, we need to create a new
 		//   usage vector with a different size than our parent's one.
 		// </summary>
 		protected FlowBranching (FlowBranching parent, BranchingType type, SiblingType stype,
 					 Block block, Location loc)
 		{
 			Parent = parent;
 			Block = block;
 			Location = loc;
 			Type = type;
 			id = ++next_id;
 
 			UsageVector vector;
 			if (Block != null) {
 				UsageVector parent_vector = parent != null ? parent.CurrentUsageVector 
 				vector = new UsageVector (stype, parent_vector, Block, loc, Block.AssignableSlots);
 			} else {
 				vector = new UsageVector (stype, Parent.CurrentUsageVector, null, loc);
 			}
 
 			AddSibling (vector);
 		}
 
 		public abstract UsageVector CurrentUsageVector {
 			get;
 		}				
 
 		// <summary>
 		//   Creates a sibling of the current usage vector.
 		// </summary>
 		public virtual void CreateSibling (Block block, SiblingType type)
 		{
 			UsageVector vector = new UsageVector (
 				type, Parent.CurrentUsageVector, block, Location);
 			AddSibling (vector);
 
 			Report.Debug (1, "  CREATED SIBLING", CurrentUsageVector);
 		}
 
 		public void CreateSibling ()
 		{
 			CreateSibling (null, SiblingType.Conditional);
 		}
 
 		protected abstract void AddSibling (UsageVector uv);
 
 		protected abstract UsageVector Merge ();
 
 		public UsageVector MergeChild (FlowBranching child)
 		{
 			return CurrentUsageVector.MergeChild (child.Merge (), true);
  		}
 
 		public virtual bool CheckRethrow (Location loc)
 		{
 			return Parent.CheckRethrow (loc);
 		}
 
 		public virtual bool AddResumePoint (ResumableStatement stmt, Location loc, out int pc)
 		{
 			return Parent.AddResumePoint (stmt, loc, out pc);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			return Parent.AddBreakOrigin (vector, loc);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			return Parent.AddContinueOrigin (vector, loc);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddReturnOrigin (UsageVector vector, ExitStatement stmt)
 		{
 			return Parent.AddReturnOrigin (vector, stmt);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			return Parent.AddGotoOrigin (vector, goto_stmt);
 		}
 
 		public bool IsAssigned (VariableInfo vi)
 		{
 			return CurrentUsageVector.IsAssigned (vi, false);
 		}
 
 		public bool IsFieldAssigned (VariableInfo vi, string field_name)
 		{
 			return CurrentUsageVector.IsAssigned (vi, false) || CurrentUsageVector.IsFieldAssigned (vi, field_name);
 		}
 
 		protected static Report Report {
 			get { return RootContext.ToplevelTypes.Compiler.Report; }
 		}
 
 		public void SetAssigned (VariableInfo vi)
 		{
 			CurrentUsageVector.SetAssigned (vi);
 		}
 
 		public void SetFieldAssigned (VariableInfo vi, string name)
 		{
 			CurrentUsageVector.SetFieldAssigned (vi, name);
 		}
 
 #if DEBUG
 		public override string ToString ()
 		{
 			StringBuilder sb = new StringBuilder ();
 			sb.Append (GetType ());
 			sb.Append (" (");
 
 			sb.Append (id);
 			sb.Append (",");
 			sb.Append (Type);
 			if (Block != null) {
 				sb.Append (" - ");
 				sb.Append (Block.ID);
 				sb.Append (" - ");
 				sb.Append (Block.StartLocation);
 			}
 			sb.Append (" - ");
 			// sb.Append (Siblings.Length);
 			// sb.Append (" - ");
 			sb.Append (CurrentUsageVector);
 			sb.Append (")");
 			return sb.ToString ();
 		}
 #endif
 
 		public string Name {
 			get { return String.Format ("{0} ({1}
 		}
 	}
 
 	public class FlowBranchingBlock 
 	{
 		UsageVector sibling_list = null;
 
 		public FlowBranchingBlock (FlowBranching parent, BranchingType type,
 					   SiblingType stype, Block block, Location loc)
 			
 		{ }
]]></clone_fragment>
<clone_fragment endline="566" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" hamdist="6" pcid="4711" startline="136"><![CDATA[
 
 		public ModuleContainer (CompilerContext context)
 			
 		{
 			this.context = context;
 
 			caching_flags &= ~(Flags.Obsolete_Undetected | Flags.Excluded_Undetected);
 
 			types = new List<TypeContainer> ();
 			anonymous_types = new Dictionary<int, List<AnonymousTypeClass>> ();
 			global_ns = new GlobalRootNamespace ();
 			alias_ns = new Dictionary<string, RootNamespace> ();
 		}
 
 		#region Properties
 
  		public override AttributeTargets AttributeTargets {
  			get {
  				return AttributeTargets.Assembly;
  			}
 		}
 
 		public ModuleBuilder Builder {
 			get {
 				return builder;
 			}
 		}
 
 		public override CompilerContext Compiler {
 			get {
 				return context;
 			}
 		}
 
 		public override AssemblyDefinition DeclaringAssembly {
 			get {
 				return assembly;
 			}
 		}
 
 		public bool HasDefaultCharSet {
 			get {
 				return has_default_charset;
 			}
 		}
 
 		public bool HasExtensionMethod {
 			get {
 				return has_extenstion_method;
 			}
 			set {
 				has_extenstion_method = value;
 			}
 		}
 
 		//
 		// Returns module global
 		//
 		public RootNamespace GlobalRootNamespace {
 		    get {
 		        return global_ns;
 		    }
 		}
 
 		public override ModuleContainer Module {
 			get {
 				return this;
 			}
 		}
 
 		internal PredefinedAttributes PredefinedAttributes {
 			get {
 				return predefined_attributes;
 			}
 		}
 
 		internal PredefinedTypes PredefinedTypes {
 			get {
 				return predefined_types;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#endregion
 
 		public void AddAnonymousType (AnonymousTypeClass type)
 		{
 			List<AnonymousTypeClass> existing;
 			if (!anonymous_types.TryGetValue (type.Parameters.Count, out existing))
 			if (existing == null) {
 				existing = new List<AnonymousTypeClass> ();
 				anonymous_types.Add (type.Parameters.Count, existing);
 			}
 
 			existing.Add (type);
 		}
 
 		public void AddAttributes (List<Attribute> attrs)
 		{
 			AddAttributes (attrs, this);
 		}
 
 		public void AddAttributes (List<Attribute> attrs, IMemberContext context)
 		{
 			foreach (Attribute a in attrs)
 				a.AttachTo (this, context);
 
 			if (attributes == null) {
 				attributes = new Attributes (attrs);
 				return;
 			}
 			attributes.AddAttributes (attrs);
 		}
 
 		public override TypeContainer AddPartial (TypeContainer nextPart)
 		{
 			return AddPartial (nextPart, nextPart.Name);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.Assembly) {
 				assembly.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.CLSCompliant) {
 				Attribute cls = DeclaringAssembly.CLSCompliantAttribute;
 				if (cls == null) {
 					Report.Warning (3012, 1, a.Location,
 						"You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking");
 				} else if (DeclaringAssembly.IsCLSCompliant != a.GetBoolean ()) {
 					Report.SymbolRelatedToPreviousError (cls.Location, cls.GetSignatureForError ());
 					Report.Warning (3017, 1, a.Location,
 						"You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly");
 					return;
 				}
 			}
 
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public override void CloseType ()
 		{
 			HackCorlibEnums ();
 
 			foreach (TypeContainer tc in types) {
 				tc.CloseType ();
 			}
 
 			if (compiler_generated != null)
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					c.CloseType ();
 		}
 
 		public TypeBuilder CreateBuilder (string name, TypeAttributes attr, int typeSize)
 		{
 			return builder.DefineType (name, attr, null, typeSize);
 		}
 
 		//
 		// Creates alias global namespace
 		//
 		public RootNamespace CreateRootNamespace (string alias)
 		{
 			if (alias == global_ns.Alias) {
 				NamespaceEntry.Error_GlobalNamespaceRedefined (Location.Null, Report);
 				return global_ns;
 			}
 
 			RootNamespace rn;
 			if (!alias_ns.TryGetValue (alias, out rn)) {
 				rn = new RootNamespace (alias);
 				alias_ns.Add (alias, rn);
 			}
 
 			return rn;
 		}
 
 		public new void Define ()
 		{
 			builder = assembly.CreateModuleBuilder ();
 
 			// FIXME
 			static_data = null;
 
 			// TODO
 			// but that require DefineType clean-up
 			ResolveGlobalAttributes ();
 
 			foreach (TypeContainer tc in types)
 				tc.CreateType ();
 
 			InitializePredefinedTypes ();
 
 			foreach (TypeContainer tc in types)
 				tc.DefineType ();
 
 			foreach (TypeContainer tc in types)
 				tc.ResolveTypeParameters ();
 
 			foreach (TypeContainer tc in types) {
 				try {
 					tc.Define ();
 				} catch (Exception e) {
 					throw new InternalErrorException (tc, e);
 				}
 			}
 		}
 
 		public override void Emit ()
 		{
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (RootContext.Unsafe) {
 				var pa = PredefinedAttributes.UnverifiableCode;
 				if (pa.IsDefined)
 					pa.EmitAttribute (builder);
 			}
 
 			foreach (var tc in types)
 				tc.DefineConstants ();
 
 			HackCorlib ();
 
 			foreach (TypeContainer tc in types)
 				tc.EmitType ();
 
 			if (Compiler.Report.Errors > 0)
 				return;
 
 			foreach (TypeContainer tc in types)
 				tc.VerifyMembers ();
 
 			if (compiler_generated != null)
 				foreach (var c in compiler_generated)
 					c.EmitType ();
 		}
 
 		public AnonymousTypeClass GetAnonymousType (IList<AnonymousTypeParameter> parameters)
 		{
 			List<AnonymousTypeClass> candidates;
 			if (!anonymous_types.TryGetValue (parameters.Count, out candidates))
 				return null;
 
 			int i;
 			foreach (AnonymousTypeClass at in candidates) {
 				for (i = 0; i < parameters.Count; ++i) {
 					if (!parameters [i].Equals (at.Parameters [i]))
 						break;
 				}
 
 				if (i == parameters.Count)
 					return at;
 			}
 
 			return null;
 		}
 
 		public RootNamespace GetRootNamespace (string name)
 		{
 			RootNamespace rn;
 			alias_ns.TryGetValue (name, out rn);
 			return rn;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return "<module>";
 		}
 
 		void HackCorlib ()
 		{
 #if !STATIC
 			if (RootContext.StdLib)
 				return;
 
 			//
 			// HACK
 			// has different predefined types and this method sets mscorlib types
 			// to be same to avoid type check errors in CreateType.
 			//
 			var type = typeof (Type);
 			var system_4_type_arg = new[] { type, type, type, type };
 
 			MethodInfo set_corlib_type_builders =
 				typeof (System.Reflection.Emit.AssemblyBuilder).GetMethod (
 				"SetCorlibTypeBuilders", BindingFlags.NonPublic | BindingFlags.Instance, null,
 				system_4_type_arg, null);
 
 			if (set_corlib_type_builders == null) {
 				Compiler.Report.Warning (-26, 3,
 					"The compilation may fail due to missing `System.Reflection.Emit.AssemblyBuilder.SetCorlibTypeBuilders(...)' method");
 				return;
 			}
 
 			object[] args = new object[4];
 			args[0] = TypeManager.object_type.GetMetaInfo ();
 			args[1] = TypeManager.value_type.GetMetaInfo ();
 			args[2] = TypeManager.enum_type.GetMetaInfo ();
 			args[3] = TypeManager.void_type.GetMetaInfo ();
 			set_corlib_type_builders.Invoke (assembly.Builder, args);
 #endif
 		}
 
 		void HackCorlibEnums ()
 		{
 			if (RootContext.StdLib)
 				return;
 
 			// Another Mono corlib HACK
 			// mono_class_layout_fields requires to have enums created
 			// before creating a class which used the enum for any of its fields
 			foreach (var e in hack_corlib_enums)
 				e.CloseType ();
 		}
 
 		public void InitializePredefinedTypes ()
 		{
 			predefined_attributes = new PredefinedAttributes (this);
 			predefined_types = new PredefinedTypes (this);
 		}
 
 		public override bool IsClsComplianceRequired ()
 		{
 			return DeclaringAssembly.IsCLSCompliant;
 		}
 
 		//
 		// Makes const data field inside internal type container
 		//
 		public FieldSpec MakeStaticData (byte[] data, Location loc)
 		{
 			if (static_data == null) {
 				static_data = new StaticDataContainer (this);
 				static_data.CreateType ();
 				static_data.DefineType ();
 
 				AddCompilerGeneratedClass (static_data);
 			}
 
 			return static_data.DefineInitializedData (data, loc);
 		}
 
 		protected override bool AddMemberType (TypeContainer ds)
 		{
 			if (!AddToContainer (ds, ds.Name))
 				return false;
 			ds.NamespaceEntry.NS.AddType (ds.Definition);
 			return true;
 		}
 
 		protected override void RemoveMemberType (DeclSpace ds)
 		{
 			ds.NamespaceEntry.NS.RemoveDeclSpace (ds.Basename);
 			base.RemoveMemberType (ds);
 		}
 
 		/// <summary>
 		/// It is called very early therefore can resolve only predefined attributes
 		/// </summary>
 		void ResolveGlobalAttributes ()
 		{
 			if (OptAttributes == null)
 				return;
 
 			if (!OptAttributes.CheckTargets ())
 				return;
 
 			// FIXME
 			var DefaultCharSet_attr = new PredefinedAttribute (this, "System.Runtime.InteropServices", "DefaultCharSetAttribute");
 			DefaultCharSet_attr.Define ();
 			Attribute a = ResolveModuleAttribute (DefaultCharSet_attr);
 			if (a != null) {
 				has_default_charset = true;
 				DefaultCharSet = a.GetCharSetValue ();
 				switch (DefaultCharSet) {
 				case CharSet.Ansi
 				case CharSet.None
 					break;
 				case CharSet.Auto
 					DefaultCharSetType = TypeAttributes.AutoClass;
 					break;
 				case CharSet.Unicode
 					DefaultCharSetType = TypeAttributes.UnicodeClass;
 					break;
 				default
 					Report.Error (1724, a.Location, "Value specified for the argument to `{0}' is not valid", 
 						DefaultCharSet_attr.GetSignatureForError ());
 					break;
 				}
 			}
 		}
 
 		public Attribute ResolveAssemblyAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("assembly", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
 
 		Attribute ResolveModuleAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("module", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
 
 		public void SetDeclaringAssembly (AssemblyDefinition assembly)
 		{
 			// TODO
 			this.assembly = assembly;
 		}
 	}
 
 	class RootDeclSpace 
 		public RootDeclSpace (NamespaceEntry ns)
 			
 		{
 			PartialContainer = RootContext.ToplevelTypes;
 		}
]]></clone_fragment>
<clone_fragment endline="447" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" hamdist="4" pcid="2527" startline="43"><![CDATA[
 		
 		Expression instance_expr;
 		ReturnParameter return_attributes;
 
 		const Modifiers MethodModifiers = Modifiers.PUBLIC | Modifiers.VIRTUAL;
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.UNSAFE |
 			Modifiers.PRIVATE;
 
  		public Delegate (NamespaceEntry ns, DeclSpace parent, FullNamedExpression type,
 				 Modifiers mod_flags, MemberName name, ParametersCompiled param_list,
 				 Attributes attrs)
 			
 
 		{
 			this.ReturnType = type;
 			ModFlags        = ModifiersExtensions.Check (AllowedModifiers, mod_flags,
 							   IsTopLevel ? Modifiers.INTERNAL 
 							   Modifiers.PRIVATE, name.Location, Report);
 			parameters      = param_list;
 			spec = new TypeSpec (Kind, null, this, null, ModFlags | Modifiers.SEALED);
 		}
 
 		#region Properties
 		public TypeSpec MemberType {
 			get {
 				return ReturnType.Type;
 			}
 		}
 
 		public AParametersCollection Parameters {
 			get {
 				return parameters;
 			}
 		}
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Delegate;
 			}
 		}
 
 		protected override bool DoDefineMembers ()
 		{
 			var ctor_parameters = ParametersCompiled.CreateFullyResolved (
 				new [] {
 					new Parameter (new TypeExpression (TypeManager.object_type, Location), "object", Parameter.Modifier.NONE, null, Location),
 					new Parameter (new TypeExpression (TypeManager.intptr_type, Location), "method", Parameter.Modifier.NONE, null, Location)
 				},
 				new [] {
 					TypeManager.object_type,
 					TypeManager.intptr_type
 				}
 			);
 
 			Constructor = new Constructor (this, Constructor.ConstructorName,
 				Modifiers.PUBLIC, null, ctor_parameters, null, Location);
 			Constructor.Define ();
 
 			//
 			// Here the various methods like Invoke, BeginInvoke etc are defined
 			//
 			// First, call the `out of band' special method for
 			// defining recursively any types we need
 			//
 			var p = parameters;
 
 			if (!p.Resolve (this))
 				return false;
 
 			//
 			// Invoke method
 			//
 
 			// Check accessibility
 			foreach (var partype in p.Types) {
 				if (!IsAccessibleAs (partype)) {
 					Report.SymbolRelatedToPreviousError (partype);
 					Report.Error (59, Location,
 						"Inconsistent accessibility
 						TypeManager.CSharpName (partype), GetSignatureForError ());
 				}
 			}
 
 			ReturnType = ReturnType.ResolveAsTypeTerminal (this, false);
 			if (ReturnType == null)
 				return false;
 
 			var ret_type = ReturnType.Type;
 
 			//
 			// We don't have to check any others because they are all
 			// guaranteed to be accessible - they are standard types.
 			//
 			if (!IsAccessibleAs (ret_type)) {
 				Report.SymbolRelatedToPreviousError (ret_type);
 				Report.Error (58, Location,
 						  "Inconsistent accessibility
 						  TypeManager.CSharpName (ret_type) + "' is less " +
 						  "accessible than delegate `" + GetSignatureForError () + "'");
 				return false;
 			}
 
 			CheckProtectedModifier ();
 
 			if (RootContext.StdLib && TypeManager.IsSpecialType (ret_type)) {
 				Method.Error1599 (Location, ret_type, Report);
 				return false;
 			}
 
 			TypeManager.CheckTypeVariance (ret_type, Variance.Covariant, this);
 
 			InvokeBuilder = new Method (this, null, ReturnType, MethodModifiers, new MemberName (InvokeMethodName), p, null);
 			InvokeBuilder.Define ();
 
 			//
 			// Don't emit async method for compiler generated delegates (e.g. dynamic site containers)
 			//
 			if (!IsCompilerGenerated) {
 				DefineAsyncMethods (Parameters.CallingConvention);
 			}
 
 			return true;
 		}
 
 		void DefineAsyncMethods (CallingConventions cc)
 		{
 			var iasync_result = Module.PredefinedTypes.IAsyncResult;
 			var async_callback = Module.PredefinedTypes.AsyncCallback;
 
 			//
 			// It's ok when async types don't exist, the delegate will have Invoke method only
 			//
 			if (!iasync_result.Define () || !async_callback.Define ())
 				return;
 
 			//
 			// BeginInvoke
 			//
 			ParametersCompiled async_parameters;
 			if (Parameters.Count == 0) {
 				async_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 			} else {
 				var compiled = new Parameter[Parameters.Count];
 				for (int i = 0; i < compiled.Length; ++i) {
 					var p = parameters[i];
 					compiled[i] = new Parameter (new TypeExpression (parameters.Types[i], Location),
 						p.Name,
 						p.ModFlags & (Parameter.Modifier.REF | Parameter.Modifier.OUT),
 						p.OptAttributes == null ? null 
 				}
 
 				async_parameters = new ParametersCompiled (compiled);
 			}
 
 			async_parameters = ParametersCompiled.MergeGenerated (Compiler, async_parameters, false,
 				new Parameter[] {
 					new Parameter (new TypeExpression (async_callback.TypeSpec, Location), "callback", Parameter.Modifier.NONE, null, Location),
 					new Parameter (new TypeExpression (TypeManager.object_type, Location), "object", Parameter.Modifier.NONE, null, Location)
 				},
 				new [] {
 					async_callback.TypeSpec,
 					TypeManager.object_type
 				}
 			);
 
 			BeginInvokeBuilder = new Method (this, null,
 				new TypeExpression (iasync_result.TypeSpec, Location), MethodModifiers,
 				new MemberName ("BeginInvoke"), async_parameters, null);
 			BeginInvokeBuilder.Define ();
 
 			//
 			// EndInvoke is a bit more interesting, all the parameters labeled as
 			// out or ref have to be duplicated here.
 			//
 
 			//
 			// Define parameters, and count out/ref parameters
 			//
 			ParametersCompiled end_parameters;
 			int out_params = 0;
 
 			foreach (Parameter p in Parameters.FixedParameters) {
 				if ((p.ModFlags & Parameter.Modifier.ISBYREF) != 0)
 					++out_params;
 			}
 
 			if (out_params > 0) {
 				Parameter[] end_params = new Parameter[out_params];
 
 				int param = 0;
 				for (int i = 0; i < Parameters.FixedParameters.Length; ++i) {
 					Parameter p = parameters [i];
 					if ((p.ModFlags & Parameter.Modifier.ISBYREF) == 0)
 						continue;
 
 					end_params [param++] = new Parameter (new TypeExpression (p.Type, Location),
 						p.Name,
 						p.ModFlags & (Parameter.Modifier.REF | Parameter.Modifier.OUT),
 						p.OptAttributes == null ? null 
 				}
 
 				end_parameters = new ParametersCompiled (end_params);
 			} else {
 				end_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 			}
 
 			end_parameters = ParametersCompiled.MergeGenerated (Compiler, end_parameters, false,
 				new Parameter (
 					new TypeExpression (iasync_result.TypeSpec, Location),
 					"result", Parameter.Modifier.NONE, null, Location),
 				iasync_result.TypeSpec);
 
 			//
 			// Create method, define parameters, register parameters with type system
 			//
 			EndInvokeBuilder = new Method (this, null, ReturnType, MethodModifiers, new MemberName ("EndInvoke"), end_parameters, null);
 			EndInvokeBuilder.Define ();
 		}
 
 		public override void DefineConstants ()
 		{
 			if (!Parameters.IsEmpty) {
 				parameters.ResolveDefaultValues (this);
 			}
 		}
 
 		public override void EmitType ()
 		{
 			if (ReturnType.Type != null) {
 				if (ReturnType.Type == InternalType.Dynamic) {
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 					Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 				} else if (ReturnType.Type.HasDynamicElement) {
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 					Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType.Type, Location);
 				}
 			}
 
 			Constructor.ParameterInfo.ApplyAttributes (this, Constructor.ConstructorBuilder);
 			Constructor.ConstructorBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 
 			parameters.ApplyAttributes (this, InvokeBuilder.MethodBuilder);
 			InvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 
 			if (BeginInvokeBuilder != null) {
 				BeginInvokeBuilder.ParameterInfo.ApplyAttributes (this, BeginInvokeBuilder.MethodBuilder);
 				EndInvokeBuilder.ParameterInfo.ApplyAttributes (this, EndInvokeBuilder.MethodBuilder);
 
 				BeginInvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 				EndInvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 			}
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			base.Emit ();
 		}
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			base_type = TypeManager.multicast_delegate_type;
 			base_class = null;
 			return null;
 		}
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed |
 					base.TypeAttr;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		//TODO
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			parameters.VerifyClsCompliance (this);
 
 			if (!ReturnType.Type.IsCLSCompliant ()) {
 				Report.Warning (3002, 1, Location, "Return type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
 
 
 		public static MethodSpec GetConstructor (CompilerContext ctx, TypeSpec container_type, TypeSpec delType)
 		{
 			var ctor = MemberCache.FindMember (delType, MemberFilter.Constructor (null), BindingRestriction.DeclaredOnly);
 			return (MethodSpec) ctor;
 		}
 
 		//
 		// Returns the "Invoke" from a delegate type
 		//
 		public static MethodSpec GetInvokeMethod (CompilerContext ctx, TypeSpec delType)
 		{
 			var invoke = MemberCache.FindMember (delType,
 				MemberFilter.Method (InvokeMethodName, 0, null, null),
 				BindingRestriction.DeclaredOnly);
 
 			return (MethodSpec) invoke;
 		}
 
 		public static AParametersCollection GetParameters (CompilerContext ctx, TypeSpec delType)
 		{
 			var invoke_mb = GetInvokeMethod (ctx, delType);
 			return invoke_mb.Parameters;
 		}
 
 		//
 		// 15.2 Delegate compatibility
 		//
 		public static bool IsTypeCovariant (Expression a, TypeSpec b)
 		{
 			//
 			// For each value parameter (a parameter with no ref or out modifier), an 
 			// identity conversion or implicit reference conversion exists from the
 			// parameter type in D to the corresponding parameter type in M
 			//
 			if (a.Type == b)
 				return true;
 
 			if (RootContext.Version == LanguageVersion.ISO_1)
 				return false;
 
 			return Convert.ImplicitReferenceConversionExists (a, b);
 		}
 
 		public static string FullDelegateDesc (MethodSpec invoke_method)
 		{
 			return TypeManager.GetFullNameSignature (invoke_method).Replace (".Invoke", "");
 		}
 		
 		public Expression InstanceExpression {
 			get {
 				return instance_expr;
 			}
 			set {
 				instance_expr = value;
 			}
 		}
 	}
 
 	//
 	// Base class for `NewDelegate' and `ImplicitDelegateCreation'
 	//
 	public abstract class DelegateCreation 
 	{
 		protected MethodSpec constructor_method;
 		protected MethodGroupExpr method_group;
 
 		public static Arguments CreateDelegateMethodArguments (AParametersCollection pd, TypeSpec[] types, Location loc)
 		{
 			Arguments delegate_arguments = new Arguments (pd.Count);
 			for (int i = 0; i < pd.Count; ++i) {
 				Argument.AType atype_modifier;
 				switch (pd.FixedParameters [i].ModFlags) {
 				case Parameter.Modifier.REF
 					atype_modifier = Argument.AType.Ref;
 					break;
 				case Parameter.Modifier.OUT
 					atype_modifier = Argument.AType.Out;
 					break;
 				default
 					atype_modifier = 0;
 					break;
 				}
 
 				delegate_arguments.Add (new Argument (new TypeExpression (types [i], loc), atype_modifier));
 			}
 			for (int i = 0; i < pd.Count; ++i) {
 				Argument.AType atype_modifier;
 				switch (pd.FixedParameters [i].ModFlags) {
 				case Parameter.Modifier.REF
 					atype_modifier = Argument.AType.Ref;
 					break;
 				case Parameter.Modifier.OUT
 					atype_modifier = Argument.AType.Out;
 					break;
 				default
 					atype_modifier = 0;
 					break;
 				}
 
 				delegate_arguments.Add (new Argument (new TypeExpression (types [i], loc), atype_modifier));
 			}
 
 			return delegate_arguments;
 		}
]]></clone_fragment>
<clone_fragment endline="1264" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" hamdist="4" pcid="5483" startline="786"><![CDATA[
 	}
 
 	public class Method 
 	{
 		Method partialMethodImplementation;
 
 		public Method (DeclSpace parent, GenericMethod generic,
 			       FullNamedExpression return_type, Modifiers mod,
 			       MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs, parameters)
 		{
 		}
 
 		protected Method (DeclSpace parent, FullNamedExpression return_type, Modifiers mod, Modifiers amod,
 					MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 		{
 		}
 
 		#region Properties
 
 		public override TypeParameter[] CurrentTypeParameters {
 			get {
 				if (GenericMethod != null)
 					return GenericMethod.CurrentTypeParameters;
 
 				return null;
 			}
 		}
 
 		public override bool HasUnresolvedConstraints {
 			get {
 				if (CurrentTypeParameters == null)
 					return false;
 
 				// When overriding base method constraints are fetched from
 				// base method but to find it we have to resolve parameters
 				// to find exact base method match
 				if (IsExplicitImpl || (ModFlags & Modifiers.OVERRIDE) != 0)
 					return base_method == null;
 
 				// Even for non-override generic method constraints check has to be
 				// delayed after all constraints are resolved
 				return true;
 			}
 		}
 
 		public TypeParameterSpec[] TypeParameters {
 			get {
 				// TODO
 				return CurrentTypeParameters.Select (l => l.Type).ToArray ();
 			}
 		}
 
 		public int TypeParametersCount {
 			get {
 				return CurrentTypeParameters == null ? 0 
 			}
 		}
 
 #endregion
 
 		public override string GetSignatureForError()
 		{
 			return base.GetSignatureForError () + parameters.GetSignatureForError ();
 		}
 
 		void Error_DuplicateEntryPoint (Method b)
 		{
 			Report.Error (17, b.Location,
 				"Program `{0}' has more than one entry point defined
 				b.Module.Builder.ScopeName, b.GetSignatureForError ());
 		}
 
 		bool IsEntryPoint ()
 		{
 			if (ReturnType != TypeManager.void_type &&
 				ReturnType != TypeManager.int32_type)
 				return false;
 
 			if (parameters.IsEmpty)
 				return true;
 
 			if (parameters.Count > 1)
 				return false;
 
 			var ac = parameters.Types [0] as ArrayContainer;
 			return ac != null && ac.Rank == 1 && ac.Element == TypeManager.string_type &&
 					(parameters[0].ModFlags & ~Parameter.Modifier.PARAMS) == Parameter.Modifier.NONE;
 		}
 
 		public override FullNamedExpression LookupNamespaceOrType (string name, int arity, Location loc, bool ignore_cs0104)
 		{
 			if (arity == 0) {
 				TypeParameter[] tp = CurrentTypeParameters;
 				if (tp != null) {
 					TypeParameter t = TypeParameter.FindTypeParameter (tp, name);
 					if (t != null)
 						return new TypeParameterExpr (t, loc);
 				}
 			}
 
 			return base.LookupNamespaceOrType (name, arity, loc, ignore_cs0104);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				if (IsExplicitImpl) {
 					Error_ConditionalAttributeIsNotValid ();
 					return;
 				}
 
 				if ((ModFlags & Modifiers.OVERRIDE) != 0) {
 					Report.Error (243, Location, "Conditional not valid on `{0}' because it is an override method", GetSignatureForError ());
 					return;
 				}
 
 				if (ReturnType != TypeManager.void_type) {
 					Report.Error (578, Location, "Conditional not valid on `{0}' because its return type is not void", GetSignatureForError ());
 					return;
 				}
 
 				if (IsInterface) {
 					Report.Error (582, Location, "Conditional not valid on interface members");
 					return;
 				}
 
 				if (MethodData.implementing != null) {
 					Report.SymbolRelatedToPreviousError (MethodData.implementing.DeclaringType);
 					Report.Error (629, Location, "Conditional member `{0}' cannot implement interface member `{1}'",
 						GetSignatureForError (), TypeManager.CSharpSignature (MethodData.implementing));
 					return;
 				}
 
 				for (int i = 0; i < parameters.Count; ++i) {
 					if (parameters.FixedParameters [i].ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (685, Location, "Conditional method `{0}' cannot have an out parameter", GetSignatureForError ());
 						return;
 					}
 				}
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		protected virtual void DefineTypeParameters ()
 		{
 			var tparams = CurrentTypeParameters;
 
 			TypeParameterSpec[] base_tparams = null;
 			TypeParameterSpec[] base_decl_tparams = TypeParameterSpec.EmptyTypes;
 			TypeSpec[] base_targs = TypeSpec.EmptyTypes;
 			if (((ModFlags & Modifiers.OVERRIDE) != 0 || IsExplicitImpl)) {
 				if (base_method != null) {
 					base_tparams = base_method.GenericDefinition.TypeParameters;
 				
 					if (base_method.DeclaringType.IsGeneric) {
 						base_decl_tparams = base_method.DeclaringType.MemberDefinition.TypeParameters;
 
 						var base_type_parent = CurrentType;
 						while (base_type_parent.BaseType != base_method.DeclaringType) {
 							base_type_parent = base_type_parent.BaseType;
 						}
 
 						base_targs = base_type_parent.BaseType.TypeArguments;
 					}
 
 					if (base_method.IsGeneric) {
 						ObsoleteAttribute oa;
 						foreach (var base_tp in base_tparams) {
 							oa = base_tp.BaseType.GetAttributeObsolete ();
 							if (oa != null) {
 								AttributeTester.Report_ObsoleteMessage (oa, base_tp.BaseType.GetSignatureForError (), Location, Report);
 							}
 
 							if (base_tp.InterfacesDefined != null) {
 								foreach (var iface in base_tp.InterfacesDefined) {
 									oa = iface.GetAttributeObsolete ();
 									if (oa != null) {
 										AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 									}
 								}
 							}
 						}
 
 						if (base_decl_tparams.Length != 0) {
 							base_decl_tparams = base_decl_tparams.Concat (base_tparams).ToArray ();
 							base_targs = base_targs.Concat (tparams.Select<TypeParameter, TypeSpec> (l => l.Type)).ToArray ();
 						} else {
 							base_decl_tparams = base_tparams;
 							base_targs = tparams.Select (l => l.Type).ToArray ();
 						}
 					}
 				} else if (MethodData.implementing != null) {
 					base_tparams = MethodData.implementing.GenericDefinition.TypeParameters;
 					if (MethodData.implementing.DeclaringType.IsGeneric) {
 						base_decl_tparams = MethodData.implementing.DeclaringType.MemberDefinition.TypeParameters;
 						foreach (var iface in Parent.CurrentType.Interfaces) {
 							if (iface == MethodData.implementing.DeclaringType) {
 								base_targs = iface.TypeArguments;
 								break;
 							}
 						}
 					}
 				}
 			}
 
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 
 				if (!tp.ResolveConstraints (this))
 					continue;
 
 				//
 				// Copy base constraints for override/explicit methods
 				//
 				if (base_tparams != null) {
 					var base_tparam = base_tparams[i];
 					var local_tparam = tp.Type;
 					local_tparam.SpecialConstraint = base_tparam.SpecialConstraint;
 
 					var inflator = new TypeParameterInflator (CurrentType, base_decl_tparams, base_targs);
 					base_tparam.InflateConstraints (inflator, local_tparam);
 
 					//
 					// Check all type argument constraints for possible collision
 					// introduced by inflating inherited constraints in this context
 					//
 					// Conflict example
 					//
 					// class A<T> { virtual void Foo<U> () where U 
 					// class B 
 					//
 					var local_tparam_targs = local_tparam.TypeArguments;
 					if (local_tparam_targs != null) {					
 						for (int ii = 0; ii < local_tparam_targs.Length; ++ii) {
 							var ta = local_tparam_targs [ii];
 							if (!ta.IsClass && !ta.IsStruct)
 								continue;
 
 							if (Constraints.CheckConflictingInheritedConstraint (local_tparam, ta, this, Location)) {
 								local_tparam.ChangeTypeArgumentToBaseType (ii);
 							}
 						}
 					}
 
 					continue;
 				}
 				
 				if (MethodData.implementing != null) {
 					var base_tp = MethodData.implementing.Constraints[i];
 					if (!tp.Type.HasSameConstraintsImplementation (base_tp)) {
 						Report.SymbolRelatedToPreviousError (MethodData.implementing);
 						Report.Error (425, Location,
 							"The constraints for type parameter `{0}' of method `{1}' must match the constraints for type parameter `{2}' of interface method `{3}'. Consider using an explicit interface implementation instead",
 							tp.GetSignatureForError (), GetSignatureForError (), base_tp.GetSignatureForError (), MethodData.implementing.GetSignatureForError ());
 					}
 				}
 			}
 		}
 
 		//
 		// Creates the type
 		//
 		public override bool Define ()
 		{
 			if (type_expr.Type == TypeManager.void_type && parameters.IsEmpty && MemberName.Arity == 0 && MemberName.Name == Destructor.MetadataName) {
 				Report.Warning (465, 1, Location, "Introducing `Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?");
 			}
 
 			if (!base.Define ())
 				return false;
 
 			if (partialMethodImplementation != null && IsPartialDefinition)
 				MethodBuilder = partialMethodImplementation.MethodBuilder;
 
 			if (RootContext.StdLib && TypeManager.IsSpecialType (ReturnType)) {
 				Error1599 (Location, ReturnType, Report);
 				return false;
 			}
 
 			if (CurrentTypeParameters == null) {
 				if (base_method != null) {
 					if (parameters.Count == 1 && ParameterTypes[0] == TypeManager.object_type && Name == "Equals")
 						Parent.PartialContainer.Mark_HasEquals ();
 					else if (parameters.IsEmpty && Name == "GetHashCode")
 						Parent.PartialContainer.Mark_HasGetHashCode ();
 				}
 					
 			} else {
 				DefineTypeParameters ();
 			}
 
 			if (block != null && block.IsIterator) {
 				//
 				// Current method is turned into automatically generated
 				// wrapper which creates an instance of iterator
 				//
 				Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 				ModFlags |= Modifiers.DEBUGGER_HIDDEN;
 			}
 
 			if ((ModFlags & Modifiers.STATIC) == 0)
 				return true;
 
 			if (parameters.HasExtensionMethodType) {
 				if (Parent.PartialContainer.IsStatic && !Parent.IsGeneric) {
 					if (!Parent.IsTopLevel)
 						Report.Error (1109, Location, "`{0}'
 							GetSignatureForError ());
 
 					PredefinedAttribute pa = Module.PredefinedAttributes.Extension;
 					if (!pa.IsDefined) {
 						Report.Error (1110, Location,
 							"`{0}'
 							GetSignatureForError ());
 					}
 
 					ModFlags |= Modifiers.METHOD_EXTENSION;
 					Parent.PartialContainer.ModFlags |= Modifiers.METHOD_EXTENSION;
 					Spec.DeclaringType.SetExtensionMethodContainer ();
 					Parent.Module.HasExtensionMethod = true;
 				} else {
 					Report.Error (1106, Location, "`{0}'
 						GetSignatureForError ());
 				}
 			}
 
 			//
 			// This is used to track the Entry Point,
 			//
 			if (RootContext.NeedsEntryPoint &&
 				Name == "Main" &&
 				(RootContext.MainClass == null ||
 				RootContext.MainClass == Parent.TypeBuilder.FullName)){
 				if (IsEntryPoint ()) {
 
 					if (Parent.DeclaringAssembly.EntryPoint == null) {
 						if (Parent.IsGeneric || MemberName.IsGeneric) {
 							Report.Warning (402, 4, Location, "`{0}'
 								GetSignatureForError ());
 						} else {
 							SetIsUsed ();
 							Parent.DeclaringAssembly.EntryPoint = this;
 						}
 					} else {
 						Error_DuplicateEntryPoint (Parent.DeclaringAssembly.EntryPoint);
 						Error_DuplicateEntryPoint (this);
 					}
 				} else {
 					Report.Warning (28, 4, Location, "`{0}' has the wrong signature to be an entry point",
 						GetSignatureForError ());
 				}
 			}
 
 			return true;
 		}
 
 		//
 		// Emits the code
 		// 
 		public override void Emit ()
 		{
 			try {
 				if (IsPartialDefinition) {
 					//
 					// Use partial method implementation builder for partial method declaration attributes
 					//
 					if (partialMethodImplementation != null) {
 						MethodBuilder = partialMethodImplementation.MethodBuilder;
 					}
 
 					return;
 				}
 				
 				if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.PartialDefinitionExists) == 0) {
 					Report.Error (759, Location, "A partial method `{0}' implementation is missing a partial method declaration",
 						GetSignatureForError ());
 				}
 
 				if (CurrentTypeParameters != null) {
 					var ge = type_expr as GenericTypeExpr;
 					if (ge != null)
 						ge.CheckConstraints (this);
 
 					foreach (Parameter p in parameters.FixedParameters) {
 						ge = p.TypeExpression as GenericTypeExpr;
 						if (ge != null)
 							ge.CheckConstraints (this);
 					}
 
 					for (int i = 0; i < CurrentTypeParameters.Length; ++i) {
 						var tp = CurrentTypeParameters [i];
 						tp.CheckGenericConstraints ();
 						tp.Emit ();
 					}
 				}
 
 				base.Emit ();
 				
 				if ((ModFlags & Modifiers.METHOD_EXTENSION) != 0)
 					Module.PredefinedAttributes.Extension.EmitAttribute (MethodBuilder);
 			} catch {
 				Console.WriteLine ("Internal compiler error at {0}
 						   Location, MethodBuilder);
 				throw;
 			}
 		}
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			// TODO
 			if (overload is Operator)
 				return overload.EnableOverloadChecks (this);
 
 			if (overload is Indexer)
 				return false;
 
 			return base.EnableOverloadChecks (overload);
 		}
 
 		public static void Error1599 (Location loc, TypeSpec t, Report Report)
 		{
 			Report.Error (1599, loc, "Method or delegate cannot return type `{0}'", TypeManager.CSharpName (t));
 		}
 
 		protected override bool ResolveMemberType ()
 		{
 			if (GenericMethod != null) {
 				MethodBuilder = Parent.TypeBuilder.DefineMethod (GetFullName (MemberName), flags);
 				if (!GenericMethod.Define (this))
 					return false;
 			}
 
 			return base.ResolveMemberType ();
 		}
 
 		public void SetPartialDefinition (Method methodDefinition)
 		{
 			caching_flags |= Flags.PartialDefinitionExists;
 			methodDefinition.partialMethodImplementation = this;
 
 			// Ensure we are always using method declaration parameters
 			for (int i = 0; i < methodDefinition.parameters.Count; ++i ) {
 				parameters [i].Name = methodDefinition.parameters [i].Name;
 				parameters [i].DefaultValue = methodDefinition.parameters [i].DefaultValue;
 			}
 
 			if (methodDefinition.attributes == null)
 				return;
 
 			if (attributes == null) {
 				attributes = methodDefinition.attributes;
 			} else {
 				attributes.Attrs.AddRange (methodDefinition.attributes.Attrs);
 			}
 		}
 	}
 
 	public abstract class ConstructorInitializer 
 	{
 		Arguments argument_list;
 		MethodSpec base_ctor;
 
 		public ConstructorInitializer (Arguments argument_list, Location loc)
 		{
 			this.argument_list = argument_list;
 			this.loc = loc;
 		}
]]></clone_fragment>
<clone_fragment endline="1185" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="6" pcid="4327" startline="718"><![CDATA[
 				switch (ExplicitTarget) {
 				case "return"
 				case "param"
 				case "field"
 				case "method"
 				case "property"
 				case "module"
 				}
 				throw new InternalErrorException ("Unknown explicit target
 			}
 				
 			StringBuilder sb = new StringBuilder ();
 			foreach (string s in valid_targets) {
 				sb.Append (s);
 				sb.Append (", ");
 			}
 			sb.Remove (sb.Length - 2, 2);
 			Report.Error (657, Location, "`{0}' is not a valid attribute location for this declaration. " +
 				"Valid attribute locations for this declaration are `{1}'", ExplicitTarget, sb.ToString ());
 			return false;
 		}
 
 		/// <summary>
 		/// Tests permitted SecurityAction for assembly or other types
 		/// </summary>
 		protected virtual bool IsSecurityActionValid (bool for_assembly)
 		{
 			SecurityAction action = GetSecurityActionValue ();
 
 			switch (action) {
 #pragma warning disable 618
 			case SecurityAction.Demand
 			case SecurityAction.Assert
 			case SecurityAction.Deny
 			case SecurityAction.PermitOnly
 			case SecurityAction.LinkDemand
 			case SecurityAction.InheritanceDemand
 				if (!for_assembly)
 					return true;
 				break;
 
 			case SecurityAction.RequestMinimum
 			case SecurityAction.RequestOptional
 			case SecurityAction.RequestRefuse
 				if (for_assembly)
 					return true;
 				break;
 #pragma warning restore 618
 
 			default
 				Error_AttributeEmitError ("SecurityAction is out of range");
 				return false;
 			}
 
 			Error_AttributeEmitError (String.Concat ("SecurityAction `", action, "' is not valid for this declaration"));
 			return false;
 		}
 
 		System.Security.Permissions.SecurityAction GetSecurityActionValue ()
 		{
 			return (SecurityAction) ((Constant) PosArguments[0].Expr).GetValue ();
 		}
 
 		/// <summary>
 		/// Creates instance of SecurityAttribute class and add result of CreatePermission method to permission table.
 		/// </summary>
 		/// <returns></returns>
 		public void ExtractSecurityPermissionSet (MethodSpec ctor, ref SecurityType permissions)
 		{
 #if STATIC
 			object[] values = new object [PosArguments.Count];
 			for (int i = 0; i < values.Length; ++i)
 				values [i] = ((Constant) PosArguments [i].Expr).GetValue ();
 
 			PropertyInfo[] prop;
 			object[] prop_values;
 			if (named_values == null) {
 				prop = null;
 				prop_values = null;
 			} else {
 				prop = new PropertyInfo[named_values.Count];
 				prop_values = new object [named_values.Count];
 				for (int i = 0; i < prop.Length; ++i) {
 					prop [i] = ((PropertyExpr) named_values [i].Key).PropertyInfo.MetaInfo;
 					prop_values [i] = ((Constant) named_values [i].Value.Expr).GetValue ();
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			var cab = new CustomAttributeBuilder ((ConstructorInfo) ctor.GetMetaInfo (), values, prop, prop_values);
 			permissions.Add (cab);
 #else
 			Type orig_assembly_type = null;
 
 			if (Type.MemberDefinition is TypeContainer) {
 				if (!RootContext.StdLib) {
 					orig_assembly_type = System.Type.GetType (Type.GetMetaInfo ().FullName);
 				} else {
 					string orig_version_path = Environment.GetEnvironmentVariable ("__SECURITY_BOOTSTRAP_DB");
 					if (orig_version_path == null) {
 						Error_AttributeEmitError ("security custom attributes can not be referenced from defining assembly");
 						return;
 					}
 
 					if (orig_sec_assembly == null) {
 						string file = Path.Combine (orig_version_path, Path.GetFileName (RootContext.OutputFile));
 						orig_sec_assembly = Assembly.LoadFile (file);
 					}
 
 					orig_assembly_type = orig_sec_assembly.GetType (Type.GetMetaInfo ().FullName, true);
 					if (orig_assembly_type == null) {
 						Report.Warning (-112, 1, Location, "Self-referenced security attribute `{0}' " +
 								"was not found in previous version of assembly");
 						return;
 					}
 				}
 			}
 
 			SecurityAttribute sa;
 			object[] args;
 
 			// For all non-selfreferencing security attributes we can avoid all hacks
 			if (orig_assembly_type == null) {
 				args = new object[PosArguments.Count];
 				for (int j = 0; j < args.Length; ++j) {
 					args[j] = ((Constant) PosArguments[j].Expr).GetValue ();
 				}
 
 				sa = (SecurityAttribute) Activator.CreateInstance (Type.GetMetaInfo (), args);
 
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						pi.SetValue (sa, ((Constant) named_values [i].Value.Expr).GetValue (), null);
 					}
 				}
 			} else {
 				// HACK
 				args = new object[] { GetSecurityActionValue () };
 				sa = (SecurityAttribute) Activator.CreateInstance (orig_assembly_type, args);
 
 				// All types are from newly created assembly but for invocation with old one we need to convert them
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo emited_pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						// FIXME
 						// TODO
 						PropertyInfo pi = orig_assembly_type.GetProperty (emited_pi.Name);
 
 						pi.SetValue (sa, ((Constant) named_values[i].Value.Expr).GetValue (), null);
 					}
 				}
 			}
 
 			IPermission perm;
 			perm = sa.CreatePermission ();
 			SecurityAction action = (SecurityAction) args [0];
 
 			// IS is correct because for corlib we are using an instance from old corlib
 			if (!(perm is System.Security.CodeAccessPermission)) {
 				switch (action) {
 				case SecurityAction.Demand
 					action = (SecurityAction)13;
 					break;
 				case SecurityAction.LinkDemand
 					action = (SecurityAction)14;
 					break;
 				case SecurityAction.InheritanceDemand
 					action = (SecurityAction)15;
 					break;
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			PermissionSet ps;
 			if (!permissions.TryGetValue (action, out ps)) {
 				if (sa is PermissionSetAttribute)
 					ps = new PermissionSet (sa.Unrestricted ? PermissionState.Unrestricted 
 				else
 					ps = new PermissionSet (PermissionState.None);
 
 				permissions.Add (action, ps);
 			} else if (!ps.IsUnrestricted () && (sa is PermissionSetAttribute) && sa.Unrestricted) {
 				ps = ps.Union (new PermissionSet (PermissionState.Unrestricted));
 				permissions [action] = ps;
 			}
 			ps.AddPermission (perm);
 #endif
 		}
 
 		public Constant GetNamedValue (string name)
 		{
 			if (named_values == null)
 				return null;
 
 			for (int i = 0; i < named_values.Count; ++i) {
 				if (named_values [i].Value.Name == name)
 					return named_values [i].Value.Expr as Constant;
 			}
 
 			return null;
 		}
 
 		public CharSet GetCharSetValue ()
 		{
 			return (CharSet)System.Enum.Parse (typeof (CharSet), ((Constant) PosArguments [0].Expr).GetValue ().ToString ());
 		}
 
 		public bool HasField (string fieldName)
 		{
 			if (named_values == null)
 				return false;
 
 			foreach (var na in named_values) {
 				if (na.Value.Name == fieldName)
 					return true;
 			}
 
 			return false;
 		}
 
 		//
 		// Returns true for MethodImplAttribute with MethodImplOptions.InternalCall value
 		// 
 		public bool IsInternalCall ()
 		{
 			MethodImplOptions options = 0;
 			if (PosArguments.Count == 1) {
 				options = (MethodImplOptions) System.Enum.Parse (typeof (MethodImplOptions), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 			} else if (HasField ("Value")) {
 				var named = GetNamedValue ("Value");
 				options = (MethodImplOptions) System.Enum.Parse (typeof (MethodImplOptions), named.GetValue ().ToString ());
 			}
 
 			return (options & MethodImplOptions.InternalCall) != 0;
 		}
 
 		//
 		// Returns true for StructLayoutAttribute with LayoutKind.Explicit value
 		// 
 		public bool IsExplicitLayoutKind ()
 		{
 			if (PosArguments == null || PosArguments.Count != 1)
 				return false;
 
 			var value = (LayoutKind) System.Enum.Parse (typeof (LayoutKind), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 			return value == LayoutKind.Explicit;
 		}
 
 		public Expression GetParameterDefaultValue ()
 		{
 			if (PosArguments == null)
 				return null;
 
 			return PosArguments[0].Expr;
 		}
 
 		public override bool Equals (object obj)
 		{
 			Attribute a = obj as Attribute;
 			if (a == null)
 				return false;
 
 			return Type == a.Type && Target == a.Target;
 		}
 
 		public override int GetHashCode ()
 		{
 			return type.GetHashCode () ^ Target.GetHashCode ();
 		}
 
 		/// <summary>
 		/// Emit attribute for Attributable symbol
 		/// </summary>
 		public void Emit (Dictionary<Attribute, List<Attribute>> allEmitted)
 		{
 			var ctor = Resolve ();
 			if (ctor == null)
 				return;
 
 			var predefined = context.Module.PredefinedAttributes;
 
 			AttributeUsageAttribute usage_attr = Type.GetAttributeUsage (predefined.AttributeUsage);
 			if ((usage_attr.ValidOn & Target) == 0) {
 				Report.Error (592, Location, "The attribute `{0}' is not valid on this declaration type. " +
 					      "It is valid on `{1}' declarations only",
 					GetSignatureForError (), GetValidTargets ());
 				return;
 			}
 
 			byte[] cdata;
 			if (PosArguments == null && named_values == null) {
 				cdata = AttributeEncoder.Empty;
 			} else {
 				AttributeEncoder encoder = new AttributeEncoder ();
 
 				if (PosArguments != null) {
 					var param_types = ctor.Parameters.Types;
 					for (int j = 0; j < PosArguments.Count; ++j) {
 						var pt = param_types[j];
 						var arg_expr = PosArguments[j].Expr;
 						if (j == 0) {
 							if (Type == predefined.IndexerName || Type == predefined.Conditional) {
 								string v = ((StringConstant) arg_expr).Value;
 								if (!Tokenizer.IsValidIdentifier (v) || Tokenizer.IsKeyword (v)) {
 									context.Compiler.Report.Error (633, arg_expr.Location,
 										"The argument to the `{0}' attribute must be a valid identifier", GetSignatureForError ());
 								}
 							} else if (Type == predefined.Guid) {
 								try {
 									string v = ((StringConstant) arg_expr).Value;
 									new Guid (v);
 								} catch (Exception e) {
 									Error_AttributeEmitError (e.Message);
 									return;
 								}
 							} else if (Type == predefined.AttributeUsage) {
 								int v = ((IntConstant) ((EnumConstant) arg_expr).Child).Value;
 								if (v == 0) {
 									context.Compiler.Report.Error (591, Location, "Invalid value for argument to `{0}' attribute",
 										"System.AttributeUsage");
 								}
 							} else if (Type == predefined.MarshalAs) {
 								if (PosArguments.Count == 1) {
 									var u_type = (UnmanagedType) System.Enum.Parse (typeof (UnmanagedType), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 									if (u_type == UnmanagedType.ByValArray && !(Owner is FieldBase)) {
 										Error_AttributeEmitError ("Specified unmanaged type is only valid on fields");
 									}
 								}
 							} else if (Type == predefined.DllImport) {
 								if (PosArguments.Count == 1) {
 									var value = ((Constant) PosArguments[0].Expr).GetValue () as string;
 									if (string.IsNullOrEmpty (value))
 										Error_AttributeEmitError ("DllName cannot be empty");
 								}
 							} else if (Type == predefined.MethodImpl && pt == TypeManager.short_type &&
 								!System.Enum.IsDefined (typeof (MethodImplOptions), ((Constant) arg_expr).GetValue ().ToString ())) {
 								Error_AttributeEmitError ("Incorrect argument value.");
 								return;
 							}
 						}
 
 						arg_expr.EncodeAttributeValue (context, encoder, pt);
 					}
 				}
 
 				if (named_values != null) {
 					encoder.Encode ((ushort) named_values.Count);
 					foreach (var na in named_values) {
 						if (na.Key is FieldExpr)
 							encoder.Encode ((byte) 0x53);
 						else
 							encoder.Encode ((byte) 0x54);
 
 						encoder.Encode (na.Key.Type);
 						encoder.Encode (na.Value.Name);
 						na.Value.Expr.EncodeAttributeValue (context, encoder, na.Key.Type);
 					}
 				} else {
 					encoder.EncodeEmptyNamedArguments ();
 				}
 
 				cdata = encoder.ToArray ();
 			}
 
 			try {
 				foreach (Attributable target in targets)
 					target.ApplyAttributeBuilder (this, ctor, cdata, predefined);
 			} catch (Exception e) {
 				Error_AttributeEmitError (e.Message);
 				return;
 			}
 
 			if (!usage_attr.AllowMultiple && allEmitted != null) {
 				if (allEmitted.ContainsKey (this)) {
 					var a = allEmitted [this];
 					if (a == null) {
 						a = new List<Attribute> (2);
 						allEmitted [this] = a;
 					}
 					a.Add (this);
 				} else {
 					allEmitted.Add (this, null);
 				}
 			}
 
 			if (!RootContext.VerifyClsCompliance)
 				return;
 
 			// Here we are testing attribute arguments for array usage (error 3016)
 			if (Owner.IsClsComplianceRequired ()) {
 				if (PosArguments != null)
 					PosArguments.CheckArrayAsAttribute (context.Compiler);
 			
 				if (NamedArguments == null)
 					return;
 
 				NamedArguments.CheckArrayAsAttribute (context.Compiler);
 			}
 		}
 
 		private Expression GetValue () 
 		{
 			if (PosArguments == null || PosArguments.Count < 1)
 				return null;
 
 			return PosArguments [0].Expr;
 		}
 
 		public string GetString () 
 		{
 			Expression e = GetValue ();
 			if (e is StringConstant)
 				return ((StringConstant)e).Value;
 			return null;
 		}
 
 		public bool GetBoolean () 
 		{
 			Expression e = GetValue ();
 			if (e is BoolConstant)
 				return ((BoolConstant)e).Value;
 			return false;
 		}
 
 		public TypeSpec GetArgumentType ()
 		{
 			TypeOf e = GetValue () as TypeOf;
 			if (e == null)
 				return null;
 			return e.TypeArgument;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			throw new NotSupportedException ("ET");
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			throw new NotImplementedException ();
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			throw new NotImplementedException ();
 		}
 	}
 	
 
 	/// <summary>
 	/// For global attributes (assembly, module) we need special handling.
 	/// Attributes can be located in the several files
 	/// </summary>
 	public class GlobalAttribute 
 	{
 		public readonly NamespaceEntry ns;
 
 		public GlobalAttribute (NamespaceEntry ns, string target, ATypeNameExpression expression,
 					Arguments[] args, Location loc, bool nameEscaped)
 			base (target, expression, args, loc, nameEscaped)
 		{
 			this.ns = ns;
 		}
]]></clone_fragment>
<clone_fragment endline="503" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" hamdist="3" pcid="107" startline="35"><![CDATA[
 
 #if !STATIC
 		// Reflection Emit hacking
 		static readonly Type TypeBuilder;
 		static readonly Type GenericTypeBuilder;
 
 		static TypeSpec ()
 		{
 			var assembly = typeof (object).Assembly;
 			TypeBuilder = assembly.GetType ("System.Reflection.Emit.TypeBuilder");
 			GenericTypeBuilder = assembly.GetType ("System.Reflection.MonoGenericClass");
 			if (GenericTypeBuilder == null)
 				GenericTypeBuilder = assembly.GetType ("System.Reflection.Emit.TypeBuilderInstantiation");
 		}
 #endif
 
 		public TypeSpec (MemberKind kind, TypeSpec declaringType, ITypeDefinition definition, MetaType info, Modifiers modifiers)
 			
 		{
 			this.declaringType = declaringType;
 			this.info = info;
 
 			if (definition != null && definition.TypeParametersCount > 0)
 				state |= StateFlags.IsGeneric;
 		}
 
 		#region Properties
 
 		public override int Arity {
 			get {
 				return MemberDefinition.TypeParametersCount;
 			}
 		}
 
 		public virtual TypeSpec BaseType {
 			get {
 				return base_type;
 			}
 			set {
 				base_type = value;
 			}
 		}
 
 		public virtual BuildinTypeSpec.Type BuildinType {
 			get {
 				return BuildinTypeSpec.Type.None;
 			}
 		}
 
 		public bool HasDynamicElement {
 			get {
 				return (state & StateFlags.HasDynamicElement) != 0;
 			}
 		}
 
 		public virtual IList<TypeSpec> Interfaces {
 			get {
 				return ifaces;
 			}
 			set {
 				ifaces = value;
 			}
 		}
 
 		public bool IsArray {
 			get {
 				return Kind == MemberKind.ArrayType;
 			}
 		}
 
 		public bool IsAttribute {
 			get {
 				if (!IsClass)
 					return false;
 
 				var type = this;
 				do {
 					if (type.IsGeneric)
 						return false;
 
 					if (type == TypeManager.attribute_type)
 						return true;
 					
 					type = type.base_type;
 				} while (type != null);
 
 				return false;
 			}
 		}
 
 		public bool IsInterface {
 			get {
 				return Kind == MemberKind.Interface;
 			}
 		}
 
 		public bool IsClass {
 			get {
 				return Kind == MemberKind.Class;
 			}
 		}
 
 		public bool IsConstantCompatible {
 			get {
 				if ((Kind & (MemberKind.Enum | MemberKind.Class | MemberKind.Interface | MemberKind.Delegate | MemberKind.ArrayType)) != 0)
 					return true;
 
 				return TypeManager.IsPrimitiveType (this) || this == TypeManager.decimal_type || this == InternalType.Dynamic;
 			}
 		}
 
 		public bool IsDelegate {
 			get {
 				return Kind == MemberKind.Delegate;
 			}
 		}
 
 		public bool IsEnum {
 			get { return Kind == MemberKind.Enum; }
 		}
 
 		// TODO
 		// IsGenericType -- recursive
 		// HasTypeParameter -- non-recursive
 		public bool IsGenericOrParentIsGeneric {
 			get {
 				var ts = this;
 				do {
 					if (ts.IsGeneric)
 						return true;
 					ts = ts.declaringType;
 				} while (ts != null);
 
 				return false;
 			}
 		}
 
 		public bool IsGenericParameter {
 			get { return Kind == MemberKind.TypeParameter; }
 		}
 
 		public bool IsNested {
 			get { return declaringType != null && Kind != MemberKind.TypeParameter; }
 		}
 
 		public bool IsPointer {
 			get {
 				return Kind == MemberKind.PointerType;
 			}
 		}
 
 		public bool IsSealed {
 			get { return (Modifiers & Modifiers.SEALED) != 0; }
 		}
 
 		public bool IsStruct {
 			get { 
 				return Kind == MemberKind.Struct;
 			}
 		}
 
 		public bool IsTypeBuilder {
 			get {
 #if STATIC
 				return true;
 #else
 				var meta = GetMetaInfo().GetType ();
 				return meta == TypeBuilder || meta == GenericTypeBuilder;
 #endif
 			}
 		}
 
 		public MemberCache MemberCache {
 			get {
 				if (cache == null || (state & StateFlags.PendingMemberCacheMembers) != 0)
 					InitializeMemberCache (false);
 
 				return cache;
 			}
 			set {
 				if (cache != null)
 					throw new InternalErrorException ("Membercache reset");
 
 				cache = value;
 			}
 		}
 
 		public MemberCache MemberCacheTypes {
 			get {
 				if (cache == null)
 					InitializeMemberCache (true);
 
 				return cache;
 			}
 		}	
 
 		public new ITypeDefinition MemberDefinition {
 			get {
 				return (ITypeDefinition) definition;
 			}
 		}
 
 		// TODO
 		// remove the property, YES IT WOULD !!!
 		public virtual TypeSpec[] TypeArguments {
 			get { return TypeSpec.EmptyTypes; }
 		}
 
 		#endregion
 
 		public bool AddInterface (TypeSpec iface)
 		{
 			if ((state & StateFlags.InterfacesExpanded) != 0)
 				throw new InternalErrorException ("Modifying expanded interface list");
 
 			if (ifaces == null) {
 				ifaces = new List<TypeSpec> () { iface };
 				return true;
 			}
 
 			if (!ifaces.Contains (iface)) {
 				ifaces.Add (iface);
 				return true;
 			}
 
 			return false;
 		}
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			if (Kind != MemberKind.Class)
 				throw new InternalErrorException ();
 
 			if (!pa.IsDefined)
 				return Attribute.DefaultUsageAttribute;
 
 			AttributeUsageAttribute aua = null;
 			var type = this;
 			while (type != null) {
 				aua = type.MemberDefinition.GetAttributeUsage (pa);
 				if (aua != null)
 					break;
 
 				type = type.BaseType;
 			}
 
 			return aua;
 		}
 
 		public virtual MetaType GetMetaInfo ()
 		{
 			return info;
 		}
 
 		public virtual TypeSpec GetDefinition ()
 		{
 			return this;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			string s;
 
 			if (IsNested) {
 				s = DeclaringType.GetSignatureForError ();
 			} else if (MemberDefinition is AnonymousTypeClass) {
 				return ((AnonymousTypeClass) MemberDefinition).GetSignatureForError ();
 			} else {
 				s = MemberDefinition.Namespace;
 			}
 
 			if (!string.IsNullOrEmpty (s))
 				s += ".";
 
 			return s + Name + GetTypeNameSignature ();
 		}
 
 		protected virtual string GetTypeNameSignature ()
 		{
 			if (!IsGeneric)
 				return null;
 
 			return "<" + TypeManager.CSharpName (MemberDefinition.TypeParameters) + ">";
 		}
 
 		public bool ImplementsInterface (TypeSpec iface, bool variantly)
 		{
 			var t = this;
 			do {
 				if (t.Interfaces != null) {	// TODO
 					foreach (TypeSpec i in t.Interfaces) {
 						if (i == iface || TypeSpecComparer.IsEqual (i, iface))
 							return true;
 
 						if (variantly && TypeSpecComparer.Variant.IsEqual (i, iface))
 							return true;
 					}
 				}
 
 				t = t.BaseType;
 			} while (t != null);
 
 			return false;
 		}
 
 		protected virtual void InitializeMemberCache (bool onlyTypes)
 		{
 			MemberDefinition.LoadMembers (this, onlyTypes, ref cache);
 
 			if (onlyTypes)
 				state |= StateFlags.PendingMemberCacheMembers;
 			else
 				state &= ~StateFlags.PendingMemberCacheMembers;
 		}
 
 		//
 		// Is @baseClass base implementation of @type. With enabled @dynamicIsEqual the slower
 		// comparison is used to hide differences between `object' and `dynamic' for generic
 		// types. Should not be used for comparisons where G<object> != G<dynamic>
 		//
 		public static bool IsBaseClass (TypeSpec type, TypeSpec baseClass, bool dynamicIsObject)
 		{
 			if (dynamicIsObject && baseClass.IsGeneric) {
 				//
 				// Returns true for a hierarchies like this when passing baseClass of A<dynamic>
 				//
 				// class B 
 				//
 				while (type != null) {
 					type = type.BaseType;
 					if (TypeSpecComparer.IsEqual (type, baseClass))
 						return true;
 				}
 
 				return false;
 			}
 
 			while (type != null) {
 				type = type.BaseType;
 				if (type == baseClass)
 					return true;
 			}
 
 			return false;
 		}
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var targs = IsGeneric ? MemberDefinition.TypeParameters 
 
 			//
 			// When inflating nested type from inside the type instance will be same
 			// because type parameters are same for all nested types
 			//
 			if (DeclaringType == inflator.TypeInstance) {
 				return MakeGenericType (targs);
 			}
 
 			return new InflatedTypeSpec (this, inflator.TypeInstance, targs);
 		}
 
 		public InflatedTypeSpec MakeGenericType (TypeSpec[] targs)
 		{
 			if (targs.Length == 0 && !IsNested)
 				throw new ArgumentException ("Empty type arguments for type " + GetSignatureForError ());
 
 			InflatedTypeSpec instance;
 
 			if (inflated_instances == null) {
 				inflated_instances = new Dictionary<TypeSpec[], InflatedTypeSpec> (TypeSpecComparer.Default);
 
 				if (IsNested) {
 					instance = this as InflatedTypeSpec;
 					if (instance != null) {
 						//
 						// Nested types could be inflated on already inflated instances
 						// Caching this type ensured we are using same instance for
 						// inside/outside inflation using local type parameters
 						//
 						inflated_instances.Add (TypeArguments, instance);
 					}
 				}
 			}
 
 			if (!inflated_instances.TryGetValue (targs, out instance)) {
 				if (GetDefinition () != this && !IsNested)
 					throw new InternalErrorException ("`{0}' must be type definition or nested non-inflated type to MakeGenericType",
 						GetSignatureForError ());
 
 				instance = new InflatedTypeSpec (this, declaringType, targs);
 				inflated_instances.Add (targs, instance);
 			}
 
 			return instance;
 		}
 
 		public virtual TypeSpec Mutate (TypeParameterMutator mutator)
 		{
 			return this;
 		}
 
 		public void SetMetaInfo (MetaType info)
 		{
 			if (this.info != null)
 				throw new InternalErrorException ("MetaInfo reset");
 
 			this.info = info;
 		}
 
 		public void SetExtensionMethodContainer ()
 		{
 			modifiers |= Modifiers.METHOD_EXTENSION;
 		}
 	}
 
 	public sealed class BuildinTypeSpec 
 	{
 		public enum Type
 		{
 			None = 0,
 
 			// TODO
 			Object,
 			ValueType,
 			Attribute,
 			Int,
 			UInt,
 			Long,
 			ULong,
 			Float,
 			Double,
 			Char,
 			Short,
 			Decimal,
 			Bool,
 			SByte,
 			Byte,
 			UShort,
 			String,
 			Enum,
 			Delegate,
 			MulticastDelegate,
 			Void,
 			Array,
 			Type,
 			IEnumerator,
 			IEnumerable,
 			IDisposable,
 			IntPtr,
 			UIntPtr,
 			RuntimeFieldHandle,
 			RuntimeTypeHandle,
 			Exception,
 
 			Null,
 			Dynamic
 		}
 
 		readonly Type type;
 		readonly string ns;
 		readonly string name;
 
 		public BuildinTypeSpec (MemberKind kind, string ns, string name, Type buildinKind)
 			
 		{
 			this.type = buildinKind;
 			this.ns = ns;
 			this.name = name;
 		}
]]></clone_fragment>
<clone_fragment endline="7928" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="3" pcid="4981" startline="7471"><![CDATA[
 
 		public QualifiedAliasMember (string alias, string identifier, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public QualifiedAliasMember (string alias, string identifier, TypeArguments targs, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public QualifiedAliasMember (string alias, string identifier, int arity, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			if (alias == GlobalAlias) {
 				expr = ec.Module.GlobalRootNamespace;
 				return base.ResolveAsTypeStep (ec, silent);
 			}
 
 			int errors = ec.Compiler.Report.Errors;
 			expr = ec.LookupNamespaceAlias (alias);
 			if (expr == null) {
 				if (errors == ec.Compiler.Report.Errors)
 					ec.Compiler.Report.Error (432, loc, "Alias `{0}' not found", alias);
 				return null;
 			}
 
 			FullNamedExpression fne = base.ResolveAsTypeStep (ec, silent);
 			if (fne == null)
 				return null;
 
 			if (expr.eclass == ExprClass.Type) {
 				if (!silent) {
 					ec.Compiler.Report.Error (431, loc,
 						"Alias `{0}' cannot be used with '
 				}
 				return null;
 			}
 
 			return fne;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return ResolveAsTypeStep (ec, false);
 		}
 
 		protected override void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			rc.Compiler.Report.Error (687, loc,
 				"A namespace alias qualifier `{0}' did not resolve to a namespace or a type",
 				GetSignatureForError ());
 		}
 
 		public override string GetSignatureForError ()
 		{
 			string name = Name;
 			if (targs != null) {
 				name = Name + "<" + targs.GetSignatureForError () + ">";
 			}
 
 			return alias + "
 		}
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			return DoResolve (rc);
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			// Nothing 
 		}
 	}
 
 	/// <summary>
 	///   Implements the member access expression
 	/// </summary>
 	public class MemberAccess 
 	{
 		protected Expression expr;
 
 		public MemberAccess (Expression expr, string id)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, TypeArguments args, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, int arity, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public Expression LeftExpression {
 			get {
 				return expr;
 			}
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return DoResolveName (ec, null);
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			return DoResolveName (ec, right_side);
 		}
 
 		Expression DoResolveName (ResolveContext rc, Expression right_side)
 		{
 			Expression e = LookupNameExpression (rc, right_side == null ? MemberLookupRestrictions.ReadAccess 
 			if (e == null)
 				return null;
 
 			if (right_side != null) {
 				if (e is TypeExpr) {
 					e.Error_UnexpectedKind (rc, ResolveFlags.VariableOrValue, loc);
 					return null;
 				}
 
 				e = e.ResolveLValue (rc, right_side);
 			} else {
 				e = e.Resolve (rc, ResolveFlags.VariableOrValue | ResolveFlags.Type);
 			}
 
 			return e;
 		}
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			var sn = expr as SimpleName;
 			const ResolveFlags flags = ResolveFlags.VariableOrValue | ResolveFlags.Type;
 
 			//
 			// Resolve the expression with flow analysis turned off, we'll do the definite
 			// assignment checks later.  This is because we don't know yet what the expression
 			// will resolve to - it may resolve to a FieldExpr and in this case we must do the
 			// definite assignment check on the actual field and not on the whole struct.
 			//
 			using (rc.Set (ResolveContext.Options.OmitStructFlowAnalysis)) {
 				if (sn != null) {
 					expr = sn.LookupNameExpression (rc, MemberLookupRestrictions.ReadAccess | MemberLookupRestrictions.ExactArity);
 
 					// Call resolve on expression which does have type set as we need expression type
 					// TODO
 					if (expr is VariableReference || expr is ConstantExpr || expr is Linq.TransparentMemberAccess) {
 						using (rc.With (ResolveContext.Options.DoFlowAnalysis, false)) {
 							expr = expr.Resolve (rc);
 						}
 					} else if (expr is TypeParameterExpr) {
 						expr.Error_UnexpectedKind (rc, flags, sn.Location);
 						expr = null;
 					}
 				} else {
 					expr = expr.Resolve (rc, flags);
 				}
 			}
 
 			if (expr == null)
 				return null;
 
 			Namespace ns = expr as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 					return null;
 				}
 
 				if (HasTypeArguments)
 					return new GenericTypeExpr (retval.Type, targs, loc);
 
 				return retval;
 			}
 
 			MemberExpr me;
 			TypeSpec expr_type = expr.Type;
 			if (expr_type == InternalType.Dynamic) {
 				me = expr as MemberExpr;
 				if (me != null)
 					me.ResolveInstanceExpression (rc, null);
 
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return new DynamicMemberBinder (Name, args, loc);
 			}
 
 			const MemberKind dot_kinds = MemberKind.Class | MemberKind.Struct | MemberKind.Delegate | MemberKind.Enum |
 				MemberKind.Interface | MemberKind.TypeParameter | MemberKind.ArrayType;
 
 			if ((expr_type.Kind & dot_kinds) == 0 || expr_type == TypeManager.void_type) {
 				if (expr_type == InternalType.Null && rc.Compiler.IsRuntimeBinder)
 					rc.Report.Error (Report.RuntimeErrorId, loc, "Cannot perform member binding on `null' value");
 				else
 					Unary.Error_OperatorCannotBeApplied (rc, loc, ".", expr_type);
 				return null;
 			}
 
 			var current_type = rc.CurrentType;
 			var lookup_arity = Arity;
 			bool errorMode = false;
 			Expression member_lookup;
 			while (true) {
 				member_lookup = MemberLookup (errorMode ? null 
 				if (member_lookup == null) {
 					//
 					// Try to look for extension method when member lookup failed
 					//
 					if (MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 						NamespaceEntry scope = null;
 						var methods = rc.LookupExtensionMethod (expr_type, Name, lookup_arity, ref scope);
 						if (methods != null) {
 							var emg = new ExtensionMethodGroupExpr (methods, scope, expr, loc);
 							if (HasTypeArguments) {
 								if (!targs.Resolve (rc))
 									return null;
 
 								emg.SetTypeArguments (rc, targs);
 							}
 
 							// TODO
 							return emg.Resolve (rc);
 						}
 					}
 				}
 
 				if (errorMode) {
 					if (member_lookup == null) {
 						if (expr is TypeExpr)
 							base.Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 						else
 							Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 
 						return null;
 					}
 
 					if (member_lookup is MethodGroupExpr) {
 						// Leave it to overload resolution to report correct error
 					} else {
 						// TODO
 						ErrorIsInaccesible (rc, member_lookup.GetSignatureForError (), loc);
 					}
 					break;
 				}
 
 				if (member_lookup != null)
 					break;
 
 				current_type = null;
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 
 			TypeExpr texpr = member_lookup as TypeExpr;
 			if (texpr != null) {
 				if (!(expr is TypeExpr)) {
 					me = expr as MemberExpr;
 					if (me == null || me.ProbeIdenticalTypeName (rc, expr, sn) == expr) {
 						rc.Report.Error (572, loc, "`{0}'
 							Name, member_lookup.GetSignatureForError ());
 						return null;
 					}
 				}
 
 				if (!texpr.Type.IsAccessible (rc.CurrentType)) {
 					rc.Report.SymbolRelatedToPreviousError (member_lookup.Type);
 					ErrorIsInaccesible (rc, member_lookup.Type.GetSignatureForError (), loc);
 					return null;
 				}
 
 				if (HasTypeArguments) {
 					return new GenericTypeExpr (member_lookup.Type, targs, loc);
 				}
 
 				return member_lookup;
 			}
 
 			me = member_lookup as MemberExpr;
 
 			if (sn != null && me.IsStatic)
 				expr = me.ProbeIdenticalTypeName (rc, expr, sn);
 
 			me = me.ResolveMemberAccess (rc, expr, sn);
 
 			if (Arity > 0) {
 				if (!targs.Resolve (rc))
 					return null;
 
 				me.SetTypeArguments (rc, targs);
 			}
 
 			if (sn != null && (!TypeManager.IsValueType (expr_type) || me is PropertyExpr)) {
 				if (me.IsInstance) {
 					LocalVariableReference var = expr as LocalVariableReference;
 					if (var != null && !var.VerifyAssigned (rc))
 						return null;
 				}
 			}
 
 			return me;
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			return ResolveNamespaceOrType (ec, silent);
 		}
 
 		public FullNamedExpression ResolveNamespaceOrType (IMemberContext rc, bool silent)
 		{
 			FullNamedExpression expr_resolved = expr.ResolveAsTypeStep (rc, silent);
 
 			if (expr_resolved == null)
 				return null;
 
 			Namespace ns = expr_resolved as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					if (!silent)
 						ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 				} else if (HasTypeArguments) {
 					retval = new GenericTypeExpr (retval.Type, targs, loc).ResolveAsTypeStep (rc, silent);
 				}
 
 				return retval;
 			}
 
 			TypeExpr tnew_expr = expr_resolved.ResolveAsTypeTerminal (rc, false);
 			if (tnew_expr == null)
 				return null;
 
 			TypeSpec expr_type = tnew_expr.Type;
 			if (TypeManager.IsGenericParameter (expr_type)) {
 				rc.Compiler.Report.Error (704, loc, "A nested type cannot be specified through a type parameter `{0}'",
 					tnew_expr.GetSignatureForError ());
 				return null;
 			}
 
 			TypeSpec nested = null;
 			while (expr_type != null) {
 				nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 				if (nested == null) {
 					if (silent)
 						return null;
 
 					if (expr_type == tnew_expr.Type) {
 						Error_IdentifierNotFound (rc, expr_type, Name);
 						return null;
 					}
 
 					expr_type = tnew_expr.Type;
 					nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 					ErrorIsInaccesible (rc, nested.GetSignatureForError (), loc);
 					break;
 				}
 
 				if (nested.IsAccessible (rc.CurrentType))
 					break;
 
 				// Keep looking after inaccessible candidate
 				expr_type = nested.DeclaringType.BaseType;
 			}
 			
 			TypeExpr texpr;
 			if (Arity > 0) {
 				if (HasTypeArguments) {
 					texpr = new GenericTypeExpr (nested, targs, loc);
 				} else {
 					texpr = new GenericOpenTypeExpr (nested, loc);
 				}
 			} else {
 				texpr = new TypeExpression (nested, loc);
 			}
 
 			return texpr.ResolveAsTypeStep (rc, false);
 		}
 
 		protected virtual void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			var nested = MemberCache.FindNestedType (expr_type, Name, -System.Math.Max (1, Arity));
 
 			if (nested != null) {
 				Error_TypeArgumentsCannotBeUsed (rc.Compiler.Report, expr.Location, nested, Arity);
 				return;
 			}
 
 			var any_other_member = MemberLookup (null, rc.CurrentType, expr_type, Name, 0, MemberLookupRestrictions.None, loc);
 			if (any_other_member != null) {
 				any_other_member.Error_UnexpectedKind (rc.Compiler.Report, null, "type", loc);
 				return;
 			}
 
 			rc.Compiler.Report.Error (426, loc, "The nested type `{0}' does not exist in the type `{1}'",
 				Name, expr_type.GetSignatureForError ());
 		}
 
 		protected override void Error_TypeDoesNotContainDefinition (ResolveContext ec, TypeSpec type, string name)
 		{
 			if (RootContext.Version > LanguageVersion.ISO_2 && !ec.Compiler.IsRuntimeBinder && MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 				ec.Report.SymbolRelatedToPreviousError (type);
 				ec.Report.Error (1061, loc,
 					"Type `{0}' does not contain a definition for `{1}' and no extension method `{1}' of type `{0}' could be found (are you missing a using directive or an assembly reference?)",
 					type.GetSignatureForError (), name);
 				return;
 			}
 
 			base.Error_TypeDoesNotContainDefinition (ec, type, name);
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return expr.GetSignatureForError () + "." + base.GetSignatureForError ();
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			MemberAccess target = (MemberAccess) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
 	}
 
 	/// <summary>
 	///   Implements checked expressions
 	/// </summary>
 	public class CheckedExpr 
 
 		public Expression Expr;
 
 		public CheckedExpr (Expression e, Location l)
 		{
 			Expr = e;
 			loc = l;
 		}
]]></clone_fragment>
<clone_fragment endline="695" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" hamdist="3" pcid="5815" startline="192"><![CDATA[
 	}
 
 	public interface IParameterData
 	{
 		Expression DefaultValue { get; }
 		bool HasExtensionMethodModifier { get; }
 		bool HasDefaultValue { get; }
 		Parameter.Modifier ModFlags { get; }
 		string Name { get; }
 	}
 
 	//
 	// Parameter information created by parser
 	//
 	public class Parameter 
 	{
 		[Flags]
 		public enum Modifier 
 			NONE    = 0,
 			REF     = REFMASK | ISBYREF,
 			OUT     = OUTMASK | ISBYREF,
 			PARAMS  = 4,
 			// This is a flag which says that it's either REF or OUT.
 			ISBYREF = 8,
 			REFMASK	= 32,
 			OUTMASK = 64,
 			This	= 128
 		}
 
 		static string[] attribute_targets = new string [] { "param" };
 
 		FullNamedExpression texpr;
 		readonly Modifier modFlags;
 		string name;
 		Expression default_expr;
 		protected TypeSpec parameter_type;
 		readonly Location loc;
 		protected int idx;
 		public bool HasAddressTaken;
 
 		TemporaryVariableReference expr_tree_variable;
 		static TypeExpr parameter_expr_tree_type;
 
 		HoistedVariable hoisted_variant;
 
 		public Parameter (FullNamedExpression type, string name, Modifier mod, Attributes attrs, Location loc)
 		{
 			this.name = name;
 			modFlags = mod;
 			this.loc = loc;
 			texpr = type;
 
 			// Only assign, attributes will be attached during resolve
 			base.attributes = attrs;
 		}
 
 		#region Properties
 
 		public DefaultParameterValueExpression DefaultValue {
 			get {
 				return default_expr as DefaultParameterValueExpression;
 			}
 			set {
 				default_expr = value;
 			}
 		}
 
 		Expression IParameterData.DefaultValue {
 			get {
 				var expr = default_expr as DefaultParameterValueExpression;
 				return expr == null ? default_expr 
 			}
 		}
 
 		bool HasOptionalExpression {
 			get {
 				return default_expr is DefaultParameterValueExpression;
 			}
 		}
 
 		public Location Location {
 			get {
 				return loc;
 			}
 		}
 
 		public TypeSpec Type {
 			get {
 				return parameter_type;
 			}
 		}
 
 		public FullNamedExpression TypeExpression  {
 			get {
 				return texpr;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.In && ModFlags == Modifier.OUT) {
 				a.Report.Error (36, a.Location, "An out parameter cannot have the `In' attribute");
 				return;
 			}
 
 			if (a.Type == pa.ParamArray) {
 				a.Report.Error (674, a.Location, "Do not use `System.ParamArrayAttribute'. Use the `params' keyword instead");
 				return;
 			}
 
 			if (a.Type == pa.Out && (ModFlags & Modifier.REF) == Modifier.REF &&
 			    !OptAttributes.Contains (pa.In)) {
 				a.Report.Error (662, a.Location,
 					"Cannot specify only `Out' attribute on a ref parameter. Use both `In' and `Out' attributes or neither");
 				return;
 			}
 
 			if (a.Type == pa.CLSCompliant) {
 				a.Report.Warning (3022, 1, a.Location, "CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead");
 			}
 
 			if (a.Type == pa.DefaultParameterValue || a.Type == pa.OptionalParameter) {
 				if (HasOptionalExpression) {
 					a.Report.Error (1745, a.Location,
 						"Cannot specify `{0}' attribute on optional parameter `{1}'",
 						TypeManager.CSharpName (a.Type).Replace ("Attribute", ""), Name);
 				}
 
 				if (a.Type == pa.DefaultParameterValue)
 					return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 		
 		public virtual bool CheckAccessibility (InterfaceMemberBase member)
 		{
 			if (parameter_type == null)
 				return true;
 
 			return member.IsAccessibleAs (parameter_type);
 		}
 
 		public static void Reset ()
 		{
 			parameter_expr_tree_type = null;
 		}
 
 		// <summary>
 		//   Resolve is used in method definitions
 		// </summary>
 		public virtual TypeSpec Resolve (IMemberContext rc, int index)
 		{
 			if (parameter_type != null)
 				return parameter_type;
 
 			if (attributes != null)
 				attributes.AttachTo (this, rc);
 
 			var expr = texpr.ResolveAsTypeTerminal (rc, false);
 			if (expr == null)
 				return null;
 
 			this.idx = index;
 			texpr = expr;
 			parameter_type = texpr.Type;
 	
 			if ((modFlags & Parameter.Modifier.ISBYREF) != 0 &&
 				TypeManager.IsSpecialType (parameter_type)) {
 				rc.Compiler.Report.Error (1601, Location, "Method or delegate parameter cannot be of type `{0}'",
 					GetSignatureForError ());
 				return null;
 			}
 
 			TypeManager.CheckTypeVariance (parameter_type,
 				(modFlags & Parameter.Modifier.ISBYREF) != 0 ? Variance.None 
 				rc);
 
 			if (parameter_type.IsStatic) {
 				rc.Compiler.Report.Error (721, Location, "`{0}'
 					texpr.GetSignatureForError ());
 				return parameter_type;
 			}
 
 			if ((modFlags & Modifier.This) != 0 && (parameter_type.IsPointer || parameter_type == InternalType.Dynamic)) {
 				rc.Compiler.Report.Error (1103, Location, "The extension method cannot be of type `{0}'",
 					TypeManager.CSharpName (parameter_type));
 			}
 
 			return parameter_type;
 		}
 
 		public void ResolveDefaultValue (ResolveContext rc)
 		{
 			//
 			// Default value was specified using an expression
 			//
 			if (default_expr != null) {
 				((DefaultParameterValueExpression)default_expr).Resolve (rc, this);
 				return;
 			}
 
 			if (attributes == null)
 				return;
 			
 			var opt_attr = attributes.Search (rc.Module.PredefinedAttributes.OptionalParameter);
 			var def_attr = attributes.Search (rc.Module.PredefinedAttributes.DefaultParameterValue);
 			if (def_attr != null) {
 				if (def_attr.Resolve () == null)
 					return;
 
 				var default_expr_attr = def_attr.GetParameterDefaultValue ();
 				if (default_expr_attr == null)
 					return;
 
 				var dpa_rc = def_attr.CreateResolveContext ();
 				default_expr = default_expr_attr.Resolve (dpa_rc);
 
 				if (default_expr is BoxedCast)
 					default_expr = ((BoxedCast) default_expr).Child;
 
 				Constant c = default_expr as Constant;
 				if (c == null) {
 					if (parameter_type == TypeManager.object_type) {
 						rc.Compiler.Report.Error (1910, default_expr.Location,
 							"Argument of type `{0}' is not applicable for the DefaultParameterValue attribute",
 							default_expr.Type.GetSignatureForError ());
 					} else {
 						rc.Compiler.Report.Error (1909, default_expr.Location,
 							"The DefaultParameterValue attribute is not applicable on parameters of type `{0}'",
 							default_expr.Type.GetSignatureForError ()); ;
 					}
 
 					default_expr = null;
 					return;
 				}
 
 				if (TypeSpecComparer.IsEqual (default_expr.Type, parameter_type) ||
 					(default_expr is NullConstant && TypeManager.IsReferenceType (parameter_type) && !parameter_type.IsGenericParameter) ||
 					TypeSpecComparer.IsEqual (parameter_type, TypeManager.object_type)) {
 					return;
 				}
 
 				//
 				// LAMESPEC
 				// User operators returning same type as parameter type are considered
 				// valid for this attribute only
 				//
 				// struct S { public static implicit operator S (int i) {} }
 				//
 				// void M ([DefaultParameterValue (3)]S s)
 				//
 				var expr = Convert.ImplicitUserConversion (dpa_rc, default_expr, parameter_type, loc);
 				if (expr != null && TypeSpecComparer.IsEqual (expr.Type, parameter_type)) {
 					return;
 				}
 				
 				rc.Compiler.Report.Error (1908, default_expr.Location, "The type of the default value should match the type of the parameter");
 				return;
 			}
 
 			if (opt_attr != null) {
 				default_expr = EmptyExpression.MissingValue;
 			}
 		}
 
 		public bool HasDefaultValue {
 			get { return default_expr != null; }
 		}
 
 		public bool HasExtensionMethodModifier {
 			get { return (modFlags & Modifier.This) != 0; }
 		}
 
 		//
 		// Hoisted parameter variant
 		//
 		public HoistedVariable HoistedVariant {
 			get {
 				return hoisted_variant;
 			}
 			set {
 				hoisted_variant = value;
 			}
 		}
 
 		public Modifier ModFlags {
 			get { return modFlags & ~Modifier.This; }
 		}
 
 		public string Name {
 			get { return name; }
 			set { name = value; }
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Parameter;
 			}
 		}
 
 		public virtual string GetSignatureForError ()
 		{
 			string type_name;
 			if (parameter_type != null)
 				type_name = TypeManager.CSharpName (parameter_type);
 			else
 				type_name = texpr.GetSignatureForError ();
 
 			string mod = GetModifierSignature (modFlags);
 			if (mod.Length > 0)
 				return String.Concat (mod, " ", type_name);
 
 			return type_name;
 		}
 
 		public static string GetModifierSignature (Modifier mod)
 		{
 			switch (mod) {
 			case Modifier.OUT
 				return "out";
 			case Modifier.PARAMS
 				return "params";
 			case Modifier.REF
 				return "ref";
 			case Modifier.This
 				return "this";
 			default
 				return "";
 			}
 		}
 
 		public void IsClsCompliant (IMemberContext ctx)
 		{
 			if (parameter_type.IsCLSCompliant ())
 				return;
 
 			ctx.Compiler.Report.Warning (3001, 1, Location,
 				"Argument type `{0}' is not CLS-compliant", parameter_type.GetSignatureForError ());
 		}
 
 		public virtual void ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			if (builder != null)
 				throw new InternalErrorException ("builder already exists");
 
 			var pattrs = ParametersCompiled.GetParameterAttribute (modFlags);
 			if (HasOptionalExpression)
 				pattrs |= ParameterAttributes.Optional;
 
 			if (mb == null)
 				builder = cb.DefineParameter (index, pattrs, Name);
 			else
 				builder = mb.DefineParameter (index, pattrs, Name);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (HasDefaultValue) {
 				//
 				// Emit constant values for true constants only, the other
 				// constant-like expressions will rely on default value expression
 				//
 				var def_value = DefaultValue;
 				Constant c = def_value != null ? def_value.Child as Constant 
 				if (c != null) {
 					if (default_expr.Type == TypeManager.decimal_type) {
 						pa.DecimalConstant.EmitAttribute (builder, (decimal) c.GetValue (), c.Location);
 					} else {
 						builder.SetConstant (c.GetValue ());
 					}
 				} else if (default_expr.Type.IsStruct) {
 					//
 					// Handles special case where default expression is used with value-type
 					//
 					// void Foo (S s = default (S)) {}
 					//
 					builder.SetConstant (null);
 				}
 			}
 
 			if (parameter_type != null) {
 				if (parameter_type == InternalType.Dynamic) {
 					pa.Dynamic.EmitAttribute (builder);
 				} else if (parameter_type.HasDynamicElement) {
 					pa.Dynamic.EmitAttribute (builder, parameter_type, Location);
 				}
 			}
 		}
 
 		public Parameter Clone ()
 		{
 			Parameter p = (Parameter) MemberwiseClone ();
 			if (attributes != null)
 				p.attributes = attributes.Clone ();
 
 			return p;
 		}
 
 		public ExpressionStatement CreateExpressionTreeVariable (BlockContext ec)
 		{
 			if ((modFlags & Modifier.ISBYREF) != 0)
 				ec.Report.Error (1951, Location, "An expression tree parameter cannot use `ref' or `out' modifier");
 
 			expr_tree_variable = TemporaryVariableReference.Create (ResolveParameterExpressionType (ec, Location).Type, ec.CurrentBlock.ParametersBlock, Location);
 			expr_tree_variable = (TemporaryVariableReference) expr_tree_variable.Resolve (ec);
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (new TypeOf (
 				new TypeExpression (parameter_type, Location), Location)));
 			arguments.Add (new Argument (new StringConstant (Name, Location)));
 			return new SimpleAssign (ExpressionTreeVariableReference (),
 				Expression.CreateExpressionFactoryCall (ec, "Parameter", null, arguments, Location));
 		}
 
 		public void Emit (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			ParameterReference.EmitLdArg (ec, arg_idx);
 		}
 
 		public void EmitAssign (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			if (arg_idx <= 255)
 				ec.Emit (OpCodes.Starg_S, (byte) arg_idx);
 			else
 				ec.Emit (OpCodes.Starg, arg_idx);
 		}
 
 		public void EmitAddressOf (EmitContext ec)
 		{
 			int arg_idx = idx;
 
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			bool is_ref = (ModFlags & Modifier.ISBYREF) != 0;
 			if (is_ref) {
 				ParameterReference.EmitLdArg (ec, arg_idx);
 			} else {
 				if (arg_idx <= 255)
 					ec.Emit (OpCodes.Ldarga_S, (byte) arg_idx);
 				else
 					ec.Emit (OpCodes.Ldarga, arg_idx);
 			}
 		}
 
 		public TemporaryVariableReference ExpressionTreeVariableReference ()
 		{
 			return expr_tree_variable;
 		}
 
 		//
 		// System.Linq.Expressions.ParameterExpression type
 		//
 		public static TypeExpr ResolveParameterExpressionType (IMemberContext ec, Location location)
 		{
 			if (parameter_expr_tree_type != null)
 				return parameter_expr_tree_type;
 
 			TypeSpec p_type = ec.Module.PredefinedTypes.ParameterExpression.Resolve (location);
 			parameter_expr_tree_type = new TypeExpression (p_type, location).
 				ResolveAsTypeTerminal (ec, false);
 
 			return parameter_expr_tree_type;
 		}
 
 		public void Warning_UselessOptionalParameter (Report Report)
 		{
 			Report.Warning (1066, 1, Location,
 				"The default value specified for optional parameter `{0}' will never be used",
 				Name);
 		}
 	}
 
 	//
 	// Imported or resolved parameter information
 	//
 	public class ParameterData 
 	{
 		readonly string name;
 		readonly Parameter.Modifier modifiers;
 		readonly Expression default_value;
 
 		public ParameterData (string name, Parameter.Modifier modifiers)
 		{
 			this.name = name;
 			this.modifiers = modifiers;
 		}
]]></clone_fragment>
<clone_fragment endline="1112" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" hamdist="3" pcid="4089" startline="612"><![CDATA[
 
 		Variance variance;
 		SpecialConstraint spec;
 		readonly int tp_pos;
 		TypeSpec[] targs;
 		TypeSpec[] ifaces_defined;
 
 		//
 		// Creates type owned type parameter
 		//
 		public TypeParameterSpec (TypeSpec declaringType, int index, ITypeDefinition definition, SpecialConstraint spec, Variance variance, MetaType info)
 			
 		{
 			this.variance = variance;
 			this.spec = spec;
 			state &= ~StateFlags.Obsolete_Undetected;
 			tp_pos = index;
 		}
 
 		//
 		// Creates method owned type parameter
 		//
 		public TypeParameterSpec (int index, ITypeDefinition definition, SpecialConstraint spec, Variance variance, MetaType info)
 			
 		{
 		}
 
 		#region Properties
 
 		public int DeclaredPosition {
 			get {
 				return tp_pos;
 			}
 		}
 
 		public bool HasSpecialConstructor {
 			get {
 				return (spec & SpecialConstraint.Constructor) != 0;
 			}
 		}
 
 		public bool HasSpecialClass {
 			get {
 				return (spec & SpecialConstraint.Class) != 0;
 			}
 		}
 
 		public bool HasSpecialStruct {
 			get {
 				return (spec & SpecialConstraint.Struct) != 0;
 			}
 		}
 
 		public bool HasTypeConstraint {
 			get {
 				return BaseType != TypeManager.object_type && BaseType != TypeManager.value_type;
 			}
 		}
 
 		public override IList<TypeSpec> Interfaces {
 			get {
 				if ((state & StateFlags.InterfacesExpanded) == 0) {
 					if (ifaces != null) {
 						for (int i = 0; i < ifaces.Count; ++i ) {
 							var iface_type = ifaces[i];
 							if (iface_type.Interfaces != null) {
 								if (ifaces_defined == null)
 									ifaces_defined = ifaces.ToArray ();
 
 								for (int ii = 0; ii < iface_type.Interfaces.Count; ++ii) {
 									var ii_iface_type = iface_type.Interfaces [ii];
 
 									AddInterface (ii_iface_type);
 								}
 							}
 						}
 					}
 
 					if (ifaces_defined == null && ifaces != null)
 						ifaces_defined = ifaces.ToArray ();
 
 					state |= StateFlags.InterfacesExpanded;
 				}
 
 				return ifaces;
 			}
 		}
 
 		//
 		// Unexpanded interfaces list
 		//
 		public TypeSpec[] InterfacesDefined {
 			get {
 				if (ifaces_defined == null && ifaces != null)
 					ifaces_defined = ifaces.ToArray ();
 
 				return ifaces_defined;
 			}
 			set {
 				ifaces_defined = value;
 			}
 		}
 
 		public bool IsConstrained {
 			get {
 				return spec != SpecialConstraint.None || ifaces != null || targs != null || HasTypeConstraint;
 			}
 		}
 
 		//
 		// Returns whether the type parameter is "known to be a reference type"
 		//
 		public bool IsReferenceType {
 			get {
 				if ((spec & SpecialConstraint.Class) != 0 || HasTypeConstraint)
 					return true;
 
 				if (targs != null) {
 					foreach (var ta in targs) {
 						if (TypeManager.IsReferenceType (ta))
 							return true;
 					}
 				}
 
 				return false;
 			}
 		}
 
 		public bool IsValueType {	// TODO
 			get {
 				// TODO MemberCache
 				return HasSpecialStruct;
 			}
 		}
 
 		public override string Name {
 			get {
 				return definition.Name;
 			}
 		}
 
 		public bool IsMethodOwned {
 			get {
 				return DeclaringType == null;
 			}
 		}
 
 		public SpecialConstraint SpecialConstraint {
 			get {
 				return spec;
 			}
 			set {
 				spec = value;
 			}
 		}
 
 		//
 		// Types used to inflate the generic type
 		//
 		public new TypeSpec[] TypeArguments {
 			get {
 				return targs;
 			}
 			set {
 				targs = value;
 			}
 		}
 
 		public Variance Variance {
 			get {
 				return variance;
 			}
 		}
 
 		#endregion
 
 		public void ChangeTypeArgumentToBaseType (int index)
 		{
 			BaseType = targs [index];
 			if (targs.Length == 1) {
 				targs = null;
 			} else {
 				var copy = new TypeSpec[targs.Length - 1];
 				if (index > 0)
 					Array.Copy (targs, copy, index);
 
 				Array.Copy (targs, index + 1, copy, index, targs.Length - index - 1);
 				targs = copy;
 			}
 		}
 
 		public string DisplayDebugInfo ()
 		{
 			var s = GetSignatureForError ();
 			return IsMethodOwned ? s + "!!" 
 		}
 
 		//
 		// Finds effective base class
 		//
 		public TypeSpec GetEffectiveBase ()
 		{
 			if (HasSpecialStruct) {
 				return TypeManager.value_type;
 			}
 
 			if (BaseType != null && targs == null)
 				return BaseType;
 
 			var types = targs;
 			if (HasTypeConstraint) {
 				Array.Resize (ref types, types.Length + 1);
 				types[types.Length - 1] = BaseType;
 			}
 
 			if (types != null)
 				return Convert.FindMostEncompassedType (types.Select (l => l.BaseType));
 
 			return TypeManager.object_type;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return Name;
 		}
 
 		//
 		// Constraints have to match by definition but not position, used by
 		// partial classes or methods
 		//
 		public bool HasSameConstraintsDefinition (TypeParameterSpec other)
 		{
 			if (spec != other.spec)
 				return false;
 
 			if (BaseType != other.BaseType)
 				return false;
 
 			if (!TypeSpecComparer.Override.IsSame (InterfacesDefined, other.InterfacesDefined))
 				return false;
 
 			if (!TypeSpecComparer.Override.IsSame (targs, other.targs))
 				return false;
 
 			return true;
 		}
 
 		//
 		// Constraints have to match by using same set of types, used by
 		// implicit interface implementation
 		//
 		public bool HasSameConstraintsImplementation (TypeParameterSpec other)
 		{
 			if (spec != other.spec)
 				return false;
 
 			//
 			// It can be same base type or inflated type parameter
 			//
 			// interface I<T> { void Foo<U> where U 
 			// class A 
 			//
 			bool found;
 			if (!TypeSpecComparer.Override.IsEqual (BaseType, other.BaseType)) {
 				if (other.targs == null)
 					return false;
 
 				found = false;
 				foreach (var otarg in other.targs) {
 					if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 						found = true;
 						break;
 					}
 				}
 
 				if (!found)
 					return false;
 			}
 
 			// Check interfaces implementation -> definition
 			if (InterfacesDefined != null) {
 				foreach (var iface in InterfacesDefined) {
 					found = false;
 					if (other.InterfacesDefined != null) {
 						foreach (var oiface in other.InterfacesDefined) {
 							if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 								found = true;
 								break;
 							}
 						}
 					}
 
 					if (found)
 						continue;
 
 					if (other.targs != null) {
 						foreach (var otarg in other.targs) {
 							if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 								found = true;
 								break;
 							}
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check interfaces implementation <- definition
 			if (other.InterfacesDefined != null) {
 				if (InterfacesDefined == null)
 					return false;
 
 				foreach (var oiface in other.InterfacesDefined) {
 					found = false;
 					foreach (var iface in InterfacesDefined) {
 						if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check type parameters implementation -> definition
 			if (targs != null) {
 				if (other.targs == null)
 					return false;
 
 				foreach (var targ in targs) {
 					found = false;
 					foreach (var otarg in other.targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check type parameters implementation <- definition
 			if (other.targs != null) {
 				foreach (var otarg in other.targs) {
 					// Ignore inflated type arguments, were checked above
 					if (!otarg.IsGenericParameter)
 						continue;
 
 					if (targs == null)
 						return false;
 
 					found = false;
 					foreach (var targ in targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}				
 			}
 
 			return true;
 		}
 
 		public static TypeParameterSpec[] InflateConstraints (TypeParameterInflator inflator, TypeParameterSpec[] tparams)
 		{
 			return InflateConstraints (tparams, l => l, inflator);
 		}
 
 		public static TypeParameterSpec[] InflateConstraints<T> (TypeParameterSpec[] tparams, Func<T, TypeParameterInflator> inflatorFactory, T arg)
 		{
 			TypeParameterSpec[] constraints = null;
 			TypeParameterInflator? inflator = null;
 
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 				if (tp.HasTypeConstraint || tp.Interfaces != null || tp.TypeArguments != null) {
 					if (constraints == null) {
 						constraints = new TypeParameterSpec[tparams.Length];
 						Array.Copy (tparams, constraints, constraints.Length);
 					}
 
 					//
 					// Using a factory to avoid possibly expensive inflator build up
 					//
 					if (inflator == null)
 						inflator = inflatorFactory (arg);
 
 					constraints[i] = (TypeParameterSpec) constraints[i].InflateMember (inflator.Value);
 				}
 			}
 
 			if (constraints == null)
 				constraints = tparams;
 
 			return constraints;
 		}
 
 		public void InflateConstraints (TypeParameterInflator inflator, TypeParameterSpec tps)
 		{
 			tps.BaseType = inflator.Inflate (BaseType);
 			if (ifaces != null) {
 				tps.ifaces = new List<TypeSpec> (ifaces.Count);
 				for (int i = 0; i < ifaces.Count; ++i)
 					tps.ifaces.Add (inflator.Inflate (ifaces[i]));
 			}
 
 			if (targs != null) {
 				tps.targs = new TypeSpec[targs.Length];
 				for (int i = 0; i < targs.Length; ++i)
 					tps.targs[i] = inflator.Inflate (targs[i]);
 			}
 		}
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var tps = (TypeParameterSpec) MemberwiseClone ();
 			InflateConstraints (inflator, tps);
 			return tps;
 		}
 
 		//
 		// Populates type parameter members using type parameter constraints
 		// The trick here is to be called late enough but not too late to
 		// populate member cache with all members from other types
 		//
 		protected override void InitializeMemberCache (bool onlyTypes)
 		{
 			cache = new MemberCache ();
 
 			//
 			// For a type parameter the membercache is the union of the sets of members of the types
 			// specified as a primary constraint or secondary constraint
 			//
 			if (BaseType != TypeManager.object_type && BaseType != TypeManager.value_type)
 				cache.AddBaseType (BaseType);
 
 			if (ifaces != null) {
 				foreach (var iface_type in Interfaces) {
 					cache.AddInterface (iface_type);
 				}
 			}
 
 			if (targs != null) {
 				foreach (var ta in targs) {
 					if (ta.BaseType != TypeManager.object_type && ta.BaseType != TypeManager.value_type)
 						cache.AddBaseType (ta.BaseType);
 
 					if (ta.Interfaces != null) {
 						foreach (var iface_type in ta.Interfaces) {
 							cache.AddInterface (iface_type);
 						}
 					}
 				}
 			}
 		}
 
 		public bool IsConvertibleToInterface (TypeSpec iface)
 		{
 			if (Interfaces != null) {
 				foreach (var t in Interfaces) {
 					if (t == iface)
 						return true;
 				}
 			}
 
 			if (TypeArguments != null) {
 				foreach (var t in TypeArguments) {
 					if (((TypeParameterSpec) t).IsConvertibleToInterface (iface))
 						return true;
 				}
 			}
 
 			return false;
 		}
 
 		public override TypeSpec Mutate (TypeParameterMutator mutator)
 		{
 			return mutator.Mutate (this);
 		}
 	}
 
 	public struct TypeParameterInflator
 	{
 		readonly TypeSpec type;
 		readonly TypeParameterSpec[] tparams;
 		readonly TypeSpec[] targs;
 
 		public TypeParameterInflator (TypeParameterInflator nested, TypeSpec type)
 			
 		{
 		}
]]></clone_fragment>
<clone_fragment endline="821" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="13" pcid="3327" startline="677"><![CDATA[
 	}
 
 	// A 'return' or a 'yield break'
 	public abstract class ExitStatement 
 	{
 		protected bool unwind_protect;
 		protected abstract bool DoResolve (BlockContext ec);
 
 		public virtual void Error_FinallyClause (Report Report)
 		{
 			Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 		}
 
 		public sealed override bool Resolve (BlockContext ec)
 		{
 			if (!DoResolve (ec))
 				return false;
 
 			unwind_protect = ec.CurrentBranching.AddReturnOrigin (ec.CurrentBranching.CurrentUsageVector, this);
 			if (unwind_protect)
 				ec.NeedReturnLabel ();
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
 	}
 
 	/// <summary>
 	///   Implements the return statement
 	/// </summary>
 	public class Return 
 	{
 		protected Expression Expr;
 		public Return (Expression expr, Location l)
 		{
 			Expr = expr;
 			loc = l;
 		}
 
 		#region Properties
 		public Expression Expression {
 			get {
 				return Expr;
 			}
 		}
 		#endregion
 
 		protected override bool DoResolve (BlockContext ec)
 		{
 			if (Expr == null) {
 				if (ec.ReturnType == TypeManager.void_type)
 					return true;
 
 				if (ec.CurrentIterator != null) {
 					Error_ReturnFromIterator (ec);
 				} else {
 					ec.Report.Error (126, loc,
 						"An object of a type convertible to `{0}' is required for the return statement",
 						ec.ReturnType.GetSignatureForError ());
 				}
 
 				return false;
 			}
 
 			Expr = Expr.Resolve (ec);
 
 			AnonymousExpression am = ec.CurrentAnonymousMethod;
 			if (am == null) {
 				if (ec.ReturnType == TypeManager.void_type) {
 					ec.Report.Error (127, loc,
 						"`{0}'
 						ec.GetSignatureForError ());
 				}
 			} else {
 				if (am.IsIterator) {
 					Error_ReturnFromIterator (ec);
 					return false;
 				}
 
 				var l = am as AnonymousMethodBody;
 				if (l != null && l.ReturnTypeInference != null && Expr != null) {
 					l.ReturnTypeInference.AddCommonTypeBound (Expr.Type);
 					return true;
 				}
 			}
 
 			if (Expr == null)
 				return false;
 
 			if (Expr.Type != ec.ReturnType) {
 				Expr = Convert.ImplicitConversionRequired (ec, Expr, ec.ReturnType, loc);
 
 				if (Expr == null) {
 					if (am != null) {
 						ec.Report.Error (1662, loc,
 							"Cannot convert `{0}' to delegate type `{1}' because some of the return types in the block are not implicitly convertible to the delegate return type",
 							am.ContainerType, am.GetSignatureForError ());
 					}
 					return false;
 				}
 			}
 
 			return true;			
 		}
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (Expr != null) {
 				Expr.Emit (ec);
 
 				if (unwind_protect)
 					ec.Emit (OpCodes.Stloc, ec.TemporaryReturn ());
 			}
 
 			if (unwind_protect)
 				ec.Emit (OpCodes.Leave, ec.ReturnLabel);
 			else
 				ec.Emit (OpCodes.Ret);
 		}
 
 		void Error_ReturnFromIterator (ResolveContext rc)
 		{
 			rc.Report.Error (1622, loc,
 				"Cannot return a value from iterators. Use the yield return statement to return a value, or yield break to end the iteration");
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Return target = (Return) t;
 			// It's null for simple return;
 			if (Expr != null)
 				target.Expr = Expr.Clone (clonectx);
 		}
 	}
 
 	public class Goto 
 		string target;
 		LabeledStatement label;
 		bool unwind_protect;
 
 		public override bool Resolve (BlockContext ec)
 		{
 			unwind_protect = ec.CurrentBranching.AddGotoOrigin (ec.CurrentBranching.CurrentUsageVector, this);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="5579" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="14" pcid="2437" startline="5408"><![CDATA[
 	}
 
 	abstract class PropertyOrIndexerExpr<T> 
 	{
 		// getter and setter can be different for base calls
 		MethodSpec getter, setter;
 		protected T best_candidate;
 
 		protected LocalTemporary temp;
 		protected bool prepared;
 
 		protected PropertyOrIndexerExpr (Location l)
 		{
 			loc = l;
 		}
 
 		#region Properties
 
 		public MethodSpec Getter {
 			get {
 				return getter;
 			}
 			set {
 				getter = value;
 			}
 		}
 
 		public MethodSpec Setter {
 			get {
 				return setter;
 			}
 			set {
 				setter = value;
 			}
 		}
 
 		#endregion
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, null);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.Resolve (ec);
 			}
 
 			if (!ResolveGetter (ec))
 				return null;
 
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (right_side == EmptyExpression.OutAccess.Instance) {
 				// TODO
 				INamedBlockVariable variable = null;
 				if (best_candidate != null && ec.CurrentBlock.ParametersBlock.TopBlock.GetLocalName (best_candidate.Name, ec.CurrentBlock, ref variable) && variable is Linq.RangeVariable) {
 					ec.Report.Error (1939, loc, "A range variable `{0}' may not be passes as `ref' or `out' parameter",
 						best_candidate.Name);
 				} else {
 					right_side.DoResolveLValue (ec, this);
 				}
 				return null;
 			}
 
 			// if the property/indexer returns a value type, and we try to set a field in it
 			if (right_side == EmptyExpression.LValueMemberAccess || right_side == EmptyExpression.LValueMemberOutAccess) {
 				Error_CannotModifyIntermediateExpressionValue (ec);
 			}
 
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, right_side);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.ResolveLValue (ec, right_side);
 			}
 
 			if (!ResolveSetter (ec))
 				return null;
 
 			return this;
 		}
 
 		//
 		// Implements the IAssignMethod interface for assignments
 		//
 		public abstract void Emit (EmitContext ec, bool leave_copy);
 		public abstract void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load);
 
 		public override void Emit (EmitContext ec)
 		{
 			Emit (ec, false);
 		}
 
 		public abstract SLE.Expression MakeAssignExpression (BuilderContext ctx, Expression source);
 
 		protected abstract Expression OverloadResolve (ResolveContext rc, Expression right_side);
 
 		bool ResolveGetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasGet) {
 				if (InstanceExpression != EmptyExpression.Null) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate);
 					rc.Report.Error (154, loc, "The property or indexer `{0}' cannot be used in this context because it lacks the `get' accessor",
 						best_candidate.GetSignatureForError ());
 					return false;
 				}
 			} else if (!best_candidate.Get.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					rc.Report.Error (271, loc, "The property or indexer `{0}' cannot be used in this context because the get accessor is inaccessible",
 						TypeManager.CSharpSignature (best_candidate));
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					ErrorIsInaccesible (rc, best_candidate.Get.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility) {
 				CheckProtectedMemberAccess (rc, best_candidate.Get);
 			}
 
 			getter = CandidateToBaseOverride (rc, best_candidate.Get);
 			return true;
 		}
 
 		bool ResolveSetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasSet) {
 				rc.Report.Error (200, loc, "Property or indexer `{0}' cannot be assigned to (it is read-only)",
 					GetSignatureForError ());
 				return false;
 			}
 
 			if (!best_candidate.Set.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					rc.Report.Error (272, loc, "The property or indexer `{0}' cannot be used in this context because the set accessor is inaccessible",
 						GetSignatureForError ());
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					ErrorIsInaccesible (rc, best_candidate.Set.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility)
 				CheckProtectedMemberAccess (rc, best_candidate.Set);
 
 			setter = CandidateToBaseOverride (rc, best_candidate.Set);
 			return true;
 		}
 	}
 
 	/// <summary>
 	///   Fully resolved expression that evaluates to an Event
 	/// </summary>
 	public class EventExpr 
 	{
 		readonly EventSpec spec;
 		MethodSpec op;
 
 		public EventExpr (EventSpec spec, Location loc)
 		{
 			this.spec = spec;
 			this.loc = loc;
 		}
]]></clone_fragment>
<clone_fragment endline="811" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" hamdist="10" pcid="761" startline="631"><![CDATA[
 
 		TypeSpec CreateType (MetaType type, TypeSpec declaringType, DynamicTypeReader dtype, bool canImportBaseType)
 		{
 			TypeSpec spec;
 			if (import_cache.TryGetValue (type, out spec)) {
 				if (spec == TypeManager.object_type) {
 					if (dtype.IsDynamicObject (this))
 						return InternalType.Dynamic;
 
 					return spec;
 				}
 
 				if (!spec.IsGeneric || type.IsGenericTypeDefinition)
 					return spec;
 
 				if (!dtype.HasDynamicAttribute (this))
 					return spec;
 
 				// We've found same object in the cache but this one has a dynamic custom attribute
 				// and it's most likely dynamic version of same type IFoo<object> agains IFoo<dynamic>
 				// Do type resolve process again in that case
 
 				// TODO
 			}
 
 			if (type.IsGenericType && !type.IsGenericTypeDefinition) {
 				var type_def = type.GetGenericTypeDefinition ();
 				var targs = CreateGenericArguments (0, type.GetGenericArguments (), dtype);
 				if (declaringType == null) {
 					// Simple case, no nesting
 					spec = CreateType (type_def, null, new DynamicTypeReader (), canImportBaseType);
 					spec = spec.MakeGenericType (targs);
 				} else {
 					//
 					// Nested type case, converting .NET types like
 					// A`1.B`1.C`1<int, long, string> to typespec like
 					// A<int>.B<long>.C<string>
 					//
 					var nested_hierarchy = new List<TypeSpec> ();
 					while (declaringType.IsNested) {
 						nested_hierarchy.Add (declaringType);
 						declaringType = declaringType.DeclaringType;
 					}
 					while (declaringType.IsNested) {
 						nested_hierarchy.Add (declaringType);
 						declaringType = declaringType.DeclaringType;
 					}
 
 					int targs_pos = 0;
 					if (declaringType.Arity > 0) {
 						spec = declaringType.MakeGenericType (targs.Skip (targs_pos).Take (declaringType.Arity).ToArray ());
 						targs_pos = spec.Arity;
 					} else {
 						spec = declaringType;
 					}
 
 					for (int i = nested_hierarchy.Count; i != 0; --i) {
 						var t = nested_hierarchy [i - 1];
 						spec = MemberCache.FindNestedType (spec, t.Name, t.Arity);
 						if (t.Arity > 0) {
 							spec = spec.MakeGenericType (targs.Skip (targs_pos).Take (spec.Arity).ToArray ());
 							targs_pos += t.Arity;
 						}
 					}
 					for (int i = nested_hierarchy.Count; i != 0; --i) {
 						var t = nested_hierarchy [i - 1];
 						spec = MemberCache.FindNestedType (spec, t.Name, t.Arity);
 						if (t.Arity > 0) {
 							spec = spec.MakeGenericType (targs.Skip (targs_pos).Take (spec.Arity).ToArray ());
 							targs_pos += t.Arity;
 						}
 					}
 
 					string name = type.Name;
 					int index = name.IndexOf ('`');
 					if (index > 0)
 						name = name.Substring (0, index);
 
 					spec = MemberCache.FindNestedType (spec, name, targs.Length - targs_pos);
 					if (spec.Arity > 0) {
 						spec = spec.MakeGenericType (targs.Skip (targs_pos).ToArray ());
 					}
 				}
 
 				// Don't add generic type with dynamic arguments, they can interfere with same type
 				// using object type arguments
 				if (!spec.HasDynamicElement) {
 
 					// Add to reading cache to speed up reading
 					if (!import_cache.ContainsKey (type))
 						import_cache.Add (type, spec);
 				}
 
 				return spec;
 			}
 
 			Modifiers mod;
 			MemberKind kind;
 
 			var ma = type.Attributes;
 			switch (ma & TypeAttributes.VisibilityMask) {
 			case TypeAttributes.Public
 			case TypeAttributes.NestedPublic
 				mod = Modifiers.PUBLIC;
 				break;
 			case TypeAttributes.NestedPrivate
 				mod = Modifiers.PRIVATE;
 				break;
 			case TypeAttributes.NestedFamily
 				mod = Modifiers.PROTECTED;
 				break;
 			case TypeAttributes.NestedFamORAssem
 				mod = Modifiers.PROTECTED | Modifiers.INTERNAL;
 				break;
 			default
 				mod = Modifiers.INTERNAL;
 				break;
 			}
 
 			if ((ma & TypeAttributes.Interface) != 0) {
 				kind = MemberKind.Interface;
 			} else if (type.IsGenericParameter) {
 				kind = MemberKind.TypeParameter;
 			} else {
 				var base_type = type.BaseType;
 				if (base_type == null || (ma & TypeAttributes.Abstract) != 0) {
 					kind = MemberKind.Class;
 				} else {
 					kind = DetermineKindFromBaseType (base_type);
 					if (kind == MemberKind.Struct || kind == MemberKind.Delegate) {
 						mod |= Modifiers.SEALED;
 					}
 				}
 
 				if (kind == MemberKind.Class) {
 					if ((ma & TypeAttributes.Sealed) != 0) {
 						mod |= Modifiers.SEALED;
 						if ((ma & TypeAttributes.Abstract) != 0)
 							mod |= Modifiers.STATIC;
 					} else if ((ma & TypeAttributes.Abstract) != 0) {
 						mod |= Modifiers.ABSTRACT;
 					}
 				}
 			}
 
 			var definition = new ImportedTypeDefinition (type, this);
 			BuildinTypeSpec pt;
 
 			if (kind == MemberKind.Enum) {
 				const BindingFlags underlying_member = BindingFlags.DeclaredOnly |
 					BindingFlags.Instance |
 					BindingFlags.Public | BindingFlags.NonPublic;
 
 				var type_members = type.GetFields (underlying_member);
 				foreach (var type_member in type_members) {
 					spec = new EnumSpec (declaringType, definition, CreateType (type_member.FieldType), type, mod);
 					break;
 				foreach (var type_member in type_members) {
 					spec = new EnumSpec (declaringType, definition, CreateType (type_member.FieldType), type, mod);
 					break;
 				}
 
 				if (spec == null)
 					kind = MemberKind.Class;
 
 			} else if (kind == MemberKind.TypeParameter) {
 				// Return as type_cache was updated
 				return CreateTypeParameter (type, declaringType);
 			} else if (type.IsGenericTypeDefinition) {
 				definition.TypeParameters = CreateGenericParameters (type, declaringType);
 
 				// Constraints are not loaded on demand and can reference this type
 				if (import_cache.TryGetValue (type, out spec))
 					return spec;
 
 			} else if (buildin_types.TryGetValue (type, out pt)) {
 				spec = pt;
 				pt.SetDefinition (definition, type, mod);
 			}
 
 			if (spec == null)
 				spec = new TypeSpec (kind, declaringType, definition, type, mod);
 
 			import_cache.Add (type, spec);
 
 			//
 			// Two stage setup as the base type can be inflated declaring type or
 			// another nested type inside same declaring type which has not been
 			// loaded, therefore we can import a base type of nested types once
 			// the types have been imported
 			//
 			if (canImportBaseType)
 				ImportTypeBase (spec, type);
 
 			return spec;
 		}
]]></clone_fragment>
<clone_fragment endline="445" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" hamdist="9" pcid="5727" startline="366"><![CDATA[
 
 		TypeExpr CreateSiteType (EmitContext ec, Arguments arguments, int dyn_args_count, bool is_statement)
 		{
 			int default_args = is_statement ? 1 
 			var module = ec.MemberContext.Module;
 
 			bool has_ref_out_argument = false;
 			var targs = new TypeExpression[dyn_args_count + default_args];
 			targs [0] = new TypeExpression (module.PredefinedTypes.CallSite.TypeSpec, loc);
 			for (int i = 0; i < dyn_args_count; ++i) {
 				Argument a = arguments [i];
 				if (a.ArgType == Argument.AType.Out || a.ArgType == Argument.AType.Ref)
 					has_ref_out_argument = true;
 
 				var t = a.Type;
 
 				// Convert any internal type like dynamic or null to object
 				if (t.Kind == MemberKind.InternalCompilerType)
 					t = TypeManager.object_type;
 
 				targs [i + 1] = new TypeExpression (t, loc);
 			}
 			for (int i = 0; i < dyn_args_count; ++i) {
 				Argument a = arguments [i];
 				if (a.ArgType == Argument.AType.Out || a.ArgType == Argument.AType.Ref)
 					has_ref_out_argument = true;
 
 				var t = a.Type;
 
 				// Convert any internal type like dynamic or null to object
 				if (t.Kind == MemberKind.InternalCompilerType)
 					t = TypeManager.object_type;
 
 				targs [i + 1] = new TypeExpression (t, loc);
 			}
 
 			TypeExpr del_type = null;
 			if (!has_ref_out_argument) {
 				string d_name = is_statement ? "Action" 
 
 				TypeExpr te = null;
 				Namespace type_ns = module.GlobalRootNamespace.GetNamespace ("System", true);
 				if (type_ns != null) {
 					te = type_ns.LookupType (module.Compiler, d_name, dyn_args_count + default_args, true, Location.Null);
 				}
 			
 				if (te != null) {
 					if (!is_statement)
 						targs [targs.Length - 1] = new TypeExpression (type, loc);
 
 					del_type = new GenericTypeExpr (te.Type, new TypeArguments (targs), loc);
 				}
 			}
 
 			//
 			// Create custom delegate when no appropriate predefined one is found
 			//
 			if (del_type == null) {
 				TypeSpec rt = is_statement ? TypeManager.void_type 
 				Parameter[] p = new Parameter [dyn_args_count + 1];
 				p[0] = new Parameter (targs [0], "p0", Parameter.Modifier.NONE, null, loc);
 
 				var site = ec.CreateDynamicSite ();
 				int index = site.Types == null ? 0 
 
 				if (site.Mutator != null)
 					rt = site.Mutator.Mutate (rt);
 
 				for (int i = 1; i < dyn_args_count + 1; ++i) {
 					var t = targs[i];
 					if (site.Mutator != null)
 						t.Type = site.Mutator.Mutate (t.Type);
 
 					p[i] = new Parameter (t, "p" + i.ToString ("X"), arguments[i - 1].Modifier, null, loc);
 				}
 				for (int i = 1; i < dyn_args_count + 1; ++i) {
 					var t = targs[i];
 					if (site.Mutator != null)
 						t.Type = site.Mutator.Mutate (t.Type);
 
 					p[i] = new Parameter (t, "p" + i.ToString ("X"), arguments[i - 1].Modifier, null, loc);
 				}
 
 				Delegate d = new Delegate (site.NamespaceEntry, site, new TypeExpression (rt, loc),
 					Modifiers.INTERNAL | Modifiers.COMPILER_GENERATED,
 					new MemberName ("Container" + index.ToString ("X")),
 					new ParametersCompiled (p), null);
 
 				d.CreateType ();
 				d.DefineType ();
 				d.Define ();
 				d.Emit ();
 
 				var inflated = site.AddDelegate (d);
 				del_type = new TypeExpression (inflated, loc);
 			}
 
 			TypeExpr site_type = new GenericTypeExpr (module.PredefinedTypes.CallSiteGeneric.TypeSpec, new TypeArguments (del_type), loc);
 			return site_type;
 		}
]]></clone_fragment>
<clone_fragment endline="1248" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" hamdist="11" pcid="783" startline="1122"><![CDATA[
 
 			public AttributeUsageAttribute AttributeUsage;
 			public ObsoleteAttribute Obsolete;
 			public string[] Conditionals;
 			public string DefaultIndexerName;
 			public bool IsNotCLSCompliant;
 			public TypeSpec CoClass;
 			
 			public static AttributesBag Read (MemberInfo mi, MetadataImporter importer)
 			{
 				AttributesBag bag = null;
 				List<string> conditionals = null;
 
 				// It should not throw any loading exception
 				IList<CustomAttributeData> attrs = CustomAttributeData.GetCustomAttributes (mi);
 
 				string ns, name;
 				foreach (var a in attrs) {
 					importer.GetCustomAttributeTypeName (a, out ns, out name);
 					if (name == "ObsoleteAttribute") {
 						if (ns != "System")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						var args = a.ConstructorArguments;
 
 						if (args.Count == 1) {
 							bag.Obsolete = new ObsoleteAttribute ((string) args[0].Value);
 						} else if (args.Count == 2) {
 							bag.Obsolete = new ObsoleteAttribute ((string) args[0].Value, (bool) args[1].Value);
 						} else {
 							bag.Obsolete = new ObsoleteAttribute ();
 						}
 
 						continue;
 					}
 
 					if (name == "ConditionalAttribute") {
 						if (ns != "System.Diagnostics")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						if (conditionals == null)
 							conditionals = new List<string> (2);
 
 						conditionals.Add ((string) a.ConstructorArguments[0].Value);
 						continue;
 					}
 
 					if (name == "CLSCompliantAttribute") {
 						if (ns != "System")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						bag.IsNotCLSCompliant = !(bool) a.ConstructorArguments[0].Value;
 						continue;
 					}
 
 					// Type only attributes
 					if (mi.MemberType == MemberTypes.TypeInfo || mi.MemberType == MemberTypes.NestedType) {
 						if (name == "DefaultMemberAttribute") {
 							if (ns != "System.Reflection")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.DefaultIndexerName = (string) a.ConstructorArguments[0].Value;
 							continue;
 						}
 
 						if (name == "AttributeUsageAttribute") {
 							if (ns != "System")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.AttributeUsage = new AttributeUsageAttribute ((AttributeTargets) a.ConstructorArguments[0].Value);
 							foreach (var named in a.NamedArguments) {
 								if (named.MemberInfo.Name == "AllowMultiple")
 									bag.AttributeUsage.AllowMultiple = (bool) named.TypedValue.Value;
 								else if (named.MemberInfo.Name == "Inherited")
 									bag.AttributeUsage.Inherited = (bool) named.TypedValue.Value;
 							}
 							continue;
 						}
 
 						// Interface only attribute
 						if (name == "CoClassAttribute") {
 							if (ns != "System.Runtime.InteropServices")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.CoClass = importer.ImportType ((MetaType) a.ConstructorArguments[0].Value);
 							continue;
 						}
 					}
 				}
 
 				if (bag == null)
 					return Default;
 
 				if (conditionals != null)
 					bag.Conditionals = conditionals.ToArray ();
 				
 				return bag;
 			}
 		}
 
 		protected readonly MemberInfo provider;
 		protected AttributesBag cattrs;
 		protected readonly MetadataImporter importer;
 
 		public ImportedDefinition (MemberInfo provider, MetadataImporter importer)
 		{
 			this.provider = provider;
 			this.importer = importer;
 		}
]]></clone_fragment>
<clone_fragment endline="671" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="15" pcid="383" startline="578"><![CDATA[
 
 		[Flags]
 		public enum MemberLookupRestrictions
 		{
 			None = 0,
 			InvocableOnly = 1,
 			ExactArity = 1 << 2,
 			ReadAccess = 1 << 3
 		}
 
 		//
 		// Lookup type `queried_type' for code in class `container_type' with a qualifier of
 		// `qualifier_type' or null to lookup members in the current class.
 		//
 		public static Expression MemberLookup (ResolveContext rc, TypeSpec currentType, TypeSpec queried_type, string name, int arity, MemberLookupRestrictions restrictions, Location loc)
 		{
 			var members = MemberCache.FindMembers (queried_type, name, false);
 			if (members == null)
 				return null;
 
 			MemberSpec non_method = null;
 			MemberSpec ambig_non_method = null;
 			currentType = currentType ?? InternalType.FakeInternalType;
 			do {
 				for (int i = 0; i < members.Count; ++i) {
 					var member = members[i];
 
 					// HACK
 					if ((member.Modifiers & Modifiers.OVERRIDE) != 0 && member.Kind != MemberKind.Event)
 						continue;
 
 					if ((arity > 0 || (restrictions & MemberLookupRestrictions.ExactArity) != 0) && member.Arity != arity)
 						continue;
 
 					if (rc != null) {
 						if (!member.IsAccessible (currentType))
 							continue;
 
 						//
 						// With runtime binder we can have a situation where queried type is inaccessible
 						// because it came via dynamic object, the check about inconsisted accessibility
 						// had no effect as the type was unknown during compilation
 						//
 						// class A {
 						//		private class N { }
 						//
 						//		public dynamic Foo ()
 						//		{
 						//			return new N ();
 						//		}
 						//	}
 						//
 						if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (currentType))
 							continue;
 					}
 
 					if ((restrictions & MemberLookupRestrictions.InvocableOnly) != 0) {
 						if (member is MethodSpec)
 							return new MethodGroupExpr (members, queried_type, loc);
 
 						if (!Invocation.IsMemberInvocable (member))
 							continue;
 					}
 
 					if (non_method == null || member is MethodSpec) {
 						non_method = member;
 					} else if (currentType != null) {
 						ambig_non_method = member;
 					}
 				}
 				for (int i = 0; i < members.Count; ++i) {
 					var member = members[i];
 
 					// HACK
 					if ((member.Modifiers & Modifiers.OVERRIDE) != 0 && member.Kind != MemberKind.Event)
 						continue;
 
 					if ((arity > 0 || (restrictions & MemberLookupRestrictions.ExactArity) != 0) && member.Arity != arity)
 						continue;
 
 					if (rc != null) {
 						if (!member.IsAccessible (currentType))
 							continue;
 
 						//
 						// With runtime binder we can have a situation where queried type is inaccessible
 						// because it came via dynamic object, the check about inconsisted accessibility
 						// had no effect as the type was unknown during compilation
 						//
 						// class A {
 						//		private class N { }
 						//
 						//		public dynamic Foo ()
 						//		{
 						//			return new N ();
 						//		}
 						//	}
 						//
 						if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (currentType))
 							continue;
 					}
 
 					if ((restrictions & MemberLookupRestrictions.InvocableOnly) != 0) {
 						if (member is MethodSpec)
 							return new MethodGroupExpr (members, queried_type, loc);
 
 						if (!Invocation.IsMemberInvocable (member))
 							continue;
 					}
 
 					if (non_method == null || member is MethodSpec) {
 						non_method = member;
 					} else if (currentType != null) {
 						ambig_non_method = member;
 					}
 				}
 
 				if (non_method != null) {
 					if (ambig_non_method != null && rc != null) {
 						rc.Report.SymbolRelatedToPreviousError (non_method);
 						rc.Report.SymbolRelatedToPreviousError (ambig_non_method);
 						rc.Report.Error (229, loc, "Ambiguity between `{0}' and `{1}'",
 							non_method.GetSignatureForError (), ambig_non_method.GetSignatureForError ());
 					}
 
 					if (non_method is MethodSpec)
 						return new MethodGroupExpr (members, queried_type, loc);
 
 					return ExprClassFromMemberInfo (non_method, loc);
 				}
 
 				if (members[0].DeclaringType.BaseType == null)
 					members = null;
 				else
 					members = MemberCache.FindMembers (members[0].DeclaringType.BaseType, name, false);
 
 			} while (members != null);
 
 			return null;
 		}
]]></clone_fragment>
<clone_fragment endline="2040" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="14" pcid="1753" startline="1947"><![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			Block prev_block = ec.CurrentBlock;
 			bool ok = true;
 
 			ec.CurrentBlock = this;
 			ec.StartFlowBranching (this);
 
 			Report.Debug (4, "RESOLVE BLOCK", StartLocation, ec.CurrentBranching);
 
 			//
 			// Compiler generated scope statements
 			//
 			if (scope_initializers != null) {
 				for (resolving_init_idx = 0; resolving_init_idx < scope_initializers.Count; ++resolving_init_idx) {
 					scope_initializers[resolving_init_idx.Value].Resolve (ec);
 				}
 				for (resolving_init_idx = 0; resolving_init_idx < scope_initializers.Count; ++resolving_init_idx) {
 					scope_initializers[resolving_init_idx.Value].Resolve (ec);
 				}
 
 				resolving_init_idx = null;
 			}
 
 			//
 			// This flag is used to notate nested statements as unreachable from the beginning of this block.
 			// For the purposes of this resolution, it doesn't matter that the whole block is unreachable 
 			// from the beginning of the function.  The outer Resolve() that detected the unreachability is
 			// responsible for handling the situation.
 			//
 			int statement_count = statements.Count;
 			for (int ix = 0; ix < statement_count; ix++){
 				Statement s = statements [ix];
 
 				//
 				// Warn if we detect unreachable code.
 				//
 				if (unreachable) {
 					if (s is EmptyStatement)
 						continue;
 
 					if (!unreachable_shown && !(s is LabeledStatement)) {
 						ec.Report.Warning (162, 2, s.loc, "Unreachable code detected");
 						unreachable_shown = true;
 					}
 
 					Block c_block = s as Block;
 					if (c_block != null)
 						c_block.unreachable = c_block.unreachable_shown = true;
 				}
 
 				//
 				// Note that we're not using ResolveUnreachable() for unreachable
 				// statements here.  ResolveUnreachable() creates a temporary
 				// flow branching and kills it afterwards.  This leads to problems
 				// if you have two unreachable statements where the first one
 				// assigns a variable and the second one tries to access it.
 				//
 
 				if (!s.Resolve (ec)) {
 					ok = false;
 					if (ec.IsInProbingMode)
 						break;
 
 					statements [ix] = new EmptyStatement (s.loc);
 					continue;
 				}
 
 				if (unreachable && !(s is LabeledStatement) && !(s is Block))
 					statements [ix] = new EmptyStatement (s.loc);
 
 				unreachable = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 				if (unreachable && s is LabeledStatement)
 					throw new InternalErrorException ("should not happen");
 			}
 			for (int ix = 0; ix < statement_count; ix++){
 				Statement s = statements [ix];
 
 				//
 				// Warn if we detect unreachable code.
 				//
 				if (unreachable) {
 					if (s is EmptyStatement)
 						continue;
 
 					if (!unreachable_shown && !(s is LabeledStatement)) {
 						ec.Report.Warning (162, 2, s.loc, "Unreachable code detected");
 						unreachable_shown = true;
 					}
 
 					Block c_block = s as Block;
 					if (c_block != null)
 						c_block.unreachable = c_block.unreachable_shown = true;
 				}
 
 				//
 				// Note that we're not using ResolveUnreachable() for unreachable
 				// statements here.  ResolveUnreachable() creates a temporary
 				// flow branching and kills it afterwards.  This leads to problems
 				// if you have two unreachable statements where the first one
 				// assigns a variable and the second one tries to access it.
 				//
 
 				if (!s.Resolve (ec)) {
 					ok = false;
 					if (ec.IsInProbingMode)
 						break;
 
 					statements [ix] = new EmptyStatement (s.loc);
 					continue;
 				}
 
 				if (unreachable && !(s is LabeledStatement) && !(s is Block))
 					statements [ix] = new EmptyStatement (s.loc);
 
 				unreachable = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 				if (unreachable && s is LabeledStatement)
 					throw new InternalErrorException ("should not happen");
 			}
 
 			Report.Debug (4, "RESOLVE BLOCK DONE", StartLocation,
 				      ec.CurrentBranching, statement_count);
 
 			while (ec.CurrentBranching is FlowBranchingLabeled)
 				ec.EndFlowBranching ();
 			while (ec.CurrentBranching is FlowBranchingLabeled)
 				ec.EndFlowBranching ();
 
 			bool flow_unreachable = ec.EndFlowBranching ();
 
 			ec.CurrentBlock = prev_block;
 
 			if (flow_unreachable)
 				flags |= Flags.HasRet;
 
 			// If we're a non-static `struct' constructor which doesn't have an
 			// initializer, then we must initialize all of the struct's fields.
 			if (this == ParametersBlock.TopBlock && !ParametersBlock.TopBlock.IsThisAssigned (ec) && !flow_unreachable)
 				ok = false;
 
 			return ok;
 		}
]]></clone_fragment>
<clone_fragment endline="2756" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" hamdist="13" pcid="1143" startline="2653"><![CDATA[
 
 		int consume_identifier (int c, bool quoted) 
 		{
 			//
 			// This method is very performance sensitive. It accounts
 			// for approximately 25% of all parser time
 			//
 
 			int pos = 0;
 			int column = col;
 
 			if (c == '\\') {
 				int surrogate;
 				c = escape (c, out surrogate);
 				if (surrogate != 0) {
 					id_builder [pos++] = (char) c;
 					c = surrogate;
 				}
 			}
 
 			id_builder [pos++] = (char) c;
 
 			try {
 				while (true) {
 					c = reader.Read ();
 
 					if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || (c >= '0' && c <= '9')) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					if (c < 0x80) {
 						if (c == '\\') {
 							int surrogate;
 							c = escape (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									id_builder[pos++] = (char) c;
 								c = surrogate;
 							}
 
 							continue;
 						}
 					} else if (Char.IsLetter ((char) c) || Char.GetUnicodeCategory ((char) c) == UnicodeCategory.ConnectorPunctuation) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					putback_char = c;
 					break;
 				while (true) {
 					c = reader.Read ();
 
 					if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || (c >= '0' && c <= '9')) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					if (c < 0x80) {
 						if (c == '\\') {
 							int surrogate;
 							c = escape (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									id_builder[pos++] = (char) c;
 								c = surrogate;
 							}
 
 							continue;
 						}
 					} else if (Char.IsLetter ((char) c) || Char.GetUnicodeCategory ((char) c) == UnicodeCategory.ConnectorPunctuation) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					putback_char = c;
 					break;
 				}
 			} catch (IndexOutOfRangeException) {
 				Report.Error (645, Location, "Identifier too long (limit is 512 chars)");
 				--pos;
 				col += pos;
 			}
 
 			col += pos - 1;
 
 			//
 			// Optimization
 			// on uppercase letters
 			//
 			if (id_builder [0] >= '_' && !quoted) {
 				int keyword = GetKeyword (id_builder, pos);
 				if (keyword != -1) {
 					val = LocatedToken.Create (null, ref_line, column);
 					return keyword;
 				}
 			}
 
 			//
 			// Keep identifiers in an array of hashtables to avoid needless
 			// allocations
 			//
 			var identifiers_group = identifiers [pos];
 			string s;
 			if (identifiers_group != null) {
 				if (identifiers_group.TryGetValue (id_builder, out s)) {
 					val = LocatedToken.Create (s, ref_line, column);
 					if (quoted)
 						AddEscapedIdentifier (((LocatedToken) val).Location);
 					return Token.IDENTIFIER;
 				}
 			} else {
 				// TODO
 				// corlib compilation peaks at 1000 and System.Core at 150
 				int capacity = pos > 20 ? 10 
 				identifiers_group = new Dictionary<char[],string> (capacity, new IdentifiersComparer (pos));
 				identifiers [pos] = identifiers_group;
 			}
 
 			char [] chars = new char [pos];
 			Array.Copy (id_builder, chars, pos);
 
 			s = new string (id_builder, 0, pos);
 			identifiers_group.Add (chars, s);
 
 			val = LocatedToken.Create (s, ref_line, column);
 			if (quoted)
 				AddEscapedIdentifier (((LocatedToken) val).Location);
 
 			return Token.IDENTIFIER;
 		}
]]></clone_fragment>
<clone_fragment endline="1756" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" hamdist="15" pcid="5313" startline="1679"><![CDATA[
 
 		public static AnonymousTypeClass Create (CompilerContext ctx, TypeContainer parent, IList<AnonymousTypeParameter> parameters, Location loc)
 		{
 			string name = ClassNamePrefix + types_counter++;
 
 			ParametersCompiled all_parameters;
 			TypeParameterName[] t_params;
 			SimpleName[] t_args;
 
 			if (parameters.Count == 0) {
 				all_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 				t_params = new TypeParameterName[0];
 				t_args = null;
 			} else {
 				t_args = new SimpleName[parameters.Count];
 				t_params = new TypeParameterName[parameters.Count];
 				Parameter[] ctor_params = new Parameter[parameters.Count];
 				for (int i = 0; i < parameters.Count; ++i) {
 					AnonymousTypeParameter p = parameters[i];
 
 					t_args[i] = new SimpleName ("<" + p.Name + ">__T", p.Location);
 					t_params[i] = new TypeParameterName (t_args[i].Name, null, p.Location);
 					ctor_params[i] = new GeneratedParameter (t_args[i], p);
 				}
 				for (int i = 0; i < parameters.Count; ++i) {
 					AnonymousTypeParameter p = parameters[i];
 
 					t_args[i] = new SimpleName ("<" + p.Name + ">__T", p.Location);
 					t_params[i] = new TypeParameterName (t_args[i].Name, null, p.Location);
 					ctor_params[i] = new GeneratedParameter (t_args[i], p);
 				}
 
 				all_parameters = new ParametersCompiled (ctor_params);
 			}
 
 			//
 			// Create generic anonymous type host with generic arguments
 			// named upon properties names
 			//
 			AnonymousTypeClass a_type = new AnonymousTypeClass (parent.NamespaceEntry.SlaveDeclSpace,
 				new MemberName (name, new TypeArguments (t_params), loc), parameters, loc);
 
 			if (parameters.Count > 0)
 				a_type.SetParameterInfo (null);
 
 			Constructor c = new Constructor (a_type, name, Modifiers.PUBLIC | Modifiers.DEBUGGER_HIDDEN,
 				null, all_parameters, null, loc);
 			c.Block = new ToplevelBlock (ctx, c.ParameterInfo, loc);
 
 			// 
 			// Create fields and contructor body with field initialization
 			//
 			bool error = false;
 			for (int i = 0; i < parameters.Count; ++i) {
 				AnonymousTypeParameter p = parameters [i];
 
 				Field f = new Field (a_type, t_args [i], Modifiers.PRIVATE | Modifiers.READONLY,
 					new MemberName ("<" + p.Name + ">", p.Location), null);
 
 				if (!a_type.AddField (f)) {
 					error = true;
 					continue;
 				}
 
 				c.Block.AddStatement (new StatementExpression (
 					new SimpleAssign (new MemberAccess (new This (p.Location), f.Name),
 						c.Block.GetParameterReference (i, p.Location))));
 
 				ToplevelBlock get_block = new ToplevelBlock (ctx, p.Location);
 				get_block.AddStatement (new Return (
 					new MemberAccess (new This (p.Location), f.Name), p.Location));
 
 				Property prop = new Property (a_type, t_args [i], Modifiers.PUBLIC,
 					new MemberName (p.Name, p.Location), null);
 				prop.Get = new Property.GetMethod (prop, 0, null, p.Location);
 				prop.Get.Block = get_block;
 				a_type.AddProperty (prop);
 			}
 			for (int i = 0; i < parameters.Count; ++i) {
 				AnonymousTypeParameter p = parameters [i];
 
 				Field f = new Field (a_type, t_args [i], Modifiers.PRIVATE | Modifiers.READONLY,
 					new MemberName ("<" + p.Name + ">", p.Location), null);
 
 				if (!a_type.AddField (f)) {
 					error = true;
 					continue;
 				}
 
 				c.Block.AddStatement (new StatementExpression (
 					new SimpleAssign (new MemberAccess (new This (p.Location), f.Name),
 						c.Block.GetParameterReference (i, p.Location))));
 
 				ToplevelBlock get_block = new ToplevelBlock (ctx, p.Location);
 				get_block.AddStatement (new Return (
 					new MemberAccess (new This (p.Location), f.Name), p.Location));
 
 				Property prop = new Property (a_type, t_args [i], Modifiers.PUBLIC,
 					new MemberName (p.Name, p.Location), null);
 				prop.Get = new Property.GetMethod (prop, 0, null, p.Location);
 				prop.Get.Block = get_block;
 				a_type.AddProperty (prop);
 			}
 
 			if (error)
 				return null;
 
 			a_type.AddConstructor (c);
 			return a_type;
 		}
]]></clone_fragment>
<clone_fragment endline="4895" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="17" pcid="3519" startline="4833"><![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			ec.StartFlowBranching (this);
 
 			if (!Block.Resolve (ec))
 				ok = false;
 
 			TypeSpec[] prev_catches = new TypeSpec [Specific.Count];
 			int last_index = 0;
 			foreach (Catch c in Specific){
 				ec.CurrentBranching.CreateSibling (c.Block, FlowBranching.SiblingType.Catch);
 
 				if (!c.Resolve (ec)) {
 					ok = false;
 					continue;
 				}
 
 				TypeSpec resolved_type = c.CatchType;
 				for (int ii = 0; ii < last_index; ++ii) {
 					if (resolved_type == prev_catches[ii] || TypeSpec.IsBaseClass (resolved_type, prev_catches[ii], true)) {
 						ec.Report.Error (160, c.loc,
 							"A previous catch clause already catches all exceptions of this or a super type `{0}'",
 							TypeManager.CSharpName (prev_catches [ii]));
 						ok = false;
 					}
 				}
 				for (int ii = 0; ii < last_index; ++ii) {
 					if (resolved_type == prev_catches[ii] || TypeSpec.IsBaseClass (resolved_type, prev_catches[ii], true)) {
 						ec.Report.Error (160, c.loc,
 							"A previous catch clause already catches all exceptions of this or a super type `{0}'",
 							TypeManager.CSharpName (prev_catches [ii]));
 						ok = false;
 					}
 				}
 
 				prev_catches [last_index++] = resolved_type;
 			}
 			foreach (Catch c in Specific){
 				ec.CurrentBranching.CreateSibling (c.Block, FlowBranching.SiblingType.Catch);
 
 				if (!c.Resolve (ec)) {
 					ok = false;
 					continue;
 				}
 
 				TypeSpec resolved_type = c.CatchType;
 				for (int ii = 0; ii < last_index; ++ii) {
 					if (resolved_type == prev_catches[ii] || TypeSpec.IsBaseClass (resolved_type, prev_catches[ii], true)) {
 						ec.Report.Error (160, c.loc,
 							"A previous catch clause already catches all exceptions of this or a super type `{0}'",
 							TypeManager.CSharpName (prev_catches [ii]));
 						ok = false;
 					}
 				}
 
 				prev_catches [last_index++] = resolved_type;
 			}
 
 			if (General != null) {
 				foreach (Catch c in Specific) {
 					if (c.CatchType != TypeManager.exception_type)
 						continue;
 
 					if (!ec.Module.DeclaringAssembly.WrapNonExceptionThrows)
 						continue;
 
 					if (!ec.Module.PredefinedAttributes.RuntimeCompatibility.IsDefined)
 						continue;
 
 					ec.Report.Warning (1058, 1, c.loc,
 						"A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a `System.Runtime.CompilerServices.RuntimeWrappedException'");
 				}
 				foreach (Catch c in Specific) {
 					if (c.CatchType != TypeManager.exception_type)
 						continue;
 
 					if (!ec.Module.DeclaringAssembly.WrapNonExceptionThrows)
 						continue;
 
 					if (!ec.Module.PredefinedAttributes.RuntimeCompatibility.IsDefined)
 						continue;
 
 					ec.Report.Warning (1058, 1, c.loc,
 						"A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a `System.Runtime.CompilerServices.RuntimeWrappedException'");
 				}
 
 				ec.CurrentBranching.CreateSibling (General.Block, FlowBranching.SiblingType.Catch);
 
 				if (!General.Resolve (ec))
 					ok = false;
 			}
 
 			ec.EndFlowBranching ();
 
 			// System.Reflection.Emit automatically emits a 'leave' at the end of a try/catch clause
 			// So, ensure there's some IL code after this statement
 			if (!inside_try_finally && !code_follows && ec.CurrentBranching.CurrentUsageVector.IsUnreachable)
 				ec.NeedReturnLabel ();
 
 			return ok;
 		}
]]></clone_fragment>
<clone_fragment endline="910" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" hamdist="17" pcid="4303" startline="780"><![CDATA[
 
 		/// <summary>
 		/// Creates instance of SecurityAttribute class and add result of CreatePermission method to permission table.
 		/// </summary>
 		/// <returns></returns>
 		public void ExtractSecurityPermissionSet (MethodSpec ctor, ref SecurityType permissions)
 		{
 #if STATIC
 			object[] values = new object [PosArguments.Count];
 			for (int i = 0; i < values.Length; ++i)
 				values [i] = ((Constant) PosArguments [i].Expr).GetValue ();
 			for (int i = 0; i < values.Length; ++i)
 				values [i] = ((Constant) PosArguments [i].Expr).GetValue ();
 
 			PropertyInfo[] prop;
 			object[] prop_values;
 			if (named_values == null) {
 				prop = null;
 				prop_values = null;
 			} else {
 				prop = new PropertyInfo[named_values.Count];
 				prop_values = new object [named_values.Count];
 				for (int i = 0; i < prop.Length; ++i) {
 					prop [i] = ((PropertyExpr) named_values [i].Key).PropertyInfo.MetaInfo;
 					prop_values [i] = ((Constant) named_values [i].Value.Expr).GetValue ();
 				}
 				for (int i = 0; i < prop.Length; ++i) {
 					prop [i] = ((PropertyExpr) named_values [i].Key).PropertyInfo.MetaInfo;
 					prop_values [i] = ((Constant) named_values [i].Value.Expr).GetValue ();
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			var cab = new CustomAttributeBuilder ((ConstructorInfo) ctor.GetMetaInfo (), values, prop, prop_values);
 			permissions.Add (cab);
 #else
 			Type orig_assembly_type = null;
 
 			if (Type.MemberDefinition is TypeContainer) {
 				if (!RootContext.StdLib) {
 					orig_assembly_type = System.Type.GetType (Type.GetMetaInfo ().FullName);
 				} else {
 					string orig_version_path = Environment.GetEnvironmentVariable ("__SECURITY_BOOTSTRAP_DB");
 					if (orig_version_path == null) {
 						Error_AttributeEmitError ("security custom attributes can not be referenced from defining assembly");
 						return;
 					}
 
 					if (orig_sec_assembly == null) {
 						string file = Path.Combine (orig_version_path, Path.GetFileName (RootContext.OutputFile));
 						orig_sec_assembly = Assembly.LoadFile (file);
 					}
 
 					orig_assembly_type = orig_sec_assembly.GetType (Type.GetMetaInfo ().FullName, true);
 					if (orig_assembly_type == null) {
 						Report.Warning (-112, 1, Location, "Self-referenced security attribute `{0}' " +
 								"was not found in previous version of assembly");
 						return;
 					}
 				}
 			}
 
 			SecurityAttribute sa;
 			object[] args;
 
 			// For all non-selfreferencing security attributes we can avoid all hacks
 			if (orig_assembly_type == null) {
 				args = new object[PosArguments.Count];
 				for (int j = 0; j < args.Length; ++j) {
 					args[j] = ((Constant) PosArguments[j].Expr).GetValue ();
 				}
 
 				sa = (SecurityAttribute) Activator.CreateInstance (Type.GetMetaInfo (), args);
 
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						pi.SetValue (sa, ((Constant) named_values [i].Value.Expr).GetValue (), null);
 					}
 				}
 			} else {
 				// HACK
 				args = new object[] { GetSecurityActionValue () };
 				sa = (SecurityAttribute) Activator.CreateInstance (orig_assembly_type, args);
 
 				// All types are from newly created assembly but for invocation with old one we need to convert them
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo emited_pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						// FIXME
 						// TODO
 						PropertyInfo pi = orig_assembly_type.GetProperty (emited_pi.Name);
 
 						pi.SetValue (sa, ((Constant) named_values[i].Value.Expr).GetValue (), null);
 					}
 				}
 			}
 
 			IPermission perm;
 			perm = sa.CreatePermission ();
 			SecurityAction action = (SecurityAction) args [0];
 
 			// IS is correct because for corlib we are using an instance from old corlib
 			if (!(perm is System.Security.CodeAccessPermission)) {
 				switch (action) {
 				case SecurityAction.Demand
 					action = (SecurityAction)13;
 					break;
 				case SecurityAction.LinkDemand
 					action = (SecurityAction)14;
 					break;
 				case SecurityAction.InheritanceDemand
 					action = (SecurityAction)15;
 					break;
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			PermissionSet ps;
 			if (!permissions.TryGetValue (action, out ps)) {
 				if (sa is PermissionSetAttribute)
 					ps = new PermissionSet (sa.Unrestricted ? PermissionState.Unrestricted 
 				else
 					ps = new PermissionSet (PermissionState.None);
 
 				permissions.Add (action, ps);
 			} else if (!ps.IsUnrestricted () && (sa is PermissionSetAttribute) && sa.Unrestricted) {
 				ps = ps.Union (new PermissionSet (PermissionState.Unrestricted));
 				permissions [action] = ps;
 			}
 			ps.AddPermission (perm);
 #endif
 		}
]]></clone_fragment>
<clone_fragment endline="1155" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="10" pcid="4733" startline="1027"><![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			
 			if (expr == null)
 				return null;
 
 			if (expr.Type == InternalType.Dynamic) {
 				//
 				// Handle postfix unary operators using local
 				// temporary variable
 				//
 				if ((mode & Mode.IsPost) != 0)
 					expr = new DynamicPostMutator (expr);
 
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return new SimpleAssign (expr, new DynamicUnaryConversion (GetOperatorExpressionTypeName (), args, loc)).Resolve (ec);
 			}
 
 			if (TypeManager.IsNullableType (expr.Type))
 				return new Nullable.LiftedUnaryMutator (mode, expr, loc).Resolve (ec);
 
 			eclass = ExprClass.Value;
 			type = expr.Type;
 
 			if (expr is RuntimeValueExpression) {
 				operation = expr;
 			} else {
 				// Use itself at the top of the stack
 				operation = new EmptyExpression (type);
 			}
 
 			//
 			// The operand of the prefix/postfix increment decrement operators
 			// should be an expression that is classified as a variable,
 			// a property access or an indexer access
 			//
 			// TODO
 			if (expr.eclass == ExprClass.Variable || expr.eclass == ExprClass.IndexerAccess || expr.eclass == ExprClass.PropertyAccess) {
 				expr = expr.ResolveLValue (ec, expr);
 			} else {
 				ec.Report.Error (1059, loc, "The operand of an increment or decrement operator must be a variable, property or indexer");
 			}
 
 			//
 			// Step 1
 			//
 			var user_op = IsDecrement ? Operator.OpType.Decrement 
 			var methods = MemberCache.GetUserOperator (type, user_op, false);
 
 			if (methods != null) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 
 				var res = new OverloadResolver (methods, OverloadResolver.Restrictions.BaseMembersIncluded | OverloadResolver.Restrictions.NoBaseMembers, loc);
 				var method = res.ResolveOperator (ec, ref args);
 				if (method == null)
 					return null;
 
 				args[0].Expr = operation;
 				operation = new UserOperatorCall (method, args, null, loc);
 				operation = Convert.ImplicitConversionRequired (ec, operation, type, loc);
 				return this;
 			}
 
 			//
 			// Step 2
 			//
 			if (predefined == null)
 				CreatePredefinedOperators ();
 
 			// Predefined without user conversion first for speed-up
 			Expression source = null;
 			bool primitive_type = false;
 			foreach (var t in predefined) {
 				if (t == type) {
 					source = operation;
 					primitive_type = true;
 					break;
 				}
 			}
 			foreach (var t in predefined) {
 				if (t == type) {
 					source = operation;
 					primitive_type = true;
 					break;
 				}
 			}
 
 			// ++/-- on pointer variables of all types except void*
 			if (source == null && type.IsPointer) {
 				if (((PointerContainer) type).Element.BuildinType == BuildinTypeSpec.Type.Void) {
 					Error_VoidPointerOperation (ec);
 					return null;
 				}
 
 				source = operation;
 			}
 
 			if (source == null) {
 				// LAMESPEC
 				foreach (var t in predefined) {
 					source = Convert.ImplicitUserConversion (ec, operation, t, loc);
 					if (source != null) {
 						break;
 					}
 				}
 				foreach (var t in predefined) {
 					source = Convert.ImplicitUserConversion (ec, operation, t, loc);
 					if (source != null) {
 						break;
 					}
 				}
 			}
 
 			// ++/-- on enum types
 			if (source == null && type.IsEnum)
 				source = operation;
 
 			if (source == null) {
 				Unary.Error_OperatorCannotBeApplied (ec, loc, Operator.GetName (user_op), type);
 				return null;
 			}
 
 			var one = new IntConstant (1, loc);
 			var op = IsDecrement ? Binary.Operator.Subtraction 
 			operation = new Binary (op, source, one, loc);
 			operation = operation.Resolve (ec);
 			if (operation == null)
 				throw new NotImplementedException ("should not be reached");
 
 			if (operation.Type != type) {
 				if (primitive_type)
 					operation = Convert.ExplicitNumericConversion (operation, type);
 				else
 					operation = Convert.ImplicitConversionRequired (ec, operation, type, loc);
 			}
 
 			return this;
 		}
]]></clone_fragment>
<clone_fragment endline="788" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" hamdist="10" pcid="3187" startline="661"><![CDATA[
 
 		/// <summary>
 		///  Determines if a standard implicit conversion exists from
 		///  expr_type to target_type
 		///
 		/// </summary>
 		public static bool ImplicitStandardConversionExists (Expression expr, TypeSpec target_type)
 		{
 			TypeSpec expr_type = expr.Type;
 
 			NullLiteral nl = expr as NullLiteral;
 			if (nl != null)
 				return nl.ConvertImplicitly (null, target_type) != null;
 
 			if (expr_type == TypeManager.void_type)
 				return false;
 
 			if (expr_type == target_type)
 				return true;
 
 			// Implicit dynamic conversion
 			if (expr_type == InternalType.Dynamic) {
 				switch (target_type.Kind) {
 				case MemberKind.ArrayType
 				case MemberKind.Class
 				case MemberKind.Struct
 				case MemberKind.Delegate
 				case MemberKind.Enum
 				case MemberKind.Interface
 				case MemberKind.TypeParameter
 					return true;
 				}
 
 				// dynamic to __arglist
 				if (target_type == InternalType.Arglist)
 					return true;
 
 				return false;
 			}
 
 			if (TypeManager.IsNullableType (target_type)) {
 				return ImplicitNulableConversion (null, expr, target_type) != null;
 			}
 
 			// First numeric conversions
 			if (ImplicitNumericConversion (null, expr_type, target_type) != null)
 				return true;
 
 			if (ImplicitReferenceConversionExists (expr, target_type))
 				return true;
 
 			if (ImplicitBoxingConversion (null, expr_type, target_type) != null)
 				return true;
 			
 			//
 			// Implicit Constant Expression Conversions
 			//
 			if (expr is IntConstant){
 				int value = ((IntConstant) expr).Value;
 
 				if (target_type == TypeManager.sbyte_type){
 					if (value >= SByte.MinValue && value <= SByte.MaxValue)
 						return true;
 				} else if (target_type == TypeManager.byte_type){
 					if (value >= 0 && value <= Byte.MaxValue)
 						return true;
 				} else if (target_type == TypeManager.short_type){
 					if (value >= Int16.MinValue && value <= Int16.MaxValue)
 						return true;
 				} else if (target_type == TypeManager.ushort_type){
 					if (value >= UInt16.MinValue && value <= UInt16.MaxValue)
 						return true;
 				} else if (target_type == TypeManager.uint32_type){
 					if (value >= 0)
 						return true;
 				} else if (target_type == TypeManager.uint64_type){
 					 //
 					 // we can optimize this case
 					 // always fits on a uint64.  But we need an opcode
 					 // to do it.
 					 //
 					if (value >= 0)
 						return true;
 				}
 			}
 
 			if (expr is LongConstant && target_type == TypeManager.uint64_type){
 				//
 				// Try the implicit constant expression conversion
 				// from long to ulong, instead of a nice routine,
 				// we just inline it
 				//
 				long v = ((LongConstant) expr).Value;
 				if (v >= 0)
 					return true;
 			}
 
 			if (expr is IntegralConstant && TypeManager.IsEnumType (target_type)) {
 				var i = (IntegralConstant) expr;
 				//
 				// LAMESPEC
 				//
 				// An implicit enumeration conversion permits the decimal-integer-literal 0
 				// to be converted to any enum-type and to any nullable-type whose underlying
 				// type is an enum-type
 				//
 				return i.IsZeroInteger;
 			}
 
 			//
 			// If `expr_type' implements `target_type' (which is an iface)
 			// see TryImplicitIntConversion
 			//
 			if (target_type.IsInterface && expr_type.ImplementsInterface (target_type, true))
 				return true;
 
 			if (target_type.IsPointer && expr_type.IsPointer && ((PointerContainer) target_type).Element.BuildinType == BuildinTypeSpec.Type.Void)
 				return true;
 
 			// Conversion from __arglist to System.ArgIterator
 			if (expr_type == InternalType.Arglist)
 				return target_type == TypeManager.arg_iterator_type;
 
 			if (TypeSpecComparer.IsEqual (expr_type, target_type))
 				return true;
 
 			return false;
 		}
]]></clone_fragment>
<clone_fragment endline="2842" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="10" pcid="2345" startline="2743"><![CDATA[
 
 		public bool ResolveInstanceExpression (ResolveContext rc, Expression rhs)
 		{
 			if (IsStatic) {
 				if (InstanceExpression != null) {
 					if (InstanceExpression is TypeExpr) {
 						var t = InstanceExpression.Type;
 						do {
 							ObsoleteAttribute oa = t.GetAttributeObsolete ();
 							if (oa != null && !rc.IsObsolete) {
 								AttributeTester.Report_ObsoleteMessage (oa, t.GetSignatureForError (), loc, rc.Report);
 							}
 
 							t = t.DeclaringType;
 						} while (t != null);
 					} else {
 						var runtime_expr = InstanceExpression as RuntimeValueExpression;
 						if (runtime_expr == null || !runtime_expr.IsSuggestionOnly) {
 							rc.Report.Error (176, loc,
 								"Static member `{0}' cannot be accessed with an instance reference, qualify it with a type name instead",
 								GetSignatureForError ());
 						}
 					}
 
 					InstanceExpression = null;
 				}
 
 				return false;
 			}
 
 			if (InstanceExpression == null || InstanceExpression is TypeExpr) {
 				if (InstanceExpression != null || !This.IsThisAvailable (rc, true)) {
 					if (rc.HasSet (ResolveContext.Options.FieldInitializerScope))
 						rc.Report.Error (236, loc,
 							"A field initializer cannot reference the nonstatic field, method, or property `{0}'",
 							GetSignatureForError ());
 					else
 						rc.Report.Error (120, loc,
 							"An object reference is required to access non-static member `{0}'",
 							GetSignatureForError ());
 
 					return false;
 				}
 
 				if (!TypeManager.IsFamilyAccessible (rc.CurrentType, DeclaringType)) {
 					rc.Report.Error (38, loc,
 						"Cannot access a nonstatic member of outer type `{0}' via nested type `{1}'",
 						DeclaringType.GetSignatureForError (), rc.CurrentType.GetSignatureForError ());
 				}
 
 				InstanceExpression = new This (loc);
 				if (this is FieldExpr && rc.CurrentType.IsStruct) {
 					using (rc.Set (ResolveContext.Options.OmitStructFlowAnalysis)) {
 						InstanceExpression = InstanceExpression.Resolve (rc);
 					}
 				} else {
 					InstanceExpression = InstanceExpression.Resolve (rc);
 				}
 
 				return false;
 			}
 
 			var me = InstanceExpression as MemberExpr;
 			if (me != null) {
 				me.ResolveInstanceExpression (rc, rhs);
 
 				var fe = me as FieldExpr;
 				if (fe != null && fe.IsMarshalByRefAccess ()) {
 					rc.Report.SymbolRelatedToPreviousError (me.DeclaringType);
 					rc.Report.Warning (1690, 1, loc,
 						"Cannot call methods, properties, or indexers on `{0}' because it is a value type member of a marshal-by-reference class",
 						me.GetSignatureForError ());
 				}
 
 				return true;
 			}
 
 			//
 			// Run member-access postponed check once we know that
 			// the expression is not field expression which is the only
 			// expression which can use uninitialized this
 			//
 			if (InstanceExpression is This && !(this is FieldExpr) && rc.CurrentType.IsStruct) {
 				((This)InstanceExpression).CheckStructThisDefiniteAssignment (rc);
 			}
 
 			//
 			// Additional checks for l-value member access
 			//
 			if (rhs != null) {
 				//
 				// TODO
 				//
 				if (InstanceExpression is UnboxCast) {
 					rc.Report.Error (445, InstanceExpression.Location, "Cannot modify the result of an unboxing conversion");
 				}
 			}
 
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="1240" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Helper.vb" hamdist="20" pcid="7607" startline="1108"><![CDATA[
 
     ''' <summary>
     ''' Emits the instanceexpression (if any), the arguments (if any), the optional arguments (if any) and then calls the method (virt or not).
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="InstanceExpression"></param>
     ''' <param name="Arguments"></param>
     ''' <param name="Method"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitArgumentsAndCallOrCallVirt(ByVal Info As EmitInfo, ByVal InstanceExpression As Expression, ByVal Arguments As ArgumentList, ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim result As Boolean = True
         Dim needsConstrained As Boolean
         Dim constrainedLocal As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         needsConstrained = InstanceExpression IsNot Nothing AndAlso CecilHelper.IsGenericParameter(InstanceExpression.ExpressionType)
 
         Helper.Assert(Method IsNot Nothing)
 
         If InstanceExpression IsNot Nothing AndAlso CecilHelper.FindDefinition(Method).IsStatic = False Then
             Dim ieDesiredType As Mono.Cecil.TypeReference
             Dim ieInfo As EmitInfo
 
             If needsConstrained Then
                 ieDesiredType = InstanceExpression.ExpressionType
             Else
                 ieDesiredType = Method.DeclaringType
                 If CecilHelper.IsValueType(ieDesiredType) Then
                     ieDesiredType = Info.Compiler.TypeManager.MakeByRefType(CType(Info.Method, ParsedObject), ieDesiredType)
                 End If
             End If
 
             ieInfo = Info.Clone(Info.Context, True, False, ieDesiredType)
 
             Dim derefExp As DeRefExpression = TryCast(InstanceExpression, DeRefExpression)
             If needsConstrained AndAlso derefExp IsNot Nothing Then
                 result = derefExp.Expression.GenerateCode(Info.Clone(Info.Context, True, False, derefExp.Expression.ExpressionType)) AndAlso result
             Else
                 Dim getRef As GetRefExpression = TryCast(InstanceExpression, GetRefExpression)
                 If getRef IsNot Nothing AndAlso CecilHelper.IsValueType(getRef.Expression.ExpressionType) AndAlso Helper.CompareType(Method.DeclaringType, Info.Compiler.TypeCache.System_Object) Then
                     result = getRef.Expression.GenerateCode(ieInfo) AndAlso result
                     Emitter.EmitBox(Info, getRef.Expression.ExpressionType)
                 Else
                     result = InstanceExpression.GenerateCode(ieInfo) AndAlso result
                 End If
 
                 If needsConstrained Then
                     constrainedLocal = Emitter.DeclareLocal(Info, InstanceExpression.ExpressionType)
                     Emitter.EmitStoreVariable(Info, constrainedLocal)
                     Emitter.EmitLoadVariableLocation(Info, constrainedLocal)
                 End If
             End If
 
         End If
 
         Dim copyBacksA As Generic.List(Of Mono.Cecil.Cil.VariableDefinition) = Nothing
         Dim copyBacksB As Generic.List(Of Expression) = Nothing
 
         If Arguments IsNot Nothing Then
             Dim methodParameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)
             methodParameters = Helper.GetParameters(Info.Compiler, Method)
 
             For i As Integer = 0 To methodParameters.Count - 1
                 Dim arg As Argument
                 Dim exp As Expression
                 Dim local As Mono.Cecil.Cil.VariableDefinition
                 Dim propAccess As PropertyAccessClassification
 
                 If CecilHelper.IsByRef(methodParameters(i).ParameterType) = False Then Continue For
 
                 arg = Arguments.Arguments(i)
                 exp = arg.Expression
 
                 If exp Is Nothing Then Continue For
 
                 If exp.Classification Is Nothing Then Continue For
                 If exp.Classification.IsPropertyAccessClassification = False Then Continue For
 
                 propAccess = exp.Classification.AsPropertyAccess
 
                 If copyBacksA Is Nothing Then
                     copyBacksA = New Generic.List(Of Mono.Cecil.Cil.VariableDefinition)
                     copyBacksB = New Generic.List(Of Expression)
                 End If
                 local = Emitter.DeclareLocal(Info, CecilHelper.GetElementType(methodParameters(i).ParameterType))
                 copyBacksA.Add(local)
                 If CecilHelper.FindDefinition(propAccess.Property).SetMethod Is Nothing Then
                     copyBacksB.Add(Nothing)
                 Else
                     copyBacksB.Add(exp)
                 End If
 
                 result = arg.GenerateCode(Info, methodParameters(i)) AndAlso result
                 Emitter.EmitStoreVariable(Info, local)
                 arg.Expression = New LoadLocalExpression(arg, local)
             Next
 
             result = Arguments.GenerateCode(Info, methodParameters) AndAlso result
         End If
 
         If needsConstrained Then
             Emitter.EmitConstrainedCallVirt(Info, Method, InstanceExpression.ExpressionType)
         ElseIf InstanceExpression IsNot Nothing AndAlso (TypeOf InstanceExpression Is MyClassExpression OrElse TypeOf InstanceExpression Is MyBaseExpression) Then
             Emitter.EmitCall(Info, Method)
         Else
             Emitter.EmitCallOrCallVirt(Info, Method)
         End If
 
         If copyBacksA IsNot Nothing Then
             For i As Integer = 0 To copyBacksA.Count - 1
                 Dim local As Mono.Cecil.Cil.VariableDefinition = copyBacksA(i)
                 Dim exp As Expression = copyBacksB(i)
 
                 If exp Is Nothing Then Continue For
 
                 result = exp.GenerateCode(Info.Clone(Info.Context, New LoadLocalExpression(exp, local))) AndAlso result
             Next
         End If
 
         If constrainedLocal IsNot Nothing Then
             Emitter.FreeLocal(constrainedLocal)
         End If
 
         If Info.DesiredType IsNot Nothing AndAlso CecilHelper.IsByRef(Info.DesiredType) Then
             Dim tmp As Mono.Cecil.Cil.VariableDefinition
             tmp = Emitter.DeclareLocal(Info, CecilHelper.GetElementType(Info.DesiredType))
             Emitter.EmitStoreVariable(Info, tmp)
             Emitter.EmitLoadVariableLocation(Info, tmp)
             Emitter.FreeLocal(tmp)
         End If
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1009" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" hamdist="20" pcid="2157" startline="939"><![CDATA[
 
 		//
 		// Checks that some operators come in pairs
 		//  == and !=
 		// > and <
 		// >= and <=
 		// true and false
 		//
 		// They are matched based on the return type and the argument types
 		//
 		void CheckPairedOperators ()
 		{
 			bool has_equality_or_inequality = false;
 			var operators = this.operators.ToArray ();
 			bool[] has_pair = new bool[operators.Length];
 
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null)
 					continue;
 
 				Operator o_a = (Operator) operators[i];
 				Operator.OpType o_type = o_a.OperatorType;
 				if (o_type == Operator.OpType.Equality || o_type == Operator.OpType.Inequality)
 					has_equality_or_inequality = true;
 
 				Operator.OpType matching_type = o_a.GetMatchingOperator ();
 				if (matching_type == Operator.OpType.TOP) {
 					operators[i] = null;
 					continue;
 				}
 
 				for (int ii = 0; ii < operators.Length; ++ii) {
 					Operator o_b = (Operator) operators[ii];
 					if (o_b == null || o_b.OperatorType != matching_type)
 						continue;
 
 					if (!TypeSpecComparer.IsEqual (o_a.ReturnType, o_b.ReturnType))
 						continue;
 
 					if (!TypeSpecComparer.Equals (o_a.ParameterTypes, o_b.ParameterTypes))
 						continue;
 
 					operators[i] = null;
 
 					//
 					// Used to ignore duplicate user conversions
 					//
 					has_pair[ii] = true;
 				}
 				for (int ii = 0; ii < operators.Length; ++ii) {
 					Operator o_b = (Operator) operators[ii];
 					if (o_b == null || o_b.OperatorType != matching_type)
 						continue;
 
 					if (!TypeSpecComparer.IsEqual (o_a.ReturnType, o_b.ReturnType))
 						continue;
 
 					if (!TypeSpecComparer.Equals (o_a.ParameterTypes, o_b.ParameterTypes))
 						continue;
 
 					operators[i] = null;
 
 					//
 					// Used to ignore duplicate user conversions
 					//
 					has_pair[ii] = true;
 				}
 			}
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null)
 					continue;
 
 				Operator o_a = (Operator) operators[i];
 				Operator.OpType o_type = o_a.OperatorType;
 				if (o_type == Operator.OpType.Equality || o_type == Operator.OpType.Inequality)
 					has_equality_or_inequality = true;
 
 				Operator.OpType matching_type = o_a.GetMatchingOperator ();
 				if (matching_type == Operator.OpType.TOP) {
 					operators[i] = null;
 					continue;
 				}
 
 				for (int ii = 0; ii < operators.Length; ++ii) {
 					Operator o_b = (Operator) operators[ii];
 					if (o_b == null || o_b.OperatorType != matching_type)
 						continue;
 
 					if (!TypeSpecComparer.IsEqual (o_a.ReturnType, o_b.ReturnType))
 						continue;
 
 					if (!TypeSpecComparer.Equals (o_a.ParameterTypes, o_b.ParameterTypes))
 						continue;
 
 					operators[i] = null;
 
 					//
 					// Used to ignore duplicate user conversions
 					//
 					has_pair[ii] = true;
 				}
 			}
 
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null || has_pair[i])
 					continue;
 
 				Operator o = (Operator) operators [i];
 				Report.Error (216, o.Location,
 					"The operator `{0}' requires a matching operator `{1}' to also be defined",
 					o.GetSignatureForError (), Operator.GetName (o.GetMatchingOperator ()));
 			}
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null || has_pair[i])
 					continue;
 
 				Operator o = (Operator) operators [i];
 				Report.Error (216, o.Location,
 					"The operator `{0}' requires a matching operator `{1}' to also be defined",
 					o.GetSignatureForError (), Operator.GetName (o.GetMatchingOperator ()));
 			}
 
 			if (has_equality_or_inequality) {
 				if (Methods == null || !HasEquals)
 					Report.Warning (660, 2, Location, "`{0}' defines operator == or operator != but does not override Object.Equals(object o)",
 						GetSignatureForError ());
 
 				if (Methods == null || !HasGetHashCode)
 					Report.Warning (661, 2, Location, "`{0}' defines operator == or operator != but does not override Object.GetHashCode()",
 						GetSignatureForError ());
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="803" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" hamdist="14" pcid="203" startline="709"><![CDATA[
 
 		//
 		// Returns all not implememted abstract members inside abstract type
 		// NOTE
 		//
 		public static IList<MethodSpec> GetNotImplementedAbstractMethods (TypeSpec type)
 		{
 			if (type.MemberCache.missing_abstract != null)
 				return type.MemberCache.missing_abstract;
 				
 			var abstract_methods = new List<MethodSpec> ();
 			List<TypeSpec> hierarchy = null;
 
 			//
 			// Stage 1
 			//
 			var abstract_type = type;
 			while (true) {
 				foreach (var entry in abstract_type.MemberCache.member_hash) {
 					foreach (var name_entry in entry.Value) {
 						if ((name_entry.Modifiers & Modifiers.ABSTRACT) == 0)
 							continue;
 
 						if (name_entry.Kind != MemberKind.Method)
 							continue;
 
 						abstract_methods.Add ((MethodSpec) name_entry);
 					}
 					foreach (var name_entry in entry.Value) {
 						if ((name_entry.Modifiers & Modifiers.ABSTRACT) == 0)
 							continue;
 
 						if (name_entry.Kind != MemberKind.Method)
 							continue;
 
 						abstract_methods.Add ((MethodSpec) name_entry);
 					}
 				}
 				foreach (var entry in abstract_type.MemberCache.member_hash) {
 					foreach (var name_entry in entry.Value) {
 						if ((name_entry.Modifiers & Modifiers.ABSTRACT) == 0)
 							continue;
 
 						if (name_entry.Kind != MemberKind.Method)
 							continue;
 
 						abstract_methods.Add ((MethodSpec) name_entry);
 					}
 				}
 
 				var base_type = abstract_type.BaseType;
 				if (!base_type.IsAbstract)
 					break;
 
 				if (hierarchy == null)
 					hierarchy = new List<TypeSpec> ();
 
 				hierarchy.Add (abstract_type);
 				abstract_type = base_type;
 			}
 			while (true) {
 				foreach (var entry in abstract_type.MemberCache.member_hash) {
 					foreach (var name_entry in entry.Value) {
 						if ((name_entry.Modifiers & Modifiers.ABSTRACT) == 0)
 							continue;
 
 						if (name_entry.Kind != MemberKind.Method)
 							continue;
 
 						abstract_methods.Add ((MethodSpec) name_entry);
 					}
 				}
 
 				var base_type = abstract_type.BaseType;
 				if (!base_type.IsAbstract)
 					break;
 
 				if (hierarchy == null)
 					hierarchy = new List<TypeSpec> ();
 
 				hierarchy.Add (abstract_type);
 				abstract_type = base_type;
 			}
 
 			int not_implemented_count = abstract_methods.Count;
 			if (not_implemented_count == 0 || hierarchy == null) {
 				type.MemberCache.missing_abstract = abstract_methods;
 				return type.MemberCache.missing_abstract;
 			}
 
 			//
 			// Stage 2
 			//
 			foreach (var type_up in hierarchy) {
 				var members = type_up.MemberCache.member_hash;
 				if (members.Count == 0)
 					continue;
 
 				for (int i = 0; i < abstract_methods.Count; ++i) {
 					var candidate = abstract_methods [i];
 					if (candidate == null)
 						continue;
 
 					IList<MemberSpec> applicable;
 					if (!members.TryGetValue (candidate.Name, out applicable))
 						continue;
 
 					var filter = new MemberFilter (candidate);
 					foreach (var item in applicable) {
 						if ((item.Modifiers & (Modifiers.OVERRIDE | Modifiers.VIRTUAL)) == 0)
 							continue;
 
 						if (filter.Equals (item)) {
 							--not_implemented_count;
 							abstract_methods [i] = null;
 							break;
 						}
 					}
 					foreach (var item in applicable) {
 						if ((item.Modifiers & (Modifiers.OVERRIDE | Modifiers.VIRTUAL)) == 0)
 							continue;
 
 						if (filter.Equals (item)) {
 							--not_implemented_count;
 							abstract_methods [i] = null;
 							break;
 						}
 					}
 				}
 				for (int i = 0; i < abstract_methods.Count; ++i) {
 					var candidate = abstract_methods [i];
 					if (candidate == null)
 						continue;
 
 					IList<MemberSpec> applicable;
 					if (!members.TryGetValue (candidate.Name, out applicable))
 						continue;
 
 					var filter = new MemberFilter (candidate);
 					foreach (var item in applicable) {
 						if ((item.Modifiers & (Modifiers.OVERRIDE | Modifiers.VIRTUAL)) == 0)
 							continue;
 
 						if (filter.Equals (item)) {
 							--not_implemented_count;
 							abstract_methods [i] = null;
 							break;
 						}
 					}
 				}
 			}
 			foreach (var type_up in hierarchy) {
 				var members = type_up.MemberCache.member_hash;
 				if (members.Count == 0)
 					continue;
 
 				for (int i = 0; i < abstract_methods.Count; ++i) {
 					var candidate = abstract_methods [i];
 					if (candidate == null)
 						continue;
 
 					IList<MemberSpec> applicable;
 					if (!members.TryGetValue (candidate.Name, out applicable))
 						continue;
 
 					var filter = new MemberFilter (candidate);
 					foreach (var item in applicable) {
 						if ((item.Modifiers & (Modifiers.OVERRIDE | Modifiers.VIRTUAL)) == 0)
 							continue;
 
 						if (filter.Equals (item)) {
 							--not_implemented_count;
 							abstract_methods [i] = null;
 							break;
 						}
 					}
 				}
 			}
 
 			if (not_implemented_count == abstract_methods.Count) {
 				type.MemberCache.missing_abstract = abstract_methods;
 				return type.MemberCache.missing_abstract;
 			}
 
 			var not_implemented = new MethodSpec[not_implemented_count];
 			int counter = 0;
 			foreach (var m in abstract_methods) {
 				if (m == null)
 					continue;
 
 				not_implemented[counter++] = m;
 			}
 			foreach (var m in abstract_methods) {
 				if (m == null)
 					continue;
 
 				not_implemented[counter++] = m;
 			}
 
 			type.MemberCache.missing_abstract = not_implemented;
 			return type.MemberCache.missing_abstract;
 		}
]]></clone_fragment>
<clone_fragment endline="3433" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="13" pcid="3749" startline="3360"><![CDATA[
 
 		//
 		// Build-in operators method overloading
 		//
 		protected virtual Expression ResolveOperatorPredefined (ResolveContext ec, PredefinedOperator [] operators, bool primitives_only, TypeSpec enum_type)
 		{
 			PredefinedOperator best_operator = null;
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Operator oper_mask = oper & ~Operator.ValuesOnlyMask;
 
 			foreach (PredefinedOperator po in operators) {
 				if ((po.OperatorsMask & oper_mask) == 0)
 					continue;
 
 				if (primitives_only) {
 					if (!po.IsPrimitiveApplicable (l, r))
 						continue;
 				} else {
 					if (!po.IsApplicable (ec, left, right))
 						continue;
 				}
 
 				if (best_operator == null) {
 					best_operator = po;
 					if (primitives_only)
 						break;
 
 					continue;
 				}
 
 				best_operator = po.ResolveBetterOperator (ec, best_operator);
 
 				if (best_operator == null) {
 					ec.Report.Error (34, loc, "Operator `{0}' is ambiguous on operands of type `{1}' and `{2}'",
 						OperName (oper), TypeManager.CSharpName (l), TypeManager.CSharpName (r));
 
 					best_operator = po;
 					break;
 				}
 			}
 			foreach (PredefinedOperator po in operators) {
 				if ((po.OperatorsMask & oper_mask) == 0)
 					continue;
 
 				if (primitives_only) {
 					if (!po.IsPrimitiveApplicable (l, r))
 						continue;
 				} else {
 					if (!po.IsApplicable (ec, left, right))
 						continue;
 				}
 
 				if (best_operator == null) {
 					best_operator = po;
 					if (primitives_only)
 						break;
 
 					continue;
 				}
 
 				best_operator = po.ResolveBetterOperator (ec, best_operator);
 
 				if (best_operator == null) {
 					ec.Report.Error (34, loc, "Operator `{0}' is ambiguous on operands of type `{1}' and `{2}'",
 						OperName (oper), TypeManager.CSharpName (l), TypeManager.CSharpName (r));
 
 					best_operator = po;
 					break;
 				}
 			}
 
 			if (best_operator == null)
 				return null;
 
 			Expression expr = best_operator.ConvertResult (ec, this);
 
 			//
 			// Optimize &/&& constant expressions with 0 value
 			//
 			if (oper == Operator.BitwiseAnd || oper == Operator.LogicalAnd) {
 				Constant rc = right as Constant;
 				Constant lc = left as Constant;
 				if (((lc != null && lc.IsDefaultValue) || (rc != null && rc.IsDefaultValue)) && !(this is Nullable.LiftedBinaryOperator)) {
 					//
 					// The result is a constant with side-effect
 					//
 					Constant side_effect = rc == null ?
 						new SideEffectConstant (lc, right, loc) 
 						new SideEffectConstant (rc, left, loc);
 
 					return ReducedExpression.Create (side_effect.Resolve (ec), expr);
 				}
 			}
 
 			if (enum_type == null)
 				return expr;
 
 			//
 			// HACK
 			//
 			expr.Type = enum_type;
 			return EmptyCast.Create (expr, enum_type);
 		}
]]></clone_fragment>
<clone_fragment endline="3714" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="15" pcid="1663" startline="3542"><![CDATA[
 
 		/// <summary>
 		///   Determines "Better function" between candidate
 		///   and the current best match
 		/// </summary>
 		/// <remarks>
 		///    Returns a boolean indicating 
 		///     false if candidate ain't better
 		///     true  if candidate is better than the current best match
 		/// </remarks>
 		static bool BetterFunction (ResolveContext ec, Arguments args, MemberSpec candidate, AParametersCollection cparam, bool candidate_params,
 			MemberSpec best, AParametersCollection bparam, bool best_params)
 		{
 			AParametersCollection candidate_pd = ((IParametersMember) candidate).Parameters;
 			AParametersCollection best_pd = ((IParametersMember) best).Parameters;
 
 			bool better_at_least_one = false;
 			bool same = true;
 			int args_count = args == null ? 0 
 			int j = 0;
 			Argument a = null;
 			TypeSpec ct, bt;
 			for (int c_idx = 0, b_idx = 0; j < args_count; ++j, ++c_idx, ++b_idx) {
 				a = args[j];
 
 				// Default arguments are ignored for better decision
 				if (a.IsDefaultArgument)
 					break;
 
 				//
 				// When comparing named argument the parameter type index has to be looked up
 				// in original parameter set (override version for virtual members)
 				//
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int idx = cparam.GetParameterIndexByName (na.Name);
 					ct = candidate_pd.Types[idx];
 					if (candidate_params && candidate_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						ct = TypeManager.GetElementType (ct);
 
 					idx = bparam.GetParameterIndexByName (na.Name);
 					bt = best_pd.Types[idx];
 					if (best_params && best_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						bt = TypeManager.GetElementType (bt);
 				} else {
 					ct = candidate_pd.Types[c_idx];
 					bt = best_pd.Types[b_idx];
 
 					if (candidate_params && candidate_pd.FixedParameters[c_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						ct = TypeManager.GetElementType (ct);
 						--c_idx;
 					}
 
 					if (best_params && best_pd.FixedParameters[b_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						bt = TypeManager.GetElementType (bt);
 						--b_idx;
 					}
 				}
 
 				if (TypeSpecComparer.IsEqual (ct, bt))
 					continue;
 
 				same = false;
 				int result = BetterExpressionConversion (ec, a, ct, bt);
 
 				// for each argument, the conversion to 'ct' should be no worse than 
 				// the conversion to 'bt'.
 				if (result == 2)
 					return false;
 
 				// for at least one argument, the conversion to 'ct' should be better than 
 				// the conversion to 'bt'.
 				if (result != 0)
 					better_at_least_one = true;
 			}
 			for (int c_idx = 0, b_idx = 0; j < args_count; ++j, ++c_idx, ++b_idx) {
 				a = args[j];
 
 				// Default arguments are ignored for better decision
 				if (a.IsDefaultArgument)
 					break;
 
 				//
 				// When comparing named argument the parameter type index has to be looked up
 				// in original parameter set (override version for virtual members)
 				//
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int idx = cparam.GetParameterIndexByName (na.Name);
 					ct = candidate_pd.Types[idx];
 					if (candidate_params && candidate_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						ct = TypeManager.GetElementType (ct);
 
 					idx = bparam.GetParameterIndexByName (na.Name);
 					bt = best_pd.Types[idx];
 					if (best_params && best_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						bt = TypeManager.GetElementType (bt);
 				} else {
 					ct = candidate_pd.Types[c_idx];
 					bt = best_pd.Types[b_idx];
 
 					if (candidate_params && candidate_pd.FixedParameters[c_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						ct = TypeManager.GetElementType (ct);
 						--c_idx;
 					}
 
 					if (best_params && best_pd.FixedParameters[b_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						bt = TypeManager.GetElementType (bt);
 						--b_idx;
 					}
 				}
 
 				if (TypeSpecComparer.IsEqual (ct, bt))
 					continue;
 
 				same = false;
 				int result = BetterExpressionConversion (ec, a, ct, bt);
 
 				// for each argument, the conversion to 'ct' should be no worse than 
 				// the conversion to 'bt'.
 				if (result == 2)
 					return false;
 
 				// for at least one argument, the conversion to 'ct' should be better than 
 				// the conversion to 'bt'.
 				if (result != 0)
 					better_at_least_one = true;
 			}
 
 			if (better_at_least_one)
 				return true;
 
 			//
 			// This handles the case
 			//
 			//   Add (float f1, float f2, float f3);
 			//   Add (params decimal [] foo);
 			//
 			// The call Add (3, 4, 5) should be ambiguous.  Without this check, the
 			// first candidate would've chosen as better.
 			//
 			if (!same && !a.IsDefaultArgument)
 				return false;
 
 			//
 			// The two methods have equal non-optional parameter types, apply tie-breaking rules
 			//
 
 			//
 			// This handles the following cases
 			//
 			//  Foo (int i) is better than Foo (int i, long l = 0)
 			//  Foo (params int[] args) is better than Foo (int i = 0, params int[] args)
 			//
 			// Prefer non-optional version
 			//
 			// LAMESPEC
 			//
 			if (candidate_params == best_params && candidate_pd.Count != best_pd.Count) {
 				if (candidate_pd.Count >= best_pd.Count)
 					return false;
 
 				if (j < candidate_pd.Count && candidate_pd.FixedParameters[j].HasDefaultValue)
 					return false;
 
 				return true;
 			}
 
 			//
 			// One is a non-generic method and second is a generic method, then non-generic is better
 			//
 			if (best.IsGeneric != candidate.IsGeneric)
 				return best.IsGeneric;
 
 			//
 			// This handles the following cases
 			//
 			//   Trim () is better than Trim (params char[] chars)
 			//   Concat (string s1, string s2, string s3) is better than
 			//     Concat (string s1, params string [] srest)
 			//   Foo (int, params int [] rest) is better than Foo (params int [] rest)
 			//
 			// Prefer non-expanded version
 			//
 			if (candidate_params != best_params)
 				return best_params;
 
 			int candidate_param_count = candidate_pd.Count;
 			int best_param_count = best_pd.Count;
 
 			if (candidate_param_count != best_param_count)
 				// can only happen if (candidate_params && best_params)
 				return candidate_param_count > best_param_count && best_pd.HasParams;
 
 			//
 			// Both methods have the same number of parameters, and the parameters have equal types
 			// Pick the "more specific" signature using rules over original (non-inflated) types
 			//
 			var candidate_def_pd = ((IParametersMember) candidate.MemberDefinition).Parameters;
 			var best_def_pd = ((IParametersMember) best.MemberDefinition).Parameters;
 
 			bool specific_at_least_once = false;
 			for (j = 0; j < args_count; ++j) {
 				NamedArgument na = args_count == 0 ? null 
 				if (na != null) {
 					ct = candidate_def_pd.Types[cparam.GetParameterIndexByName (na.Name)];
 					bt = best_def_pd.Types[bparam.GetParameterIndexByName (na.Name)];
 				} else {
 					ct = candidate_def_pd.Types[j];
 					bt = best_def_pd.Types[j];
 				}
 
 				if (ct == bt)
 					continue;
 				TypeSpec specific = MoreSpecific (ct, bt);
 				if (specific == bt)
 					return false;
 				if (specific == ct)
 					specific_at_least_once = true;
 			}
 			for (j = 0; j < args_count; ++j) {
 				NamedArgument na = args_count == 0 ? null 
 				if (na != null) {
 					ct = candidate_def_pd.Types[cparam.GetParameterIndexByName (na.Name)];
 					bt = best_def_pd.Types[bparam.GetParameterIndexByName (na.Name)];
 				} else {
 					ct = candidate_def_pd.Types[j];
 					bt = best_def_pd.Types[j];
 				}
 
 				if (ct == bt)
 					continue;
 				TypeSpec specific = MoreSpecific (ct, bt);
 				if (specific == bt)
 					return false;
 				if (specific == ct)
 					specific_at_least_once = true;
 			}
 
 			if (specific_at_least_once)
 				return true;
 
 			return false;
 		}
]]></clone_fragment>
<clone_fragment endline="1225" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" hamdist="14" pcid="2163" startline="1137"><![CDATA[
 
 		bool DefineBaseTypes ()
 		{
 			iface_exprs = ResolveBaseTypes (out base_type_expr);
 			if (partial_parts != null) {
 				iface_exprs = GetNormalPartialBases ();
 			}
 
 			var cycle = CheckRecursiveDefinition (this);
 			if (cycle != null) {
 				Report.SymbolRelatedToPreviousError (cycle);
 				if (this is Interface) {
 					Report.Error (529, Location,
 						"Inherited interface `{0}' causes a cycle in the interface hierarchy of `{1}'",
 					    GetSignatureForError (), cycle.GetSignatureForError ());
 
 					iface_exprs = null;
 				} else {
 					Report.Error (146, Location,
 						"Circular base class dependency involving `{0}' and `{1}'",
 						GetSignatureForError (), cycle.GetSignatureForError ());
 
 					base_type = null;
 				}
 			}
 
 			if (iface_exprs != null) {
 				foreach (TypeExpr iface in iface_exprs) {
 					// Prevents a crash, the interface might not have been resolved
 					if (iface == null)
 						continue;
 					
 					var iface_type = iface.Type;
 
 					if (!spec.AddInterface (iface_type))
 						continue;
 
 					if (iface_type.IsGeneric && spec.Interfaces != null) {
 						foreach (var prev_iface in iface_exprs) {
 							if (prev_iface == iface)
 								break;
 
 							if (!TypeSpecComparer.Unify.IsEqual (iface_type, prev_iface.Type))
 								continue;
 
 							Report.Error (695, Location,
 								"`{0}' cannot implement both `{1}' and `{2}' because they may unify for some type parameter substitutions",
 								GetSignatureForError (), prev_iface.GetSignatureForError (), iface_type.GetSignatureForError ());
 						}
 						foreach (var prev_iface in iface_exprs) {
 							if (prev_iface == iface)
 								break;
 
 							if (!TypeSpecComparer.Unify.IsEqual (iface_type, prev_iface.Type))
 								continue;
 
 							Report.Error (695, Location,
 								"`{0}' cannot implement both `{1}' and `{2}' because they may unify for some type parameter substitutions",
 								GetSignatureForError (), prev_iface.GetSignatureForError (), iface_type.GetSignatureForError ());
 						}
 					}
 
 					TypeBuilder.AddInterfaceImplementation (iface_type.GetMetaInfo ());
 
 					// Ensure the base is always setup
 					var compiled_iface = iface_type.MemberDefinition as Interface;
 					if (compiled_iface != null) {
 						// TODO
 						compiled_iface.DefineType ();
 					}
 
 					if (iface_type.Interfaces != null) {
 						var base_ifaces = new List<TypeSpec> (iface_type.Interfaces);
 						for (int i = 0; i < base_ifaces.Count; ++i) {
 							var ii_iface_type = base_ifaces[i];
 							if (spec.AddInterface (ii_iface_type)) {
 								TypeBuilder.AddInterfaceImplementation (ii_iface_type.GetMetaInfo ());
 
 								if (ii_iface_type.Interfaces != null)
 									base_ifaces.AddRange (ii_iface_type.Interfaces);
 							}
 						}
 						for (int i = 0; i < base_ifaces.Count; ++i) {
 							var ii_iface_type = base_ifaces[i];
 							if (spec.AddInterface (ii_iface_type)) {
 								TypeBuilder.AddInterfaceImplementation (ii_iface_type.GetMetaInfo ());
 
 								if (ii_iface_type.Interfaces != null)
 									base_ifaces.AddRange (ii_iface_type.Interfaces);
 							}
 						}
 					}
 				}
 				foreach (TypeExpr iface in iface_exprs) {
 					// Prevents a crash, the interface might not have been resolved
 					if (iface == null)
 						continue;
 					
 					var iface_type = iface.Type;
 
 					if (!spec.AddInterface (iface_type))
 						continue;
 
 					if (iface_type.IsGeneric && spec.Interfaces != null) {
 						foreach (var prev_iface in iface_exprs) {
 							if (prev_iface == iface)
 								break;
 
 							if (!TypeSpecComparer.Unify.IsEqual (iface_type, prev_iface.Type))
 								continue;
 
 							Report.Error (695, Location,
 								"`{0}' cannot implement both `{1}' and `{2}' because they may unify for some type parameter substitutions",
 								GetSignatureForError (), prev_iface.GetSignatureForError (), iface_type.GetSignatureForError ());
 						}
 					}
 
 					TypeBuilder.AddInterfaceImplementation (iface_type.GetMetaInfo ());
 
 					// Ensure the base is always setup
 					var compiled_iface = iface_type.MemberDefinition as Interface;
 					if (compiled_iface != null) {
 						// TODO
 						compiled_iface.DefineType ();
 					}
 
 					if (iface_type.Interfaces != null) {
 						var base_ifaces = new List<TypeSpec> (iface_type.Interfaces);
 						for (int i = 0; i < base_ifaces.Count; ++i) {
 							var ii_iface_type = base_ifaces[i];
 							if (spec.AddInterface (ii_iface_type)) {
 								TypeBuilder.AddInterfaceImplementation (ii_iface_type.GetMetaInfo ());
 
 								if (ii_iface_type.Interfaces != null)
 									base_ifaces.AddRange (ii_iface_type.Interfaces);
 							}
 						}
 					}
 				}
 			}
 
 			if (Kind == MemberKind.Interface) {
 				spec.BaseType = TypeManager.object_type;
 				return true;
 			}
 
 			if (base_type != null) {
 				spec.BaseType = base_type;
 
 				// Set base type after type creation
 				TypeBuilder.SetParent (base_type.GetMetaInfo ());
 			}
 
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="445" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" hamdist="12" pcid="3953" startline="343"><![CDATA[
 
 		bool ParseArguments (string[] args, bool require_files, Func<string [], int, int> unknown_option_parser)
 		{
 			List<string> response_file_list = null;
 			bool parsing_options = true;
 
 			for (int i = 0; i < args.Length; i++) {
 				string arg = args [i];
 				if (arg.Length == 0)
 					continue;
 
 				if (arg [0] == '@') {
 					string [] extra_args;
 					string response_file = arg.Substring (1);
 
 					if (response_file_list == null)
 						response_file_list = new List<string> ();
 
 					if (response_file_list.Contains (response_file)) {
 						Report.Error (
 							1515, "Response file `" + response_file +
 							"' specified multiple times");
 						return false;
 					}
 
 					response_file_list.Add (response_file);
 
 					extra_args = LoadArgs (response_file);
 					if (extra_args == null) {
 						Report.Error (2011, "Unable to open response file
 								  response_file);
 						return false;
 					}
 
 					args = AddArgs (args, extra_args);
 					continue;
 				}
 
 				if (parsing_options) {
 					if (arg == "--") {
 						parsing_options = false;
 						continue;
 					}
 
 					if (arg [0] == '-') {
 						if (UnixParseOption (arg, ref args, ref i))
 							continue;
 
 						// Try a -CSCOPTION
 						string csc_opt = "/" + arg.Substring (1);
 						if (CSCParseOption (csc_opt, ref args))
 							continue;
 
 						if (unknown_option_parser != null){
 							var ret = unknown_option_parser (args, i);
 							if (ret != -1){
 								i = ret;
 								return true;
 							}
 						}
 						
 						Error_WrongOption (arg);
 						return false;
 					}
 					if (arg [0] == '/') {
 						if (CSCParseOption (arg, ref args))
 							continue;
 
 						// Need to skip `/home/test.cs' however /test.cs is considered as error
 						if (arg.Length < 2 || arg.IndexOf ('/', 2) == -1) {
 							Error_WrongOption (arg);
 							return false;
 						}
 					}
 				}
 
 				ProcessSourceFiles (arg, false);
 			}
 			for (int i = 0; i < args.Length; i++) {
 				string arg = args [i];
 				if (arg.Length == 0)
 					continue;
 
 				if (arg [0] == '@') {
 					string [] extra_args;
 					string response_file = arg.Substring (1);
 
 					if (response_file_list == null)
 						response_file_list = new List<string> ();
 
 					if (response_file_list.Contains (response_file)) {
 						Report.Error (
 							1515, "Response file `" + response_file +
 							"' specified multiple times");
 						return false;
 					}
 
 					response_file_list.Add (response_file);
 
 					extra_args = LoadArgs (response_file);
 					if (extra_args == null) {
 						Report.Error (2011, "Unable to open response file
 								  response_file);
 						return false;
 					}
 
 					args = AddArgs (args, extra_args);
 					continue;
 				}
 
 				if (parsing_options) {
 					if (arg == "--") {
 						parsing_options = false;
 						continue;
 					}
 
 					if (arg [0] == '-') {
 						if (UnixParseOption (arg, ref args, ref i))
 							continue;
 
 						// Try a -CSCOPTION
 						string csc_opt = "/" + arg.Substring (1);
 						if (CSCParseOption (csc_opt, ref args))
 							continue;
 
 						if (unknown_option_parser != null){
 							var ret = unknown_option_parser (args, i);
 							if (ret != -1){
 								i = ret;
 								return true;
 							}
 						}
 						
 						Error_WrongOption (arg);
 						return false;
 					}
 					if (arg [0] == '/') {
 						if (CSCParseOption (arg, ref args))
 							continue;
 
 						// Need to skip `/home/test.cs' however /test.cs is considered as error
 						if (arg.Length < 2 || arg.IndexOf ('/', 2) == -1) {
 							Error_WrongOption (arg);
 							return false;
 						}
 					}
 				}
 
 				ProcessSourceFiles (arg, false);
 			}
 
 			if (require_files == false)
 				return true;
 					
 			//
 			// If we are an exe, require a source file for the entry point
 			//
 			if (RootContext.Target == Target.Exe || RootContext.Target == Target.WinExe || RootContext.Target == Target.Module) {
 				if (first_source == null) {
 					Report.Error (2008, "No files to compile were specified");
 					return false;
 				}
 
 			}
 
 			//
 			// If there is nothing to put in the assembly, and we are not a library
 			//
 			if (first_source == null && RootContext.Resources == null) {
 				Report.Error (2008, "No files to compile were specified");
 				return false;
 			}
 
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="185" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" hamdist="13" pcid="8771" startline="73"><![CDATA[
     End Property
 
     Public Function CreateImplicitElements() As Boolean Implements IHasImplicitTypes.CreateImplicitTypes
         Dim result As Boolean = True
         'An event creates the following members.
         '1 - if the event is not an explicit delegate, and not an implemented interface event, a nested delegate in the 
         '    parent called (name)EventHandler.
         '    the parameters to the delegate are the same as for the event 
         '    accessability is the same as for the event.
         '2 - a private variable in the parent called (name)Event of type (name)EventHandler.
         '    (unless it is an interface)
         '3 - an add_(name) method in the parent with 1 parameter of type (name)EventHandler.
         '    accessability is the same as for the event.
         '4 - an remove_(name) method in the parent with 1 parameter of type (name)EventHandler.
         '    accessability is the same as for the event.
         '5 - possibly a raise_(name) method in the parent as well.
         '    accessability is the same as for the event.
         '    this method seems to be created only for custom events.
         '6 - an event in the parent called (name) with the add, remove and raise methods of 3, 4 & 5
         '    accessability is the same as for the event.
 
         If m_ElementsCreated Then Return result
         m_ElementsCreated = True
 
         Dim m_AddMethod As RegularEventHandlerDeclaration
         Dim m_RemoveMethod As RegularEventHandlerDeclaration
         Dim m_Parameters As ParameterList = Me.Parameters
         Dim m_Type As TypeName = Nothing
 
         If Me.Type IsNot Nothing Then m_Type = New TypeName(Me, Me.Type)
 
 
         'Create the delegate, if necessary.
         If ImplementsClause IsNot Nothing AndAlso ImplementsClause.ImplementsList.Count > 0 Then
             Dim ism As InterfaceMemberSpecifier
             ism = ImplementsClause.ImplementsList(0)
 
             Helper.Assert(ImplementsClause.ImplementsList.Count = 1)
             Helper.Assert(ism IsNot Nothing)
 
             result = ism.ResolveEarly() AndAlso result
 
             If result = False Then Return result
 
             Helper.Assert(ism.ResolvedEventInfo IsNot Nothing)
 
             Dim eD As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition(ism.ResolvedEventInfo)
 
             If eD IsNot Nothing Then
                 If eD.EventType Is Nothing Then
                     Dim red As RegularEventDeclaration = TryCast(eD.Annotations(Compiler), RegularEventDeclaration)
                     If red IsNot Nothing Then
                         result = red.CreateImplicitElements AndAlso result
                         result = red.ResolveTypeReferences AndAlso result
                     End If
                 End If
                 Helper.Assert(eD.EventType IsNot Nothing)
                 EventType = eD.EventType
             Else
                 EventType = ism.ResolvedEventInfo.EventType
             End If
             m_Type = New TypeName(Me, EventType)
         ElseIf m_Parameters IsNot Nothing Then
             m_ImplicitEventDelegate = New DelegateDeclaration(DeclaringType, DeclaringType.Namespace, New SubSignature(m_ImplicitEventDelegate, Me.Name & "EventHandler", m_Parameters.Clone()))
             m_ImplicitEventDelegate.Modifiers = Me.Modifiers
             m_ImplicitEventDelegate.UpdateDefinition()
             If m_ImplicitEventDelegate.CreateImplicitElements() = False Then Helper.ErrorRecoveryNotImplemented(Me.Location)
 
             EventType = m_ImplicitEventDelegate.CecilType
         ElseIf m_Type IsNot Nothing Then
             m_ImplicitEventDelegate = Nothing
             'Helper.NotImplemented()
         Else
             Throw New InternalException(Me)
         End If
 
 
         'Create the variable.
         If DeclaringType.IsInterface = False Then
             Dim eventVariableModifiers As Modifiers
             m_Variable = New TypeVariableDeclaration(DeclaringType)
             eventVariableModifiers = New Modifiers(ModifierMasks.Private)
             If Me.IsShared Then eventVariableModifiers.AddModifiers(ModifierMasks.Shared)
             If m_ImplicitEventDelegate IsNot Nothing Then
                 m_Variable.Init(eventVariableModifiers, Me.Name & "Event", m_ImplicitEventDelegate.CecilType)
             Else
                 Helper.Assert(m_Type IsNot Nothing)
                 m_Variable.Init(eventVariableModifiers, Me.Name & "Event", m_Type)
             End If
         Else
             m_Variable = Nothing
         End If
 
         'Create the add method
         m_AddMethod = New RegularEventHandlerDeclaration(Me, Me.Modifiers, KS.AddHandler, Me.Identifier)
 
         'Create the remove method
         m_RemoveMethod = New RegularEventHandlerDeclaration(Me, Me.Modifiers, KS.RemoveHandler, Me.Identifier)
 
         Helper.Assert(m_AddMethod IsNot Nothing)
         Helper.Assert(m_AddMethod.Name <> "")
         Helper.Assert(m_RemoveMethod IsNot Nothing)
         Helper.Assert(m_RemoveMethod.Name <> "")
 
         'Add everything to the parent's members.
         If m_ImplicitEventDelegate IsNot Nothing Then DeclaringType.Members.Add(m_ImplicitEventDelegate)
         If m_Variable IsNot Nothing Then DeclaringType.Members.Add(m_Variable)
 
         MyBase.AddMethod = m_AddMethod
         MyBase.RemoveMethod = m_RemoveMethod
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="542" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\Statements\ForStatement.vb" hamdist="19" pcid="9431" startline="420"><![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LoopControlVariable.ResolveCode(Info) AndAlso result
         result = m_LoopStartExpression.ResolveExpression(Info) AndAlso result
         result = m_LoopEndExpression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         If m_LoopControlVariable.MustInfer = False AndAlso m_LoopControlVariable.Expression IsNot Nothing Then
             If m_LoopControlVariable.Expression.Classification.IsVariableClassification = False Then
                 Select Case m_LoopControlVariable.Expression.Classification.Classification
                     Case ExpressionClassification.Classifications.Type
                         If Me.IsOptionInferOn Then
                             m_LoopControlVariable.MustInfer = True
                         Else
                             Return Compiler.Report.ShowMessage(Messages.VBNC30108, Me.Location, m_LoopControlVariable.Identifier.Identifier)
                         End If
                     Case ExpressionClassification.Classifications.PropertyAccess, ExpressionClassification.Classifications.PropertyGroup, ExpressionClassification.Classifications.LateBoundAccess
                         Return Compiler.Report.ShowMessage(Messages.VBNC30039, Me.Location) AndAlso result
                     Case ExpressionClassification.Classifications.Value
                         Return Helper.ShowClassificationError(Compiler, Me.Location, m_LoopControlVariable.Expression.Classification, "Variable") AndAlso result
                     Case Else
                         Return Helper.ShowClassificationError(Compiler, Me.Location, m_LoopControlVariable.Expression.Classification, "Variable") AndAlso result
                 End Select
             End If
         End If
 
         If m_LoopStepExpression IsNot Nothing Then
             result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
             If Not m_LoopStepExpression.Classification.CanBeValueClassification Then
                 result = m_LoopStepExpression.ReportReclassifyToValueErrorMessage()
             Else
                 m_LoopStepExpression = m_LoopStepExpression.ReclassifyToValueExpression()
                 result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         If Not m_LoopStartExpression.Classification.CanBeValueClassification Then
             result = m_LoopStartExpression.ReportReclassifyToValueErrorMessage()
         Else
             m_LoopStartExpression = m_LoopStartExpression.ReclassifyToValueExpression()
             result = m_LoopStartExpression.ResolveExpression(Info) AndAlso result
         End If
 
         If Not m_LoopEndExpression.Classification.CanBeValueClassification Then
             result = m_LoopEndExpression.ReportReclassifyToValueErrorMessage()
         Else
             m_LoopEndExpression = m_LoopEndExpression.ReclassifyToValueExpression()
             result = m_LoopEndExpression.ResolveExpression(Info) AndAlso result
         End If
 
         If result = False Then Return result
 
         If m_LoopControlVariable.MustInfer Then
             Dim start_type As TypeReference = m_LoopStartExpression.ExpressionType
             Dim end_type As TypeReference = m_LoopEndExpression.ExpressionType
             Dim step_type As TypeReference = If(m_LoopStepExpression IsNot Nothing, m_LoopStepExpression.ExpressionType, Nothing)
 
             m_LoopType = Compiler.TypeResolution.GetWidestType(start_type, end_type, step_type)
             If m_LoopType Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC30983, Me.Location, m_LoopControlVariable.Identifier.Identifier)
                 Return False
             End If
 
             m_LoopControlVariable.CreateInferredVariable(m_LoopType)
         Else
             m_LoopType = m_LoopControlVariable.VariableType
         End If
 
         If m_LoopStepExpression Is Nothing Then
             If m_LoopControlVariable.MustInfer Then
                 m_LoopStepExpression = New ConstantExpression(Me, 1, m_LoopType)
                 result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
                 If Helper.IsEnum(Compiler, m_LoopType) Then
                     m_LoopStepExpression = New CTypeExpression(Me, m_LoopStepExpression, m_LoopType)
                     result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
                 End If
             Else
                 m_LoopStepExpression = New ConstantExpression(Me, 1, Compiler.TypeCache.System_Int32)
                 result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         'If m_NextExpressionList IsNot Nothing Then result = m_NextExpressionList.ResolveCode(info) AndAlso result
         m_LoopStepExpression = Helper.CreateTypeConversion(Me, m_LoopStepExpression, m_LoopType, result)
         m_LoopStartExpression = Helper.CreateTypeConversion(Me, m_LoopStartExpression, m_LoopType, result)
         m_LoopEndExpression = Helper.CreateTypeConversion(Me, m_LoopEndExpression, m_LoopType, result)
 
         If m_LoopControlVariable.IsVariableDeclaration Then
             CodeBlock.Variables.Add(m_LoopControlVariable.GetVariableDeclaration)
         End If
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         Select Case Helper.GetTypeCode(Compiler, m_LoopType)
             Case TypeCode.Boolean, TypeCode.Char, TypeCode.DBNull, TypeCode.Empty, TypeCode.String
                 result = Compiler.Report.ShowMessage(Messages.VBNC30337, Location, m_LoopType.Name) AndAlso result
             Case TypeCode.Decimal
                 m_IsLateBound = False
                 m_IsDecimal = True
             Case TypeCode.Byte, TypeCode.Double, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.SByte, TypeCode.Single, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 m_IsLateBound = False
             Case TypeCode.Object
                 m_IsLateBound = True
 
                 Compiler.Helper.AddCheck("The loop control variable of a For statement must be of a primitive numeric type (...), Object, or a type T that has the following operators
 
             Case Else
                 result = Compiler.Report.ShowMessage(Messages.VBNC30337, Location, m_LoopType.Name) AndAlso result
         End Select
 
 
         Compiler.Helper.AddCheck("Check that loop variable has not been used in another for statement.")
         Compiler.Helper.AddCheck("The bound and step expressions must be implicitly convertible to the type of the loop control. ")
         Compiler.Helper.AddCheck("If a variable matches a For loop that is not the most nested loop at that point, a compile-time error results")
         Compiler.Helper.AddCheck("It is not valid to branch into a For loop from outside the loop.")
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="1971" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" hamdist="19" pcid="5317" startline="1781"><![CDATA[
 
 		protected override bool DoDefineMembers ()
 		{
 			if (!base.DoDefineMembers ())
 				return false;
 
 			Location loc = Location;
 
 			var equals_parameters = ParametersCompiled.CreateFullyResolved (
 				new Parameter (new TypeExpression (TypeManager.object_type, loc), "obj", 0, null, loc),	TypeManager.object_type);
 
 			Method equals = new Method (this, null, new TypeExpression (TypeManager.bool_type, loc),
 				Modifiers.PUBLIC | Modifiers.OVERRIDE | Modifiers.DEBUGGER_HIDDEN, new MemberName ("Equals", loc),
 				equals_parameters, null);
 
 			equals_parameters[0].Resolve (equals, 0);
 
 			Method tostring = new Method (this, null, new TypeExpression (TypeManager.string_type, loc),
 				Modifiers.PUBLIC | Modifiers.OVERRIDE | Modifiers.DEBUGGER_HIDDEN, new MemberName ("ToString", loc),
 				Mono.CSharp.ParametersCompiled.EmptyReadOnlyParameters, null);
 
 			ToplevelBlock equals_block = new ToplevelBlock (Compiler, equals.ParameterInfo, loc);
 
 			TypeExpr current_type;
 			if (type_params != null) {
 				var targs = new TypeArguments ();
 				foreach (var type_param in type_params)
 					targs.Add (new TypeParameterExpr (type_param, type_param.Location));
 				foreach (var type_param in type_params)
 					targs.Add (new TypeParameterExpr (type_param, type_param.Location));
 
 				current_type = new GenericTypeExpr (Definition, targs, loc);
 			} else {
 				current_type = new TypeExpression (Definition, loc);
 			}
 
 			var li_other = LocalVariable.CreateCompilerGenerated (CurrentType, equals_block, loc);
 			equals_block.AddStatement (new BlockVariableDeclaration (new TypeExpression (li_other.Type, loc), li_other));
 			var other_variable = new LocalVariableReference (li_other, loc);
 
 			MemberAccess system_collections_generic = new MemberAccess (new MemberAccess (
 				new QualifiedAliasMember ("global", "System", loc), "Collections", loc), "Generic", loc);
 
 			Expression rs_equals = null;
 			Expression string_concat = new StringConstant ("{", loc);
 			Expression rs_hashcode = new IntConstant (-2128831035, loc);
 			for (int i = 0; i < parameters.Count; ++i) {
 				var p = parameters [i];
 				var f = Fields [i];
 
 				MemberAccess equality_comparer = new MemberAccess (new MemberAccess (
 					system_collections_generic, "EqualityComparer",
 						new TypeArguments (new SimpleName (CurrentTypeParameters [i].Name, loc)), loc),
 						"Default", loc);
 
 				Arguments arguments_equal = new Arguments (2);
 				arguments_equal.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				arguments_equal.Add (new Argument (new MemberAccess (other_variable, f.Name)));
 
 				Expression field_equal = new Invocation (new MemberAccess (equality_comparer,
 					"Equals", loc), arguments_equal);
 
 				Arguments arguments_hashcode = new Arguments (1);
 				arguments_hashcode.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				Expression field_hashcode = new Invocation (new MemberAccess (equality_comparer,
 					"GetHashCode", loc), arguments_hashcode);
 
 				IntConstant FNV_prime = new IntConstant (16777619, loc);				
 				rs_hashcode = new Binary (Binary.Operator.Multiply,
 					new Binary (Binary.Operator.ExclusiveOr, rs_hashcode, field_hashcode, loc),
 					FNV_prime, loc);
 
 				Expression field_to_string = new Conditional (new BooleanExpression (new Binary (Binary.Operator.Inequality,
 					new MemberAccess (new This (f.Location), f.Name), new NullLiteral (loc), loc)),
 					new Invocation (new MemberAccess (
 						new MemberAccess (new This (f.Location), f.Name), "ToString"), null),
 					new StringConstant (string.Empty, loc), loc);
 
 				if (rs_equals == null) {
 					rs_equals = field_equal;
 					string_concat = new Binary (Binary.Operator.Addition,
 						string_concat,
 						new Binary (Binary.Operator.Addition,
 							new StringConstant (" " + p.Name + " = ", loc),
 							field_to_string,
 							loc),
 						loc);
 					continue;
 				}
 
 				//
 				// Implementation of ToString () body using string concatenation
 				//				
 				string_concat = new Binary (Binary.Operator.Addition,
 					new Binary (Binary.Operator.Addition,
 						string_concat,
 						new StringConstant (", " + p.Name + " = ", loc),
 						loc),
 					field_to_string,
 					loc);
 
 				rs_equals = new Binary (Binary.Operator.LogicalAnd, rs_equals, field_equal, loc);
 			}
 			for (int i = 0; i < parameters.Count; ++i) {
 				var p = parameters [i];
 				var f = Fields [i];
 
 				MemberAccess equality_comparer = new MemberAccess (new MemberAccess (
 					system_collections_generic, "EqualityComparer",
 						new TypeArguments (new SimpleName (CurrentTypeParameters [i].Name, loc)), loc),
 						"Default", loc);
 
 				Arguments arguments_equal = new Arguments (2);
 				arguments_equal.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				arguments_equal.Add (new Argument (new MemberAccess (other_variable, f.Name)));
 
 				Expression field_equal = new Invocation (new MemberAccess (equality_comparer,
 					"Equals", loc), arguments_equal);
 
 				Arguments arguments_hashcode = new Arguments (1);
 				arguments_hashcode.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				Expression field_hashcode = new Invocation (new MemberAccess (equality_comparer,
 					"GetHashCode", loc), arguments_hashcode);
 
 				IntConstant FNV_prime = new IntConstant (16777619, loc);				
 				rs_hashcode = new Binary (Binary.Operator.Multiply,
 					new Binary (Binary.Operator.ExclusiveOr, rs_hashcode, field_hashcode, loc),
 					FNV_prime, loc);
 
 				Expression field_to_string = new Conditional (new BooleanExpression (new Binary (Binary.Operator.Inequality,
 					new MemberAccess (new This (f.Location), f.Name), new NullLiteral (loc), loc)),
 					new Invocation (new MemberAccess (
 						new MemberAccess (new This (f.Location), f.Name), "ToString"), null),
 					new StringConstant (string.Empty, loc), loc);
 
 				if (rs_equals == null) {
 					rs_equals = field_equal;
 					string_concat = new Binary (Binary.Operator.Addition,
 						string_concat,
 						new Binary (Binary.Operator.Addition,
 							new StringConstant (" " + p.Name + " = ", loc),
 							field_to_string,
 							loc),
 						loc);
 					continue;
 				}
 
 				//
 				// Implementation of ToString () body using string concatenation
 				//				
 				string_concat = new Binary (Binary.Operator.Addition,
 					new Binary (Binary.Operator.Addition,
 						string_concat,
 						new StringConstant (", " + p.Name + " = ", loc),
 						loc),
 					field_to_string,
 					loc);
 
 				rs_equals = new Binary (Binary.Operator.LogicalAnd, rs_equals, field_equal, loc);
 			}
 
 			string_concat = new Binary (Binary.Operator.Addition,
 				string_concat,
 				new StringConstant (" }", loc),
 				loc);
 
 			//
 			// Equals (object obj) override
 			//		
 			var other_variable_assign = new TemporaryVariableReference (li_other, loc);
 			equals_block.AddStatement (new StatementExpression (
 				new SimpleAssign (other_variable_assign,
 					new As (equals_block.GetParameterReference (0, loc),
 						current_type, loc), loc)));
 
 			Expression equals_test = new Binary (Binary.Operator.Inequality, other_variable, new NullLiteral (loc), loc);
 			if (rs_equals != null)
 				equals_test = new Binary (Binary.Operator.LogicalAnd, equals_test, rs_equals, loc);
 			equals_block.AddStatement (new Return (equals_test, loc));
 
 			equals.Block = equals_block;
 			equals.Define ();
 			AddMethod (equals);
 
 			//
 			// GetHashCode () override
 			//
 			Method hashcode = new Method (this, null, new TypeExpression (TypeManager.int32_type, loc),
 				Modifiers.PUBLIC | Modifiers.OVERRIDE | Modifiers.DEBUGGER_HIDDEN,
 				new MemberName ("GetHashCode", loc),
 				Mono.CSharp.ParametersCompiled.EmptyReadOnlyParameters, null);
 
 			//
 			// Modified FNV with good avalanche behavior and uniform
 			// distribution with larger hash sizes.
 			//
 			// const int FNV_prime = 16777619;
 			// int hash = (int) 2166136261;
 			// foreach (int d in data)
 			//     hash = (hash ^ d) * FNV_prime;
 			// hash += hash << 13;
 			// hash ^= hash >> 7;
 			// hash += hash << 3;
 			// hash ^= hash >> 17;
 			// hash += hash << 5;
 
 			ToplevelBlock hashcode_top = new ToplevelBlock (Compiler, loc);
 			Block hashcode_block = new Block (hashcode_top, loc, loc);
 			hashcode_top.AddStatement (new Unchecked (hashcode_block, loc));
 
 			var li_hash = LocalVariable.CreateCompilerGenerated (TypeManager.int32_type, hashcode_top, loc);
 			hashcode_block.AddStatement (new BlockVariableDeclaration (new TypeExpression (li_hash.Type, loc), li_hash));
 			LocalVariableReference hash_variable_assign = new LocalVariableReference (li_hash, loc);
 			hashcode_block.AddStatement (new StatementExpression (
 				new SimpleAssign (hash_variable_assign, rs_hashcode)));
 
 			var hash_variable = new LocalVariableReference (li_hash, loc);
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.Addition, hash_variable,
 					new Binary (Binary.Operator.LeftShift, hash_variable, new IntConstant (13, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.ExclusiveOr, hash_variable,
 					new Binary (Binary.Operator.RightShift, hash_variable, new IntConstant (7, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.Addition, hash_variable,
 					new Binary (Binary.Operator.LeftShift, hash_variable, new IntConstant (3, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.ExclusiveOr, hash_variable,
 					new Binary (Binary.Operator.RightShift, hash_variable, new IntConstant (17, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.Addition, hash_variable,
 					new Binary (Binary.Operator.LeftShift, hash_variable, new IntConstant (5, loc), loc), loc)));
 
 			hashcode_block.AddStatement (new Return (hash_variable, loc));
 			hashcode.Block = hashcode_top;
 			hashcode.Define ();
 			AddMethod (hashcode);
 
 			//
 			// ToString () override
 			//
 
 			ToplevelBlock tostring_block = new ToplevelBlock (Compiler, loc);
 			tostring_block.AddStatement (new Return (string_concat, loc));
 			tostring.Block = tostring_block;
 			tostring.Define ();
 			AddMethod (tostring);
 
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="531" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" hamdist="19" pcid="9709" startline="254"><![CDATA[
 
     Private Function CreateMyGroupMembers() As Boolean
         Dim result As Boolean = True
 
         If Me.CustomAttributes Is Nothing Then Return result
 
         Dim attrib As Attribute
         Dim attribs As Generic.List(Of Attribute)
 
         attribs = Me.CustomAttributes.FindAttributes(Compiler.TypeCache.MS_VB_MyGroupCollectionAttribute)
 
         If attribs Is Nothing Then Return result
         If attribs.Count <> 1 Then Return result
 
         attrib = attribs(0)
 
         Dim groupData As New MyGroupData
         Dim typeToCollect As String
         Dim createInstanceMethodName As String
         Dim disposeInstanceMethodName As String
         Dim defaultInstanceAlias As String
 
         If Not attrib.ResolveCode(ResolveInfo.Default(Compiler)) Then
             'The attribute is not instantiated correctly, this will cause an error on the attribute
             'no need to show more errors here.
             Return result
         End If
 
         'Check the number of arguments and their types
         'There should be 4 string arguments, if not there's something wrong with
         'the MyGroupCollectionAttribute (won't reach here if the code is wrong
         'because we resolve the attribute first)
         'It's also safe to index the arguments, since attributes can't have named constructor parameters.
         Dim args As Object() = attrib.Arguments
         If args Is Nothing OrElse args.Length <> 4 Then
             Throw New InternalException("Weird MyGroupCollectionAttribute, should have 4 arguments.")
         Else
             For Each arg As Object In args
                 If arg Is Nothing Then Continue For
                 If TypeOf arg Is String Then Continue For
                 Throw New InternalException("Weird MyGroupCollectionAttribute, non-string argument?")
             Next
         End If
         typeToCollect = DirectCast(args(0), String)
         createInstanceMethodName = DirectCast(args(1), String)
         disposeInstanceMethodName = DirectCast(args(2), String)
         defaultInstanceAlias = DirectCast(args(3), String)
 
         If typeToCollect = String.Empty Then Return result
         If createInstanceMethodName = String.Empty Then Return result
         If disposeInstanceMethodName = String.Empty Then Return result
 
         Dim collectType As Mono.Cecil.TypeReference
         Dim foundTypes As Generic.List(Of Mono.Cecil.TypeReference)
         foundTypes = Compiler.TypeManager.GetType(typeToCollect, False)
         If foundTypes.Count <> 1 Then
             Return result
         End If
         collectType = foundTypes(0)
         groupData.TypeToCollect = collectType
 
         For Each mi As MethodDeclaration In Members.GetSpecificMembers(Of MethodDeclaration)()
             If mi.IsShared AndAlso Helper.CompareName(createInstanceMethodName, mi.Name) Then
                 If mi.Signature.Parameters.Count <> 1 Then Continue For
                 If mi.Signature.TypeParameters Is Nothing OrElse mi.Signature.TypeParameters.Parameters.Count <> 1 Then Continue For
                 If mi.Signature.ReturnType Is Nothing Then Continue For
 
                 Dim T As TypeParameter = mi.Signature.TypeParameters.Parameters(0)
                 If T.TypeParameterConstraints Is Nothing Then Continue For
 
                 Dim constraints As ConstraintList = T.TypeParameterConstraints.Constraints
                 If constraints.Count <> 2 Then Continue For
 
                 If Not (constraints(0).Special = KS.[New] OrElse constraints(1).Special = KS.[New]) Then Continue For
 
                 Dim tn As TypeName
                 tn = constraints(0).TypeName
                 If tn Is Nothing Then tn = constraints(1).TypeName
                 If tn Is Nothing Then Continue For
                 If Not Helper.CompareType(tn.ResolvedType, groupData.TypeToCollect) Then Continue For
 
                 If Helper.CompareType(mi.Signature.Parameters(0).ParameterType, T.CecilBuilder) = False Then Continue For
                 If Helper.CompareType(mi.Signature.ReturnType, T.CecilBuilder) = False Then Continue For
 
 
                 If groupData.CreateInstanceMethod IsNot Nothing Then Continue For
                 groupData.CreateInstanceMethod = mi.CecilBuilder
             ElseIf mi.IsShared = False AndAlso Helper.CompareName(disposeInstanceMethodName, mi.Name) Then
                 If mi.Signature.Parameters.Count <> 1 Then Continue For
                 If mi.Signature.TypeParameters Is Nothing OrElse mi.Signature.TypeParameters.Parameters.Count <> 1 Then Continue For
                 If mi.Signature.ReturnType IsNot Nothing AndAlso Helper.CompareType(mi.Signature.ReturnType, Compiler.TypeCache.System_Void) = False Then Continue For
 
                 Dim T As TypeParameter = mi.Signature.TypeParameters.Parameters(0)
                 'SPECBUG
                 'https
                 If T.TypeParameterConstraints Is Nothing OrElse T.TypeParameterConstraints.Constraints Is Nothing OrElse T.TypeParameterConstraints.Constraints.Count <> 1 Then Continue For
                 If Not Helper.CompareType(T.TypeParameterConstraints.Constraints(0).TypeName.ResolvedType, groupData.TypeToCollect) Then Continue For
 
                 If Helper.CompareType(mi.Signature.Parameters(0).ParameterType, Compiler.TypeManager.MakeByRefType(Me, T.CecilBuilder)) = False Then Continue For
 
                 If groupData.DisposeInstanceMethod IsNot Nothing Then Continue For
                 groupData.DisposeInstanceMethod = mi.CecilBuilder
             End If
             If groupData.DisposeInstanceMethod IsNot Nothing AndAlso groupData.CreateInstanceMethod IsNot Nothing Then Exit For
         Next
 
         If groupData.CreateInstanceMethod Is Nothing Then Return result
         If groupData.DisposeInstanceMethod Is Nothing Then Return result
 
         If Compiler.Assembly.GroupedClasses Is Nothing Then Compiler.Assembly.GroupedClasses = New Generic.List(Of MyGroupData)
         Compiler.Assembly.GroupedClasses.Add(groupData)
 
         'Parse the alias
         If defaultInstanceAlias <> String.Empty Then
             Dim scanner As New Scanner(Compiler, defaultInstanceAlias)
             Dim parser As New Parser(Compiler, scanner)
             Dim alias_exp As Expression
             'TODO
             alias_exp = parser.ParseExpression(Me)
 
             If alias_exp IsNot Nothing Then
                 Dim alias_result As Boolean
                 alias_result = alias_exp.ResolveExpression(New ResolveInfo(Compiler))
                 If alias_result Then
                     groupData.DefaultInstanceAlias = alias_exp
                 End If
             End If
         End If
 
 
         'Find all non-generic types that inherit from the type to collect
         Dim typesCollected As New Generic.List(Of TypeDeclaration)
         Dim namesUsed As New Generic.Dictionary(Of String, Object)(Helper.StringComparer)
         Dim namesClashed As New Generic.Dictionary(Of String, Object)(Helper.StringComparer)
         For Each type As TypeDeclaration In Compiler.theAss.Types
             Dim classType As ClassDeclaration = TryCast(type, ClassDeclaration)
 
             If classType Is Nothing Then Continue For
             If classType.TypeParameters IsNot Nothing AndAlso classType.TypeParameters.Parameters.Count > 0 Then Continue For
 
             If Helper.IsSubclassOf(collectType, type.CecilType) Then
                 typesCollected.Add(type)
                 If namesUsed.ContainsKey(type.Name) Then
                     namesClashed.Add(type.Name, Nothing)
                 Else
                     namesUsed.Add(type.Name, Nothing)
                 End If
             End If
         Next
 
         For Each type As TypeDeclaration In typesCollected
             Dim propertyName As String
             Dim fieldName As String
 
             If namesClashed.ContainsKey(type.Name) Then
                 propertyName = type.FullName.Replace(".", "_")
             Else
                 propertyName = type.Name
             End If
             fieldName = "m_" & propertyName
 
             Dim field As New TypeVariableDeclaration(Me)
             Dim prop As New PropertyDeclaration(Me)
             Dim modifiers As New Modifiers(ModifierMasks.Public)
 
             field.Init(modifiers, fieldName, type.CecilType)
             prop.Init(modifiers, propertyName, type.CecilType)
 
             type.MyGroupField = field
 
             Dim setter As MethodDeclaration
             Dim getter As MethodDeclaration
 
             getter = prop.GetDeclaration
             setter = prop.SetDeclaration
 
             getter.Code = New CodeBlock(getter)
             setter.Code = New CodeBlock(setter)
 
             Dim get_1 As New AssignmentStatement(getter.Code)
             Dim get_1_left As New SimpleNameExpression(get_1)
             Dim get_1_right As New InvocationOrIndexExpression(get_1)
             Dim get_1_right_instance_exp As New SimpleNameExpression(get_1_right)
             Dim get_1_right_instance_exp_typeargs As New TypeArgumentList(get_1_right_instance_exp)
             Dim get_1_right_instance_exp_typeargs_1 As New TypeName(get_1_right_instance_exp_typeargs)
             Dim get_1_right_arg1 As New SimpleNameExpression(get_1_right)
             Dim get_1_right_arglist As New ArgumentList(get_1_right, get_1_right_arg1)
             Dim get_1_right_field_token As Identifier = New Identifier(get_1_right, fieldName, attrib.Location, TypeCharacters.Characters.None)
             Dim get_1_right_method_token As Identifier = New Identifier(get_1_right, createInstanceMethodName, attrib.Location, TypeCharacters.Characters.None)
 
             get_1_left.Init(get_1_right_field_token, Nothing)
 
             get_1_right_instance_exp_typeargs_1.Init(type.CecilType)
             get_1_right_instance_exp_typeargs.Add(get_1_right_instance_exp_typeargs_1)
             get_1_right_instance_exp.Init(get_1_right_method_token, get_1_right_instance_exp_typeargs)
             get_1_right_arg1.Init(get_1_right_field_token, Nothing)
             get_1_right.Init(get_1_right_instance_exp, get_1_right_arglist)
             get_1.Init(get_1_left, get_1_right)
 
             Dim get_2 As New ReturnStatement(getter.Code)
             Dim get_2_exp As New SimpleNameExpression(get_2)
             get_2_exp.Init(get_1_right_field_token, Nothing)
             get_2.Init(get_2_exp)
 
             getter.Code.AddStatement(get_1)
             getter.Code.AddStatement(get_2)
 
             Dim set_if1 As New IfStatement(setter.Code)
             Dim value_token As Identifier = New Identifier(set_if1, "Value", attrib.Location, TypeCharacters.Characters.None)
             Dim field_token As Identifier = New Identifier(set_if1, fieldName, attrib.Location, TypeCharacters.Characters.None)
             Dim set_if1_condition_left As New SimpleNameExpression(set_if1)
             Dim set_if1_condition_right As New SimpleNameExpression(set_if1)
             Dim set_if1_condition As New Is_IsNotExpression(set_if1, set_if1_condition_left, set_if1_condition_right, KS.IsNot)
             Dim set_if1_code As New CodeBlock(set_if1)
             Dim set_if2 As New IfStatement(set_if1)
             Dim set_if2_condition_right As New NothingConstantExpression(set_if2)
             Dim set_if2_condition As New Is_IsNotExpression(set_if2, set_if1_condition_left, set_if2_condition_right, KS.IsNot)
             Dim set_if2_code As New CodeBlock(set_if2)
             Dim set_throw As New ThrowStatement(set_if2_code)
             Dim set_throw_creation As New DelegateOrObjectCreationExpression(set_throw)
             Dim set_throw_arg1 As New ConstantExpression(set_throw_creation, "Property can only be set to Nothing", Compiler.TypeCache.System_String)
             Dim set_throw_args As New ArgumentList(set_throw_creation, set_throw_arg1)
             Dim set_dispose As New CallStatement(set_if1)
             Dim set_dispose_invocation As New InvocationOrIndexExpression(set_dispose)
             Dim set_dispose_invocation_instance_exp As New SimpleNameExpression(set_dispose_invocation)
             Dim set_dispose_invocation_instance_exp_typeargs As New TypeArgumentList(set_dispose_invocation_instance_exp)
             Dim set_dispose_invocation_instance_exp_typeargs_1 As New TypeName(set_dispose_invocation_instance_exp_typeargs)
             Dim set_dispose_invocation_arg1 As New SimpleNameExpression(set_dispose_invocation)
             Dim set_dispose_invocation_arglist As New ArgumentList(set_dispose_invocation, set_dispose_invocation_arg1)
             Dim set_dispose_invocation_field_token As Identifier = New Identifier(set_dispose_invocation, fieldName, attrib.Location, TypeCharacters.Characters.None)
             Dim set_dispose_invocation_method_token As Identifier = New Identifier(set_dispose_invocation, disposeInstanceMethodName, attrib.Location, TypeCharacters.Characters.None)
 
             set_throw_creation.Init(Compiler.TypeCache.System_ArgumentException, set_throw_args)
             set_throw.Init(set_throw_creation)
 
             set_if2_code.AddStatement(set_throw)
 
             set_dispose_invocation_instance_exp_typeargs_1.Init(type.CecilType)
             set_dispose_invocation_instance_exp_typeargs.Add(set_dispose_invocation_instance_exp_typeargs_1)
             set_dispose_invocation_instance_exp.Init(set_dispose_invocation_method_token, set_dispose_invocation_instance_exp_typeargs)
             set_dispose_invocation_arg1.Init(set_dispose_invocation_field_token, Nothing)
             set_dispose_invocation.Init(set_dispose_invocation_instance_exp, set_dispose_invocation_arglist)
             set_dispose.Init(set_dispose_invocation)
 
             set_if1_code.AddStatement(set_if2)
             set_if1_code.AddStatement(set_dispose)
 
             set_if1_condition_left.Init(value_token, Nothing)
             set_if1_condition_right.Init(field_token, Nothing)
 
             set_if1.Init(set_if1_condition, Nothing, set_if1_code, False, Nothing)
             set_if2.Init(set_if2_condition, Nothing, set_if2_code, False, Nothing)
 
             setter.Code.AddStatement(set_if1)
 
             result = setter.ResolveTypeReferences AndAlso result
             result = getter.ResolveTypeReferences AndAlso result
 
             Members.Add(field)
             Members.Add(prop)
 
             field.UpdateDefinition()
             prop.UpdateDefinition()
 
             'Me.TypeDescriptor.ClearCache()
 
             If Compiler.TypeManager.ContainsCache(Me.CecilType) Then
                 Dim cache As MemberCache = Compiler.TypeManager.GetCache(Me.CecilType)
                 'cache.Cache.Add(New MemberCacheEntry(field.FieldDescriptor))
                 'cache.Cache.Add(New MemberCacheEntry(prop.MemberDescriptor))
                 'cache.FlattenedCache.Add(New MemberCacheEntry(field.FieldDescriptor))
                 'cache.FlattenedCache.Add(New MemberCacheEntry(prop.MemberDescriptor))
                 cache.ClearAll()
             End If
         Next
 
         Return result
     End Function
]]></clone_fragment>
<clone_fragment endline="599" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" hamdist="9" pcid="1049" startline="254"><![CDATA[
 		static readonly char[] simple_whitespaces = new char[] { ' ', '\t' };
 
 		public bool PropertyParsing {
 			get { return handle_get_set; }
 			set { handle_get_set = value; }
 		}
 
 		public bool EventParsing {
 			get { return handle_remove_add; }
 			set { handle_remove_add = value; }
 		}
 
 		public bool ConstraintsParsing {
 			get { return handle_where; }
 			set { handle_where = value; }
 		}
 
 		public bool TypeOfParsing {
 			get { return handle_typeof; }
 			set { handle_typeof = value; }
 		}
 
 		public int TabSize {
 			get { return tab_size; }
 			set { tab_size = value; }
 		}
 		
 		public XmlCommentState doc_state {
 			get { return xml_doc_state; }
 			set {
 				if (value == XmlCommentState.Allowed) {
 					check_incorrect_doc_comment ();
 					reset_doc_comment ();
 				}
 				xml_doc_state = value;
 			}
 		}
 
 		//
 		// This is used to trigger completion generation on the parser
 		public bool CompleteOnEOF;
 		
 		void AddEscapedIdentifier (Location loc)
 		{
 			if (escaped_identifiers == null)
 				escaped_identifiers = new List<Location> ();
 
 			escaped_identifiers.Add (loc);
 		}
 
 		public bool IsEscapedIdentifier (MemberName name)
 		{
 			return escaped_identifiers != null && escaped_identifiers.Contains (name.Location);
 		}
 
 		//
 		// Class variables
 		// 
 		static KeywordEntry<int>[][] keywords;
 		static KeywordEntry<PreprocessorDirective>[][] keywords_preprocessor;
 		static Dictionary<string, object> keyword_strings; 		// TODO
 		static NumberStyles styles;
 		static NumberFormatInfo csharp_format_info;
 
 		// Pragma arguments
 		static readonly char[] pragma_warning = "warning".ToCharArray ();
 		static readonly char[] pragma_warning_disable = "disable".ToCharArray ();
 		static readonly char[] pragma_warning_restore = "restore".ToCharArray ();
 		static readonly char[] pragma_checksum = "checksum".ToCharArray ();
 		
 		//
 		// Values for the associated token returned
 		//
 		internal int putback_char; 	// Used by repl only
 		object val;
 
 		//
 		// Pre-processor
 		//
 		const int TAKING        = 1;
 		const int ELSE_SEEN     = 4;
 		const int PARENT_TAKING = 8;
 		const int REGION        = 16;		
 
 		//
 		// pre-processor if stack state
 		//
 		Stack<int> ifstack;
 
 		static System.Text.StringBuilder string_builder;
 
 		const int max_id_size = 512;
 		static char [] id_builder = new char [max_id_size];
 
 		public static Dictionary<char[], string>[] identifiers = new Dictionary<char[], string>[max_id_size + 1];
 
 		const int max_number_size = 512;
 		static char [] number_builder = new char [max_number_size];
 		static int number_pos;
 
 		static StringBuilder static_cmd_arg = new System.Text.StringBuilder ();
 		
 		public int Line {
 			get {
 				return ref_line;
 			}
 		}
 
 		//
 		// This is used when the tokenizer needs to save
 		// the current position as it needs to do some parsing
 		// on its own to deamiguate a token in behalf of the
 		// parser.
 		//
 		Stack<Position> position_stack = new Stack<Position> (2);
 
 		class Position {
 			public int position;
 			public int line;
 			public int ref_line;
 			public int col;
 			public bool hidden;
 			public int putback_char;
 			public int previous_col;
 			public Stack<int> ifstack;
 			public int parsing_generic_less_than;
 			public int current_token;
 			public object val;
 
 			public Position (Tokenizer t)
 			{
 				position = t.reader.Position;
 				line = t.line;
 				ref_line = t.ref_line;
 				col = t.col;
 				hidden = t.hidden;
 				putback_char = t.putback_char;
 				previous_col = t.previous_col;
 				if (t.ifstack != null && t.ifstack.Count != 0) {
 					// There is no simple way to clone Stack<T> all
 					// methods reverse the order
 					var clone = t.ifstack.ToArray ();
 					Array.Reverse (clone);
 					ifstack = new Stack<int> (clone);
 				}
 				parsing_generic_less_than = t.parsing_generic_less_than;
 				current_token = t.current_token;
 				val = t.val;
 			}
 		}
 		
 		public void PushPosition ()
 		{
 			position_stack.Push (new Position (this));
 		}
 
 		public void PopPosition ()
 		{
 			Position p = position_stack.Pop ();
 
 			reader.Position = p.position;
 			ref_line = p.ref_line;
 			line = p.line;
 			col = p.col;
 			hidden = p.hidden;
 			putback_char = p.putback_char;
 			previous_col = p.previous_col;
 			ifstack = p.ifstack;
 			parsing_generic_less_than = p.parsing_generic_less_than;
 			current_token = p.current_token;
 			val = p.val;
 		}
 
 		// Do not reset the position, ignore it.
 		public void DiscardPosition ()
 		{
 			position_stack.Pop ();
 		}
 		
 		static void AddKeyword (string kw, int token)
 		{
 			keyword_strings.Add (kw, null);
 
 			AddKeyword (keywords, kw, token);
 		}
 
 		static void AddPreprocessorKeyword (string kw, PreprocessorDirective directive)
 		{
 			AddKeyword (keywords_preprocessor, kw, directive);
 		}
 
 		static void AddKeyword<T> (KeywordEntry<T>[][] keywords, string kw, T token)
 		{
 			int length = kw.Length;
 			if (keywords[length] == null) {
 				keywords[length] = new KeywordEntry<T>['z' - '_' + 1];
 			}
 
 			int char_index = kw[0] - '_';
 			var kwe = keywords[length][char_index];
 			if (kwe == null) {
 				keywords[length][char_index] = new KeywordEntry<T> (kw, token);
 				return;
 			}
 
 			while (kwe.Next != null) {
 				kwe = kwe.Next;
 			}
 
 			kwe.Next = new KeywordEntry<T> (kw, token);
 		}
 
 		static void InitTokens ()
 		{
 			keyword_strings = new Dictionary<string, object> ();
 
 			// 11 is the length of the longest keyword for now
 			keywords = new KeywordEntry<int> [11] [];
 
 			AddKeyword ("__arglist", Token.ARGLIST);
 			AddKeyword ("abstract", Token.ABSTRACT);
 			AddKeyword ("as", Token.AS);
 			AddKeyword ("add", Token.ADD);
 			AddKeyword ("base", Token.BASE);
 			AddKeyword ("bool", Token.BOOL);
 			AddKeyword ("break", Token.BREAK);
 			AddKeyword ("byte", Token.BYTE);
 			AddKeyword ("case", Token.CASE);
 			AddKeyword ("catch", Token.CATCH);
 			AddKeyword ("char", Token.CHAR);
 			AddKeyword ("checked", Token.CHECKED);
 			AddKeyword ("class", Token.CLASS);
 			AddKeyword ("const", Token.CONST);
 			AddKeyword ("continue", Token.CONTINUE);
 			AddKeyword ("decimal", Token.DECIMAL);
 			AddKeyword ("default", Token.DEFAULT);
 			AddKeyword ("delegate", Token.DELEGATE);
 			AddKeyword ("do", Token.DO);
 			AddKeyword ("double", Token.DOUBLE);
 			AddKeyword ("else", Token.ELSE);
 			AddKeyword ("enum", Token.ENUM);
 			AddKeyword ("event", Token.EVENT);
 			AddKeyword ("explicit", Token.EXPLICIT);
 			AddKeyword ("extern", Token.EXTERN);
 			AddKeyword ("false", Token.FALSE);
 			AddKeyword ("finally", Token.FINALLY);
 			AddKeyword ("fixed", Token.FIXED);
 			AddKeyword ("float", Token.FLOAT);
 			AddKeyword ("for", Token.FOR);
 			AddKeyword ("foreach", Token.FOREACH);
 			AddKeyword ("goto", Token.GOTO);
 			AddKeyword ("get", Token.GET);
 			AddKeyword ("if", Token.IF);
 			AddKeyword ("implicit", Token.IMPLICIT);
 			AddKeyword ("in", Token.IN);
 			AddKeyword ("int", Token.INT);
 			AddKeyword ("interface", Token.INTERFACE);
 			AddKeyword ("internal", Token.INTERNAL);
 			AddKeyword ("is", Token.IS);
 			AddKeyword ("lock", Token.LOCK);
 			AddKeyword ("long", Token.LONG);
 			AddKeyword ("namespace", Token.NAMESPACE);
 			AddKeyword ("new", Token.NEW);
 			AddKeyword ("null", Token.NULL);
 			AddKeyword ("object", Token.OBJECT);
 			AddKeyword ("operator", Token.OPERATOR);
 			AddKeyword ("out", Token.OUT);
 			AddKeyword ("override", Token.OVERRIDE);
 			AddKeyword ("params", Token.PARAMS);
 			AddKeyword ("private", Token.PRIVATE);
 			AddKeyword ("protected", Token.PROTECTED);
 			AddKeyword ("public", Token.PUBLIC);
 			AddKeyword ("readonly", Token.READONLY);
 			AddKeyword ("ref", Token.REF);
 			AddKeyword ("remove", Token.REMOVE);
 			AddKeyword ("return", Token.RETURN);
 			AddKeyword ("sbyte", Token.SBYTE);
 			AddKeyword ("sealed", Token.SEALED);
 			AddKeyword ("set", Token.SET);
 			AddKeyword ("short", Token.SHORT);
 			AddKeyword ("sizeof", Token.SIZEOF);
 			AddKeyword ("stackalloc", Token.STACKALLOC);
 			AddKeyword ("static", Token.STATIC);
 			AddKeyword ("string", Token.STRING);
 			AddKeyword ("struct", Token.STRUCT);
 			AddKeyword ("switch", Token.SWITCH);
 			AddKeyword ("this", Token.THIS);
 			AddKeyword ("throw", Token.THROW);
 			AddKeyword ("true", Token.TRUE);
 			AddKeyword ("try", Token.TRY);
 			AddKeyword ("typeof", Token.TYPEOF);
 			AddKeyword ("uint", Token.UINT);
 			AddKeyword ("ulong", Token.ULONG);
 			AddKeyword ("unchecked", Token.UNCHECKED);
 			AddKeyword ("unsafe", Token.UNSAFE);
 			AddKeyword ("ushort", Token.USHORT);
 			AddKeyword ("using", Token.USING);
 			AddKeyword ("virtual", Token.VIRTUAL);
 			AddKeyword ("void", Token.VOID);
 			AddKeyword ("volatile", Token.VOLATILE);
 			AddKeyword ("while", Token.WHILE);
 			AddKeyword ("partial", Token.PARTIAL);
 			AddKeyword ("where", Token.WHERE);
 			AddKeyword ("async", Token.ASYNC);
 
 			// LINQ keywords
 			AddKeyword ("from", Token.FROM);
 			AddKeyword ("join", Token.JOIN);
 			AddKeyword ("on", Token.ON);
 			AddKeyword ("equals", Token.EQUALS);
 			AddKeyword ("select", Token.SELECT);
 			AddKeyword ("group", Token.GROUP);
 			AddKeyword ("by", Token.BY);
 			AddKeyword ("let", Token.LET);
 			AddKeyword ("orderby", Token.ORDERBY);
 			AddKeyword ("ascending", Token.ASCENDING);
 			AddKeyword ("descending", Token.DESCENDING);
 			AddKeyword ("into", Token.INTO);
 
 			keywords_preprocessor = new KeywordEntry<PreprocessorDirective>[10][];
 
 			AddPreprocessorKeyword ("region", PreprocessorDirective.Region);
 			AddPreprocessorKeyword ("endregion", PreprocessorDirective.Endregion);
 			AddPreprocessorKeyword ("if", PreprocessorDirective.If);
 			AddPreprocessorKeyword ("endif", PreprocessorDirective.Endif);
 			AddPreprocessorKeyword ("elif", PreprocessorDirective.Elif);
 			AddPreprocessorKeyword ("else", PreprocessorDirective.Else);
 			AddPreprocessorKeyword ("define", PreprocessorDirective.Define);
 			AddPreprocessorKeyword ("undef", PreprocessorDirective.Undef);
 			AddPreprocessorKeyword ("error", PreprocessorDirective.Error);
 			AddPreprocessorKeyword ("warning", PreprocessorDirective.Warning);
 			AddPreprocessorKeyword ("pragma", PreprocessorDirective.Pragma);
 			AddPreprocessorKeyword ("line", PreprocessorDirective.Line);
 		}
 
 		//
 		// Class initializer
 		// 
 		static Tokenizer ()
 		{
 			InitTokens ();			
 			csharp_format_info = NumberFormatInfo.InvariantInfo;
 			styles = NumberStyles.Float;
 
 			string_builder = new System.Text.StringBuilder ();
 		}
]]></clone_fragment>
<clone_fragment endline="2435" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="16" pcid="2329" startline="2291"><![CDATA[
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			int lookup_arity = Arity;
 			bool errorMode = false;
 			Expression e;
 			Block current_block = rc.CurrentBlock;
 			INamedBlockVariable variable = null;
 			bool variable_found = false;
 
 			while (true) {
 				//
 				// Stage 1
 				//
 				// LAMESPEC
 				//
 				if (current_block != null && lookup_arity == 0) {
 					if (current_block.ParametersBlock.TopBlock.GetLocalName (Name, current_block.Original, ref variable)) {
 						if (!variable.IsDeclared) {
 							// We found local name in accessible block but it's not
 							// initialized yet, maybe the user wanted to bind to something else
 							errorMode = true;
 							variable_found = true;
 						} else {
 							e = variable.CreateReferenceExpression (rc, loc);
 							if (e != null) {
 								if (Arity > 0)
 									Error_TypeArgumentsCannotBeUsed (rc.Report, "variable", Name, loc);
 
 								return e;
 							}
 						}
 					}
 				}
 
 				//
 				// Stage 2
 				//
 				TypeSpec member_type = rc.CurrentType;
 				TypeSpec current_type = member_type;
 				for (; member_type != null; member_type = member_type.DeclaringType) {
 					e = MemberLookup (errorMode ? null 
 					if (e == null)
 						continue;
 
 					var me = e as MemberExpr;
 					if (me == null) {
 						// The name matches a type, defer to ResolveAsTypeStep
 						if (e is TypeExpr)
 							break;
 
 						continue;
 					}
 
 					if (errorMode) {
 						if (variable != null) {
 							if (me is FieldExpr || me is ConstantExpr || me is EventExpr || me is PropertyExpr) {
 								rc.Report.Error (844, loc,
 									"A local variable `{0}' cannot be used before it is declared. Consider renaming the local variable when it hides the member `{1}'",
 									Name, me.GetSignatureForError ());
 							} else {
 								break;
 							}
 						} else if (me is MethodGroupExpr) {
 							// Leave it to overload resolution to report correct error
 						} else {
 							// TODO
 							ErrorIsInaccesible (rc, me.GetSignatureForError (), loc);
 						}
 					} else {
 						// LAMESPEC
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						//
 						// MemberLookup does not check accessors availability, this is actually needed for properties only
 						//
 						var pe = me as PropertyExpr;
 						if (pe != null) {
 
 							// Break as there is no other overload available anyway
 							if ((restrictions & MemberLookupRestrictions.ReadAccess) != 0) {
 								if (!pe.PropertyInfo.HasGet || !pe.PropertyInfo.Get.IsAccessible (current_type))
 									break;
 
 								pe.Getter = pe.PropertyInfo.Get;
 							} else {
 								if (!pe.PropertyInfo.HasSet || !pe.PropertyInfo.Set.IsAccessible (current_type))
 									break;
 
 								pe.Setter = pe.PropertyInfo.Set;
 							}
 						}
 					}
 
 					// TODO
 					// TODO
 					me = me.ResolveMemberAccess (rc, null, null);
 
 					if (Arity > 0) {
 						targs.Resolve (rc);
 						me.SetTypeArguments (rc, targs);
 					}
 
 					return me;
 				for (; member_type != null; member_type = member_type.DeclaringType) {
 					e = MemberLookup (errorMode ? null 
 					if (e == null)
 						continue;
 
 					var me = e as MemberExpr;
 					if (me == null) {
 						// The name matches a type, defer to ResolveAsTypeStep
 						if (e is TypeExpr)
 							break;
 
 						continue;
 					}
 
 					if (errorMode) {
 						if (variable != null) {
 							if (me is FieldExpr || me is ConstantExpr || me is EventExpr || me is PropertyExpr) {
 								rc.Report.Error (844, loc,
 									"A local variable `{0}' cannot be used before it is declared. Consider renaming the local variable when it hides the member `{1}'",
 									Name, me.GetSignatureForError ());
 							} else {
 								break;
 							}
 						} else if (me is MethodGroupExpr) {
 							// Leave it to overload resolution to report correct error
 						} else {
 							// TODO
 							ErrorIsInaccesible (rc, me.GetSignatureForError (), loc);
 						}
 					} else {
 						// LAMESPEC
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						//
 						// MemberLookup does not check accessors availability, this is actually needed for properties only
 						//
 						var pe = me as PropertyExpr;
 						if (pe != null) {
 
 							// Break as there is no other overload available anyway
 							if ((restrictions & MemberLookupRestrictions.ReadAccess) != 0) {
 								if (!pe.PropertyInfo.HasGet || !pe.PropertyInfo.Get.IsAccessible (current_type))
 									break;
 
 								pe.Getter = pe.PropertyInfo.Get;
 							} else {
 								if (!pe.PropertyInfo.HasSet || !pe.PropertyInfo.Set.IsAccessible (current_type))
 									break;
 
 								pe.Setter = pe.PropertyInfo.Set;
 							}
 						}
 					}
 
 					// TODO
 					// TODO
 					me = me.ResolveMemberAccess (rc, null, null);
 
 					if (Arity > 0) {
 						targs.Resolve (rc);
 						me.SetTypeArguments (rc, targs);
 					}
 
 					return me;
 				}
 
 				//
 				// Stage 3
 				//
 				if ((restrictions & MemberLookupRestrictions.InvocableOnly) == 0 && !variable_found) {
 					e = ResolveAsTypeStep (rc, lookup_arity == 0 || !errorMode);
 					if (e != null) {
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						return e;
 					}
 				}
 
 				if (errorMode) {
 					if (variable_found) {
 						rc.Report.Error (841, loc, "A local variable `{0}' cannot be used before it is declared", Name);
 					} else {
 						rc.Report.Error (103, loc, "The name `{0}' does not exist in the current context", Name);
 					}
 
 					return null;
 				}
 
 				if (RootContext.EvalMode) {
 					var fi = Evaluator.LookupField (Name);
 					if (fi != null)
 						return new FieldExpr (fi.Item1, loc);
 				}
 
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 			while (true) {
 				//
 				// Stage 1
 				//
 				// LAMESPEC
 				//
 				if (current_block != null && lookup_arity == 0) {
 					if (current_block.ParametersBlock.TopBlock.GetLocalName (Name, current_block.Original, ref variable)) {
 						if (!variable.IsDeclared) {
 							// We found local name in accessible block but it's not
 							// initialized yet, maybe the user wanted to bind to something else
 							errorMode = true;
 							variable_found = true;
 						} else {
 							e = variable.CreateReferenceExpression (rc, loc);
 							if (e != null) {
 								if (Arity > 0)
 									Error_TypeArgumentsCannotBeUsed (rc.Report, "variable", Name, loc);
 
 								return e;
 							}
 						}
 					}
 				}
 
 				//
 				// Stage 2
 				//
 				TypeSpec member_type = rc.CurrentType;
 				TypeSpec current_type = member_type;
 				for (; member_type != null; member_type = member_type.DeclaringType) {
 					e = MemberLookup (errorMode ? null 
 					if (e == null)
 						continue;
 
 					var me = e as MemberExpr;
 					if (me == null) {
 						// The name matches a type, defer to ResolveAsTypeStep
 						if (e is TypeExpr)
 							break;
 
 						continue;
 					}
 
 					if (errorMode) {
 						if (variable != null) {
 							if (me is FieldExpr || me is ConstantExpr || me is EventExpr || me is PropertyExpr) {
 								rc.Report.Error (844, loc,
 									"A local variable `{0}' cannot be used before it is declared. Consider renaming the local variable when it hides the member `{1}'",
 									Name, me.GetSignatureForError ());
 							} else {
 								break;
 							}
 						} else if (me is MethodGroupExpr) {
 							// Leave it to overload resolution to report correct error
 						} else {
 							// TODO
 							ErrorIsInaccesible (rc, me.GetSignatureForError (), loc);
 						}
 					} else {
 						// LAMESPEC
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						//
 						// MemberLookup does not check accessors availability, this is actually needed for properties only
 						//
 						var pe = me as PropertyExpr;
 						if (pe != null) {
 
 							// Break as there is no other overload available anyway
 							if ((restrictions & MemberLookupRestrictions.ReadAccess) != 0) {
 								if (!pe.PropertyInfo.HasGet || !pe.PropertyInfo.Get.IsAccessible (current_type))
 									break;
 
 								pe.Getter = pe.PropertyInfo.Get;
 							} else {
 								if (!pe.PropertyInfo.HasSet || !pe.PropertyInfo.Set.IsAccessible (current_type))
 									break;
 
 								pe.Setter = pe.PropertyInfo.Set;
 							}
 						}
 					}
 
 					// TODO
 					// TODO
 					me = me.ResolveMemberAccess (rc, null, null);
 
 					if (Arity > 0) {
 						targs.Resolve (rc);
 						me.SetTypeArguments (rc, targs);
 					}
 
 					return me;
 				}
 
 				//
 				// Stage 3
 				//
 				if ((restrictions & MemberLookupRestrictions.InvocableOnly) == 0 && !variable_found) {
 					e = ResolveAsTypeStep (rc, lookup_arity == 0 || !errorMode);
 					if (e != null) {
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						return e;
 					}
 				}
 
 				if (errorMode) {
 					if (variable_found) {
 						rc.Report.Error (841, loc, "A local variable `{0}' cannot be used before it is declared", Name);
 					} else {
 						rc.Report.Error (103, loc, "The name `{0}' does not exist in the current context", Name);
 					}
 
 					return null;
 				}
 
 				if (RootContext.EvalMode) {
 					var fi = Evaluator.LookupField (Name);
 					if (fi != null)
 						return new FieldExpr (fi.Item1, loc);
 				}
 
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="176" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" hamdist="16" pcid="2563" startline="151"><![CDATA[
 	}
 #endif
 
 	public class MonoSymbolFile 
 	{
 		List<MethodEntry> methods = new List<MethodEntry> ();
 		List<SourceFileEntry> sources = new List<SourceFileEntry> ();
 		List<CompileUnitEntry> comp_units = new List<CompileUnitEntry> ();
 		Dictionary<Type, int> type_hash = new Dictionary<Type, int> ();
 		Dictionary<int, AnonymousScopeEntry> anonymous_scopes;
 
 		OffsetTable ot;
 		int last_type_index;
 		int last_method_index;
 		int last_namespace_index;
 
 		public readonly string FileName = "<dynamic>";
 		public readonly int MajorVersion = OffsetTable.MajorVersion;
 		public readonly int MinorVersion = OffsetTable.MinorVersion;
 
 		public int NumLineNumbers;
 
 		internal MonoSymbolFile ()
 		{
 			ot = new OffsetTable ();
 		}
 
 		internal int AddSource (SourceFileEntry source)
 		{
 			sources.Add (source);
 			return sources.Count;
 		}
 
 		internal int AddCompileUnit (CompileUnitEntry entry)
 		{
 			comp_units.Add (entry);
 			return comp_units.Count;
 		}
 
 		internal int DefineType (Type type)
 		{
 			int index;
 			if (type_hash.TryGetValue (type, out index))
 				return index;
 
 			index = ++last_type_index;
 			type_hash.Add (type, index);
 			return index;
 		}
 
 		internal void AddMethod (MethodEntry entry)
 		{
 			methods.Add (entry);
 		}
 
 		public MethodEntry DefineMethod (CompileUnitEntry comp_unit, int token,
 						 ScopeVariable[] scope_vars, LocalVariableEntry[] locals,
 						 LineNumberEntry[] lines, CodeBlockEntry[] code_blocks,
 						 string real_name, MethodEntry.Flags flags,
 						 int namespace_id)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			MethodEntry method = new MethodEntry (
 				this, comp_unit, token, scope_vars, locals, lines, code_blocks, 
 				real_name, flags, namespace_id);
 			AddMethod (method);
 			return method;
 		}
 
 		internal void DefineAnonymousScope (int id)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			if (anonymous_scopes == null)
 				anonymous_scopes = new Dictionary<int, AnonymousScopeEntry>  ();
 
 			anonymous_scopes.Add (id, new AnonymousScopeEntry (id));
 		}
 
 		internal void DefineCapturedVariable (int scope_id, string name, string captured_name,
 						      CapturedVariable.CapturedKind kind)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedVariable (name, captured_name, kind);
 		}
 
 		internal void DefineCapturedScope (int scope_id, int id, string captured_name)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedScope (id, captured_name);
 		}
 
 		internal int GetNextTypeIndex ()
 		{
 			return ++last_type_index;
 		}
 
 		internal int GetNextMethodIndex ()
 		{
 			return ++last_method_index;
 		}
 
 		internal int GetNextNamespaceIndex ()
 		{
 			return ++last_namespace_index;
 		}
 		
 		void Write (MyBinaryWriter bw, Guid guid)
 		{
 			// Magic number and file version.
 			bw.Write (OffsetTable.Magic);
 			bw.Write (MajorVersion);
 			bw.Write (MinorVersion);
 
 			bw.Write (guid.ToByteArray ());
 
 			//
 			// Offsets of file sections; we must write this after we're done
 			// writing the whole file, so we just reserve the space for it here.
 			//
 			long offset_table_offset = bw.BaseStream.Position;
 			ot.Write (bw, MajorVersion, MinorVersion);
 
 			//
 			// Sort the methods according to their tokens and update their index.
 			//
 			methods.Sort ();
 			for (int i = 0; i < methods.Count; i++)
 				((MethodEntry) methods [i]).Index = i + 1;
 
 			//
 			// Write data sections.
 			//
 			ot.DataSectionOffset = (int) bw.BaseStream.Position;
 			foreach (SourceFileEntry source in sources)
 				source.WriteData (bw);
 			foreach (CompileUnitEntry comp_unit in comp_units)
 				comp_unit.WriteData (bw);
 			foreach (MethodEntry method in methods)
 				method.WriteData (this, bw);
 			ot.DataSectionSize = (int) bw.BaseStream.Position - ot.DataSectionOffset;
 
 			//
 			// Write the method index table.
 			//
 			ot.MethodTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < methods.Count; i++) {
 				MethodEntry entry = (MethodEntry) methods [i];
 				entry.Write (bw);
 			}
 			ot.MethodTableSize = (int) bw.BaseStream.Position - ot.MethodTableOffset;
 
 			//
 			// Write source table.
 			//
 			ot.SourceTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < sources.Count; i++) {
 				SourceFileEntry source = (SourceFileEntry) sources [i];
 				source.Write (bw);
 			}
 			ot.SourceTableSize = (int) bw.BaseStream.Position - ot.SourceTableOffset;
 
 			//
 			// Write compilation unit table.
 			//
 			ot.CompileUnitTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < comp_units.Count; i++) {
 				CompileUnitEntry unit = (CompileUnitEntry) comp_units [i];
 				unit.Write (bw);
 			}
 			ot.CompileUnitTableSize = (int) bw.BaseStream.Position - ot.CompileUnitTableOffset;
 
 			//
 			// Write anonymous scope table.
 			//
 			ot.AnonymousScopeCount = anonymous_scopes != null ? anonymous_scopes.Count 
 			ot.AnonymousScopeTableOffset = (int) bw.BaseStream.Position;
 			if (anonymous_scopes != null) {
 				foreach (AnonymousScopeEntry scope in anonymous_scopes.Values)
 					scope.Write (bw);
 			}
 			ot.AnonymousScopeTableSize = (int) bw.BaseStream.Position - ot.AnonymousScopeTableOffset;
 
 			//
 			// Fixup offset table.
 			//
 			ot.TypeCount = last_type_index;
 			ot.MethodCount = methods.Count;
 			ot.SourceCount = sources.Count;
 			ot.CompileUnitCount = comp_units.Count;
 
 			//
 			// Write offset table.
 			//
 			ot.TotalFileSize = (int) bw.BaseStream.Position;
 			bw.Seek ((int) offset_table_offset, SeekOrigin.Begin);
 			ot.Write (bw, MajorVersion, MinorVersion);
 			bw.Seek (0, SeekOrigin.End);
 
 #if false
 			Console.WriteLine ("TOTAL
 					   "{3} methods.", NumLineNumbers, LineNumberSize,
 					   ExtendedLineNumberSize, methods.Count);
 #endif
 		}
 
 		public void CreateSymbolFile (Guid guid, FileStream fs)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			Write (new MyBinaryWriter (fs), guid);
 		}
 
 		MyBinaryReader reader;
 		Dictionary<int, SourceFileEntry> source_file_hash;
 		Dictionary<int, CompileUnitEntry> compile_unit_hash;
 
 		List<MethodEntry> method_list;
 		Dictionary<int, MethodEntry> method_token_hash;
 		Dictionary<string, int> source_name_hash;
 
 		Guid guid;
 
 		MonoSymbolFile (string filename)
 		{
 			this.FileName = filename;
 			FileStream stream = new FileStream (filename, FileMode.Open, FileAccess.Read);
 			reader = new MyBinaryReader (stream);
 
 			try {
 				long magic = reader.ReadInt64 ();
 				int major_version = reader.ReadInt32 ();
 				int minor_version = reader.ReadInt32 ();
 
 				if (magic != OffsetTable.Magic)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' is not a valid " +
 						"Mono symbol file", filename);
 				if (major_version != OffsetTable.MajorVersion)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' has version {1}, " +
 						"but expected {2}", filename, major_version,
 						OffsetTable.MajorVersion);
 				if (minor_version != OffsetTable.MinorVersion)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' has version {1}.{2}, " +
 						"but expected {3}.{4}", filename, major_version,
 						minor_version, OffsetTable.MajorVersion,
 						OffsetTable.MinorVersion);
 
 				MajorVersion = major_version;
 				MinorVersion = minor_version;
 				guid = new Guid (reader.ReadBytes (16));
 
 				ot = new OffsetTable (reader, major_version, minor_version);
 			} catch {
 				throw new MonoSymbolFileException (
 					"Cannot read symbol file `{0}'", filename);
 			}
 
 			source_file_hash = new Dictionary<int, SourceFileEntry> ();
 			compile_unit_hash = new Dictionary<int, CompileUnitEntry> ();
 		}
 
 		void CheckGuidMatch (Guid other, string filename, string assembly)
 		{
 			if (other == guid)
 				return;
 
 			throw new MonoSymbolFileException (
 				"Symbol file `{0}' does not match assembly `{1}'",
 				filename, assembly);
 		}
 
 #if CECIL
 		protected MonoSymbolFile (string filename, Mono.Cecil.ModuleDefinition module)
 			
 		{
 			CheckGuidMatch (module.Mvid, filename, module.FullyQualifiedName);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Mono.Cecil.ModuleDefinition module)
 		{
 			return ReadSymbolFile (module, module.FullyQualifiedName);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Mono.Cecil.ModuleDefinition module, string filename)
 		{
 			string name = filename + ".mdb";
 
 			return new MonoSymbolFile (name, module);
 		}
 #else
 		protected MonoSymbolFile (string filename, Assembly assembly) 
 		{
 			// Check that the MDB file matches the assembly, if we have been
 			// passed an assembly.
 			if (assembly == null)
 				return;
 			
 			Module[] modules = assembly.GetModules ();
 			Guid assembly_guid = MonoDebuggerSupport.GetGuid (modules [0]);
 
 			CheckGuidMatch (assembly_guid, filename, assembly.Location);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Assembly assembly)
 		{
 			string filename = assembly.Location;
 			string name = filename + ".mdb";
 
 			return new MonoSymbolFile (name, assembly);
 		}
 #endif
 
 		public static MonoSymbolFile ReadSymbolFile (string mdbFilename)
 		{
 			return new MonoSymbolFile (mdbFilename, null);
 		}
 
 		public int CompileUnitCount {
 			get { return ot.CompileUnitCount; }
 		}
 
 		public int SourceCount {
 			get { return ot.SourceCount; }
 		}
 
 		public int MethodCount {
 			get { return ot.MethodCount; }
 		}
 
 		public int TypeCount {
 			get { return ot.TypeCount; }
 		}
 
 		public int AnonymousScopeCount {
 			get { return ot.AnonymousScopeCount; }
 		}
 
 		public int NamespaceCount {
 			get { return last_namespace_index; }
 		}
 
 		public Guid Guid {
 			get { return guid; }
 		}
 
 		public OffsetTable OffsetTable {
 			get { return ot; }
 		}
 
 		internal int LineNumberCount = 0;
 		internal int LocalCount = 0;
 		internal int StringSize = 0;
 
 		internal int LineNumberSize = 0;
 		internal int ExtendedLineNumberSize = 0;
 		internal MonoSymbolFile ()
 		{
 			ot = new OffsetTable ();
 		}
]]></clone_fragment>
<clone_fragment endline="1548" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="16" pcid="8119" startline="1542"><![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
     Private m_PeekedChars As New Generic.Queue(Of Char)
     Private m_Reader As System.IO.StreamReader
 
     Private m_StringBuilder(127) As Char
     Private m_StringBuilderLength As Integer
 
     ''' <summary>
     ''' If any tokens has been found on this line.
     ''' Reset by IncLine, set by NewToken
     ''' </summary>
     ''' <remarks></remarks>
     Private m_TokensSeenOnLine As Integer
 
     Private m_Files As Generic.Queue(Of CodeFile)
 
     Private m_Peeked As Token
 
     'Data about the current token
     Private m_LastWasNewline As Boolean
     Private m_Current As Token
     Private m_CurrentTypeCharacter As TypeCharacters.Characters
     Private m_CurrentTokenType As TokenType
     Private m_CurrentData As Object
 
 #Region "Conditional Compilation"
     'Data related to conditional compilation
     Private m_ProjectConstants As New ConditionalConstants
     Private m_CurrentConstants As ConditionalConstants
     Private m_Evaluator As New ConditionalExpression(Me)
 
     ''' <summary>
     ''' 0 if condition is false and has never been true
     ''' 1 if condition is true
     ''' -1 if condition has been true
     ''' </summary>
     ''' <remarks></remarks>
     Private m_ConditionStack As New Generic.List(Of Integer)
 
     Private m_Methods As New Generic.Dictionary(Of Mono.Cecil.MethodReference, Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute))
 
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
     End Property
 
     ReadOnly Property CurrentConstants() As ConditionalConstants
         Get
             Return m_CurrentConstants
         End Get
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
 
     Private Sub ResetCurrentConstants()
         m_CurrentConstants = New ConditionalConstants(m_ProjectConstants)
     End Sub
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, GetCurrentLocation())
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '='")
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Helper.AddError(Me, "Expected string literal")
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
 
     Public Function [Next]() As Token
         Do
             NextUnconditionally()
 
             If m_Current.IsEndOfCode Then
                 m_Peeked = m_Current
                 Return m_Current
             End If
 
             If m_Current.IsEndOfFile Then
                 ResetCurrentConstants()
                 Return m_Current
             End If
 
             If TokensSeenOnLine = 1 AndAlso m_Current = KS.Numeral Then
                 Me.NextUnconditionally()
                 If m_Current = KS.If Then
                     ParseIf()
                 ElseIf m_Current = KS.Else Then
                     ParseElse()
                 ElseIf m_Current = KS.ElseIf Then
                     ParseElseIf()
                 ElseIf m_Current = KS.Const Then
                     ParseConst()
                 ElseIf m_Current.Equals("ExternalSource") Then
                     ParseExternalSource()
                 ElseIf m_Current.Equals("Region") Then
                     ParseRegion()
                 ElseIf m_Current = KS.End Then
                     ParseEnd()
                 Else
                     Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If', 'ElseIf', 'Else', 'Const' or 'Region'.")
                     EatLine(False)
                 End If
             ElseIf IfdOut Then
                 If m_Current.IsEndOfLine = False Then EatLine(False)
                 Continue Do
             Else
                 If m_Current.IsEndOfLineOnly AndAlso m_LastWasNewline Then
                     Continue Do
                 End If
                 m_LastWasNewline = m_Current.IsEndOfLineOnly
                 Return m_Current
             End If
         Loop While m_Current.IsEndOfCode = False AndAlso m_Current.IsEndOfFile = False
         Return m_Current
     End Function
 
     Public Function Peek() As Token
         If Token.IsSomething(m_Peeked) Then Return m_Peeked
         m_Peeked = Me.Next
         Return m_Peeked
     End Function
 #End Region
 
 #Region "StringBuilder"
     Private Property StringBuilderLength As Integer
         Get
             Return m_StringBuilderLength
         End Get
         Set(ByVal value As Integer)
             m_StringBuilderLength = value
         End Set
     End Property
 
     Private Sub StringBuilderAppend(ByVal c As Char)
         m_StringBuilderLength += 1
         If m_StringBuilder Is Nothing Then
             ReDim m_StringBuilder(31)
         End If
         If m_StringBuilder.Length < m_StringBuilderLength Then
             Dim tmp(Math.Max(m_StringBuilder.Length * 2 - 1, m_StringBuilderLength)) As Char
             m_StringBuilder.CopyTo(tmp, 0)
             m_StringBuilder = tmp
         End If
         m_StringBuilder(m_StringBuilderLength - 1) = c
     End Sub
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
 #End Region
 
     Private Structure Data
         Public Type As TokenType
         Public Symbol As KS
         Public Data As Object
         Public TypeCharacter As TypeCharacters.Characters
 
         Public Sub Clear()
             Type = vbnc.TokenType.None
             Symbol = KS.None
             Data = Nothing
             TypeCharacter = TypeCharacters.Characters.None
         End Sub
     End Structure
 
     ReadOnly Property TokensSeenOnLine() As Integer
         Get
             Return m_TokensSeenOnLine
         End Get
     End Property
 
     ReadOnly Property TotalLineCount() As UInteger
         Get
             Return m_TotalLineCount
         End Get
     End Property
 
     ReadOnly Property TotalCharCount() As Integer
         Get
             Return m_TotalCharCount
         End Get
     End Property
 
     Private Function IsNewLine() As Boolean
         Return IsNewLine(CurrentChar)
     End Function
 
     Public Shared Function IsNewLine(ByVal chr As Char) As Boolean
         Return chr = nlA OrElse chr = nlD OrElse chr = nl2028 OrElse chr = nl2029 OrElse chr = nl0
     End Function
 
     Private Function IsUnderscoreCharacter(ByVal chr As Char) As Boolean
         'UnderscoreCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.ConnectorPunctuation
     End Function
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
 
     Private Function IsNumericCharacter(ByVal chr As Char) As Boolean
         'NumericCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.DecimalDigitNumber 'Nd
     End Function
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsFormattingCharacter(ByVal chr As Char) As Boolean
         'FormattingCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.Format 'Cf
     End Function
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
 
     Shared Function IsWhiteSpace(ByVal chr As Char) As Boolean
         Return chr = nlTab OrElse Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.SpaceSeparator
     End Function
 
     Private Function IsWhiteSpace() As Boolean
         Return IsWhiteSpace(CurrentChar())
     End Function
 
     Private Function IsComment(ByVal chr As Char) As Boolean
         Return chr = COMMENTCHAR1 OrElse chr = COMMENTCHAR2 OrElse chr = COMMENTCHAR3
     End Function
 
     Private Function IsComment() As Boolean
         Return IsComment(CurrentChar)
     End Function
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
 
     Public Shared Function IsSingleNewLine(ByVal chr1 As Char, ByVal chr2 As Char) As Boolean
         Return Not (chr1 = nlD AndAlso chr2 = nlA)
     End Function
 
     Private Sub EatComment()
         Select Case CurrentChar()
             Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'Traditional VB comment
                 EatLine(False) 'do not eat newline, it needs to be added as a token
                 Return
             Case Else
                 REM is taken care of some other place.
                 'Function should never be called if not a comment
                 Throw New InternalException("EatComment called with no comment.")
         End Select
     End Sub
 
     Private Sub EatWhiteSpace()
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
     End Sub
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
 
     Private Function CanStartIdentifier() As Boolean
         Return CanStartIdentifier(CurrentChar)
     End Function
 
     Private Function CanStartIdentifier(ByVal chr As Char) As Boolean
         Return IsAlphaCharacter(chr) OrElse IsUnderscoreCharacter(chr)
     End Function
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case """"c '
                     'If " followed by a ", output one "
                     If NextChar() = """" Then
                         StringBuilderAppend(""""c)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     'vbc accepts this...
                     Compiler.Report.ShowMessage(Messages.VBNC90003, GetCurrentLocation())
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC90004, GetCurrentLocation())
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
 
     Private Function GetNumber() As Token
         Dim Base As IntegerBase
         Dim bReal As Boolean
         Dim bE As Boolean
         Static Builder As New Text.StringBuilder
         Builder.Length = 0
 
         'First find the type of the number
         Select Case CurrentChar()
             Case "."c, "0"c To "9"c 'Decimal
                 Base = IntegerBase.Decimal
             Case "&"c
                 Select Case NextChar()
 #If EXTENDED Then
                     Case "b"c, "B"c 'Binary
                         Base = IntegerBase.Binary
 #End If
                     Case "d"c, "D"c 'Decimal
                         Base = IntegerBase.Decimal
                     Case "h"c, "H"c 'Hex
                         Base = IntegerBase.Hex
                     Case "o"c, "O"c 'Octal
                         Base = IntegerBase.Octal
                     Case Else
                         Throw New InternalException(GetCurrentLocation.ToString(Compiler)) 'Should never get here, this function should only be called with the correct specifiers.
                 End Select
                 NextChar()
             Case Else
                 Throw New InternalException("Invalid character
         End Select
 
         Dim ch As Char = CurrentChar()
         ' Then start the parsing
         Select Case Base
             Case IntegerBase.Decimal
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 If ch = "."c Then
                     If Me.IsNumericCharacter(Me.PeekChar) Then
                         Builder.Append(ch)
                         bReal = True
                         ch = NextChar()
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                     End If
                 End If
                 If ch = "E"c OrElse ch = "e"c Then
                     bE = True
                     bReal = True
                     Builder.Append(ch)
                     ch = NextChar()
                     If ch = "+"c OrElse ch = "-"c Then
                         Builder.Append(ch)
                         ch = NextChar()
                     End If
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                 End If
 #If EXTENDED Then
             Case IntegerBase.Binary
                 While ((ch >= "0"c) AndAlso (ch <= "1"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
 #End If
             Case IntegerBase.Hex
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case IntegerBase.Octal
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
 
         'Find the type character, if any
         Dim strType As String = ""
         Dim typeOfNumber As BuiltInDataTypes
         Dim typeCharacter As LiteralTypeCharacters_Characters = LiteralTypeCharacters_Characters.None
 
         Dim test As String
         test = CurrentChar()
         If test = "U" OrElse test = "u" Then test &= PeekChar()
         typeCharacter = LiteralTypeCharacters.GetTypeCharacter(test)
         If typeCharacter <> LiteralTypeCharacters_Characters.None Then
             NextChar()
             If test.Length = 2 Then NextChar()
             typeOfNumber = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
         End If
 
         If typeCharacter <> LiteralTypeCharacters_Characters.None AndAlso LiteralTypeCharacters.IsIntegral(typeCharacter) = False AndAlso Base <> IntegerBase.Decimal Then
             Compiler.Report.ShowMessage(Messages.VBNC90002, Me.GetCurrentLocation(), KS.Decimal.ToString)
         End If
 
         ' Found the string of the number
         Dim strResult As String = Builder.ToString
         Dim IntegerValue As ULong
 
         Select Case Base
             Case IntegerBase.Decimal
                 Try
                     Dim tp As BuiltInDataTypes
                     If typeCharacter = LiteralTypeCharacters_Characters.None Then
                         If bReal Then
                             tp = BuiltInDataTypes.Double
                         Else
                             tp = BuiltInDataTypes.Integer
                         End If
                     Else
                         tp = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
                     End If
                     Select Case tp
                         Case BuiltInDataTypes.Decimal
                             GetNumber = Token.CreateDecimalToken(GetCurrentLocation, Decimal.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Double
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, Double.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Single
                             GetNumber = Token.CreateSingleToken(GetCurrentLocation, Single.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Short, BuiltInDataTypes.UInteger, BuiltInDataTypes.ULong, BuiltInDataTypes.UShort
                             If bReal Then
                                 Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                                 IntegerValue = 0
                             Else
                                 'Try to parse the result
                                 IntegerValue = ULong.Parse(strResult, Helper.USCulture)
                             End If
                             'Check if value is out of range for data type.
                             Dim bOutOfRange As Boolean
                             'TODO
                             Select Case tp
                                 Case BuiltInDataTypes.Integer
                                     If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Long
                                     If IntegerValue > Long.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Short
                                     If IntegerValue > Short.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UInteger
                                     If IntegerValue > UInteger.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.ULong 'Not necessary
                                     '    If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UShort
                                     If IntegerValue > UShort.MaxValue Then bOutOfRange = True
                                 Case Else
                                     Throw New InternalException("")
                             End Select
                             If bOutOfRange AndAlso typeCharacter <> LiteralTypeCharacters_Characters.None Then
                                 Compiler.Report.ShowMessage(Messages.VBNC30439, GetCurrentLocation(), typeCharacter.ToString)
                             End If
                             GetNumber = GetIntegralToken(ULong.Parse(strResult, Helper.USCulture), Base, typeCharacter)
                         Case Else
                             Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                     End Select
                 Catch ex As System.OverflowException
                     Compiler.Report.ShowMessage(Messages.VBNC30036, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90005, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 End Try
 #If EXTENDED Then
             Case IntegerBase.Binary
                 Try
                     IntegerValue = Helper.BinToInt(strResult)
                     IntegerValue = ConvertNonDecimalBits(IntegerValue, typeCharacter)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, "binary")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
 #End If
             Case IntegerBase.Hex
                 Try
                     'Console.WriteLine("Hex
                     IntegerValue = Helper.HexToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, Me.GetCurrentLocation, "hexadecimal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case IntegerBase.Octal
                 Try
                     IntegerValue = Helper.OctToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, GetCurrentLocation(), "octal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
     End Function
 
     Private Function GetIntegralToken(ByVal Value As ULong, ByVal Base As IntegerBase, ByVal TypeCharacter As LiteralTypeCharacters_Characters) As Token
         Dim case_type As BuiltInDataTypes
         'TODO
         If TypeCharacter = LiteralTypeCharacters_Characters.None Then
             If Value > Integer.MaxValue Then
                 case_type = BuiltInDataTypes.Long
             Else
                 case_type = BuiltInDataTypes.Integer
             End If
         Else
             case_type = LiteralTypeCharacters.GetBuiltInType(TypeCharacter)
         End If
 
         Select Case case_type
             Case BuiltInDataTypes.Integer
                 Return Token.CreateInt32Token(GetCurrentLocation, ExtractInt(Value, Base))
             Case BuiltInDataTypes.UInteger
                 Return Token.CreateUInt32Token(GetCurrentLocation, ExtractUInt(Value, Base))
             Case BuiltInDataTypes.Long
                 Return Token.CreateInt64Token(GetCurrentLocation, ExtractLong(Value, Base))
             Case BuiltInDataTypes.ULong
                 Return Token.CreateUInt64Token(GetCurrentLocation, ExtractULong(Value, Base))
             Case BuiltInDataTypes.Short
                 Return Token.CreateInt16Token(GetCurrentLocation, ExtractShort(Value, Base))
             Case BuiltInDataTypes.UShort
                 Return Token.CreateUInt16Token(GetCurrentLocation, ExtractUShort(Value, Base))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Function GetCurrentLocation() As Span
         Return New Span(m_CodeFileIndex, m_CurrentLine, m_CurrentColumn)
     End Function
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return GetCurrentLocation()
         End Get
     End Property
 
     Private ReadOnly Property CurrentChar() As Char
         Get
             Return m_CurrentChar
         End Get
     End Property
 
     Private Function NextChar() As Char
         If m_CurrentColumn < 255 Then m_CurrentColumn += CByte(1)
         m_TotalCharCount += 1
 
         m_PreviousChar = m_CurrentChar
         If m_PeekedChars.Count > 0 Then
             m_CurrentChar = m_PeekedChars.Dequeue
         Else
             If m_Reader.EndOfStream Then
                 m_CurrentChar = nl0
             Else
                 If m_Reader.EndOfStream Then
                     m_EndOfFile = True
                     m_CurrentChar = nl0
                 Else
                     m_CurrentChar = Convert.ToChar(m_Reader.Read())
                 End If
             End If
         End If
 
         Return m_CurrentChar
     End Function
 
     Private ReadOnly Property PreviousChar() As Char
         Get
             Return m_PreviousChar
         End Get
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
 
     Private Function PeekChars(ByVal Chars As Integer) As Char
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Return m_PeekedChars.ToArray()(Chars - 1)
     End Function
 
     ''' <summary>
     ''' Returns true if the current character is the last character in the scanner.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function IsLastChar() As Boolean
         Return m_Reader.EndOfStream
     End Function
 
     ''' <summary>
     ''' Next line!
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub IncLine()
         m_CurrentLine += 1UI
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
     End Sub
 
     ''' <summary>
     ''' Creates a new symbol token of the specified symbol.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function NewToken(ByVal Symbol As KS) As Token
         Return Token.CreateSymbolToken(GetCurrentLocation, Symbol)
     End Function
 
     Private Function GetNextToken() As Token
         Dim Result As Token = Nothing
         Do
             Select Case CurrentChar()
                 Case """"c 'String Literal
                     Result = GetString()
                 Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'VB Comment
                     EatComment()
                 Case nlD, nlA, nl2028, nl2029 'New line
                     EatNewLine()
                     Result = Token.CreateEndOfLineToken(GetCurrentLocation)
                 Case nl0 'End of file
                     Result = Token.CreateEndOfFileToken(GetCurrentLocation)
                 Case "
                     NextChar()
                     Result = NewToken(KS.Colon)
                 Case ","c ',
                     NextChar()
                     Result = NewToken(KS.Comma)
                 Case "."c
                     If PeekChar() >= "0"c AndAlso PeekChar() <= "9"c Then
                         Result = GetNumber()
                     Else
                         NextChar()
                         Result = NewToken(KS.Dot)
                     End If
                 Case "0"c To "9"c
                     Result = GetNumber()
                 Case "("c
                     NextChar()
                     Result = NewToken(KS.LParenthesis)
                 Case ")"c
                     NextChar()
                     Result = NewToken(KS.RParenthesis)
                 Case "["c
                     Result = GetEscapedIdentifier()
                 Case "{"c
                     NextChar()
                     Result = NewToken(KS.LBrace)
                 Case "}"c
                     NextChar()
                     Result = NewToken(KS.RBrace)
                 Case ">"c
                     NextChar()
                     EatWhiteSpace()
                     'If CurrentChar() = "<"c Then
                     '    NextChar()
                     '    Result = NewToken(KS.NotEqual)
                     'Else
                     If CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.GE)
                     ElseIf CurrentChar() = ">"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftRightAssign)
                         Else
                             Result = NewToken(KS.ShiftRight)
                         End If
                     Else
                         Result = NewToken(KS.GT)
                     End If
                 Case "<"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = ">"c) Then
                         NextChar()
                         Result = NewToken(KS.NotEqual)
                     ElseIf CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.LE)
                     ElseIf CurrentChar() = "<"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftLeftAssign)
                         Else
                             Result = NewToken(KS.ShiftLeft)
                         End If
                     Else
                         Result = NewToken(KS.LT)
                     End If
                 Case "="c
                     NextChar()
                     Result = NewToken(KS.Equals)
                 Case "!"c
                     NextChar()
                     Result = NewToken(KS.Exclamation)
                 Case "?"c
                     NextChar()
                     Result = NewToken(KS.Interrogation)
                 Case "&"c
                     Select Case PeekChar()
 #If EXTENDED Then
                         Case "b"c, "B"c, "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #Else
                         Case "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #End If
                             Result = GetNumber()
                         Case Else 'Not a number, but operator
                             NextChar()
                             EatWhiteSpace()
                             If CurrentChar() = "="c Then
                                 Result = NewToken(KS.ConcatAssign)
                                 NextChar()
                             Else
                                 Result = NewToken(KS.Concat)
                             End If
                     End Select
                 Case "*"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MultAssign)
                     Else
                         Result = NewToken(KS.Mult)
                     End If
                 Case "+"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.AddAssign)
                     Else
                         Result = NewToken(KS.Add)
                     End If
                 Case "-"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MinusAssign)
                     Else
                         Result = NewToken(KS.Minus)
                     End If
                 Case "^"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.PowerAssign)
                     Else
                         Result = NewToken(KS.Power)
                     End If
                 Case "\"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.IntDivAssign)
                     Else
                         Result = NewToken(KS.IntDivision)
                     End If
                 Case "#"c
                     'Type characters are already scanned when they appear after a literal. 
                     'If scanning gets here, it is not a type character.
                     If m_TokensSeenOnLine = 0 Then
                         Result = NewToken(KS.Numeral)
                         NextChar()
                     Else
                         Result = GetDate()
                     End If
                 Case "/"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.RealDivAssign)
                     Else
                         Result = NewToken(KS.RealDivision)
                     End If
                 Case " "c 'Space
                     NextChar()
                     If (CurrentChar() = "_"c) Then '
                         Dim i As Integer = 1
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         If IsNewLine(PeekChars(i)) Then
                             NextChar()
                             EatWhiteSpace()
                             EatNewLine()
                         End If
                     End If
                 Case nlTab ' Tab character
                     NextChar()
                 Case Else
                     If IsWhiteSpace() Then
                         NextChar()
                     ElseIf CanStartIdentifier() Then
                         Result = GetIdentifier()
                         If Result.IsKeyword AndAlso Result.Equals(KS.[REM]) Then
                             EatLine(False)
                             Result = Nothing
                         End If
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30037, GetCurrentLocation())
                         EatLine(False)
                     End If
             End Select
         Loop While Token.IsSomething(Result) = False
 
         If Result.IsEndOfLine = False Then
             m_TokensSeenOnLine += 1
         Else
             m_TokensSeenOnLine = 0
         End If
 
         Return Result
     End Function
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)(Compiler.CommandLine.Files)
         NextFile()
         LoadProjectConstants()
     End Sub
]]></clone_fragment>
<clone_fragment endline="1558" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\Scanner.vb" hamdist="0" pcid="8121" startline="1549"><![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler, ByVal Code As String)
         MyBase.New(Compiler)
     Private m_PeekedChars As New Generic.Queue(Of Char)
     Private m_Reader As System.IO.StreamReader
 
     Private m_StringBuilder(127) As Char
     Private m_StringBuilderLength As Integer
 
     ''' <summary>
     ''' If any tokens has been found on this line.
     ''' Reset by IncLine, set by NewToken
     ''' </summary>
     ''' <remarks></remarks>
     Private m_TokensSeenOnLine As Integer
 
     Private m_Files As Generic.Queue(Of CodeFile)
 
     Private m_Peeked As Token
 
     'Data about the current token
     Private m_LastWasNewline As Boolean
     Private m_Current As Token
     Private m_CurrentTypeCharacter As TypeCharacters.Characters
     Private m_CurrentTokenType As TokenType
     Private m_CurrentData As Object
 
 #Region "Conditional Compilation"
     'Data related to conditional compilation
     Private m_ProjectConstants As New ConditionalConstants
     Private m_CurrentConstants As ConditionalConstants
     Private m_Evaluator As New ConditionalExpression(Me)
 
     ''' <summary>
     ''' 0 if condition is false and has never been true
     ''' 1 if condition is true
     ''' -1 if condition has been true
     ''' </summary>
     ''' <remarks></remarks>
     Private m_ConditionStack As New Generic.List(Of Integer)
 
     Private m_Methods As New Generic.Dictionary(Of Mono.Cecil.MethodReference, Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute))
 
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
 
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
     End Property
 
     ReadOnly Property CurrentConstants() As ConditionalConstants
         Get
             Return m_CurrentConstants
         End Get
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
 
     Private Sub ResetCurrentConstants()
         m_CurrentConstants = New ConditionalConstants(m_ProjectConstants)
     End Sub
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, GetCurrentLocation())
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '='")
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Helper.AddError(Me, "Expected string literal")
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
 
     Public Function [Next]() As Token
         Do
             NextUnconditionally()
 
             If m_Current.IsEndOfCode Then
                 m_Peeked = m_Current
                 Return m_Current
             End If
 
             If m_Current.IsEndOfFile Then
                 ResetCurrentConstants()
                 Return m_Current
             End If
 
             If TokensSeenOnLine = 1 AndAlso m_Current = KS.Numeral Then
                 Me.NextUnconditionally()
                 If m_Current = KS.If Then
                     ParseIf()
                 ElseIf m_Current = KS.Else Then
                     ParseElse()
                 ElseIf m_Current = KS.ElseIf Then
                     ParseElseIf()
                 ElseIf m_Current = KS.Const Then
                     ParseConst()
                 ElseIf m_Current.Equals("ExternalSource") Then
                     ParseExternalSource()
                 ElseIf m_Current.Equals("Region") Then
                     ParseRegion()
                 ElseIf m_Current = KS.End Then
                     ParseEnd()
                 Else
                     Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If', 'ElseIf', 'Else', 'Const' or 'Region'.")
                     EatLine(False)
                 End If
             ElseIf IfdOut Then
                 If m_Current.IsEndOfLine = False Then EatLine(False)
                 Continue Do
             Else
                 If m_Current.IsEndOfLineOnly AndAlso m_LastWasNewline Then
                     Continue Do
                 End If
                 m_LastWasNewline = m_Current.IsEndOfLineOnly
                 Return m_Current
             End If
         Loop While m_Current.IsEndOfCode = False AndAlso m_Current.IsEndOfFile = False
         Return m_Current
     End Function
 
     Public Function Peek() As Token
         If Token.IsSomething(m_Peeked) Then Return m_Peeked
         m_Peeked = Me.Next
         Return m_Peeked
     End Function
 #End Region
 
 #Region "StringBuilder"
     Private Property StringBuilderLength As Integer
         Get
             Return m_StringBuilderLength
         End Get
         Set(ByVal value As Integer)
             m_StringBuilderLength = value
         End Set
     End Property
 
     Private Sub StringBuilderAppend(ByVal c As Char)
         m_StringBuilderLength += 1
         If m_StringBuilder Is Nothing Then
             ReDim m_StringBuilder(31)
         End If
         If m_StringBuilder.Length < m_StringBuilderLength Then
             Dim tmp(Math.Max(m_StringBuilder.Length * 2 - 1, m_StringBuilderLength)) As Char
             m_StringBuilder.CopyTo(tmp, 0)
             m_StringBuilder = tmp
         End If
         m_StringBuilder(m_StringBuilderLength - 1) = c
     End Sub
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
 #End Region
 
     Private Structure Data
         Public Type As TokenType
         Public Symbol As KS
         Public Data As Object
         Public TypeCharacter As TypeCharacters.Characters
 
         Public Sub Clear()
             Type = vbnc.TokenType.None
             Symbol = KS.None
             Data = Nothing
             TypeCharacter = TypeCharacters.Characters.None
         End Sub
     End Structure
 
     ReadOnly Property TokensSeenOnLine() As Integer
         Get
             Return m_TokensSeenOnLine
         End Get
     End Property
 
     ReadOnly Property TotalLineCount() As UInteger
         Get
             Return m_TotalLineCount
         End Get
     End Property
 
     ReadOnly Property TotalCharCount() As Integer
         Get
             Return m_TotalCharCount
         End Get
     End Property
 
     Private Function IsNewLine() As Boolean
         Return IsNewLine(CurrentChar)
     End Function
 
     Public Shared Function IsNewLine(ByVal chr As Char) As Boolean
         Return chr = nlA OrElse chr = nlD OrElse chr = nl2028 OrElse chr = nl2029 OrElse chr = nl0
     End Function
 
     Private Function IsUnderscoreCharacter(ByVal chr As Char) As Boolean
         'UnderscoreCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.ConnectorPunctuation
     End Function
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
 
     Private Function IsNumericCharacter(ByVal chr As Char) As Boolean
         'NumericCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.DecimalDigitNumber 'Nd
     End Function
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsFormattingCharacter(ByVal chr As Char) As Boolean
         'FormattingCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.Format 'Cf
     End Function
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
 
     Shared Function IsWhiteSpace(ByVal chr As Char) As Boolean
         Return chr = nlTab OrElse Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.SpaceSeparator
     End Function
 
     Private Function IsWhiteSpace() As Boolean
         Return IsWhiteSpace(CurrentChar())
     End Function
 
     Private Function IsComment(ByVal chr As Char) As Boolean
         Return chr = COMMENTCHAR1 OrElse chr = COMMENTCHAR2 OrElse chr = COMMENTCHAR3
     End Function
 
     Private Function IsComment() As Boolean
         Return IsComment(CurrentChar)
     End Function
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
 
     Public Shared Function IsSingleNewLine(ByVal chr1 As Char, ByVal chr2 As Char) As Boolean
         Return Not (chr1 = nlD AndAlso chr2 = nlA)
     End Function
 
     Private Sub EatComment()
         Select Case CurrentChar()
             Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'Traditional VB comment
                 EatLine(False) 'do not eat newline, it needs to be added as a token
                 Return
             Case Else
                 REM is taken care of some other place.
                 'Function should never be called if not a comment
                 Throw New InternalException("EatComment called with no comment.")
         End Select
     End Sub
 
     Private Sub EatWhiteSpace()
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
     End Sub
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
 
     Private Function CanStartIdentifier() As Boolean
         Return CanStartIdentifier(CurrentChar)
     End Function
 
     Private Function CanStartIdentifier(ByVal chr As Char) As Boolean
         Return IsAlphaCharacter(chr) OrElse IsUnderscoreCharacter(chr)
     End Function
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case """"c '
                     'If " followed by a ", output one "
                     If NextChar() = """" Then
                         StringBuilderAppend(""""c)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     'vbc accepts this...
                     Compiler.Report.ShowMessage(Messages.VBNC90003, GetCurrentLocation())
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC90004, GetCurrentLocation())
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
 
     Private Function GetNumber() As Token
         Dim Base As IntegerBase
         Dim bReal As Boolean
         Dim bE As Boolean
         Static Builder As New Text.StringBuilder
         Builder.Length = 0
 
         'First find the type of the number
         Select Case CurrentChar()
             Case "."c, "0"c To "9"c 'Decimal
                 Base = IntegerBase.Decimal
             Case "&"c
                 Select Case NextChar()
 #If EXTENDED Then
                     Case "b"c, "B"c 'Binary
                         Base = IntegerBase.Binary
 #End If
                     Case "d"c, "D"c 'Decimal
                         Base = IntegerBase.Decimal
                     Case "h"c, "H"c 'Hex
                         Base = IntegerBase.Hex
                     Case "o"c, "O"c 'Octal
                         Base = IntegerBase.Octal
                     Case Else
                         Throw New InternalException(GetCurrentLocation.ToString(Compiler)) 'Should never get here, this function should only be called with the correct specifiers.
                 End Select
                 NextChar()
             Case Else
                 Throw New InternalException("Invalid character
         End Select
 
         Dim ch As Char = CurrentChar()
         ' Then start the parsing
         Select Case Base
             Case IntegerBase.Decimal
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 If ch = "."c Then
                     If Me.IsNumericCharacter(Me.PeekChar) Then
                         Builder.Append(ch)
                         bReal = True
                         ch = NextChar()
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                     End If
                 End If
                 If ch = "E"c OrElse ch = "e"c Then
                     bE = True
                     bReal = True
                     Builder.Append(ch)
                     ch = NextChar()
                     If ch = "+"c OrElse ch = "-"c Then
                         Builder.Append(ch)
                         ch = NextChar()
                     End If
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                 End If
 #If EXTENDED Then
             Case IntegerBase.Binary
                 While ((ch >= "0"c) AndAlso (ch <= "1"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
 #End If
             Case IntegerBase.Hex
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case IntegerBase.Octal
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
 
         'Find the type character, if any
         Dim strType As String = ""
         Dim typeOfNumber As BuiltInDataTypes
         Dim typeCharacter As LiteralTypeCharacters_Characters = LiteralTypeCharacters_Characters.None
 
         Dim test As String
         test = CurrentChar()
         If test = "U" OrElse test = "u" Then test &= PeekChar()
         typeCharacter = LiteralTypeCharacters.GetTypeCharacter(test)
         If typeCharacter <> LiteralTypeCharacters_Characters.None Then
             NextChar()
             If test.Length = 2 Then NextChar()
             typeOfNumber = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
         End If
 
         If typeCharacter <> LiteralTypeCharacters_Characters.None AndAlso LiteralTypeCharacters.IsIntegral(typeCharacter) = False AndAlso Base <> IntegerBase.Decimal Then
             Compiler.Report.ShowMessage(Messages.VBNC90002, Me.GetCurrentLocation(), KS.Decimal.ToString)
         End If
 
         ' Found the string of the number
         Dim strResult As String = Builder.ToString
         Dim IntegerValue As ULong
 
         Select Case Base
             Case IntegerBase.Decimal
                 Try
                     Dim tp As BuiltInDataTypes
                     If typeCharacter = LiteralTypeCharacters_Characters.None Then
                         If bReal Then
                             tp = BuiltInDataTypes.Double
                         Else
                             tp = BuiltInDataTypes.Integer
                         End If
                     Else
                         tp = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
                     End If
                     Select Case tp
                         Case BuiltInDataTypes.Decimal
                             GetNumber = Token.CreateDecimalToken(GetCurrentLocation, Decimal.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Double
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, Double.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Single
                             GetNumber = Token.CreateSingleToken(GetCurrentLocation, Single.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Short, BuiltInDataTypes.UInteger, BuiltInDataTypes.ULong, BuiltInDataTypes.UShort
                             If bReal Then
                                 Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                                 IntegerValue = 0
                             Else
                                 'Try to parse the result
                                 IntegerValue = ULong.Parse(strResult, Helper.USCulture)
                             End If
                             'Check if value is out of range for data type.
                             Dim bOutOfRange As Boolean
                             'TODO
                             Select Case tp
                                 Case BuiltInDataTypes.Integer
                                     If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Long
                                     If IntegerValue > Long.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Short
                                     If IntegerValue > Short.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UInteger
                                     If IntegerValue > UInteger.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.ULong 'Not necessary
                                     '    If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UShort
                                     If IntegerValue > UShort.MaxValue Then bOutOfRange = True
                                 Case Else
                                     Throw New InternalException("")
                             End Select
                             If bOutOfRange AndAlso typeCharacter <> LiteralTypeCharacters_Characters.None Then
                                 Compiler.Report.ShowMessage(Messages.VBNC30439, GetCurrentLocation(), typeCharacter.ToString)
                             End If
                             GetNumber = GetIntegralToken(ULong.Parse(strResult, Helper.USCulture), Base, typeCharacter)
                         Case Else
                             Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                     End Select
                 Catch ex As System.OverflowException
                     Compiler.Report.ShowMessage(Messages.VBNC30036, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90005, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 End Try
 #If EXTENDED Then
             Case IntegerBase.Binary
                 Try
                     IntegerValue = Helper.BinToInt(strResult)
                     IntegerValue = ConvertNonDecimalBits(IntegerValue, typeCharacter)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, "binary")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
 #End If
             Case IntegerBase.Hex
                 Try
                     'Console.WriteLine("Hex
                     IntegerValue = Helper.HexToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, Me.GetCurrentLocation, "hexadecimal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case IntegerBase.Octal
                 Try
                     IntegerValue = Helper.OctToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, GetCurrentLocation(), "octal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
     End Function
 
     Private Function GetIntegralToken(ByVal Value As ULong, ByVal Base As IntegerBase, ByVal TypeCharacter As LiteralTypeCharacters_Characters) As Token
         Dim case_type As BuiltInDataTypes
         'TODO
         If TypeCharacter = LiteralTypeCharacters_Characters.None Then
             If Value > Integer.MaxValue Then
                 case_type = BuiltInDataTypes.Long
             Else
                 case_type = BuiltInDataTypes.Integer
             End If
         Else
             case_type = LiteralTypeCharacters.GetBuiltInType(TypeCharacter)
         End If
 
         Select Case case_type
             Case BuiltInDataTypes.Integer
                 Return Token.CreateInt32Token(GetCurrentLocation, ExtractInt(Value, Base))
             Case BuiltInDataTypes.UInteger
                 Return Token.CreateUInt32Token(GetCurrentLocation, ExtractUInt(Value, Base))
             Case BuiltInDataTypes.Long
                 Return Token.CreateInt64Token(GetCurrentLocation, ExtractLong(Value, Base))
             Case BuiltInDataTypes.ULong
                 Return Token.CreateUInt64Token(GetCurrentLocation, ExtractULong(Value, Base))
             Case BuiltInDataTypes.Short
                 Return Token.CreateInt16Token(GetCurrentLocation, ExtractShort(Value, Base))
             Case BuiltInDataTypes.UShort
                 Return Token.CreateUInt16Token(GetCurrentLocation, ExtractUShort(Value, Base))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Function GetCurrentLocation() As Span
         Return New Span(m_CodeFileIndex, m_CurrentLine, m_CurrentColumn)
     End Function
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return GetCurrentLocation()
         End Get
     End Property
 
     Private ReadOnly Property CurrentChar() As Char
         Get
             Return m_CurrentChar
         End Get
     End Property
 
     Private Function NextChar() As Char
         If m_CurrentColumn < 255 Then m_CurrentColumn += CByte(1)
         m_TotalCharCount += 1
 
         m_PreviousChar = m_CurrentChar
         If m_PeekedChars.Count > 0 Then
             m_CurrentChar = m_PeekedChars.Dequeue
         Else
             If m_Reader.EndOfStream Then
                 m_CurrentChar = nl0
             Else
                 If m_Reader.EndOfStream Then
                     m_EndOfFile = True
                     m_CurrentChar = nl0
                 Else
                     m_CurrentChar = Convert.ToChar(m_Reader.Read())
                 End If
             End If
         End If
 
         Return m_CurrentChar
     End Function
 
     Private ReadOnly Property PreviousChar() As Char
         Get
             Return m_PreviousChar
         End Get
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
 
     Private Function PeekChars(ByVal Chars As Integer) As Char
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Return m_PeekedChars.ToArray()(Chars - 1)
     End Function
 
     ''' <summary>
     ''' Returns true if the current character is the last character in the scanner.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function IsLastChar() As Boolean
         Return m_Reader.EndOfStream
     End Function
 
     ''' <summary>
     ''' Next line!
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub IncLine()
         m_CurrentLine += 1UI
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
     End Sub
 
     ''' <summary>
     ''' Creates a new symbol token of the specified symbol.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function NewToken(ByVal Symbol As KS) As Token
         Return Token.CreateSymbolToken(GetCurrentLocation, Symbol)
     End Function
 
     Private Function GetNextToken() As Token
         Dim Result As Token = Nothing
         Do
             Select Case CurrentChar()
                 Case """"c 'String Literal
                     Result = GetString()
                 Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'VB Comment
                     EatComment()
                 Case nlD, nlA, nl2028, nl2029 'New line
                     EatNewLine()
                     Result = Token.CreateEndOfLineToken(GetCurrentLocation)
                 Case nl0 'End of file
                     Result = Token.CreateEndOfFileToken(GetCurrentLocation)
                 Case "
                     NextChar()
                     Result = NewToken(KS.Colon)
                 Case ","c ',
                     NextChar()
                     Result = NewToken(KS.Comma)
                 Case "."c
                     If PeekChar() >= "0"c AndAlso PeekChar() <= "9"c Then
                         Result = GetNumber()
                     Else
                         NextChar()
                         Result = NewToken(KS.Dot)
                     End If
                 Case "0"c To "9"c
                     Result = GetNumber()
                 Case "("c
                     NextChar()
                     Result = NewToken(KS.LParenthesis)
                 Case ")"c
                     NextChar()
                     Result = NewToken(KS.RParenthesis)
                 Case "["c
                     Result = GetEscapedIdentifier()
                 Case "{"c
                     NextChar()
                     Result = NewToken(KS.LBrace)
                 Case "}"c
                     NextChar()
                     Result = NewToken(KS.RBrace)
                 Case ">"c
                     NextChar()
                     EatWhiteSpace()
                     'If CurrentChar() = "<"c Then
                     '    NextChar()
                     '    Result = NewToken(KS.NotEqual)
                     'Else
                     If CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.GE)
                     ElseIf CurrentChar() = ">"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftRightAssign)
                         Else
                             Result = NewToken(KS.ShiftRight)
                         End If
                     Else
                         Result = NewToken(KS.GT)
                     End If
                 Case "<"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = ">"c) Then
                         NextChar()
                         Result = NewToken(KS.NotEqual)
                     ElseIf CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.LE)
                     ElseIf CurrentChar() = "<"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftLeftAssign)
                         Else
                             Result = NewToken(KS.ShiftLeft)
                         End If
                     Else
                         Result = NewToken(KS.LT)
                     End If
                 Case "="c
                     NextChar()
                     Result = NewToken(KS.Equals)
                 Case "!"c
                     NextChar()
                     Result = NewToken(KS.Exclamation)
                 Case "?"c
                     NextChar()
                     Result = NewToken(KS.Interrogation)
                 Case "&"c
                     Select Case PeekChar()
 #If EXTENDED Then
                         Case "b"c, "B"c, "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #Else
                         Case "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #End If
                             Result = GetNumber()
                         Case Else 'Not a number, but operator
                             NextChar()
                             EatWhiteSpace()
                             If CurrentChar() = "="c Then
                                 Result = NewToken(KS.ConcatAssign)
                                 NextChar()
                             Else
                                 Result = NewToken(KS.Concat)
                             End If
                     End Select
                 Case "*"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MultAssign)
                     Else
                         Result = NewToken(KS.Mult)
                     End If
                 Case "+"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.AddAssign)
                     Else
                         Result = NewToken(KS.Add)
                     End If
                 Case "-"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MinusAssign)
                     Else
                         Result = NewToken(KS.Minus)
                     End If
                 Case "^"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.PowerAssign)
                     Else
                         Result = NewToken(KS.Power)
                     End If
                 Case "\"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.IntDivAssign)
                     Else
                         Result = NewToken(KS.IntDivision)
                     End If
                 Case "#"c
                     'Type characters are already scanned when they appear after a literal. 
                     'If scanning gets here, it is not a type character.
                     If m_TokensSeenOnLine = 0 Then
                         Result = NewToken(KS.Numeral)
                         NextChar()
                     Else
                         Result = GetDate()
                     End If
                 Case "/"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.RealDivAssign)
                     Else
                         Result = NewToken(KS.RealDivision)
                     End If
                 Case " "c 'Space
                     NextChar()
                     If (CurrentChar() = "_"c) Then '
                         Dim i As Integer = 1
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         If IsNewLine(PeekChars(i)) Then
                             NextChar()
                             EatWhiteSpace()
                             EatNewLine()
                         End If
                     End If
                 Case nlTab ' Tab character
                     NextChar()
                 Case Else
                     If IsWhiteSpace() Then
                         NextChar()
                     ElseIf CanStartIdentifier() Then
                         Result = GetIdentifier()
                         If Result.IsKeyword AndAlso Result.Equals(KS.[REM]) Then
                             EatLine(False)
                             Result = Nothing
                         End If
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30037, GetCurrentLocation())
                         EatLine(False)
                     End If
             End Select
         Loop While Token.IsSomething(Result) = False
 
         If Result.IsEndOfLine = False Then
             m_TokensSeenOnLine += 1
         Else
             m_TokensSeenOnLine = 0
         End If
 
         Return Result
     End Function
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)(Compiler.CommandLine.Files)
         NextFile()
         LoadProjectConstants()
     End Sub
 
     Public Sub New(ByVal Compiler As Compiler, ByVal Code As String)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)()
         Dim cf As New CodeFile("<Internal>", "", Compiler, Code)
         m_Files.Enqueue(cf)
         Compiler.CommandLine.Files.Add(cf)
         NextFile()
         LoadProjectConstants()
     End Sub
]]></clone_fragment>
<clone_fragment endline="515" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" hamdist="15" pcid="2671" startline="56"><![CDATA[
 			28, 67, 78,
 			105, 108, 109, 114, 162, 164, 168, 169, 183, 184, 197,
 			219, 251, 252, 253, 278, 282,
 			402, 414, 419, 420, 429, 436, 440, 458, 464, 465, 467, 469, 472,
 			612, 618, 626, 628, 642, 649, 652, 658, 659, 660, 661, 665, 672, 675, 693,
 			728,
 			809,
 			1030, 1058, 1066,
 			1522, 1570, 1571, 1572, 1573, 1574, 1580, 1581, 1584, 1587, 1589, 1590, 1591, 1592,
 			1607, 1616, 1633, 1634, 1635, 1685, 1690, 1691, 1692, 1695, 1696, 1699, 1683,
 			1700, 1701, 1702, 1709, 1717, 1718, 1720,
 			1901, 1981,
 			2002, 2023, 2029,
 			3000, 3001, 3002, 3003, 3005, 3006, 3007, 3008, 3009,
 			3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019,
 			3021, 3022, 3023, 3024, 3026, 3027
 		};
 
 		static HashSet<int> AllWarningsHashSet;
 
 		public Report (ReportPrinter printer)
 		{
 			if (printer == null)
 				throw new ArgumentNullException ("printer");
 
 			this.printer = printer;
 			warning_level = 4;
 		}
 
 		public void DisableReporting ()
 		{
 			++reporting_disabled;
 		}
 
 		public void EnableReporting ()
 		{
 			--reporting_disabled;
 		}
 
 		public void FeatureIsNotAvailable (Location loc, string feature)
 		{
 			string version;
 			switch (RootContext.Version) {
 			case LanguageVersion.ISO_1
 				version = "1.0";
 				break;
 			case LanguageVersion.ISO_2
 				version = "2.0";
 				break;
 			case LanguageVersion.V_3
 				version = "3.0";
 				break;
 			default
 				throw new InternalErrorException ("Invalid feature version", RootContext.Version);
 			}
 
 			Error (1644, loc,
 				"Feature `{0}' cannot be used because it is not part of the C# {1} language specification",
 				      feature, version);
 		}
 
 		public void FeatureIsNotSupported (Location loc, string feature)
 		{
 			Error (1644, loc,
 				"Feature `{0}' is not supported in Mono mcs1 compiler. Consider using the `gmcs' compiler instead",
 				feature);
 		}
 		
 		bool IsWarningEnabled (int code, int level, Location loc)
 		{
 			if (WarningLevel < level)
 				return false;
 
 			if (IsWarningDisabledGlobally (code))
 				return false;
 
 			if (warning_regions_table == null || loc.IsNull)
 				return true;
 
 			WarningRegions regions;
 			if (!warning_regions_table.TryGetValue (loc.File, out regions))
 				return true;
 
 			return regions.IsWarningEnabled (code, loc.Row);
 		}
 
 		public bool IsWarningDisabledGlobally (int code)
 		{
 			return warning_ignore_table != null && warning_ignore_table.Contains (code);
 		}
 
 		bool IsWarningAsError (int code)
 		{
 			bool is_error = WarningsAreErrors;
 
 			// Check specific list
 			if (warnings_as_error != null)
 				is_error |= warnings_as_error.Contains (code);
 
 			// Ignore excluded warnings
 			if (warnings_only != null && warnings_only.Contains (code))
 				is_error = false;
 
 			return is_error;
 		}
 		        
 		public void RuntimeMissingSupport (Location loc, string feature) 
 		{
 			Error (-88, loc, "Your .NET Runtime does not support `{0}'. Please use the latest Mono runtime instead.", feature);
 		}
 
 		/// <summary>
 		/// In most error cases is very useful to have information about symbol that caused the error.
 		/// Call this method before you call Report.Error when it makes sense.
 		/// </summary>
 		public void SymbolRelatedToPreviousError (Location loc, string symbol)
 		{
 			SymbolRelatedToPreviousError (loc.ToString ());
 		}
 
 		public void SymbolRelatedToPreviousError (MemberSpec ms)
 		{
 			if (reporting_disabled > 0 || !printer.HasRelatedSymbolSupport)
 				return;
 
 			var mc = ms.MemberDefinition as MemberCore;
 			while (ms is ElementTypeSpec) {
 				ms = ((ElementTypeSpec) ms).Element;
 				mc = ms.MemberDefinition as MemberCore;
 			}
 
 			if (mc != null) {
 				SymbolRelatedToPreviousError (mc);
 			} else {
 				if (ms.DeclaringType != null)
 					ms = ms.DeclaringType;
 
 				var imported_type = ms.MemberDefinition as ImportedTypeDefinition;
 				if (imported_type != null) {
 					var iad = imported_type.DeclaringAssembly as ImportedAssemblyDefinition;
 					SymbolRelatedToPreviousError (iad.Location);
 				}
 			}
 		}
 
 		public void SymbolRelatedToPreviousError (MemberCore mc)
 		{
 			SymbolRelatedToPreviousError (mc.Location, mc.GetSignatureForError ());
 		}
 
 		public void SymbolRelatedToPreviousError (string loc)
 		{
 			string msg = String.Format ("{0} (Location of the symbol related to previous ", loc);
 			if (extra_information.Contains (msg))
 				return;
 
 			extra_information.Add (msg);
 		}
 
 		public void AddWarningAsError (string warningId)
 		{
 			int id;
 			try {
 				id = int.Parse (warningId);
 			} catch {
 				CheckWarningCode (warningId, Location.Null);
 				return;
 			}
 
 			if (!CheckWarningCode (id, Location.Null))
 				return;
 
 			if (warnings_as_error == null)
 				warnings_as_error = new List<int> ();
 			
 			warnings_as_error.Add (id);
 		}
 
 		public void RemoveWarningAsError (string warningId)
 		{
 			int id;
 			try {
 				id = int.Parse (warningId);
 			} catch {
 				CheckWarningCode (warningId, Location.Null);
 				return;
 			}
 
 			if (!CheckWarningCode (id, Location.Null))
 				return;
 
 			if (warnings_only == null)
 				warnings_only = new List<int> ();
 
 			warnings_only.Add (id);
 		}
 
 		public bool CheckWarningCode (string code, Location loc)
 		{
 			Warning (1691, 1, loc, "`{0}' is not a valid warning number", code);
 			return false;
 		}
 
 		public bool CheckWarningCode (int code, Location loc)
 		{
 			if (AllWarningsHashSet == null)
 				AllWarningsHashSet = new HashSet<int> (AllWarnings);
 
 			if (AllWarningsHashSet.Contains (code))
 				return true;
 
 			return CheckWarningCode (code.ToString (), loc);
 		}
 
 		public void ExtraInformation (Location loc, string msg)
 		{
 			extra_information.Add (String.Format ("{0} {1}", loc, msg));
 		}
 
 		public WarningRegions RegisterWarningRegion (Location location)
 		{
 			WarningRegions regions;
 			if (warning_regions_table == null) {
 				regions = null;
 				warning_regions_table = new Dictionary<int, WarningRegions> ();
 			} else {
 				warning_regions_table.TryGetValue (location.File, out regions);
 			}
 
 			if (regions == null) {
 				regions = new WarningRegions ();
 				warning_regions_table.Add (location.File, regions);
 			}
 
 			return regions;
 		}
 
 		public void Warning (int code, int level, Location loc, string message)
 		{
 			if (reporting_disabled > 0)
 				return;
 
 			if (!IsWarningEnabled (code, level, loc))
 				return;
 
 			AbstractMessage msg;
 			if (IsWarningAsError (code))
 				msg = new ErrorMessage (code, loc, message, extra_information);
 			else
 				msg = new WarningMessage (code, loc, message, extra_information);
 
 			extra_information.Clear ();
 			printer.Print (msg);
 		}
 
 		public void Warning (int code, int level, Location loc, string format, string arg)
 		{
 			Warning (code, level, loc, String.Format (format, arg));
 		}
 
 		public void Warning (int code, int level, Location loc, string format, string arg1, string arg2)
 		{
 			Warning (code, level, loc, String.Format (format, arg1, arg2));
 		}
 
 		public void Warning (int code, int level, Location loc, string format, params object[] args)
 		{
 			Warning (code, level, loc, String.Format (format, args));
 		}
 
 		public void Warning (int code, int level, string message)
 		{
 			Warning (code, level, Location.Null, message);
 		}
 
 		public void Warning (int code, int level, string format, string arg)
 		{
 			Warning (code, level, Location.Null, format, arg);
 		}
 
 		public void Warning (int code, int level, string format, string arg1, string arg2)
 		{
 			Warning (code, level, Location.Null, format, arg1, arg2);
 		}
 
 		public void Warning (int code, int level, string format, params string[] args)
 		{
 			Warning (code, level, Location.Null, String.Format (format, args));
 		}
 
 		//
 		// Warnings encountered so far
 		//
 		public int Warnings {
 			get { return printer.WarningsCount; }
 		}
 
 		public void Error (int code, Location loc, string error)
 		{
 			if (reporting_disabled > 0)
 				return;
 
 			ErrorMessage msg = new ErrorMessage (code, loc, error, extra_information);
 			extra_information.Clear ();
 
 			printer.Print (msg);
 		}
 
 		public void Error (int code, Location loc, string format, string arg)
 		{
 			Error (code, loc, String.Format (format, arg));
 		}
 
 		public void Error (int code, Location loc, string format, string arg1, string arg2)
 		{
 			Error (code, loc, String.Format (format, arg1, arg2));
 		}
 
 		public void Error (int code, Location loc, string format, params string[] args)
 		{
 			Error (code, loc, String.Format (format, args));
 		}
 
 		public void Error (int code, string error)
 		{
 			Error (code, Location.Null, error);
 		}
 
 		public void Error (int code, string format, string arg)
 		{
 			Error (code, Location.Null, format, arg);
 		}
 
 		public void Error (int code, string format, string arg1, string arg2)
 		{
 			Error (code, Location.Null, format, arg1, arg2);
 		}
 
 		public void Error (int code, string format, params string[] args)
 		{
 			Error (code, Location.Null, String.Format (format, args));
 		}
 
 		//
 		// Errors encountered so far
 		//
 		public int Errors {
 			get { return printer.ErrorsCount; }
 		}
 
 		public bool IsDisabled {
 			get {
 				return reporting_disabled > 0;
 			}
 		}
 
 		public ReportPrinter Printer {
 			get { return printer; }
 		}
 
 		public void SetIgnoreWarning (int code)
 		{
 			if (warning_ignore_table == null)
 				warning_ignore_table = new HashSet<int> ();
 
 			warning_ignore_table.Add (code);
 		}
 
 		public ReportPrinter SetPrinter (ReportPrinter printer)
 		{
 			ReportPrinter old = this.printer;
 			this.printer = printer;
 			return old;
 		}
 
 		public int WarningLevel {
 			get {
 				return warning_level;
 			}
 			set {
 				warning_level = value;
 			}
 		}
 
 		[Conditional ("MCS_DEBUG")]
 		static public void Debug (string message, params object[] args)
 		{
 			Debug (4, message, args);
 		}
 			
 		[Conditional ("MCS_DEBUG")]
 		static public void Debug (int category, string message, params object[] args)
 		{
 			if ((category & DebugFlags) == 0)
 				return;
 
 			StringBuilder sb = new StringBuilder (message);
 
 			if ((args != null) && (args.Length > 0)) {
 				sb.Append ("
 
 				bool first = true;
 				foreach (object arg in args) {
 					if (first)
 						first = false;
 					else
 						sb.Append (", ");
 					if (arg == null)
 						sb.Append ("null");
 //					else if (arg is ICollection)
 //						sb.Append (PrintCollection ((ICollection) arg));
 					else
 						sb.Append (arg);
 				}
 			}
 
 			Console.WriteLine (sb.ToString ());
 		}
 /*
 		static public string PrintCollection (ICollection collection)
 		{
 			StringBuilder sb = new StringBuilder ();
 
 			sb.Append (collection.GetType ());
 			sb.Append ("(");
 
 			bool first = true;
 			foreach (object o in collection) {
 				if (first)
 					first = false;
 				else
 					sb.Append (", ");
 				sb.Append (o);
 			}
 
 			sb.Append (")");
 			return sb.ToString ();
 		}
 */ 
 	}
 
 	public abstract class AbstractMessage
 	{
 		readonly string[] extra_info;
 		protected readonly int code;
 		protected readonly Location location;
 		readonly string message;
 
 		protected AbstractMessage (int code, Location loc, string msg, List<string> extraInfo)
 		{
 			this.code = code;
 			if (code < 0)
 				this.code = 8000 - code;
 
 			this.location = loc;
 			this.message = msg;
 			if (extraInfo.Count != 0) {
 				this.extra_info = extraInfo.ToArray ();
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="1149" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" hamdist="14" pcid="215" startline="1036"><![CDATA[
 
 		//
 		// Checks all appropriate container members for CLS compliance
 		//
 		public void VerifyClsCompliance (TypeSpec container, Report report)
 		{
 			if (locase_members != null)
 				return;
 
 			if (container.BaseType == null) {
 				locase_members = new Dictionary<string, MemberSpec[]> (member_hash.Count); // StringComparer.OrdinalIgnoreCase);
 			} else {
 				container.BaseType.MemberCache.VerifyClsCompliance (container.BaseType, report);
 				locase_members = new Dictionary<string, MemberSpec[]> (container.BaseType.MemberCache.locase_members); //, StringComparer.OrdinalIgnoreCase);
 			}
 
 			var is_imported_type = container.MemberDefinition.IsImported;
 			foreach (var entry in container.MemberCache.member_hash) {
 				for (int i = 0; i < entry.Value.Count; ++i ) {
 					var name_entry = entry.Value[i];
 					if ((name_entry.Modifiers & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 						continue;
 
 					if ((name_entry.Modifiers & (Modifiers.OVERRIDE | Modifiers.COMPILER_GENERATED)) != 0)
 						continue;
 
 					if ((name_entry.Kind & MemberKind.MaskType) == 0)
 						continue;
 
 					if (name_entry.MemberDefinition.IsNotCLSCompliant ())
 					    continue;
 
 					IParametersMember p_a = name_entry as IParametersMember;
 					if (p_a != null && !name_entry.IsAccessor) {
 						if (!is_imported_type) {
 							var p_a_pd = p_a.Parameters;
 							for (int ii = i + 1; ii < entry.Value.Count; ++ii) {
 								var checked_entry = entry.Value[ii];
 								IParametersMember p_b = checked_entry as IParametersMember;
 								if (p_b == null)
 									continue;
 
 								if (p_a_pd.Count != p_b.Parameters.Count)
 									continue;
 
 								if (checked_entry.IsAccessor)
 									continue;
 
 								var res = ParametersCompiled.IsSameClsSignature (p_a.Parameters, p_b.Parameters);
 								if (res != 0) {
 									var last = GetLaterDefinedMember (checked_entry, name_entry);
 									if (last == checked_entry.MemberDefinition) {
 										report.SymbolRelatedToPreviousError (name_entry);
 									} else {
 										report.SymbolRelatedToPreviousError (checked_entry);
 									}
 
 									if ((res & 1) != 0) {
 										report.Warning (3006, 1, last.Location,
 												"Overloaded method `{0}' differing only in ref or out, or in array rank, is not CLS-compliant",
 												name_entry.GetSignatureForError ());
 									}
 
 									if ((res & 2) != 0) {
 										report.Warning (3007, 1, last.Location,
 											"Overloaded method `{0}' differing only by unnamed array types is not CLS-compliant",
 											name_entry.GetSignatureForError ());
 									}
 								}
 							}
 							for (int ii = i + 1; ii < entry.Value.Count; ++ii) {
 								var checked_entry = entry.Value[ii];
 								IParametersMember p_b = checked_entry as IParametersMember;
 								if (p_b == null)
 									continue;
 
 								if (p_a_pd.Count != p_b.Parameters.Count)
 									continue;
 
 								if (checked_entry.IsAccessor)
 									continue;
 
 								var res = ParametersCompiled.IsSameClsSignature (p_a.Parameters, p_b.Parameters);
 								if (res != 0) {
 									var last = GetLaterDefinedMember (checked_entry, name_entry);
 									if (last == checked_entry.MemberDefinition) {
 										report.SymbolRelatedToPreviousError (name_entry);
 									} else {
 										report.SymbolRelatedToPreviousError (checked_entry);
 									}
 
 									if ((res & 1) != 0) {
 										report.Warning (3006, 1, last.Location,
 												"Overloaded method `{0}' differing only in ref or out, or in array rank, is not CLS-compliant",
 												name_entry.GetSignatureForError ());
 									}
 
 									if ((res & 2) != 0) {
 										report.Warning (3007, 1, last.Location,
 											"Overloaded method `{0}' differing only by unnamed array types is not CLS-compliant",
 											name_entry.GetSignatureForError ());
 									}
 								}
 							}
 						}
 					}
 
 					if (i > 0 || name_entry.Kind == MemberKind.Constructor || name_entry.Kind == MemberKind.Indexer)
 						continue;
 
 					var name_entry_locase = name_entry.Name.ToLowerInvariant ();
 
 					MemberSpec[] found;
 					if (!locase_members.TryGetValue (name_entry_locase, out found)) {
 						found = new MemberSpec[] { name_entry };
 						locase_members.Add (name_entry_locase, found);
 					} else {
 						bool same_names_only = true;
 						foreach (var f in found) {
 							if (f.Name == name_entry.Name)
 								continue;
 
 //							if (f.IsAccessor && name_entry.IsAccessor)
 //								continue;
 
 							same_names_only = false;
 							if (!is_imported_type) {
 								var last = GetLaterDefinedMember (f, name_entry);
 								if (last == f.MemberDefinition) {
 									report.SymbolRelatedToPreviousError (name_entry);
 								} else {
 									report.SymbolRelatedToPreviousError (f);
 								}
 
 								report.Warning (3005, 1, last.Location,
 									"Identifier `{0}' differing only in case is not CLS-compliant", last.GetSignatureForError ());
 							}
 						}
 						foreach (var f in found) {
 							if (f.Name == name_entry.Name)
 								continue;
 
 //							if (f.IsAccessor && name_entry.IsAccessor)
 //								continue;
 
 							same_names_only = false;
 							if (!is_imported_type) {
 								var last = GetLaterDefinedMember (f, name_entry);
 								if (last == f.MemberDefinition) {
 									report.SymbolRelatedToPreviousError (name_entry);
 								} else {
 									report.SymbolRelatedToPreviousError (f);
 								}
 
 								report.Warning (3005, 1, last.Location,
 									"Identifier `{0}' differing only in case is not CLS-compliant", last.GetSignatureForError ());
 							}
 						}
 
 						if (!same_names_only) {
 							Array.Resize (ref found, found.Length + 1);
 							found[found.Length - 1] = name_entry;
 							locase_members[name_entry_locase] = found;
 						}
 					}
 				}
 				for (int i = 0; i < entry.Value.Count; ++i ) {
 					var name_entry = entry.Value[i];
 					if ((name_entry.Modifiers & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 						continue;
 
 					if ((name_entry.Modifiers & (Modifiers.OVERRIDE | Modifiers.COMPILER_GENERATED)) != 0)
 						continue;
 
 					if ((name_entry.Kind & MemberKind.MaskType) == 0)
 						continue;
 
 					if (name_entry.MemberDefinition.IsNotCLSCompliant ())
 					    continue;
 
 					IParametersMember p_a = name_entry as IParametersMember;
 					if (p_a != null && !name_entry.IsAccessor) {
 						if (!is_imported_type) {
 							var p_a_pd = p_a.Parameters;
 							for (int ii = i + 1; ii < entry.Value.Count; ++ii) {
 								var checked_entry = entry.Value[ii];
 								IParametersMember p_b = checked_entry as IParametersMember;
 								if (p_b == null)
 									continue;
 
 								if (p_a_pd.Count != p_b.Parameters.Count)
 									continue;
 
 								if (checked_entry.IsAccessor)
 									continue;
 
 								var res = ParametersCompiled.IsSameClsSignature (p_a.Parameters, p_b.Parameters);
 								if (res != 0) {
 									var last = GetLaterDefinedMember (checked_entry, name_entry);
 									if (last == checked_entry.MemberDefinition) {
 										report.SymbolRelatedToPreviousError (name_entry);
 									} else {
 										report.SymbolRelatedToPreviousError (checked_entry);
 									}
 
 									if ((res & 1) != 0) {
 										report.Warning (3006, 1, last.Location,
 												"Overloaded method `{0}' differing only in ref or out, or in array rank, is not CLS-compliant",
 												name_entry.GetSignatureForError ());
 									}
 
 									if ((res & 2) != 0) {
 										report.Warning (3007, 1, last.Location,
 											"Overloaded method `{0}' differing only by unnamed array types is not CLS-compliant",
 											name_entry.GetSignatureForError ());
 									}
 								}
 							}
 						}
 					}
 
 					if (i > 0 || name_entry.Kind == MemberKind.Constructor || name_entry.Kind == MemberKind.Indexer)
 						continue;
 
 					var name_entry_locase = name_entry.Name.ToLowerInvariant ();
 
 					MemberSpec[] found;
 					if (!locase_members.TryGetValue (name_entry_locase, out found)) {
 						found = new MemberSpec[] { name_entry };
 						locase_members.Add (name_entry_locase, found);
 					} else {
 						bool same_names_only = true;
 						foreach (var f in found) {
 							if (f.Name == name_entry.Name)
 								continue;
 
 //							if (f.IsAccessor && name_entry.IsAccessor)
 //								continue;
 
 							same_names_only = false;
 							if (!is_imported_type) {
 								var last = GetLaterDefinedMember (f, name_entry);
 								if (last == f.MemberDefinition) {
 									report.SymbolRelatedToPreviousError (name_entry);
 								} else {
 									report.SymbolRelatedToPreviousError (f);
 								}
 
 								report.Warning (3005, 1, last.Location,
 									"Identifier `{0}' differing only in case is not CLS-compliant", last.GetSignatureForError ());
 							}
 						}
 
 						if (!same_names_only) {
 							Array.Resize (ref found, found.Length + 1);
 							found[found.Length - 1] = name_entry;
 							locase_members[name_entry_locase] = found;
 						}
 					}
 				}
 			}
 			foreach (var entry in container.MemberCache.member_hash) {
 				for (int i = 0; i < entry.Value.Count; ++i ) {
 					var name_entry = entry.Value[i];
 					if ((name_entry.Modifiers & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 						continue;
 
 					if ((name_entry.Modifiers & (Modifiers.OVERRIDE | Modifiers.COMPILER_GENERATED)) != 0)
 						continue;
 
 					if ((name_entry.Kind & MemberKind.MaskType) == 0)
 						continue;
 
 					if (name_entry.MemberDefinition.IsNotCLSCompliant ())
 					    continue;
 
 					IParametersMember p_a = name_entry as IParametersMember;
 					if (p_a != null && !name_entry.IsAccessor) {
 						if (!is_imported_type) {
 							var p_a_pd = p_a.Parameters;
 							for (int ii = i + 1; ii < entry.Value.Count; ++ii) {
 								var checked_entry = entry.Value[ii];
 								IParametersMember p_b = checked_entry as IParametersMember;
 								if (p_b == null)
 									continue;
 
 								if (p_a_pd.Count != p_b.Parameters.Count)
 									continue;
 
 								if (checked_entry.IsAccessor)
 									continue;
 
 								var res = ParametersCompiled.IsSameClsSignature (p_a.Parameters, p_b.Parameters);
 								if (res != 0) {
 									var last = GetLaterDefinedMember (checked_entry, name_entry);
 									if (last == checked_entry.MemberDefinition) {
 										report.SymbolRelatedToPreviousError (name_entry);
 									} else {
 										report.SymbolRelatedToPreviousError (checked_entry);
 									}
 
 									if ((res & 1) != 0) {
 										report.Warning (3006, 1, last.Location,
 												"Overloaded method `{0}' differing only in ref or out, or in array rank, is not CLS-compliant",
 												name_entry.GetSignatureForError ());
 									}
 
 									if ((res & 2) != 0) {
 										report.Warning (3007, 1, last.Location,
 											"Overloaded method `{0}' differing only by unnamed array types is not CLS-compliant",
 											name_entry.GetSignatureForError ());
 									}
 								}
 							}
 						}
 					}
 
 					if (i > 0 || name_entry.Kind == MemberKind.Constructor || name_entry.Kind == MemberKind.Indexer)
 						continue;
 
 					var name_entry_locase = name_entry.Name.ToLowerInvariant ();
 
 					MemberSpec[] found;
 					if (!locase_members.TryGetValue (name_entry_locase, out found)) {
 						found = new MemberSpec[] { name_entry };
 						locase_members.Add (name_entry_locase, found);
 					} else {
 						bool same_names_only = true;
 						foreach (var f in found) {
 							if (f.Name == name_entry.Name)
 								continue;
 
 //							if (f.IsAccessor && name_entry.IsAccessor)
 //								continue;
 
 							same_names_only = false;
 							if (!is_imported_type) {
 								var last = GetLaterDefinedMember (f, name_entry);
 								if (last == f.MemberDefinition) {
 									report.SymbolRelatedToPreviousError (name_entry);
 								} else {
 									report.SymbolRelatedToPreviousError (f);
 								}
 
 								report.Warning (3005, 1, last.Location,
 									"Identifier `{0}' differing only in case is not CLS-compliant", last.GetSignatureForError ());
 							}
 						}
 
 						if (!same_names_only) {
 							Array.Resize (ref found, found.Length + 1);
 							found[found.Length - 1] = name_entry;
 							locase_members[name_entry_locase] = found;
 						}
 					}
 				}
 			}
 		}
]]></clone_fragment>
<clone_fragment endline="303" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" hamdist="8" pcid="4039" startline="133"><![CDATA[
 
 		//
 		// Resolve the constraints types with only possible early checks, return
 		// value `false' is reserved for recursive failure
 		//
 		public bool Resolve (IMemberContext context, TypeParameter tp)
 		{
 			if (resolved)
 				return true;
 
 			if (resolving)
 				return false;
 
 			resolving = true;
 			var spec = tp.Type;
 			List<TypeParameterSpec> tparam_types = null;
 			bool iface_found = false;
 
 			spec.BaseType = TypeManager.object_type;
 
 			for (int i = 0; i < constraints.Count; ++i) {
 				var constraint = constraints[i];
 
 				if (constraint is SpecialContraintExpr) {
 					spec.SpecialConstraint |= ((SpecialContraintExpr) constraint).Constraint;
 					if (spec.HasSpecialStruct)
 						spec.BaseType = TypeManager.value_type;
 
 					// Set to null as it does not have a type
 					constraints[i] = null;
 					continue;
 				}
 
 				var type_expr = constraints[i] = constraint.ResolveAsTypeTerminal (context, false);
 				if (type_expr == null)
 					continue;
 
 				var gexpr = type_expr as GenericTypeExpr;
 				if (gexpr != null && gexpr.HasDynamicArguments ()) {
 					context.Compiler.Report.Error (1968, constraint.Location,
 						"A constraint cannot be the dynamic type `{0}'", gexpr.GetSignatureForError ());
 					continue;
 				}
 
 				var type = type_expr.Type;
 
 				if (!context.CurrentMemberDefinition.IsAccessibleAs (type)) {
 					context.Compiler.Report.SymbolRelatedToPreviousError (type);
 					context.Compiler.Report.Error (703, loc,
 						"Inconsistent accessibility
 						type.GetSignatureForError (), context.GetSignatureForError ());
 				}
 
 				if (type.IsInterface) {
 					if (!spec.AddInterface (type)) {
 						context.Compiler.Report.Error (405, constraint.Location,
 							"Duplicate constraint `{0}' for type parameter `{1}'", type.GetSignatureForError (), tparam.Value);
 					}
 
 					iface_found = true;
 					continue;
 				}
 
 
 				var constraint_tp = type as TypeParameterSpec;
 				if (constraint_tp != null) {
 					if (tparam_types == null) {
 						tparam_types = new List<TypeParameterSpec> (2);
 					} else if (tparam_types.Contains (constraint_tp)) {
 						context.Compiler.Report.Error (405, constraint.Location,
 							"Duplicate constraint `{0}' for type parameter `{1}'", type.GetSignatureForError (), tparam.Value);
 						continue;
 					}
 
 					//
 					// Checks whether each generic method parameter constraint type
 					// is valid with respect to T
 					//
 					if (tp.IsMethodTypeParameter) {
 						TypeManager.CheckTypeVariance (type, Variance.Contravariant, context);
 					}
 
 					var tp_def = constraint_tp.MemberDefinition as TypeParameter;
 					if (tp_def != null && !tp_def.ResolveConstraints (context)) {
 						context.Compiler.Report.Error (454, constraint.Location,
 							"Circular constraint dependency involving `{0}' and `{1}'",
 							constraint_tp.GetSignatureForError (), tp.GetSignatureForError ());
 						continue;
 					}
 
 					//
 					// Checks whether there are no conflicts between type parameter constraints
 					//
 					// class Foo<T, U>
 					//      where T 
 					//      where U 
 					//
 					// A and B are not convertible and only 1 class constraint is allowed
 					//
 					if (constraint_tp.HasTypeConstraint) {
 						if (spec.HasTypeConstraint || spec.HasSpecialStruct) {
 							if (!CheckConflictingInheritedConstraint (spec, constraint_tp.BaseType, context, constraint.Location))
 								continue;
 						} else {
 							for (int ii = 0; ii < tparam_types.Count; ++ii) {
 								if (!tparam_types[ii].HasTypeConstraint)
 									continue;
 
 								if (!CheckConflictingInheritedConstraint (spec, tparam_types[ii].BaseType, constraint_tp.BaseType, context, constraint.Location))
 									break;
 							}
 							for (int ii = 0; ii < tparam_types.Count; ++ii) {
 								if (!tparam_types[ii].HasTypeConstraint)
 									continue;
 
 								if (!CheckConflictingInheritedConstraint (spec, tparam_types[ii].BaseType, constraint_tp.BaseType, context, constraint.Location))
 									break;
 							}
 						}
 					}
 
 					if (constraint_tp.HasSpecialStruct) {
 						context.Compiler.Report.Error (456, constraint.Location,
 							"Type parameter `{0}' has the `struct' constraint, so it cannot be used as a constraint for `{1}'",
 							constraint_tp.GetSignatureForError (), tp.GetSignatureForError ());
 						continue;
 					}
 
 					tparam_types.Add (constraint_tp);
 					continue;
 				}
 
 				if (iface_found || spec.HasTypeConstraint) {
 					context.Compiler.Report.Error (406, constraint.Location,
 						"The class type constraint `{0}' must be listed before any other constraints. Consider moving type constraint to the beginning of the constraint list",
 						type.GetSignatureForError ());
 				}
 
 				if (spec.HasSpecialStruct || spec.HasSpecialClass) {
 					context.Compiler.Report.Error (450, type_expr.Location,
 						"`{0}'
 						type.GetSignatureForError ());
 				}
 
 				if (type == InternalType.Dynamic) {
 					context.Compiler.Report.Error (1967, constraint.Location, "A constraint cannot be the dynamic type");
 					continue;
 				}
 
 				if (type.IsSealed || !type.IsClass) {
 					context.Compiler.Report.Error (701, loc,
 						"`{0}' is not a valid constraint. A constraint must be an interface, a non-sealed class or a type parameter",
 						TypeManager.CSharpName (type));
 					continue;
 				}
 
 				if (type.IsStatic) {
 					context.Compiler.Report.Error (717, constraint.Location,
 						"`{0}' is not a valid constraint. Static classes cannot be used as constraints",
 						type.GetSignatureForError ());
 				} else if (type == TypeManager.array_type || type == TypeManager.delegate_type ||
 							type == TypeManager.enum_type || type == TypeManager.value_type ||
 							type == TypeManager.object_type || type == TypeManager.multicast_delegate_type) {
 					context.Compiler.Report.Error (702, constraint.Location,
 						"A constraint cannot be special class `{0}'", type.GetSignatureForError ());
 					continue;
 				}
 
 				spec.BaseType = type;
 			}
 			for (int i = 0; i < constraints.Count; ++i) {
 				var constraint = constraints[i];
 
 				if (constraint is SpecialContraintExpr) {
 					spec.SpecialConstraint |= ((SpecialContraintExpr) constraint).Constraint;
 					if (spec.HasSpecialStruct)
 						spec.BaseType = TypeManager.value_type;
 
 					// Set to null as it does not have a type
 					constraints[i] = null;
 					continue;
 				}
 
 				var type_expr = constraints[i] = constraint.ResolveAsTypeTerminal (context, false);
 				if (type_expr == null)
 					continue;
 
 				var gexpr = type_expr as GenericTypeExpr;
 				if (gexpr != null && gexpr.HasDynamicArguments ()) {
 					context.Compiler.Report.Error (1968, constraint.Location,
 						"A constraint cannot be the dynamic type `{0}'", gexpr.GetSignatureForError ());
 					continue;
 				}
 
 				var type = type_expr.Type;
 
 				if (!context.CurrentMemberDefinition.IsAccessibleAs (type)) {
 					context.Compiler.Report.SymbolRelatedToPreviousError (type);
 					context.Compiler.Report.Error (703, loc,
 						"Inconsistent accessibility
 						type.GetSignatureForError (), context.GetSignatureForError ());
 				}
 
 				if (type.IsInterface) {
 					if (!spec.AddInterface (type)) {
 						context.Compiler.Report.Error (405, constraint.Location,
 							"Duplicate constraint `{0}' for type parameter `{1}'", type.GetSignatureForError (), tparam.Value);
 					}
 
 					iface_found = true;
 					continue;
 				}
 
 
 				var constraint_tp = type as TypeParameterSpec;
 				if (constraint_tp != null) {
 					if (tparam_types == null) {
 						tparam_types = new List<TypeParameterSpec> (2);
 					} else if (tparam_types.Contains (constraint_tp)) {
 						context.Compiler.Report.Error (405, constraint.Location,
 							"Duplicate constraint `{0}' for type parameter `{1}'", type.GetSignatureForError (), tparam.Value);
 						continue;
 					}
 
 					//
 					// Checks whether each generic method parameter constraint type
 					// is valid with respect to T
 					//
 					if (tp.IsMethodTypeParameter) {
 						TypeManager.CheckTypeVariance (type, Variance.Contravariant, context);
 					}
 
 					var tp_def = constraint_tp.MemberDefinition as TypeParameter;
 					if (tp_def != null && !tp_def.ResolveConstraints (context)) {
 						context.Compiler.Report.Error (454, constraint.Location,
 							"Circular constraint dependency involving `{0}' and `{1}'",
 							constraint_tp.GetSignatureForError (), tp.GetSignatureForError ());
 						continue;
 					}
 
 					//
 					// Checks whether there are no conflicts between type parameter constraints
 					//
 					// class Foo<T, U>
 					//      where T 
 					//      where U 
 					//
 					// A and B are not convertible and only 1 class constraint is allowed
 					//
 					if (constraint_tp.HasTypeConstraint) {
 						if (spec.HasTypeConstraint || spec.HasSpecialStruct) {
 							if (!CheckConflictingInheritedConstraint (spec, constraint_tp.BaseType, context, constraint.Location))
 								continue;
 						} else {
 							for (int ii = 0; ii < tparam_types.Count; ++ii) {
 								if (!tparam_types[ii].HasTypeConstraint)
 									continue;
 
 								if (!CheckConflictingInheritedConstraint (spec, tparam_types[ii].BaseType, constraint_tp.BaseType, context, constraint.Location))
 									break;
 							}
 						}
 					}
 
 					if (constraint_tp.HasSpecialStruct) {
 						context.Compiler.Report.Error (456, constraint.Location,
 							"Type parameter `{0}' has the `struct' constraint, so it cannot be used as a constraint for `{1}'",
 							constraint_tp.GetSignatureForError (), tp.GetSignatureForError ());
 						continue;
 					}
 
 					tparam_types.Add (constraint_tp);
 					continue;
 				}
 
 				if (iface_found || spec.HasTypeConstraint) {
 					context.Compiler.Report.Error (406, constraint.Location,
 						"The class type constraint `{0}' must be listed before any other constraints. Consider moving type constraint to the beginning of the constraint list",
 						type.GetSignatureForError ());
 				}
 
 				if (spec.HasSpecialStruct || spec.HasSpecialClass) {
 					context.Compiler.Report.Error (450, type_expr.Location,
 						"`{0}'
 						type.GetSignatureForError ());
 				}
 
 				if (type == InternalType.Dynamic) {
 					context.Compiler.Report.Error (1967, constraint.Location, "A constraint cannot be the dynamic type");
 					continue;
 				}
 
 				if (type.IsSealed || !type.IsClass) {
 					context.Compiler.Report.Error (701, loc,
 						"`{0}' is not a valid constraint. A constraint must be an interface, a non-sealed class or a type parameter",
 						TypeManager.CSharpName (type));
 					continue;
 				}
 
 				if (type.IsStatic) {
 					context.Compiler.Report.Error (717, constraint.Location,
 						"`{0}' is not a valid constraint. Static classes cannot be used as constraints",
 						type.GetSignatureForError ());
 				} else if (type == TypeManager.array_type || type == TypeManager.delegate_type ||
 							type == TypeManager.enum_type || type == TypeManager.value_type ||
 							type == TypeManager.object_type || type == TypeManager.multicast_delegate_type) {
 					context.Compiler.Report.Error (702, constraint.Location,
 						"A constraint cannot be special class `{0}'", type.GetSignatureForError ());
 					continue;
 				}
 
 				spec.BaseType = type;
 			}
 
 			if (tparam_types != null)
 				spec.TypeArguments = tparam_types.ToArray ();
 
 			resolving = false;
 			resolved = true;
 			return true;
 		}
]]></clone_fragment>
<clone_fragment endline="4022" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" hamdist="8" pcid="1667" startline="3722"><![CDATA[
 
 		//
 		// Determines if the candidate method is applicable to the given set of arguments
 		// There could be two different set of parameters for same candidate where one
 		// is the closest override for default values and named arguments checks and second
 		// one being the virtual base for the parameter types and modifiers.
 		//
 		// A return value rates candidate method compatibility,
 		// 0 = the best, int.MaxValue = the worst
 		//
 		int IsApplicable (ResolveContext ec, ref Arguments arguments, int arg_count, ref MemberSpec candidate, IParametersMember pm, ref bool params_expanded_form, ref bool dynamicArgument, ref TypeSpec returnType)
 		{
 			// Parameters of most-derived type used mainly for named and optional parameters
 			var pd = pm.Parameters;
 
 			// Used for params modifier only, that's legacy of C# 1.0 which uses base type for
 			// params modifier instead of most-derived type
 			var cpd = ((IParametersMember) candidate).Parameters;
 			int param_count = pd.Count;
 			int optional_count = 0;
 			int score;
 			Arguments orig_args = arguments;
 
 			if (arg_count != param_count) {
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 
 				if (optional_count != 0) {
 					// Readjust expected number when params used
 					if (cpd.HasParams) {
 						optional_count--;
 						if (arg_count < param_count)
 							param_count--;
 					} else if (arg_count > param_count) {
 						int args_gap = System.Math.Abs (arg_count - param_count);
 						return int.MaxValue - 10000 + args_gap;
 					}
 				} else if (arg_count != param_count) {
 					int args_gap = System.Math.Abs (arg_count - param_count);
 					if (!cpd.HasParams)
 						return int.MaxValue - 10000 + args_gap;
 					if (arg_count < param_count - 1)
 						return int.MaxValue - 10000 + args_gap;
 				}
 
 				// Resize to fit optional arguments
 				if (optional_count != 0) {
 					if (arguments == null) {
 						arguments = new Arguments (optional_count);
 					} else {
 						// Have to create a new container, so the next run can do same
 						var resized = new Arguments (param_count);
 						resized.AddRange (arguments);
 						arguments = resized;
 					}
 
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 				}
 			}
 
 			if (arg_count > 0) {
 				//
 				// Shuffle named arguments to the right positions if there are any
 				//
 				if (arguments[arg_count - 1] is NamedArgument) {
 					arg_count = arguments.Count;
 
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 				} else {
 					arg_count = arguments.Count;
 				}
 			} else if (arguments != null) {
 				arg_count = arguments.Count;
 			}
 
 			//
 			// 1. Handle generic method using type arguments when specified or type inference
 			//
 			TypeSpec[] ptypes;
 			var ms = candidate as MethodSpec;
 			if (ms != null && ms.IsGeneric) {
 				// Setup constraint checker for probing only
 				ConstraintChecker cc = new ConstraintChecker (null);
 
 				if (type_arguments != null) {
 					var g_args_count = ms.Arity;
 					if (g_args_count != type_arguments.Count)
 						return int.MaxValue - 20000 + System.Math.Abs (type_arguments.Count - g_args_count);
 
 					ms = ms.MakeGenericMethod (type_arguments.Arguments);
 				} else {
 					// TODO
 					// for now it simplifies things. I should probably add a callback to ResolveContext
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 
 					var ti = new TypeInference (arguments);
 					TypeSpec[] i_args = ti.InferMethodArguments (ec, ms);
 					lambda_conv_msgs.EndSession ();
 
 					if (i_args == null)
 						return ti.InferenceScore - 20000;
 
 					if (i_args.Length != 0) {
 						ms = ms.MakeGenericMethod (i_args);
 					}
 
 					cc.IgnoreInferredDynamic = true;
 				}
 
 				//
 				// Type arguments constraints have to match for the method to be applicable
 				//
 				if (!cc.CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc)) {
 					candidate = ms;
 					return int.MaxValue - 25000;
 				}
 
 				//
 				// We have a generic return type and at same time the method is override which
 				// means we have to also inflate override return type in case the candidate is
 				// best candidate and override return type is different to base return type.
 				// 
 				// virtual Foo<T, object> with override Foo<T, dynamic>
 				//
 				if (candidate != pm) {
 					MethodSpec override_ms = (MethodSpec) pm;
 					var inflator = new TypeParameterInflator (ms.DeclaringType, override_ms.GenericDefinition.TypeParameters, ms.TypeArguments);
 					returnType = inflator.Inflate (returnType);
 				} else {
 					returnType = ms.ReturnType;
 				}
 
 				candidate = ms;
 				ptypes = ms.Parameters.Types;
 			} else {
 				if (type_arguments != null)
 					return int.MaxValue - 15000;
 
 				ptypes = cpd.Types;
 			}
 
 			//
 			// 2. Each argument has to be implicitly convertible to method parameter
 			//
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 
 			//
 			// When params parameter has no argument it will be provided later if the method is the best candidate
 			//
 			if (arg_count + 1 == pd.Count && (cpd.FixedParameters [arg_count].ModFlags & Parameter.Modifier.PARAMS) != 0)
 				params_expanded_form = true;
 
 			//
 			// Restore original arguments for dynamic binder to keep the intention of original source code
 			//
 			if (dynamicArgument)
 				arguments = orig_args;
 
 			return 0;
 		}
]]></clone_fragment>
<clone_fragment endline="837" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" hamdist="10" pcid="1055" startline="169"><![CDATA[
 		bool hidden = false;
 		int ref_line = 1;
 		int line = 1;
 		int col = 0;
 		int previous_col;
 		int current_token;
 		int tab_size;
 		bool handle_get_set = false;
 		bool handle_remove_add = false;
 		bool handle_where = false;
 		bool handle_typeof = false;
 		bool lambda_arguments_parsing;
 		Location current_comment_location = Location.Null;
 		List<Location> escaped_identifiers;
 		int parsing_generic_less_than;
 		
 		//
 		// Used mainly for parser optimizations. Some expressions for instance
 		// can appear only in block (including initializer, base initializer)
 		// scope only
 		//
 		public int parsing_block;
 		internal bool query_parsing;
 		
 		// 
 		// When parsing type only, useful for ambiguous nullable types
 		//
 		public int parsing_type;
 		
 		//
 		// Set when parsing generic declaration (type or method header)
 		//
 		public bool parsing_generic_declaration;
 		
 		//
 		// The value indicates that we have not reach any declaration or
 		// namespace yet
 		//
 		public int parsing_declaration;
 
 		//
 		// The special character to inject on streams to trigger the EXPRESSION_PARSE
 		// token to be returned.   It just happens to be a Unicode character that
 		// would never be part of a program (can not be an identifier).
 		//
 		// This character is only tested just before the tokenizer is about to report
 		// an error;   So on the regular operation mode, this addition will have no
 		// impact on the tokenizer's performance.
 		//
 		
 		public const int EvalStatementParserCharacter = 0x2190;   // Unicode Left Arrow
 		public const int EvalCompilationUnitParserCharacter = 0x2191;  // Unicode Arrow
 		public const int EvalUsingDeclarationsParserCharacter = 0x2192;  // Unicode Arrow
 		
 		//
 		// XML documentation buffer. The save point is used to divide
 		// comments on types and comments on members.
 		//
 		StringBuilder xml_comment_buffer;
 
 		//
 		// See comment on XmlCommentState enumeration.
 		//
 		XmlCommentState xml_doc_state = XmlCommentState.Allowed;
 
 		//
 		// Whether tokens have been seen on this line
 		//
 		bool tokens_seen = false;
 
 		//
 		// Set to true once the GENERATE_COMPLETION token has bee
 		// returned.   This helps produce one GENERATE_COMPLETION,
 		// as many COMPLETE_COMPLETION as necessary to complete the
 		// AST tree and one final EOF.
 		//
 		bool generated;
 		
 		//
 		// Whether a token has been seen on the file
 		// This is needed because `define' is not allowed to be used
 		// after a token has been seen.
 		//
 		bool any_token_seen = false;
 
 		static readonly char[] simple_whitespaces = new char[] { ' ', '\t' };
 
 		public bool PropertyParsing {
 			get { return handle_get_set; }
 			set { handle_get_set = value; }
 		}
 
 		public bool EventParsing {
 			get { return handle_remove_add; }
 			set { handle_remove_add = value; }
 		}
 
 		public bool ConstraintsParsing {
 			get { return handle_where; }
 			set { handle_where = value; }
 		}
 
 		public bool TypeOfParsing {
 			get { return handle_typeof; }
 			set { handle_typeof = value; }
 		}
 
 		public int TabSize {
 			get { return tab_size; }
 			set { tab_size = value; }
 		}
 		
 		public XmlCommentState doc_state {
 			get { return xml_doc_state; }
 			set {
 				if (value == XmlCommentState.Allowed) {
 					check_incorrect_doc_comment ();
 					reset_doc_comment ();
 				}
 				xml_doc_state = value;
 			}
 		}
 
 		//
 		// This is used to trigger completion generation on the parser
 		public bool CompleteOnEOF;
 		
 		void AddEscapedIdentifier (Location loc)
 		{
 			if (escaped_identifiers == null)
 				escaped_identifiers = new List<Location> ();
 
 			escaped_identifiers.Add (loc);
 		}
 
 		public bool IsEscapedIdentifier (MemberName name)
 		{
 			return escaped_identifiers != null && escaped_identifiers.Contains (name.Location);
 		}
 
 		//
 		// Class variables
 		// 
 		static KeywordEntry<int>[][] keywords;
 		static KeywordEntry<PreprocessorDirective>[][] keywords_preprocessor;
 		static Dictionary<string, object> keyword_strings; 		// TODO
 		static NumberStyles styles;
 		static NumberFormatInfo csharp_format_info;
 
 		// Pragma arguments
 		static readonly char[] pragma_warning = "warning".ToCharArray ();
 		static readonly char[] pragma_warning_disable = "disable".ToCharArray ();
 		static readonly char[] pragma_warning_restore = "restore".ToCharArray ();
 		static readonly char[] pragma_checksum = "checksum".ToCharArray ();
 		
 		//
 		// Values for the associated token returned
 		//
 		internal int putback_char; 	// Used by repl only
 		object val;
 
 		//
 		// Pre-processor
 		//
 		const int TAKING        = 1;
 		const int ELSE_SEEN     = 4;
 		const int PARENT_TAKING = 8;
 		const int REGION        = 16;		
 
 		//
 		// pre-processor if stack state
 		//
 		Stack<int> ifstack;
 
 		static System.Text.StringBuilder string_builder;
 
 		const int max_id_size = 512;
 		static char [] id_builder = new char [max_id_size];
 
 		public static Dictionary<char[], string>[] identifiers = new Dictionary<char[], string>[max_id_size + 1];
 
 		const int max_number_size = 512;
 		static char [] number_builder = new char [max_number_size];
 		static int number_pos;
 
 		static StringBuilder static_cmd_arg = new System.Text.StringBuilder ();
 		
 		public int Line {
 			get {
 				return ref_line;
 			}
 		}
 
 		//
 		// This is used when the tokenizer needs to save
 		// the current position as it needs to do some parsing
 		// on its own to deamiguate a token in behalf of the
 		// parser.
 		//
 		Stack<Position> position_stack = new Stack<Position> (2);
 
 		class Position {
 			public int position;
 			public int line;
 			public int ref_line;
 			public int col;
 			public bool hidden;
 			public int putback_char;
 			public int previous_col;
 			public Stack<int> ifstack;
 			public int parsing_generic_less_than;
 			public int current_token;
 			public object val;
 
 			public Position (Tokenizer t)
 			{
 				position = t.reader.Position;
 				line = t.line;
 				ref_line = t.ref_line;
 				col = t.col;
 				hidden = t.hidden;
 				putback_char = t.putback_char;
 				previous_col = t.previous_col;
 				if (t.ifstack != null && t.ifstack.Count != 0) {
 					// There is no simple way to clone Stack<T> all
 					// methods reverse the order
 					var clone = t.ifstack.ToArray ();
 					Array.Reverse (clone);
 					ifstack = new Stack<int> (clone);
 				}
 				parsing_generic_less_than = t.parsing_generic_less_than;
 				current_token = t.current_token;
 				val = t.val;
 			}
 		}
 		
 		public void PushPosition ()
 		{
 			position_stack.Push (new Position (this));
 		}
 
 		public void PopPosition ()
 		{
 			Position p = position_stack.Pop ();
 
 			reader.Position = p.position;
 			ref_line = p.ref_line;
 			line = p.line;
 			col = p.col;
 			hidden = p.hidden;
 			putback_char = p.putback_char;
 			previous_col = p.previous_col;
 			ifstack = p.ifstack;
 			parsing_generic_less_than = p.parsing_generic_less_than;
 			current_token = p.current_token;
 			val = p.val;
 		}
 
 		// Do not reset the position, ignore it.
 		public void DiscardPosition ()
 		{
 			position_stack.Pop ();
 		}
 		
 		static void AddKeyword (string kw, int token)
 		{
 			keyword_strings.Add (kw, null);
 
 			AddKeyword (keywords, kw, token);
 		}
 
 		static void AddPreprocessorKeyword (string kw, PreprocessorDirective directive)
 		{
 			AddKeyword (keywords_preprocessor, kw, directive);
 		}
 
 		static void AddKeyword<T> (KeywordEntry<T>[][] keywords, string kw, T token)
 		{
 			int length = kw.Length;
 			if (keywords[length] == null) {
 				keywords[length] = new KeywordEntry<T>['z' - '_' + 1];
 			}
 
 			int char_index = kw[0] - '_';
 			var kwe = keywords[length][char_index];
 			if (kwe == null) {
 				keywords[length][char_index] = new KeywordEntry<T> (kw, token);
 				return;
 			}
 
 			while (kwe.Next != null) {
 				kwe = kwe.Next;
 			}
 
 			kwe.Next = new KeywordEntry<T> (kw, token);
 		}
 
 		static void InitTokens ()
 		{
 			keyword_strings = new Dictionary<string, object> ();
 
 			// 11 is the length of the longest keyword for now
 			keywords = new KeywordEntry<int> [11] [];
 
 			AddKeyword ("__arglist", Token.ARGLIST);
 			AddKeyword ("abstract", Token.ABSTRACT);
 			AddKeyword ("as", Token.AS);
 			AddKeyword ("add", Token.ADD);
 			AddKeyword ("base", Token.BASE);
 			AddKeyword ("bool", Token.BOOL);
 			AddKeyword ("break", Token.BREAK);
 			AddKeyword ("byte", Token.BYTE);
 			AddKeyword ("case", Token.CASE);
 			AddKeyword ("catch", Token.CATCH);
 			AddKeyword ("char", Token.CHAR);
 			AddKeyword ("checked", Token.CHECKED);
 			AddKeyword ("class", Token.CLASS);
 			AddKeyword ("const", Token.CONST);
 			AddKeyword ("continue", Token.CONTINUE);
 			AddKeyword ("decimal", Token.DECIMAL);
 			AddKeyword ("default", Token.DEFAULT);
 			AddKeyword ("delegate", Token.DELEGATE);
 			AddKeyword ("do", Token.DO);
 			AddKeyword ("double", Token.DOUBLE);
 			AddKeyword ("else", Token.ELSE);
 			AddKeyword ("enum", Token.ENUM);
 			AddKeyword ("event", Token.EVENT);
 			AddKeyword ("explicit", Token.EXPLICIT);
 			AddKeyword ("extern", Token.EXTERN);
 			AddKeyword ("false", Token.FALSE);
 			AddKeyword ("finally", Token.FINALLY);
 			AddKeyword ("fixed", Token.FIXED);
 			AddKeyword ("float", Token.FLOAT);
 			AddKeyword ("for", Token.FOR);
 			AddKeyword ("foreach", Token.FOREACH);
 			AddKeyword ("goto", Token.GOTO);
 			AddKeyword ("get", Token.GET);
 			AddKeyword ("if", Token.IF);
 			AddKeyword ("implicit", Token.IMPLICIT);
 			AddKeyword ("in", Token.IN);
 			AddKeyword ("int", Token.INT);
 			AddKeyword ("interface", Token.INTERFACE);
 			AddKeyword ("internal", Token.INTERNAL);
 			AddKeyword ("is", Token.IS);
 			AddKeyword ("lock", Token.LOCK);
 			AddKeyword ("long", Token.LONG);
 			AddKeyword ("namespace", Token.NAMESPACE);
 			AddKeyword ("new", Token.NEW);
 			AddKeyword ("null", Token.NULL);
 			AddKeyword ("object", Token.OBJECT);
 			AddKeyword ("operator", Token.OPERATOR);
 			AddKeyword ("out", Token.OUT);
 			AddKeyword ("override", Token.OVERRIDE);
 			AddKeyword ("params", Token.PARAMS);
 			AddKeyword ("private", Token.PRIVATE);
 			AddKeyword ("protected", Token.PROTECTED);
 			AddKeyword ("public", Token.PUBLIC);
 			AddKeyword ("readonly", Token.READONLY);
 			AddKeyword ("ref", Token.REF);
 			AddKeyword ("remove", Token.REMOVE);
 			AddKeyword ("return", Token.RETURN);
 			AddKeyword ("sbyte", Token.SBYTE);
 			AddKeyword ("sealed", Token.SEALED);
 			AddKeyword ("set", Token.SET);
 			AddKeyword ("short", Token.SHORT);
 			AddKeyword ("sizeof", Token.SIZEOF);
 			AddKeyword ("stackalloc", Token.STACKALLOC);
 			AddKeyword ("static", Token.STATIC);
 			AddKeyword ("string", Token.STRING);
 			AddKeyword ("struct", Token.STRUCT);
 			AddKeyword ("switch", Token.SWITCH);
 			AddKeyword ("this", Token.THIS);
 			AddKeyword ("throw", Token.THROW);
 			AddKeyword ("true", Token.TRUE);
 			AddKeyword ("try", Token.TRY);
 			AddKeyword ("typeof", Token.TYPEOF);
 			AddKeyword ("uint", Token.UINT);
 			AddKeyword ("ulong", Token.ULONG);
 			AddKeyword ("unchecked", Token.UNCHECKED);
 			AddKeyword ("unsafe", Token.UNSAFE);
 			AddKeyword ("ushort", Token.USHORT);
 			AddKeyword ("using", Token.USING);
 			AddKeyword ("virtual", Token.VIRTUAL);
 			AddKeyword ("void", Token.VOID);
 			AddKeyword ("volatile", Token.VOLATILE);
 			AddKeyword ("while", Token.WHILE);
 			AddKeyword ("partial", Token.PARTIAL);
 			AddKeyword ("where", Token.WHERE);
 			AddKeyword ("async", Token.ASYNC);
 
 			// LINQ keywords
 			AddKeyword ("from", Token.FROM);
 			AddKeyword ("join", Token.JOIN);
 			AddKeyword ("on", Token.ON);
 			AddKeyword ("equals", Token.EQUALS);
 			AddKeyword ("select", Token.SELECT);
 			AddKeyword ("group", Token.GROUP);
 			AddKeyword ("by", Token.BY);
 			AddKeyword ("let", Token.LET);
 			AddKeyword ("orderby", Token.ORDERBY);
 			AddKeyword ("ascending", Token.ASCENDING);
 			AddKeyword ("descending", Token.DESCENDING);
 			AddKeyword ("into", Token.INTO);
 
 			keywords_preprocessor = new KeywordEntry<PreprocessorDirective>[10][];
 
 			AddPreprocessorKeyword ("region", PreprocessorDirective.Region);
 			AddPreprocessorKeyword ("endregion", PreprocessorDirective.Endregion);
 			AddPreprocessorKeyword ("if", PreprocessorDirective.If);
 			AddPreprocessorKeyword ("endif", PreprocessorDirective.Endif);
 			AddPreprocessorKeyword ("elif", PreprocessorDirective.Elif);
 			AddPreprocessorKeyword ("else", PreprocessorDirective.Else);
 			AddPreprocessorKeyword ("define", PreprocessorDirective.Define);
 			AddPreprocessorKeyword ("undef", PreprocessorDirective.Undef);
 			AddPreprocessorKeyword ("error", PreprocessorDirective.Error);
 			AddPreprocessorKeyword ("warning", PreprocessorDirective.Warning);
 			AddPreprocessorKeyword ("pragma", PreprocessorDirective.Pragma);
 			AddPreprocessorKeyword ("line", PreprocessorDirective.Line);
 		}
 
 		//
 		// Class initializer
 		// 
 		static Tokenizer ()
 		{
 			InitTokens ();			
 			csharp_format_info = NumberFormatInfo.InvariantInfo;
 			styles = NumberStyles.Float;
 
 			string_builder = new System.Text.StringBuilder ();
 		}
 
 		int GetKeyword (char[] id, int id_len)
 		{
 			//
 			// Keywords are stored in an array of arrays grouped by their
 			// length and then by the first character
 			//
 			if (id_len >= keywords.Length || keywords [id_len] == null)
 				return -1;
 
 			int first_index = id [0] - '_';
 			if (first_index > 'z' - '_')
 				return -1;
 
 			var kwe = keywords [id_len] [first_index];
 			if (kwe == null)
 				return -1;
 
 			int res;
 			do {
 				res = kwe.Token;
 				for (int i = 1; i < id_len; ++i) {
 					if (id [i] != kwe.Value [i]) {
 						res = 0;
 						kwe = kwe.Next;
 						break;
 					}
 				}
 			} while (res == 0 && kwe != null);
 
 			if (res == 0)
 				return -1;
 
 			int next_token;
 			switch (res) {
 			case Token.GET
 			case Token.SET
 				if (!handle_get_set)
 					res = -1;
 				break;
 			case Token.REMOVE
 			case Token.ADD
 				if (!handle_remove_add)
 					res = -1;
 				break;
 			case Token.EXTERN
 				if (parsing_declaration == 0)
 					res = Token.EXTERN_ALIAS;
 				break;
 			case Token.DEFAULT
 				if (peek_token () == Token.COLON) {
 					token ();
 					res = Token.DEFAULT_COLON;
 				}
 				break;
 			case Token.WHERE
 				if (!handle_where && !query_parsing)
 					res = -1;
 				break;
 			case Token.FROM
 				//
 				// A query expression is any expression that starts with `from identifier'
 				// followed by any token except ; , =
 				// 
 				if (!query_parsing) {
 					if (lambda_arguments_parsing) {
 						res = -1;
 						break;
 					}
 
 					PushPosition ();
 					// HACK
 					// store identifiers array
 					parsing_generic_less_than = 1;
 					switch (xtoken ()) {
 					case Token.IDENTIFIER
 					case Token.INT
 					case Token.BOOL
 					case Token.BYTE
 					case Token.CHAR
 					case Token.DECIMAL
 					case Token.FLOAT
 					case Token.LONG
 					case Token.OBJECT
 					case Token.STRING
 					case Token.UINT
 					case Token.ULONG
 						next_token = xtoken ();
 						if (next_token == Token.SEMICOLON || next_token == Token.COMMA || next_token == Token.EQUALS)
 							goto default;
 						
 						res = Token.FROM_FIRST;
 						query_parsing = true;
 						if (RootContext.Version <= LanguageVersion.ISO_2)
 							Report.FeatureIsNotAvailable (Location, "query expressions");
 						break;
 					case Token.VOID
 						Expression.Error_VoidInvalidInTheContext (Location, Report);
 						break;
 					default
 						PopPosition ();
 						// HACK
 						// which has been overwritten before we grabbed the identifier
 						id_builder [0] = 'f'; id_builder [1] = 'r'; id_builder [2] = 'o'; id_builder [3] = 'm';
 						return -1;
 					}
 					PopPosition ();
 				}
 				break;
 			case Token.JOIN
 			case Token.ON
 			case Token.EQUALS
 			case Token.SELECT
 			case Token.GROUP
 			case Token.BY
 			case Token.LET
 			case Token.ORDERBY
 			case Token.ASCENDING
 			case Token.DESCENDING
 			case Token.INTO
 				if (!query_parsing)
 					res = -1;
 				break;
 				
 			case Token.USING
 			case Token.NAMESPACE
 				// TODO
 				check_incorrect_doc_comment ();
 				break;
 				
 			case Token.PARTIAL
 				if (parsing_block > 0) {
 					res = -1;
 					break;
 				}
 
 				// Save current position and parse next token.
 				PushPosition ();
 
 				next_token = token ();
 				bool ok = (next_token == Token.CLASS) ||
 					(next_token == Token.STRUCT) ||
 					(next_token == Token.INTERFACE) ||
 					(next_token == Token.VOID);
 
 				PopPosition ();
 
 				if (ok) {
 					if (next_token == Token.VOID) {
 						if (RootContext.Version == LanguageVersion.ISO_1 ||
 						    RootContext.Version == LanguageVersion.ISO_2)
 							Report.FeatureIsNotAvailable (Location, "partial methods");
 					} else if (RootContext.Version == LanguageVersion.ISO_1)
 						Report.FeatureIsNotAvailable (Location, "partial types");
 
 					return res;
 				}
 
 				if (next_token < Token.LAST_KEYWORD) {
 					Report.Error (267, Location,
 						"The `partial' modifier can be used only immediately before `class', `struct', `interface', or `void' keyword");
 					return token ();
 				}					
 
 				res = -1;
 				break;
 
 			case Token.ASYNC
 				if (parsing_block > 0 || RootContext.Version != LanguageVersion.Future) {
 					res = -1;
 					break;
 				}
 				break;
 			}
 
 			return res;
 		}
 
 		static PreprocessorDirective GetPreprocessorDirective (char[] id, int id_len)
 		{
 			//
 			// Keywords are stored in an array of arrays grouped by their
 			// length and then by the first character
 			//
 			if (id_len >= keywords_preprocessor.Length || keywords_preprocessor[id_len] == null)
 				return PreprocessorDirective.Invalid;
 
 			int first_index = id[0] - '_';
 			if (first_index > 'z' - '_')
 				return PreprocessorDirective.Invalid;
 
 			var kwe = keywords_preprocessor[id_len][first_index];
 			if (kwe == null)
 				return PreprocessorDirective.Invalid;
 
 			PreprocessorDirective res = PreprocessorDirective.Invalid;
 			do {
 				res = kwe.Token;
 				for (int i = 1; i < id_len; ++i) {
 					if (id[i] != kwe.Value[i]) {
 						res = 0;
 						kwe = kwe.Next;
 						break;
 					}
 				}
 			} while (res == PreprocessorDirective.Invalid && kwe != null);
 
 			return res;
 		}
 
 		public Location Location {
 			get {
 				return new Location (ref_line, hidden ? -1 
 			}
 		}
 
 		public Tokenizer (SeekableStreamReader input, CompilationUnit file, CompilerContext ctx)
 		{
 			this.ref_name = file;
 			this.file_name = file;
 			this.context = ctx;
 			reader = input;
 			
 			putback_char = -1;
 
 			xml_comment_buffer = new StringBuilder ();
 
 			if (Environment.OSVersion.Platform == PlatformID.Win32NT)
 				tab_size = 4;
 			else
 				tab_size = 8;
 
 			//
 			// FIXME
 			// find out why the MS compiler allows this
 			//
 			Mono.CSharp.Location.Push (file, file);
 		}
]]></clone_fragment>
<clone_fragment endline="5519" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" hamdist="6" pcid="4843" startline="4853"><![CDATA[
 	}
 
 	/// <summary>
 	///   This represents a reference to a parameter in the intermediate
 	///   representation.
 	/// </summary>
 	public class ParameterReference 
 	{
 		protected ParametersBlock.ParameterInfo pi;
 
 		public ParameterReference (ParametersBlock.ParameterInfo pi, Location loc)
 		{
 			this.pi = pi;
 			this.loc = loc;
 		}
 
 		#region Properties
 
 		public override bool IsLockedByStatement {
 			get {
 				return pi.IsLocked;
 			}
 			set	{
 				pi.IsLocked = value;
 			}
 		}
 
 		public override bool IsRef {
 			get { return (pi.Parameter.ModFlags & Parameter.Modifier.ISBYREF) != 0; }
 		}
 
 		bool HasOutModifier {
 			get { return pi.Parameter.ModFlags == Parameter.Modifier.OUT; }
 		}
 
 		public override HoistedVariable GetHoistedVariable (AnonymousExpression ae)
 		{
 			return pi.Parameter.HoistedVariant;
 		}
 
 		//
 		// A ref or out parameter is classified as a moveable variable, even 
 		// if the argument given for the parameter is a fixed variable
 		//		
 		public override bool IsFixed {
 			get { return !IsRef; }
 		}
 
 		public override string Name {
 			get { return Parameter.Name; }
 		}
 
 		public Parameter Parameter {
 			get { return pi.Parameter; }
 		}
 
 		public override VariableInfo VariableInfo {
 			get { return pi.VariableInfo; }
 		}
 
 		protected override ILocalVariable Variable {
 			get { return Parameter; }
 		}
 
 		#endregion
 
 		public bool IsAssigned (ResolveContext ec, Location loc)
 		{
 			// HACK
 			if (ec.IsInProbingMode)
 				return true;
 			
 			if (!ec.DoFlowAnalysis || !HasOutModifier || ec.CurrentBranching.IsAssigned (VariableInfo))
 				return true;
 
 			ec.Report.Error (269, loc, "Use of unassigned out parameter `{0}'", Name);
 			return false;
 		}
 
 		public override void SetHasAddressTaken ()
 		{
 			Parameter.HasAddressTaken = true;
 		}
 
 		void SetAssigned (ResolveContext ec)
 		{
 			if (HasOutModifier && ec.DoFlowAnalysis)
 				ec.CurrentBranching.SetAssigned (VariableInfo);
 		}
 
 		bool DoResolveBase (ResolveContext ec)
 		{
 			type = pi.ParameterType;
 			eclass = ExprClass.Variable;
 
 			//
 			// If we are referencing a parameter from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (pi)) {
 				if (Parameter.HasAddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (IsRef) {
 					ec.Report.Error (1628, loc,
 						"Parameter `{0}' cannot be used inside `{1}' when using `ref' or `out' modifier",
 						Name, ec.CurrentAnonymousMethod.ContainerType);
 				}
 
 				if (ec.IsVariableCapturingRequired && !pi.Block.ParametersBlock.IsExpressionTree) {
 					AnonymousMethodStorey storey = pi.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureParameter (ec, this);
 				}
 			}
 
 			return true;
 		}
 
 		public override int GetHashCode ()
 		{
 			return Name.GetHashCode ();
 		}
 
 		public override bool Equals (object obj)
 		{
 			ParameterReference pr = obj as ParameterReference;
 			if (pr == null)
 				return false;
 
 			return Name == pr.Name;
 		}
 
 		public override void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			//
 			// ParameterReferences might already be a reference
 			//
 			if (IsRef) {
 				EmitLoad (ec);
 				return;
 			}
 
 			base.AddressOf (ec, mode);
 		}
 		
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			// Nothing to clone
 			return;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			return Parameter.ExpressionTreeVariableReference ();
 		}
 
 		//
 		// Notice that for ref/out parameters, the type exposed is not the
 		// same type exposed externally.
 		//
 		// for "ref int a"
 		//   externally we expose "int&"
 		//   here we expose       "int".
 		//
 		// We record this in "is_ref".  This means that the type system can treat
 		// the type as it is expected, but when we generate the code, we generate
 		// the alternate kind of code.
 		//
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			// HACK
 			if (ec.IsInProbingMode)
 				return this;
 
 			if (HasOutModifier && ec.DoFlowAnalysis &&
 			    (!ec.OmitStructFlowAnalysis || !VariableInfo.TypeInfo.IsStruct) && !IsAssigned (ec, loc))
 				return null;
 
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			SetAssigned (ec);
 			return base.DoResolveLValue (ec, right_side);
 		}
 
 		static public void EmitLdArg (EmitContext ec, int x)
 		{
 			switch (x) {
 			case 0
 			case 1
 			case 2
 			case 3
 			default
 				if (x > byte.MaxValue)
 					ec.Emit (OpCodes.Ldarg, x);
 				else
 					ec.Emit (OpCodes.Ldarg_S, (byte) x);
 				break;
 			}
 		}
 	}
 	
 	/// <summary>
 	///   Invocation of methods or delegates.
 	/// </summary>
 	public class Invocation 
 	{
 		protected Arguments arguments;
 		protected Expression expr;
 		protected MethodGroupExpr mg;
 		
 		public Invocation (Expression expr, Arguments arguments)
 		{
 			this.expr = expr;		
 			this.arguments = arguments;
 			if (expr != null)
 				loc = expr.Location;
 		}
 
 		#region Properties
 		public Arguments Arguments {
 			get {
 				return arguments;
 			}
 		}
 		
 		public Expression Expression {
 			get {
 				return expr;
 			}
 		}
 		#endregion
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Invocation target = (Invocation) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 
 			target.expr = expr.Clone (clonectx);
 		}
 
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Expression instance = mg.IsInstance ?
 				mg.InstanceExpression.CreateExpressionTree (ec) 
 				new NullLiteral (loc);
 
 			var args = Arguments.CreateForExpressionTree (ec, arguments,
 				instance,
 				mg.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression member_expr;
 			var atn = expr as ATypeNameExpression;
 			if (atn != null) {
 				member_expr = atn.LookupNameExpression (ec, MemberLookupRestrictions.InvocableOnly | MemberLookupRestrictions.ReadAccess);
 				if (member_expr != null)
 					member_expr = member_expr.Resolve (ec);
 			} else {
 				member_expr = expr.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.MethodGroup);
 			}
 
 			if (member_expr == null)
 				return null;
 
 			//
 			// Next, evaluate all the expressions in the argument list
 			//
 			bool dynamic_arg = false;
 			if (arguments != null)
 				arguments.Resolve (ec, out dynamic_arg);
 
 			TypeSpec expr_type = member_expr.Type;
 			if (expr_type == InternalType.Dynamic)
 				return DoResolveDynamic (ec, member_expr);
 
 			mg = member_expr as MethodGroupExpr;
 			Expression invoke = null;
 
 			if (mg == null) {
 				if (expr_type != null && TypeManager.IsDelegateType (expr_type)) {
 					invoke = new DelegateInvocation (member_expr, arguments, loc);
 					invoke = invoke.Resolve (ec);
 					if (invoke == null || !dynamic_arg)
 						return invoke;
 				} else {
 					if (member_expr is RuntimeValueExpression) {
 						ec.Report.Error (Report.RuntimeErrorId, loc, "Cannot invoke a non-delegate type `{0}'",
 							member_expr.Type.GetSignatureForError ()); ;
 						return null;
 					}
 
 					MemberExpr me = member_expr as MemberExpr;
 					if (me == null) {
 						member_expr.Error_UnexpectedKind (ec, ResolveFlags.MethodGroup, loc);
 						return null;
 					}
 
 					ec.Report.Error (1955, loc, "The member `{0}' cannot be used as method or delegate",
 							member_expr.GetSignatureForError ());
 					return null;
 				}
 			}
 
 			if (invoke == null) {
 				mg = DoResolveOverload (ec);
 				if (mg == null)
 					return null;
 			}
 
 			if (dynamic_arg)
 				return DoResolveDynamic (ec, member_expr);
 
 			var method = mg.BestCandidate;
 			type = mg.BestCandidateReturnType;
 		
 			if (arguments == null && method.DeclaringType == TypeManager.object_type && method.Name == Destructor.MetadataName) {
 				if (mg.IsBase)
 					ec.Report.Error (250, loc, "Do not directly call your base class Finalize method. It is called automatically from your destructor");
 				else
 					ec.Report.Error (245, loc, "Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available");
 				return null;
 			}
 
 			IsSpecialMethodInvocation (ec, method, loc);
 			
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		protected virtual Expression DoResolveDynamic (ResolveContext ec, Expression memberExpr)
 		{
 			Arguments args;
 			DynamicMemberBinder dmb = memberExpr as DynamicMemberBinder;
 			if (dmb != null) {
 				args = dmb.Arguments;
 				if (arguments != null)
 					args.AddRange (arguments);
 			} else if (mg == null) {
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				args.Insert (0, new Argument (memberExpr));
 				this.expr = null;
 			} else {
 				if (mg.IsBase) {
 					ec.Report.Error (1971, loc,
 						"The base call to method `{0}' cannot be dynamically dispatched. Consider casting the dynamic arguments or eliminating the base access",
 						mg.Name);
 					return null;
 				}
 
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				MemberAccess ma = expr as MemberAccess;
 				if (ma != null) {
 					var left_type = ma.LeftExpression as TypeExpr;
 					if (left_type != null) {
 						args.Insert (0, new Argument (new TypeOf (left_type, loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						//
 						// Any value type has to be pass as by-ref to get back the same
 						// instance on which the member was called
 						//
 						var mod = TypeManager.IsValueType (ma.LeftExpression.Type) ? Argument.AType.Ref 
 						args.Insert (0, new Argument (ma.LeftExpression.Resolve (ec), mod));
 					}
 				} else {	// is SimpleName
 					if (ec.IsStatic) {
 						args.Insert (0, new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						args.Insert (0, new Argument (new This (loc).Resolve (ec)));
 					}
 				}
 			}
 
 			return new DynamicInvocation (expr as ATypeNameExpression, args, loc).Resolve (ec);
 		}
 
 		protected virtual MethodGroupExpr DoResolveOverload (ResolveContext ec)
 		{
 			return mg.OverloadResolve (ec, ref arguments, null, OverloadResolver.Restrictions.None);
 		}
 
 		static MetaType[] GetVarargsTypes (MethodSpec mb, Arguments arguments)
 		{
 			AParametersCollection pd = mb.Parameters;
 
 			Argument a = arguments[pd.Count - 1];
 			Arglist list = (Arglist) a.Expr;
 
 			return list.ArgumentTypes;
 		}
 
 		//
 		// If a member is a method or event, or if it is a constant, field or property of either a delegate type
 		// or the type dynamic, then the member is invocable
 		//
 		public static bool IsMemberInvocable (MemberSpec member)
 		{
 			switch (member.Kind) {
 			case MemberKind.Event
 				return true;
 			case MemberKind.Field
 			case MemberKind.Property
 				var m = member as IInterfaceMemberSpec;
 				return m.MemberType.IsDelegate || m.MemberType == InternalType.Dynamic;
 			default
 				return false;
 			}
 		}
 
 		public static bool IsSpecialMethodInvocation (ResolveContext ec, MethodSpec method, Location loc)
 		{
 			if (!method.IsReservedMethod)
 				return false;
 
 			if (ec.HasSet (ResolveContext.Options.InvokeSpecialName) || ec.CurrentMemberDefinition.IsCompilerGenerated)
 				return false;
 
 			ec.Report.SymbolRelatedToPreviousError (method);
 			ec.Report.Error (571, loc, "`{0}'
 				method.GetSignatureForError ());
 	
 			return true;
 		}
 
 		//
 		// Used to decide whether call or callvirt is needed
 		//
 		static bool IsVirtualCallRequired (Expression instance, MethodSpec method)
 		{
 			//
 			// There are 2 scenarious where we emit callvirt
 			//
 			// Case 1
 			// Case 2
 			// correct NRE exception when the method is called
 			//
 			var decl_type = method.DeclaringType;
 			if (decl_type.IsStruct || decl_type.IsEnum)
 				return false;
 
 			if (instance is BaseThis)
 				return false;
 
 			//
 			// It's non-virtual and will never be null
 			//
 			if (!method.IsVirtual && (instance is This || instance is New || instance is ArrayCreation || instance is DelegateCreation))
 				return false;
 
 			return true;
 		}
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
 		
 		// `dup_args' leaves an extra copy of the arguments on the stack
 		// `omit_args' does not leave any arguments at all.
 		// So, basically, you could make one call with `dup_args' set to true,
 		// and then another with `omit_args' set to true, and the two calls
 		// would have the same set of arguments. However, each argument would
 		// only have been evaluated once.
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc,
 		                             bool dup_args, bool omit_args)
 		{
 			LocalTemporary this_arg = null;
 
 			// Speed up the check by not doing it on not allowed targets
 			if (method.ReturnType == TypeManager.void_type && method.IsConditionallyExcluded (loc))
 				return;
 
 			OpCode call_op;
 			TypeSpec iexpr_type;
 
 			if (method.IsStatic) {
 				iexpr_type = null;
 				call_op = OpCodes.Call;
 			} else {
 				iexpr_type = instance_expr.Type;
 
 				if (IsVirtualCallRequired (instance_expr, method)) {
 					call_op = OpCodes.Callvirt;
 				} else {
 					call_op = OpCodes.Call;
 				}
 
 				//
 				// If this is ourselves, push "this"
 				//
 				if (!omit_args) {
 					TypeSpec t = iexpr_type;
 
 					//
 					// Push the instance expression
 					//
 					if ((iexpr_type.IsStruct && (call_op == OpCodes.Callvirt || (call_op == OpCodes.Call && method.DeclaringType == iexpr_type))) ||
 						iexpr_type.IsGenericParameter || TypeManager.IsNullableType (method.DeclaringType)) {
 						//
 						// If the expression implements IMemoryLocation, then
 						// we can optimize and use AddressOf on the
 						// return.
 						//
 						// If not we have to use some temporary storage for
 						// it.
 						var iml = instance_expr as IMemoryLocation;
 						if (iml != null) {
 							iml.AddressOf (ec, AddressOp.LoadStore);
 						} else {
 							LocalTemporary temp = new LocalTemporary (iexpr_type);
 							instance_expr.Emit (ec);
 							temp.Store (ec);
 							temp.AddressOf (ec, AddressOp.Load);
 						}
 
 						// avoid the overhead of doing this all the time.
 						if (dup_args)
 							t = ReferenceContainer.MakeType (iexpr_type);
 					} else if (iexpr_type.IsEnum || iexpr_type.IsStruct) {
 						instance_expr.Emit (ec);
 						ec.Emit (OpCodes.Box, iexpr_type);
 						t = iexpr_type = TypeManager.object_type;
 					} else {
 						instance_expr.Emit (ec);
 					}
 
 					if (dup_args) {
 						ec.Emit (OpCodes.Dup);
 						if (Arguments != null && Arguments.Count != 0) {
 							this_arg = new LocalTemporary (t);
 							this_arg.Store (ec);
 						}
 					}
 				}
 			}
 
 			if (!omit_args && Arguments != null) {
 				var dup_arg_exprs = Arguments.Emit (ec, dup_args);
 				if (dup_args) {
 					this_arg.Emit (ec);
 					LocalTemporary lt;
 					foreach (var dup in dup_arg_exprs) {
 						dup.Emit (ec);
 						lt = dup as LocalTemporary;
 						if (lt != null)
 							lt.Release (ec);
 					}
 				}
 			}
 
 			if (call_op == OpCodes.Callvirt && (iexpr_type.IsGenericParameter || iexpr_type.IsStruct)) {
 				ec.Emit (OpCodes.Constrained, iexpr_type);
 			}
 
 			if (method.Parameters.HasArglist) {
 				var varargs_types = GetVarargsTypes (method, Arguments);
 				ec.Emit (call_op, method, varargs_types);
 				return;
 			}
 
 			//
 			// If you have
 			// this.DoFoo ();
 			// and DoFoo is not virtual, you can omit the callvirt,
 			// because you don't need the null checking behavior.
 			//
 			ec.Emit (call_op, method);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			mg.EmitCall (ec, arguments);
 		}
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			return MakeExpression (ctx, mg.InstanceExpression, mg.BestCandidate, arguments);
 		}
 
 		public static SLE.Expression MakeExpression (BuilderContext ctx, Expression instance, MethodSpec mi, Arguments args)
 		{
 #if STATIC
 			throw new NotSupportedException ();
 #else
 			var instance_expr = instance == null ? null 
 			return SLE.Expression.Call (instance_expr, (MethodInfo) mi.GetMetaInfo (), Arguments.MakeExpression (args, ctx));
 #endif
 		}
 	}
 
 	//
 	// Implements simple new expression 
 	//
 	public class New 
 	{
 		protected Arguments arguments;
 
 		//
 		// During bootstrap, it contains the RequestedType,
 		// but if `type' is not null, it *might* contain a NewDelegate
 		// (because of field multi-initialization)
 		//
 		protected Expression RequestedType;
 
 		protected MethodSpec method;
 
 		public New (Expression requested_type, Arguments arguments, Location l)
 		{
 			RequestedType = requested_type;
 			this.arguments = arguments;
 			loc = l;
 		}
]]></clone_fragment>
<clone_fragment endline="702" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" hamdist="10" pcid="5223" startline="53"><![CDATA[
 		static object evaluator_lock = new object ();
 		
 		static string current_debug_name;
 		static int count;
 		static Thread invoke_thread;
 
 		static List<NamespaceEntry.UsingAliasEntry> using_alias_list = new List<NamespaceEntry.UsingAliasEntry> ();
 		internal static List<NamespaceEntry.UsingEntry> using_list = new List<NamespaceEntry.UsingEntry> ();
 		static Dictionary<string, Tuple<FieldSpec, FieldInfo>> fields = new Dictionary<string, Tuple<FieldSpec, FieldInfo>> ();
 
 		static TypeSpec interactive_base_class;
 		static Driver driver;
 		static bool inited;
 
 		static CompilerContext ctx;
 		static DynamicLoader loader;
 		
 		public static TextWriter MessageOutput = Console.Out;
 
 		/// <summary>
 		///   Optional initialization for the Evaluator.
 		/// </summary>
 		/// <remarks>
 		///  Initializes the Evaluator with the command line options
 		///  that would be processed by the command line compiler.  Only
 		///  the first call to Init will work, any future invocations are
 		///  ignored.
 		///
 		///  You can safely avoid calling this method if your application
 		///  does not need any of the features exposed by the command line
 		///  interface.
 		/// </remarks>
 		public static void Init (string [] args)
 		{
 			InitAndGetStartupFiles (args);
 		}
 
 		internal static ReportPrinter SetPrinter (ReportPrinter report_printer)
 		{
 			return ctx.Report.SetPrinter (report_printer);
 		}				
 
 		public static string [] InitAndGetStartupFiles (string [] args)
 		{
 			return InitAndGetStartupFiles (args, null);
 		}
 
 		/// <summary>
 		///   Optional initialization for the Evaluator.
 		/// </summary>
 		/// <remarks>
 		///  Initializes the Evaluator with the command line
 		///  options that would be processed by the command
 		///  line compiler.  Only the first call to
 		///  InitAndGetStartupFiles or Init will work, any future
 		///  invocations are ignored.
 		///
 		///  You can safely avoid calling this method if your application
 		///  does not need any of the features exposed by the command line
 		///  interface.
 		///
 		///  This method return an array of strings that contains any
 		///  files that were specified in `args'.
 		///
 		///  If the unknownOptionParser is not null, this function is invoked
 		///  with the current args array and the index of the option that is not
 		///  known.  A value of true means that the value was processed, otherwise
 		///  it will be reported as an error
 		/// </remarks>
 		public static string [] InitAndGetStartupFiles (string [] args, Func<string [], int, int> unknownOptionParser)
 		{
 			lock (evaluator_lock){
 				if (inited)
 					return new string [0];
 
 				CompilerCallableEntryPoint.Reset ();
 				var crp = new ConsoleReportPrinter ();
 				driver = Driver.Create (args, false, unknownOptionParser, crp);
 				if (driver == null)
 					throw new Exception ("Failed to create compiler driver with the given arguments");
 
 				crp.Fatal = driver.fatal_errors;
 				ctx = driver.ctx;
 
 				RootContext.ToplevelTypes = new ModuleContainer (ctx);
 				
 				var startup_files = new List<string> ();
 				foreach (CompilationUnit file in Location.SourceFiles)
 					startup_files.Add (file.Path);
 				
 				CompilerCallableEntryPoint.PartialReset ();
 
 				var importer = new ReflectionImporter (ctx.BuildinTypes);
 				loader = new DynamicLoader (importer, ctx);
 
 				RootContext.ToplevelTypes.SetDeclaringAssembly (new AssemblyDefinitionDynamic (RootContext.ToplevelTypes, "temp"));
 
 				loader.LoadReferences (RootContext.ToplevelTypes);
 				ctx.BuildinTypes.CheckDefinitions (RootContext.ToplevelTypes);
 				RootContext.ToplevelTypes.InitializePredefinedTypes ();
 
 				RootContext.EvalMode = true;
 				inited = true;
 
 				return startup_files.ToArray ();
 			}
 		}
 
 		static void Init ()
 		{
 			Init (new string [0]);
 		}
 		
 		static void Reset ()
 		{
 			CompilerCallableEntryPoint.PartialReset ();
 			
 			Location.AddFile (null, "{interactive}");
 			Location.Initialize ();
 
 			current_debug_name = "interactive" + (count++) + ".dll";
 		}
 
 		/// <summary>
 		///   The base class for the classes that host the user generated code
 		/// </summary>
 		/// <remarks>
 		///
 		///   This is the base class that will host the code
 		///   executed by the Evaluator.  By default
 		///   this is the Mono.CSharp.InteractiveBase class
 		///   which is useful for interactive use.
 		///
 		///   By changing this property you can control the
 		///   base class and the static members that are
 		///   available to your evaluated code.
 		/// </remarks>
 		static public TypeSpec InteractiveBaseClass {
 			get {
 				if (interactive_base_class != null)
 					return interactive_base_class;
 
 				return loader.Importer.ImportType (typeof (InteractiveBase));
 			}
 		}
 
 		public static void SetInteractiveBaseClass (Type type)
 		{
 			if (type == null)
 				throw new ArgumentNullException ();
 
 			if (!inited)
 				throw new Exception ("Evaluator has to be initiated before seting custom InteractiveBase class");
 
 			lock (evaluator_lock)
 				interactive_base_class = loader.Importer.ImportType (type);
 		}
 
 		/// <summary>
 		///   Interrupts the evaluation of an expression executing in Evaluate.
 		/// </summary>
 		/// <remarks>
 		///   Use this method to interrupt long-running invocations.
 		/// </remarks>
 		public static void Interrupt ()
 		{
 			if (!inited || !invoking)
 				return;
 			
 			if (invoke_thread != null)
 				invoke_thread.Abort ();
 		}
 
 		/// <summary>
 		///   Compiles the input string and returns a delegate that represents the compiled code.
 		/// </summary>
 		/// <remarks>
 		///
 		///   Compiles the input string as a C# expression or
 		///   statement, unlike the Evaluate method, the
 		///   resulting delegate can be invoked multiple times
 		///   without incurring in the compilation overhead.
 		///
 		///   If the return value of this function is null,
 		///   this indicates that the parsing was complete.
 		///   If the return value is a string it indicates
 		///   that the input string was partial and that the
 		///   invoking code should provide more code before
 		///   the code can be successfully compiled.
 		///
 		///   If you know that you will always get full expressions or
 		///   statements and do not care about partial input, you can use
 		///   the other Compile overload. 
 		///
 		///   On success, in addition to returning null, the
 		///   compiled parameter will be set to the delegate
 		///   that can be invoked to execute the code.
 		///
 	        /// </remarks>
 		static public string Compile (string input, out CompiledMethod compiled)
 		{
 			if (input == null || input.Length == 0){
 				compiled = null;
 				return null;
 			}
 
 			lock (evaluator_lock){
 				if (!inited)
 					Init ();
 				else
 					ctx.Report.Printer.Reset ();
 
 			//	RootContext.ToplevelTypes = new ModuleContainer (ctx);
 
 				bool partial_input;
 				CSharpParser parser = ParseString (ParseMode.Silent, input, out partial_input);
 				if (parser == null){
 					compiled = null;
 					if (partial_input)
 						return input;
 					
 					ParseString (ParseMode.ReportErrors, input, out partial_input);
 					return null;
 				}
 				
 				object parser_result = parser.InteractiveResult;
 				
 				if (!(parser_result is Class)){
 					int errors = ctx.Report.Errors;
 
 					NamespaceEntry.VerifyAllUsing ();
 					if (errors == ctx.Report.Errors)
 						parser.CurrentNamespace.Extract (using_alias_list, using_list);
 					else
 						NamespaceEntry.Reset ();
 				}
 
 #if STATIC
 				throw new NotSupportedException ();
 #else
 				compiled = CompileBlock (parser_result as Class, parser.undo, ctx.Report);
 				return null;
 #endif
 			}
 		}
 
 		/// <summary>
 		///   Compiles the input string and returns a delegate that represents the compiled code.
 		/// </summary>
 		/// <remarks>
 		///
 		///   Compiles the input string as a C# expression or
 		///   statement, unlike the Evaluate method, the
 		///   resulting delegate can be invoked multiple times
 		///   without incurring in the compilation overhead.
 		///
 		///   This method can only deal with fully formed input
 		///   strings and does not provide a completion mechanism.
 		///   If you must deal with partial input (for example for
 		///   interactive use) use the other overload. 
 		///
 		///   On success, a delegate is returned that can be used
 		///   to invoke the method.
 		///
 	        /// </remarks>
 		static public CompiledMethod Compile (string input)
 		{
 			CompiledMethod compiled;
 
 			// Ignore partial inputs
 			if (Compile (input, out compiled) != null){
 				// Error, the input was partial.
 				return null;
 			}
 
 			// Either null (on error) or the compiled method.
 			return compiled;
 		}
 
 		//
 		// Todo
 		// the recording themselves?
 		//
 
 		/// <summary>
 		///   Evaluates and expression or statement and returns any result values.
 		/// </summary>
 		/// <remarks>
 		///   Evaluates the input string as a C# expression or
 		///   statement.  If the input string is an expression
 		///   the result will be stored in the result variable
 		///   and the result_set variable will be set to true.
 		///
 		///   It is necessary to use the result/result_set
 		///   pair to identify when a result was set (for
 		///   example, execution of user-provided input can be
 		///   an expression, a statement or others, and
 		///   result_set would only be set if the input was an
 		///   expression.
 		///
 		///   If the return value of this function is null,
 		///   this indicates that the parsing was complete.
 		///   If the return value is a string, it indicates
 		///   that the input is partial and that the user
 		///   should provide an updated string.
 		/// </remarks>
 		public static string Evaluate (string input, out object result, out bool result_set)
 		{
 			CompiledMethod compiled;
 
 			result_set = false;
 			result = null;
 
 			input = Compile (input, out compiled);
 			if (input != null)
 				return input;
 			
 			if (compiled == null)
 				return null;
 				
 			//
 			// The code execution does not need to keep the compiler lock
 			//
 			object retval = typeof (NoValueSet);
 
 			try {
 				invoke_thread = System.Threading.Thread.CurrentThread;
 				invoking = true;
 				compiled (ref retval);
 			} catch (ThreadAbortException e){
 				Thread.ResetAbort ();
 				Console.WriteLine ("Interrupted!\n{0}", e);
 			} finally {
 				invoking = false;
 			}
 
 			//
 			// We use a reference to a compiler type, in this case
 			// Driver as a flag to indicate that this was a statement
 			//
 			if (retval != typeof (NoValueSet)){
 				result_set = true;
 				result = retval; 
 			}
 
 			return null;
 		}
 
 		public static string [] GetCompletions (string input, out string prefix)
 		{
 			prefix = "";
 			if (input == null || input.Length == 0)
 				return null;
 			
 			lock (evaluator_lock){
 				if (!inited)
 					Init ();
 				
 				bool partial_input;
 				CSharpParser parser = ParseString (ParseMode.GetCompletions, input, out partial_input);
 				if (parser == null){
 					if (CSharpParser.yacc_verbose_flag != 0)
 						Console.WriteLine ("DEBUG
 					return null;
 				}
 				
 				Class parser_result = parser.InteractiveResult as Class;
 				
 				if (parser_result == null){
 					if (CSharpParser.yacc_verbose_flag != 0)
 						Console.WriteLine ("Do not know how to cope with !Class yet");
 					return null;
 				}
 
 				try {
 					var a = new AssemblyDefinitionDynamic (RootContext.ToplevelTypes, "temp");
 					a.Create (AppDomain.CurrentDomain, AssemblyBuilderAccess.Run);
 					RootContext.ToplevelTypes.SetDeclaringAssembly (a);
 					RootContext.ToplevelTypes.Define ();
 					if (ctx.Report.Errors != 0)
 						return null;
 					
 					MethodOrOperator method = null;
 					foreach (MemberCore member in parser_result.Methods){
 						if (member.Name != "Host")
 							continue;
 						
 						method = (MethodOrOperator) member;
 						break;
 					}
 					if (method == null)
 						throw new InternalErrorException ("did not find the the Host method");
 
 					BlockContext bc = new BlockContext (method, method.Block, method.ReturnType);
 
 					try {
 						method.Block.Resolve (null, bc, method);
 					} catch (CompletionResult cr){
 						prefix = cr.BaseText;
 						return cr.Result;
 					} 
 				} finally {
 					parser.undo.ExecuteUndo ();
 				}
 				
 			}
 			return null;
 		}
 
 		/// <summary>
 		///   Executes the given expression or statement.
 		/// </summary>
 		/// <remarks>
 		///    Executes the provided statement, returns true
 		///    on success, false on parsing errors.  Exceptions
 		///    might be thrown by the called code.
 		/// </remarks>
 		public static bool Run (string statement)
 		{
 			if (!inited)
 				Init ();
 
 			object result;
 			bool result_set;
 
 			bool ok = Evaluate (statement, out result, out result_set) == null;
 			
 			return ok;
 		}
 
 		/// <summary>
 		///   Evaluates and expression or statement and returns the result.
 		/// </summary>
 		/// <remarks>
 		///   Evaluates the input string as a C# expression or
 		///   statement and returns the value.   
 		///
 		///   This method will throw an exception if there is a syntax error,
 		///   of if the provided input is not an expression but a statement.
 		/// </remarks>
 		public static object Evaluate (string input)
 		{
 			object result;
 			bool result_set;
 			
 			string r = Evaluate (input, out result, out result_set);
 
 			if (r != null)
 				throw new ArgumentException ("Syntax error on input
 			
 			if (result_set == false)
 				throw new ArgumentException ("The expression did not set a result");
 
 			return result;
 		}
 
 		enum InputKind {
 			EOF,
 			StatementOrExpression,
 			CompilationUnit,
 			Error
 		}
 
 		//
 		// Deambiguates the input string to determine if we
 		// want to process a statement or if we want to
 		// process a compilation unit.
 		//
 		// This is done using a top-down predictive parser,
 		// since the yacc/jay parser can not deambiguage this
 		// without more than one lookahead token.   There are very
 		// few ambiguities.
 		//
 		static InputKind ToplevelOrStatement (SeekableStreamReader seekable)
 		{
 			Tokenizer tokenizer = new Tokenizer (seekable, (CompilationUnit) Location.SourceFiles [0], ctx);
 			
 			int t = tokenizer.token ();
 			switch (t){
 			case Token.EOF
 				return InputKind.EOF;
 				
 			// These are toplevels
 			case Token.EXTERN
 			case Token.OPEN_BRACKET
 			case Token.ABSTRACT
 			case Token.CLASS
 			case Token.ENUM
 			case Token.INTERFACE
 			case Token.INTERNAL
 			case Token.NAMESPACE
 			case Token.PRIVATE
 			case Token.PROTECTED
 			case Token.PUBLIC
 			case Token.SEALED
 			case Token.STATIC
 			case Token.STRUCT
 				return InputKind.CompilationUnit;
 				
 			// Definitely expression
 			case Token.FIXED
 			case Token.BOOL
 			case Token.BYTE
 			case Token.CHAR
 			case Token.DECIMAL
 			case Token.DOUBLE
 			case Token.FLOAT
 			case Token.INT
 			case Token.LONG
 			case Token.NEW
 			case Token.OBJECT
 			case Token.SBYTE
 			case Token.SHORT
 			case Token.STRING
 			case Token.UINT
 			case Token.ULONG
 				return InputKind.StatementOrExpression;
 
 			// These need deambiguation help
 			case Token.USING
 				t = tokenizer.token ();
 				if (t == Token.EOF)
 					return InputKind.EOF;
 
 				if (t == Token.IDENTIFIER)
 					return InputKind.CompilationUnit;
 				return InputKind.StatementOrExpression;
 
 
 			// Distinguish between
 			//    delegate opt_anonymous_method_signature block
 			//    delegate type 
 			case Token.DELEGATE
 				t = tokenizer.token ();
 				if (t == Token.EOF)
 					return InputKind.EOF;
 				if (t == Token.OPEN_PARENS || t == Token.OPEN_BRACE)
 					return InputKind.StatementOrExpression;
 				return InputKind.CompilationUnit;
 
 			// Distinguih between
 			//    unsafe block
 			//    unsafe as modifier of a type declaration
 			case Token.UNSAFE
 				t = tokenizer.token ();
 				if (t == Token.EOF)
 					return InputKind.EOF;
 				if (t == Token.OPEN_PARENS)
 					return InputKind.StatementOrExpression;
 				return InputKind.CompilationUnit;
 				
 		        // These are errors
 			// from the grammar, ERROR and then everything else
 
 			case Token.READONLY
 			case Token.OVERRIDE
 			case Token.ERROR
 				return InputKind.Error;
 
 			// This catches everything else allowed by
 			// expressions.  We could add one-by-one use cases
 			// if needed.
 			default
 				return InputKind.StatementOrExpression;
 			}
 		}
 		
 		//
 		// Parses the string @input and returns a CSharpParser if succeeful.
 		//
 		// if @silent is set to true then no errors are
 		// reported to the user.  This is used to do various calls to the
 		// parser and check if the expression is parsable.
 		//
 		// @partial_input
 		// parsed expression was partial, and more data is needed
 		//
 		static CSharpParser ParseString (ParseMode mode, string input, out bool partial_input)
 		{
 			partial_input = false;
 			Reset ();
 			queued_fields.Clear ();
 			Tokenizer.LocatedToken.Initialize ();
 
 			Stream s = new MemoryStream (Encoding.Default.GetBytes (input));
 			SeekableStreamReader seekable = new SeekableStreamReader (s, Encoding.Default);
 
 			InputKind kind = ToplevelOrStatement (seekable);
 			if (kind == InputKind.Error){
 				if (mode == ParseMode.ReportErrors)
 					ctx.Report.Error (-25, "Detection Parsing Error");
 				partial_input = false;
 				return null;
 			}
 
 			if (kind == InputKind.EOF){
 				if (mode == ParseMode.ReportErrors)
 					Console.Error.WriteLine ("Internal error
 				partial_input = true;
 				return null;
 				
 			}
 			seekable.Position = 0;
 
 			CSharpParser parser = new CSharpParser (seekable, Location.SourceFiles [0], RootContext.ToplevelTypes);
 
 			if (kind == InputKind.StatementOrExpression){
 				parser.Lexer.putback_char = Tokenizer.EvalStatementParserCharacter;
 				RootContext.StatementMode = true;
 			} else {
 				//
 				// Do not activate EvalCompilationUnitParserCharacter until
 				// I have figured out all the limitations to invoke methods
 				// in the generated classes.  See repl.txt
 				//
 				parser.Lexer.putback_char = Tokenizer.EvalUsingDeclarationsParserCharacter;
 				//parser.Lexer.putback_char = Tokenizer.EvalCompilationUnitParserCharacter;
 				RootContext.StatementMode = false;
 			}
 
 			if (mode == ParseMode.GetCompletions)
 				parser.Lexer.CompleteOnEOF = true;
 
 			ReportPrinter old_printer = null;
 			if ((mode == ParseMode.Silent || mode == ParseMode.GetCompletions) && CSharpParser.yacc_verbose_flag == 0)
 				old_printer = SetPrinter (new StreamReportPrinter (TextWriter.Null));
 
 			try {
 				parser.parse ();
 			} finally {
 				if (ctx.Report.Errors != 0){
 					if (mode != ParseMode.ReportErrors  && parser.UnexpectedEOF)
 						partial_input = true;
 
 					parser.undo.ExecuteUndo ();
 					parser = null;
 				}
 
 				if (old_printer != null)
 					SetPrinter (old_printer);
 			}
 			return parser;
 		}
 
 		//
 		// Queue all the fields that we use, as we need to then go from FieldBuilder to FieldInfo
 		// or reflection gets confused (it basically gets confused, and variables override each
 		// other).
 		//
 		static List<Field> queued_fields = new List<Field> ();
]]></clone_fragment>
<clone_fragment endline="291" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" hamdist="17" pcid="5869" startline="100"><![CDATA[
 		private readonly int position;
 
 		private sealed class DummyModule 
 		{
 			internal DummyModule()
 				
 			{
 			}
 
 			public override bool Equals(object obj)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override int GetHashCode()
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ToString()
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override int MDStreamVersion
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Assembly Assembly
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			internal override Type GetTypeImpl(string typeName)
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override void GetTypesImpl(List<Type> list)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string FullyQualifiedName
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override string Name
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Guid ModuleVersionId
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ResolveString(int metadataToken)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override Type[] __ResolveOptionalParameterTypes(int metadataToken)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ScopeName
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override AssemblyName[] __GetReferencedAssemblies()
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override Type GetModuleType()
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override ByteReader GetBlob(int blobIndex)
 			{
 				throw new InvalidOperationException();
 			}
 		}
 
 		internal static Type Make(int position)
 		{
 			return module.CanonicalizeType(new UnboundGenericMethodParameter(position));
 		}
 
 		private UnboundGenericMethodParameter(int position)
 		{
 			this.position = position;
 		}
 
 		public override bool Equals(object obj)
 		{
 			UnboundGenericMethodParameter other = obj as UnboundGenericMethodParameter;
 			return other != null && other.position == position;
 		}
 
 		public override int GetHashCode()
 		{
 			return position;
 		}
 
 		public override string Namespace
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override string Name
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override int MetadataToken
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override Module Module
 		{
 			get { return module; }
 		}
 
 		public override int GenericParameterPosition
 		{
 			get { return position; }
 		}
 
 		public override Type DeclaringType
 		{
 			get { return null; }
 		}
 
 		public override MethodBase DeclaringMethod
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override Type[] GetGenericParameterConstraints()
 		{
 			throw new InvalidOperationException();
 		}
 
 		public override GenericParameterAttributes GenericParameterAttributes
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		internal override Type BindTypeParameters(IGenericBinder binder)
 		{
 			return binder.BindMethodParameter(this);
 		}
 	}
 
 	sealed class GenericTypeParameter 
 	{
 		private readonly ModuleReader module;
 		private readonly int index;
 
 		internal GenericTypeParameter(ModuleReader module, int index)
 		{
 			this.module = module;
 			this.index = index;
 		}
]]></clone_fragment>
<clone_fragment endline="3109" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="17" pcid="3427" startline="2999"><![CDATA[
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
 
 		public Expression Label {
 			get {
 				return label;
 			}
 		}
 
 		public Location Location {
 			get { return loc; }
 		}
 
 		public object Converted {
 			get {
 				return converted;
 			}
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
 
 		public void Error_AlreadyOccurs (ResolveContext ec, TypeSpec switch_type, SwitchLabel collision_with)
 		{
 			string label;
 			if (converted == null)
 				label = "default";
 			else if (converted == NullStringCase)
 				label = "null";
 			else
 				label = converted.ToString ();
 			
 			ec.Report.SymbolRelatedToPreviousError (collision_with.loc, null);
 			ec.Report.Error (152, loc, "The label `case {0}
 		}
 
 		public SwitchLabel Clone (CloneContext clonectx)
 		{
 			if (label == null)
 				return this;
 
 			return new SwitchLabel (label.Clone (clonectx), loc);
 		}
 	}
 
 	public class SwitchSection {
 		public readonly List<SwitchLabel> Labels;
 		public readonly Block Block;
 		
 		public SwitchSection (List<SwitchLabel> labels, Block block)
 		{
 			Labels = labels;
 			Block = block;
 		}
]]></clone_fragment>
<clone_fragment endline="1205" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" hamdist="11" pcid="3203" startline="1050"><![CDATA[
 
 		//
 		// User-defined conversions
 		//
 		static Expression UserDefinedConversion (ResolveContext ec, Expression source, TypeSpec target, bool implicitOnly, Location loc)
 		{
 			List<MethodSpec> candidates = null;
 
 			//
 			// If S or T are nullable types, source_type and target_type are their underlying types
 			// otherwise source_type and target_type are equal to S and T respectively.
 			//
 			TypeSpec source_type = source.Type;
 			TypeSpec target_type = target;
 			Expression source_type_expr;
 
 			if (TypeManager.IsNullableType (source_type)) {
 				// No implicit conversion S? -> T for non-reference types
 				if (implicitOnly && !TypeManager.IsReferenceType (target_type) && !TypeManager.IsNullableType (target_type))
 					return null;
 
 				source_type_expr = Nullable.Unwrap.Create (source);
 				source_type = source_type_expr.Type;
 			} else {
 				source_type_expr = source;
 			}
 
 			if (TypeManager.IsNullableType (target_type))
 				target_type = Nullable.NullableInfo.GetUnderlyingType (target_type);
 
 			// Only these containers can contain a user defined implicit or explicit operators
 			const MemberKind user_conversion_kinds = MemberKind.Class | MemberKind.Struct | MemberKind.TypeParameter;
 
 			if ((source_type.Kind & user_conversion_kinds) != 0 && source_type != TypeManager.decimal_type) {
 				bool declared_only = source_type.IsStruct;
 
 				var operators = MemberCache.GetUserOperator (source_type, Operator.OpType.Implicit, declared_only);
 				if (operators != null) {
 					FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, implicitOnly, ref candidates);
 				}
 
 				if (!implicitOnly) {
 					operators = MemberCache.GetUserOperator (source_type, Operator.OpType.Explicit, declared_only);
 					if (operators != null) {
 						FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, false, ref candidates);
 					}
 				}
 			}
 
 			if ((target.Kind & user_conversion_kinds) != 0 && target_type != TypeManager.decimal_type) {
 				bool declared_only = target.IsStruct || implicitOnly;
 
 				var operators = MemberCache.GetUserOperator (target_type, Operator.OpType.Implicit, declared_only);
 				if (operators != null) {
 					FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, implicitOnly, ref candidates);
 				}
 
 				if (!implicitOnly) {
 					operators = MemberCache.GetUserOperator (target_type, Operator.OpType.Explicit, declared_only);
 					if (operators != null) {
 						FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, false, ref candidates);
 					}
 				}
 			}
 
 			if (candidates == null)
 				return null;
 
 			//
 			// Find the most specific conversion operator
 			//
 			MethodSpec most_specific_operator;
 			TypeSpec s_x, t_x;
 			if (candidates.Count == 1) {
 				most_specific_operator = candidates[0];
 				s_x = most_specific_operator.Parameters.Types[0];
 				t_x = most_specific_operator.ReturnType;
 			} else {
 				//
 				// Pass original source type to find the best match against input type and
 				// not the unwrapped expression
 				//
 				s_x = FindMostSpecificSource (candidates, source.Type, source_type_expr, !implicitOnly);
 				if (s_x == null)
 					return null;
 
 				t_x = FindMostSpecificTarget (candidates, target, !implicitOnly);
 				if (t_x == null)
 					return null;
 
 				most_specific_operator = null;
 				for (int i = 0; i < candidates.Count; ++i) {
 					if (candidates[i].ReturnType == t_x && candidates[i].Parameters.Types[0] == s_x) {
 						most_specific_operator = candidates[i];
 						break;
 					}
 				}
 				for (int i = 0; i < candidates.Count; ++i) {
 					if (candidates[i].ReturnType == t_x && candidates[i].Parameters.Types[0] == s_x) {
 						most_specific_operator = candidates[i];
 						break;
 					}
 				}
 
 				if (most_specific_operator == null) {
 					MethodSpec ambig_arg = null;
 					foreach (var candidate in candidates) {
 						if (candidate.ReturnType == t_x)
 							most_specific_operator = candidate;
 						else if (candidate.Parameters.Types[0] == s_x)
 							ambig_arg = candidate;
 					}
 					foreach (var candidate in candidates) {
 						if (candidate.ReturnType == t_x)
 							most_specific_operator = candidate;
 						else if (candidate.Parameters.Types[0] == s_x)
 							ambig_arg = candidate;
 					}
 
 					ec.Report.Error (457, loc,
 						"Ambiguous user defined operators `{0}' and `{1}' when converting from `{2}' to `{3}'",
 						ambig_arg.GetSignatureForError (), most_specific_operator.GetSignatureForError (),
 						source.Type.GetSignatureForError (), target.GetSignatureForError ());
 				}
 			}
 
 			//
 			// Convert input type when it's different to best operator argument
 			//
 			if (s_x != source_type)
 				source = implicitOnly ?
 					ImplicitConversionStandard (ec, source_type_expr, s_x, loc) 
 					ExplicitConversionStandard (ec, source_type_expr, s_x, loc);
 			else {
 				source = source_type_expr;
 			}
 
 			source = new UserCast (most_specific_operator, source, loc).Resolve (ec);
 
 			//
 			// Convert result type when it's different to best operator return type
 			//
 			if (t_x != target_type) {
 				//
 				// User operator is of T?, no need to lift it
 				//
 				if (TypeManager.IsNullableType (t_x) && t_x == target)
 					return source;
 
 				source = implicitOnly ?
 					ImplicitConversionStandard (ec, source, target_type, loc) 
 					ExplicitConversionStandard (ec, source, target_type, loc);
 
 				if (source == null)
 					return null;
 			}
 
 			//
 			// Source expression is of nullable type, lift the result in the case it's null and
 			// not nullable/lifted user operator is used
 			//
 			if (source_type_expr is Nullable.Unwrap && !TypeManager.IsNullableType (s_x) && (TypeManager.IsReferenceType (target) || target_type != target))
 				source = new Nullable.Lifted (source, source_type_expr, target).Resolve (ec);
 			else if (target_type != target)
 				source = Nullable.Wrap.Create (source, target);
 
 			return source;
 		}
]]></clone_fragment>
<clone_fragment endline="2108" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" hamdist="14" pcid="4157" startline="1991"><![CDATA[
 
 		bool CheckConstraint (MemberSpec context, TypeSpec atype, TypeParameterSpec tparam, Location loc)
 		{
 			//
 			// First, check the `class' and `struct' constraints.
 			//
 			if (tparam.HasSpecialClass && !TypeManager.IsReferenceType (atype)) {
 				if (mc != null) {
 					mc.Compiler.Report.Error (452, loc,
 						"The type `{0}' must be a reference type in order to use it as type parameter `{1}' in the generic type or method `{2}'",
 						TypeManager.CSharpName (atype), tparam.GetSignatureForError (), context.GetSignatureForError ());
 				}
 
 				return false;
 			}
 
 			if (tparam.HasSpecialStruct && (!TypeManager.IsValueType (atype) || TypeManager.IsNullableType (atype))) {
 				if (mc != null) {
 					mc.Compiler.Report.Error (453, loc,
 						"The type `{0}' must be a non-nullable value type in order to use it as type parameter `{1}' in the generic type or method `{2}'",
 						TypeManager.CSharpName (atype), tparam.GetSignatureForError (), context.GetSignatureForError ());
 				}
 
 				return false;
 			}
 
 			bool ok = true;
 
 			//
 			// Check the class constraint
 			//
 			if (tparam.HasTypeConstraint) {
 				var dep = tparam.BaseType.GetMissingDependencies ();
 				if (dep != null) {
 					if (mc == null)
 						return false;
 
 					ImportedTypeDefinition.Error_MissingDependency (mc, dep, loc);
 					ok = false;
 				}
 
 				if (!CheckConversion (mc, context, atype, tparam, tparam.BaseType, loc)) {
 					if (mc == null)
 						return false;
 
 					ok = false;
 				}
 			}
 
 			//
 			// Check the interfaces constraints
 			//
 			if (tparam.Interfaces != null) {
 				if (TypeManager.IsNullableType (atype)) {
 					if (mc == null)
 						return false;
 
 					mc.Compiler.Report.Error (313, loc,
 						"The type `{0}' cannot be used as type parameter `{1}' in the generic type or method `{2}'. The nullable type `{0}' never satisfies interface constraint",
 						atype.GetSignatureForError (), tparam.GetSignatureForError (), context.GetSignatureForError ());
 					ok = false;
 				} else {
 					foreach (TypeSpec iface in tparam.Interfaces) {
 						var dep = iface.GetMissingDependencies ();
 						if (dep != null) {
 							if (mc == null)
 								return false;
 
 							ImportedTypeDefinition.Error_MissingDependency (mc, dep, loc);
 							ok = false;
 
 							// return immediately to avoid duplicate errors because we are scanning
 							// expanded interface list
 							return false;
 						}
 
 						if (!CheckConversion (mc, context, atype, tparam, iface, loc)) {
 							if (mc == null)
 								return false;
 
 							ok = false;
 						}
 					}
 					foreach (TypeSpec iface in tparam.Interfaces) {
 						var dep = iface.GetMissingDependencies ();
 						if (dep != null) {
 							if (mc == null)
 								return false;
 
 							ImportedTypeDefinition.Error_MissingDependency (mc, dep, loc);
 							ok = false;
 
 							// return immediately to avoid duplicate errors because we are scanning
 							// expanded interface list
 							return false;
 						}
 
 						if (!CheckConversion (mc, context, atype, tparam, iface, loc)) {
 							if (mc == null)
 								return false;
 
 							ok = false;
 						}
 					}
 				}
 			}
 
 			//
 			// Check the type parameter constraint
 			//
 			if (tparam.TypeArguments != null) {
 				foreach (var ta in tparam.TypeArguments) {
 					if (!CheckConversion (mc, context, atype, tparam, ta, loc)) {
 						if (mc == null)
 							return false;
 
 						ok = false;
 					}
 				}
 				foreach (var ta in tparam.TypeArguments) {
 					if (!CheckConversion (mc, context, atype, tparam, ta, loc)) {
 						if (mc == null)
 							return false;
 
 						ok = false;
 					}
 				}
 			}
 
 			//
 			// Finally, check the constructor constraint.
 			//
 			if (!tparam.HasSpecialConstructor)
 				return ok;
 
 			if (!HasDefaultConstructor (atype)) {
 				if (mc != null) {
 					mc.Compiler.Report.SymbolRelatedToPreviousError (atype);
 					mc.Compiler.Report.Error (310, loc,
 						"The type `{0}' must have a public parameterless constructor in order to use it as parameter `{1}' in the generic type or method `{2}'",
 						TypeManager.CSharpName (atype), tparam.GetSignatureForError (), context.GetSignatureForError ());
 				}
 				return false;
 			}
 
 			return ok;
 		}
]]></clone_fragment>
<clone_fragment endline="1368" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" hamdist="8" pcid="3365" startline="1275"><![CDATA[
 
 		public override bool Resolve (BlockContext bc)
 		{
 			if (li.Type == null) {
 				TypeSpec type = null;
 				if (type_expr is VarExpr) {
 					//
 					// C# 3.0 introduced contextual keywords (var) which behaves like a type if type with
 					// same name exists or as a keyword when no type was found
 					// 
 					var texpr = type_expr.ResolveAsTypeTerminal (bc, true);
 					if (texpr == null) {
 						if (RootContext.Version < LanguageVersion.V_3)
 							bc.Report.FeatureIsNotAvailable (loc, "implicitly typed local variable");
 
 						if (li.IsFixed) {
 							bc.Report.Error (821, loc, "A fixed statement cannot use an implicitly typed local variable");
 							return false;
 						}
 
 						if (li.IsConstant) {
 							bc.Report.Error (822, loc, "An implicitly typed local variable cannot be a constant");
 							return false;
 						}
 
 						if (Initializer == null) {
 							bc.Report.Error (818, loc, "An implicitly typed local variable declarator must include an initializer");
 							return false;
 						}
 
 						if (declarators != null) {
 							bc.Report.Error (819, loc, "An implicitly typed local variable declaration cannot include multiple declarators");
 							declarators = null;
 						}
 
 						Initializer = Initializer.Resolve (bc);
 						if (Initializer != null) {
 							((VarExpr) type_expr).InferType (bc, Initializer);
 							type = type_expr.Type;
 						}
 					}
 				}
 
 				if (type == null) {
 					var texpr = type_expr.ResolveAsTypeTerminal (bc, false);
 					if (texpr == null)
 						return false;
 
 					type = texpr.Type;
 
 					if (li.IsConstant && !type.IsConstantCompatible) {
 						Const.Error_InvalidConstantType (type, loc, bc.Report);
 					}
 				}
 
 				if (type.IsStatic)
 					FieldBase.Error_VariableOfStaticClass (loc, li.Name, type, bc.Report);
 
 				if (type.IsPointer && !bc.IsUnsafe)
 					Expression.UnsafeError (bc, loc);
 
 				li.Type = type;
 			}
 
 			bool eval_global = RootContext.StatementMode && bc.CurrentBlock is ToplevelBlock;
 			if (eval_global) {
 				CreateEvaluatorVariable (bc, li);
 			} else {
 				li.PrepareForFlowAnalysis (bc);
 			}
 
 			if (initializer != null) {
 				initializer = ResolveInitializer (bc, li, initializer);
 				// li.Variable.DefinitelyAssigned 
 			}
 
 			if (declarators != null) {
 				foreach (var d in declarators) {
 					d.Variable.Type = li.Type;
 					if (eval_global) {
 						CreateEvaluatorVariable (bc, d.Variable);
 					} else {
 						d.Variable.PrepareForFlowAnalysis (bc);
 					}
 
 					if (d.Initializer != null) {
 						d.Initializer = ResolveInitializer (bc, d.Variable, d.Initializer);
 						// d.Variable.DefinitelyAssigned 
 					}
 				}
 				foreach (var d in declarators) {
 					d.Variable.Type = li.Type;
 					if (eval_global) {
 						CreateEvaluatorVariable (bc, d.Variable);
 					} else {
 						d.Variable.PrepareForFlowAnalysis (bc);
 					}
 
 					if (d.Initializer != null) {
 						d.Initializer = ResolveInitializer (bc, d.Variable, d.Initializer);
 						// d.Variable.DefinitelyAssigned 
 					}
 				}
 			}
 
 			return true;
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="365" nfragments="2">
<clone_fragment endline="520" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" hamdist="0" pcid="4005" startline="398"><![CDATA[
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly MethodBuilder method;
 			private readonly int parameter;
 
 			internal ParameterInfoImpl(MethodBuilder method, int parameter)
 			{
 				this.method = method;
 				this.parameter = parameter;
 			}
 
 			private ParameterBuilder ParameterBuilder
 			{
 				get
 				{
 					if (method.parameters != null)
 					{
 						foreach (ParameterBuilder pb in method.parameters)
 						{
 							if (pb.Position == parameter)
 							{
 								return pb;
 							}
 						}
 					}
 					return null;
 				}
 			}
 
 			public override string Name
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? pb.Name 
 				}
 			}
 
 			public override Type ParameterType
 			{
 				get { return parameter == -1 ? method.returnType 
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? (ParameterAttributes)pb.Attributes 
 				}
 			}
 
 			public override int Position
 			{
 				get { return parameter; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					if (pb != null && (pb.Attributes & (int)ParameterAttributes.HasDefault) != 0)
 					{
 						return method.ModuleBuilder.Constant.GetRawConstantValue(method.ModuleBuilder, pb.PseudoToken);
 					}
 					if (pb != null && (pb.Attributes & (int)ParameterAttributes.Optional) != 0)
 					{
 						return Missing.Value;
 					}
 					return null;
 				}
 			}
 
 			private Type[] GetCustomModifiers(int optOrReq)
 			{
 				if (method.modifiers == null || method.modifiers[parameter + 1] == null)
 				{
 					return Type.EmptyTypes;
 				}
 				return Util.Copy(method.modifiers[parameter + 1][optOrReq]);
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return GetCustomModifiers(0);
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return GetCustomModifiers(1);
 			}
 
 			public override MemberInfo Member
 			{
 				get { return method; }
 			}
 
 			public override int MetadataToken
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? pb.PseudoToken 
 				}
 			}
 
 			internal override Module Module
 			{
 				get { return method.Module; }
 			}
 		}
 
 		public override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = new ParameterInfo[parameterTypes.Length];
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			return parameters;
 		}
]]></clone_fragment>
<clone_fragment endline="402" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" hamdist="12" pcid="5979" startline="260"><![CDATA[
 
 		public void Save(string assemblyFileName, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine)
 		{
 			ModuleBuilder manifestModule = null;
 
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.PopulatePropertyAndEventTables();
 
 				if (manifestModule == null
 					&& string.Compare(moduleBuilder.fileName, assemblyFileName, StringComparison.OrdinalIgnoreCase) == 0)
 				{
 					manifestModule = moduleBuilder;
 				}
 			}
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.PopulatePropertyAndEventTables();
 
 				if (manifestModule == null
 					&& string.Compare(moduleBuilder.fileName, assemblyFileName, StringComparison.OrdinalIgnoreCase) == 0)
 				{
 					manifestModule = moduleBuilder;
 				}
 			}
 
 			if (manifestModule == null)
 			{
 				manifestModule = DefineDynamicModule("RefEmit_OnDiskManifestModule", assemblyFileName, false);
 			}
 
 			AssemblyTable.Record assemblyRecord = new AssemblyTable.Record();
 			assemblyRecord.HashAlgId = (int)hashAlgorithm;
 			assemblyRecord.Name = manifestModule.Strings.Add(name);
 			assemblyRecord.MajorVersion = majorVersion;
 			assemblyRecord.MinorVersion = minorVersion;
 			assemblyRecord.BuildNumber = buildVersion;
 			assemblyRecord.RevisionNumber = revisionVersion;
 			if (publicKey != null)
 			{
 				assemblyRecord.PublicKey = manifestModule.Blobs.Add(ByteBuffer.Wrap(publicKey));
 				assemblyRecord.Flags = (int)(flags | AssemblyNameFlags.PublicKey);
 			}
 			else
 			{
 				assemblyRecord.Flags = (int)(flags & ~AssemblyNameFlags.PublicKey);
 			}
 			if (culture != null)
 			{
 				assemblyRecord.Culture = manifestModule.Strings.Add(culture);
 			}
 			int token = 0x20000000 + manifestModule.AssemblyTable.AddRecord(assemblyRecord);
 
 #pragma warning disable 618
 			// this values are obsolete, but we already know that so we disable the warning
 			System.Security.Permissions.SecurityAction requestMinimum = System.Security.Permissions.SecurityAction.RequestMinimum;
 			System.Security.Permissions.SecurityAction requestOptional = System.Security.Permissions.SecurityAction.RequestOptional;
 			System.Security.Permissions.SecurityAction requestRefuse = System.Security.Permissions.SecurityAction.RequestRefuse;
 #pragma warning restore 618
 			if (requiredPermissions != null)
 			{
 				manifestModule.AddDeclarativeSecurity(token, requestMinimum, requiredPermissions);
 			}
 			if (optionalPermissions != null)
 			{
 				manifestModule.AddDeclarativeSecurity(token, requestOptional, optionalPermissions);
 			}
 			if (refusedPermissions != null)
 			{
 				manifestModule.AddDeclarativeSecurity(token, requestRefuse, refusedPermissions);
 			}
 
 			if (versionInfo != null)
 			{
 				versionInfo.SetName(GetName());
 				versionInfo.SetFileName(assemblyFileName);
 				foreach (CustomAttributeBuilder cab in customAttributes)
 				{
 					// .NET doesn't support copying blob custom attributes into the version info
 					if (!cab.HasBlob)
 					{
 						versionInfo.SetAttribute(cab);
 					}
 				}
 				foreach (CustomAttributeBuilder cab in customAttributes)
 				{
 					// .NET doesn't support copying blob custom attributes into the version info
 					if (!cab.HasBlob)
 					{
 						versionInfo.SetAttribute(cab);
 					}
 				}
 				ByteBuffer versionInfoData = new ByteBuffer(512);
 				versionInfo.Write(versionInfoData);
 				if (unmanagedResources == null)
 				{
 					unmanagedResources = new ResourceSection();
 				}
 				unmanagedResources.AddVersionInfo(versionInfoData);
 			}
 
 			foreach (CustomAttributeBuilder cab in customAttributes)
 			{
 				// we intentionally don't filter out the version info (pseudo) custom attributes (to be compatible with .NET)
 				manifestModule.SetCustomAttribute(0x20000001, cab);
 			}
 			foreach (CustomAttributeBuilder cab in customAttributes)
 			{
 				// we intentionally don't filter out the version info (pseudo) custom attributes (to be compatible with .NET)
 				manifestModule.SetCustomAttribute(0x20000001, cab);
 			}
 
 			manifestModule.AddDeclarativeSecurity(0x20000001, declarativeSecurity);
 
 			foreach (Type type in typeForwarders)
 			{
 				manifestModule.AddTypeForwarder(type);
 			}
 			foreach (Type type in typeForwarders)
 			{
 				manifestModule.AddTypeForwarder(type);
 			}
 
 			foreach (ResourceFile resfile in resourceFiles)
 			{
 				int fileToken = AddFile(manifestModule, resfile.FileName, 1 /*ContainsNoMetaData*/);
 				ManifestResourceTable.Record rec = new ManifestResourceTable.Record();
 				rec.Offset = 0;
 				rec.Flags = (int)resfile.Attributes;
 				rec.Name = manifestModule.Strings.Add(resfile.Name);
 				rec.Implementation = fileToken;
 				manifestModule.ManifestResource.AddRecord(rec);
 			}
 			foreach (ResourceFile resfile in resourceFiles)
 			{
 				int fileToken = AddFile(manifestModule, resfile.FileName, 1 /*ContainsNoMetaData*/);
 				ManifestResourceTable.Record rec = new ManifestResourceTable.Record();
 				rec.Offset = 0;
 				rec.Flags = (int)resfile.Attributes;
 				rec.Name = manifestModule.Strings.Add(resfile.Name);
 				rec.Implementation = fileToken;
 				manifestModule.ManifestResource.AddRecord(rec);
 			}
 
 			int entryPointToken = 0;
 
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.FillAssemblyRefTable();
 				if (moduleBuilder != manifestModule)
 				{
 					int fileToken;
 					if (entryPoint != null && entryPoint.Module == moduleBuilder)
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, entryPoint.MetadataToken);
 						entryPointToken = fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					else
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, 0);
 						fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					moduleBuilder.ExportTypes(fileToken, manifestModule);
 				}
 			}
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.FillAssemblyRefTable();
 				if (moduleBuilder != manifestModule)
 				{
 					int fileToken;
 					if (entryPoint != null && entryPoint.Module == moduleBuilder)
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, entryPoint.MetadataToken);
 						entryPointToken = fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					else
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, 0);
 						fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					moduleBuilder.ExportTypes(fileToken, manifestModule);
 				}
 			}
 
 			foreach (Module module in addedModules)
 			{
 				int fileToken = AddFile(manifestModule, module.FullyQualifiedName, 0 /*ContainsMetaData*/);
 				module.ExportTypes(fileToken, manifestModule);
 			}
 			foreach (Module module in addedModules)
 			{
 				int fileToken = AddFile(manifestModule, module.FullyQualifiedName, 0 /*ContainsMetaData*/);
 				module.ExportTypes(fileToken, manifestModule);
 			}
 
 			if (entryPointToken == 0 && entryPoint != null)
 			{
 				entryPointToken = entryPoint.MetadataToken;
 			}
 
 			// finally, write the manifest module
 			ModuleWriter.WriteModule(keyPair, publicKey, manifestModule, fileKind, portableExecutableKind, imageFileMachine, unmanagedResources ?? manifestModule.unmanagedResources, entryPointToken);
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="366" nfragments="2">
<clone_fragment endline="795" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CommandLine.vb" hamdist="0" pcid="7451" startline="782"><![CDATA[
     End Property
 
     ''' <summary>
     ''' Create a new commandline parser!
     ''' </summary>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler)
     Private m_lstResponseFiles As New Specialized.StringCollection
 
     ''' <summary>
     ''' All files specified
     ''' </summary>s
     ''' <remarks></remarks>
     Private m_lstFileNames As CodeFiles
 
     ''' <summary>
     ''' A list of all the arguments parsed.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_lstAllArgs As New Specialized.StringCollection
 
     ''' <summary>
     ''' The compiler used.
     ''' </summary>
     Private m_Compiler As Compiler
 
     ''' <summary>
     ''' The compiler used.
     ''' </summary>
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
 #Region "Properties"
 
     ' - OUTPUT FILE -
 
     ''' <summary>
     ''' /out
     ''' </summary>
     Private m_strOut As String
 
     ''' <summary>
     ''' /target
     ''' /target
     ''' /target
     ''' /target
     ''' </summary>
     Private m_strTarget As Targets
 
     ''' <summary>
     ''' /doc[+|-]               Generates XML documentation file.
     ''' /doc
     ''' </summary>
     ''' <remarks></remarks>
     Private m_strDoc As String
 
     ' - INPUT FILES -
 
     ''' <summary>
     ''' /addmodule
     ''' </summary>
     Private m_lstModules As New Specialized.StringCollection
 
     ''' <summary>
     ''' /recurse
     ''' </summary>
     Private m_lstRecurse As New Specialized.StringCollection
 
     ''' <summary>
     ''' /reference
     ''' </summary>
     Private m_lstReferences As New Specialized.StringCollection
 
     ' - RESOURCES -
 
     ''' <summary>
     ''' /linkresource
     ''' </summary>	
     Private m_lstLinkResources As Resources
 
     ''' <summary>
     ''' /resource
     ''' </summary>
     Private m_lstResources As Resources
 
     ''' <summary>
     ''' /win32icon
     ''' </summary>
     Private m_strWin32Icon As String
 
     ''' <summary>
     ''' /win32resource
     ''' </summary>
     Private m_strWin32Resource As String
 
     ' - CODE GENERATION -
 
     ''' <summary>
     ''' /optimize[+|-]          Enable optimizations.
     ''' </summary>
     Private m_bOptimize As Boolean
 
     ''' <summary>
     ''' /removeintchecks[+|-]   Remove integer checks. Default off.
     ''' </summary>
     Private m_bRemoveIntChecks As Boolean
 
     ''' <summary>
     ''' /debug[+|-]             Emit debugging information.
     '''/debug
     '''/debug
     ''' According to #81054 vbc doesn't emit debug info unless /debug is specified.
     ''' </summary>
     Private m_eDebugInfo As DebugTypes = DebugTypes.None
 
     ' - ERRORS AND WARNINGS -
 
     ''' <summary>
     ''' /nowarn                 Disable warnings.
     ''' </summary>
     Private m_bNoWarn As Boolean
 
     ''' <summary>
     ''' /warnaserror[+|-]       Treat warnings as errors.
     ''' </summary>
     Private m_bWarnAsError As Boolean
 
     ' - LANGUAGE -
 
     ''' <summary>
     ''' /define
     ''' </summary>
     Private m_lstDefine As New Defines
 
     ''' <summary>
     ''' /imports
     ''' </summary>
     Private m_lstImports As ImportsStatement
 
     ''' <summary>
     ''' /optionexplicit[+|-]    Require explicit declaration of variables.
     ''' </summary>
     Private m_eOptionExplicit As OptionExplicitTypes = OptionExplicitTypes.On
 
     ''' <summary>
     ''' /optionstrict[+|-]      Enforce strict language semantics.
     ''' </summary>
     Private m_eOptionStrict As OptionStrictTypes = OptionStrictTypes.Off
 
     ''' <summary>
     ''' /optioninfer[+|-]       Allow type inference of variables.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_eOptionInfer As OptionInferTypes = OptionInferTypes.Off
 
     ''' <summary>
     ''' /rootnamespace
     ''' </summary>
     Private m_strRootNamespace As String
 
     ''' <summary>
     '''/optioncompare
     '''/optioncompare
     ''' </summary>
     Private m_eOptionCompare As OptionCompareTypes = OptionCompareTypes.Binary
 
     ' - MISCELLANEOUS -
 
     ''' <summary>
     ''' /help                   Display this usage message. (Short form
     ''' </summary>
     Private m_bHelp As Boolean
 
     ''' <summary>
     ''' /nologo                 Do not display compiler copyright banner.
     ''' </summary>
     Private m_bNoLogo As Boolean
 
     ''' <summary>
     ''' /quiet                  Quiet output mode. 
     ''' </summary>
     Private m_bQuiet As Boolean
 
     ''' <summary>
     ''' /verbose                Display verbose messages.
     ''' </summary>
     Private m_bVerbose As Boolean
 
     ''' <summary>
     ''' /noconfig               Disable the automatic inclusion of the vbnc.rsp response file.
     ''' </summary>
     Private m_bNoConfig As Boolean
 
     ''' <summary>
     ''' /trace                  Output trace messages (vbnc extension)
     ''' </summary>
     ''' <remarks></remarks>
     Private m_bTrace As Boolean
 
     ' - ADVANCED -
 
     ''' <summary>
     ''' /baseaddress
     ''' </summary>
     Private m_strBaseAddress As String
 
     ''' <summary>
     ''' /bugreport
     ''' </summary>
     Private m_strBugReport As String
 
     ''' <summary>
     ''' /codepage
     ''' </summary>
     Private m_Encoding As System.Text.Encoding
 
     ''' <summary>
     ''' /delaysign[+|-]         Delay-sign the assembly using only the public portion of the strong name key.
     ''' </summary>
     Private m_bDelaySign As Boolean
 
     ''' <summary>
     ''' /keycontainer
     ''' </summary>
     Private m_strKeyContainer As String
 
     ''' <summary>
     ''' /keyfile
     ''' </summary>
     Private m_strKeyFile As String
 
     ''' <summary>
     ''' /libpath
     ''' </summary>
     Private m_lstLibPath As New Specialized.StringCollection
 
     ''' <summary>
     ''' /main
     ''' </summary>
     Private m_strMain As String
 
     ''' <summary>
     ''' /netcf                  Target the .NET Compact Framework.
     ''' </summary>
     Private m_bNetCF As Boolean
 
     ''' <summary>
     ''' /sdkpath
     ''' </summary>
     Private m_strSDKPath As String
 
     ''' <summary>
     ''' /utf8output[+|-]        Emit compiler output in UTF8 character encoding.
     ''' </summary>
     Private m_bUTF8Output As Boolean
 
     Private m_VBRuntime As String = "Microsoft.VisualBasic.dll"
 
     ''' <summary>
     ''' /vbversion
     ''' </summary>
     ''' <remarks></remarks>
     Private m_VBVersion As VBVersions = VBVersions.V8
     ' - OUTPUT FILE -
 
 
     ReadOnly Property VBVersion() As VBVersions
         Get
             Return m_VBVersion
         End Get
     End Property
 
     ''' <summary>
     ''' /out
     ''' </summary>
     ReadOnly Property Out() As String
         Get
             Return m_strOut
         End Get
     End Property
 
     ''' <summary>
     ''' /target
     ''' /target
     ''' /target
     ''' /target
     ''' </summary>
     ReadOnly Property Target() As Targets
         Get
             Return m_strTarget
         End Get
     End Property
 
     ' - INPUT FILES - 
 
     ''' <summary>
     ''' /addmodule
     ''' </summary>
     ReadOnly Property Modules() As Specialized.StringCollection
         Get
             Return m_lstModules
         End Get
     End Property
 
     ''' <summary>
     ''' /recurse
     ''' </summary>
     ReadOnly Property Recurse() As Specialized.StringCollection
         Get
             Return m_lstRecurse
         End Get
     End Property
 
     ''' <summary>
     ''' /reference
     ''' </summary>
     ReadOnly Property References() As Specialized.StringCollection
         Get
             Return m_lstReferences
         End Get
     End Property
 
     ' - RESOURCES -
 
     ''' <summary>
     ''' /linkresource
     ''' </summary>	
     ReadOnly Property LinkResources() As Resources
         Get
             Return m_lstLinkResources
         End Get
     End Property
 
     ''' <summary>
     ''' /resource
     ''' </summary>
     ReadOnly Property Resources() As Resources
         Get
             Return m_lstResources
         End Get
     End Property
 
     ''' <summary>
     ''' /win32icon
     ''' </summary>
     ReadOnly Property Win32Icon() As String
         Get
             Return m_strWin32Icon
         End Get
     End Property
 
     ''' <summary>
     ''' /win32resource
     ''' </summary>
     ReadOnly Property Win32Resource() As String
         Get
             Return m_strWin32Resource
         End Get
     End Property
 
     ' - CODE GENERATION -
 
     ''' <summary>
     ''' /optimize[+|-]          Enable optimizations.
     ''' </summary>
     ReadOnly Property Optimize() As Boolean
         Get
             Return m_bOptimize
         End Get
     End Property
 
     ''' <summary>
     ''' /removeintchecks[+|-]   Remove integer checks. Default off.
     ''' </summary>
     ReadOnly Property RemoveIntChecks() As Boolean
         Get
             Return m_bRemoveIntChecks
         End Get
     End Property
 
     ''' <summary>
     '''/debug
     '''/debug
     ''' </summary>
     ReadOnly Property DebugInfo() As DebugTypes
         Get
             Return m_eDebugInfo
         End Get
     End Property
 
     ' - ERRORS AND WARNINGS -
 
     ''' <summary>
     ''' /nowarn                 Disable warnings.
     ''' </summary>
     ReadOnly Property NoWarn() As Boolean
         Get
             Return m_bNoLogo
         End Get
     End Property
 
     ''' <summary>
     ''' /warnaserror[+|-]       Treat warnings as errors.
     ''' </summary>
     ReadOnly Property WarnAsError() As Boolean
         Get
             Return m_bWarnAsError
         End Get
     End Property
 
     ' - LANGUAGE -
 
     ''' <summary>
     ''' /define
     ''' </summary>
     ReadOnly Property Define() As Defines
         Get
             Return m_lstDefine
         End Get
     End Property
 
     ''' <summary>
     ''' /imports
     ''' </summary>
     ReadOnly Property [Imports]() As ImportsStatement
         Get
             Return m_lstImports
         End Get
     End Property
 
     ''' <summary>
     ''' /optionexplicit[+|-]    Require explicit declaration of variables.
     ''' </summary>
     ReadOnly Property OptionExplicit() As OptionExplicitTypes
         Get
             Return m_eOptionExplicit
         End Get
     End Property
 
     ''' <summary>
     ''' /optionstrict[+|-]      Enforce strict language semantics.
     ''' </summary>
     ReadOnly Property OptionStrict() As OptionStrictTypes
         Get
             Return m_eOptionStrict
         End Get
     End Property
 
     ''' <summary>
     ''' /rootnamespace
     ''' </summary>
     ReadOnly Property RootNamespace() As String
         Get
             Return m_strRootNamespace
         End Get
     End Property
 
     ''' <summary>
     '''/optioncompare
     '''/optioncompare
     ''' </summary>
     ReadOnly Property OptionCompare() As OptionCompareTypes
         Get
             Return m_eOptionCompare
         End Get
     End Property
 
     ''' <summary>
     ''' /optioninfer[+|-]       Allow type inference of variables.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property OptionInfer As OptionInferTypes
         Get
             Return m_eOptionInfer
         End Get
     End Property
 
     ' - MISCELLANEOUS -
 
     ''' <summary>
     ''' /help                   Display this usage message. (Short form
     ''' </summary>
     ReadOnly Property Help() As Boolean
         Get
             Return m_bHelp
         End Get
     End Property
 
     ''' <summary>
     ''' /nologo                 Do not display compiler copyright banner.
     ''' </summary>
     ReadOnly Property NoLogo() As Boolean
         Get
             Return m_bNoLogo
         End Get
     End Property
 
     ''' <summary>
     ''' /quiet                  Quiet output mode. 
     ''' </summary>
     ReadOnly Property Quiet() As Boolean
         Get
             Return m_bQuiet
         End Get
     End Property
 
     ''' <summary>
     ''' /verbose                Display verbose messages.
     ''' </summary>
     ReadOnly Property Verbose() As Boolean
         Get
             Return m_bVerbose
         End Get
     End Property
 
     ''' <summary>
     ''' /noconfig               Disable the automatic inclusion of the vbnc.rsp response file.
     ''' </summary>
     ReadOnly Property NoConfig() As Boolean
         Get
             Return m_bNoConfig
         End Get
     End Property
 
     ''' <summary>
     ''' /trace                  Output trace messages (vbnc extension)
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Trace As Boolean
         Get
             Return m_bTrace
         End Get
     End Property
 
     ReadOnly Property VBRuntime() As String
         Get
             Return m_VBRuntime
         End Get
     End Property
 
     ' - ADVANCED -
 
     ''' <summary>
     ''' /baseaddress
     ''' </summary>
     ReadOnly Property BaseAddress() As String
         Get
             Return m_strBaseAddress
         End Get
     End Property
 
     ''' <summary>
     ''' /bugreport
     ''' </summary>
     ReadOnly Property BugReport() As String
         Get
             Return m_strBugReport
         End Get
     End Property
 
     ''' <summary>
     ''' /codepage
     ''' </summary>
     ReadOnly Property Encoding() As System.Text.Encoding
         Get
             If m_Encoding Is Nothing Then m_Encoding = System.Text.Encoding.Default
             Return m_Encoding
         End Get
     End Property
 
     ''' <summary>
     ''' /delaysign[+|-]         Delay-sign the assembly using only the public portion of the strong name key.
     ''' </summary>
     ReadOnly Property DelaySign() As Boolean
         Get
             Return m_bDelaySign
         End Get
     End Property
 
     ''' <summary>
     ''' /keycontainer
     ''' </summary>
     ReadOnly Property KeyContainer() As String
         Get
             Return m_strKeyContainer
         End Get
     End Property
 
     ''' <summary>
     ''' /keyfile
     ''' </summary>
     ReadOnly Property KeyFile() As String
         Get
             Return m_strKeyFile
         End Get
     End Property
 
     ''' <summary>
     ''' /libpath
     ''' </summary>
     ReadOnly Property LibPath() As Specialized.StringCollection
         Get
             Return m_lstLibPath
         End Get
     End Property
 
     ''' <summary>
     ''' /main
     ''' </summary>
     ReadOnly Property Main() As String
         Get
             Return m_strMain
         End Get
     End Property
 
     ''' <summary>
     ''' /netcf                  Target the .NET Compact Framework.
     ''' </summary>
     ReadOnly Property NetCF() As Boolean
         Get
             Return m_bNetCF
         End Get
     End Property
 
     ''' <summary>
     ''' /sdkpath
     ''' </summary>
     ReadOnly Property SDKPath() As String
         Get
             Return m_strSDKPath
         End Get
     End Property
 
     ''' <summary>
     ''' /utf8output[+|-]        Emit compiler output in UTF8 character encoding.
     ''' </summary>
     ReadOnly Property UTF8Output() As Boolean
         Get
             Return m_bUTF8Output
         End Get
     End Property
 
     ''' <summary>
     ''' A list of all the response files specified on the command line.
     ''' </summary>
     ReadOnly Property ResponseFiles() As Specialized.StringCollection
         Get
             Return m_lstResponseFiles
         End Get
     End Property
 
 #End Region
 
     ReadOnly Property AllArgumentsAsArray() As String()
         Get
             Dim result(m_lstAllArgs.Count - 1) As String
             m_lstAllArgs.CopyTo(result, 0)
             Return result
         End Get
     End Property
 
     ''' <summary>
     ''' This property returns the files the commandline parser found on the commandline,
     ''' this includes expanded wildcards.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property Files() As CodeFiles
         Get
             Return m_lstFileNames
         End Get
     End Property
 
     ''' <summary>
     ''' Create a new commandline parser!
     ''' </summary>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         m_lstImports = New ImportsStatement(Compiler)
         m_lstImports.Init(New ImportsClauses(m_lstImports))
         m_lstFileNames = New CodeFiles(m_Compiler)
         m_lstResources = New Resources(m_Compiler, False)
         m_lstLinkResources = New Resources(m_Compiler, True)
     End Sub
]]></clone_fragment>
<clone_fragment endline="277" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\CodeFile.vb" hamdist="11" pcid="7439" startline="262"><![CDATA[
 
     ''' <summary>
     ''' Create a new code file with the specified filename.
     ''' </summary>
     ''' <param name="FileName"></param>
     ''' <remarks></remarks>
     Sub New(ByVal FileName As String, ByVal RelativePath As String, ByVal Parent As BaseObject)
         MyBase.New(Parent)
     Private m_ConditionalConstants As New Generic.List(Of ConditionalConstants)
     Private m_ConditionalConstantsLines As New Generic.List(Of UInteger)
 
     Private m_Code As String
 
     Public ReadOnly Property SymbolDocument() As Mono.Cecil.Cil.Document
         Get
             If m_SymbolDocument Is Nothing Then
                 m_SymbolDocument = New Mono.Cecil.Cil.Document(System.IO.Path.Combine(m_RelativePath.Replace("<"c, "["c).Replace(">"c, "]"c), m_FileName.Replace("<"c, "["c).Replace(">"c, "]"c)))
                 m_SymbolDocument.Language = Cil.DocumentLanguage.Basic
                 m_SymbolDocument.LanguageVendor = Cil.DocumentLanguageVendor.Microsoft
                 m_SymbolDocument.Type = Cil.DocumentType.Text
             End If
             Return m_SymbolDocument
         End Get
     End Property
 
     Sub AddConditionalConstants(ByVal Line As UInteger, ByVal Constants As ConditionalConstants)
         m_ConditionalConstants.Add(Constants.Clone)
         m_ConditionalConstantsLines.Add(Line)
     End Sub
 
     Function GetConditionalConstants(ByVal Line As UInteger) As ConditionalConstants
         If m_ConditionalConstantsLines.Count = 0 Then Return Nothing
 
         'If the first #const is after the line, no constants in this file at the line
         If m_ConditionalConstantsLines(0) > Line Then Return Nothing
 
         For i As Integer = 0 To m_ConditionalConstantsLines.Count - 1
             'If the current #const is after the line, the previous one corresponds to the line
             If m_ConditionalConstantsLines(i) > Line Then
                 Return m_ConditionalConstants(i - 1)
             End If
         Next
 
         'If no constants are after the line, the last is the one.
         Return m_ConditionalConstants(m_ConditionalConstants.Count - 1)
     End Function
 
     Private Shared ReadOnly Property UTF8Throw() As System.Text.Encoding
         Get
             ' Use no preamble to let StreamReader use a non-throwing decoder
             ' when UTF-8 byte order mark found.
             If m_UTF8Throw Is Nothing Then m_UTF8Throw = New System.Text.UTF8Encoding(False, True)
             Return m_UTF8Throw
         End Get
     End Property
 
     Property RelativePath() As String
         Get
             Return m_RelativePath
         End Get
         Set(ByVal value As String)
             m_RelativePath = value
         End Set
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return m_Imports.ResolveCode(Info)
     End Function
 
     ReadOnly Property OptionExplicit() As OptionExplicitStatement
         Get
             Return m_OptionExplicit
         End Get
     End Property
 
     ReadOnly Property OptionStrict() As OptionStrictStatement
         Get
             Return m_OptionStrict
         End Get
     End Property
 
     ReadOnly Property OptionCompare() As OptionCompareStatement
         Get
             Return m_OptionCompare
         End Get
     End Property
 
     ReadOnly Property OptionInfer As OptionInferStatement
         Get
             Return m_OptionInfer
         End Get
     End Property
 
     Sub Init(ByVal OptionCompare As OptionCompareStatement, ByVal OptionStrict As OptionStrictStatement, ByVal OptionExplicit As OptionExplicitStatement, ByVal OptionInfer As OptionInferStatement, ByVal [Imports] As ImportsClauses)
         m_OptionCompare = OptionCompare
         m_OptionStrict = OptionStrict
         m_OptionExplicit = OptionExplicit
         m_OptionInfer = OptionInfer
         m_Imports = [Imports]
         Helper.AssertNotNothing(m_Imports)
     End Sub
 
     ''' <summary>
     ''' The state of the Option Explicit flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionExplicitOn() As Boolean
         Get
             If m_OptionExplicit Is Nothing Then
                 Return Compiler.CommandLine.OptionExplicit = CommandLine.OptionExplicitTypes.On
             Else
                 Return m_OptionExplicit.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareBinary() As Boolean
         Get
             If m_OptionCompare Is Nothing Then
                 Return Compiler.CommandLine.OptionCompare = CommandLine.OptionCompareTypes.Binary
             Else
                 Return m_OptionCompare.IsBinary
             End If
         End Get
     End Property
 
     Public Shadows ReadOnly Property IsOptionInferOn As Boolean
         Get
             If m_OptionInfer Is Nothing Then
                 Return Compiler.CommandLine.OptionInfer = CommandLine.OptionInferTypes.On
             Else
                 Return m_OptionInfer.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareText() As Boolean
         Get
             Return Not IsOptionCompareBinary
         End Get
     End Property
 
     ''' <summary>
     ''' The imports clauses this file has.
     ''' </summary>
     ReadOnly Property [Imports]() As ImportsClauses
         Get
             Return m_Imports
         End Get
     End Property
 
     ''' <summary>
     ''' Compare one CodeFile to another based on filename.
     ''' </summary>
     ''' <param name="value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Overrides Function Equals(ByVal value As Object) As Boolean
         Dim file As CodeFile = TryCast(value, CodeFile)
         If file IsNot Nothing Then
             If file Is Me Then
                 Return True
             Else
                 Return Microsoft.VisualBasic.Strings.StrComp(m_FileName, file.FileName, Microsoft.VisualBasic.CompareMethod.Text) = 0
             End If
         Else
             Return False
         End If
     End Function
 
     ''' <summary>
     ''' Create a new code file with the specified filename.
     ''' </summary>
     ''' <param name="FileName"></param>
     ''' <remarks></remarks>
     Sub New(ByVal FileName As String, ByVal RelativePath As String, ByVal Parent As BaseObject)
         MyBase.New(Parent)
         'Try to get the absolute path for all files.
         If FileName Is Nothing OrElse FileName.IndexOfAny(System.IO.Path.GetInvalidFileNameChars()) >= 0 Then
             m_FileName = FileName
         Else
             m_FileName = IO.Path.GetFullPath(FileName)
         End If
         m_RelativePath = RelativePath
     End Sub
]]></clone_fragment>
</clone_group>
<clone_group groupid="367" nfragments="2">
<clone_fragment endline="868" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" hamdist="0" pcid="3161" startline="248"><![CDATA[
 			new char [] {' ', '\t', '\n', '\r'};
 
 		//
 		// returns a full runtime type name from a name which might
 		// be C# specific type name.
 		//
 		private static TypeSpec FindDocumentedType (MemberCore mc, string name, DeclSpace ds, string cref, Report r)
 		{
 			bool is_array = false;
 			string identifier = name;
 			if (name [name.Length - 1] == ']') {
 				string tmp = name.Substring (0, name.Length - 1).Trim (wsChars);
 				if (tmp [tmp.Length - 1] == '[') {
 					identifier = tmp.Substring (0, tmp.Length - 1).Trim (wsChars);
 					is_array = true;
 				}
 			}
 			TypeSpec t = FindDocumentedTypeNonArray (mc, identifier, ds, cref, r);
 			if (t != null && is_array)
 				t = ArrayContainer.MakeType (t);
 			return t;
 		}
 
 		private static TypeSpec FindDocumentedTypeNonArray (MemberCore mc, 
 			string identifier, DeclSpace ds, string cref, Report r)
 		{
 			switch (identifier) {
 			case "int"
 				return TypeManager.int32_type;
 			case "uint"
 				return TypeManager.uint32_type;
 			case "short"
 				return TypeManager.short_type;;
 			case "ushort"
 				return TypeManager.ushort_type;
 			case "long"
 				return TypeManager.int64_type;
 			case "ulong"
 				return TypeManager.uint64_type;;
 			case "float"
 				return TypeManager.float_type;;
 			case "double"
 				return TypeManager.double_type;
 			case "char"
 				return TypeManager.char_type;;
 			case "decimal"
 				return TypeManager.decimal_type;;
 			case "byte"
 				return TypeManager.byte_type;;
 			case "sbyte"
 				return TypeManager.sbyte_type;;
 			case "object"
 				return TypeManager.object_type;;
 			case "bool"
 				return TypeManager.bool_type;;
 			case "string"
 				return TypeManager.string_type;;
 			case "void"
 				return TypeManager.void_type;;
 			}
 			FullNamedExpression e = ds.LookupNamespaceOrType (identifier, 0, mc.Location, false);
 			if (e != null) {
 				if (!(e is TypeExpr))
 					return null;
 				return e.Type;
 			}
 			int index = identifier.LastIndexOf ('.');
 			if (index < 0)
 				return null;
 
 			var nsName = identifier.Substring (0, index);
 			var typeName = identifier.Substring (index + 1);
 			Namespace ns = ds.NamespaceEntry.NS.GetNamespace (nsName, false);
 			ns = ns ?? mc.Module.GlobalRootNamespace.GetNamespace(nsName, false);
 			if (ns != null) {
 				var te = ns.LookupType(mc.Compiler, typeName, 0, true, mc.Location);
 				if(te != null)
 					return te.Type;
 			}
 
 			int warn;
 			TypeSpec parent = FindDocumentedType (mc, identifier.Substring (0, index), ds, cref, r);
 			if (parent == null)
 				return null;
 			// no need to detect warning 419 here
 			var ts = FindDocumentedMember (mc, parent,
 				identifier.Substring (index + 1),
 				null, ds, out warn, cref, false, null, r) as TypeSpec;
 			if (ts != null)
 				return ts;
 			return null;
 		}
 
 		//
 		// Returns a MemberInfo that is referenced in XML documentation
 		// (by "see" or "seealso" elements).
 		//
 		private static MemberSpec FindDocumentedMember (MemberCore mc,
 			TypeSpec type, string member_name, AParametersCollection param_list, 
 			DeclSpace ds, out int warning_type, string cref,
 			bool warn419, string name_for_error, Report r)
 		{
 //			for (; type != null; type = type.DeclaringType) {
 				var mi = FindDocumentedMemberNoNest (
 					mc, type, member_name, param_list, ds,
 					out warning_type, cref, warn419,
 					name_for_error, r);
 				if (mi != null)
 					return mi; // new FoundMember (type, mi);
 //			}
 			warning_type = 0;
 			return null;
 		}
 
 		private static MemberSpec FindDocumentedMemberNoNest (
 			MemberCore mc, TypeSpec type, string member_name,
 			AParametersCollection param_list, DeclSpace ds, out int warning_type, 
 			string cref, bool warn419, string name_for_error, Report Report)
 		{
 			warning_type = 0;
 //			var filter = new MemberFilter (member_name, 0, MemberKind.All, param_list, null);
 			IList<MemberSpec> found = null;
 			while (type != null && found == null) {
 				found = MemberCache.FindMembers (type, member_name, false);
 				type = type.DeclaringType;
 			}
 
 			if (found == null)
 				return null;
 
 			if (warn419 && found.Count > 1) {
 				Report419 (mc, name_for_error, found.ToArray (), Report);
 			}
 
 			return found [0];
 
 /*
 			if (param_list == null) {
 				// search for fields/events etc.
 				mis = TypeManager.MemberLookup (type, null,
 					type, MemberKind.All,
 					BindingRestriction.None,
 					member_name, null);
 				mis = FilterOverridenMembersOut (mis);
 				if (mis == null || mis.Length == 0)
 					return null;
 				if (warn419 && IsAmbiguous (mis))
 					Report419 (mc, name_for_error, mis, Report);
 				return mis [0];
 			}
 
 			MethodSignature msig = new MethodSignature (member_name, null, param_list);
 			mis = FindMethodBase (type, 
 				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
 				msig);
 
 			if (warn419 && mis.Length > 0) {
 				if (IsAmbiguous (mis))
 					Report419 (mc, name_for_error, mis, Report);
 				return mis [0];
 			}
 
 			// search for operators (whose parameters exactly
 			// matches with the list) and possibly report CS1581.
 			string oper = null;
 			string return_type_name = null;
 			if (member_name.StartsWith ("implicit operator ")) {
 				Operator.GetMetadataName (Operator.OpType.Implicit);
 				return_type_name = member_name.Substring (18).Trim (wsChars);
 			}
 			else if (member_name.StartsWith ("explicit operator ")) {
 				oper = Operator.GetMetadataName (Operator.OpType.Explicit);
 				return_type_name = member_name.Substring (18).Trim (wsChars);
 			}
 			else if (member_name.StartsWith ("operator ")) {
 				oper = member_name.Substring (9).Trim (wsChars);
 				switch (oper) {
 				// either unary or binary
 				case "+"
 					oper = param_list.Length == 2 ?
 						Operator.GetMetadataName (Operator.OpType.Addition) 
 						Operator.GetMetadataName (Operator.OpType.UnaryPlus);
 					break;
 				case "-"
 					oper = param_list.Length == 2 ?
 						Operator.GetMetadataName (Operator.OpType.Subtraction) 
 						Operator.GetMetadataName (Operator.OpType.UnaryNegation);
 					break;
 				default
 					oper = Operator.GetMetadataName (oper);
 					if (oper != null)
 						break;
 
 					warning_type = 1584;
 					Report.Warning (1020, 1, mc.Location, "Overloadable {0} operator is expected", param_list.Length == 2 ? "binary" 
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					return null;
 				}
 			}
 			// here we still don't consider return type (to
 			// detect CS1581 or CS1002+CS1584).
 			msig = new MethodSignature (oper, null, param_list);
 
 			mis = FindMethodBase (type, 
 				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
 				msig);
 			if (mis.Length == 0)
 				return null; // CS1574
 			var mi = mis [0];
 			TypeSpec expected = mi is MethodSpec ?
 				((MethodSpec) mi).ReturnType 
 				mi is PropertySpec ?
 				((PropertySpec) mi).PropertyType 
 				null;
 			if (return_type_name != null) {
 				TypeSpec returnType = FindDocumentedType (mc, return_type_name, ds, cref, Report);
 				if (returnType == null || returnType != expected) {
 					warning_type = 1581;
 					Report.Warning (1581, 1, mc.Location, "Invalid return type in XML comment cref attribute `{0}'", cref);
 					return null;
 				}
 			}
 			return mis [0];
 */ 
 		}
 
 		//
 		// Processes "see" or "seealso" elements.
 		// Checks cref attribute.
 		//
 		private static void HandleXrefCommon (MemberCore mc,
 			DeclSpace ds, XmlElement xref, Report Report)
 		{
 			string cref = xref.GetAttribute ("cref").Trim (wsChars);
 			// when, XmlReader, "if (cref == null)"
 			if (!xref.HasAttribute ("cref"))
 				return;
 			if (cref.Length == 0)
 				Report.Warning (1001, 1, mc.Location, "Identifier expected");
 				// ... and continue until CS1584.
 
 			string signature; // "x
 			string name; // method invokation "(...)" are removed
 			string parameters; // method parameter list
 
 			// When it found '?
 			// MS ignores not only its member kind, but also
 			// the entire syntax correctness. Nor it also does
 			// type fullname resolution i.e. "T
 			// as T
 			// T
 			if (cref.Length > 2 && cref [1] == '
 				return;
 			else
 				signature = cref;
 
 			// Also note that without "T
 			// indication fails.
 
 			int parens_pos = signature.IndexOf ('(');
 			int brace_pos = parens_pos >= 0 ? -1 
 				signature.IndexOf ('[');
 			if (parens_pos > 0 && signature [signature.Length - 1] == ')') {
 				name = signature.Substring (0, parens_pos).Trim (wsChars);
 				parameters = signature.Substring (parens_pos + 1, signature.Length - parens_pos - 2).Trim (wsChars);
 			}
 			else if (brace_pos > 0 && signature [signature.Length - 1] == ']') {
 				name = signature.Substring (0, brace_pos).Trim (wsChars);
 				parameters = signature.Substring (brace_pos + 1, signature.Length - brace_pos - 2).Trim (wsChars);
 			}
 			else {
 				name = signature;
 				parameters = null;
 			}
 			Normalize (mc, ref name, Report);
 
 			string identifier = GetBodyIdentifierFromName (name);
 
 			// Check if identifier is valid.
 			// This check is not necessary to mark as error, but
 			// csc specially reports CS1584 for wrong identifiers.
 			string [] name_elems = identifier.Split ('.');
 			for (int i = 0; i < name_elems.Length; i++) {
 				string nameElem = GetBodyIdentifierFromName (name_elems [i]);
 				if (i > 0)
 					Normalize (mc, ref nameElem, Report);
 				if (!Tokenizer.IsValidIdentifier (nameElem)
 					&& nameElem.IndexOf ("operator") < 0) {
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					xref.SetAttribute ("cref", "!
 					return;
 				}
 			}
 
 			// check if parameters are valid
 			AParametersCollection parameter_types;
 			if (parameters == null)
 				parameter_types = null;
 			else if (parameters.Length == 0)
 				parameter_types = ParametersCompiled.EmptyReadOnlyParameters;
 			else {
 				string [] param_list = parameters.Split (',');
 				var plist = new List<TypeSpec> ();
 				for (int i = 0; i < param_list.Length; i++) {
 					string param_type_name = param_list [i].Trim (wsChars);
 					Normalize (mc, ref param_type_name, Report);
 					TypeSpec param_type = FindDocumentedType (mc, param_type_name, ds, cref, Report);
 					if (param_type == null) {
 						Report.Warning (1580, 1, mc.Location, "Invalid type for parameter `{0}' in XML comment cref attribute `{1}'",
 							(i + 1).ToString (), cref);
 						return;
 					}
 					plist.Add (param_type);
 				}
 
 				parameter_types = ParametersCompiled.CreateFullyResolved (plist.ToArray ());
 			}
 
 			TypeSpec type = FindDocumentedType (mc, name, ds, cref, Report);
 			if (type != null
 				// delegate must not be referenced with args
 				&& (!type.IsDelegate
 				|| parameter_types == null)) {
 				string result = GetSignatureForDoc (type)
 					+ (brace_pos < 0 ? String.Empty 
 				xref.SetAttribute ("cref", "T
 				return; // a type
 			}
 
 			int period = name.LastIndexOf ('.');
 			if (period > 0) {
 				string typeName = name.Substring (0, period);
 				string member_name = name.Substring (period + 1);
 				string lookup_name = member_name == "this" ? MemberCache.IndexerNameAlias 
 				Normalize (mc, ref lookup_name, Report);
 				Normalize (mc, ref member_name, Report);
 				type = FindDocumentedType (mc, typeName, ds, cref, Report);
 				int warn_result;
 				if (type != null) {
 					var mi = FindDocumentedMember (mc, type, lookup_name, parameter_types, ds, out warn_result, cref, true, name, Report);
 					if (warn_result > 0)
 						return;
 					if (mi != null) {
 						// we cannot use 'type' directly
 						// to get its name, since mi
 						// could be from DeclaringType
 						// for nested types.
 						xref.SetAttribute ("cref", GetMemberDocHead (mi) + GetSignatureForDoc (mi.DeclaringType) + "." + member_name + GetParametersFormatted (mi));
 						return; // a member of a type
 					}
 				}
 			} else {
 				int warn_result;
 				var mi = FindDocumentedMember (mc, ds.PartialContainer.Definition, name, parameter_types, ds, out warn_result, cref, true, name, Report);
 
 				if (warn_result > 0)
 					return;
 				if (mi != null) {
 					// we cannot use 'type' directly
 					// to get its name, since mi
 					// could be from DeclaringType
 					// for nested types.
 					xref.SetAttribute ("cref", GetMemberDocHead (mi) + GetSignatureForDoc (mi.DeclaringType) + "." + name + GetParametersFormatted (mi));
 					return; // local member name
 				}
 			}
 
 			// It still might be part of namespace name.
 			Namespace ns = ds.NamespaceEntry.NS.GetNamespace (name, false);
 			if (ns != null) {
 				xref.SetAttribute ("cref", "N
 				return; // a namespace
 			}
 			if (mc.Module.GlobalRootNamespace.IsNamespace (name)) {
 				xref.SetAttribute ("cref", "N
 				return; // a namespace
 			}
 
 			Report.Warning (1574, 1, mc.Location, "XML comment on `{0}' has cref attribute `{1}' that could not be resolved",
 				mc.GetSignatureForError (), cref);
 
 			xref.SetAttribute ("cref", "!
 		}
 
 		static string GetParametersFormatted (MemberSpec mi)
 		{
 			var pm = mi as IParametersMember;
 			if (pm == null || pm.Parameters.IsEmpty)
 				return string.Empty;
 
 			AParametersCollection parameters = pm.Parameters;
 /*
 			if (parameters == null || parameters.Count == 0)
 				return String.Empty;
 */
 			StringBuilder sb = new StringBuilder ();
 			sb.Append ('(');
 			for (int i = 0; i < parameters.Count; i++) {
 //				if (is_setter && i + 1 == parameters.Count)
 //					break; // skip "value".
 				if (i > 0)
 					sb.Append (',');
 				TypeSpec t = parameters.Types [i];
 				sb.Append (GetSignatureForDoc (t));
 			}
 			sb.Append (')');
 			return sb.ToString ();
 		}
 
 		static string GetBodyIdentifierFromName (string name)
 		{
 			string identifier = name;
 
 			if (name.Length > 0 && name [name.Length - 1] == ']') {
 				string tmp = name.Substring (0, name.Length - 1).Trim (wsChars);
 				int last = tmp.LastIndexOf ('[');
 				if (last > 0)
 					identifier = tmp.Substring (0, last).Trim (wsChars);
 			}
 
 			return identifier;
 		}
 
 		static void Report419 (MemberCore mc, string member_name, MemberSpec [] mis, Report Report)
 		{
 			Report.Warning (419, 3, mc.Location, 
 				"Ambiguous reference in cref attribute `{0}'. Assuming `{1}' but other overloads including `{2}' have also matched",
 				member_name,
 				TypeManager.GetFullNameSignature (mis [0]),
 				TypeManager.GetFullNameSignature (mis [1]));
 		}
 
 		//
 		// Get a prefix from member type for XML documentation (used
 		// to formalize cref target name).
 		//
 		static string GetMemberDocHead (MemberSpec type)
 		{
 			if (type is FieldSpec)
 				return "F
 			if (type is MethodSpec)
 				return "M
 			if (type is EventSpec)
 				return "E
 			if (type is PropertySpec)
 				return "P
 			if (type is TypeSpec)
 				return "T
 
 			return "!
 		}
 
 		// MethodCore
 
 		//
 		// Returns a string that represents the signature for this 
 		// member which should be used in XML documentation.
 		//
 		public static string GetMethodDocCommentName (MemberCore mc, ParametersCompiled parameters, DeclSpace ds)
 		{
 			IParameterData [] plist = parameters.FixedParameters;
 			string paramSpec = String.Empty;
 			if (plist != null) {
 				StringBuilder psb = new StringBuilder ();
 				int i = 0;
 				foreach (Parameter p in plist) {
 					psb.Append (psb.Length != 0 ? "," 
 					psb.Append (GetSignatureForDoc (parameters.Types [i++]));
 					if ((p.ModFlags & Parameter.Modifier.ISBYREF) != 0)
 						psb.Append ('@');
 				}
 				paramSpec = psb.ToString ();
 			}
 
 			if (paramSpec.Length > 0)
 				paramSpec += ")";
 
 			string name = mc.Name;
 			if (mc is Constructor)
 				name = "#ctor";
 			else if (mc is InterfaceMemberBase) {
 				var imb = (InterfaceMemberBase) mc;
 				name = imb.GetFullName (imb.ShortName);
 			}
 			name = name.Replace ('.', '#');
 
 			if (mc.MemberName.TypeArguments != null && mc.MemberName.TypeArguments.Count > 0)
 				name += "``" + mc.MemberName.CountTypeArguments;
 
 			string suffix = String.Empty;
 			Operator op = mc as Operator;
 			if (op != null) {
 				switch (op.OperatorType) {
 				case Operator.OpType.Implicit
 				case Operator.OpType.Explicit
 					suffix = "~" + GetSignatureForDoc (op.ReturnType);
 					break;
 				}
 			}
 			return String.Concat (mc.DocCommentHeader, ds.Name, ".", name, paramSpec, suffix);
 		}
 
 		static string GetSignatureForDoc (TypeSpec type)
 		{
 			var tp = type as TypeParameterSpec;
 			if (tp != null) {
 				int c = 0;
 				type = type.DeclaringType;
 				while (type != null && type.DeclaringType != null) {
 					type = type.DeclaringType;
 					c += type.MemberDefinition.TypeParametersCount;
 				}
 				var prefix = tp.IsMethodOwned ? "``" 
 				return prefix + (c + tp.DeclaredPosition);
 			}
 
 			var pp = type as PointerContainer;
 			if (pp != null)
 				return GetSignatureForDoc (pp.Element) + "*";
 
 			ArrayContainer ap = type as ArrayContainer;
 			if (ap != null)
 				return GetSignatureForDoc (ap.Element) +
 					ArrayContainer.GetPostfixSignature (ap.Rank);
 
 			if (TypeManager.IsGenericType (type)) {
 				string g = type.MemberDefinition.Namespace;
 				if (g != null && g.Length > 0)
 					g += '.';
 				int idx = type.Name.LastIndexOf ('`');
 				g += (idx < 0 ? type.Name 
 				int argpos = 0;
 				foreach (TypeSpec t in TypeManager.GetTypeArguments (type))
 					g += (argpos++ > 0 ? "," 
 				g += '}';
 				return g;
 			}
 
 			string name = type.GetMetaInfo ().FullName != null ? type.GetMetaInfo ().FullName 
 			return name.Replace ("+", ".").Replace ('&', '@');
 		}
 
 		//
 		// Raised (and passed an XmlElement that contains the comment)
 		// when GenerateDocComment is writing documentation expectedly.
 		//
 		// FIXME
 		// that means removal of DOM use.
 		//
 		internal static void OnMethodGenerateDocComment (
 			MethodCore mc, XmlElement el, Report Report)
 		{
 			var paramTags = new Dictionary<string, string> ();
 			foreach (XmlElement pelem in el.SelectNodes ("param")) {
 				string xname = pelem.GetAttribute ("name");
 				if (xname.Length == 0)
 					continue; // really? but MS looks doing so
 				if (xname != "" && mc.ParameterInfo.GetParameterIndexByName (xname) < 0)
 					Report.Warning (1572, 2, mc.Location, "XML comment on `{0}' has a param tag for `{1}', but there is no parameter by that name",
 						mc.GetSignatureForError (), xname);
 				else if (paramTags.ContainsKey (xname))
 					Report.Warning (1571, 2, mc.Location, "XML comment on `{0}' has a duplicate param tag for `{1}'",
 						mc.GetSignatureForError (), xname);
 				paramTags [xname] = xname;
 			}
 			IParameterData [] plist = mc.ParameterInfo.FixedParameters;
 			foreach (Parameter p in plist) {
 				if (paramTags.Count > 0 && !paramTags.ContainsKey (p.Name))
 					Report.Warning (1573, 4, mc.Location, "Parameter `{0}' has no matching param tag in the XML comment for `{1}'",
 						p.Name, mc.GetSignatureForError ());
 			}
 		}
 
 		private static void Normalize (MemberCore mc, ref string name, Report Report)
 		{
 			if (name.Length > 0 && name [0] == '@')
 				name = name.Substring (1);
 			else if (name == "this")
 				name = "Item";
 			else if (Tokenizer.IsKeyword (name) && !IsTypeName (name))
 				Report.Warning (1041, 1, mc.Location, "Identifier expected. `{0}' is a keyword", name);
 		}
 
 		private static bool IsTypeName (string name)
 		{
 			switch (name) {
 			case "bool"
 			case "byte"
 			case "char"
 			case "decimal"
 			case "double"
 			case "float"
 			case "int"
 			case "long"
 			case "object"
 			case "sbyte"
 			case "short"
 			case "string"
 			case "uint"
 			case "ulong"
 			case "ushort"
 			case "void"
 				return true;
 			}
 			return false;
 		}
 	}
 
 	//
 	// Implements XML documentation generation.
 	//
 	public class Documentation
 	{
 		public Documentation (string xml_output_filename)
 		{
 			docfilename = xml_output_filename;
 			XmlDocumentation = new XmlDocument ();
 			XmlDocumentation.PreserveWhitespace = false;
 		}
 
 		private string docfilename;
 
 		//
 		// Used to create element which helps well-formedness checking.
 		//
 		public XmlDocument XmlDocumentation;
 
 		//
 		// The output for XML documentation.
 		//
 		public XmlWriter XmlCommentOutput;
 
 		//
 		// Stores XmlDocuments that are included in XML documentation.
 		// Keys are included filenames, values are XmlDocuments.
 		//
 		public Dictionary<string, XmlDocument> StoredDocuments = new Dictionary<string, XmlDocument> ();
 		public Documentation (string xml_output_filename)
 		{
 			docfilename = xml_output_filename;
 			XmlDocumentation = new XmlDocument ();
 			XmlDocumentation.PreserveWhitespace = false;
 		}
]]></clone_fragment>
<clone_fragment endline="632" file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" hamdist="13" pcid="3139" startline="474"><![CDATA[
 
 		//
 		// Processes "see" or "seealso" elements.
 		// Checks cref attribute.
 		//
 		private static void HandleXrefCommon (MemberCore mc,
 			DeclSpace ds, XmlElement xref, Report Report)
 		{
 			string cref = xref.GetAttribute ("cref").Trim (wsChars);
 			// when, XmlReader, "if (cref == null)"
 			if (!xref.HasAttribute ("cref"))
 				return;
 			if (cref.Length == 0)
 				Report.Warning (1001, 1, mc.Location, "Identifier expected");
 				// ... and continue until CS1584.
 
 			string signature; // "x
 			string name; // method invokation "(...)" are removed
 			string parameters; // method parameter list
 
 			// When it found '?
 			// MS ignores not only its member kind, but also
 			// the entire syntax correctness. Nor it also does
 			// type fullname resolution i.e. "T
 			// as T
 			// T
 			if (cref.Length > 2 && cref [1] == '
 				return;
 			else
 				signature = cref;
 
 			// Also note that without "T
 			// indication fails.
 
 			int parens_pos = signature.IndexOf ('(');
 			int brace_pos = parens_pos >= 0 ? -1 
 				signature.IndexOf ('[');
 			if (parens_pos > 0 && signature [signature.Length - 1] == ')') {
 				name = signature.Substring (0, parens_pos).Trim (wsChars);
 				parameters = signature.Substring (parens_pos + 1, signature.Length - parens_pos - 2).Trim (wsChars);
 			}
 			else if (brace_pos > 0 && signature [signature.Length - 1] == ']') {
 				name = signature.Substring (0, brace_pos).Trim (wsChars);
 				parameters = signature.Substring (brace_pos + 1, signature.Length - brace_pos - 2).Trim (wsChars);
 			}
 			else {
 				name = signature;
 				parameters = null;
 			}
 			Normalize (mc, ref name, Report);
 
 			string identifier = GetBodyIdentifierFromName (name);
 
 			// Check if identifier is valid.
 			// This check is not necessary to mark as error, but
 			// csc specially reports CS1584 for wrong identifiers.
 			string [] name_elems = identifier.Split ('.');
 			for (int i = 0; i < name_elems.Length; i++) {
 				string nameElem = GetBodyIdentifierFromName (name_elems [i]);
 				if (i > 0)
 					Normalize (mc, ref nameElem, Report);
 				if (!Tokenizer.IsValidIdentifier (nameElem)
 					&& nameElem.IndexOf ("operator") < 0) {
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					xref.SetAttribute ("cref", "!
 					return;
 				}
 			}
 			for (int i = 0; i < name_elems.Length; i++) {
 				string nameElem = GetBodyIdentifierFromName (name_elems [i]);
 				if (i > 0)
 					Normalize (mc, ref nameElem, Report);
 				if (!Tokenizer.IsValidIdentifier (nameElem)
 					&& nameElem.IndexOf ("operator") < 0) {
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					xref.SetAttribute ("cref", "!
 					return;
 				}
 			}
 
 			// check if parameters are valid
 			AParametersCollection parameter_types;
 			if (parameters == null)
 				parameter_types = null;
 			else if (parameters.Length == 0)
 				parameter_types = ParametersCompiled.EmptyReadOnlyParameters;
 			else {
 				string [] param_list = parameters.Split (',');
 				var plist = new List<TypeSpec> ();
 				for (int i = 0; i < param_list.Length; i++) {
 					string param_type_name = param_list [i].Trim (wsChars);
 					Normalize (mc, ref param_type_name, Report);
 					TypeSpec param_type = FindDocumentedType (mc, param_type_name, ds, cref, Report);
 					if (param_type == null) {
 						Report.Warning (1580, 1, mc.Location, "Invalid type for parameter `{0}' in XML comment cref attribute `{1}'",
 							(i + 1).ToString (), cref);
 						return;
 					}
 					plist.Add (param_type);
 				}
 				for (int i = 0; i < param_list.Length; i++) {
 					string param_type_name = param_list [i].Trim (wsChars);
 					Normalize (mc, ref param_type_name, Report);
 					TypeSpec param_type = FindDocumentedType (mc, param_type_name, ds, cref, Report);
 					if (param_type == null) {
 						Report.Warning (1580, 1, mc.Location, "Invalid type for parameter `{0}' in XML comment cref attribute `{1}'",
 							(i + 1).ToString (), cref);
 						return;
 					}
 					plist.Add (param_type);
 				}
 
 				parameter_types = ParametersCompiled.CreateFullyResolved (plist.ToArray ());
 			}
 
 			TypeSpec type = FindDocumentedType (mc, name, ds, cref, Report);
 			if (type != null
 				// delegate must not be referenced with args
 				&& (!type.IsDelegate
 				|| parameter_types == null)) {
 				string result = GetSignatureForDoc (type)
 					+ (brace_pos < 0 ? String.Empty 
 				xref.SetAttribute ("cref", "T
 				return; // a type
 			}
 
 			int period = name.LastIndexOf ('.');
 			if (period > 0) {
 				string typeName = name.Substring (0, period);
 				string member_name = name.Substring (period + 1);
 				string lookup_name = member_name == "this" ? MemberCache.IndexerNameAlias 
 				Normalize (mc, ref lookup_name, Report);
 				Normalize (mc, ref member_name, Report);
 				type = FindDocumentedType (mc, typeName, ds, cref, Report);
 				int warn_result;
 				if (type != null) {
 					var mi = FindDocumentedMember (mc, type, lookup_name, parameter_types, ds, out warn_result, cref, true, name, Report);
 					if (warn_result > 0)
 						return;
 					if (mi != null) {
 						// we cannot use 'type' directly
 						// to get its name, since mi
 						// could be from DeclaringType
 						// for nested types.
 						xref.SetAttribute ("cref", GetMemberDocHead (mi) + GetSignatureForDoc (mi.DeclaringType) + "." + member_name + GetParametersFormatted (mi));
 						return; // a member of a type
 					}
 				}
 			} else {
 				int warn_result;
 				var mi = FindDocumentedMember (mc, ds.PartialContainer.Definition, name, parameter_types, ds, out warn_result, cref, true, name, Report);
 
 				if (warn_result > 0)
 					return;
 				if (mi != null) {
 					// we cannot use 'type' directly
 					// to get its name, since mi
 					// could be from DeclaringType
 					// for nested types.
 					xref.SetAttribute ("cref", GetMemberDocHead (mi) + GetSignatureForDoc (mi.DeclaringType) + "." + name + GetParametersFormatted (mi));
 					return; // local member name
 				}
 			}
 
 			// It still might be part of namespace name.
 			Namespace ns = ds.NamespaceEntry.NS.GetNamespace (name, false);
 			if (ns != null) {
 				xref.SetAttribute ("cref", "N
 				return; // a namespace
 			}
 			if (mc.Module.GlobalRootNamespace.IsNamespace (name)) {
 				xref.SetAttribute ("cref", "N
 				return; // a namespace
 			}
 
 			Report.Warning (1574, 1, mc.Location, "XML comment on `{0}' has cref attribute `{1}' that could not be resolved",
 				mc.GetSignatureForError (), cref);
 
 			xref.SetAttribute ("cref", "!
 		}
]]></clone_fragment>
</clone_group>
<clone_group groupid="368" nfragments="2">
<clone_fragment endline="88" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" hamdist="0" pcid="7273" startline="71"><![CDATA[
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject, ByVal Location As Span)
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     Public Initialized As Boolean
     Public Overridable Sub Initialize(ByVal Parent As BaseObject)
         If Parent Is Nothing Then Throw New InternalException(Me.Location.AsString(Compiler))
         If Initialized Then
             'Throw New InternalException(Me.Location.AsString(Compiler))
         End If
         m_Parent = Parent
         Initialized = True
     End Sub
 
     Public Shared Sub ClearCache()
         m_compiler = Nothing
     End Sub
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
         Set(ByVal value As Span)
             m_Location = value
         End Set
     End Property
 
     ReadOnly Property File() As CodeFile
         Get
             Return Location.File(Compiler)
         End Get
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
     End Property
 
     Friend Function FindTypeParent() As TypeDeclaration
         Return Me.FindFirstParent(Of TypeDeclaration)()
     End Function
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
 
     ''' <summary>
     ''' The parent of this type. Is nothing if this type is an assembly.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public Property Parent() As BaseObject Implements IBaseObject.Parent
         Get
             Return m_Parent
         End Get
         Set(ByVal value As BaseObject)
             m_Parent = value
             Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         End Set
     End Property
 
     ReadOnly Property ParentAsParsedObject() As ParsedObject
         Get
             Return DirectCast(Me.Parent, ParsedObject)
         End Get
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
     End Property
 
     Friend ReadOnly Property Report() As Report
         Get
             Return Compiler.Report
         End Get
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean Implements IBaseObject.GenerateCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement GenerateCode()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Public ReadOnly Property IsOptionInferOn As Boolean
         Get
             Return Location.File(Compiler).IsOptionInferOn
         End Get
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Private m_ObjectID As Integer = NewID()
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
]]></clone_fragment>
<clone_fragment endline="70" file="C:\Users\faa634\Desktop\mono\mono-basic-2.10\vbnc\vbnc\source\General\BaseObject.vb" hamdist="2" pcid="7271" startline="53"><![CDATA[
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject)
         m_Parent = Parent
         'Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         If m_Parent IsNot Nothing AndAlso tm IsNot Nothing AndAlso tm.IsCurrentTokenValid Then m_Location = tm.CurrentLocation
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject, ByVal Location As Span)
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     Public Initialized As Boolean
     Public Overridable Sub Initialize(ByVal Parent As BaseObject)
         If Parent Is Nothing Then Throw New InternalException(Me.Location.AsString(Compiler))
         If Initialized Then
             'Throw New InternalException(Me.Location.AsString(Compiler))
         End If
         m_Parent = Parent
         Initialized = True
     End Sub
 
     Public Shared Sub ClearCache()
         m_compiler = Nothing
     End Sub
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
         Set(ByVal value As Span)
             m_Location = value
         End Set
     End Property
 
     ReadOnly Property File() As CodeFile
         Get
             Return Location.File(Compiler)
         End Get
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
     End Property
 
     Friend Function FindTypeParent() As TypeDeclaration
         Return Me.FindFirstParent(Of TypeDeclaration)()
     End Function
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
 
     ''' <summary>
     ''' The parent of this type. Is nothing if this type is an assembly.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public Property Parent() As BaseObject Implements IBaseObject.Parent
         Get
             Return m_Parent
         End Get
         Set(ByVal value As BaseObject)
             m_Parent = value
             Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         End Set
     End Property
 
     ReadOnly Property ParentAsParsedObject() As ParsedObject
         Get
             Return DirectCast(Me.Parent, ParsedObject)
         End Get
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
     End Property
 
     Friend ReadOnly Property Report() As Report
         Get
             Return Compiler.Report
         End Get
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean Implements IBaseObject.GenerateCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement GenerateCode()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Public ReadOnly Property IsOptionInferOn As Boolean
         Get
             Return Location.File(Compiler).IsOptionInferOn
         End Get
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Private m_ObjectID As Integer = NewID()
         m_Parent = Parent
         'Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         If m_Parent IsNot Nothing AndAlso tm IsNot Nothing AndAlso tm.IsCurrentTokenValid Then m_Location = tm.CurrentLocation
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
]]></clone_fragment>
</clone_group>
</clones>
