<clones  nfragments="2690" ngroups="28">
<clone_group groupid="0" nfragments="2606" Csharpe_files="2592" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="40" endline="164">
<![CDATA[
 		{
 			// TODO use binary search?
 			for (int i = 0; i < module.FieldMarshal.records.Length; i++)
 			{
 				if (module.FieldMarshal.records[i].Parent == token)
 				{
 					ByteReader blob = module.GetBlob(module.FieldMarshal.records[i].NativeType);
 					UnmanagedType unmanagedType = (UnmanagedType)blob.ReadCompressedInt();
 					UnmanagedType? arraySubType = null;
 					short? sizeParamIndex = null;
 					int? sizeConst = null;
 					VarEnum? safeArraySubType = null;
 					Type safeArrayUserDefinedSubType = null;
 					int? iidParameterIndex = null;
 					string marshalType = null;
 					string marshalCookie = null;
 					Type marshalTypeRef = null;
 					if (unmanagedType == UnmanagedType.LPArray)
 					{
 						arraySubType = (UnmanagedType)blob.ReadCompressedInt();
 						if (arraySubType == NATIVE_TYPE_MAX)
 						{
 							arraySubType = null;
 						}
 						if (blob.Length != 0)
 						{
 							sizeParamIndex = (short)blob.ReadCompressedInt();
 							if (blob.Length != 0)
 							{
 								sizeConst = blob.ReadCompressedInt();
 								if (blob.Length != 0 && blob.ReadCompressedInt() == 0)
 								{
 									sizeParamIndex = null;
 								}
 							}
 						}
 					}
 					else if (unmanagedType == UnmanagedType.SafeArray)
 					{
 						if (blob.Length != 0)
 						{
 							safeArraySubType = (VarEnum)blob.ReadCompressedInt();
 							if (blob.Length != 0)
 							{
 								safeArrayUserDefinedSubType = ReadType(module, blob);
 							}
 						}
 					}
 					else if (unmanagedType == UnmanagedType.ByValArray)
 					{
 						sizeConst = blob.ReadCompressedInt();
 						if (blob.Length != 0)
 						{
 							arraySubType = (UnmanagedType)blob.ReadCompressedInt();
 						}
 					}
 					else if (unmanagedType == UnmanagedType.ByValTStr)
 					{
 						sizeConst = blob.ReadCompressedInt();
 					}
 					else if (unmanagedType == UnmanagedType.Interface
 						|| unmanagedType == UnmanagedType.IDispatch
 						|| unmanagedType == UnmanagedType.IUnknown)
 					{
 						if (blob.Length != 0)
 						{
 							iidParameterIndex = blob.ReadCompressedInt();
 						}
 					}
 					else if (unmanagedType == UnmanagedType.CustomMarshaler)
 					{
 						blob.ReadCompressedInt();
 						blob.ReadCompressedInt();
 						marshalType = ReadString(blob);
 						marshalCookie = ReadString(blob);
 						marshalTypeRef = module.Assembly.GetType(marshalType) ?? module.universe.GetType(marshalType);
 					}
 
 					Type typeofMarshalAs = module.universe.System_Runtime_InteropServices_MarshalAsAttribute;
 					Type typeofUnmanagedType = module.universe.System_Runtime_InteropServices_UnmanagedType;
 					Type typeofVarEnum = module.universe.System_Runtime_InteropServices_VarEnum;
 					Type typeofType = module.universe.System_Type;
 					List<CustomAttributeNamedArgument> named = new List<CustomAttributeNamedArgument>();
 					if (arraySubType != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("ArraySubType"), new CustomAttributeTypedArgument(typeofUnmanagedType, arraySubType.Value)));
 					}
 					if (sizeParamIndex != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SizeParamIndex"), new CustomAttributeTypedArgument(module.universe.System_Int16, sizeParamIndex.Value)));
 					}
 					if (sizeConst != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SizeConst"), new CustomAttributeTypedArgument(module.universe.System_Int32, sizeConst.Value)));
 					}
 					if (safeArraySubType != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SafeArraySubType"), new CustomAttributeTypedArgument(typeofVarEnum, safeArraySubType.Value)));
 					}
 					if (safeArrayUserDefinedSubType != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SafeArrayUserDefinedSubType"), new CustomAttributeTypedArgument(typeofType, safeArrayUserDefinedSubType)));
 					}
 					if (iidParameterIndex != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("IidParameterIndex"), new CustomAttributeTypedArgument(module.universe.System_Int32, iidParameterIndex.Value)));
 					}
 					if (marshalType != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("MarshalType"), new CustomAttributeTypedArgument(module.universe.System_String, marshalType)));
 					}
 					if (marshalTypeRef != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("MarshalTypeRef"), new CustomAttributeTypedArgument(module.universe.System_Type, marshalTypeRef)));
 					}
 					if (marshalCookie != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("MarshalCookie"), new CustomAttributeTypedArgument(module.universe.System_String, marshalCookie)));
 					}
 					ConstructorInfo constructor = typeofMarshalAs.GetConstructor(new Type[] { typeofUnmanagedType });
 					return new CustomAttributeData(constructor, new object[] { unmanagedType }, named);
 				}
 			}
 			for (int i = 0; i < module.FieldMarshal.records.Length; i++)
 			{
 				if (module.FieldMarshal.records[i].Parent == token)
 				{
 					ByteReader blob = module.GetBlob(module.FieldMarshal.records[i].NativeType);
 					UnmanagedType unmanagedType = (UnmanagedType)blob.ReadCompressedInt();
 					UnmanagedType? arraySubType = null;
 					short? sizeParamIndex = null;
 					int? sizeConst = null;
 					VarEnum? safeArraySubType = null;
 					Type safeArrayUserDefinedSubType = null;
 					int? iidParameterIndex = null;
 					string marshalType = null;
 					string marshalCookie = null;
 					Type marshalTypeRef = null;
 					if (unmanagedType == UnmanagedType.LPArray)
 					{
 						arraySubType = (UnmanagedType)blob.ReadCompressedInt();
 						if (arraySubType == NATIVE_TYPE_MAX)
 						{
 							arraySubType = null;
 						}
 						if (blob.Length != 0)
 						{
 							sizeParamIndex = (short)blob.ReadCompressedInt();
 							if (blob.Length != 0)
 							{
 								sizeConst = blob.ReadCompressedInt();
 								if (blob.Length != 0 && blob.ReadCompressedInt() == 0)
 								{
 									sizeParamIndex = null;
 								}
 							}
 						}
 					}
 					else if (unmanagedType == UnmanagedType.SafeArray)
 					{
 						if (blob.Length != 0)
 						{
 							safeArraySubType = (VarEnum)blob.ReadCompressedInt();
 							if (blob.Length != 0)
 							{
 								safeArrayUserDefinedSubType = ReadType(module, blob);
 							}
 						}
 					}
 					else if (unmanagedType == UnmanagedType.ByValArray)
 					{
 						sizeConst = blob.ReadCompressedInt();
 						if (blob.Length != 0)
 						{
 							arraySubType = (UnmanagedType)blob.ReadCompressedInt();
 						}
 					}
 					else if (unmanagedType == UnmanagedType.ByValTStr)
 					{
 						sizeConst = blob.ReadCompressedInt();
 					}
 					else if (unmanagedType == UnmanagedType.Interface
 						|| unmanagedType == UnmanagedType.IDispatch
 						|| unmanagedType == UnmanagedType.IUnknown)
 					{
 						if (blob.Length != 0)
 						{
 							iidParameterIndex = blob.ReadCompressedInt();
 						}
 					}
 					else if (unmanagedType == UnmanagedType.CustomMarshaler)
 					{
 						blob.ReadCompressedInt();
 						blob.ReadCompressedInt();
 						marshalType = ReadString(blob);
 						marshalCookie = ReadString(blob);
 						marshalTypeRef = module.Assembly.GetType(marshalType) ?? module.universe.GetType(marshalType);
 					}
 
 					Type typeofMarshalAs = module.universe.System_Runtime_InteropServices_MarshalAsAttribute;
 					Type typeofUnmanagedType = module.universe.System_Runtime_InteropServices_UnmanagedType;
 					Type typeofVarEnum = module.universe.System_Runtime_InteropServices_VarEnum;
 					Type typeofType = module.universe.System_Type;
 					List<CustomAttributeNamedArgument> named = new List<CustomAttributeNamedArgument>();
 					if (arraySubType != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("ArraySubType"), new CustomAttributeTypedArgument(typeofUnmanagedType, arraySubType.Value)));
 					}
 					if (sizeParamIndex != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SizeParamIndex"), new CustomAttributeTypedArgument(module.universe.System_Int16, sizeParamIndex.Value)));
 					}
 					if (sizeConst != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SizeConst"), new CustomAttributeTypedArgument(module.universe.System_Int32, sizeConst.Value)));
 					}
 					if (safeArraySubType != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SafeArraySubType"), new CustomAttributeTypedArgument(typeofVarEnum, safeArraySubType.Value)));
 					}
 					if (safeArrayUserDefinedSubType != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("SafeArrayUserDefinedSubType"), new CustomAttributeTypedArgument(typeofType, safeArrayUserDefinedSubType)));
 					}
 					if (iidParameterIndex != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("IidParameterIndex"), new CustomAttributeTypedArgument(module.universe.System_Int32, iidParameterIndex.Value)));
 					}
 					if (marshalType != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("MarshalType"), new CustomAttributeTypedArgument(module.universe.System_String, marshalType)));
 					}
 					if (marshalTypeRef != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("MarshalTypeRef"), new CustomAttributeTypedArgument(module.universe.System_Type, marshalTypeRef)));
 					}
 					if (marshalCookie != null)
 					{
 						named.Add(new CustomAttributeNamedArgument(typeofMarshalAs.GetField("MarshalCookie"), new CustomAttributeTypedArgument(module.universe.System_String, marshalCookie)));
 					}
 					ConstructorInfo constructor = typeofMarshalAs.GetConstructor(new Type[] { typeofUnmanagedType });
 					return new CustomAttributeData(constructor, new object[] { unmanagedType }, named);
 				}
 			}
 			throw new BadImageFormatException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2346" endline="2484">
<![CDATA[
 		
 		public override bool Define ()
 		{
 			const Modifiers RequiredModifiers = Modifiers.PUBLIC | Modifiers.STATIC;
 			if ((ModFlags & RequiredModifiers) != RequiredModifiers){
 				Report.Error (558, Location, "User-defined operator `{0}' must be declared static and public", GetSignatureForError ());
 			}
 
 			if (!base.Define ())
 				return false;
 
 			if (block != null && block.IsIterator) {
 				//
 				// Current method is turned into automatically generated
 				// wrapper which creates an instance of iterator
 				//
 				Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 				ModFlags |= Modifiers.DEBUGGER_HIDDEN;
 			}
 
 			// imlicit and explicit operator of same types are not allowed
 			if (OperatorType == OpType.Explicit)
 				Parent.MemberCache.CheckExistingMembersOverloads (this, GetMetadataName (OpType.Implicit), parameters);
 			else if (OperatorType == OpType.Implicit)
 				Parent.MemberCache.CheckExistingMembersOverloads (this, GetMetadataName (OpType.Explicit), parameters);
 
 			TypeSpec declaring_type = Parent.CurrentType;
 			TypeSpec return_type = MemberType;
 			TypeSpec first_arg_type = ParameterTypes [0];
 			
 			TypeSpec first_arg_type_unwrap = first_arg_type;
 			if (TypeManager.IsNullableType (first_arg_type))
 				first_arg_type_unwrap = TypeManager.GetTypeArguments (first_arg_type) [0];
 			
 			TypeSpec return_type_unwrap = return_type;
 			if (TypeManager.IsNullableType (return_type))
 				return_type_unwrap = TypeManager.GetTypeArguments (return_type) [0];
 
 			//
 			// Rules for conversion operators
 			//
 			if (OperatorType == OpType.Implicit || OperatorType == OpType.Explicit) {
 				if (first_arg_type_unwrap == return_type_unwrap && first_arg_type_unwrap == declaring_type) {
 					Report.Error (555, Location,
 						"User-defined operator cannot take an object of the enclosing type and convert to an object of the enclosing type");
 					return false;
 				}
 
 				TypeSpec conv_type;
 				if (declaring_type == return_type || declaring_type == return_type_unwrap) {
 					conv_type = first_arg_type;
 				} else if (declaring_type == first_arg_type || declaring_type == first_arg_type_unwrap) {
 					conv_type = return_type;
 				} else {
 					Report.Error (556, Location,
 						"User-defined conversion must convert to or from the enclosing type");
 					return false;
 				}
 
 				if (conv_type == InternalType.Dynamic) {
 					Report.Error (1964, Location,
 						"User-defined conversion `{0}' cannot convert to or from the dynamic type",
 						GetSignatureForError ());
 
 					return false;
 				}
 
 				if (conv_type.IsInterface) {
 					Report.Error (552, Location, "User-defined conversion `{0}' cannot convert to or from an interface type",
 						GetSignatureForError ());
 					return false;
 				}
 
 				if (conv_type.IsClass) {
 					if (TypeSpec.IsBaseClass (declaring_type, conv_type, true)) {
 						Report.Error (553, Location, "User-defined conversion `{0}' cannot convert to or from a base class",
 							GetSignatureForError ());
 						return false;
 					}
 
 					if (TypeSpec.IsBaseClass (conv_type, declaring_type, false)) {
 						Report.Error (554, Location, "User-defined conversion `{0}' cannot convert to or from a derived class",
 							GetSignatureForError ());
 						return false;
 					}
 				}
 			} else if (OperatorType == OpType.LeftShift || OperatorType == OpType.RightShift) {
 				if (first_arg_type != declaring_type || parameters.Types[1] != TypeManager.int32_type) {
 					Report.Error (564, Location, "Overloaded shift operator must have the type of the first operand be the containing type, and the type of the second operand must be int");
 					return false;
 				}
 			} else if (parameters.Count == 1) {
 				// Checks for Unary operators
 
 				if (OperatorType == OpType.Increment || OperatorType == OpType.Decrement) {
 					if (return_type != declaring_type && !TypeSpec.IsBaseClass (return_type, declaring_type, false)) {
 						Report.Error (448, Location,
 							"The return type for ++ or -- operator must be the containing type or derived from the containing type");
 						return false;
 					}
 					if (first_arg_type != declaring_type) {
 						Report.Error (
 							559, Location, "The parameter type for ++ or -- operator must be the containing type");
 						return false;
 					}
 				}
 
 				if (first_arg_type_unwrap != declaring_type) {
 					Report.Error (562, Location,
 						"The parameter type of a unary operator must be the containing type");
 					return false;
 				}
 
 				if (OperatorType == OpType.True || OperatorType == OpType.False) {
 					if (return_type != TypeManager.bool_type) {
 						Report.Error (
 							215, Location,
 							"The return type of operator True or False " +
 							"must be bool");
 						return false;
 					}
 				}
 
 			} else if (first_arg_type_unwrap != declaring_type) {
 				// Checks for Binary operators
 
 				var second_arg_type = ParameterTypes[1];
 				if (TypeManager.IsNullableType (second_arg_type))
 					second_arg_type = TypeManager.GetTypeArguments (second_arg_type)[0];
 
 				if (second_arg_type != declaring_type) {
 					Report.Error (563, Location,
 						"One of the parameters of a binary operator must be the containing type");
 					return false;
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="327" endline="333">
<![CDATA[
 
 		public Type[] GetTypes()
 		{
 			List<Type> list = new List<Type>();
 			GetTypesImpl(list);
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1610" endline="1621">
<![CDATA[
 
 		public sealed override bool ContainsGenericParameters
 		{
 			get
 			{
 				Type type = elementType;
 				while (type.HasElementType)
 				{
 					type = type.GetElementType();
 				}
 				while (type.HasElementType)
 				{
 					type = type.GetElementType();
 				}
 				return type.ContainsGenericParameters;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="535" endline="543">
<![CDATA[
 
 		public Attribute ResolveAssemblyAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("assembly", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="544" endline="552">
<![CDATA[
 
 		Attribute ResolveModuleAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("module", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="562" endline="571">
<![CDATA[
 
 		public Type[] GetInterfaces()
 		{
 			List<Type> list = new List<Type>();
 			for (Type type = this; type != null; type = type.BaseType)
 			{
 				AddInterfaces(list, type);
 			}
 			for (Type type = this; type != null; type = type.BaseType)
 			{
 				AddInterfaces(list, type);
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2315" endline="2322">
<![CDATA[
 		}
 
 		public new void VerifyClsCompliance ()
 		{
 			foreach (TypeParameter tp in TypeParameters) {
 				tp.VerifyClsCompliance ();
 			}
 			foreach (TypeParameter tp in TypeParameters) {
 				tp.VerifyClsCompliance ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\VersionInfo.cs" startline="218" endline="226">
<![CDATA[
 
 		private static void WriteUTF16Z(ByteBuffer bb, string str)
 		{
 			foreach (char c in str)
 			{
 				bb.Write((short)c);
 			}
 			foreach (char c in str)
 			{
 				bb.Write((short)c);
 			}
 			bb.Write((short)0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1340" endline="1353">
<![CDATA[
 
 		public bool IsSubclassOf(Type type)
 		{
 			Type thisType = this.BaseType;
 			while (thisType != null)
 			{
 				if (thisType.Equals(type))
 				{
 					return true;
 				}
 				thisType = thisType.BaseType;
 			}
 			while (thisType != null)
 			{
 				if (thisType.Equals(type))
 				{
 					return true;
 				}
 				thisType = thisType.BaseType;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="455" endline="461">
<![CDATA[
 
 		protected virtual void EmitHoistedParameters (EmitContext ec, IList<HoistedParameter> hoisted)
 		{
 			foreach (HoistedParameter hp in hoisted) {
 				hp.EmitHoistingAssignment (ec);
 			}
 			foreach (HoistedParameter hp in hoisted) {
 				hp.EmitHoistingAssignment (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="124" endline="132">
<![CDATA[
 
 		public void CheckGenericConstraints (IMemberContext context)
 		{
 			foreach (var c in constraints) {
 				var ge = c as GenericTypeExpr;
 				if (ge != null)
 					ge.CheckConstraints (context);
 			}
 			foreach (var c in constraints) {
 				var ge = c as GenericTypeExpr;
 				if (ge != null)
 					ge.CheckConstraints (context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="550" endline="568">
<![CDATA[
 
 		public Assembly LoadFile(string path)
 		{
 			try
 			{
 				using (RawModule module = OpenRawModule(path))
 				{
 					return LoadAssembly(module);
 				}
 			}
 			catch (IOException x)
 			{
 				throw new FileNotFoundException(x.Message, x);
 			}
 			catch (UnauthorizedAccessException x)
 			{
 				throw new FileNotFoundException(x.Message, x);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1756" endline="1764">
<![CDATA[
 
 		public TypeArguments Clone ()
 		{
 			TypeArguments copy = new TypeArguments ();
 			foreach (var ta in args)
 				copy.args.Add (ta);
 			foreach (var ta in args)
 				copy.args.Add (ta);
 
 			return copy;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="105" endline="114">
<![CDATA[
 
 		public void InitializeBuildinTypes (BuildinTypes buildin, Assembly corlib)
 		{
 			//
 			// Setup mapping for build-in types to avoid duplication of their definition
 			//
 			foreach (var type in buildin.AllTypes) {
 				buildin_types.Add (corlib.GetType (type.FullName), type);
 			}
 			foreach (var type in buildin.AllTypes) {
 				buildin_types.Add (corlib.GetType (type.FullName), type);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="921" endline="932">
<![CDATA[
 
 		//
 		// Fixes full type name of each documented types/members up.
 		//
 		public void GenerateDocComment (Report r)
 		{
 			TypeContainer root = RootContext.ToplevelTypes;
 
 			if (root.Types != null)
 				foreach (TypeContainer tc in root.Types)
 					DocUtil.GenerateTypeDocComment (tc, null, r);
 				foreach (TypeContainer tc in root.Types)
 					DocUtil.GenerateTypeDocComment (tc, null, r);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="585" endline="594">
<![CDATA[
 
 		public static TypeParameter FindTypeParameter (TypeParameter[] tparams, string name)
 		{
 			foreach (var tp in tparams) {
 				if (tp.Name == name)
 					return tp;
 			}
 			foreach (var tp in tparams) {
 				if (tp.Name == name)
 					return tp;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="311" endline="323">
<![CDATA[
 
 		internal Type GetEnumUnderlyingTypeImpl()
 		{
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (!field.IsStatic)
 				{
 					// the CLR assumes that an enum has only one instance field, so we can do the same
 					return field.FieldType;
 				}
 			}
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (!field.IsStatic)
 				{
 					// the CLR assumes that an enum has only one instance field, so we can do the same
 					return field.FieldType;
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="572" endline="584">
<![CDATA[
 
 		private static void AddInterfaces(List<Type> list, Type type)
 		{
 			type.CheckBaked();
 			foreach (Type iface in type.__GetDeclaredInterfaces())
 			{
 				if (!list.Contains(iface))
 				{
 					list.Add(iface);
 					AddInterfaces(list, iface);
 				}
 			}
 			foreach (Type iface in type.__GetDeclaredInterfaces())
 			{
 				if (!list.Contains(iface))
 				{
 					list.Add(iface);
 					AddInterfaces(list, iface);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="720" endline="731">
<![CDATA[
 
 		public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
 		{
 			foreach (ConstructorInfo constructor in GetConstructors(bindingAttr))
 			{
 				if (constructor.MethodSignature.MatchParameterTypes(types))
 				{
 					return constructor;
 				}
 			}
 			foreach (ConstructorInfo constructor in GetConstructors(bindingAttr))
 			{
 				if (constructor.MethodSignature.MatchParameterTypes(types))
 				{
 					return constructor;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="462" endline="473">
<![CDATA[
 
 		public EventInfo GetEvent(string name, BindingFlags bindingAttr)
 		{
 			foreach (EventInfo evt in GetEvents(bindingAttr))
 			{
 				if (evt.Name == name)
 				{
 					return evt;
 				}
 			}
 			foreach (EventInfo evt in GetEvents(bindingAttr))
 			{
 				if (evt.Name == name)
 				{
 					return evt;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="515" endline="526">
<![CDATA[
 
 		public FieldInfo GetField(string name, BindingFlags bindingAttr)
 		{
 			foreach (FieldInfo field in GetFields(bindingAttr))
 			{
 				if (field.Name == name)
 				{
 					return field;
 				}
 			}
 			foreach (FieldInfo field in GetFields(bindingAttr))
 			{
 				if (field.Name == name)
 				{
 					return field;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="743" endline="754">
<![CDATA[
 
 		public virtual Type GetNestedType(string name, BindingFlags bindingAttr)
 		{
 			foreach (Type type in GetNestedTypes(bindingAttr))
 			{
 				if (type.Name == name)
 				{
 					return type;
 				}
 			}
 			foreach (Type type in GetNestedTypes(bindingAttr))
 			{
 				if (type.Name == name)
 				{
 					return type;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="815" endline="826">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, BindingFlags bindingAttr)
 		{
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name)
 				{
 					return prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name)
 				{
 					return prop;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="1189" endline="1200">
<![CDATA[
 
 		public bool IsWarningEnabled (int code, int src_line)
 		{
 			bool result = true;
 			foreach (PragmaCmd pragma in regions) {
 				if (src_line < pragma.Line)
 					break;
 
 				result = pragma.IsEnabled (code, result);
 			}
 			foreach (PragmaCmd pragma in regions) {
 				if (src_line < pragma.Line)
 					break;
 
 				result = pragma.IsEnabled (code, result);
 			}
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="73" endline="86">
<![CDATA[
 		}
 
 		public Type[] GetExportedTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (type.IsVisible)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="56" endline="69">
<![CDATA[
 		}
 
 		public override Type[] __GetDeclaredInterfaces()
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetGenericParameterConstraints())
 			{
 				if (type.IsInterface)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetGenericParameterConstraints())
 			{
 				if (type.IsInterface)
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1354" endline="1367">
<![CDATA[
 
 		// This returns true if this type directly (i.e. not inherited from the base class) implements the interface.
 		// Note that a complicating factor is that the interface itself can be implemented by an interface that extends it.
 		private bool IsDirectlyImplementedInterface(Type interfaceType)
 		{
 			foreach (Type iface in __GetDeclaredInterfaces())
 			{
 				if (interfaceType.IsAssignableFrom(iface))
 				{
 					return true;
 				}
 			}
 			foreach (Type iface in __GetDeclaredInterfaces())
 			{
 				if (interfaceType.IsAssignableFrom(iface))
 				{
 					return true;
 				}
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1574" endline="1587">
<![CDATA[
 
 		protected virtual void DefineContainerMembers (System.Collections.IList mcal) // IList<MemberCore>
 		{
 			if (mcal != null) {
 				for (int i = 0; i < mcal.Count; ++i) {
 					MemberCore mc = (MemberCore) mcal[i];
 					try {
 						mc.Define ();
 					} catch (Exception e) {
 						throw new InternalErrorException (mc, e);
 					}
 				}
 				for (int i = 0; i < mcal.Count; ++i) {
 					MemberCore mc = (MemberCore) mcal[i];
 					try {
 						mc.Define ();
 					} catch (Exception e) {
 						throw new InternalErrorException (mc, e);
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1409" endline="1418">
<![CDATA[
 
 		protected virtual bool DefineNestedTypes ()
 		{
 			if (Types != null) {
 				foreach (TypeContainer tc in Types)
 					tc.DefineType ();
 				foreach (TypeContainer tc in Types)
 					tc.DefineType ();
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="228" endline="239">
<![CDATA[
 
 		internal override void GetTypesImpl(List<Type> list)
 		{
 			PopulateTypeDef();
 			foreach (TypeDefImpl type in typeDefs)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (TypeDefImpl type in typeDefs)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="241" endline="253">
<![CDATA[
 
 		internal static int GetHashCode(Type[][] types)
 		{
 			int h = 0;
 			if (types != null)
 			{
 				foreach (Type[] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 				foreach (Type[] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 			}
 			return h;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="254" endline="266">
<![CDATA[
 
 		internal static int GetHashCode(Type[][][] types)
 		{
 			int h = 0;
 			if (types != null)
 			{
 				foreach (Type[][] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 				foreach (Type[][] array in types)
 				{
 					h ^= GetHashCode(array);
 				}
 			}
 			return h;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="125" endline="139">
<![CDATA[
 		}
 
 		public override Module[] GetLoadedModules(bool getResourceModules)
 		{
 			List<Module> list = new List<Module>();
 			list.Add(manifestModule);
 			foreach (Module m in externalModules)
 			{
 				if (m != null)
 				{
 					list.Add(m);
 				}
 			}
 			foreach (Module m in externalModules)
 			{
 				if (m != null)
 				{
 					list.Add(m);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="925" endline="937">
<![CDATA[
 
 		public Type[] FindInterfaces(TypeFilter filter, object filterCriteria)
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetInterfaces())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetInterfaces())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="334" endline="346">
<![CDATA[
 
 		public Type[] FindTypes(TypeFilter filter, object filterCriteria)
 		{
 			List<Type> list = new List<Type>();
 			foreach (Type type in GetTypes())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in GetTypes())
 			{
 				if (filter(type, filterCriteria))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="446" endline="459">
<![CDATA[
 
 		public void Parse (ModuleContainer module)
 		{
 			Location.Initialize ();
 
 			var cu = Location.SourceFiles;
 			for (int i = 0; i < cu.Count; ++i) {
 				if (RootContext.TokenizeOnly) {
 					tokenize_file (cu [i], ctx);
 				} else {
 					Parse (cu [i], module);
 				}
 			}
 			for (int i = 0; i < cu.Count; ++i) {
 				if (RootContext.TokenizeOnly) {
 					tokenize_file (cu [i], ctx);
 				} else {
 					Parse (cu [i], module);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="760" endline="773">
<![CDATA[
 
 		public Type[] GetNestedTypes(BindingFlags bindingAttr)
 		{
 			CheckBaked();
 			List<Type> list = new List<Type>();
 			foreach (Type type in __GetDeclaredTypes())
 			{
 				if (BindingFlagsMatch(type.IsNestedPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic))
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in __GetDeclaredTypes())
 			{
 				if (BindingFlagsMatch(type.IsNestedPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic))
 				{
 					list.Add(type);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="773" endline="790">
<![CDATA[
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			MethodBase[] methods = new MethodBase[this.methods.Count];
 			for (int i = 0; i < methods.Length; i++)
 			{
 				MethodBuilder mb = this.methods[i];
 				if (mb.IsConstructor)
 				{
 					methods[i] = new ConstructorInfoImpl(mb);
 				}
 				else
 				{
 					methods[i] = mb;
 				}
 			}
 			for (int i = 0; i < methods.Length; i++)
 			{
 				MethodBuilder mb = this.methods[i];
 				if (mb.IsConstructor)
 				{
 					methods[i] = new ConstructorInfoImpl(mb);
 				}
 				else
 				{
 					methods[i] = mb;
 				}
 			}
 			return methods;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1480" endline="1495">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			if (type_params != null) {
 				foreach (TypeParameter tp in type_params) {
 					tp.VerifyClsCompliance ();
 				}
 				foreach (TypeParameter tp in type_params) {
 					tp.VerifyClsCompliance ();
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1473" endline="1484">
<![CDATA[
 
 		internal MethodBase FindMethod(string name, MethodSignature signature)
 		{
 			foreach (MethodBase method in __GetDeclaredMethods())
 			{
 				if (method.Name == name && method.MethodSignature.Equals(signature))
 				{
 					return method;
 				}
 			}
 			foreach (MethodBase method in __GetDeclaredMethods())
 			{
 				if (method.Name == name && method.MethodSignature.Equals(signature))
 				{
 					return method;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1485" endline="1496">
<![CDATA[
 
 		internal FieldInfo FindField(string name, FieldSignature signature)
 		{
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (field.Name == name && field.FieldSignature.Equals(signature))
 				{
 					return field;
 				}
 			}
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (field.Name == name && field.FieldSignature.Equals(signature))
 				{
 					return field;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9356" endline="9367">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			var expr_initializers = new ArrayInitializer (initializers.Count, loc);
 			foreach (Expression e in initializers) {
 				Expression expr = e.CreateExpressionTree (ec);
 				if (expr != null)
 					expr_initializers.Add (expr);
 			}
 			foreach (Expression e in initializers) {
 				Expression expr = e.CreateExpressionTree (ec);
 				if (expr != null)
 					expr_initializers.Add (expr);
 			}
 
 			return new ImplicitlyTypedArrayCreation (expr_initializers, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="643" endline="659">
<![CDATA[
 
 		public MethodInfo GetMethod(string name, BindingFlags bindingAttr)
 		{
 			MethodInfo found = null;
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name)
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name)
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1112" endline="1129">
<![CDATA[
 
 		public void ResolveDefaultValues (MemberCore m)
 		{
 			ResolveContext rc = null;
 			for (int i = 0; i < parameters.Length; ++i) {
 				Parameter p = (Parameter) parameters [i];
 
 				//
 				// Try not to enter default values resolution if there are is not any default value possible
 				//
 				if (p.HasDefaultValue || p.OptAttributes != null) {
 					if (rc == null)
 						rc = new ResolveContext (m);
 
 					p.ResolveDefaultValue (rc);
 				}
 			}
 			for (int i = 0; i < parameters.Length; ++i) {
 				Parameter p = (Parameter) parameters [i];
 
 				//
 				// Try not to enter default values resolution if there are is not any default value possible
 				//
 				if (p.HasDefaultValue || p.OptAttributes != null) {
 					if (rc == null)
 						rc = new ResolveContext (m);
 
 					p.ResolveDefaultValue (rc);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="41" endline="55">
<![CDATA[
 		}
 
 		public sealed override Type BaseType
 		{
 			get
 			{
 				foreach (Type type in GetGenericParameterConstraints())
 				{
 					if (!type.IsInterface && !type.IsGenericParameter)
 					{
 						return type;
 					}
 				}
 				foreach (Type type in GetGenericParameterConstraints())
 				{
 					if (!type.IsInterface && !type.IsGenericParameter)
 					{
 						return type;
 					}
 				}
 				return this.IsValueType ? this.Module.universe.System_ValueType 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="88" endline="102">
<![CDATA[
 
 		public override Type[] GetTypes()
 		{
 			if (externalModules.Length == 0)
 			{
 				return manifestModule.GetTypes();
 			}
 
 			List<Type> list = new List<Type>();
 			foreach (Module module in GetModules(false))
 			{
 				list.AddRange(module.GetTypes());
 			}
 			foreach (Module module in GetModules(false))
 			{
 				list.AddRange(module.GetTypes());
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="280" endline="296">
<![CDATA[
 
 		public override string ToString()
 		{
 			StringBuilder sb = new StringBuilder(this.FullName);
 			string sep = "[";
 			foreach (Type arg in GetGenericArguments())
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			foreach (Type arg in GetGenericArguments())
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			if (sep != "[")
 			{
 				sb.Append(']');
 			}
 			return sb.ToString();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="765" endline="780">
<![CDATA[
 
 		public bool CheckChecksum ()
 		{
 			try {
 				using (FileStream fs = new FileStream (file_name, FileMode.Open)) {
 					MD5 md5 = MD5.Create ();
 					byte[] data = md5.ComputeHash (fs);
 					for (int i = 0; i < 16; i++)
 						if (data [i] != hash [i])
 							return false;
 					for (int i = 0; i < 16; i++)
 						if (data [i] != hash [i])
 							return false;
 					return true;
 				}
 			} catch {
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="505" endline="531">
<![CDATA[
 
 		struct CustomModifiers
 		{
 			internal Type[] required;
 			internal Type[] optional;
 		}
 
 		private static CustomModifiers ReadCustomModifiers(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			CustomModifiers mods = new CustomModifiers();
 			byte b = br.PeekByte();
 			if (IsCustomModifier(b))
 			{
 				List<Type> required = new List<Type>();
 				List<Type> optional = new List<Type>();
 				while (IsCustomModifier(b))
 				{
 					bool req = br.ReadByte() == ELEMENT_TYPE_CMOD_REQD;
 					Type type = ReadTypeDefOrRefEncoded(module, br, context);
 					(req ? required 
 					b = br.PeekByte();
 				}
 				while (IsCustomModifier(b))
 				{
 					bool req = br.ReadByte() == ELEMENT_TYPE_CMOD_REQD;
 					Type type = ReadTypeDefOrRefEncoded(module, br, context);
 					(req ? required 
 					b = br.PeekByte();
 				}
 				mods.required = required.ToArray();
 				mods.optional = optional.ToArray();
 			}
 			return mods;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="215" endline="230">
<![CDATA[
 
 		protected override bool DoDefineMembers ()
 		{
 			if (constants != null) {
 				for (int i = 0; i < constants.Count; ++i) {
 					EnumMember em = (EnumMember) constants [i];
 					if (em.Initializer == null) {
 						em.Initializer = new ImplicitInitializer (em, i == 0 ? null 
 					}
 
 					em.Define ();
 				}
 				for (int i = 0; i < constants.Count; ++i) {
 					EnumMember em = (EnumMember) constants [i];
 					if (em.Initializer == null) {
 						em.Initializer = new ImplicitInitializer (em, i == 0 ? null 
 					}
 
 					em.Define ();
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1332" endline="1351">
<![CDATA[
 		}
 
 		#endregion
 
 		public void ReadAttributes ()
 		{
 			IList<CustomAttributeData> attrs = CustomAttributeData.GetCustomAttributes (module);
 
 			string ns, name;
 			foreach (var a in attrs) {
 				importer.GetCustomAttributeTypeName (a, out ns, out name);
 				if (name == "CLSCompliantAttribute") {
 					if (ns != "System")
 						continue;
 
 					cls_compliant = (bool) a.ConstructorArguments[0].Value;
 					continue;
 				}
 			}
 			foreach (var a in attrs) {
 				importer.GetCustomAttributeTypeName (a, out ns, out name);
 				if (name == "CLSCompliantAttribute") {
 					if (ns != "System")
 						continue;
 
 					cls_compliant = (bool) a.ConstructorArguments[0].Value;
 					continue;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="653" endline="691">
<![CDATA[
 
 		private Assembly DefaultResolver(string refname, bool throwOnError)
 		{
 			Assembly asm = GetDynamicAssembly(refname);
 			if (asm != null)
 			{
 				return asm;
 			}
 			string fileName;
 			if (throwOnError)
 			{
 				try
 				{
 					fileName = System.Reflection.Assembly.ReflectionOnlyLoad(refname).Location;
 				}
 				catch (System.BadImageFormatException x)
 				{
 					throw new BadImageFormatException(x.Message, x);
 				}
 			}
 			else
 			{
 				try
 				{
 					fileName = System.Reflection.Assembly.ReflectionOnlyLoad(refname).Location;
 				}
 				catch (System.BadImageFormatException x)
 				{
 					throw new BadImageFormatException(x.Message, x);
 				}
 				catch (FileNotFoundException)
 				{
 					// we intentionally only swallow the FileNotFoundException, if the file exists but isn't a valid assembly,
 					// we should throw an exception
 					return null;
 				}
 			}
 			return LoadFile(fileName);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="887" endline="903">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType) && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties(bindingAttr))
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType) && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1308" endline="1325">
<![CDATA[
 
 		/// <summary>
 		/// Returns all attributes of type 't'. Use it when attribute is AllowMultiple = true
 		/// </summary>
 		public Attribute[] SearchMulti (PredefinedAttribute t)
 		{
 			List<Attribute> ar = null;
 
 			foreach (Attribute a in Attrs) {
 				if (a.ResolveType () == t) {
 					if (ar == null)
 						ar = new List<Attribute> (Attrs.Count);
 					ar.Add (a);
 				}
 			}
 			foreach (Attribute a in Attrs) {
 				if (a.ResolveType () == t) {
 					if (ar == null)
 						ar = new List<Attribute> (Attrs.Count);
 					ar.Add (a);
 				}
 			}
 
 			return ar == null ? null 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="827" endline="843">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, Type returnType)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && prop.PropertyType.Equals(returnType))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="844" endline="860">
<![CDATA[
 
 		public PropertyInfo GetProperty(string name, Type[] types)
 		{
 			PropertyInfo found = null;
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			foreach (PropertyInfo prop in GetProperties())
 			{
 				if (prop.Name == name && MatchParameterTypes(prop.GetIndexParameters(), types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = prop;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="353" endline="367">
<![CDATA[
 
 		private static FieldInfo GetField(Type type, string name)
 		{
 			for (; type != null; type = type.BaseType)
 			{
 				foreach (FieldInfo field in type.__GetDeclaredFields())
 				{
 					if (field.IsPublic && !field.IsStatic && field.Name == name)
 					{
 						return field;
 					}
 				}
 				foreach (FieldInfo field in type.__GetDeclaredFields())
 				{
 					if (field.IsPublic && !field.IsStatic && field.Name == name)
 					{
 						return field;
 					}
 				}
 			}
 			for (; type != null; type = type.BaseType)
 			{
 				foreach (FieldInfo field in type.__GetDeclaredFields())
 				{
 					if (field.IsPublic && !field.IsStatic && field.Name == name)
 					{
 						return field;
 					}
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="368" endline="382">
<![CDATA[
 
 		private static PropertyInfo GetProperty(Type type, string name)
 		{
 			for (; type != null; type = type.BaseType)
 			{
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (property.IsPublic && !property.IsStatic && property.Name == name)
 					{
 						return property;
 					}
 				}
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (property.IsPublic && !property.IsStatic && property.Name == name)
 					{
 						return property;
 					}
 				}
 			}
 			for (; type != null; type = type.BaseType)
 			{
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (property.IsPublic && !property.IsStatic && property.Name == name)
 					{
 						return property;
 					}
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodInfo.cs" startline="79" endline="96">
<![CDATA[
 		}
 
 		public MethodInfo GetBaseDefinition()
 		{
 			MethodInfo match = this;
 			if (match.IsVirtual)
 			{
 				for (Type type = this.DeclaringType.BaseType; type != null && !match.IsNewSlot; type = type.BaseType)
 				{
 					MethodInfo method = type.FindMethod(this.Name, this.MethodSignature) as MethodInfo;
 					if (method != null && method.IsVirtual)
 					{
 						match = method;
 					}
 				}
 				for (Type type = this.DeclaringType.BaseType; type != null && !match.IsNewSlot; type = type.BaseType)
 				{
 					MethodInfo method = type.FindMethod(this.Name, this.MethodSignature) as MethodInfo;
 					if (method != null && method.IsVirtual)
 					{
 						match = method;
 					}
 				}
 			}
 			return match;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="969" endline="984">
<![CDATA[
 		
 		// Looks-up a alias named @name in this and surrounding namespace declarations
 		public FullNamedExpression LookupNamespaceAlias (string name)
 		{
 			for (NamespaceEntry n = this; n != null; n = n.ImplicitParent) {
 				if (n.using_aliases == null)
 					continue;
 
 				foreach (UsingAliasEntry ue in n.using_aliases) {
 					if (ue.Alias == name)
 						return ue.Resolve (Doppelganger ?? this, Doppelganger == null);
 				}
 				foreach (UsingAliasEntry ue in n.using_aliases) {
 					if (ue.Alias == name)
 						return ue.Resolve (Doppelganger ?? this, Doppelganger == null);
 				}
 			}
 			for (NamespaceEntry n = this; n != null; n = n.ImplicitParent) {
 				if (n.using_aliases == null)
 					continue;
 
 				foreach (UsingAliasEntry ue in n.using_aliases) {
 					if (ue.Alias == name)
 						return ue.Resolve (Doppelganger ?? this, Doppelganger == null);
 				}
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="380" endline="399">
<![CDATA[
 
 		public AnonymousTypeClass GetAnonymousType (IList<AnonymousTypeParameter> parameters)
 		{
 			List<AnonymousTypeClass> candidates;
 			if (!anonymous_types.TryGetValue (parameters.Count, out candidates))
 				return null;
 
 			int i;
 			foreach (AnonymousTypeClass at in candidates) {
 				for (i = 0; i < parameters.Count; ++i) {
 					if (!parameters [i].Equals (at.Parameters [i]))
 						break;
 				}
 				for (i = 0; i < parameters.Count; ++i) {
 					if (!parameters [i].Equals (at.Parameters [i]))
 						break;
 				}
 
 				if (i == parameters.Count)
 					return at;
 			}
 			foreach (AnonymousTypeClass at in candidates) {
 				for (i = 0; i < parameters.Count; ++i) {
 					if (!parameters [i].Equals (at.Parameters [i]))
 						break;
 				}
 
 				if (i == parameters.Count)
 					return at;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="415" endline="443">
<![CDATA[
 
 		//
 		// Optimized default assembly loader version
 		//
 		public override Assembly LoadAssemblyDefault (string assembly)
 		{
 			foreach (var path in paths) {
 				var file = Path.Combine (path, assembly);
 				if (!File.Exists (file))
 					continue;
 
 				try {
 					if (Report.DebugFlags > 0)
 						Console.WriteLine ("Loading default assembly `{0}'", file);
 
 					var a = domain.LoadFile (file);
 					if (a != null) {
 						loaded_names.Add (Tuple.Create (a.GetName (), assembly));
 					}
 
 					return a;
 				} catch {
 					// Default assemblies can fail to load without error
 					return null;
 			foreach (var path in paths) {
 				var file = Path.Combine (path, assembly);
 				if (!File.Exists (file))
 					continue;
 
 				try {
 					if (Report.DebugFlags > 0)
 						Console.WriteLine ("Loading default assembly `{0}'", file);
 
 					var a = domain.LoadFile (file);
 					if (a != null) {
 						loaded_names.Add (Tuple.Create (a.GetName (), assembly));
 					}
 
 					return a;
 				} catch {
 					// Default assemblies can fail to load without error
 					return null;
 				}
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="390" endline="414">
<![CDATA[
 
 		public RawModule LoadModuleFile (string moduleName)
 		{
 			foreach (var path in paths) {
 				var file = Path.Combine (path, moduleName);
 				if (!File.Exists (file)) {
 					if (moduleName.EndsWith (".netmodule", StringComparison.Ordinal))
 						continue;
 
 					file += ".netmodule";
 					if (!File.Exists (file))
 						continue;
 				}
 
 				try {
 					return domain.OpenRawModule (file);
 				} catch {
 					Error_FileCorrupted (file);
 					return null;
 			foreach (var path in paths) {
 				var file = Path.Combine (path, moduleName);
 				if (!File.Exists (file)) {
 					if (moduleName.EndsWith (".netmodule", StringComparison.Ordinal))
 						continue;
 
 					file += ".netmodule";
 					if (!File.Exists (file))
 						continue;
 				}
 
 				try {
 					return domain.OpenRawModule (file);
 				} catch {
 					Error_FileCorrupted (file);
 					return null;
 				}
 			}
 
 			Error_FileNotFound (moduleName);
 			return null;				
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\TypeNameParser.cs" startline="43" endline="66">
<![CDATA[
 		{
 			if (name == null)
 			{
 				return null;
 			}
 			StringBuilder sb = null;
 			for (int pos = 0; pos < name.Length; pos++)
 			{
 				char c = name[pos];
 				if (SpecialChars.IndexOf(c) != -1)
 				{
 					if (sb == null)
 					{
 						sb = new StringBuilder(name, 0, pos, name.Length + 3);
 					}
 					sb.Append('\\').Append(c);
 				}
 				else if (sb != null)
 				{
 					sb.Append(c);
 				}
 			}
 			for (int pos = 0; pos < name.Length; pos++)
 			{
 				char c = name[pos];
 				if (SpecialChars.IndexOf(c) != -1)
 				{
 					if (sb == null)
 					{
 						sb = new StringBuilder(name, 0, pos, name.Length + 3);
 					}
 					sb.Append('\\').Append(c);
 				}
 				else if (sb != null)
 				{
 					sb.Append(c);
 				}
 			}
 			return sb != null ? sb.ToString() 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="948" endline="968">
<![CDATA[
 
 		public IList<string> CompletionGetTypesStartingWith (string prefix)
 		{
 			IEnumerable<string> all = Enumerable.Empty<string> ();
 			
 			for (NamespaceEntry curr_ns = this; curr_ns != null; curr_ns = curr_ns.ImplicitParent){
 				foreach (Namespace using_ns in GetUsingTable ()){
 					if (prefix.StartsWith (using_ns.Name)){
 						int ld = prefix.LastIndexOf ('.');
 						if (ld != -1){
 							string rest = prefix.Substring (ld+1);
 
 							all = all.Concat (using_ns.CompletionGetTypesStartingWith (rest));
 						}
 					}
 					all = all.Concat (using_ns.CompletionGetTypesStartingWith (prefix));
 				}
 				foreach (Namespace using_ns in GetUsingTable ()){
 					if (prefix.StartsWith (using_ns.Name)){
 						int ld = prefix.LastIndexOf ('.');
 						if (ld != -1){
 							string rest = prefix.Substring (ld+1);
 
 							all = all.Concat (using_ns.CompletionGetTypesStartingWith (rest));
 						}
 					}
 					all = all.Concat (using_ns.CompletionGetTypesStartingWith (prefix));
 				}
 			}
 			for (NamespaceEntry curr_ns = this; curr_ns != null; curr_ns = curr_ns.ImplicitParent){
 				foreach (Namespace using_ns in GetUsingTable ()){
 					if (prefix.StartsWith (using_ns.Name)){
 						int ld = prefix.LastIndexOf ('.');
 						if (ld != -1){
 							string rest = prefix.Substring (ld+1);
 
 							all = all.Concat (using_ns.CompletionGetTypesStartingWith (rest));
 						}
 					}
 					all = all.Concat (using_ns.CompletionGetTypesStartingWith (prefix));
 				}
 			}
 
 			return all.Distinct ().ToList ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="319" endline="338">
<![CDATA[
 
 		public bool ImplementsInterface (TypeSpec iface, bool variantly)
 		{
 			var t = this;
 			do {
 				if (t.Interfaces != null) {	// TODO
 					foreach (TypeSpec i in t.Interfaces) {
 						if (i == iface || TypeSpecComparer.IsEqual (i, iface))
 							return true;
 
 						if (variantly && TypeSpecComparer.Variant.IsEqual (i, iface))
 							return true;
 					}
 					foreach (TypeSpec i in t.Interfaces) {
 						if (i == iface || TypeSpecComparer.IsEqual (i, iface))
 							return true;
 
 						if (variantly && TypeSpecComparer.Variant.IsEqual (i, iface))
 							return true;
 					}
 				}
 
 				t = t.BaseType;
 			} while (t != null);
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1944" endline="1973">
<![CDATA[
 
 		public override List<MissingType> ResolveMissingDependencies ()
 		{
 #if STATIC
 			List<MissingType> missing = null;
 
 			MetaType mt = (MetaType) provider;
 			do {
 				if (mt is MissingType) {
 					missing = new List<MissingType> ();
 					missing.Add ((MissingType) mt);
 				}
 
 				foreach (var iface in mt.GetInterfaces ()) {
 					if (iface is MissingType) {
 						if (missing == null)
 							missing = new List<MissingType> ();
 
 						missing.Add ((MissingType) iface);
 					}
 				}
 				foreach (var iface in mt.GetInterfaces ()) {
 					if (iface is MissingType) {
 						if (missing == null)
 							missing = new List<MissingType> ();
 
 						missing.Add ((MissingType) iface);
 					}
 				}
 
 				if (missing != null)
 					return missing;
 
 				mt = mt.BaseType;
 			} while (mt != null);
 #endif
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1077" endline="1095">
<![CDATA[
 
 		public bool IsConvertibleToInterface (TypeSpec iface)
 		{
 			if (Interfaces != null) {
 				foreach (var t in Interfaces) {
 					if (t == iface)
 						return true;
 				}
 				foreach (var t in Interfaces) {
 					if (t == iface)
 						return true;
 				}
 			}
 
 			if (TypeArguments != null) {
 				foreach (var t in TypeArguments) {
 					if (((TypeParameterSpec) t).IsConvertibleToInterface (iface))
 						return true;
 				}
 				foreach (var t in TypeArguments) {
 					if (((TypeParameterSpec) t).IsConvertibleToInterface (iface))
 						return true;
 				}
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="336" endline="354">
<![CDATA[
 
 		public static Arguments CreateForExpressionTree (ResolveContext ec, Arguments args, params Expression[] e)
 		{
 			Arguments all = new Arguments ((args == null ? 0 
 			for (int i = 0; i < e.Length; ++i) {
 				if (e [i] != null)
 					all.Add (new Argument (e[i]));
 			}
 			for (int i = 0; i < e.Length; ++i) {
 				if (e [i] != null)
 					all.Add (new Argument (e[i]));
 			}
 
 			if (args != null) {
 				foreach (Argument a in args.args) {
 					Expression tree_arg = a.CreateExpressionTree (ec);
 					if (tree_arg != null)
 						all.Add (new Argument (tree_arg));
 				}
 				foreach (Argument a in args.args) {
 					Expression tree_arg = a.CreateExpressionTree (ec);
 					if (tree_arg != null)
 						all.Add (new Argument (tree_arg));
 				}
 			}
 
 			return all;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="659" endline="681">
<![CDATA[
 
 		public static IList<MemberSpec> GetCompletitionMembers (TypeSpec container, string name)
 		{
 			var matches = new List<MemberSpec> ();
 			foreach (var entry in container.MemberCache.member_hash) {
 				foreach (var name_entry in entry.Value) {
 					if (name_entry.IsAccessor)
 						continue;
 
 					if ((name_entry.Kind & (MemberKind.Constructor | MemberKind.Destructor | MemberKind.Operator)) != 0)
 						continue;
 
 					if (!name_entry.IsAccessible (InternalType.FakeInternalType))
 						continue;
 
 					if (name == null || name_entry.Name.StartsWith (name)) {
 						matches.Add (name_entry);
 					}
 				}
 				foreach (var name_entry in entry.Value) {
 					if (name_entry.IsAccessor)
 						continue;
 
 					if ((name_entry.Kind & (MemberKind.Constructor | MemberKind.Destructor | MemberKind.Operator)) != 0)
 						continue;
 
 					if (!name_entry.IsAccessible (InternalType.FakeInternalType))
 						continue;
 
 					if (name == null || name_entry.Name.StartsWith (name)) {
 						matches.Add (name_entry);
 					}
 				}
 			}
 			foreach (var entry in container.MemberCache.member_hash) {
 				foreach (var name_entry in entry.Value) {
 					if (name_entry.IsAccessor)
 						continue;
 
 					if ((name_entry.Kind & (MemberKind.Constructor | MemberKind.Destructor | MemberKind.Operator)) != 0)
 						continue;
 
 					if (!name_entry.IsAccessible (InternalType.FakeInternalType))
 						continue;
 
 					if (name == null || name_entry.Name.StartsWith (name)) {
 						matches.Add (name_entry);
 					}
 				}
 			}
 
 			return matches;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="776" endline="793">
<![CDATA[
 
 		public void Dispose()
 		{
 			foreach (Assembly asm in assemblies)
 			{
 				foreach (Module mod in asm.GetLoadedModules())
 				{
 					mod.Dispose();
 				}
 				foreach (Module mod in asm.GetLoadedModules())
 				{
 					mod.Dispose();
 				}
 			}
 			foreach (Assembly asm in assemblies)
 			{
 				foreach (Module mod in asm.GetLoadedModules())
 				{
 					mod.Dispose();
 				}
 			}
 			foreach (AssemblyBuilder asm in dynamicAssemblies)
 			{
 				foreach (Module mod in asm.GetLoadedModules())
 				{
 					mod.Dispose();
 				}
 				foreach (Module mod in asm.GetLoadedModules())
 				{
 					mod.Dispose();
 				}
 			}
 			foreach (AssemblyBuilder asm in dynamicAssemblies)
 			{
 				foreach (Module mod in asm.GetLoadedModules())
 				{
 					mod.Dispose();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="188" endline="215">
<![CDATA[
 
 		public StaticLoader (StaticImporter importer, CompilerContext compiler)
 			
 		{
 			this.importer = importer;
 			domain = new Universe ();
 			domain.AssemblyResolve += AssemblyReferenceResolver;
 			loaded_names = new List<Tuple<AssemblyName, string>> ();
 
 			var corlib_path = Path.GetDirectoryName (typeof (object).Assembly.Location);
 			string fx_path = corlib_path.Substring (0, corlib_path.LastIndexOf (Path.DirectorySeparatorChar));
 			string sdk_path = null;
 
 			foreach (var dir in sdk_directory[RootContext.SdkVersion]) {
 				sdk_path = Path.Combine (fx_path, dir);
 				if (File.Exists (Path.Combine (sdk_path, "mscorlib.dll")))
 					break;
 
 				sdk_path = null;
 			}
 			foreach (var dir in sdk_directory[RootContext.SdkVersion]) {
 				sdk_path = Path.Combine (fx_path, dir);
 				if (File.Exists (Path.Combine (sdk_path, "mscorlib.dll")))
 					break;
 
 				sdk_path = null;
 			}
 
 			if (sdk_path == null) {
 				compiler.Report.Warning (-1, 1, "SDK path could not be resolved");
 				sdk_path = corlib_path;
 			}
 
 			paths.Add (sdk_path);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="388" endline="426">
<![CDATA[
 
 		//
 		// if `dup_args' is true, a copy of the arguments will be left
 		// on the stack and return value will contain an array of access
 		// expressions
 		// NOTE
 		//
 		public virtual Expression[] Emit (EmitContext ec, bool dup_args)
 		{
 			Expression[] temps;
 
 			if (dup_args && Count != 0)
 				temps = new Expression [Count];
 			else
 				temps = null;
 
 			int i = 0;
 			LocalTemporary lt;
 			foreach (Argument a in args) {
 				a.Emit (ec);
 				if (!dup_args)
 					continue;
 
 				if (a.Expr is Constant || a.Expr is This) {
 					//
 					// No need to create a temporary variable for constants
 					//
 					temps[i] = a.Expr;
 				} else {
 					ec.Emit (OpCodes.Dup);
 					temps[i] = lt = new LocalTemporary (a.Type);
 					lt.Store (ec);
 				}
 
 				++i;
 			}
 			foreach (Argument a in args) {
 				a.Emit (ec);
 				if (!dup_args)
 					continue;
 
 				if (a.Expr is Constant || a.Expr is This) {
 					//
 					// No need to create a temporary variable for constants
 					//
 					temps[i] = a.Expr;
 				} else {
 					ec.Emit (OpCodes.Dup);
 					temps[i] = lt = new LocalTemporary (a.Type);
 					lt.Store (ec);
 				}
 
 				++i;
 			}
 
 			return temps;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="362" endline="393">
<![CDATA[
 
 		/// 
 		/// Looks for extension method in this namespace
 		/// 
 		public List<MethodSpec> LookupExtensionMethod (TypeSpec extensionType, TypeContainer invocationContext, string name, int arity)
 		{
 			if (types == null)
 				return null;
 
 			List<MethodSpec> found = null;
 
 			// TODO
 
 			foreach (var tgroup in types.Values) {
 				foreach (var ts in tgroup) {
 					if ((ts.Modifiers & Modifiers.METHOD_EXTENSION) == 0)
 						continue;
 
 					var res = ts.MemberCache.FindExtensionMethods (invocationContext, extensionType, name, arity);
 					if (res == null)
 						continue;
 
 					if (found == null) {
 						found = res;
 					} else {
 						found.AddRange (res);
 					}
 				}
 				foreach (var ts in tgroup) {
 					if ((ts.Modifiers & Modifiers.METHOD_EXTENSION) == 0)
 						continue;
 
 					var res = ts.MemberCache.FindExtensionMethods (invocationContext, extensionType, name, arity);
 					if (res == null)
 						continue;
 
 					if (found == null) {
 						found = res;
 					} else {
 						found.AddRange (res);
 					}
 				}
 			}
 			foreach (var tgroup in types.Values) {
 				foreach (var ts in tgroup) {
 					if ((ts.Modifiers & Modifiers.METHOD_EXTENSION) == 0)
 						continue;
 
 					var res = ts.MemberCache.FindExtensionMethods (invocationContext, extensionType, name, arity);
 					if (res == null)
 						continue;
 
 					if (found == null) {
 						found = res;
 					} else {
 						found.AddRange (res);
 					}
 				}
 			}
 
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="305" endline="335">
<![CDATA[
 
 		TypeSpec LookupType (string name, int arity)
 		{
 			if (types == null)
 				return null;
 
 			IList<TypeSpec> found;
 			if (types.TryGetValue (name, out found)) {
 				TypeSpec best = null;
 
 				foreach (var ts in found) {
 					if (ts.Arity == arity)
 						return ts;
 
 					//
 					// Lookup for the best candidate with closest arity match
 					//
 					if (arity < 0) {
 						if (best == null) {
 							best = ts;
 						} else if (System.Math.Abs (ts.Arity + arity) < System.Math.Abs (best.Arity + arity)) {
 							best = ts;
 						}
 					}
 				}
 				foreach (var ts in found) {
 					if (ts.Arity == arity)
 						return ts;
 
 					//
 					// Lookup for the best candidate with closest arity match
 					//
 					if (arity < 0) {
 						if (best == null) {
 							best = ts;
 						} else if (System.Math.Abs (ts.Arity + arity) < System.Math.Abs (best.Arity + arity)) {
 							best = ts;
 						}
 					}
 				}
 				
 				return best;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="789" endline="823">
<![CDATA[
 
 		/// <summary>
 		///  Finds "most encompassed type" according to the spec (13.4.2)
 		///  amongst the methods in the MethodGroupExpr
 		/// </summary>
 		public static TypeSpec FindMostEncompassedType (IEnumerable<TypeSpec> types)
 		{
 			TypeSpec best = null;
 			EmptyExpression expr = EmptyExpression.Grab ();
 
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (t);
 				if (ImplicitStandardConversionExists (expr, best))
 					best = t;
 			}
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (t);
 				if (ImplicitStandardConversionExists (expr, best))
 					best = t;
 			}
 
 			expr.SetType (best);
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				if (!ImplicitStandardConversionExists (expr, t)) {
 					best = null;
 					break;
 				}
 			}
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				if (!ImplicitStandardConversionExists (expr, t)) {
 					best = null;
 					break;
 				}
 			}
 
 			EmptyExpression.Release (expr);
 
 			return best;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1106" endline="1141">
<![CDATA[
 
 		protected virtual ParametersCompiled ResolveParameters (ResolveContext ec, TypeInferenceContext tic, TypeSpec delegate_type)
 		{
 			var delegate_parameters = Delegate.GetParameters (ec.Compiler, delegate_type);
 
 			if (Parameters == ParametersCompiled.Undefined) {
 				//
 				// We provide a set of inaccessible parameters
 				//
 				Parameter[] fixedpars = new Parameter[delegate_parameters.Count];
 
 				for (int i = 0; i < delegate_parameters.Count; i++) {
 					Parameter.Modifier i_mod = delegate_parameters.FixedParameters [i].ModFlags;
 					if (i_mod == Parameter.Modifier.OUT) {
 						if (!ec.IsInProbingMode) {
 							ec.Report.Error (1688, loc,
 								"Cannot convert anonymous method block without a parameter list to delegate type `{0}' because it has one or more `out' parameters",
 								delegate_type.GetSignatureForError ());
 						}
 
 						return null;
 					}
 					fixedpars[i] = new Parameter (
 						new TypeExpression (delegate_parameters.Types [i], loc), null,
 						delegate_parameters.FixedParameters [i].ModFlags, null, loc);
 				}
 				for (int i = 0; i < delegate_parameters.Count; i++) {
 					Parameter.Modifier i_mod = delegate_parameters.FixedParameters [i].ModFlags;
 					if (i_mod == Parameter.Modifier.OUT) {
 						if (!ec.IsInProbingMode) {
 							ec.Report.Error (1688, loc,
 								"Cannot convert anonymous method block without a parameter list to delegate type `{0}' because it has one or more `out' parameters",
 								delegate_type.GetSignatureForError ());
 						}
 
 						return null;
 					}
 					fixedpars[i] = new Parameter (
 						new TypeExpression (delegate_parameters.Types [i], loc), null,
 						delegate_parameters.FixedParameters [i].ModFlags, null, loc);
 				}
 
 				return ParametersCompiled.CreateFullyResolved (fixedpars, delegate_parameters.Types);
 			}
 
 			if (!VerifyExplicitParameters (ec, delegate_type, delegate_parameters)) {
 				return null;
 			}
 
 			return Parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="159" endline="187">
<![CDATA[
 		}
 
 		public bool CheckDefinitions (ModuleContainer module)
 		{
 			var ctx = module.Compiler;
 			foreach (var p in types) {
 				var found = PredefinedType.Resolve (module, p.Kind, p.Namespace, p.Name, p.Arity, Location.Null);
 				if (found == null || found == p)
 					continue;
 
 				if (!RootContext.StdLib) {
 					var ns = module.GlobalRootNamespace.GetNamespace (p.Namespace, false);
 					ns.ReplaceTypeWithPredefined (found, p);
 
 					var tc = found.MemberDefinition as TypeContainer;
 					tc.SetPredefinedSpec (p);
 					p.SetDefinition (found);
 				}
 			}
 			foreach (var p in types) {
 				var found = PredefinedType.Resolve (module, p.Kind, p.Namespace, p.Name, p.Arity, Location.Null);
 				if (found == null || found == p)
 					continue;
 
 				if (!RootContext.StdLib) {
 					var ns = module.GlobalRootNamespace.GetNamespace (p.Namespace, false);
 					ns.ReplaceTypeWithPredefined (found, p);
 
 					var tc = found.MemberDefinition as TypeContainer;
 					tc.SetPredefinedSpec (p);
 					p.SetDefinition (found);
 				}
 			}
 
 			if (ctx.Report.Errors != 0)
 				return false;
 
 			// Set internal build-in types
 			Dynamic.SetDefinition (Object);
 			Null.SetDefinition (Object);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="824" endline="865">
<![CDATA[
 
 		/// <summary>
 		///  Finds "most encompassing type" according to the spec (13.4.2)
 		///  amongst the types in the given set
 		/// </summary>
 		static TypeSpec FindMostEncompassingType (IList<TypeSpec> types)
 		{
 			TypeSpec best = null;
 
 			if (types.Count == 0)
 				return null;
 
 			if (types.Count == 1)
 				return types [0];
 
 			EmptyExpression expr = EmptyExpression.Grab ();
 
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (best);
 				if (ImplicitStandardConversionExists (expr, t))
 					best = t;
 			}
 			foreach (TypeSpec t in types) {
 				if (best == null) {
 					best = t;
 					continue;
 				}
 
 				expr.SetType (best);
 				if (ImplicitStandardConversionExists (expr, t))
 					best = t;
 			}
 
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				expr.SetType (t);
 				if (!ImplicitStandardConversionExists (expr, best)) {
 					best = null;
 					break;
 				}
 			}
 			foreach (TypeSpec t in types) {
 				if (best == t)
 					continue;
 				expr.SetType (t);
 				if (!ImplicitStandardConversionExists (expr, best)) {
 					best = null;
 					break;
 				}
 			}
 
 			EmptyExpression.Release (expr);
 
 			return best;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="911" endline="959">
<![CDATA[
 
 		/// <summary>
 		///  Finds the most specific target Tx according to section 13.4.4
 		/// </summary>
 		static public TypeSpec FindMostSpecificTarget (IList<MethodSpec> list,
 							   TypeSpec target, bool apply_explicit_conv_rules)
 		{
 			var tgt_types_set = new List<TypeSpec> ();
 
 			//
 			// If any operator converts to T then Tx = T
 			//
 			foreach (var mi in list){
 				TypeSpec ret_type = mi.ReturnType;
 				if (ret_type == target)
 					return ret_type;
 
 				tgt_types_set.Add (ret_type);
 			}
 			foreach (var mi in list){
 				TypeSpec ret_type = mi.ReturnType;
 				if (ret_type == target)
 					return ret_type;
 
 				tgt_types_set.Add (ret_type);
 			}
 
 			//
 			// Explicit conv rules
 			//
 			if (apply_explicit_conv_rules) {
 				var candidate_set = new List<TypeSpec> ();
 
 				EmptyExpression expr = EmptyExpression.Grab ();
 
 				foreach (TypeSpec ret_type in tgt_types_set){
 					expr.SetType (ret_type);
 
 					if (ImplicitStandardConversionExists (expr, target))
 						candidate_set.Add (ret_type);
 				}
 				foreach (TypeSpec ret_type in tgt_types_set){
 					expr.SetType (ret_type);
 
 					if (ImplicitStandardConversionExists (expr, target))
 						candidate_set.Add (ret_type);
 				}
 
 				EmptyExpression.Release (expr);
 
 				if (candidate_set.Count != 0)
 					return FindMostEncompassingType (candidate_set);
 			}
 
 			//
 			// Okay, final case !
 			//
 			if (apply_explicit_conv_rules)
 				return FindMostEncompassedType (tgt_types_set);
 			else
 				return FindMostEncompassingType (tgt_types_set);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="780" endline="910">
<![CDATA[
 
 		/// <summary>
 		/// Creates instance of SecurityAttribute class and add result of CreatePermission method to permission table.
 		/// </summary>
 		/// <returns></returns>
 		public void ExtractSecurityPermissionSet (MethodSpec ctor, ref SecurityType permissions)
 		{
 #if STATIC
 			object[] values = new object [PosArguments.Count];
 			for (int i = 0; i < values.Length; ++i)
 				values [i] = ((Constant) PosArguments [i].Expr).GetValue ();
 			for (int i = 0; i < values.Length; ++i)
 				values [i] = ((Constant) PosArguments [i].Expr).GetValue ();
 
 			PropertyInfo[] prop;
 			object[] prop_values;
 			if (named_values == null) {
 				prop = null;
 				prop_values = null;
 			} else {
 				prop = new PropertyInfo[named_values.Count];
 				prop_values = new object [named_values.Count];
 				for (int i = 0; i < prop.Length; ++i) {
 					prop [i] = ((PropertyExpr) named_values [i].Key).PropertyInfo.MetaInfo;
 					prop_values [i] = ((Constant) named_values [i].Value.Expr).GetValue ();
 				}
 				for (int i = 0; i < prop.Length; ++i) {
 					prop [i] = ((PropertyExpr) named_values [i].Key).PropertyInfo.MetaInfo;
 					prop_values [i] = ((Constant) named_values [i].Value.Expr).GetValue ();
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			var cab = new CustomAttributeBuilder ((ConstructorInfo) ctor.GetMetaInfo (), values, prop, prop_values);
 			permissions.Add (cab);
 #else
 			Type orig_assembly_type = null;
 
 			if (Type.MemberDefinition is TypeContainer) {
 				if (!RootContext.StdLib) {
 					orig_assembly_type = System.Type.GetType (Type.GetMetaInfo ().FullName);
 				} else {
 					string orig_version_path = Environment.GetEnvironmentVariable ("__SECURITY_BOOTSTRAP_DB");
 					if (orig_version_path == null) {
 						Error_AttributeEmitError ("security custom attributes can not be referenced from defining assembly");
 						return;
 					}
 
 					if (orig_sec_assembly == null) {
 						string file = Path.Combine (orig_version_path, Path.GetFileName (RootContext.OutputFile));
 						orig_sec_assembly = Assembly.LoadFile (file);
 					}
 
 					orig_assembly_type = orig_sec_assembly.GetType (Type.GetMetaInfo ().FullName, true);
 					if (orig_assembly_type == null) {
 						Report.Warning (-112, 1, Location, "Self-referenced security attribute `{0}' " +
 								"was not found in previous version of assembly");
 						return;
 					}
 				}
 			}
 
 			SecurityAttribute sa;
 			object[] args;
 
 			// For all non-selfreferencing security attributes we can avoid all hacks
 			if (orig_assembly_type == null) {
 				args = new object[PosArguments.Count];
 				for (int j = 0; j < args.Length; ++j) {
 					args[j] = ((Constant) PosArguments[j].Expr).GetValue ();
 				}
 
 				sa = (SecurityAttribute) Activator.CreateInstance (Type.GetMetaInfo (), args);
 
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						pi.SetValue (sa, ((Constant) named_values [i].Value.Expr).GetValue (), null);
 					}
 				}
 			} else {
 				// HACK
 				args = new object[] { GetSecurityActionValue () };
 				sa = (SecurityAttribute) Activator.CreateInstance (orig_assembly_type, args);
 
 				// All types are from newly created assembly but for invocation with old one we need to convert them
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo emited_pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						// FIXME
 						// TODO
 						PropertyInfo pi = orig_assembly_type.GetProperty (emited_pi.Name);
 
 						pi.SetValue (sa, ((Constant) named_values[i].Value.Expr).GetValue (), null);
 					}
 				}
 			}
 
 			IPermission perm;
 			perm = sa.CreatePermission ();
 			SecurityAction action = (SecurityAction) args [0];
 
 			// IS is correct because for corlib we are using an instance from old corlib
 			if (!(perm is System.Security.CodeAccessPermission)) {
 				switch (action) {
 				case SecurityAction.Demand
 					action = (SecurityAction)13;
 					break;
 				case SecurityAction.LinkDemand
 					action = (SecurityAction)14;
 					break;
 				case SecurityAction.InheritanceDemand
 					action = (SecurityAction)15;
 					break;
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			PermissionSet ps;
 			if (!permissions.TryGetValue (action, out ps)) {
 				if (sa is PermissionSetAttribute)
 					ps = new PermissionSet (sa.Unrestricted ? PermissionState.Unrestricted 
 				else
 					ps = new PermissionSet (PermissionState.None);
 
 				permissions.Add (action, ps);
 			} else if (!ps.IsUnrestricted () && (sa is PermissionSetAttribute) && sa.Unrestricted) {
 				ps = ps.Union (new PermissionSet (PermissionState.Unrestricted));
 				permissions [action] = ps;
 			}
 			ps.AddPermission (perm);
 #endif
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="901" endline="938">
<![CDATA[
 
 		TypeExpr[] GetNormalPartialBases ()
 		{
 			var ifaces = new List<TypeExpr> (0);
 			if (iface_exprs != null)
 				ifaces.AddRange (iface_exprs);
 
 			foreach (TypeContainer part in partial_parts) {
 				TypeExpr new_base_class;
 				TypeExpr[] new_ifaces = part.ResolveBaseTypes (out new_base_class);
 				if (new_base_class != null) {
 					if (base_type_expr != null && new_base_class.Type != base_type) {
 						Report.SymbolRelatedToPreviousError (new_base_class.Location, "");
 						Report.Error (263, part.Location,
 							"Partial declarations of `{0}' must not specify different base classes",
 							part.GetSignatureForError ());
 					} else {
 						base_type_expr = new_base_class;
 						base_type = base_type_expr.Type;
 					}
 				}
 
 				if (new_ifaces == null)
 					continue;
 
 				foreach (TypeExpr iface in new_ifaces) {
 					if (ifaces.Contains (iface))
 						continue;
 
 					ifaces.Add (iface);
 				}
 				foreach (TypeExpr iface in new_ifaces) {
 					if (ifaces.Contains (iface))
 						continue;
 
 					ifaces.Add (iface);
 				}
 			}
 			foreach (TypeContainer part in partial_parts) {
 				TypeExpr new_base_class;
 				TypeExpr[] new_ifaces = part.ResolveBaseTypes (out new_base_class);
 				if (new_base_class != null) {
 					if (base_type_expr != null && new_base_class.Type != base_type) {
 						Report.SymbolRelatedToPreviousError (new_base_class.Location, "");
 						Report.Error (263, part.Location,
 							"Partial declarations of `{0}' must not specify different base classes",
 							part.GetSignatureForError ());
 					} else {
 						base_type_expr = new_base_class;
 						base_type = base_type_expr.Type;
 					}
 				}
 
 				if (new_ifaces == null)
 					continue;
 
 				foreach (TypeExpr iface in new_ifaces) {
 					if (ifaces.Contains (iface))
 						continue;
 
 					ifaces.Add (iface);
 				}
 			}
 
 			if (ifaces.Count == 0)
 				return null;
 
 			return ifaces.ToArray ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="731" endline="770">
<![CDATA[
 
 		//
 		// Extracts the using alises and using clauses into a couple of
 		// arrays that might already have the same information;  Used by the
 		// C# Eval mode.
 		//
 		public void Extract (List<UsingAliasEntry> out_using_aliases, List<UsingEntry> out_using_clauses)
 		{
 			if (using_aliases != null){
 				foreach (UsingAliasEntry uae in using_aliases){
 					bool replaced = false;
 					
 					for (int i = 0; i < out_using_aliases.Count; i++){
 						UsingAliasEntry out_uea = (UsingAliasEntry) out_using_aliases [i];
 						
 						if (out_uea.Alias == uae.Alias){
 							out_using_aliases [i] = uae;
 							replaced = true;
 							break;
 						}
 					}
 					for (int i = 0; i < out_using_aliases.Count; i++){
 						UsingAliasEntry out_uea = (UsingAliasEntry) out_using_aliases [i];
 						
 						if (out_uea.Alias == uae.Alias){
 							out_using_aliases [i] = uae;
 							replaced = true;
 							break;
 						}
 					}
 					if (!replaced)
 						out_using_aliases.Add (uae);
 				}
 				foreach (UsingAliasEntry uae in using_aliases){
 					bool replaced = false;
 					
 					for (int i = 0; i < out_using_aliases.Count; i++){
 						UsingAliasEntry out_uea = (UsingAliasEntry) out_using_aliases [i];
 						
 						if (out_uea.Alias == uae.Alias){
 							out_using_aliases [i] = uae;
 							replaced = true;
 							break;
 						}
 					}
 					if (!replaced)
 						out_using_aliases.Add (uae);
 				}
 			}
 
 			if (using_clauses != null){
 				foreach (UsingEntry ue in using_clauses){
 					bool found = false;
 					
 					foreach (UsingEntry out_ue in out_using_clauses)
 						if (out_ue.Name == ue.Name){
 							found = true;
 							break;
 					foreach (UsingEntry out_ue in out_using_clauses)
 						if (out_ue.Name == ue.Name){
 							found = true;
 							break;
 						}
 					if (!found)
 						out_using_clauses.Add (ue);
 				}
 				foreach (UsingEntry ue in using_clauses){
 					bool found = false;
 					
 					foreach (UsingEntry out_ue in out_using_clauses)
 						if (out_ue.Name == ue.Name){
 							found = true;
 							break;
 						}
 					if (!found)
 						out_using_clauses.Add (ue);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2256" endline="2294">
<![CDATA[
 		}
 
 		/// <summary>
 		///   Define and resolve the type parameters.
 		///   We're called from Method.Define().
 		/// </summary>
 		public bool Define (MethodOrOperator m)
 		{
 			TypeParameterName[] names = MemberName.TypeArguments.GetDeclarations ();
 			string[] snames = new string [names.Length];
 			var block = m.Block;
 			for (int i = 0; i < names.Length; i++) {
 				string type_argument_name = names[i].Name;
 
 				if (block == null) {
 					int idx = parameters.GetParameterIndexByName (type_argument_name);
 					if (idx >= 0) {
 						var b = m.Block;
 						if (b == null)
 							b = new ToplevelBlock (Compiler, Location);
 
 						b.Error_AlreadyDeclaredTypeParameter (type_argument_name, parameters[i].Location);
 					}
 				} else {
 					INamedBlockVariable variable = null;
 					block.GetLocalName (type_argument_name, m.Block, ref variable);
 					if (variable != null)
 						variable.Block.Error_AlreadyDeclaredTypeParameter (type_argument_name, variable.Location);
 				}
 
 				snames[i] = type_argument_name;
 			}
 			for (int i = 0; i < names.Length; i++) {
 				string type_argument_name = names[i].Name;
 
 				if (block == null) {
 					int idx = parameters.GetParameterIndexByName (type_argument_name);
 					if (idx >= 0) {
 						var b = m.Block;
 						if (b == null)
 							b = new ToplevelBlock (Compiler, Location);
 
 						b.Error_AlreadyDeclaredTypeParameter (type_argument_name, parameters[i].Location);
 					}
 				} else {
 					INamedBlockVariable variable = null;
 					block.GetLocalName (type_argument_name, m.Block, ref variable);
 					if (variable != null)
 						variable.Block.Error_AlreadyDeclaredTypeParameter (type_argument_name, variable.Location);
 				}
 
 				snames[i] = type_argument_name;
 			}
 
 			GenericTypeParameterBuilder[] gen_params = m.MethodBuilder.DefineGenericParameters (snames);
 			for (int i = 0; i < TypeParameters.Length; i++)
 				TypeParameters [i].Define (gen_params [i], null);
 			for (int i = 0; i < TypeParameters.Length; i++)
 				TypeParameters [i].Define (gen_params [i], null);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1050" endline="1088">
<![CDATA[
 
 		//
 		// Use this method when you merge compiler generated parameters with user parameters
 		//
 		public static ParametersCompiled MergeGenerated (CompilerContext ctx, ParametersCompiled userParams, bool checkConflicts, Parameter[] compilerParams, TypeSpec[] compilerTypes)
 		{
 			Parameter[] all_params = new Parameter [userParams.Count + compilerParams.Length];
 			userParams.FixedParameters.CopyTo(all_params, 0);
 
 			TypeSpec [] all_types;
 			if (userParams.types != null) {
 				all_types = new TypeSpec [all_params.Length];
 				userParams.Types.CopyTo (all_types, 0);
 			} else {
 				all_types = null;
 			}
 
 			int last_filled = userParams.Count;
 			int index = 0;
 			foreach (Parameter p in compilerParams) {
 				for (int i = 0; i < last_filled; ++i) {
 					while (p.Name == all_params [i].Name) {
 						if (checkConflicts && i < userParams.Count) {
 							ctx.Report.Error (316, userParams[i].Location,
 								"The parameter name `{0}' conflicts with a compiler generated name", p.Name);
 						}
 						p.Name = '_' + p.Name;
 					}
 					while (p.Name == all_params [i].Name) {
 						if (checkConflicts && i < userParams.Count) {
 							ctx.Report.Error (316, userParams[i].Location,
 								"The parameter name `{0}' conflicts with a compiler generated name", p.Name);
 						}
 						p.Name = '_' + p.Name;
 					}
 				}
 				for (int i = 0; i < last_filled; ++i) {
 					while (p.Name == all_params [i].Name) {
 						if (checkConflicts && i < userParams.Count) {
 							ctx.Report.Error (316, userParams[i].Location,
 								"The parameter name `{0}' conflicts with a compiler generated name", p.Name);
 						}
 						p.Name = '_' + p.Name;
 					}
 				}
 				all_params [last_filled] = p;
 				if (all_types != null)
 					all_types [last_filled] = compilerTypes [index++];
 				++last_filled;
 			}
 			foreach (Parameter p in compilerParams) {
 				for (int i = 0; i < last_filled; ++i) {
 					while (p.Name == all_params [i].Name) {
 						if (checkConflicts && i < userParams.Count) {
 							ctx.Report.Error (316, userParams[i].Location,
 								"The parameter name `{0}' conflicts with a compiler generated name", p.Name);
 						}
 						p.Name = '_' + p.Name;
 					}
 				}
 				all_params [last_filled] = p;
 				if (all_types != null)
 					all_types [last_filled] = compilerTypes [index++];
 				++last_filled;
 			}
 			
 			ParametersCompiled parameters = new ParametersCompiled (all_params, all_types);
 			parameters.has_params = userParams.has_params;
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="257" endline="302">
<![CDATA[
 
 		static string [] LoadArgs (string file)
 		{
 			StreamReader f;
 			var args = new List<string> ();
 			string line;
 			try {
 				f = new StreamReader (file);
 			} catch {
 				return null;
 			}
 
 			StringBuilder sb = new StringBuilder ();
 			
 			while ((line = f.ReadLine ()) != null){
 				int t = line.Length;
 
 				for (int i = 0; i < t; i++){
 					char c = line [i];
 					
 					if (c == '"' || c == '\''){
 						char end = c;
 						
 						for (i++; i < t; i++){
 							c = line [i];
 
 							if (c == end)
 								break;
 							sb.Append (c);
 						}
 						for (i++; i < t; i++){
 							c = line [i];
 
 							if (c == end)
 								break;
 							sb.Append (c);
 						}
 					} else if (c == ' '){
 						if (sb.Length > 0){
 							args.Add (sb.ToString ());
 							sb.Length = 0;
 						}
 					} else
 						sb.Append (c);
 				}
 				for (int i = 0; i < t; i++){
 					char c = line [i];
 					
 					if (c == '"' || c == '\''){
 						char end = c;
 						
 						for (i++; i < t; i++){
 							c = line [i];
 
 							if (c == end)
 								break;
 							sb.Append (c);
 						}
 					} else if (c == ' '){
 						if (sb.Length > 0){
 							args.Add (sb.ToString ());
 							sb.Length = 0;
 						}
 					} else
 						sb.Append (c);
 				}
 				if (sb.Length > 0){
 					args.Add (sb.ToString ());
 					sb.Length = 0;
 				}
 			}
 			while ((line = f.ReadLine ()) != null){
 				int t = line.Length;
 
 				for (int i = 0; i < t; i++){
 					char c = line [i];
 					
 					if (c == '"' || c == '\''){
 						char end = c;
 						
 						for (i++; i < t; i++){
 							c = line [i];
 
 							if (c == end)
 								break;
 							sb.Append (c);
 						}
 					} else if (c == ' '){
 						if (sb.Length > 0){
 							args.Add (sb.ToString ());
 							sb.Length = 0;
 						}
 					} else
 						sb.Append (c);
 				}
 				if (sb.Length > 0){
 					args.Add (sb.ToString ());
 					sb.Length = 0;
 				}
 			}
 
 			return args.ToArray ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1360" endline="1397">
<![CDATA[
 		
 		TypeParameter[] initialize_type_params ()
 		{
 			if (type_param_list != null)
 				return type_param_list;
 
 			DeclSpace the_parent = Parent;
 			if (this is GenericMethod)
 				the_parent = null;
 
 			var list = new List<TypeParameter> ();
 			if (the_parent != null && the_parent.IsGeneric) {
 				// FIXME
 				TypeParameter[] parent_params = the_parent.TypeParameters;
 				list.AddRange (parent_params);
 			}
  
 			int count = type_params != null ? type_params.Length 
 			for (int i = 0; i < count; i++) {
 				TypeParameter param = type_params [i];
 				list.Add (param);
 				if (Parent.CurrentTypeParameters != null) {
 					foreach (TypeParameter tp in Parent.CurrentTypeParameters) {
 						if (tp.Name != param.Name)				
 							continue;
 
 						Report.SymbolRelatedToPreviousError (tp.Location, null);
 						Report.Warning (693, 3, param.Location,
 							"Type parameter `{0}' has the same name as the type parameter from outer type `{1}'",
 							param.Name, Parent.GetSignatureForError ());
 					}
 					foreach (TypeParameter tp in Parent.CurrentTypeParameters) {
 						if (tp.Name != param.Name)				
 							continue;
 
 						Report.SymbolRelatedToPreviousError (tp.Location, null);
 						Report.Warning (693, 3, param.Location,
 							"Type parameter `{0}' has the same name as the type parameter from outer type `{1}'",
 							param.Name, Parent.GetSignatureForError ());
 					}
 				}
 			}
 			for (int i = 0; i < count; i++) {
 				TypeParameter param = type_params [i];
 				list.Add (param);
 				if (Parent.CurrentTypeParameters != null) {
 					foreach (TypeParameter tp in Parent.CurrentTypeParameters) {
 						if (tp.Name != param.Name)				
 							continue;
 
 						Report.SymbolRelatedToPreviousError (tp.Location, null);
 						Report.Warning (693, 3, param.Location,
 							"Type parameter `{0}' has the same name as the type parameter from outer type `{1}'",
 							param.Name, Parent.GetSignatureForError ());
 					}
 				}
 			}
 
 			type_param_list = new TypeParameter [list.Count];
 			list.CopyTo (type_param_list, 0);
 			return type_param_list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="394" endline="444">
<![CDATA[
 
 		public void AddType (TypeSpec ts)
 		{
 			if (types == null) {
 				types = new Dictionary<string, IList<TypeSpec>> (64);
 			}
 
 			var name = ts.Name;
 			IList<TypeSpec> existing;
 			if (types.TryGetValue (name, out existing)) {
 				TypeSpec better_type;
 				TypeSpec found;
 				if (existing.Count == 1) {
 					found = existing[0];
 					if (ts.Arity == found.Arity) {
 						better_type = IsImportedTypeOverride (ts, found);
 						if (better_type == found)
 							return;
 
 						if (better_type != null) {
 							existing [0] = better_type;
 							return;
 						}
 					}
 
 					existing = new List<TypeSpec> ();
 					existing.Add (found);
 					types[name] = existing;
 				} else {
 					for (int i = 0; i < existing.Count; ++i) {
 						found = existing[i];
 						if (ts.Arity != found.Arity)
 							continue;
 
 						better_type = IsImportedTypeOverride (ts, found);
 						if (better_type == found)
 							return;
 
 						if (better_type != null) {
 							existing.RemoveAt (i);
 							--i;
 							continue;
 						}
 					}
 					for (int i = 0; i < existing.Count; ++i) {
 						found = existing[i];
 						if (ts.Arity != found.Arity)
 							continue;
 
 						better_type = IsImportedTypeOverride (ts, found);
 						if (better_type == found)
 							return;
 
 						if (better_type != null) {
 							existing.RemoveAt (i);
 							--i;
 							continue;
 						}
 					}
 				}
 
 				existing.Add (ts);
 			} else {
 				types.Add (name, new TypeSpec[] { ts });
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="1095" endline="1145">
<![CDATA[
 
 		protected void LoadReferencesCore (ModuleContainer module, out T corlib_assembly, out List<Tuple<RootNamespace, T>> loaded)
 		{
 			loaded = new List<Tuple<RootNamespace, T>> ();
 
 			//
 			// Load mscorlib.dll as the first
 			//
 			if (RootContext.StdLib) {
 				corlib_assembly = LoadAssemblyDefault ("mscorlib.dll");
 			} else {
 				corlib_assembly = default (T);
 			}
 
 			T a;
 			foreach (string r in default_references) {
 				a = LoadAssemblyDefault (r);
 				if (a != null)
 					loaded.Add (Tuple.Create (module.GlobalRootNamespace, a));
 			}
 			foreach (string r in default_references) {
 				a = LoadAssemblyDefault (r);
 				if (a != null)
 					loaded.Add (Tuple.Create (module.GlobalRootNamespace, a));
 			}
 
 			foreach (string r in RootContext.AssemblyReferences) {
 				a = LoadAssemblyFile (r);
 				if (a == null || EqualityComparer<T>.Default.Equals (a, corlib_assembly))
 					continue;
 
 				var key = Tuple.Create (module.GlobalRootNamespace, a);
 				if (loaded.Contains (key))
 					continue;
 
 				// A corlib assembly is the first assembly which contains System.Object
 				if (corlib_assembly == null && HasObjectType (a)) {
 					corlib_assembly = a;
 					continue;
 				}
 
 				loaded.Add (key);
 			}
 			foreach (string r in RootContext.AssemblyReferences) {
 				a = LoadAssemblyFile (r);
 				if (a == null || EqualityComparer<T>.Default.Equals (a, corlib_assembly))
 					continue;
 
 				var key = Tuple.Create (module.GlobalRootNamespace, a);
 				if (loaded.Contains (key))
 					continue;
 
 				// A corlib assembly is the first assembly which contains System.Object
 				if (corlib_assembly == null && HasObjectType (a)) {
 					corlib_assembly = a;
 					continue;
 				}
 
 				loaded.Add (key);
 			}
 
 			foreach (var entry in RootContext.AssemblyReferencesAliases) {
 				a = LoadAssemblyFile (entry.Item2);
 				if (a == null)
 					continue;
 
 				var key = Tuple.Create (module.CreateRootNamespace (entry.Item1), a);
 				if (loaded.Contains (key))
 					continue;
 
 				loaded.Add (key);
 			}
 			foreach (var entry in RootContext.AssemblyReferencesAliases) {
 				a = LoadAssemblyFile (entry.Item2);
 				if (a == null)
 					continue;
 
 				var key = Tuple.Create (module.CreateRootNamespace (entry.Item1), a);
 				if (loaded.Contains (key))
 					continue;
 
 				loaded.Add (key);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3353" endline="3592">
<![CDATA[
 		
 		// structure used to hold blocks of keys while calculating table switch
 		class KeyBlock 
 		{
 			public KeyBlock (long _first)
 			{
 				first = last = _first;
 			}
 			public long first;
 			public long last;
 			public List<object> element_keys;
 			// how many items are in the bucket
 			public int Size = 1;
 			public int Length
 			{
 				get { return (int) (last - first + 1); }
 			}
 			public static long TotalLength (KeyBlock kb_first, KeyBlock kb_last)
 			{
 				return kb_last.last - kb_first.first + 1;
 			}
 			public int CompareTo (object obj)
 			{
 				KeyBlock kb = (KeyBlock) obj;
 				int nLength = Length;
 				int nLengthOther = kb.Length;
 				if (nLengthOther == nLength)
 					return (int) (kb.first - first);
 				return nLength - nLengthOther;
 			}
 		}
 
 		/// <summary>
 		/// This method emits code for a lookup-based switch statement (non-string)
 		/// Basically it groups the cases into blocks that are at least half full,
 		/// and then spits out individual lookup opcodes for each block.
 		/// It emits the longest blocks first, and short blocks are just
 		/// handled with direct compares.
 		/// </summary>
 		/// <param name="ec"></param>
 		/// <param name="val"></param>
 		/// <returns></returns>
 		void TableSwitchEmit (EmitContext ec, Expression val)
 		{
 			int element_count = Elements.Count;
 			object [] element_keys = new object [element_count];
 			Elements.Keys.CopyTo (element_keys, 0);
 			Array.Sort (element_keys);
 
 			// initialize the block list with one element per key
 			var key_blocks = new List<KeyBlock> (element_count);
 			foreach (object key in element_keys)
 				key_blocks.Add (new KeyBlock (System.Convert.ToInt64 (key)));
 			foreach (object key in element_keys)
 				key_blocks.Add (new KeyBlock (System.Convert.ToInt64 (key)));
 
 			KeyBlock current_kb;
 			// iteratively merge the blocks while they are at least half full
 			// there's probably a really cool way to do this with a tree...
 			while (key_blocks.Count > 1)
 			{
 				var key_blocks_new = new List<KeyBlock> ();
 				current_kb = (KeyBlock) key_blocks [0];
 				for (int ikb = 1; ikb < key_blocks.Count; ikb++)
 				{
 					KeyBlock kb = (KeyBlock) key_blocks [ikb];
 					if ((current_kb.Size + kb.Size) * 2 >=  KeyBlock.TotalLength (current_kb, kb))
 					{
 						// merge blocks
 						current_kb.last = kb.last;
 						current_kb.Size += kb.Size;
 					}
 					else
 					{
 						// start a new block
 						key_blocks_new.Add (current_kb);
 						current_kb = kb;
 					}
 				}
 				for (int ikb = 1; ikb < key_blocks.Count; ikb++)
 				{
 					KeyBlock kb = (KeyBlock) key_blocks [ikb];
 					if ((current_kb.Size + kb.Size) * 2 >=  KeyBlock.TotalLength (current_kb, kb))
 					{
 						// merge blocks
 						current_kb.last = kb.last;
 						current_kb.Size += kb.Size;
 					}
 					else
 					{
 						// start a new block
 						key_blocks_new.Add (current_kb);
 						current_kb = kb;
 					}
 				}
 				key_blocks_new.Add (current_kb);
 				if (key_blocks.Count == key_blocks_new.Count)
 					break;
 				key_blocks = key_blocks_new;
 			}
 			while (key_blocks.Count > 1)
 			{
 				var key_blocks_new = new List<KeyBlock> ();
 				current_kb = (KeyBlock) key_blocks [0];
 				for (int ikb = 1; ikb < key_blocks.Count; ikb++)
 				{
 					KeyBlock kb = (KeyBlock) key_blocks [ikb];
 					if ((current_kb.Size + kb.Size) * 2 >=  KeyBlock.TotalLength (current_kb, kb))
 					{
 						// merge blocks
 						current_kb.last = kb.last;
 						current_kb.Size += kb.Size;
 					}
 					else
 					{
 						// start a new block
 						key_blocks_new.Add (current_kb);
 						current_kb = kb;
 					}
 				}
 				key_blocks_new.Add (current_kb);
 				if (key_blocks.Count == key_blocks_new.Count)
 					break;
 				key_blocks = key_blocks_new;
 			}
 
 			// initialize the key lists
 			foreach (KeyBlock kb in key_blocks)
 				kb.element_keys = new List<object> ();
 			foreach (KeyBlock kb in key_blocks)
 				kb.element_keys = new List<object> ();
 
 			// fill the key lists
 			int iBlockCurr = 0;
 			if (key_blocks.Count > 0) {
 				current_kb = (KeyBlock) key_blocks [0];
 				foreach (object key in element_keys)
 				{
 					bool next_block = (key is UInt64) ? (ulong) key > (ulong) current_kb.last 
 						System.Convert.ToInt64 (key) > current_kb.last;
 					if (next_block)
 						current_kb = (KeyBlock) key_blocks [++iBlockCurr];
 					current_kb.element_keys.Add (key);
 				}
 				foreach (object key in element_keys)
 				{
 					bool next_block = (key is UInt64) ? (ulong) key > (ulong) current_kb.last 
 						System.Convert.ToInt64 (key) > current_kb.last;
 					if (next_block)
 						current_kb = (KeyBlock) key_blocks [++iBlockCurr];
 					current_kb.element_keys.Add (key);
 				}
 			}
 
 			// sort the blocks so we can tackle the largest ones first
 			key_blocks.Sort ();
 
 			// okay now we can start...
 			Label lbl_end = ec.DefineLabel ();	// at the end ;-)
 			Label lbl_default = default_target;
 
 			Type type_keys = null;
 			if (element_keys.Length > 0)
 				type_keys = element_keys [0].GetType ();	// used for conversions
 
 			TypeSpec compare_type;
 			
 			if (TypeManager.IsEnumType (SwitchType))
 				compare_type = EnumSpec.GetUnderlyingType (SwitchType);
 			else
 				compare_type = SwitchType;
 			
 			for (int iBlock = key_blocks.Count - 1; iBlock >= 0; --iBlock)
 			{
 				KeyBlock kb = ((KeyBlock) key_blocks [iBlock]);
 				lbl_default = (iBlock == 0) ? default_target 
 				if (kb.Length <= 2)
 				{
 					foreach (object key in kb.element_keys) {
 						SwitchLabel sl = (SwitchLabel) Elements [key];
 						if (key is int && (int) key == 0) {
 							val.EmitBranchable (ec, sl.GetILLabel (ec), false);
 						} else {
 							val.Emit (ec);
 							EmitObjectInteger (ec, key);
 							ec.Emit (OpCodes.Beq, sl.GetILLabel (ec));
 						}
 					}
 					foreach (object key in kb.element_keys) {
 						SwitchLabel sl = (SwitchLabel) Elements [key];
 						if (key is int && (int) key == 0) {
 							val.EmitBranchable (ec, sl.GetILLabel (ec), false);
 						} else {
 							val.Emit (ec);
 							EmitObjectInteger (ec, key);
 							ec.Emit (OpCodes.Beq, sl.GetILLabel (ec));
 						}
 					}
 				}
 				else
 				{
 					// TODO
 					//       no gaps/defaults then just use a range-check.
 					if (compare_type == TypeManager.int64_type ||
 						compare_type == TypeManager.uint64_type)
 					{
 						// TODO
 
 						// check block range (could be > 2^31)
 						val.Emit (ec);
 						EmitObjectInteger (ec, System.Convert.ChangeType (kb.first, type_keys));
 						ec.Emit (OpCodes.Blt, lbl_default);
 						val.Emit (ec);
 						EmitObjectInteger (ec, System.Convert.ChangeType (kb.last, type_keys));
 						ec.Emit (OpCodes.Bgt, lbl_default);
 
 						// normalize range
 						val.Emit (ec);
 						if (kb.first != 0)
 						{
 							EmitObjectInteger (ec, System.Convert.ChangeType (kb.first, type_keys));
 							ec.Emit (OpCodes.Sub);
 						}
 						ec.Emit (OpCodes.Conv_I4);	// assumes < 2^31 labels!
 					}
 					else
 					{
 						// normalize range
 						val.Emit (ec);
 						int first = (int) kb.first;
 						if (first > 0)
 						{
 							ec.EmitInt (first);
 							ec.Emit (OpCodes.Sub);
 						}
 						else if (first < 0)
 						{
 							ec.EmitInt (-first);
 							ec.Emit (OpCodes.Add);
 						}
 					}
 
 					// first, build the list of labels for the switch
 					int iKey = 0;
 					int cJumps = kb.Length;
 					Label [] switch_labels = new Label [cJumps];
 					for (int iJump = 0; iJump < cJumps; iJump++)
 					{
 						object key = kb.element_keys [iKey];
 						if (System.Convert.ToInt64 (key) == kb.first + iJump)
 						{
 							SwitchLabel sl = (SwitchLabel) Elements [key];
 							switch_labels [iJump] = sl.GetILLabel (ec);
 							iKey++;
 						}
 						else
 							switch_labels [iJump] = lbl_default;
 					}
 					for (int iJump = 0; iJump < cJumps; iJump++)
 					{
 						object key = kb.element_keys [iKey];
 						if (System.Convert.ToInt64 (key) == kb.first + iJump)
 						{
 							SwitchLabel sl = (SwitchLabel) Elements [key];
 							switch_labels [iJump] = sl.GetILLabel (ec);
 							iKey++;
 						}
 						else
 							switch_labels [iJump] = lbl_default;
 					}
 					// emit the switch opcode
 					ec.Emit (OpCodes.Switch, switch_labels);
 				}
 
 				// mark the default for this block
 				if (iBlock != 0)
 					ec.MarkLabel (lbl_default);
 			}
 			for (int iBlock = key_blocks.Count - 1; iBlock >= 0; --iBlock)
 			{
 				KeyBlock kb = ((KeyBlock) key_blocks [iBlock]);
 				lbl_default = (iBlock == 0) ? default_target 
 				if (kb.Length <= 2)
 				{
 					foreach (object key in kb.element_keys) {
 						SwitchLabel sl = (SwitchLabel) Elements [key];
 						if (key is int && (int) key == 0) {
 							val.EmitBranchable (ec, sl.GetILLabel (ec), false);
 						} else {
 							val.Emit (ec);
 							EmitObjectInteger (ec, key);
 							ec.Emit (OpCodes.Beq, sl.GetILLabel (ec));
 						}
 					}
 				}
 				else
 				{
 					// TODO
 					//       no gaps/defaults then just use a range-check.
 					if (compare_type == TypeManager.int64_type ||
 						compare_type == TypeManager.uint64_type)
 					{
 						// TODO
 
 						// check block range (could be > 2^31)
 						val.Emit (ec);
 						EmitObjectInteger (ec, System.Convert.ChangeType (kb.first, type_keys));
 						ec.Emit (OpCodes.Blt, lbl_default);
 						val.Emit (ec);
 						EmitObjectInteger (ec, System.Convert.ChangeType (kb.last, type_keys));
 						ec.Emit (OpCodes.Bgt, lbl_default);
 
 						// normalize range
 						val.Emit (ec);
 						if (kb.first != 0)
 						{
 							EmitObjectInteger (ec, System.Convert.ChangeType (kb.first, type_keys));
 							ec.Emit (OpCodes.Sub);
 						}
 						ec.Emit (OpCodes.Conv_I4);	// assumes < 2^31 labels!
 					}
 					else
 					{
 						// normalize range
 						val.Emit (ec);
 						int first = (int) kb.first;
 						if (first > 0)
 						{
 							ec.EmitInt (first);
 							ec.Emit (OpCodes.Sub);
 						}
 						else if (first < 0)
 						{
 							ec.EmitInt (-first);
 							ec.Emit (OpCodes.Add);
 						}
 					}
 
 					// first, build the list of labels for the switch
 					int iKey = 0;
 					int cJumps = kb.Length;
 					Label [] switch_labels = new Label [cJumps];
 					for (int iJump = 0; iJump < cJumps; iJump++)
 					{
 						object key = kb.element_keys [iKey];
 						if (System.Convert.ToInt64 (key) == kb.first + iJump)
 						{
 							SwitchLabel sl = (SwitchLabel) Elements [key];
 							switch_labels [iJump] = sl.GetILLabel (ec);
 							iKey++;
 						}
 						else
 							switch_labels [iJump] = lbl_default;
 					}
 					// emit the switch opcode
 					ec.Emit (OpCodes.Switch, switch_labels);
 				}
 
 				// mark the default for this block
 				if (iBlock != 0)
 					ec.MarkLabel (lbl_default);
 			}
 
 			// TODO
 			//       to prevent having to do the following jump.
 			//       make sure to mark other labels in the default section
 
 			// the last default just goes to the end
 			if (element_keys.Length > 0)
 				ec.Emit (OpCodes.Br, lbl_default);
 
 			// now emit the code for the sections
 			bool found_default = false;
 
 			foreach (SwitchSection ss in Sections) {
 				foreach (SwitchLabel sl in ss.Labels) {
 					if (sl.Converted == SwitchLabel.NullStringCase) {
 						ec.MarkLabel (null_target);
 					} else if (sl.Label == null) {
 						ec.MarkLabel (lbl_default);
 						found_default = true;
 						if (!has_null_case)
 							ec.MarkLabel (null_target);
 					}
 					ec.MarkLabel (sl.GetILLabel (ec));
 					ec.MarkLabel (sl.GetILLabelCode (ec));
 				}
 				foreach (SwitchLabel sl in ss.Labels) {
 					if (sl.Converted == SwitchLabel.NullStringCase) {
 						ec.MarkLabel (null_target);
 					} else if (sl.Label == null) {
 						ec.MarkLabel (lbl_default);
 						found_default = true;
 						if (!has_null_case)
 							ec.MarkLabel (null_target);
 					}
 					ec.MarkLabel (sl.GetILLabel (ec));
 					ec.MarkLabel (sl.GetILLabelCode (ec));
 				}
 				ss.Block.Emit (ec);
 			}
 			foreach (SwitchSection ss in Sections) {
 				foreach (SwitchLabel sl in ss.Labels) {
 					if (sl.Converted == SwitchLabel.NullStringCase) {
 						ec.MarkLabel (null_target);
 					} else if (sl.Label == null) {
 						ec.MarkLabel (lbl_default);
 						found_default = true;
 						if (!has_null_case)
 							ec.MarkLabel (null_target);
 					}
 					ec.MarkLabel (sl.GetILLabel (ec));
 					ec.MarkLabel (sl.GetILLabelCode (ec));
 				}
 				ss.Block.Emit (ec);
 			}
 			
 			if (!found_default) {
 				ec.MarkLabel (lbl_default);
 				if (!has_null_case) {
 					ec.MarkLabel (null_target);
 				}
 			}
 			
 			ec.MarkLabel (lbl_end);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1398" endline="1457">
<![CDATA[
 
 		public virtual void SetParameterInfo (List<Constraints> constraints_list)
 		{
 			if (!is_generic) {
 				if (constraints_list != null) {
 					Report.Error (
 						80, Location, "Constraints are not allowed " +
 						"on non-generic declarations");
 				}
 
 				return;
 			}
 
 			TypeParameterName[] names = MemberName.TypeArguments.GetDeclarations ();
 			type_params = new TypeParameter [names.Length];
 
 			//
 			// Register all the names
 			//
 			for (int i = 0; i < type_params.Length; i++) {
 				TypeParameterName name = names [i];
 
 				Constraints constraints = null;
 				if (constraints_list != null) {
 					int total = constraints_list.Count;
 					for (int ii = 0; ii < total; ++ii) {
 						Constraints constraints_at = (Constraints)constraints_list[ii];
 						// TODO
 						if (constraints_at == null) {
 							constraints_list.RemoveAt (ii);
 							--total;
 							continue;
 						}
 						if (constraints_at.TypeParameter.Value == name.Name) {
 							constraints = constraints_at;
 							constraints_list.RemoveAt(ii);
 							break;
 						}
 					}
 					for (int ii = 0; ii < total; ++ii) {
 						Constraints constraints_at = (Constraints)constraints_list[ii];
 						// TODO
 						if (constraints_at == null) {
 							constraints_list.RemoveAt (ii);
 							--total;
 							continue;
 						}
 						if (constraints_at.TypeParameter.Value == name.Name) {
 							constraints = constraints_at;
 							constraints_list.RemoveAt(ii);
 							break;
 						}
 					}
 				}
 
 				Variance variance = name.Variance;
 				if (name.Variance != Variance.None && !(this is Delegate || this is Interface)) {
 					Report.Error (1960, name.Location, "Variant type parameters can only be used with interfaces and delegates");
 					variance = Variance.None;
 				}
 
 				type_params [i] = new TypeParameter (
 					Parent, i, new MemberName (name.Name, Location), constraints, name.OptAttributes, variance);
 
 				AddToContainer (type_params [i], name.Name);
 			}
 			for (int i = 0; i < type_params.Length; i++) {
 				TypeParameterName name = names [i];
 
 				Constraints constraints = null;
 				if (constraints_list != null) {
 					int total = constraints_list.Count;
 					for (int ii = 0; ii < total; ++ii) {
 						Constraints constraints_at = (Constraints)constraints_list[ii];
 						// TODO
 						if (constraints_at == null) {
 							constraints_list.RemoveAt (ii);
 							--total;
 							continue;
 						}
 						if (constraints_at.TypeParameter.Value == name.Name) {
 							constraints = constraints_at;
 							constraints_list.RemoveAt(ii);
 							break;
 						}
 					}
 				}
 
 				Variance variance = name.Variance;
 				if (name.Variance != Variance.None && !(this is Delegate || this is Interface)) {
 					Report.Error (1960, name.Location, "Variant type parameters can only be used with interfaces and delegates");
 					variance = Variance.None;
 				}
 
 				type_params [i] = new TypeParameter (
 					Parent, i, new MemberName (name.Name, Location), constraints, name.OptAttributes, variance);
 
 				AddToContainer (type_params [i], name.Name);
 			}
 
 			if (constraints_list != null && constraints_list.Count > 0) {
 				foreach (Constraints constraint in constraints_list) {
 					Report.Error(699, constraint.Location, "`{0}'
 						GetSignatureForError (), constraint.TypeParameter.Value);
 				}
 				foreach (Constraints constraint in constraints_list) {
 					Report.Error(699, constraint.Location, "`{0}'
 						GetSignatureForError (), constraint.TypeParameter.Value);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="830" endline="901">
<![CDATA[
 
 		//
 		// Returns all operators declared on container and its base types (until declaredOnly is used)
 		//
 		public static IList<MemberSpec> GetUserOperator (TypeSpec container, Operator.OpType op, bool declaredOnly)
 		{
 			IList<MemberSpec> found = null;
 
 			IList<MemberSpec> applicable;
 			do {
 				var mc = container.MemberCache;
 
 				if (((op == Operator.OpType.Implicit || op == Operator.OpType.Explicit) && (mc.state & StateFlags.HasConversionOperator) != 0) ||
 					 (mc.state & StateFlags.HasUserOperator) != 0) {
 
 					if (mc.member_hash.TryGetValue (Operator.GetMetadataName (op), out applicable)) {
 						int i;
 						for (i = 0; i < applicable.Count; ++i) {
 							if (applicable[i].Kind != MemberKind.Operator) {
 								break;
 							}
 						}
 						for (i = 0; i < applicable.Count; ++i) {
 							if (applicable[i].Kind != MemberKind.Operator) {
 								break;
 							}
 						}
 
 						//
 						// Handles very rare case where a method with same name as operator (op_xxxx) exists
 						// and we have to resize the applicable list
 						//
 						if (i != applicable.Count) {
 							for (i = 0; i < applicable.Count; ++i) {
 								if (applicable[i].Kind != MemberKind.Operator) {
 									continue;
 								}
 
 								if (found == null) {
 									found = new List<MemberSpec> ();
 									found.Add (applicable[i]);
 								} else {
 									var prev = found as List<MemberSpec>;
 									if (prev == null) {
 										prev = new List<MemberSpec> (found.Count + 1);
 										prev.AddRange (found);
 									}
 
 									prev.Add (applicable[i]);
 								}
 							}
 							for (i = 0; i < applicable.Count; ++i) {
 								if (applicable[i].Kind != MemberKind.Operator) {
 									continue;
 								}
 
 								if (found == null) {
 									found = new List<MemberSpec> ();
 									found.Add (applicable[i]);
 								} else {
 									var prev = found as List<MemberSpec>;
 									if (prev == null) {
 										prev = new List<MemberSpec> (found.Count + 1);
 										prev.AddRange (found);
 									}
 
 									prev.Add (applicable[i]);
 								}
 							}
 						} else {
 							if (found == null) {
 								found = applicable;
 							} else {
 								var merged = found as List<MemberSpec>;
 								if (merged == null) {
 									merged = new List<MemberSpec> (found.Count + applicable.Count);
 									merged.AddRange (found);
 									found = merged;
 								}
 
 								merged.AddRange (applicable);
 							}
 						}
 					}
 				}
 
 				// BaseType call can be expensive
 				if (declaredOnly)
 					break;
 
 				container = container.BaseType;
 			} while (container != null);
 
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="400" endline="460">
<![CDATA[
 
 		public static string [] GetCompletions (string input, out string prefix)
 		{
 			prefix = "";
 			if (input == null || input.Length == 0)
 				return null;
 			
 			lock (evaluator_lock){
 				if (!inited)
 					Init ();
 				
 				bool partial_input;
 				CSharpParser parser = ParseString (ParseMode.GetCompletions, input, out partial_input);
 				if (parser == null){
 					if (CSharpParser.yacc_verbose_flag != 0)
 						Console.WriteLine ("DEBUG
 					return null;
 				}
 				
 				Class parser_result = parser.InteractiveResult as Class;
 				
 				if (parser_result == null){
 					if (CSharpParser.yacc_verbose_flag != 0)
 						Console.WriteLine ("Do not know how to cope with !Class yet");
 					return null;
 				}
 
 				try {
 					var a = new AssemblyDefinitionDynamic (RootContext.ToplevelTypes, "temp");
 					a.Create (AppDomain.CurrentDomain, AssemblyBuilderAccess.Run);
 					RootContext.ToplevelTypes.SetDeclaringAssembly (a);
 					RootContext.ToplevelTypes.Define ();
 					if (ctx.Report.Errors != 0)
 						return null;
 					
 					MethodOrOperator method = null;
 					foreach (MemberCore member in parser_result.Methods){
 						if (member.Name != "Host")
 							continue;
 						
 						method = (MethodOrOperator) member;
 						break;
 					foreach (MemberCore member in parser_result.Methods){
 						if (member.Name != "Host")
 							continue;
 						
 						method = (MethodOrOperator) member;
 						break;
 					}
 					if (method == null)
 						throw new InternalErrorException ("did not find the the Host method");
 
 					BlockContext bc = new BlockContext (method, method.Block, method.ReturnType);
 
 					try {
 						method.Block.Resolve (null, bc, method);
 					} catch (CompletionResult cr){
 						prefix = cr.BaseText;
 						return cr.Result;
 					} 
 				} finally {
 					parser.undo.ExecuteUndo ();
 				}
 				
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="118" endline="168">
<![CDATA[
 
 		//
 		// Generates xml doc comments (if any), and if required,
 		// handle warning report.
 		//
 		internal static void GenerateDocComment (MemberCore mc,
 			DeclSpace ds, Report Report)
 		{
 			if (mc.DocComment != null) {
 				string name = mc.GetDocCommentName (ds);
 
 				XmlNode n = GetDocCommentNode (mc, name, Report);
 
 				XmlElement el = n as XmlElement;
 				if (el != null) {
 					mc.OnGenerateDocComment (el);
 
 					// FIXME
 					XmlNodeList nl = n.SelectNodes (".//include");
 					if (nl.Count > 0) {
 						// It could result in current node removal, so prepare another list to iterate.
 						var al = new List<XmlNode> (nl.Count);
 						foreach (XmlNode inc in nl)
 							al.Add (inc);
 						foreach (XmlNode inc in nl)
 							al.Add (inc);
 						foreach (XmlElement inc in al)
 							if (!HandleInclude (mc, inc, Report))
 								inc.ParentNode.RemoveChild (inc);
 						foreach (XmlElement inc in al)
 							if (!HandleInclude (mc, inc, Report))
 								inc.ParentNode.RemoveChild (inc);
 					}
 
 					// FIXME
 					DeclSpace ds_target = mc as DeclSpace;
 					if (ds_target == null)
 						ds_target = ds;
 
 					foreach (XmlElement see in n.SelectNodes (".//see"))
 						HandleSee (mc, ds_target, see, Report);
 					foreach (XmlElement see in n.SelectNodes (".//see"))
 						HandleSee (mc, ds_target, see, Report);
 					foreach (XmlElement seealso in n.SelectNodes (".//seealso"))
 						HandleSeeAlso (mc, ds_target, seealso ,Report);
 					foreach (XmlElement seealso in n.SelectNodes (".//seealso"))
 						HandleSeeAlso (mc, ds_target, seealso ,Report);
 					foreach (XmlElement see in n.SelectNodes (".//exception"))
 						HandleException (mc, ds_target, see, Report);
 					foreach (XmlElement see in n.SelectNodes (".//exception"))
 						HandleException (mc, ds_target, see, Report);
 				}
 
 				n.WriteTo (RootContext.Documentation.XmlCommentOutput);
 			}
 			else if (mc.IsExposedFromAssembly ()) {
 				Constructor c = mc as Constructor;
 				if (c == null || !c.IsDefault ())
 					Report.Warning (1591, 4, mc.Location,
 						"Missing XML comment for publicly visible type or member `{0}'", mc.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="929" endline="1035">
<![CDATA[
 
 		//
 		// Inflates all open type members, requires InflateTypes to be called before
 		//
 		public void InflateMembers (MemberCache cacheToInflate, TypeSpec inflatedType, TypeParameterInflator inflator)
 		{
 			var inflated_member_hash = cacheToInflate.member_hash;
 			Dictionary<MemberSpec, MethodSpec> accessor_relation = null;
 			List<MemberSpec> accessor_members = null;
 
 			// Copy member specific flags when all members were added
 			cacheToInflate.state = state;
 
 			foreach (var item in member_hash) {
 				var members = item.Value;
 				IList<MemberSpec> inflated_members = null;
 				for (int i = 0; i < members.Count; ++i ) {
 					var member = members[i];
 
 					//
 					// All nested types have been inflated earlier except for
 					// compiler types which are created later and could miss InflateTypes
 					//
 					if ((member.Kind & MemberKind.NestedMask) != 0 &&
 						(member.Modifiers & Modifiers.COMPILER_GENERATED) == 0) {
 						if (inflated_members == null)
 							inflated_members = inflated_member_hash[item.Key];
 
 						continue;
 					}
 
 					//
 					// Clone the container first
 					//
 					if (inflated_members == null) {
 						inflated_members = new MemberSpec [item.Value.Count];
 						inflated_member_hash.Add (item.Key, inflated_members);
 					}
 
 					var local_inflator = inflator;
 
 					if (member.DeclaringType != inflatedType) {
 						//
 						// Don't inflate top-level non-generic interface members
 						// merged into generic interface
 						//
 						if (!member.DeclaringType.IsGeneric && !member.DeclaringType.IsNested) {
 							inflated_members [i] = member;
 							continue;
 						}
 
 						//
 						// Needed when inflating flatten interfaces. It inflates
 						// container type only, type parameters are already done
 						//
 						// Handles cases like
 						//
 						// interface I<T> {}
 						// interface I<U, V> 
 						// 
 						// class C
 						//
 						var inflated_parent = inflator.Inflate (member.DeclaringType);
 						if (inflated_parent != inflator.TypeInstance)
 							local_inflator = new TypeParameterInflator (inflator, inflated_parent);
 					}
 
 					//
 					// Inflate every member, its parent is now different
 					//
 					var inflated = member.InflateMember (local_inflator);
 					inflated_members [i] = inflated;
 
 					if (member is PropertySpec || member is EventSpec) {
 						if (accessor_members == null)
 							accessor_members = new List<MemberSpec> ();
 
 						accessor_members.Add (inflated);
 						continue;
 					}
 
 					if (member.IsAccessor) {
 						if (accessor_relation == null)
 							accessor_relation = new Dictionary<MemberSpec, MethodSpec> ();
 						accessor_relation.Add (member, (MethodSpec) inflated);
 					}
 				}
 				for (int i = 0; i < members.Count; ++i ) {
 					var member = members[i];
 
 					//
 					// All nested types have been inflated earlier except for
 					// compiler types which are created later and could miss InflateTypes
 					//
 					if ((member.Kind & MemberKind.NestedMask) != 0 &&
 						(member.Modifiers & Modifiers.COMPILER_GENERATED) == 0) {
 						if (inflated_members == null)
 							inflated_members = inflated_member_hash[item.Key];
 
 						continue;
 					}
 
 					//
 					// Clone the container first
 					//
 					if (inflated_members == null) {
 						inflated_members = new MemberSpec [item.Value.Count];
 						inflated_member_hash.Add (item.Key, inflated_members);
 					}
 
 					var local_inflator = inflator;
 
 					if (member.DeclaringType != inflatedType) {
 						//
 						// Don't inflate top-level non-generic interface members
 						// merged into generic interface
 						//
 						if (!member.DeclaringType.IsGeneric && !member.DeclaringType.IsNested) {
 							inflated_members [i] = member;
 							continue;
 						}
 
 						//
 						// Needed when inflating flatten interfaces. It inflates
 						// container type only, type parameters are already done
 						//
 						// Handles cases like
 						//
 						// interface I<T> {}
 						// interface I<U, V> 
 						// 
 						// class C
 						//
 						var inflated_parent = inflator.Inflate (member.DeclaringType);
 						if (inflated_parent != inflator.TypeInstance)
 							local_inflator = new TypeParameterInflator (inflator, inflated_parent);
 					}
 
 					//
 					// Inflate every member, its parent is now different
 					//
 					var inflated = member.InflateMember (local_inflator);
 					inflated_members [i] = inflated;
 
 					if (member is PropertySpec || member is EventSpec) {
 						if (accessor_members == null)
 							accessor_members = new List<MemberSpec> ();
 
 						accessor_members.Add (inflated);
 						continue;
 					}
 
 					if (member.IsAccessor) {
 						if (accessor_relation == null)
 							accessor_relation = new Dictionary<MemberSpec, MethodSpec> ();
 						accessor_relation.Add (member, (MethodSpec) inflated);
 					}
 				}
 			}
 			foreach (var item in member_hash) {
 				var members = item.Value;
 				IList<MemberSpec> inflated_members = null;
 				for (int i = 0; i < members.Count; ++i ) {
 					var member = members[i];
 
 					//
 					// All nested types have been inflated earlier except for
 					// compiler types which are created later and could miss InflateTypes
 					//
 					if ((member.Kind & MemberKind.NestedMask) != 0 &&
 						(member.Modifiers & Modifiers.COMPILER_GENERATED) == 0) {
 						if (inflated_members == null)
 							inflated_members = inflated_member_hash[item.Key];
 
 						continue;
 					}
 
 					//
 					// Clone the container first
 					//
 					if (inflated_members == null) {
 						inflated_members = new MemberSpec [item.Value.Count];
 						inflated_member_hash.Add (item.Key, inflated_members);
 					}
 
 					var local_inflator = inflator;
 
 					if (member.DeclaringType != inflatedType) {
 						//
 						// Don't inflate top-level non-generic interface members
 						// merged into generic interface
 						//
 						if (!member.DeclaringType.IsGeneric && !member.DeclaringType.IsNested) {
 							inflated_members [i] = member;
 							continue;
 						}
 
 						//
 						// Needed when inflating flatten interfaces. It inflates
 						// container type only, type parameters are already done
 						//
 						// Handles cases like
 						//
 						// interface I<T> {}
 						// interface I<U, V> 
 						// 
 						// class C
 						//
 						var inflated_parent = inflator.Inflate (member.DeclaringType);
 						if (inflated_parent != inflator.TypeInstance)
 							local_inflator = new TypeParameterInflator (inflator, inflated_parent);
 					}
 
 					//
 					// Inflate every member, its parent is now different
 					//
 					var inflated = member.InflateMember (local_inflator);
 					inflated_members [i] = inflated;
 
 					if (member is PropertySpec || member is EventSpec) {
 						if (accessor_members == null)
 							accessor_members = new List<MemberSpec> ();
 
 						accessor_members.Add (inflated);
 						continue;
 					}
 
 					if (member.IsAccessor) {
 						if (accessor_relation == null)
 							accessor_relation = new Dictionary<MemberSpec, MethodSpec> ();
 						accessor_relation.Add (member, (MethodSpec) inflated);
 					}
 				}
 			}
 
 			if (accessor_members != null) {
 				foreach (var member in accessor_members) {
 					var prop = member as PropertySpec;
 					if (prop != null) {
 						if (prop.Get != null)
 							prop.Get = accessor_relation[prop.Get];
 						if (prop.Set != null)
 							prop.Set = accessor_relation[prop.Set];
 
 						continue;
 					}
 
 					var ev = (EventSpec) member;
 					ev.AccessorAdd = accessor_relation[ev.AccessorAdd];
 					ev.AccessorRemove = accessor_relation[ev.AccessorRemove];
 				}
 				foreach (var member in accessor_members) {
 					var prop = member as PropertySpec;
 					if (prop != null) {
 						if (prop.Get != null)
 							prop.Get = accessor_relation[prop.Get];
 						if (prop.Set != null)
 							prop.Set = accessor_relation[prop.Set];
 
 						continue;
 					}
 
 					var ev = (EventSpec) member;
 					ev.AccessorAdd = accessor_relation[ev.AccessorAdd];
 					ev.AccessorRemove = accessor_relation[ev.AccessorRemove];
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="709" endline="803">
<![CDATA[
 
 		//
 		// Returns all not implememted abstract members inside abstract type
 		// NOTE
 		//
 		public static IList<MethodSpec> GetNotImplementedAbstractMethods (TypeSpec type)
 		{
 			if (type.MemberCache.missing_abstract != null)
 				return type.MemberCache.missing_abstract;
 				
 			var abstract_methods = new List<MethodSpec> ();
 			List<TypeSpec> hierarchy = null;
 
 			//
 			// Stage 1
 			//
 			var abstract_type = type;
 			while (true) {
 				foreach (var entry in abstract_type.MemberCache.member_hash) {
 					foreach (var name_entry in entry.Value) {
 						if ((name_entry.Modifiers & Modifiers.ABSTRACT) == 0)
 							continue;
 
 						if (name_entry.Kind != MemberKind.Method)
 							continue;
 
 						abstract_methods.Add ((MethodSpec) name_entry);
 					}
 					foreach (var name_entry in entry.Value) {
 						if ((name_entry.Modifiers & Modifiers.ABSTRACT) == 0)
 							continue;
 
 						if (name_entry.Kind != MemberKind.Method)
 							continue;
 
 						abstract_methods.Add ((MethodSpec) name_entry);
 					}
 				}
 				foreach (var entry in abstract_type.MemberCache.member_hash) {
 					foreach (var name_entry in entry.Value) {
 						if ((name_entry.Modifiers & Modifiers.ABSTRACT) == 0)
 							continue;
 
 						if (name_entry.Kind != MemberKind.Method)
 							continue;
 
 						abstract_methods.Add ((MethodSpec) name_entry);
 					}
 				}
 
 				var base_type = abstract_type.BaseType;
 				if (!base_type.IsAbstract)
 					break;
 
 				if (hierarchy == null)
 					hierarchy = new List<TypeSpec> ();
 
 				hierarchy.Add (abstract_type);
 				abstract_type = base_type;
 			}
 			while (true) {
 				foreach (var entry in abstract_type.MemberCache.member_hash) {
 					foreach (var name_entry in entry.Value) {
 						if ((name_entry.Modifiers & Modifiers.ABSTRACT) == 0)
 							continue;
 
 						if (name_entry.Kind != MemberKind.Method)
 							continue;
 
 						abstract_methods.Add ((MethodSpec) name_entry);
 					}
 				}
 
 				var base_type = abstract_type.BaseType;
 				if (!base_type.IsAbstract)
 					break;
 
 				if (hierarchy == null)
 					hierarchy = new List<TypeSpec> ();
 
 				hierarchy.Add (abstract_type);
 				abstract_type = base_type;
 			}
 
 			int not_implemented_count = abstract_methods.Count;
 			if (not_implemented_count == 0 || hierarchy == null) {
 				type.MemberCache.missing_abstract = abstract_methods;
 				return type.MemberCache.missing_abstract;
 			}
 
 			//
 			// Stage 2
 			//
 			foreach (var type_up in hierarchy) {
 				var members = type_up.MemberCache.member_hash;
 				if (members.Count == 0)
 					continue;
 
 				for (int i = 0; i < abstract_methods.Count; ++i) {
 					var candidate = abstract_methods [i];
 					if (candidate == null)
 						continue;
 
 					IList<MemberSpec> applicable;
 					if (!members.TryGetValue (candidate.Name, out applicable))
 						continue;
 
 					var filter = new MemberFilter (candidate);
 					foreach (var item in applicable) {
 						if ((item.Modifiers & (Modifiers.OVERRIDE | Modifiers.VIRTUAL)) == 0)
 							continue;
 
 						if (filter.Equals (item)) {
 							--not_implemented_count;
 							abstract_methods [i] = null;
 							break;
 						}
 					}
 					foreach (var item in applicable) {
 						if ((item.Modifiers & (Modifiers.OVERRIDE | Modifiers.VIRTUAL)) == 0)
 							continue;
 
 						if (filter.Equals (item)) {
 							--not_implemented_count;
 							abstract_methods [i] = null;
 							break;
 						}
 					}
 				}
 				for (int i = 0; i < abstract_methods.Count; ++i) {
 					var candidate = abstract_methods [i];
 					if (candidate == null)
 						continue;
 
 					IList<MemberSpec> applicable;
 					if (!members.TryGetValue (candidate.Name, out applicable))
 						continue;
 
 					var filter = new MemberFilter (candidate);
 					foreach (var item in applicable) {
 						if ((item.Modifiers & (Modifiers.OVERRIDE | Modifiers.VIRTUAL)) == 0)
 							continue;
 
 						if (filter.Equals (item)) {
 							--not_implemented_count;
 							abstract_methods [i] = null;
 							break;
 						}
 					}
 				}
 			}
 			foreach (var type_up in hierarchy) {
 				var members = type_up.MemberCache.member_hash;
 				if (members.Count == 0)
 					continue;
 
 				for (int i = 0; i < abstract_methods.Count; ++i) {
 					var candidate = abstract_methods [i];
 					if (candidate == null)
 						continue;
 
 					IList<MemberSpec> applicable;
 					if (!members.TryGetValue (candidate.Name, out applicable))
 						continue;
 
 					var filter = new MemberFilter (candidate);
 					foreach (var item in applicable) {
 						if ((item.Modifiers & (Modifiers.OVERRIDE | Modifiers.VIRTUAL)) == 0)
 							continue;
 
 						if (filter.Equals (item)) {
 							--not_implemented_count;
 							abstract_methods [i] = null;
 							break;
 						}
 					}
 				}
 			}
 
 			if (not_implemented_count == abstract_methods.Count) {
 				type.MemberCache.missing_abstract = abstract_methods;
 				return type.MemberCache.missing_abstract;
 			}
 
 			var not_implemented = new MethodSpec[not_implemented_count];
 			int counter = 0;
 			foreach (var m in abstract_methods) {
 				if (m == null)
 					continue;
 
 				not_implemented[counter++] = m;
 			}
 			foreach (var m in abstract_methods) {
 				if (m == null)
 					continue;
 
 				not_implemented[counter++] = m;
 			}
 
 			type.MemberCache.missing_abstract = not_implemented;
 			return type.MemberCache.missing_abstract;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="940" endline="1055">
<![CDATA[
 
 		protected virtual void DefineTypeParameters ()
 		{
 			var tparams = CurrentTypeParameters;
 
 			TypeParameterSpec[] base_tparams = null;
 			TypeParameterSpec[] base_decl_tparams = TypeParameterSpec.EmptyTypes;
 			TypeSpec[] base_targs = TypeSpec.EmptyTypes;
 			if (((ModFlags & Modifiers.OVERRIDE) != 0 || IsExplicitImpl)) {
 				if (base_method != null) {
 					base_tparams = base_method.GenericDefinition.TypeParameters;
 				
 					if (base_method.DeclaringType.IsGeneric) {
 						base_decl_tparams = base_method.DeclaringType.MemberDefinition.TypeParameters;
 
 						var base_type_parent = CurrentType;
 						while (base_type_parent.BaseType != base_method.DeclaringType) {
 							base_type_parent = base_type_parent.BaseType;
 						}
 						while (base_type_parent.BaseType != base_method.DeclaringType) {
 							base_type_parent = base_type_parent.BaseType;
 						}
 
 						base_targs = base_type_parent.BaseType.TypeArguments;
 					}
 
 					if (base_method.IsGeneric) {
 						ObsoleteAttribute oa;
 						foreach (var base_tp in base_tparams) {
 							oa = base_tp.BaseType.GetAttributeObsolete ();
 							if (oa != null) {
 								AttributeTester.Report_ObsoleteMessage (oa, base_tp.BaseType.GetSignatureForError (), Location, Report);
 							}
 
 							if (base_tp.InterfacesDefined != null) {
 								foreach (var iface in base_tp.InterfacesDefined) {
 									oa = iface.GetAttributeObsolete ();
 									if (oa != null) {
 										AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 									}
 								}
 								foreach (var iface in base_tp.InterfacesDefined) {
 									oa = iface.GetAttributeObsolete ();
 									if (oa != null) {
 										AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 									}
 								}
 							}
 						}
 						foreach (var base_tp in base_tparams) {
 							oa = base_tp.BaseType.GetAttributeObsolete ();
 							if (oa != null) {
 								AttributeTester.Report_ObsoleteMessage (oa, base_tp.BaseType.GetSignatureForError (), Location, Report);
 							}
 
 							if (base_tp.InterfacesDefined != null) {
 								foreach (var iface in base_tp.InterfacesDefined) {
 									oa = iface.GetAttributeObsolete ();
 									if (oa != null) {
 										AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 									}
 								}
 							}
 						}
 
 						if (base_decl_tparams.Length != 0) {
 							base_decl_tparams = base_decl_tparams.Concat (base_tparams).ToArray ();
 							base_targs = base_targs.Concat (tparams.Select<TypeParameter, TypeSpec> (l => l.Type)).ToArray ();
 						} else {
 							base_decl_tparams = base_tparams;
 							base_targs = tparams.Select (l => l.Type).ToArray ();
 						}
 					}
 				} else if (MethodData.implementing != null) {
 					base_tparams = MethodData.implementing.GenericDefinition.TypeParameters;
 					if (MethodData.implementing.DeclaringType.IsGeneric) {
 						base_decl_tparams = MethodData.implementing.DeclaringType.MemberDefinition.TypeParameters;
 						foreach (var iface in Parent.CurrentType.Interfaces) {
 							if (iface == MethodData.implementing.DeclaringType) {
 								base_targs = iface.TypeArguments;
 								break;
 							}
 						}
 						foreach (var iface in Parent.CurrentType.Interfaces) {
 							if (iface == MethodData.implementing.DeclaringType) {
 								base_targs = iface.TypeArguments;
 								break;
 							}
 						}
 					}
 				}
 			}
 
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 
 				if (!tp.ResolveConstraints (this))
 					continue;
 
 				//
 				// Copy base constraints for override/explicit methods
 				//
 				if (base_tparams != null) {
 					var base_tparam = base_tparams[i];
 					var local_tparam = tp.Type;
 					local_tparam.SpecialConstraint = base_tparam.SpecialConstraint;
 
 					var inflator = new TypeParameterInflator (CurrentType, base_decl_tparams, base_targs);
 					base_tparam.InflateConstraints (inflator, local_tparam);
 
 					//
 					// Check all type argument constraints for possible collision
 					// introduced by inflating inherited constraints in this context
 					//
 					// Conflict example
 					//
 					// class A<T> { virtual void Foo<U> () where U 
 					// class B 
 					//
 					var local_tparam_targs = local_tparam.TypeArguments;
 					if (local_tparam_targs != null) {					
 						for (int ii = 0; ii < local_tparam_targs.Length; ++ii) {
 							var ta = local_tparam_targs [ii];
 							if (!ta.IsClass && !ta.IsStruct)
 								continue;
 
 							if (Constraints.CheckConflictingInheritedConstraint (local_tparam, ta, this, Location)) {
 								local_tparam.ChangeTypeArgumentToBaseType (ii);
 							}
 						}
 						for (int ii = 0; ii < local_tparam_targs.Length; ++ii) {
 							var ta = local_tparam_targs [ii];
 							if (!ta.IsClass && !ta.IsStruct)
 								continue;
 
 							if (Constraints.CheckConflictingInheritedConstraint (local_tparam, ta, this, Location)) {
 								local_tparam.ChangeTypeArgumentToBaseType (ii);
 							}
 						}
 					}
 
 					continue;
 				}
 				
 				if (MethodData.implementing != null) {
 					var base_tp = MethodData.implementing.Constraints[i];
 					if (!tp.Type.HasSameConstraintsImplementation (base_tp)) {
 						Report.SymbolRelatedToPreviousError (MethodData.implementing);
 						Report.Error (425, Location,
 							"The constraints for type parameter `{0}' of method `{1}' must match the constraints for type parameter `{2}' of interface method `{3}'. Consider using an explicit interface implementation instead",
 							tp.GetSignatureForError (), GetSignatureForError (), base_tp.GetSignatureForError (), MethodData.implementing.GetSignatureForError ());
 					}
 				}
 			}
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 
 				if (!tp.ResolveConstraints (this))
 					continue;
 
 				//
 				// Copy base constraints for override/explicit methods
 				//
 				if (base_tparams != null) {
 					var base_tparam = base_tparams[i];
 					var local_tparam = tp.Type;
 					local_tparam.SpecialConstraint = base_tparam.SpecialConstraint;
 
 					var inflator = new TypeParameterInflator (CurrentType, base_decl_tparams, base_targs);
 					base_tparam.InflateConstraints (inflator, local_tparam);
 
 					//
 					// Check all type argument constraints for possible collision
 					// introduced by inflating inherited constraints in this context
 					//
 					// Conflict example
 					//
 					// class A<T> { virtual void Foo<U> () where U 
 					// class B 
 					//
 					var local_tparam_targs = local_tparam.TypeArguments;
 					if (local_tparam_targs != null) {					
 						for (int ii = 0; ii < local_tparam_targs.Length; ++ii) {
 							var ta = local_tparam_targs [ii];
 							if (!ta.IsClass && !ta.IsStruct)
 								continue;
 
 							if (Constraints.CheckConflictingInheritedConstraint (local_tparam, ta, this, Location)) {
 								local_tparam.ChangeTypeArgumentToBaseType (ii);
 							}
 						}
 					}
 
 					continue;
 				}
 				
 				if (MethodData.implementing != null) {
 					var base_tp = MethodData.implementing.Constraints[i];
 					if (!tp.Type.HasSameConstraintsImplementation (base_tp)) {
 						Report.SymbolRelatedToPreviousError (MethodData.implementing);
 						Report.Error (425, Location,
 							"The constraints for type parameter `{0}' of method `{1}' must match the constraints for type parameter `{2}' of interface method `{3}'. Consider using an explicit interface implementation instead",
 							tp.GetSignatureForError (), GetSignatureForError (), base_tp.GetSignatureForError (), MethodData.implementing.GetSignatureForError ());
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="858" endline="983">
<![CDATA[
 
 		//
 		// Constraints have to match by using same set of types, used by
 		// implicit interface implementation
 		//
 		public bool HasSameConstraintsImplementation (TypeParameterSpec other)
 		{
 			if (spec != other.spec)
 				return false;
 
 			//
 			// It can be same base type or inflated type parameter
 			//
 			// interface I<T> { void Foo<U> where U 
 			// class A 
 			//
 			bool found;
 			if (!TypeSpecComparer.Override.IsEqual (BaseType, other.BaseType)) {
 				if (other.targs == null)
 					return false;
 
 				found = false;
 				foreach (var otarg in other.targs) {
 					if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 						found = true;
 						break;
 					}
 				}
 				foreach (var otarg in other.targs) {
 					if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 						found = true;
 						break;
 					}
 				}
 
 				if (!found)
 					return false;
 			}
 
 			// Check interfaces implementation -> definition
 			if (InterfacesDefined != null) {
 				foreach (var iface in InterfacesDefined) {
 					found = false;
 					if (other.InterfacesDefined != null) {
 						foreach (var oiface in other.InterfacesDefined) {
 							if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 								found = true;
 								break;
 							}
 						}
 						foreach (var oiface in other.InterfacesDefined) {
 							if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 								found = true;
 								break;
 							}
 						}
 					}
 
 					if (found)
 						continue;
 
 					if (other.targs != null) {
 						foreach (var otarg in other.targs) {
 							if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 								found = true;
 								break;
 							}
 						}
 						foreach (var otarg in other.targs) {
 							if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 								found = true;
 								break;
 							}
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 				foreach (var iface in InterfacesDefined) {
 					found = false;
 					if (other.InterfacesDefined != null) {
 						foreach (var oiface in other.InterfacesDefined) {
 							if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 								found = true;
 								break;
 							}
 						}
 					}
 
 					if (found)
 						continue;
 
 					if (other.targs != null) {
 						foreach (var otarg in other.targs) {
 							if (TypeSpecComparer.Override.IsEqual (BaseType, otarg)) {
 								found = true;
 								break;
 							}
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check interfaces implementation <- definition
 			if (other.InterfacesDefined != null) {
 				if (InterfacesDefined == null)
 					return false;
 
 				foreach (var oiface in other.InterfacesDefined) {
 					found = false;
 					foreach (var iface in InterfacesDefined) {
 						if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 							found = true;
 							break;
 						}
 					}
 					foreach (var iface in InterfacesDefined) {
 						if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 				foreach (var oiface in other.InterfacesDefined) {
 					found = false;
 					foreach (var iface in InterfacesDefined) {
 						if (TypeSpecComparer.Override.IsEqual (iface, oiface)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check type parameters implementation -> definition
 			if (targs != null) {
 				if (other.targs == null)
 					return false;
 
 				foreach (var targ in targs) {
 					found = false;
 					foreach (var otarg in other.targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 					foreach (var otarg in other.targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 				foreach (var targ in targs) {
 					found = false;
 					foreach (var otarg in other.targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}
 			}
 
 			// Check type parameters implementation <- definition
 			if (other.targs != null) {
 				foreach (var otarg in other.targs) {
 					// Ignore inflated type arguments, were checked above
 					if (!otarg.IsGenericParameter)
 						continue;
 
 					if (targs == null)
 						return false;
 
 					found = false;
 					foreach (var targ in targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 					foreach (var targ in targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}				
 				foreach (var otarg in other.targs) {
 					// Ignore inflated type arguments, were checked above
 					if (!otarg.IsGenericParameter)
 						continue;
 
 					if (targs == null)
 						return false;
 
 					found = false;
 					foreach (var targ in targs) {
 						if (TypeSpecComparer.Override.IsEqual (targ, otarg)) {
 							found = true;
 							break;
 						}
 					}
 
 					if (!found)
 						return false;
 				}				
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="265" endline="283">
<![CDATA[
 		}
 
 		public virtual bool ContainsGenericParameters
 		{
 			get
 			{
 				if (this.IsGenericParameter)
 				{
 					return true;
 				}
 				foreach (Type arg in this.GetGenericArguments())
 				{
 					if (arg.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type arg in this.GetGenericArguments())
 				{
 					if (arg.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="426" endline="440">
<![CDATA[
 
 		internal object GetFieldValue(string name)
 		{
 			if (namedFields != null)
 			{
 				for (int i = 0; i < namedFields.Length; i++)
 				{
 					if (namedFields[i].Name == name)
 					{
 						return fieldValues[i];
 					}
 				}
 				for (int i = 0; i < namedFields.Length; i++)
 				{
 					if (namedFields[i].Name == name)
 					{
 						return fieldValues[i];
 					}
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="259" endline="274">
<![CDATA[
 
 		TypeSpec ResolvePossibleAttributeType (ATypeNameExpression expr, ref bool is_attr)
 		{
 			TypeExpr te = ResolveAsTypeTerminal (expr, context);
 			if (te == null)
 				return null;
 
 			TypeSpec t = te.Type;
 			if (t.IsAttribute) {
 				is_attr = true;
 			} else {
 				Report.SymbolRelatedToPreviousError (t);
 				Report.Error (616, Location, "`{0}'
 			}
 			return t;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="719" endline="737">
<![CDATA[
 		}
 
 		//
 		// Returns whether the type parameter is "known to be a reference type"
 		//
 		public bool IsReferenceType {
 			get {
 				if ((spec & SpecialConstraint.Class) != 0 || HasTypeConstraint)
 					return true;
 
 				if (targs != null) {
 					foreach (var ta in targs) {
 						if (TypeManager.IsReferenceType (ta))
 							return true;
 					}
 					foreach (var ta in targs) {
 						if (TypeManager.IsReferenceType (ta))
 							return true;
 					}
 				}
 
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="921" endline="939">
<![CDATA[
 
 		//
 		// Test for a custom attribute type match. Custom attributes are not really predefined globaly 
 		// they can be assembly specific therefore we do check based on names only
 		//
 		public bool HasAttribute (IList<CustomAttributeData> attributesData, string attrName, string attrNamespace)
 		{
 			if (attributesData.Count == 0)
 				return false;
 
 			string ns, name;
 			foreach (var attr in attributesData) {
 				GetCustomAttributeTypeName (attr, out ns, out name);
 				if (name == attrName && ns == attrNamespace)
 					return true;
 			}
 			foreach (var attr in attributesData) {
 				GetCustomAttributeTypeName (attr, out ns, out name);
 				if (name == attrName && ns == attrNamespace)
 					return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="698" endline="714">
<![CDATA[
 
 		public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
 		{
 			CheckBaked();
 			List<ConstructorInfo> list = new List<ConstructorInfo>();
 			foreach (MethodBase mb in __GetDeclaredMethods())
 			{
 				ConstructorInfo constructor = mb as ConstructorInfo;
 				if (constructor != null
 					&& BindingFlagsMatch(constructor.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(constructor.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(constructor);
 				}
 			}
 			foreach (MethodBase mb in __GetDeclaredMethods())
 			{
 				ConstructorInfo constructor = mb as ConstructorInfo;
 				if (constructor != null
 					&& BindingFlagsMatch(constructor.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(constructor.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(constructor);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="144" endline="165">
<![CDATA[
 		}
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				if (declaringType.ContainsGenericParameters)
 				{
 					return true;
 				}
 				if (methodArgs != null)
 				{
 					foreach (Type type in methodArgs)
 					{
 						if (type.ContainsGenericParameters)
 						{
 							return true;
 						}
 					}
 					foreach (Type type in methodArgs)
 					{
 						if (type.ContainsGenericParameters)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2840" endline="2859">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (iface_exprs != null) {
 				foreach (var iface in iface_exprs) {
 					if (iface.Type.IsCLSCompliant ())
 						continue;
 
 					Report.SymbolRelatedToPreviousError (iface.Type);
 					Report.Warning (3027, 1, Location, "`{0}' is not CLS-compliant because base interface `{1}' is not CLS-compliant",
 						GetSignatureForError (), TypeManager.CSharpName (iface.Type));
 				}
 				foreach (var iface in iface_exprs) {
 					if (iface.Type.IsCLSCompliant ())
 						continue;
 
 					Report.SymbolRelatedToPreviousError (iface.Type);
 					Report.Warning (3027, 1, Location, "`{0}' is not CLS-compliant because base interface `{1}' is not CLS-compliant",
 						GetSignatureForError (), TypeManager.CSharpName (iface.Type));
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1618" endline="1636">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance () || !IsExposedFromAssembly ()) {
 				return false;
 			}
 
 			if (!parameters.IsEmpty && Parent.Definition.IsAttribute) {
 				foreach (TypeSpec param in parameters.Types) {
 					if (param.IsArray) {
 						return true;
 					}
 				}
 				foreach (TypeSpec param in parameters.Types) {
 					if (param.IsArray) {
 						return true;
 					}
 				}
 			}
 
 			has_compliant_args = true;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="758" endline="780">
<![CDATA[
 		}
 
 		//
 		// Prints collected messages, common messages have a priority
 		//
 		public bool Merge (ReportPrinter dest)
 		{
 			var messages_to_print = merged_messages;
 			if (common_messages != null && common_messages.Count > 0) {
 				messages_to_print = common_messages;
 			}
 
 			if (messages_to_print == null)
 				return false;
 
 			bool error_msg = false;
 			foreach (AbstractMessage msg in messages_to_print) {
 				dest.Print (msg);
 				error_msg |= !msg.IsWarning;
 			}
 			foreach (AbstractMessage msg in messages_to_print) {
 				dest.Print (msg);
 				error_msg |= !msg.IsWarning;
 			}
 
 			return error_msg;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6186" endline="6207">
<![CDATA[
 		
 		public void UpdateIndices ()
 		{
 			int i = 0;
 			for (var probe = initializers; probe != null;) {
 				if (probe.Count > 0 && probe [0] is ArrayInitializer) {
 					Expression e = new IntConstant (probe.Count, Location.Null);
 					arguments.Add (e);
 
 					bounds [i++] = probe.Count;
 
 					probe = (ArrayInitializer) probe[0];
 					
 				} else {
 					Expression e = new IntConstant (probe.Count, Location.Null);
 					arguments.Add (e);
 
 					bounds [i++] = probe.Count;
 					return;
 				}
 			}
 			for (var probe = initializers; probe != null;) {
 				if (probe.Count > 0 && probe [0] is ArrayInitializer) {
 					Expression e = new IntConstant (probe.Count, Location.Null);
 					arguments.Add (e);
 
 					bounds [i++] = probe.Count;
 
 					probe = (ArrayInitializer) probe[0];
 					
 				} else {
 					Expression e = new IntConstant (probe.Count, Location.Null);
 					arguments.Add (e);
 
 					bounds [i++] = probe.Count;
 					return;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="652" endline="674">
<![CDATA[
 		}
 
 		public int FindSource (string file_name)
 		{
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				if (source_name_hash == null) {
 					source_name_hash = new Dictionary<string, int> ();
 
 					for (int i = 0; i < ot.SourceCount; i++) {
 						SourceFileEntry source = GetSourceFile (i + 1);
 						source_name_hash.Add (source.FileName, i);
 					}
 					for (int i = 0; i < ot.SourceCount; i++) {
 						SourceFileEntry source = GetSourceFile (i + 1);
 						source_name_hash.Add (source.FileName, i);
 					}
 				}
 
 				int value;
 				if (!source_name_hash.TryGetValue (file_name, out value))
 					return -1;
 				return value;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1129" endline="1150">
<![CDATA[
 
 		// Returns the implicit operator that converts from
 		// 'child.Type' to our target type (type)
 		MethodSpec GetConversionOperator (bool find_explicit)
 		{
 			var op = find_explicit ? Operator.OpType.Explicit 
 
 			var mi = MemberCache.GetUserOperator (child.Type, op, true);
 			if (mi == null){
 				mi = MemberCache.GetUserOperator (type, op, true);
 			}
 			
 			foreach (MethodSpec oper in mi) {
 				if (oper.ReturnType != type)
 					continue;
 
 				if (oper.Parameters.Types [0] == child.Type)
 					return oper;
 			}
 			foreach (MethodSpec oper in mi) {
 				if (oper.ReturnType != type)
 					continue;
 
 				if (oper.Parameters.Types [0] == child.Type)
 					return oper;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1226" endline="1249">
<![CDATA[
 
 		public LocalVariableEntry[] GetLocals ()
 		{
 			lock (SymbolFile) {
 				if (locals != null)
 					return locals;
 
 				if (LocalVariableTableOffset == 0)
 					return null;
 
 				MyBinaryReader reader = SymbolFile.BinaryReader;
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = LocalVariableTableOffset;
 
 				int num_locals = reader.ReadLeb128 ();
 				locals = new LocalVariableEntry [num_locals];
 
 				for (int i = 0; i < num_locals; i++)
 					locals [i] = new LocalVariableEntry (SymbolFile, reader);
 				for (int i = 0; i < num_locals; i++)
 					locals [i] = new LocalVariableEntry (SymbolFile, reader);
 
 				reader.BaseStream.Position = old_pos;
 				return locals;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="403" endline="425">
<![CDATA[
 
 		private int AddFile(ModuleBuilder manifestModule, string fileName, int flags)
 		{
 			SHA1Managed hash = new SHA1Managed();
 			string fullPath = fileName;
 			if (dir != null)
 			{
 				fullPath = Path.Combine(dir, fileName);
 			}
 			using (FileStream fs = new FileStream(fullPath, FileMode.Open, FileAccess.Read))
 			{
 				using (CryptoStream cs = new CryptoStream(Stream.Null, hash, CryptoStreamMode.Write))
 				{
 					byte[] buf = new byte[8192];
 					ModuleWriter.HashChunk(fs, cs, buf, (int)fs.Length);
 				}
 			}
 			FileTable.Record file = new FileTable.Record();
 			file.Flags = flags;
 			file.Name = manifestModule.Strings.Add(Path.GetFileName(fileName));
 			file.HashValue = manifestModule.Blobs.Add(ByteBuffer.Wrap(hash.Hash));
 			return 0x26000000 + manifestModule.File.AddRecord(file);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1250" endline="1273">
<![CDATA[
 
 		public CodeBlockEntry[] GetCodeBlocks ()
 		{
 			lock (SymbolFile) {
 				if (code_blocks != null)
 					return code_blocks;
 
 				if (CodeBlockTableOffset == 0)
 					return null;
 
 				MyBinaryReader reader = SymbolFile.BinaryReader;
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = CodeBlockTableOffset;
 
 				int num_code_blocks = reader.ReadLeb128 ();
 				code_blocks = new CodeBlockEntry [num_code_blocks];
 
 				for (int i = 0; i < num_code_blocks; i++)
 					code_blocks [i] = new CodeBlockEntry (i, reader);
 				for (int i = 0; i < num_code_blocks; i++)
 					code_blocks [i] = new CodeBlockEntry (i, reader);
 
 				reader.BaseStream.Position = old_pos;
 				return code_blocks;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1274" endline="1297">
<![CDATA[
 
 		public ScopeVariable[] GetScopeVariables ()
 		{
 			lock (SymbolFile) {
 				if (scope_vars != null)
 					return scope_vars;
 
 				if (ScopeVariableTableOffset == 0)
 					return null;
 
 				MyBinaryReader reader = SymbolFile.BinaryReader;
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = ScopeVariableTableOffset;
 
 				int num_scope_vars = reader.ReadLeb128 ();
 				scope_vars = new ScopeVariable [num_scope_vars];
 
 				for (int i = 0; i < num_scope_vars; i++)
 					scope_vars [i] = new ScopeVariable (reader);
 				for (int i = 0; i < num_scope_vars; i++)
 					scope_vars [i] = new ScopeVariable (reader);
 
 				reader.BaseStream.Position = old_pos;
 				return scope_vars;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1588" endline="1623">
<![CDATA[
 		
 		protected virtual void ComputeIndexerName ()
 		{
 			if (indexers == null)
 				return;
 
 			string class_indexer_name = null;
 
 			//
 			// If there's both an explicit and an implicit interface implementation, the
 			// explicit one actually implements the interface while the other one is just
 			// a normal indexer.  See bug #37714.
 			//
 
 			// Invariant maintained by AddIndexer()
 			foreach (Indexer i in indexers) {
 				if (i.InterfaceType != null) {
 					if (seen_normal_indexers)
 						throw new Exception ("Internal Error
 					continue;
 				}
 
 				seen_normal_indexers = true;
 
 				if (class_indexer_name == null) {
 					class_indexer_name = i.ShortName;
 					continue;
 				}
 
 				if (i.ShortName != class_indexer_name)
 					Report.Error (668, i.Location, "Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type");
 			}
 			foreach (Indexer i in indexers) {
 				if (i.InterfaceType != null) {
 					if (seen_normal_indexers)
 						throw new Exception ("Internal Error
 					continue;
 				}
 
 				seen_normal_indexers = true;
 
 				if (class_indexer_name == null) {
 					class_indexer_name = i.ShortName;
 					continue;
 				}
 
 				if (i.ShortName != class_indexer_name)
 					Report.Error (668, i.Location, "Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type");
 			}
 
 			if (class_indexer_name != null)
 				indexer_name = class_indexer_name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="902" endline="928">
<![CDATA[
 
 		//
 		// Inflates all member cache nested types
 		//
 		public void InflateTypes (MemberCache inflated_cache, TypeParameterInflator inflator)
 		{
 			foreach (var item in member_hash) {
 				IList<MemberSpec> inflated_members = null;
 				for (int i = 0; i < item.Value.Count; ++i ) {
 					var member = item.Value[i];
 
 					// FIXME
 					if (member == null)
 						continue;
 
 					if ((member.Kind & MemberKind.NestedMask) != 0 &&
 						(member.Modifiers & Modifiers.COMPILER_GENERATED) == 0) {
 						if (inflated_members == null) {
 							inflated_members = new MemberSpec[item.Value.Count];
 							inflated_cache.member_hash.Add (item.Key, inflated_members);
 						}
 
 						inflated_members [i] = member.InflateMember (inflator);
 					}
 				}
 				for (int i = 0; i < item.Value.Count; ++i ) {
 					var member = item.Value[i];
 
 					// FIXME
 					if (member == null)
 						continue;
 
 					if ((member.Kind & MemberKind.NestedMask) != 0 &&
 						(member.Modifiers & Modifiers.COMPILER_GENERATED) == 0) {
 						if (inflated_members == null) {
 							inflated_members = new MemberSpec[item.Value.Count];
 							inflated_cache.member_hash.Add (item.Key, inflated_members);
 						}
 
 						inflated_members [i] = member.InflateMember (inflator);
 					}
 				}
 			}
 			foreach (var item in member_hash) {
 				IList<MemberSpec> inflated_members = null;
 				for (int i = 0; i < item.Value.Count; ++i ) {
 					var member = item.Value[i];
 
 					// FIXME
 					if (member == null)
 						continue;
 
 					if ((member.Kind & MemberKind.NestedMask) != 0 &&
 						(member.Modifiers & Modifiers.COMPILER_GENERATED) == 0) {
 						if (inflated_members == null) {
 							inflated_members = new MemberSpec[item.Value.Count];
 							inflated_cache.member_hash.Add (item.Key, inflated_members);
 						}
 
 						inflated_members [i] = member.InflateMember (inflator);
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="88" endline="114">
<![CDATA[
 	       
 		void tokenize_file (CompilationUnit file, CompilerContext ctx)
 		{
 			Stream input;
 
 			try {
 				input = File.OpenRead (file.Name);
 			} catch {
 				Report.Error (2001, "Source file `" + file.Name + "' could not be found");
 				return;
 			}
 
 			using (input){
 				SeekableStreamReader reader = new SeekableStreamReader (input, RootContext.Encoding);
 				Tokenizer lexer = new Tokenizer (reader, file, ctx);
 				int token, tokens = 0, errors = 0;
 
 				while ((token = lexer.token ()) != Token.EOF){
 					tokens++;
 					if (token == Token.ERROR)
 						errors++;
 				}
 				while ((token = lexer.token ()) != Token.EOF){
 					tokens++;
 					if (token == Token.ERROR)
 						errors++;
 				}
 				Console.WriteLine ("Tokenized
 			}
 			
 			return;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1264" endline="1296">
<![CDATA[
 
 		//
 		// Defines the type in the appropriate ModuleBuilder or TypeBuilder.
 		//
 		public bool CreateType ()
 		{
 			if (TypeBuilder != null)
 				return !error;
 
 			if (error)
 				return false;
 
 			if (!CreateTypeBuilder ()) {
 				error = true;
 				return false;
 			}
 
 			if (partial_parts != null) {
 				foreach (TypeContainer part in partial_parts) {
 					part.spec = spec;
 					part.current_type = current_type;
 					part.TypeBuilder = TypeBuilder;
 				}
 				foreach (TypeContainer part in partial_parts) {
 					part.spec = spec;
 					part.current_type = current_type;
 					part.TypeBuilder = TypeBuilder;
 				}
 			}
 
 			if (Types != null) {
 				foreach (TypeContainer tc in Types) {
 					tc.CreateType ();
 				}
 				foreach (TypeContainer tc in Types) {
 					tc.CreateType ();
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="234" endline="273">
<![CDATA[
 
 		TypeParameterSpec[] CreateGenericParameters (MetaType type, TypeSpec declaringType)
 		{
 			var tparams = type.GetGenericArguments ();
 
 			int parent_owned_count;
 			if (type.IsNested) {
 				parent_owned_count = type.DeclaringType.GetGenericArguments ().Length;
 
 				//
 				// System.Reflection duplicates parent type parameters for each
 				// nested type with slightly modified properties (eg. different owner)
 				// This just makes things more complicated (think of cloned constraints)
 				// therefore we remap any nested type owned by parent using `type_cache'
 				// to the single TypeParameterSpec
 				//
 				if (declaringType != null && parent_owned_count > 0) {
 					int read_count = 0;
 					while (read_count != parent_owned_count) {
 						var tparams_count = declaringType.Arity;
 						if (tparams_count != 0) {
 							var parent_tp = declaringType.MemberDefinition.TypeParameters;
 							read_count += tparams_count;
 							for (int i = 0; i < tparams_count; i++) {
 								import_cache.Add (tparams[parent_owned_count - read_count + i], parent_tp[i]);
 							}
 							for (int i = 0; i < tparams_count; i++) {
 								import_cache.Add (tparams[parent_owned_count - read_count + i], parent_tp[i]);
 							}
 						}
 
 						declaringType = declaringType.DeclaringType;
 					}
 					while (read_count != parent_owned_count) {
 						var tparams_count = declaringType.Arity;
 						if (tparams_count != 0) {
 							var parent_tp = declaringType.MemberDefinition.TypeParameters;
 							read_count += tparams_count;
 							for (int i = 0; i < tparams_count; i++) {
 								import_cache.Add (tparams[parent_owned_count - read_count + i], parent_tp[i]);
 							}
 						}
 
 						declaringType = declaringType.DeclaringType;
 					}
 				}			
 			} else {
 				parent_owned_count = 0;
 			}
 
 			if (tparams.Length - parent_owned_count == 0)
 				return null;
 
 			return CreateGenericParameters (parent_owned_count, tparams);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="794" endline="831">
<![CDATA[
 
 #if !SMCS_SOURCE
 		public static string GetPackageFlags (string packages, bool fatal, Report report)
 		{
 			ProcessStartInfo pi = new ProcessStartInfo ();
 			pi.FileName = "pkg-config";
 			pi.RedirectStandardOutput = true;
 			pi.UseShellExecute = false;
 			pi.Arguments = "--libs " + packages;
 			Process p = null;
 			try {
 				p = Process.Start (pi);
 			} catch (Exception e) {
 				report.Error (-27, "Couldn't run pkg-config
 				if (fatal)
 					Environment.Exit (1);
 				p.Close ();
 				return null;
 			}
 			
 			if (p.StandardOutput == null){
 				report.Warning (-27, 1, "Specified package did not return any information");
 				p.Close ();
 				return null;
 			}
 			string pkgout = p.StandardOutput.ReadToEnd ();
 			p.WaitForExit ();
 			if (p.ExitCode != 0) {
 				report.Error (-27, "Error running pkg-config. Check the above output.");
 				if (fatal)
 					Environment.Exit (1);
 				p.Close ();
 				return null;
 			}
 			p.Close ();
 
 			return pkgout;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="440" endline="482">
<![CDATA[
 
 		//
 		// Finds the nested type in container
 		//
 		public static TypeSpec FindNestedType (TypeSpec container, string name, int arity)
 		{
 			IList<MemberSpec> applicable;
 			TypeSpec best_match = null;
 			do {
 				// TODO
 				// When resolving base type of nested type, parent type must have
 				// base type resolved to scan full hierarchy correctly
 				// Similarly MemberCacheTypes will inflate BaseType and Interfaces
 				// based on type definition
 				var tc = container.MemberDefinition as TypeContainer;
 				if (tc != null)
 					tc.DefineType ();
 
 				if (container.MemberCacheTypes.member_hash.TryGetValue (name, out applicable)) {
 					for (int i = applicable.Count - 1; i >= 0; i--) {
 						var entry = applicable[i];
 						if ((entry.Kind & MemberKind.NestedMask) == 0)
 							continue;
 
 						var ts = (TypeSpec) entry;
 						if (arity == ts.Arity)
 							return ts;
 
 						if (arity < 0) {
 							if (best_match == null) {
 								best_match = ts;
 							} else if (System.Math.Abs (ts.Arity + arity) < System.Math.Abs (ts.Arity + arity)) {
 								best_match = ts;
 							}
 						}
 					}
 					for (int i = applicable.Count - 1; i >= 0; i--) {
 						var entry = applicable[i];
 						if ((entry.Kind & MemberKind.NestedMask) == 0)
 							continue;
 
 						var ts = (TypeSpec) entry;
 						if (arity == ts.Arity)
 							return ts;
 
 						if (arity < 0) {
 							if (best_match == null) {
 								best_match = ts;
 							} else if (System.Math.Abs (ts.Arity + arity) < System.Math.Abs (ts.Arity + arity)) {
 								best_match = ts;
 							}
 						}
 					}
 				}
 
 				container = container.BaseType;
 			} while (container != null);
 
 			return best_match;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="532" endline="561">
<![CDATA[
 
 		public FieldInfo[] GetFields(BindingFlags bindingAttr)
 		{
 			List<FieldInfo> list = new List<FieldInfo>();
 			CheckBaked();
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (BindingFlagsMatch(field.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(field);
 				}
 			}
 			foreach (FieldInfo field in __GetDeclaredFields())
 			{
 				if (BindingFlagsMatch(field.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(field);
 				}
 			}
 			if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 			{
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (FieldInfo field in type.__GetDeclaredFields())
 					{
 						if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
 							&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
 						{
 							list.Add(field);
 						}
 					}
 					foreach (FieldInfo field in type.__GetDeclaredFields())
 					{
 						if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
 							&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
 						{
 							list.Add(field);
 						}
 					}
 				}
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (FieldInfo field in type.__GetDeclaredFields())
 					{
 						if ((field.Attributes & FieldAttributes.FieldAccessMask) > FieldAttributes.Private
 							&& BindingFlagsMatch(field.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance))
 						{
 							list.Add(field);
 						}
 					}
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1380" endline="1421">
<![CDATA[
 
 		public bool IsAssigned (MyBitVector vector)
 		{
 			if (vector == null)
 				return true;
 
 			if (vector [Offset])
 				return true;
 
 			// FIXME
 			for (VariableInfo parent = Parent; parent != null; parent = parent.Parent) {
 				if (vector [parent.Offset]) {
 					// 'parent' is assigned, but someone forgot to note that all its components are assigned too
 					parent.SetAssigned (vector);
 					return true;
 				}
 			}
 			for (VariableInfo parent = Parent; parent != null; parent = parent.Parent) {
 				if (vector [parent.Offset]) {
 					// 'parent' is assigned, but someone forgot to note that all its components are assigned too
 					parent.SetAssigned (vector);
 					return true;
 				}
 			}
 
 			// Return unless this is a struct.
 			if (!TypeInfo.IsStruct)
 				return false;
 
 			// Ok, so each field must be assigned.
 			for (int i = 0; i < TypeInfo.Length; i++) {
 				if (!vector [Offset + i + 1])
 					return false;
 			}
 			for (int i = 0; i < TypeInfo.Length; i++) {
 				if (!vector [Offset + i + 1])
 					return false;
 			}
 
 			// Ok, now check all fields which are structs.
 			for (int i = 0; i < sub_info.Length; i++) {
 				VariableInfo sinfo = sub_info [i];
 				if (sinfo == null)
 					continue;
 
 				if (!sinfo.IsAssigned (vector))
 					return false;
 			}
 			for (int i = 0; i < sub_info.Length; i++) {
 				VariableInfo sinfo = sub_info [i];
 				if (sinfo == null)
 					continue;
 
 				if (!sinfo.IsAssigned (vector))
 					return false;
 			}
 
 			vector [Offset] = true;
 			is_ever_assigned = true;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="342" endline="388">
<![CDATA[
 		}
 
 		public Location Location { get; private set; }
 
 		public string Name { get; private set; }
 
 		#endregion
 
 		public Expression CreateReferenceExpression (ResolveContext rc, Location loc)
 		{
 			// 
 			// We know the variable name is somewhere in the scope. This generates
 			// an access expression from current block
 			//
 			var pb = rc.CurrentBlock.ParametersBlock;
 			while (true) {
 				if (pb is QueryBlock) {
 					for (int i = pb.Parameters.Count - 1; i >= 0; --i) {
 						var p = pb.Parameters[i];
 						if (p.Name == Name)
 							return pb.GetParameterReference (i, loc);
 
 						Expression expr = null;
 						var tp = p as QueryBlock.TransparentParameter;
 						while (tp != null) {
 							if (expr == null)
 								expr = pb.GetParameterReference (i, loc);
 							else
 								expr = new TransparentMemberAccess (expr, tp.Name);
 
 							if (tp.Identifier == Name)
 								return new TransparentMemberAccess (expr, Name);
 
 							if (tp.Parent.Name == Name)
 								return new TransparentMemberAccess (expr, Name);
 
 							tp = tp.Parent as QueryBlock.TransparentParameter;
 						}
 						while (tp != null) {
 							if (expr == null)
 								expr = pb.GetParameterReference (i, loc);
 							else
 								expr = new TransparentMemberAccess (expr, tp.Name);
 
 							if (tp.Identifier == Name)
 								return new TransparentMemberAccess (expr, Name);
 
 							if (tp.Parent.Name == Name)
 								return new TransparentMemberAccess (expr, Name);
 
 							tp = tp.Parent as QueryBlock.TransparentParameter;
 						}
 					}
 					for (int i = pb.Parameters.Count - 1; i >= 0; --i) {
 						var p = pb.Parameters[i];
 						if (p.Name == Name)
 							return pb.GetParameterReference (i, loc);
 
 						Expression expr = null;
 						var tp = p as QueryBlock.TransparentParameter;
 						while (tp != null) {
 							if (expr == null)
 								expr = pb.GetParameterReference (i, loc);
 							else
 								expr = new TransparentMemberAccess (expr, tp.Name);
 
 							if (tp.Identifier == Name)
 								return new TransparentMemberAccess (expr, Name);
 
 							if (tp.Parent.Name == Name)
 								return new TransparentMemberAccess (expr, Name);
 
 							tp = tp.Parent as QueryBlock.TransparentParameter;
 						}
 					}
 				}
 
 				if (pb == block)
 					return null;
 
 				pb = pb.Parent.ParametersBlock;
 			}
 			while (true) {
 				if (pb is QueryBlock) {
 					for (int i = pb.Parameters.Count - 1; i >= 0; --i) {
 						var p = pb.Parameters[i];
 						if (p.Name == Name)
 							return pb.GetParameterReference (i, loc);
 
 						Expression expr = null;
 						var tp = p as QueryBlock.TransparentParameter;
 						while (tp != null) {
 							if (expr == null)
 								expr = pb.GetParameterReference (i, loc);
 							else
 								expr = new TransparentMemberAccess (expr, tp.Name);
 
 							if (tp.Identifier == Name)
 								return new TransparentMemberAccess (expr, Name);
 
 							if (tp.Parent.Name == Name)
 								return new TransparentMemberAccess (expr, Name);
 
 							tp = tp.Parent as QueryBlock.TransparentParameter;
 						}
 					}
 				}
 
 				if (pb == block)
 					return null;
 
 				pb = pb.Parent.ParametersBlock;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1462" endline="1498">
<![CDATA[
 
 		public bool IsFriendAssemblyTo (IAssemblyDefinition assembly)
 		{
 			if (internals_visible_to == null)
 				return false;
 
 			AssemblyName is_visible = null;
 			if (internals_visible_to_cache == null) {
 				internals_visible_to_cache = new Dictionary<IAssemblyDefinition, AssemblyName> ();
 			} else {
 				if (internals_visible_to_cache.TryGetValue (assembly, out is_visible))
 					return is_visible != null;
 			}
 
 			var token = assembly.GetPublicKeyToken ();
 			if (token != null && token.Length == 0)
 				token = null;
 
 			foreach (var internals in internals_visible_to) {
 				if (internals.Name != assembly.Name)
 					continue;
 
 				if (token == null && assembly is AssemblyDefinition) {
 					is_visible = internals;
 					break;
 				}
 
 				if (!ArrayComparer.IsEqual (token, internals.GetPublicKeyToken ()))
 					continue;
 
 				is_visible = internals;
 				break;
 			foreach (var internals in internals_visible_to) {
 				if (internals.Name != assembly.Name)
 					continue;
 
 				if (token == null && assembly is AssemblyDefinition) {
 					is_visible = internals;
 					break;
 				}
 
 				if (!ArrayComparer.IsEqual (token, internals.GetPublicKeyToken ()))
 					continue;
 
 				is_visible = internals;
 				break;
 			}
 
 			internals_visible_to_cache.Add (assembly, is_visible);
 			return is_visible != null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="651" endline="677">
<![CDATA[
 
 		internal void FillAssemblyRefTable()
 		{
 			int[] realtokens = new int[referencedAssemblies.Count];
 			foreach (KeyValuePair<Assembly, int> kv in referencedAssemblies)
 			{
 				realtokens[(kv.Value & 0x7FFFFF) - 1] = FindOrAddAssemblyRef(kv.Key.GetName());
 			}
 			foreach (KeyValuePair<Assembly, int> kv in referencedAssemblies)
 			{
 				realtokens[(kv.Value & 0x7FFFFF) - 1] = FindOrAddAssemblyRef(kv.Key.GetName());
 			}
 			// now fixup the resolution scopes in TypeRef
 			for (int i = 0; i < this.TypeRef.records.Length; i++)
 			{
 				int resolutionScope = this.TypeRef.records[i].ResolutionScope;
 				if ((resolutionScope >> 24) == AssemblyRefTable.Index)
 				{
 					this.TypeRef.records[i].ResolutionScope = realtokens[(resolutionScope & 0x7FFFFF) - 1];
 				}
 			}
 			for (int i = 0; i < this.TypeRef.records.Length; i++)
 			{
 				int resolutionScope = this.TypeRef.records[i].ResolutionScope;
 				if ((resolutionScope >> 24) == AssemblyRefTable.Index)
 				{
 					this.TypeRef.records[i].ResolutionScope = realtokens[(resolutionScope & 0x7FFFFF) - 1];
 				}
 			}
 			// and implementation in ExportedType
 			for (int i = 0; i < this.ExportedType.records.Length; i++)
 			{
 				int implementation = this.ExportedType.records[i].Implementation;
 				if ((implementation >> 24) == AssemblyRefTable.Index)
 				{
 					this.ExportedType.records[i].Implementation = realtokens[(implementation & 0x7FFFFF) - 1];
 				}
 			}
 			for (int i = 0; i < this.ExportedType.records.Length; i++)
 			{
 				int implementation = this.ExportedType.records[i].Implementation;
 				if ((implementation >> 24) == AssemblyRefTable.Index)
 				{
 					this.ExportedType.records[i].Implementation = realtokens[(implementation & 0x7FFFFF) - 1];
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1499" endline="1537">
<![CDATA[
 
 		public void ReadAttributes ()
 		{
 			IList<CustomAttributeData> attrs = CustomAttributeData.GetCustomAttributes (assembly);
 
 			string ns, name;
 			foreach (var a in attrs) {
 				importer.GetCustomAttributeTypeName (a, out ns, out name);
 
 				if (name == "CLSCompliantAttribute") {
 					if (ns == "System")
 						cls_compliant = (bool) a.ConstructorArguments[0].Value;
 					continue;
 				}
 
 				if (name == "InternalsVisibleToAttribute") {
 					if (ns != MetadataImporter.CompilerServicesNamespace)
 						continue;
 
 					string s = a.ConstructorArguments[0].Value as string;
 					if (s == null)
 						continue;
 
 					var an = new AssemblyName (s);
 					if (internals_visible_to == null)
 						internals_visible_to = new List<AssemblyName> ();
 
 					internals_visible_to.Add (an);
 					continue;
 				}
 
 				if (name == "ExtensionAttribute") {
 					if (ns == MetadataImporter.CompilerServicesNamespace)
 						contains_extension_methods = true;
 
 					continue;
 				}
 			}
 			foreach (var a in attrs) {
 				importer.GetCustomAttributeTypeName (a, out ns, out name);
 
 				if (name == "CLSCompliantAttribute") {
 					if (ns == "System")
 						cls_compliant = (bool) a.ConstructorArguments[0].Value;
 					continue;
 				}
 
 				if (name == "InternalsVisibleToAttribute") {
 					if (ns != MetadataImporter.CompilerServicesNamespace)
 						continue;
 
 					string s = a.ConstructorArguments[0].Value as string;
 					if (s == null)
 						continue;
 
 					var an = new AssemblyName (s);
 					if (internals_visible_to == null)
 						internals_visible_to = new List<AssemblyName> ();
 
 					internals_visible_to.Add (an);
 					continue;
 				}
 
 				if (name == "ExtensionAttribute") {
 					if (ns == MetadataImporter.CompilerServicesNamespace)
 						contains_extension_methods = true;
 
 					continue;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="275" endline="325">
<![CDATA[
 
 		/// <summary>
 		///   Tries to resolve the type of the attribute. Flags an error if it can't, and complain is true.
 		/// </summary>
 		void ResolveAttributeType ()
 		{
 			SessionReportPrinter resolve_printer = new SessionReportPrinter ();
 			ReportPrinter prev_recorder = context.Compiler.Report.SetPrinter (resolve_printer);
 
 			bool t1_is_attr = false;
 			bool t2_is_attr = false;
 			TypeSpec t1, t2;
 			ATypeNameExpression expanded = null;
 
 			try {
 				t1 = ResolvePossibleAttributeType (expression, ref t1_is_attr);
 
 				if (nameEscaped) {
 					t2 = null;
 				} else {
 					expanded = (ATypeNameExpression) expression.Clone (null);
 					expanded.Name += "Attribute";
 
 					t2 = ResolvePossibleAttributeType (expanded, ref t2_is_attr);
 				}
 
 				resolve_printer.EndSession ();
 			} finally {
 				context.Compiler.Report.SetPrinter (prev_recorder);
 			}
 
 			if (t1_is_attr && t2_is_attr) {
 				Report.Error (1614, Location, "`{0}' is ambiguous between `{1}' and `{2}'. Use either `@{0}' or `{0}Attribute'",
 					GetSignatureForError (), expression.GetSignatureForError (), expanded.GetSignatureForError ());
 				resolve_error = true;
 				return;
 			}
 
 			if (t1_is_attr) {
 				Type = t1;
 				return;
 			}
 
 			if (t2_is_attr) {
 				Type = t2;
 				return;
 			}
 
 			resolve_printer.Merge (prev_recorder);
 			resolve_error = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="132" endline="173">
<![CDATA[
 
 		internal static void ReadDeclarativeSecurity(Assembly asm, List<CustomAttributeData> list, int action, ByteReader br)
 		{
 			Universe u = asm.universe;
 			if (br.PeekByte() == '.')
 			{
 				br.ReadByte();
 				int count = br.ReadCompressedInt();
 				for (int j = 0; j < count; j++)
 				{
 					Type type = ReadType(asm, br);
 					ConstructorInfo constructor;
 					if (type == u.System_Security_Permissions_HostProtectionAttribute && action == (int)System.Security.Permissions.SecurityAction.LinkDemand)
 					{
 						constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, Type.EmptyTypes, null);
 					}
 					else
 					{
 						constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { u.System_Security_Permissions_SecurityAction }, null);
 					}
 					// LAMESPEC there is an additional length here (probably of the named argument list)
 					ByteReader slice = br.Slice(br.ReadCompressedInt());
 					// LAMESPEC the count of named arguments is a compressed integer (instead of UInt16 as NumNamed in custom attributes)
 					list.Add(new CustomAttributeData(constructor, action, ReadNamedArguments(asm, slice, slice.ReadCompressedInt(), type)));
 				}
 				for (int j = 0; j < count; j++)
 				{
 					Type type = ReadType(asm, br);
 					ConstructorInfo constructor;
 					if (type == u.System_Security_Permissions_HostProtectionAttribute && action == (int)System.Security.Permissions.SecurityAction.LinkDemand)
 					{
 						constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, Type.EmptyTypes, null);
 					}
 					else
 					{
 						constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { u.System_Security_Permissions_SecurityAction }, null);
 					}
 					// LAMESPEC there is an additional length here (probably of the named argument list)
 					ByteReader slice = br.Slice(br.ReadCompressedInt());
 					// LAMESPEC the count of named arguments is a compressed integer (instead of UInt16 as NumNamed in custom attributes)
 					list.Add(new CustomAttributeData(constructor, action, ReadNamedArguments(asm, slice, slice.ReadCompressedInt(), type)));
 				}
 			}
 			else
 			{
 				// .NET 1.x format (xml)
 				char[] buf = new char[br.Length / 2];
 				for (int i = 0; i < buf.Length; i++)
 				{
 					buf[i] = br.ReadChar();
 				}
 				for (int i = 0; i < buf.Length; i++)
 				{
 					buf[i] = br.ReadChar();
 				}
 				string xml = new String(buf);
 				ConstructorInfo constructor = u.System_Security_Permissions_PermissionSetAttribute.GetConstructor(new Type[] { u.System_Security_Permissions_SecurityAction });
 				List<CustomAttributeNamedArgument> args = new List<CustomAttributeNamedArgument>();
 				args.Add(new CustomAttributeNamedArgument(u.System_Security_Permissions_PermissionSetAttribute.GetProperty("XML"),
 					new CustomAttributeTypedArgument(u.System_String, xml)));
 				list.Add(new CustomAttributeData(constructor, action, args));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="703" endline="752">
<![CDATA[
 
 		public void EndSession ()
 		{
 			if (session_messages == null)
 				return;
 
 			//
 			// Handles the first session
 			//
 			if (common_messages == null) {
 				common_messages = new List<AbstractMessage> (session_messages);
 				merged_messages = session_messages;
 				session_messages = null;
 				return;
 			}
 
 			//
 			// Store common messages if any
 			//
 			for (int i = 0; i < common_messages.Count; ++i) {
 				AbstractMessage cmsg = common_messages[i];
 				bool common_msg_found = false;
 				foreach (AbstractMessage msg in session_messages) {
 					if (cmsg.Equals (msg)) {
 						common_msg_found = true;
 						break;
 					}
 				}
 				foreach (AbstractMessage msg in session_messages) {
 					if (cmsg.Equals (msg)) {
 						common_msg_found = true;
 						break;
 					}
 				}
 
 				if (!common_msg_found)
 					common_messages.RemoveAt (i);
 			}
 			for (int i = 0; i < common_messages.Count; ++i) {
 				AbstractMessage cmsg = common_messages[i];
 				bool common_msg_found = false;
 				foreach (AbstractMessage msg in session_messages) {
 					if (cmsg.Equals (msg)) {
 						common_msg_found = true;
 						break;
 					}
 				}
 
 				if (!common_msg_found)
 					common_messages.RemoveAt (i);
 			}
 
 			//
 			// Merge session and previous messages
 			//
 			for (int i = 0; i < session_messages.Count; ++i) {
 				AbstractMessage msg = session_messages[i];
 				bool msg_found = false;
 				for (int ii = 0; ii < merged_messages.Count; ++ii) {
 					if (msg.Equals (merged_messages[ii])) {
 						msg_found = true;
 						break;
 					}
 				}
 				for (int ii = 0; ii < merged_messages.Count; ++ii) {
 					if (msg.Equals (merged_messages[ii])) {
 						msg_found = true;
 						break;
 					}
 				}
 
 				if (!msg_found)
 					merged_messages.Add (msg);
 			}
 			for (int i = 0; i < session_messages.Count; ++i) {
 				AbstractMessage msg = session_messages[i];
 				bool msg_found = false;
 				for (int ii = 0; ii < merged_messages.Count; ++ii) {
 					if (msg.Equals (merged_messages[ii])) {
 						msg_found = true;
 						break;
 					}
 				}
 
 				if (!msg_found)
 					merged_messages.Add (msg);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1187" endline="1229">
<![CDATA[
 
 		public void __Save(PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine)
 		{
 			PopulatePropertyAndEventTables();
 			IList<CustomAttributeData> attributes = asm.GetCustomAttributesData(null);
 			if (attributes.Count > 0)
 			{
 				int mscorlib = ImportAssemblyRef(universe.Mscorlib);
 				int[] placeholderTokens = new int[4];
 				string[] placeholderTypeNames = new string[] { "AssemblyAttributesGoHere", "AssemblyAttributesGoHereM", "AssemblyAttributesGoHereS", "AssemblyAttributesGoHereSM" };
 				foreach (CustomAttributeData cad in attributes)
 				{
 					int index;
 					if (cad.Constructor.DeclaringType.BaseType == universe.System_Security_Permissions_CodeAccessSecurityAttribute)
 					{
 						if (cad.Constructor.DeclaringType.IsAllowMultipleCustomAttribute)
 						{
 							index = 3;
 						}
 						else
 						{
 							index = 2;
 						}
 					}
 					else if (cad.Constructor.DeclaringType.IsAllowMultipleCustomAttribute)
 					{
 						index = 1;
 					}
 					else
 					{
 						index = 0;
 					}
 					if (placeholderTokens[index] == 0)
 					{
 						// we manually add a TypeRef without looking it up in mscorlib, because Mono and Silverlight's mscorlib don't have these types
 						placeholderTokens[index] = AddTypeRefByName(mscorlib, "System.Runtime.CompilerServices", placeholderTypeNames[index]);
 					}
 					SetCustomAttribute(placeholderTokens[index], cad.__ToBuilder());
 				}
 				foreach (CustomAttributeData cad in attributes)
 				{
 					int index;
 					if (cad.Constructor.DeclaringType.BaseType == universe.System_Security_Permissions_CodeAccessSecurityAttribute)
 					{
 						if (cad.Constructor.DeclaringType.IsAllowMultipleCustomAttribute)
 						{
 							index = 3;
 						}
 						else
 						{
 							index = 2;
 						}
 					}
 					else if (cad.Constructor.DeclaringType.IsAllowMultipleCustomAttribute)
 					{
 						index = 1;
 					}
 					else
 					{
 						index = 0;
 					}
 					if (placeholderTokens[index] == 0)
 					{
 						// we manually add a TypeRef without looking it up in mscorlib, because Mono and Silverlight's mscorlib don't have these types
 						placeholderTokens[index] = AddTypeRefByName(mscorlib, "System.Runtime.CompilerServices", placeholderTypeNames[index]);
 					}
 					SetCustomAttribute(placeholderTokens[index], cad.__ToBuilder());
 				}
 			}
 			FillAssemblyRefTable();
 			ModuleWriter.WriteModule(null, null, this, PEFileKinds.Dll, portableExecutableKind, imageFileMachine, unmanagedResources, 0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1153" endline="1203">
<![CDATA[
 
 		//
 		// Emits the code
 		// 
 		public override void Emit ()
 		{
 			try {
 				if (IsPartialDefinition) {
 					//
 					// Use partial method implementation builder for partial method declaration attributes
 					//
 					if (partialMethodImplementation != null) {
 						MethodBuilder = partialMethodImplementation.MethodBuilder;
 					}
 
 					return;
 				}
 				
 				if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.PartialDefinitionExists) == 0) {
 					Report.Error (759, Location, "A partial method `{0}' implementation is missing a partial method declaration",
 						GetSignatureForError ());
 				}
 
 				if (CurrentTypeParameters != null) {
 					var ge = type_expr as GenericTypeExpr;
 					if (ge != null)
 						ge.CheckConstraints (this);
 
 					foreach (Parameter p in parameters.FixedParameters) {
 						ge = p.TypeExpression as GenericTypeExpr;
 						if (ge != null)
 							ge.CheckConstraints (this);
 					}
 					foreach (Parameter p in parameters.FixedParameters) {
 						ge = p.TypeExpression as GenericTypeExpr;
 						if (ge != null)
 							ge.CheckConstraints (this);
 					}
 
 					for (int i = 0; i < CurrentTypeParameters.Length; ++i) {
 						var tp = CurrentTypeParameters [i];
 						tp.CheckGenericConstraints ();
 						tp.Emit ();
 					}
 					for (int i = 0; i < CurrentTypeParameters.Length; ++i) {
 						var tp = CurrentTypeParameters [i];
 						tp.CheckGenericConstraints ();
 						tp.Emit ();
 					}
 				}
 
 				base.Emit ();
 				
 				if ((ModFlags & Modifiers.METHOD_EXTENSION) != 0)
 					Module.PredefinedAttributes.Extension.EmitAttribute (MethodBuilder);
 			} catch {
 				Console.WriteLine ("Internal compiler error at {0}
 						   Location, MethodBuilder);
 				throw;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2052" endline="2110">
<![CDATA[
 
 		//
 		// When any element of the type is a dynamic type
 		//
 		// This method builds a transformation array for dynamic types
 		// used in places where DynamicAttribute cannot be applied to.
 		// It uses bool flag when type is of dynamic type and each
 		// section always starts with "false" for some reason.
 		//
 		// LAMESPEC
 		// 
 		// Example
 		// Transformation
 		//
 		static bool[] GetTransformationFlags (TypeSpec t)
 		{
 			bool[] element;
 			var ac = t as ArrayContainer;
 			if (ac != null) {
 				element = GetTransformationFlags (ac.Element);
 				if (element == null)
 					return null;
 
 				bool[] res = new bool[element.Length + 1];
 				res[0] = false;
 				Array.Copy (element, 0, res, 1, element.Length);
 				return res;
 			}
 
 			if (t == null)
 				return null;
 
 			if (t.IsGeneric) {
 				List<bool> transform = null;
 				var targs = t.TypeArguments;
 				for (int i = 0; i < targs.Length; ++i) {
 					element = GetTransformationFlags (targs[i]);
 					if (element != null) {
 						if (transform == null) {
 							transform = new List<bool> ();
 							for (int ii = 0; ii <= i; ++ii)
 								transform.Add (false);
 							for (int ii = 0; ii <= i; ++ii)
 								transform.Add (false);
 						}
 
 						transform.AddRange (element);
 					} else if (transform != null) {
 						transform.Add (false);
 					}
 				}
 				for (int i = 0; i < targs.Length; ++i) {
 					element = GetTransformationFlags (targs[i]);
 					if (element != null) {
 						if (transform == null) {
 							transform = new List<bool> ();
 							for (int ii = 0; ii <= i; ++ii)
 								transform.Add (false);
 						}
 
 						transform.AddRange (element);
 					} else if (transform != null) {
 						transform.Add (false);
 					}
 				}
 
 				if (transform != null)
 					return transform.ToArray ();
 			}
 
 			if (t == InternalType.Dynamic)
 				return new bool[] { true };
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="42" endline="83">
<![CDATA[
 
 		protected void CheckReservedNameConflict (string prefix, MethodSpec accessor)
 		{
 			string name;
 			AParametersCollection parameters;
 			if (accessor != null) {
 				name = accessor.Name;
 				parameters = accessor.Parameters;
 			} else {
 				name = prefix + ShortName;
 				if (IsExplicitImpl)
 					name = MemberName.Left + "." + name;
 
 				if (this is Indexer) {
 					parameters = ((Indexer) this).ParameterInfo;
 					if (prefix[0] == 's') {
 						var data = new IParameterData[parameters.Count + 1];
 						Array.Copy (parameters.FixedParameters, data, data.Length - 1);
 						data[data.Length - 1] = new ParameterData ("value", Parameter.Modifier.NONE);
 						var types = new TypeSpec[data.Length];
 						Array.Copy (parameters.Types, types, data.Length - 1);
 						types[data.Length - 1] = member_type;
 
 						parameters = new ParametersImported (data, types, false);
 					}
 				} else {
 					if (prefix[0] == 's')
 						parameters = ParametersCompiled.CreateFullyResolved (new[] { member_type });
 					else
 						parameters = ParametersCompiled.EmptyReadOnlyParameters;
 				}
 			}
 
 			var conflict = MemberCache.FindMember (Parent.Definition,
 				new MemberFilter (name, 0, MemberKind.Method, parameters, null),
 				BindingRestriction.DeclaredOnly | BindingRestriction.NoAccessors);
 
 			if (conflict != null) {
 				Report.SymbolRelatedToPreviousError (conflict);
 				Report.Error (82, Location, "A member `{0}' is already reserved", conflict.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1683" endline="1737">
<![CDATA[
 
 		public virtual void VerifyMembers ()
 		{
 			//
 			// Check for internal or private fields that were never assigned
 			//
 			if (Report.WarningLevel >= 3) {
 				if (RootContext.EnhancedWarnings) {
 					CheckMemberUsage (properties, "property");
 					CheckMemberUsage (methods, "method");
 					CheckMemberUsage (constants, "constant");
 				}
 
 				if (fields != null){
 					bool is_type_exposed = Kind == MemberKind.Struct || IsExposedFromAssembly ();
 					foreach (FieldBase f in fields) {
 						if ((f.ModFlags & Modifiers.AccessibilityMask) != Modifiers.PRIVATE) {
 							if (is_type_exposed)
 								continue;
 
 							f.SetIsUsed ();
 						}				
 						
 						if (!f.IsUsed){
 							if ((f.caching_flags & Flags.IsAssigned) == 0)
 								Report.Warning (169, 3, f.Location, "The private field `{0}' is never used", f.GetSignatureForError ());
 							else {
 								Report.Warning (414, 3, f.Location, "The private field `{0}' is assigned but its value is never used",
 									f.GetSignatureForError ());
 							}
 							continue;
 						}
 						
 						//
 						// Only report 649 on level 4
 						//
 						if (Report.WarningLevel < 4)
 							continue;
 						
 						if ((f.caching_flags & Flags.IsAssigned) != 0)
 							continue;
 
 						//
 						// Don't be pendatic over serializable attributes
 						//
 						if (f.OptAttributes != null || PartialContainer.HasStructLayout)
 							continue;
 						
 						Constant c = New.Constantify (f.MemberType, f.Location);
 						Report.Warning (649, 4, f.Location, "Field `{0}' is never assigned to, and will always have its default value `{1}'",
 							f.GetSignatureForError (), c == null ? "null" 
 					}
 					foreach (FieldBase f in fields) {
 						if ((f.ModFlags & Modifiers.AccessibilityMask) != Modifiers.PRIVATE) {
 							if (is_type_exposed)
 								continue;
 
 							f.SetIsUsed ();
 						}				
 						
 						if (!f.IsUsed){
 							if ((f.caching_flags & Flags.IsAssigned) == 0)
 								Report.Warning (169, 3, f.Location, "The private field `{0}' is never used", f.GetSignatureForError ());
 							else {
 								Report.Warning (414, 3, f.Location, "The private field `{0}' is assigned but its value is never used",
 									f.GetSignatureForError ());
 							}
 							continue;
 						}
 						
 						//
 						// Only report 649 on level 4
 						//
 						if (Report.WarningLevel < 4)
 							continue;
 						
 						if ((f.caching_flags & Flags.IsAssigned) != 0)
 							continue;
 
 						//
 						// Don't be pendatic over serializable attributes
 						//
 						if (f.OptAttributes != null || PartialContainer.HasStructLayout)
 							continue;
 						
 						Constant c = New.Constantify (f.MemberType, f.Location);
 						Report.Warning (649, 4, f.Location, "Field `{0}' is never assigned to, and will always have its default value `{1}'",
 							f.GetSignatureForError (), c == null ? "null" 
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\TypeNameParser.cs" startline="395" endline="456">
<![CDATA[
 
 		internal Type Expand(Type type, Assembly context, bool throwOnError, string originalName)
 		{
 			if (type == null)
 			{
 				if (throwOnError)
 				{
 					throw new TypeLoadException(originalName);
 				}
 				return null;
 			}
 			if (nested != null)
 			{
 				foreach (string nest in nested)
 				{
 					type = type.GetNestedType(nest, BindingFlags.Public | BindingFlags.NonPublic);
 					if (type == null)
 					{
 						if (throwOnError)
 						{
 							throw new TypeLoadException(originalName);
 						}
 						return null;
 					}
 				}
 				foreach (string nest in nested)
 				{
 					type = type.GetNestedType(nest, BindingFlags.Public | BindingFlags.NonPublic);
 					if (type == null)
 					{
 						if (throwOnError)
 						{
 							throw new TypeLoadException(originalName);
 						}
 						return null;
 					}
 				}
 			}
 			if (genericParameters != null)
 			{
 				Type[] typeArgs = new Type[genericParameters.Length];
 				for (int i = 0; i < typeArgs.Length; i++)
 				{
 					typeArgs[i] = genericParameters[i].GetType(type.Assembly.universe, context, throwOnError, originalName);
 					if (typeArgs[i] == null)
 					{
 						return null;
 					}
 				}
 				for (int i = 0; i < typeArgs.Length; i++)
 				{
 					typeArgs[i] = genericParameters[i].GetType(type.Assembly.universe, context, throwOnError, originalName);
 					if (typeArgs[i] == null)
 					{
 						return null;
 					}
 				}
 				type = type.MakeGenericType(typeArgs);
 			}
 			if (modifiers != null)
 			{
 				foreach (short modifier in modifiers)
 				{
 					switch (modifier)
 					{
 						case SZARRAY
 							type = type.MakeArrayType();
 							break;
 						case BYREF
 							type = type.MakeByRefType();
 							break;
 						case POINTER
 							type = type.MakePointerType();
 							break;
 						default
 							type = type.MakeArrayType(modifier);
 							break;
 					}
 				}
 				foreach (short modifier in modifiers)
 				{
 					switch (modifier)
 					{
 						case SZARRAY
 							type = type.MakeArrayType();
 							break;
 						case BYREF
 							type = type.MakeByRefType();
 							break;
 						case POINTER
 							type = type.MakePointerType();
 							break;
 						default
 							type = type.MakeArrayType(modifier);
 							break;
 					}
 				}
 			}
 			return type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="230" endline="288">
<![CDATA[
 		}
 
 		Assembly AssemblyReferenceResolver (object sender, IKVM.Reflection.ResolveEventArgs args)
 		{
 			var refname = args.Name;
 			if (refname == "mscorlib")
 				return corlib;
 
 			Assembly version_mismatch = null;
 			foreach (var assembly in domain.GetAssemblies ()) {
 				// TODO
 				if (assembly is AssemblyBuilder)
 					continue;
 
 				AssemblyComparisonResult result;
 				if (!Fusion.CompareAssemblyIdentityPure (refname, false, assembly.FullName, false, out result)) {
 					if ((result == AssemblyComparisonResult.NonEquivalentVersion || result == AssemblyComparisonResult.NonEquivalentPartialVersion) &&
 						(version_mismatch == null || version_mismatch.GetName ().Version < assembly.GetName ().Version)) {
 						version_mismatch = assembly;
 					}
 
 					continue;
 				}
 
 				if (result == AssemblyComparisonResult.EquivalentFXUnified ||
 					result == AssemblyComparisonResult.EquivalentFullMatch ||
 					result == AssemblyComparisonResult.EquivalentWeakNamed ||
 					result == AssemblyComparisonResult.EquivalentPartialMatch) {
 					return assembly;
 				}
 
 				throw new NotImplementedException ("Assembly equality = " + result.ToString ());
 			foreach (var assembly in domain.GetAssemblies ()) {
 				// TODO
 				if (assembly is AssemblyBuilder)
 					continue;
 
 				AssemblyComparisonResult result;
 				if (!Fusion.CompareAssemblyIdentityPure (refname, false, assembly.FullName, false, out result)) {
 					if ((result == AssemblyComparisonResult.NonEquivalentVersion || result == AssemblyComparisonResult.NonEquivalentPartialVersion) &&
 						(version_mismatch == null || version_mismatch.GetName ().Version < assembly.GetName ().Version)) {
 						version_mismatch = assembly;
 					}
 
 					continue;
 				}
 
 				if (result == AssemblyComparisonResult.EquivalentFXUnified ||
 					result == AssemblyComparisonResult.EquivalentFullMatch ||
 					result == AssemblyComparisonResult.EquivalentWeakNamed ||
 					result == AssemblyComparisonResult.EquivalentPartialMatch) {
 					return assembly;
 				}
 
 				throw new NotImplementedException ("Assembly equality = " + result.ToString ());
 			}
 
 			if (version_mismatch != null) {
 				var v1 = new AssemblyName (refname).Version;
 				var v2 = version_mismatch.GetName ().Version;
 
 				if (v1 > v2) {
 //					compiler.Report.SymbolRelatedToPreviousError (args.RequestingAssembly.Location);
 					compiler.Report.Error (1705, "Assembly `{0}' references `{1}' which has higher version number than imported assembly `{2}'",
 						args.RequestingAssembly.FullName, refname, version_mismatch.GetName ().FullName);
 				} else if (v1.Major != v2.Major || v1.Minor != v2.Minor) {
 					compiler.Report.Warning (1701, 2,
 						"Assuming assembly reference `{0}' matches assembly `{1}'. You may need to supply runtime policy",
 						refname, version_mismatch.GetName ().FullName);
 				} else {
 					compiler.Report.Warning (1702, 3,
 						"Assuming assembly reference `{0}' matches assembly `{1}'. You may need to supply runtime policy",
 						refname, version_mismatch.GetName ().FullName);
 				}
 
 				return version_mismatch;
 			}
 
 			// AssemblyReference has not been found in the domain
 			// create missing reference and continue
 			return new MissingAssembly (domain, args.Name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="211" endline="305">
<![CDATA[
 
 		/// <remarks>
 		///   If a method in Type `t' (or null to look in all interfaces
 		///   and the base abstract class) with name `Name', return type `ret_type' and
 		///   arguments `args' implements an interface, this method will
 		///   return the MethodInfo that this method implements.
 		///
 		///   If `name' is null, we operate solely on the method's signature.  This is for
 		///   instance used when implementing indexers.
 		///
 		///   The `Operation op' controls whether to lookup, clear the pending bit, or clear
 		///   all the methods with the given signature.
 		///
 		///   The `MethodInfo need_proxy' is used when we're implementing an interface's
 		///   indexer in a class.  If the new indexer's IndexerName does not match the one
 		///   that was used in the interface, then we always need to create a proxy for it.
 		///
 		/// </remarks>
 		public MethodSpec InterfaceMethod (MemberName name, TypeSpec iType, MethodData method, Operation op)
 		{
 			if (pending_implementations == null)
 				return null;
 
 			TypeSpec ret_type = method.method.ReturnType;
 			ParametersCompiled args = method.method.ParameterInfo;
 			bool is_indexer = method.method is Indexer.SetIndexerMethod || method.method is Indexer.GetIndexerMethod;
 
 			foreach (TypeAndMethods tm in pending_implementations){
 				if (!(iType == null || tm.type == iType))
 					continue;
 
 				int method_count = tm.methods.Count;
 				MethodSpec m;
 				for (int i = 0; i < method_count; i++){
 					m = tm.methods [i];
 
 					if (m == null)
 						continue;
 
 					if (is_indexer) {
 						if (!m.IsAccessor || m.Parameters.IsEmpty)
 							continue;
 					} else {
 						if (name.Name != m.Name)
 							continue;
 
 						if (m.Arity != name.Arity)
 							continue;
 					}
 
 					if (!TypeSpecComparer.Override.IsEqual (m.Parameters, args))
 						continue;
 
 					if (!TypeSpecComparer.Override.IsEqual (m.ReturnType, ret_type)) {
 						tm.found[i] = method;
 						continue;
 					}
 
 					//
 					// `need_proxy' is not null when we're implementing an
 					// interface indexer and this is Clear(One/All) operation.
 					//
 					// If `name' is null, then we do a match solely based on the
 					// signature and not on the name (this is done in the Lookup
 					// for an interface indexer).
 					//
 					if (op != Operation.Lookup) {
 						// If `t != null', then this is an explicitly interface
 						// implementation and we can always clear the method.
 						// `need_proxy' is not null if we're implementing an
 						// interface indexer.  In this case, we need to create
 						// a proxy if the implementation's IndexerName doesn't
 						// match the IndexerName in the interface.
 						if (m.DeclaringType.IsInterface && iType == null && name.Name != m.Name) {	// TODO
 							tm.need_proxy[i] = method.method.Spec;
 						} else {
 							tm.methods[i] = null;
 						}
 					} else {
 						tm.found [i] = method;
 					}
 
 					//
 					// Lookups and ClearOne return
 					//
 					if (op != Operation.ClearAll)
 						return m;
 				}
 				for (int i = 0; i < method_count; i++){
 					m = tm.methods [i];
 
 					if (m == null)
 						continue;
 
 					if (is_indexer) {
 						if (!m.IsAccessor || m.Parameters.IsEmpty)
 							continue;
 					} else {
 						if (name.Name != m.Name)
 							continue;
 
 						if (m.Arity != name.Arity)
 							continue;
 					}
 
 					if (!TypeSpecComparer.Override.IsEqual (m.Parameters, args))
 						continue;
 
 					if (!TypeSpecComparer.Override.IsEqual (m.ReturnType, ret_type)) {
 						tm.found[i] = method;
 						continue;
 					}
 
 					//
 					// `need_proxy' is not null when we're implementing an
 					// interface indexer and this is Clear(One/All) operation.
 					//
 					// If `name' is null, then we do a match solely based on the
 					// signature and not on the name (this is done in the Lookup
 					// for an interface indexer).
 					//
 					if (op != Operation.Lookup) {
 						// If `t != null', then this is an explicitly interface
 						// implementation and we can always clear the method.
 						// `need_proxy' is not null if we're implementing an
 						// interface indexer.  In this case, we need to create
 						// a proxy if the implementation's IndexerName doesn't
 						// match the IndexerName in the interface.
 						if (m.DeclaringType.IsInterface && iType == null && name.Name != m.Name) {	// TODO
 							tm.need_proxy[i] = method.method.Spec;
 						} else {
 							tm.methods[i] = null;
 						}
 					} else {
 						tm.found [i] = method;
 					}
 
 					//
 					// Lookups and ClearOne return
 					//
 					if (op != Operation.ClearAll)
 						return m;
 				}
 
 				// If a specific type was requested, we can stop now.
 				if (tm.type == iType)
 					return null;
 			}
 			foreach (TypeAndMethods tm in pending_implementations){
 				if (!(iType == null || tm.type == iType))
 					continue;
 
 				int method_count = tm.methods.Count;
 				MethodSpec m;
 				for (int i = 0; i < method_count; i++){
 					m = tm.methods [i];
 
 					if (m == null)
 						continue;
 
 					if (is_indexer) {
 						if (!m.IsAccessor || m.Parameters.IsEmpty)
 							continue;
 					} else {
 						if (name.Name != m.Name)
 							continue;
 
 						if (m.Arity != name.Arity)
 							continue;
 					}
 
 					if (!TypeSpecComparer.Override.IsEqual (m.Parameters, args))
 						continue;
 
 					if (!TypeSpecComparer.Override.IsEqual (m.ReturnType, ret_type)) {
 						tm.found[i] = method;
 						continue;
 					}
 
 					//
 					// `need_proxy' is not null when we're implementing an
 					// interface indexer and this is Clear(One/All) operation.
 					//
 					// If `name' is null, then we do a match solely based on the
 					// signature and not on the name (this is done in the Lookup
 					// for an interface indexer).
 					//
 					if (op != Operation.Lookup) {
 						// If `t != null', then this is an explicitly interface
 						// implementation and we can always clear the method.
 						// `need_proxy' is not null if we're implementing an
 						// interface indexer.  In this case, we need to create
 						// a proxy if the implementation's IndexerName doesn't
 						// match the IndexerName in the interface.
 						if (m.DeclaringType.IsInterface && iType == null && name.Name != m.Name) {	// TODO
 							tm.need_proxy[i] = method.method.Spec;
 						} else {
 							tm.methods[i] = null;
 						}
 					} else {
 						tm.found [i] = method;
 					}
 
 					//
 					// Lookups and ClearOne return
 					//
 					if (op != Operation.ClearAll)
 						return m;
 				}
 
 				// If a specific type was requested, we can stop now.
 				if (tm.type == iType)
 					return null;
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="89" endline="146">
<![CDATA[
 
 		protected override void WriteImpl(MetadataWriter mw)
 		{
 			Table[] tables = mw.ModuleBuilder.GetTables();
 			// Header
 			mw.Write(0);		// Reserved
 			int ver = mw.ModuleBuilder.MDStreamVersion;
 			mw.Write((byte)(ver >> 16));	// MajorVersion
 			mw.Write((byte)ver);			// MinorVersion
 			byte heapSizes = 0;
 			if (mw.ModuleBuilder.Strings.IsBig)
 			{
 				heapSizes |= 0x01;
 			}
 			if (mw.ModuleBuilder.Guids.IsBig)
 			{
 				heapSizes |= 0x02;
 			}
 			if (mw.ModuleBuilder.Blobs.IsBig)
 			{
 				heapSizes |= 0x04;
 			}
 			mw.Write(heapSizes);// HeapSizes
 			// LAMESPEC spec says reserved, but .NET 2.0 Ref.Emit sets it to 0x10
 			mw.Write((byte)0x10);	// Reserved
 			long bit = 1;
 			long valid = 0;
 			foreach (Table table in tables)
 			{
 				if (table != null && table.RowCount > 0)
 				{
 					valid |= bit;
 				}
 				bit <<= 1;
 			}
 			foreach (Table table in tables)
 			{
 				if (table != null && table.RowCount > 0)
 				{
 					valid |= bit;
 				}
 				bit <<= 1;
 			}
 			mw.Write(valid);	// Valid
 			mw.Write(0x0016003301FA00L);	// Sorted
 			// Rows
 			foreach (Table table in tables)
 			{
 				if (table != null && table.RowCount > 0)
 				{
 					mw.Write(table.RowCount);
 				}
 			}
 			foreach (Table table in tables)
 			{
 				if (table != null && table.RowCount > 0)
 				{
 					mw.Write(table.RowCount);
 				}
 			}
 			// Tables
 			foreach (Table table in tables)
 			{
 				if (table != null && table.RowCount > 0)
 				{
 					int pos = mw.Position;
 					table.Write(mw);
 					Debug.Assert(mw.Position - pos == table.GetLength(mw));
 				}
 			}
 			foreach (Table table in tables)
 			{
 				if (table != null && table.RowCount > 0)
 				{
 					int pos = mw.Position;
 					table.Write(mw);
 					Debug.Assert(mw.Position - pos == table.GetLength(mw));
 				}
 			}
 			// unexplained extra padding
 			mw.Write((byte)0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="907" endline="982">
<![CDATA[
 
 		void DoRead (MonoSymbolFile file, MyBinaryReader br)
 		{
 			var lines = new List<LineNumberEntry> ();
 
 			bool is_hidden = false, modified = false;
 			int stm_line = 1, stm_offset = 0, stm_file = 1;
 			while (true) {
 				byte opcode = br.ReadByte ();
 
 				if (opcode == 0) {
 					byte size = br.ReadByte ();
 					long end_pos = br.BaseStream.Position + size;
 					opcode = br.ReadByte ();
 
 					if (opcode == DW_LNE_end_sequence) {
 						if (modified)
 							lines.Add (new LineNumberEntry (
 								stm_file, stm_line, stm_offset, is_hidden));
 						break;
 					} else if (opcode == DW_LNE_MONO_negate_is_hidden) {
 						is_hidden = !is_hidden;
 						modified = true;
 					} else if ((opcode >= DW_LNE_MONO__extensions_start) &&
 						   (opcode <= DW_LNE_MONO__extensions_end)) {
 						; // reserved for future extensions
 					} else {
 						throw new MonoSymbolFileException (
 							"Unknown extended opcode {0
 							opcode, file.FileName);
 					}
 
 					br.BaseStream.Position = end_pos;
 					continue;
 				} else if (opcode < OpcodeBase) {
 					switch (opcode) {
 					case DW_LNS_copy
 						lines.Add (new LineNumberEntry (
 							stm_file, stm_line, stm_offset, is_hidden));
 						modified = false;
 						break;
 					case DW_LNS_advance_pc
 						stm_offset += br.ReadLeb128 ();
 						modified = true;
 						break;
 					case DW_LNS_advance_line
 						stm_line += br.ReadLeb128 ();
 						modified = true;
 						break;
 					case DW_LNS_set_file
 						stm_file = br.ReadLeb128 ();
 						modified = true;
 						break;
 					case DW_LNS_const_add_pc
 						stm_offset += MaxAddressIncrement;
 						modified = true;
 						break;
 					default
 						throw new MonoSymbolFileException (
 							"Unknown standard opcode {0
 							opcode);
 					}
 				} else {
 					opcode -= OpcodeBase;
 
 					stm_offset += opcode / LineRange;
 					stm_line += LineBase + (opcode % LineRange);
 					lines.Add (new LineNumberEntry (
 						stm_file, stm_line, stm_offset, is_hidden));
 					modified = false;
 				}
 			}
 			while (true) {
 				byte opcode = br.ReadByte ();
 
 				if (opcode == 0) {
 					byte size = br.ReadByte ();
 					long end_pos = br.BaseStream.Position + size;
 					opcode = br.ReadByte ();
 
 					if (opcode == DW_LNE_end_sequence) {
 						if (modified)
 							lines.Add (new LineNumberEntry (
 								stm_file, stm_line, stm_offset, is_hidden));
 						break;
 					} else if (opcode == DW_LNE_MONO_negate_is_hidden) {
 						is_hidden = !is_hidden;
 						modified = true;
 					} else if ((opcode >= DW_LNE_MONO__extensions_start) &&
 						   (opcode <= DW_LNE_MONO__extensions_end)) {
 						; // reserved for future extensions
 					} else {
 						throw new MonoSymbolFileException (
 							"Unknown extended opcode {0
 							opcode, file.FileName);
 					}
 
 					br.BaseStream.Position = end_pos;
 					continue;
 				} else if (opcode < OpcodeBase) {
 					switch (opcode) {
 					case DW_LNS_copy
 						lines.Add (new LineNumberEntry (
 							stm_file, stm_line, stm_offset, is_hidden));
 						modified = false;
 						break;
 					case DW_LNS_advance_pc
 						stm_offset += br.ReadLeb128 ();
 						modified = true;
 						break;
 					case DW_LNS_advance_line
 						stm_line += br.ReadLeb128 ();
 						modified = true;
 						break;
 					case DW_LNS_set_file
 						stm_file = br.ReadLeb128 ();
 						modified = true;
 						break;
 					case DW_LNS_const_add_pc
 						stm_offset += MaxAddressIncrement;
 						modified = true;
 						break;
 					default
 						throw new MonoSymbolFileException (
 							"Unknown standard opcode {0
 							opcode);
 					}
 				} else {
 					opcode -= OpcodeBase;
 
 					stm_offset += opcode / LineRange;
 					stm_line += LineBase + (opcode % LineRange);
 					lines.Add (new LineNumberEntry (
 						stm_file, stm_line, stm_offset, is_hidden));
 					modified = false;
 				}
 			}
 
 			_line_numbers = new LineNumberEntry [lines.Count];
 			lines.CopyTo (_line_numbers, 0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="646" endline="720">
<![CDATA[
 
 		protected void ResolveAssemblySecurityAttributes ()
 		{
 			string key_file = null;
 			string key_container = null;
 
 			if (module.OptAttributes != null) {
 				foreach (Attribute a in module.OptAttributes.Attrs) {
 					// cannot rely on any resolve-based members before you call Resolve
 					if (a.ExplicitTarget != "assembly")
 						continue;
 
 					// TODO
 					//       However, this is invoked by CodeGen.Init, when none of the namespaces
 					//       are loaded yet.
 					// TODO
 					switch (a.Name) {
 					case "AssemblyKeyFile"
 					case "AssemblyKeyFileAttribute"
 					case "System.Reflection.AssemblyKeyFileAttribute"
 						if (RootContext.StrongNameKeyFile != null) {
 							Report.SymbolRelatedToPreviousError (a.Location, a.GetSignatureForError ());
 							Report.Warning (1616, 1, "Option `{0}' overrides attribute `{1}' given in a source file or added module",
 									"keyfile", "System.Reflection.AssemblyKeyFileAttribute");
 						} else {
 							string value = a.GetString ();
 							if (!string.IsNullOrEmpty (value)) {
 								Error_ObsoleteSecurityAttribute (a, "keyfile");
 								key_file = value;
 							}
 						}
 						break;
 					case "AssemblyKeyName"
 					case "AssemblyKeyNameAttribute"
 					case "System.Reflection.AssemblyKeyNameAttribute"
 						if (RootContext.StrongNameKeyContainer != null) {
 							Report.SymbolRelatedToPreviousError (a.Location, a.GetSignatureForError ());
 							Report.Warning (1616, 1, "Option `{0}' overrides attribute `{1}' given in a source file or added module",
 									"keycontainer", "System.Reflection.AssemblyKeyNameAttribute");
 						} else {
 							string value = a.GetString ();
 							if (!string.IsNullOrEmpty (value)) {
 								Error_ObsoleteSecurityAttribute (a, "keycontainer");
 								key_container = value;
 							}
 						}
 						break;
 					case "AssemblyDelaySign"
 					case "AssemblyDelaySignAttribute"
 					case "System.Reflection.AssemblyDelaySignAttribute"
 						bool b = a.GetBoolean ();
 						if (b) {
 							Error_ObsoleteSecurityAttribute (a, "delaysign");
 						}
 
 						delay_sign = b;
 						break;
 					}
 				}
 				foreach (Attribute a in module.OptAttributes.Attrs) {
 					// cannot rely on any resolve-based members before you call Resolve
 					if (a.ExplicitTarget != "assembly")
 						continue;
 
 					// TODO
 					//       However, this is invoked by CodeGen.Init, when none of the namespaces
 					//       are loaded yet.
 					// TODO
 					switch (a.Name) {
 					case "AssemblyKeyFile"
 					case "AssemblyKeyFileAttribute"
 					case "System.Reflection.AssemblyKeyFileAttribute"
 						if (RootContext.StrongNameKeyFile != null) {
 							Report.SymbolRelatedToPreviousError (a.Location, a.GetSignatureForError ());
 							Report.Warning (1616, 1, "Option `{0}' overrides attribute `{1}' given in a source file or added module",
 									"keyfile", "System.Reflection.AssemblyKeyFileAttribute");
 						} else {
 							string value = a.GetString ();
 							if (!string.IsNullOrEmpty (value)) {
 								Error_ObsoleteSecurityAttribute (a, "keyfile");
 								key_file = value;
 							}
 						}
 						break;
 					case "AssemblyKeyName"
 					case "AssemblyKeyNameAttribute"
 					case "System.Reflection.AssemblyKeyNameAttribute"
 						if (RootContext.StrongNameKeyContainer != null) {
 							Report.SymbolRelatedToPreviousError (a.Location, a.GetSignatureForError ());
 							Report.Warning (1616, 1, "Option `{0}' overrides attribute `{1}' given in a source file or added module",
 									"keycontainer", "System.Reflection.AssemblyKeyNameAttribute");
 						} else {
 							string value = a.GetString ();
 							if (!string.IsNullOrEmpty (value)) {
 								Error_ObsoleteSecurityAttribute (a, "keycontainer");
 								key_container = value;
 							}
 						}
 						break;
 					case "AssemblyDelaySign"
 					case "AssemblyDelaySignAttribute"
 					case "System.Reflection.AssemblyDelaySignAttribute"
 						bool b = a.GetBoolean ();
 						if (b) {
 							Error_ObsoleteSecurityAttribute (a, "delaysign");
 						}
 
 						delay_sign = b;
 						break;
 					}
 				}
 			}
 
 			// We came here only to report assembly attributes warnings
 			if (public_key != null)
 				return;
 
 			//
 			// Load the strong key file found in attributes when no
 			// command line key was given
 			//
 			if (key_file != null || key_container != null) {
 				LoadPublicKey (key_file, key_container);
 			} else if (delay_sign) {
 				Report.Warning (1607, 1, "Delay signing was requested but no key file was given");
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3434" endline="3517">
<![CDATA[
 
 		//
 		// Performs user-operator overloading
 		//
 		protected virtual Expression ResolveUserOperator (ResolveContext ec, Expression left, Expression right)
 		{
 			var op = ConvertBinaryToUserOperator (oper);
 			var l = left.Type;
 			if (TypeManager.IsNullableType (l))
 				l = Nullable.NullableInfo.GetUnderlyingType (l);
 			var r = right.Type;
 			if (TypeManager.IsNullableType (r))
 				r = Nullable.NullableInfo.GetUnderlyingType (r);
 
 			IList<MemberSpec> left_operators = MemberCache.GetUserOperator (l, op, false);
 			IList<MemberSpec> right_operators = null;
 
 			if (l != r) {
 				right_operators = MemberCache.GetUserOperator (r, op, false);
 				if (right_operators == null && left_operators == null)
 					return null;
 			} else if (left_operators == null) {
 				return null;
 			}
 
 			Arguments args = new Arguments (2);
 			Argument larg = new Argument (left);
 			args.Add (larg);
 			Argument rarg = new Argument (right);
 			args.Add (rarg);
 
 			//
 			// User-defined operator implementations always take precedence
 			// over predefined operator implementations
 			//
 			if (left_operators != null && right_operators != null) {
 				left_operators = CombineUserOperators (left_operators, right_operators);
 			} else if (right_operators != null) {
 				left_operators = right_operators;
 			}
 
 			var res = new OverloadResolver (left_operators, OverloadResolver.Restrictions.ProbingOnly | 
 				OverloadResolver.Restrictions.NoBaseMembers | OverloadResolver.Restrictions.BaseMembersIncluded, loc);
 
 			var oper_method = res.ResolveOperator (ec, ref args);
 			if (oper_method == null)
 				return null;
 
 			var llifted = (state & State.LeftNullLifted) != 0;
 			var rlifted = (state & State.RightNullLifted) != 0;
 			if ((Oper & Operator.EqualityMask) != 0) {
 				var parameters = oper_method.Parameters;
 				// LAMESPEC
 				if ((left is Nullable.Unwrap || right is Nullable.Unwrap) && parameters.Types [0] != parameters.Types [1])
 					return null;
 
 				// Binary operation was lifted but we have found a user operator
 				// which requires value-type argument, we downgrade ourself back to
 				// binary operation
 				// LAMESPEC
 				// but compilation succeeds
 				if ((llifted && !parameters.Types[0].IsStruct) || (rlifted && !parameters.Types[1].IsStruct)) {
 					state &= ~(State.LeftNullLifted | State.RightNullLifted);
 				}
 			}
 
 			Expression oper_expr;
 
 			// TODO
 			if ((oper & Operator.LogicalMask) != 0) {
 				oper_expr = new ConditionalLogicalOperator (oper_method, args, CreateExpressionTree,
 					oper == Operator.LogicalAnd, loc).Resolve (ec);
 			} else {
 				oper_expr = new UserOperatorCall (oper_method, args, CreateExpressionTree, loc);
 			}
 
 			if (!llifted)
 				this.left = larg.Expr;
 
 			if (!rlifted)
 				this.right = rarg.Expr;
 
 			return oper_expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1137" endline="1225">
<![CDATA[
 
 		bool DefineBaseTypes ()
 		{
 			iface_exprs = ResolveBaseTypes (out base_type_expr);
 			if (partial_parts != null) {
 				iface_exprs = GetNormalPartialBases ();
 			}
 
 			var cycle = CheckRecursiveDefinition (this);
 			if (cycle != null) {
 				Report.SymbolRelatedToPreviousError (cycle);
 				if (this is Interface) {
 					Report.Error (529, Location,
 						"Inherited interface `{0}' causes a cycle in the interface hierarchy of `{1}'",
 					    GetSignatureForError (), cycle.GetSignatureForError ());
 
 					iface_exprs = null;
 				} else {
 					Report.Error (146, Location,
 						"Circular base class dependency involving `{0}' and `{1}'",
 						GetSignatureForError (), cycle.GetSignatureForError ());
 
 					base_type = null;
 				}
 			}
 
 			if (iface_exprs != null) {
 				foreach (TypeExpr iface in iface_exprs) {
 					// Prevents a crash, the interface might not have been resolved
 					if (iface == null)
 						continue;
 					
 					var iface_type = iface.Type;
 
 					if (!spec.AddInterface (iface_type))
 						continue;
 
 					if (iface_type.IsGeneric && spec.Interfaces != null) {
 						foreach (var prev_iface in iface_exprs) {
 							if (prev_iface == iface)
 								break;
 
 							if (!TypeSpecComparer.Unify.IsEqual (iface_type, prev_iface.Type))
 								continue;
 
 							Report.Error (695, Location,
 								"`{0}' cannot implement both `{1}' and `{2}' because they may unify for some type parameter substitutions",
 								GetSignatureForError (), prev_iface.GetSignatureForError (), iface_type.GetSignatureForError ());
 						}
 						foreach (var prev_iface in iface_exprs) {
 							if (prev_iface == iface)
 								break;
 
 							if (!TypeSpecComparer.Unify.IsEqual (iface_type, prev_iface.Type))
 								continue;
 
 							Report.Error (695, Location,
 								"`{0}' cannot implement both `{1}' and `{2}' because they may unify for some type parameter substitutions",
 								GetSignatureForError (), prev_iface.GetSignatureForError (), iface_type.GetSignatureForError ());
 						}
 					}
 
 					TypeBuilder.AddInterfaceImplementation (iface_type.GetMetaInfo ());
 
 					// Ensure the base is always setup
 					var compiled_iface = iface_type.MemberDefinition as Interface;
 					if (compiled_iface != null) {
 						// TODO
 						compiled_iface.DefineType ();
 					}
 
 					if (iface_type.Interfaces != null) {
 						var base_ifaces = new List<TypeSpec> (iface_type.Interfaces);
 						for (int i = 0; i < base_ifaces.Count; ++i) {
 							var ii_iface_type = base_ifaces[i];
 							if (spec.AddInterface (ii_iface_type)) {
 								TypeBuilder.AddInterfaceImplementation (ii_iface_type.GetMetaInfo ());
 
 								if (ii_iface_type.Interfaces != null)
 									base_ifaces.AddRange (ii_iface_type.Interfaces);
 							}
 						}
 						for (int i = 0; i < base_ifaces.Count; ++i) {
 							var ii_iface_type = base_ifaces[i];
 							if (spec.AddInterface (ii_iface_type)) {
 								TypeBuilder.AddInterfaceImplementation (ii_iface_type.GetMetaInfo ());
 
 								if (ii_iface_type.Interfaces != null)
 									base_ifaces.AddRange (ii_iface_type.Interfaces);
 							}
 						}
 					}
 				}
 				foreach (TypeExpr iface in iface_exprs) {
 					// Prevents a crash, the interface might not have been resolved
 					if (iface == null)
 						continue;
 					
 					var iface_type = iface.Type;
 
 					if (!spec.AddInterface (iface_type))
 						continue;
 
 					if (iface_type.IsGeneric && spec.Interfaces != null) {
 						foreach (var prev_iface in iface_exprs) {
 							if (prev_iface == iface)
 								break;
 
 							if (!TypeSpecComparer.Unify.IsEqual (iface_type, prev_iface.Type))
 								continue;
 
 							Report.Error (695, Location,
 								"`{0}' cannot implement both `{1}' and `{2}' because they may unify for some type parameter substitutions",
 								GetSignatureForError (), prev_iface.GetSignatureForError (), iface_type.GetSignatureForError ());
 						}
 					}
 
 					TypeBuilder.AddInterfaceImplementation (iface_type.GetMetaInfo ());
 
 					// Ensure the base is always setup
 					var compiled_iface = iface_type.MemberDefinition as Interface;
 					if (compiled_iface != null) {
 						// TODO
 						compiled_iface.DefineType ();
 					}
 
 					if (iface_type.Interfaces != null) {
 						var base_ifaces = new List<TypeSpec> (iface_type.Interfaces);
 						for (int i = 0; i < base_ifaces.Count; ++i) {
 							var ii_iface_type = base_ifaces[i];
 							if (spec.AddInterface (ii_iface_type)) {
 								TypeBuilder.AddInterfaceImplementation (ii_iface_type.GetMetaInfo ());
 
 								if (ii_iface_type.Interfaces != null)
 									base_ifaces.AddRange (ii_iface_type.Interfaces);
 							}
 						}
 					}
 				}
 			}
 
 			if (Kind == MemberKind.Interface) {
 				spec.BaseType = TypeManager.object_type;
 				return true;
 			}
 
 			if (base_type != null) {
 				spec.BaseType = base_type;
 
 				// Set base type after type creation
 				TypeBuilder.SetParent (base_type.GetMetaInfo ());
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="57" endline="263">
<![CDATA[
 
 	public void OutlineType ()
         {
 		bool first;
 		
 		OutlineAttributes ();
 		o.Write (GetTypeVisibility (t));
 		
 		if (t.IsClass && !t.IsSubclassOf (typeof (System.MulticastDelegate))) {
 			if (t.IsSealed)
 				o.Write (t.IsAbstract ? " static" 
 			else if (t.IsAbstract)
 				o.Write (" abstract");
 		}
 		
 		o.Write (" ");
 		o.Write (GetTypeKind (t));
 		o.Write (" ");
 		
 		Type [] interfaces = (Type []) Comparer.Sort (TypeGetInterfaces (t, declared_only));
 		Type parent = t.BaseType;
 
 		if (t.IsSubclassOf (typeof (System.MulticastDelegate))) {
 			MethodInfo method;
 
 			method = t.GetMethod ("Invoke");
 
 			o.Write (FormatType (method.ReturnType));
 			o.Write (" ");
 			o.Write (GetTypeName (t));
 			o.Write (" (");
 			OutlineParams (method.GetParameters ());
 			o.Write (")");
 
 #if NET_2_0
 			WriteGenericConstraints (t.GetGenericArguments ());
 #endif			
 	
 			o.WriteLine (";"); 
 			return;
 		}
 		
 		o.Write (GetTypeName (t));
 		if (((parent != null && parent != typeof (object) && parent != typeof (ValueType)) || interfaces.Length != 0) && ! t.IsEnum) {
 			first = true;
 			o.Write (" 
 			
 			if (parent != null && parent != typeof (object) && parent != typeof (ValueType)) {
 				o.Write (FormatType (parent));
 				first = false;
 			}
 			
 			foreach (Type intf in interfaces) {
 				if (!first) o.Write (", ");
 				first = false;
 				
 				o.Write (FormatType (intf));
 			}
 			foreach (Type intf in interfaces) {
 				if (!first) o.Write (", ");
 				first = false;
 				
 				o.Write (FormatType (intf));
 			}
 		}
 
 		if (t.IsEnum) {
 			Type underlyingType = System.Enum.GetUnderlyingType (t);
 			if (underlyingType != typeof (int))
 				o.Write (" 
 		}
 #if NET_2_0
 		WriteGenericConstraints (t.GetGenericArguments ());
 #endif		
 		o.WriteLine (" {");
 		o.Indent++;
 
 		if (t.IsEnum) {
 			bool is_first = true;
 			foreach (FieldInfo fi in t.GetFields (BindingFlags.Public | BindingFlags.Static)) {
 				
 				if (! is_first)
 					o.WriteLine (",");
 				is_first = false;
 				o.Write (fi.Name);
 			}
 			foreach (FieldInfo fi in t.GetFields (BindingFlags.Public | BindingFlags.Static)) {
 				
 				if (! is_first)
 					o.WriteLine (",");
 				is_first = false;
 				o.Write (fi.Name);
 			}
 			o.WriteLine ();
 			o.Indent--; o.WriteLine ("}");
 			return;
 		}
 		
 		first = true;
 		
 		foreach (ConstructorInfo ci in t.GetConstructors (DefaultFlags)) {
 			
 			if (! ShowMember (ci))
 				continue;
 			
 			if (first)
 				o.WriteLine ();
 			first = false;
 			
 			OutlineConstructor (ci);
 			
 			o.WriteLine ();
 		}
 		foreach (ConstructorInfo ci in t.GetConstructors (DefaultFlags)) {
 			
 			if (! ShowMember (ci))
 				continue;
 			
 			if (first)
 				o.WriteLine ();
 			first = false;
 			
 			OutlineConstructor (ci);
 			
 			o.WriteLine ();
 		}
 		
 
 		first = true;
 		
 		foreach (MethodInfo m in Comparer.Sort (t.GetMethods (DefaultFlags))) {
 			
 			if (! ShowMember (m))
 				continue;		
 			
 			if ((m.Attributes & MethodAttributes.SpecialName) != 0)
 				continue;
 			
 			if (first)
 				o.WriteLine ();
 			first = false;
 			
 			OutlineMethod (m);
 			
 			o.WriteLine ();
 		}
 		foreach (MethodInfo m in Comparer.Sort (t.GetMethods (DefaultFlags))) {
 			
 			if (! ShowMember (m))
 				continue;		
 			
 			if ((m.Attributes & MethodAttributes.SpecialName) != 0)
 				continue;
 			
 			if (first)
 				o.WriteLine ();
 			first = false;
 			
 			OutlineMethod (m);
 			
 			o.WriteLine ();
 		}
 		
 		first = true;
 		
 		foreach (MethodInfo m in t.GetMethods (DefaultFlags)) {
 			
 			if (! ShowMember (m))
 				continue;
 			
 			if ((m.Attributes & MethodAttributes.SpecialName) == 0)
 				continue;
 			if (!(m.Name.StartsWith ("op_")))
 				continue;
 
 			if (first)
 				o.WriteLine ();
 			first = false;
 			
 			OutlineOperator (m);
 			
 			o.WriteLine ();
 		}
 		foreach (MethodInfo m in t.GetMethods (DefaultFlags)) {
 			
 			if (! ShowMember (m))
 				continue;
 			
 			if ((m.Attributes & MethodAttributes.SpecialName) == 0)
 				continue;
 			if (!(m.Name.StartsWith ("op_")))
 				continue;
 
 			if (first)
 				o.WriteLine ();
 			first = false;
 			
 			OutlineOperator (m);
 			
 			o.WriteLine ();
 		}
 
 		first = true;
 		
 		foreach (PropertyInfo pi in Comparer.Sort (t.GetProperties (DefaultFlags))) {
 			
 			if (! ((pi.CanRead  && ShowMember (pi.GetGetMethod (true))) ||
 			       (pi.CanWrite && ShowMember (pi.GetSetMethod (true)))))
 				continue;
 			
 			if (first)
 				o.WriteLine ();
 			first = false;
 			
 			OutlineProperty (pi);
 			
 			o.WriteLine ();
 		}
 		foreach (PropertyInfo pi in Comparer.Sort (t.GetProperties (DefaultFlags))) {
 			
 			if (! ((pi.CanRead  && ShowMember (pi.GetGetMethod (true))) ||
 			       (pi.CanWrite && ShowMember (pi.GetSetMethod (true)))))
 				continue;
 			
 			if (first)
 				o.WriteLine ();
 			first = false;
 			
 			OutlineProperty (pi);
 			
 			o.WriteLine ();
 		}
 		
 		first = true;
 
 		foreach (FieldInfo fi in t.GetFields (DefaultFlags)) {
 			
 			if (! ShowMember (fi))
 				continue;
 			
 			if (first)
 				o.WriteLine ();
 			first = false;
 			
 			OutlineField (fi);
 			
 			o.WriteLine ();
 		}
 		foreach (FieldInfo fi in t.GetFields (DefaultFlags)) {
 			
 			if (! ShowMember (fi))
 				continue;
 			
 			if (first)
 				o.WriteLine ();
 			first = false;
 			
 			OutlineField (fi);
 			
 			o.WriteLine ();
 		}
 
 		first = true;
 		
 		foreach (EventInfo ei in Comparer.Sort (t.GetEvents (DefaultFlags))) {
 			
 			if (! ShowMember (ei.GetAddMethod (true)))
 				continue;
 			
 			if (first)
 				o.WriteLine ();
 			first = false;
 			
 			OutlineEvent (ei);
 			
 			o.WriteLine ();
 		}
 		foreach (EventInfo ei in Comparer.Sort (t.GetEvents (DefaultFlags))) {
 			
 			if (! ShowMember (ei.GetAddMethod (true)))
 				continue;
 			
 			if (first)
 				o.WriteLine ();
 			first = false;
 			
 			OutlineEvent (ei);
 			
 			o.WriteLine ();
 		}
 
 		first = true;
 
 		foreach (Type ntype in Comparer.Sort (t.GetNestedTypes (DefaultFlags))) {
 			
 			if (! ShowMember (ntype))
 				continue;
 			
 			if (first)
 				o.WriteLine ();
 			first = false;
 			
 			new Outline (ntype, o, declared_only, show_private, filter_obsolete).OutlineType ();
 		}
 		foreach (Type ntype in Comparer.Sort (t.GetNestedTypes (DefaultFlags))) {
 			
 			if (! ShowMember (ntype))
 				continue;
 			
 			if (first)
 				o.WriteLine ();
 			first = false;
 			
 			new Outline (ntype, o, declared_only, show_private, filter_obsolete).OutlineType ();
 		}
 		
 		o.Indent--; o.WriteLine ("}");
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4217" endline="4319">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			TypeSpec op_type = left.Type;
 			
 			// It must be either array or fixed buffer
 			TypeSpec element;
 			if (TypeManager.HasElementType (op_type)) {
 				element = TypeManager.GetElementType (op_type);
 			} else {
 				FieldExpr fe = left as FieldExpr;
 				if (fe != null)
 					element = ((FixedFieldSpec) (fe.Spec)).ElementType;
 				else
 					element = op_type;
 			}
 
 			int size = GetTypeSize (element);
 			TypeSpec rtype = right.Type;
 			
 			if ((op & Binary.Operator.SubtractionMask) != 0 && rtype.IsPointer){
 				//
 				// handle (pointer - pointer)
 				//
 				left.Emit (ec);
 				right.Emit (ec);
 				ec.Emit (OpCodes.Sub);
 
 				if (size != 1){
 					if (size == 0)
 						ec.Emit (OpCodes.Sizeof, element);
 					else 
 						ec.EmitInt (size);
 					ec.Emit (OpCodes.Div);
 				}
 				ec.Emit (OpCodes.Conv_I8);
 			} else {
 				//
 				// handle + and - on (pointer op int)
 				//
 				Constant left_const = left as Constant;
 				if (left_const != null) {
 					//
 					// Optimize ((T*)null) pointer operations
 					//
 					if (left_const.IsDefaultValue) {
 						left = EmptyExpression.Null;
 					} else {
 						left_const = null;
 					}
 				}
 
 				left.Emit (ec);
 
 				var right_const = right as Constant;
 				if (right_const != null) {
 					//
 					// Optimize 0-based arithmetic
 					//
 					if (right_const.IsDefaultValue)
 						return;
 
 					if (size != 0)
 						right = new IntConstant (size, right.Location);
 					else
 						right = new SizeOf (new TypeExpression (element, right.Location), right.Location);
 					
 					// TODO
 					ResolveContext rc = new ResolveContext (ec.MemberContext, ResolveContext.Options.UnsafeScope);
 					right = new Binary (Binary.Operator.Multiply, right, right_const, loc).Resolve (rc);
 					if (right == null)
 						return;
 				}
 
 				right.Emit (ec);
 				if (rtype == TypeManager.sbyte_type || rtype == TypeManager.byte_type ||
 					rtype == TypeManager.short_type || rtype == TypeManager.ushort_type) {
 					ec.Emit (OpCodes.Conv_I);
 				} else if (rtype == TypeManager.uint32_type) {
 					ec.Emit (OpCodes.Conv_U);
 				}
 
 				if (right_const == null && size != 1){
 					if (size == 0)
 						ec.Emit (OpCodes.Sizeof, element);
 					else 
 						ec.EmitInt (size);
 					if (rtype == TypeManager.int64_type || rtype == TypeManager.uint64_type)
 						ec.Emit (OpCodes.Conv_I8);
 
 					Binary.EmitOperatorOpcode (ec, Binary.Operator.Multiply, rtype);
 				}
 
 				if (left_const == null) {
 					if (rtype == TypeManager.int64_type)
 						ec.Emit (OpCodes.Conv_I);
 					else if (rtype == TypeManager.uint64_type)
 						ec.Emit (OpCodes.Conv_U);
 
 					Binary.EmitOperatorOpcode (ec, op, op_type);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="493" endline="609">
<![CDATA[
 
 		//
 		// Returns null when the property is not valid C# property
 		//
 		public PropertySpec CreateProperty (PropertyInfo pi, TypeSpec declaringType, MethodSpec get, MethodSpec set)
 		{
 			Modifiers mod = 0;
 			AParametersCollection param = null;
 			TypeSpec type = null;
 			if (get != null) {
 				mod = get.Modifiers;
 				param = get.Parameters;
 				type = get.ReturnType;
 			}
 
 			bool is_valid_property = true;
 			if (set != null) {
 				if (set.ReturnType != TypeManager.void_type)
 					is_valid_property = false;
 
 				var set_param_count = set.Parameters.Count - 1;
 
 				if (set_param_count < 0) {
 					set_param_count = 0;
 					is_valid_property = false;
 				}
 
 				var set_type = set.Parameters.Types[set_param_count];
 
 				if (mod == 0) {
 					AParametersCollection set_based_param;
 
 					if (set_param_count == 0) {
 						set_based_param = ParametersCompiled.EmptyReadOnlyParameters;
 					} else {
 						//
 						// Create indexer parameters based on setter method parameters (the last parameter has to be removed)
 						//
 						var data = new IParameterData[set_param_count];
 						var types = new TypeSpec[set_param_count];
 						Array.Copy (set.Parameters.FixedParameters, data, set_param_count);
 						Array.Copy (set.Parameters.Types, types, set_param_count);
 						set_based_param = new ParametersImported (data, types, set.Parameters.HasParams);
 					}
 
 					mod = set.Modifiers;
 					param = set_based_param;
 					type = set_type;
 				} else {
 					if (set_param_count != get.Parameters.Count)
 						is_valid_property = false;
 
 					if (get.ReturnType != set_type)
 						is_valid_property = false;
 
 					// Possible custom accessor modifiers
 					if ((mod & Modifiers.AccessibilityMask) != (set.Modifiers & Modifiers.AccessibilityMask)) {
 						var get_acc = mod & Modifiers.AccessibilityMask;
 						if (get_acc != Modifiers.PUBLIC) {
 							var set_acc = set.Modifiers & Modifiers.AccessibilityMask;
 							// If the accessor modifiers are not same, do extra restriction checks
 							if (get_acc != set_acc) {
 								var get_restr = ModifiersExtensions.IsRestrictedModifier (get_acc, set_acc);
 								var set_restr = ModifiersExtensions.IsRestrictedModifier (set_acc, get_acc);
 								if (get_restr && set_restr) {
 									is_valid_property = false; // Neither is more restrictive
 								}
 
 								if (get_restr) {
 									mod &= ~Modifiers.AccessibilityMask;
 									mod |= set_acc;
 								}
 							}
 						}
 					}
 				}
 			}
 
 			PropertySpec spec = null;
 			if (!param.IsEmpty) {
 				var index_name = declaringType.MemberDefinition.GetAttributeDefaultMember ();
 				if (index_name == null) {
 					is_valid_property = false;
 				} else {
 					if (get != null) {
 						if (get.IsStatic)
 							is_valid_property = false;
 						if (get.Name.IndexOf (index_name, StringComparison.Ordinal) != 4)
 							is_valid_property = false;
 					}
 					if (set != null) {
 						if (set.IsStatic)
 							is_valid_property = false;
 						if (set.Name.IndexOf (index_name, StringComparison.Ordinal) != 4)
 							is_valid_property = false;
 					}
 				}
 
 				if (is_valid_property)
 					spec = new IndexerSpec (declaringType, new ImportedParameterMemberDefinition (pi, type, param, this), type, param, pi, mod);
 			}
 
 			if (spec == null)
 				spec = new PropertySpec (MemberKind.Property, declaringType, new ImportedMemberDefinition (pi, type, this), type, pi, mod);
 
 			if (!is_valid_property) {
 				spec.IsNotRealProperty = true;
 				return spec;
 			}
 
 			if (set != null)
 				spec.Set = set;
 			if (get != null)
 				spec.Get = get;
 
 			return spec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="415" endline="492">
<![CDATA[
 
 		//
 		// Imports System.Reflection parameters
 		//
 		AParametersCollection CreateParameters (TypeSpec parent, ParameterInfo[] pi, MethodBase method)
 		{
 			int varargs = method != null && (method.CallingConvention & CallingConventions.VarArgs) != 0 ? 1 
 
 			if (pi.Length == 0 && varargs == 0)
 				return ParametersCompiled.EmptyReadOnlyParameters;
 
 			TypeSpec[] types = new TypeSpec[pi.Length + varargs];
 			IParameterData[] par = new IParameterData[pi.Length + varargs];
 			bool is_params = false;
 			for (int i = 0; i < pi.Length; i++) {
 				ParameterInfo p = pi[i];
 				Parameter.Modifier mod = 0;
 				Expression default_value = null;
 				if (p.ParameterType.IsByRef) {
 					if ((p.Attributes & (ParameterAttributes.Out | ParameterAttributes.In)) == ParameterAttributes.Out)
 						mod = Parameter.Modifier.OUT;
 					else
 						mod = Parameter.Modifier.REF;
 
 					//
 					// Strip reference wrapping
 					//
 					var el = p.ParameterType.GetElementType ();
 					types[i] = ImportType (el, new DynamicTypeReader (p));	// TODO
 				} else if (i == 0 && method.IsStatic && parent.IsStatic && parent.MemberDefinition.DeclaringAssembly.HasExtensionMethod &&
 					HasAttribute (CustomAttributeData.GetCustomAttributes (method), "ExtensionAttribute", CompilerServicesNamespace)) {
 					mod = Parameter.Modifier.This;
 					types[i] = ImportType (p.ParameterType);
 				} else {
 					types[i] = ImportType (p.ParameterType, new DynamicTypeReader (p));
 
 					if (i >= pi.Length - 2 && types[i] is ArrayContainer) {
 						if (HasAttribute (CustomAttributeData.GetCustomAttributes (p), "ParamArrayAttribute", "System")) {
 							mod = Parameter.Modifier.PARAMS;
 							is_params = true;
 						}
 					}
 
 					if (!is_params && p.IsOptional) {
 						object value = p.RawDefaultValue;
 						var ptype = types[i];
 						if ((p.Attributes & ParameterAttributes.HasDefault) != 0 && ptype.Kind != MemberKind.TypeParameter && (value != null || TypeManager.IsReferenceType (ptype))) {
 							if (value == null) {
 								default_value = Constant.CreateConstant (null, ptype, null, Location.Null);
 							} else {
 								default_value = ImportParameterConstant (value).Resolve (null);
 
 								if (ptype.IsEnum) {
 									default_value = new EnumConstant ((Constant) default_value, ptype).Resolve (null);
 								}
 							}
 						} else if (value == Missing.Value) {
 							default_value = EmptyExpression.MissingValue;
 						} else if (value == null) {
 							default_value = new DefaultValueExpression (new TypeExpression (ptype, Location.Null), Location.Null);
 						} else if (ptype == TypeManager.decimal_type) {
 							default_value = ImportParameterConstant (value).Resolve (null);
 						}
 					}
 				}
 
 				par[i] = new ParameterData (p.Name, mod, default_value);
 			}
 			for (int i = 0; i < pi.Length; i++) {
 				ParameterInfo p = pi[i];
 				Parameter.Modifier mod = 0;
 				Expression default_value = null;
 				if (p.ParameterType.IsByRef) {
 					if ((p.Attributes & (ParameterAttributes.Out | ParameterAttributes.In)) == ParameterAttributes.Out)
 						mod = Parameter.Modifier.OUT;
 					else
 						mod = Parameter.Modifier.REF;
 
 					//
 					// Strip reference wrapping
 					//
 					var el = p.ParameterType.GetElementType ();
 					types[i] = ImportType (el, new DynamicTypeReader (p));	// TODO
 				} else if (i == 0 && method.IsStatic && parent.IsStatic && parent.MemberDefinition.DeclaringAssembly.HasExtensionMethod &&
 					HasAttribute (CustomAttributeData.GetCustomAttributes (method), "ExtensionAttribute", CompilerServicesNamespace)) {
 					mod = Parameter.Modifier.This;
 					types[i] = ImportType (p.ParameterType);
 				} else {
 					types[i] = ImportType (p.ParameterType, new DynamicTypeReader (p));
 
 					if (i >= pi.Length - 2 && types[i] is ArrayContainer) {
 						if (HasAttribute (CustomAttributeData.GetCustomAttributes (p), "ParamArrayAttribute", "System")) {
 							mod = Parameter.Modifier.PARAMS;
 							is_params = true;
 						}
 					}
 
 					if (!is_params && p.IsOptional) {
 						object value = p.RawDefaultValue;
 						var ptype = types[i];
 						if ((p.Attributes & ParameterAttributes.HasDefault) != 0 && ptype.Kind != MemberKind.TypeParameter && (value != null || TypeManager.IsReferenceType (ptype))) {
 							if (value == null) {
 								default_value = Constant.CreateConstant (null, ptype, null, Location.Null);
 							} else {
 								default_value = ImportParameterConstant (value).Resolve (null);
 
 								if (ptype.IsEnum) {
 									default_value = new EnumConstant ((Constant) default_value, ptype).Resolve (null);
 								}
 							}
 						} else if (value == Missing.Value) {
 							default_value = EmptyExpression.MissingValue;
 						} else if (value == null) {
 							default_value = new DefaultValueExpression (new TypeExpression (ptype, Location.Null), Location.Null);
 						} else if (ptype == TypeManager.decimal_type) {
 							default_value = ImportParameterConstant (value).Resolve (null);
 						}
 					}
 				}
 
 				par[i] = new ParameterData (p.Name, mod, default_value);
 			}
 
 			if (varargs != 0) {
 				par[par.Length - 1] = new ArglistParameter (Location.Null);
 				types[types.Length - 1] = InternalType.Arglist;
 			}
 
 			return method != null ?
 				new ParametersImported (par, types, varargs != 0, is_params) 
 				new ParametersImported (par, types, is_params);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="1036" endline="1149">
<![CDATA[
 
 		//
 		// Checks all appropriate container members for CLS compliance
 		//
 		public void VerifyClsCompliance (TypeSpec container, Report report)
 		{
 			if (locase_members != null)
 				return;
 
 			if (container.BaseType == null) {
 				locase_members = new Dictionary<string, MemberSpec[]> (member_hash.Count); // StringComparer.OrdinalIgnoreCase);
 			} else {
 				container.BaseType.MemberCache.VerifyClsCompliance (container.BaseType, report);
 				locase_members = new Dictionary<string, MemberSpec[]> (container.BaseType.MemberCache.locase_members); //, StringComparer.OrdinalIgnoreCase);
 			}
 
 			var is_imported_type = container.MemberDefinition.IsImported;
 			foreach (var entry in container.MemberCache.member_hash) {
 				for (int i = 0; i < entry.Value.Count; ++i ) {
 					var name_entry = entry.Value[i];
 					if ((name_entry.Modifiers & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 						continue;
 
 					if ((name_entry.Modifiers & (Modifiers.OVERRIDE | Modifiers.COMPILER_GENERATED)) != 0)
 						continue;
 
 					if ((name_entry.Kind & MemberKind.MaskType) == 0)
 						continue;
 
 					if (name_entry.MemberDefinition.IsNotCLSCompliant ())
 					    continue;
 
 					IParametersMember p_a = name_entry as IParametersMember;
 					if (p_a != null && !name_entry.IsAccessor) {
 						if (!is_imported_type) {
 							var p_a_pd = p_a.Parameters;
 							for (int ii = i + 1; ii < entry.Value.Count; ++ii) {
 								var checked_entry = entry.Value[ii];
 								IParametersMember p_b = checked_entry as IParametersMember;
 								if (p_b == null)
 									continue;
 
 								if (p_a_pd.Count != p_b.Parameters.Count)
 									continue;
 
 								if (checked_entry.IsAccessor)
 									continue;
 
 								var res = ParametersCompiled.IsSameClsSignature (p_a.Parameters, p_b.Parameters);
 								if (res != 0) {
 									var last = GetLaterDefinedMember (checked_entry, name_entry);
 									if (last == checked_entry.MemberDefinition) {
 										report.SymbolRelatedToPreviousError (name_entry);
 									} else {
 										report.SymbolRelatedToPreviousError (checked_entry);
 									}
 
 									if ((res & 1) != 0) {
 										report.Warning (3006, 1, last.Location,
 												"Overloaded method `{0}' differing only in ref or out, or in array rank, is not CLS-compliant",
 												name_entry.GetSignatureForError ());
 									}
 
 									if ((res & 2) != 0) {
 										report.Warning (3007, 1, last.Location,
 											"Overloaded method `{0}' differing only by unnamed array types is not CLS-compliant",
 											name_entry.GetSignatureForError ());
 									}
 								}
 							}
 							for (int ii = i + 1; ii < entry.Value.Count; ++ii) {
 								var checked_entry = entry.Value[ii];
 								IParametersMember p_b = checked_entry as IParametersMember;
 								if (p_b == null)
 									continue;
 
 								if (p_a_pd.Count != p_b.Parameters.Count)
 									continue;
 
 								if (checked_entry.IsAccessor)
 									continue;
 
 								var res = ParametersCompiled.IsSameClsSignature (p_a.Parameters, p_b.Parameters);
 								if (res != 0) {
 									var last = GetLaterDefinedMember (checked_entry, name_entry);
 									if (last == checked_entry.MemberDefinition) {
 										report.SymbolRelatedToPreviousError (name_entry);
 									} else {
 										report.SymbolRelatedToPreviousError (checked_entry);
 									}
 
 									if ((res & 1) != 0) {
 										report.Warning (3006, 1, last.Location,
 												"Overloaded method `{0}' differing only in ref or out, or in array rank, is not CLS-compliant",
 												name_entry.GetSignatureForError ());
 									}
 
 									if ((res & 2) != 0) {
 										report.Warning (3007, 1, last.Location,
 											"Overloaded method `{0}' differing only by unnamed array types is not CLS-compliant",
 											name_entry.GetSignatureForError ());
 									}
 								}
 							}
 						}
 					}
 
 					if (i > 0 || name_entry.Kind == MemberKind.Constructor || name_entry.Kind == MemberKind.Indexer)
 						continue;
 
 					var name_entry_locase = name_entry.Name.ToLowerInvariant ();
 
 					MemberSpec[] found;
 					if (!locase_members.TryGetValue (name_entry_locase, out found)) {
 						found = new MemberSpec[] { name_entry };
 						locase_members.Add (name_entry_locase, found);
 					} else {
 						bool same_names_only = true;
 						foreach (var f in found) {
 							if (f.Name == name_entry.Name)
 								continue;
 
 //							if (f.IsAccessor && name_entry.IsAccessor)
 //								continue;
 
 							same_names_only = false;
 							if (!is_imported_type) {
 								var last = GetLaterDefinedMember (f, name_entry);
 								if (last == f.MemberDefinition) {
 									report.SymbolRelatedToPreviousError (name_entry);
 								} else {
 									report.SymbolRelatedToPreviousError (f);
 								}
 
 								report.Warning (3005, 1, last.Location,
 									"Identifier `{0}' differing only in case is not CLS-compliant", last.GetSignatureForError ());
 							}
 						}
 						foreach (var f in found) {
 							if (f.Name == name_entry.Name)
 								continue;
 
 //							if (f.IsAccessor && name_entry.IsAccessor)
 //								continue;
 
 							same_names_only = false;
 							if (!is_imported_type) {
 								var last = GetLaterDefinedMember (f, name_entry);
 								if (last == f.MemberDefinition) {
 									report.SymbolRelatedToPreviousError (name_entry);
 								} else {
 									report.SymbolRelatedToPreviousError (f);
 								}
 
 								report.Warning (3005, 1, last.Location,
 									"Identifier `{0}' differing only in case is not CLS-compliant", last.GetSignatureForError ());
 							}
 						}
 
 						if (!same_names_only) {
 							Array.Resize (ref found, found.Length + 1);
 							found[found.Length - 1] = name_entry;
 							locase_members[name_entry_locase] = found;
 						}
 					}
 				}
 				for (int i = 0; i < entry.Value.Count; ++i ) {
 					var name_entry = entry.Value[i];
 					if ((name_entry.Modifiers & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 						continue;
 
 					if ((name_entry.Modifiers & (Modifiers.OVERRIDE | Modifiers.COMPILER_GENERATED)) != 0)
 						continue;
 
 					if ((name_entry.Kind & MemberKind.MaskType) == 0)
 						continue;
 
 					if (name_entry.MemberDefinition.IsNotCLSCompliant ())
 					    continue;
 
 					IParametersMember p_a = name_entry as IParametersMember;
 					if (p_a != null && !name_entry.IsAccessor) {
 						if (!is_imported_type) {
 							var p_a_pd = p_a.Parameters;
 							for (int ii = i + 1; ii < entry.Value.Count; ++ii) {
 								var checked_entry = entry.Value[ii];
 								IParametersMember p_b = checked_entry as IParametersMember;
 								if (p_b == null)
 									continue;
 
 								if (p_a_pd.Count != p_b.Parameters.Count)
 									continue;
 
 								if (checked_entry.IsAccessor)
 									continue;
 
 								var res = ParametersCompiled.IsSameClsSignature (p_a.Parameters, p_b.Parameters);
 								if (res != 0) {
 									var last = GetLaterDefinedMember (checked_entry, name_entry);
 									if (last == checked_entry.MemberDefinition) {
 										report.SymbolRelatedToPreviousError (name_entry);
 									} else {
 										report.SymbolRelatedToPreviousError (checked_entry);
 									}
 
 									if ((res & 1) != 0) {
 										report.Warning (3006, 1, last.Location,
 												"Overloaded method `{0}' differing only in ref or out, or in array rank, is not CLS-compliant",
 												name_entry.GetSignatureForError ());
 									}
 
 									if ((res & 2) != 0) {
 										report.Warning (3007, 1, last.Location,
 											"Overloaded method `{0}' differing only by unnamed array types is not CLS-compliant",
 											name_entry.GetSignatureForError ());
 									}
 								}
 							}
 						}
 					}
 
 					if (i > 0 || name_entry.Kind == MemberKind.Constructor || name_entry.Kind == MemberKind.Indexer)
 						continue;
 
 					var name_entry_locase = name_entry.Name.ToLowerInvariant ();
 
 					MemberSpec[] found;
 					if (!locase_members.TryGetValue (name_entry_locase, out found)) {
 						found = new MemberSpec[] { name_entry };
 						locase_members.Add (name_entry_locase, found);
 					} else {
 						bool same_names_only = true;
 						foreach (var f in found) {
 							if (f.Name == name_entry.Name)
 								continue;
 
 //							if (f.IsAccessor && name_entry.IsAccessor)
 //								continue;
 
 							same_names_only = false;
 							if (!is_imported_type) {
 								var last = GetLaterDefinedMember (f, name_entry);
 								if (last == f.MemberDefinition) {
 									report.SymbolRelatedToPreviousError (name_entry);
 								} else {
 									report.SymbolRelatedToPreviousError (f);
 								}
 
 								report.Warning (3005, 1, last.Location,
 									"Identifier `{0}' differing only in case is not CLS-compliant", last.GetSignatureForError ());
 							}
 						}
 
 						if (!same_names_only) {
 							Array.Resize (ref found, found.Length + 1);
 							found[found.Length - 1] = name_entry;
 							locase_members[name_entry_locase] = found;
 						}
 					}
 				}
 			}
 			foreach (var entry in container.MemberCache.member_hash) {
 				for (int i = 0; i < entry.Value.Count; ++i ) {
 					var name_entry = entry.Value[i];
 					if ((name_entry.Modifiers & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 						continue;
 
 					if ((name_entry.Modifiers & (Modifiers.OVERRIDE | Modifiers.COMPILER_GENERATED)) != 0)
 						continue;
 
 					if ((name_entry.Kind & MemberKind.MaskType) == 0)
 						continue;
 
 					if (name_entry.MemberDefinition.IsNotCLSCompliant ())
 					    continue;
 
 					IParametersMember p_a = name_entry as IParametersMember;
 					if (p_a != null && !name_entry.IsAccessor) {
 						if (!is_imported_type) {
 							var p_a_pd = p_a.Parameters;
 							for (int ii = i + 1; ii < entry.Value.Count; ++ii) {
 								var checked_entry = entry.Value[ii];
 								IParametersMember p_b = checked_entry as IParametersMember;
 								if (p_b == null)
 									continue;
 
 								if (p_a_pd.Count != p_b.Parameters.Count)
 									continue;
 
 								if (checked_entry.IsAccessor)
 									continue;
 
 								var res = ParametersCompiled.IsSameClsSignature (p_a.Parameters, p_b.Parameters);
 								if (res != 0) {
 									var last = GetLaterDefinedMember (checked_entry, name_entry);
 									if (last == checked_entry.MemberDefinition) {
 										report.SymbolRelatedToPreviousError (name_entry);
 									} else {
 										report.SymbolRelatedToPreviousError (checked_entry);
 									}
 
 									if ((res & 1) != 0) {
 										report.Warning (3006, 1, last.Location,
 												"Overloaded method `{0}' differing only in ref or out, or in array rank, is not CLS-compliant",
 												name_entry.GetSignatureForError ());
 									}
 
 									if ((res & 2) != 0) {
 										report.Warning (3007, 1, last.Location,
 											"Overloaded method `{0}' differing only by unnamed array types is not CLS-compliant",
 											name_entry.GetSignatureForError ());
 									}
 								}
 							}
 						}
 					}
 
 					if (i > 0 || name_entry.Kind == MemberKind.Constructor || name_entry.Kind == MemberKind.Indexer)
 						continue;
 
 					var name_entry_locase = name_entry.Name.ToLowerInvariant ();
 
 					MemberSpec[] found;
 					if (!locase_members.TryGetValue (name_entry_locase, out found)) {
 						found = new MemberSpec[] { name_entry };
 						locase_members.Add (name_entry_locase, found);
 					} else {
 						bool same_names_only = true;
 						foreach (var f in found) {
 							if (f.Name == name_entry.Name)
 								continue;
 
 //							if (f.IsAccessor && name_entry.IsAccessor)
 //								continue;
 
 							same_names_only = false;
 							if (!is_imported_type) {
 								var last = GetLaterDefinedMember (f, name_entry);
 								if (last == f.MemberDefinition) {
 									report.SymbolRelatedToPreviousError (name_entry);
 								} else {
 									report.SymbolRelatedToPreviousError (f);
 								}
 
 								report.Warning (3005, 1, last.Location,
 									"Identifier `{0}' differing only in case is not CLS-compliant", last.GetSignatureForError ());
 							}
 						}
 
 						if (!same_names_only) {
 							Array.Resize (ref found, found.Length + 1);
 							found[found.Length - 1] = name_entry;
 							locase_members[name_entry_locase] = found;
 						}
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="271" endline="280">
<![CDATA[
 
 		private static Type ReadType(Module module, ByteReader br)
 		{
 			string str = ReadString(br);
 			if (str == "")
 			{
 				return null;
 			}
 			return module.Assembly.GetType(str) ?? module.universe.GetType(str, true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4834" endline="4840">
<![CDATA[
 
 		public void SetHasAddressTaken ()
 		{
 			IVariableReference vr = InstanceExpression as IVariableReference;
 			if (vr != null)
 				vr.SetHasAddressTaken ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="353" endline="362">
<![CDATA[
 
 		public ScopeVariable[] ScopeVariables {
 			get {
 				if (_scope_vars == null)
 					return new ScopeVariable [0];
 
 				ScopeVariable[] retval = new ScopeVariable [_scope_vars.Count];
 				_scope_vars.CopyTo (retval);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="173" endline="180">
<![CDATA[
 
 		public void SetInterfaceConstraints(params Type[] interfaceConstraints)
 		{
 			foreach (Type type in interfaceConstraints)
 			{
 				AddConstraint(type);
 			}
 			foreach (Type type in interfaceConstraints)
 			{
 				AddConstraint(type);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="444" endline="458">
<![CDATA[
 		}
 
 		public Type Import(System.Type type)
 		{
 			Type imported;
 			if (!importedTypes.TryGetValue(type, out imported))
 			{
 				imported = ImportImpl(type);
 				if (imported != null)
 				{
 					importedTypes.Add(type, imported);
 				}
 			}
 			return imported;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1625" endline="1641">
<![CDATA[
 
 		//
 		// Look for the best storey for this anonymous method
 		//
 		AnonymousMethodStorey FindBestMethodStorey ()
 		{
 			//
 			// Use the nearest parent block which has a storey
 			//
 			for (Block b = Block.Parent; b != null; b = b.Parent) {
 				AnonymousMethodStorey s = b.Explicit.AnonymousMethodStorey;
 				if (s != null)
 					return s;
 			}
 			for (Block b = Block.Parent; b != null; b = b.Parent) {
 				AnonymousMethodStorey s = b.Explicit.AnonymousMethodStorey;
 				if (s != null)
 					return s;
 			}
 					
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1362" endline="1373">
<![CDATA[
 
 		public static string GetPostfixSignature (int rank)
 		{
 			StringBuilder sb = new StringBuilder ();
 			sb.Append ("[");
 			for (int i = 1; i < rank; i++) {
 				sb.Append (",");
 			}
 			for (int i = 1; i < rank; i++) {
 				sb.Append (",");
 			}
 			sb.Append ("]");
 
 			return sb.ToString ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2778" endline="2792">
<![CDATA[
 
 		//
 		// Creates an arguments set from all parameters, useful for method proxy calls
 		//
 		public Arguments GetAllParametersArguments ()
 		{
 			int count = parameters.Count;
 			Arguments args = new Arguments (count);
 			for (int i = 0; i < count; ++i) {
 				var arg_expr = GetParameterReference (i, parameter_info[i].Location);
 				args.Add (new Argument (arg_expr));
 			}
 			for (int i = 0; i < count; ++i) {
 				var arg_expr = GetParameterReference (i, parameter_info[i].Location);
 				args.Add (new Argument (arg_expr));
 			}
 
 			return args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="311" endline="322">
<![CDATA[
 
 		private static IList<CustomAttributeTypedArgument> ReadConstructorArguments(Assembly asm, ByteReader br, ConstructorInfo constructor)
 		{
 			MethodSignature sig = constructor.MethodSignature;
 			int count = sig.GetParameterCount();
 			List<CustomAttributeTypedArgument> list = new List<CustomAttributeTypedArgument>(count);
 			for (int i = 0; i < count; i++)
 			{
 				list.Add(ReadFixedArg(asm, br, sig.GetParameterType(i)));
 			}
 			for (int i = 0; i < count; i++)
 			{
 				list.Add(ReadFixedArg(asm, br, sig.GetParameterType(i)));
 			}
 			return list.AsReadOnly();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1624" endline="1640">
<![CDATA[
 
 		void EmitIndexerName ()
 		{
 			if (!seen_normal_indexers)
 				return;
 
 			PredefinedAttribute pa = Module.PredefinedAttributes.DefaultMember;
 			if (pa.Constructor == null &&
 				!pa.ResolveConstructor (Location, TypeManager.string_type))
 				return;
 
 			var encoder = new AttributeEncoder ();
 			encoder.Encode (GetAttributeDefaultMember ());
 			encoder.EncodeEmptyNamedArguments ();
 
 			pa.EmitAttribute (TypeBuilder, encoder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="109" endline="118">
<![CDATA[
 
 		public static int OpenScope (ILGenerator ig)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ig);
 				return symwriter.OpenScope (offset);
 			} else {
 				return -1;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="143" endline="154">
<![CDATA[
 
 		public string CodeBase
 		{
 			get
 			{
 				string path = this.Location.Replace(System.IO.Path.DirectorySeparatorChar, '/');
 				if (!path.StartsWith("/"))
 				{
 					path = "/" + path;
 				}
 				return "file
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="538" endline="549">
<![CDATA[
 
 		public Assembly LoadAssembly(RawModule module)
 		{
 			string refname = module.GetAssemblyName().FullName;
 			Assembly asm = GetLoadedAssembly(refname);
 			if (asm == null)
 			{
 				asm = module.ToAssembly();
 				assemblies.Add(asm);
 			}
 			return asm;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2343" endline="2356">
<![CDATA[
 
 		public override bool ContainsGenericParameters
 		{
 			get
 			{
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				foreach (Type type in args)
 				{
 					if (type.ContainsGenericParameters)
 					{
 						return true;
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="432" endline="441">
<![CDATA[
 
 		public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
 		{
 			TypeBuilder tb = DefineNestedType(name, attr, parent);
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			return tb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="191" endline="200">
<![CDATA[
 
 		public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
 		{
 			TypeBuilder tb = DefineType(name, attr, parent);
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			foreach (Type iface in interfaces)
 			{
 				tb.AddInterfaceImplementation(iface);
 			}
 			return tb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2255" endline="2267">
<![CDATA[
 
 		internal List<int> GetNestedClasses(int enclosingClass)
 		{
 			List<int> nestedClasses = new List<int>();
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].EnclosingClass == enclosingClass)
 				{
 					nestedClasses.Add(records[i].NestedClass);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].EnclosingClass == enclosingClass)
 				{
 					nestedClasses.Add(records[i].NestedClass);
 				}
 			}
 			return nestedClasses;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="137" endline="150">
<![CDATA[
 
 		internal static Type[] ReadMethodSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			if (br.ReadByte() != GENERICINST)
 			{
 				throw new BadImageFormatException();
 			}
 			Type[] args = new Type[br.ReadCompressedInt()];
 			for (int i = 0; i < args.Length; i++)
 			{
 				args[i] = ReadType(module, br, context);
 			}
 			for (int i = 0; i < args.Length; i++)
 			{
 				args[i] = ReadType(module, br, context);
 			}
 			return args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="151" endline="166">
<![CDATA[
 
 		private static int ReadArrayShape(ByteReader br)
 		{
 			int rank = br.ReadCompressedInt();
 			int numSizes = br.ReadCompressedInt();
 			for (int i = 0; i < numSizes; i++)
 			{
 				br.ReadCompressedInt();
 			}
 			for (int i = 0; i < numSizes; i++)
 			{
 				br.ReadCompressedInt();
 			}
 			int numLoBounds = br.ReadCompressedInt();
 			for (int i = 0; i < numLoBounds; i++)
 			{
 				br.ReadCompressedInt();
 			}
 			for (int i = 0; i < numLoBounds; i++)
 			{
 				br.ReadCompressedInt();
 			}
 			return rank;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="69" endline="78">
<![CDATA[
 
 		protected override bool HasVolatileModifier (MetaType[] modifiers)
 		{
 			foreach (var t in modifiers) {
 				if (t.Name == "IsVolatile" && t.Namespace == CompilerServicesNamespace)
 					return true;
 			}
 			foreach (var t in modifiers) {
 				if (t.Name == "IsVolatile" && t.Namespace == CompilerServicesNamespace)
 					return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="663" endline="674">
<![CDATA[
 
 		Expression ResolvePrimitivePredefinedType (Expression expr)
 		{
 			expr = DoNumericPromotion (Oper, expr);
 			TypeSpec expr_type = expr.Type;
 			TypeSpec[] predefined = predefined_operators [(int) Oper];
 			foreach (TypeSpec t in predefined) {
 				if (t == expr_type)
 					return expr;
 			}
 			foreach (TypeSpec t in predefined) {
 				if (t == expr_type)
 					return expr;
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="909" endline="924">
<![CDATA[
 
 		public Type GetInterface(string name, bool ignoreCase)
 		{
 			if (ignoreCase)
 			{
 				throw new NotImplementedException();
 			}
 			foreach (Type type in GetInterfaces())
 			{
 				if (type.FullName == name)
 				{
 					return type;
 				}
 			}
 			foreach (Type type in GetInterfaces())
 			{
 				if (type.FullName == name)
 				{
 					return type;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1502" endline="1514">
<![CDATA[
 
 		protected override bool IsNotCLSCompliant ()
 		{
 			if (base.IsNotCLSCompliant ())
 				return true;
 
 			foreach (var ta in TypeArguments) {
 				if (ta.MemberDefinition.IsNotCLSCompliant ())
 					return true;
 			}
 			foreach (var ta in TypeArguments) {
 				if (ta.MemberDefinition.IsNotCLSCompliant ())
 					return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="111" endline="124">
<![CDATA[
 
 		internal static T[] ToArray<T, V>(List<V> list, T[] empty) where V 
 		{
 			if (list == null || list.Count == 0)
 			{
 				return empty;
 			}
 			T[] array = new T[list.Count];
 			for (int i = 0; i < array.Length; i++)
 			{
 				array[i] = list[i];
 			}
 			for (int i = 0; i < array.Length; i++)
 			{
 				array[i] = list[i];
 			}
 			return array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1111" endline="1123">
<![CDATA[
 
 		public void SetUserEntryPoint(MethodInfo entryPoint)
 		{
 			int token = entryPoint.MetadataToken;
 			if (token < 0)
 			{
 				token = -token | 0x06000000;
 			}
 			if (symbolWriter != null)
 			{
 				symbolWriter.SetUserEntryPoint(new SymbolToken(token));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1366" endline="1377">
<![CDATA[
 
 		public void SetHasThisAccess ()
 		{
 			ExplicitBlock b = block;
 			do {
 				if (b.HasCapturedThis)
 					return;
 
 				b.HasCapturedThis = true;
 				b = b.Parent == null ? null 
 			} while (b != null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="301" endline="311">
<![CDATA[
 
 		internal void AddTypeForwarder(Type type)
 		{
 			ExportType(type);
 			foreach (Type nested in type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic))
 			{
 				// we export all nested types (i.e. even the private ones)
 				// (this behavior is the same as the C# compiler)
 				AddTypeForwarder(nested);
 			}
 			foreach (Type nested in type.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic))
 			{
 				// we export all nested types (i.e. even the private ones)
 				// (this behavior is the same as the C# compiler)
 				AddTypeForwarder(nested);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1380" endline="1391">
<![CDATA[
 
 		internal int FindOrAddRecord(int blob)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == blob)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == blob)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(blob);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1774" endline="1785">
<![CDATA[
 
 		internal int FindOrAddRecord(int str)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == str)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i] == str)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(str);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="352" endline="370">
<![CDATA[
 
 		private static OrdinalOrName ReadOrdinalOrName(ByteReader br)
 		{
 			char c = br.ReadChar();
 			if (c == 0xFFFF)
 			{
 				return new OrdinalOrName(br.ReadUInt16());
 			}
 			else
 			{
 				StringBuilder sb = new StringBuilder();
 				while (c != 0)
 				{
 					sb.Append(c);
 					c = br.ReadChar();
 				}
 				while (c != 0)
 				{
 					sb.Append(c);
 					c = br.ReadChar();
 				}
 				return new OrdinalOrName(sb.ToString());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="432" endline="444">
<![CDATA[
 
 		//
 		// At least one argument is of dynamic type
 		//
 		public bool HasDynamic {
 			get {
 				foreach (Argument a in args) {
 					if (a.Type == InternalType.Dynamic && !a.IsByRef)
 						return true;
 				}
 				foreach (Argument a in args) {
 					if (a.Type == InternalType.Dynamic && !a.IsByRef)
 						return true;
 				}
 				
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="488" endline="499">
<![CDATA[
 
 		protected static void WriteCustomModifiers(ModuleBuilder module, ByteBuffer bb, byte mod, Type[] modifiers)
 		{
 			if (modifiers != null)
 			{
 				foreach (Type type in modifiers)
 				{
 					bb.Write(mod);
 					bb.WriteTypeDefOrRefEncoded(module.GetTypeTokenForMemberRef(type));
 				}
 				foreach (Type type in modifiers)
 				{
 					bb.Write(mod);
 					bb.WriteTypeDefOrRefEncoded(module.GetTypeTokenForMemberRef(type));
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="416" endline="426">
<![CDATA[
 
 		private static void AddMembers(List<MemberInfo> list, MemberFilter filter, object filterCriteria, MemberInfo[] members)
 		{
 			foreach (MemberInfo member in members)
 			{
 				if (filter == null || filter(member, filterCriteria))
 				{
 					list.Add(member);
 				}
 			}
 			foreach (MemberInfo member in members)
 			{
 				if (filter == null || filter(member, filterCriteria))
 				{
 					list.Add(member);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="590" endline="604">
<![CDATA[
 
 		private Assembly GetDynamicAssembly(string refname)
 		{
 			foreach (AssemblyBuilder asm in dynamicAssemblies)
 			{
 				AssemblyComparisonResult result;
 				// We won't allow FX unification here, because our own (non-Fusion) implementation of CompareAssemblyIdentity doesn't support it and
 				// we don't want to create a fundamental functional difference based on that.
 				if (CompareAssemblyIdentity(refname, false, asm.FullName, false, out result) && result != AssemblyComparisonResult.EquivalentFXUnified)
 				{
 					return asm;
 				}
 			}
 			foreach (AssemblyBuilder asm in dynamicAssemblies)
 			{
 				AssemblyComparisonResult result;
 				// We won't allow FX unification here, because our own (non-Fusion) implementation of CompareAssemblyIdentity doesn't support it and
 				// we don't want to create a fundamental functional difference based on that.
 				if (CompareAssemblyIdentity(refname, false, asm.FullName, false, out result) && result != AssemblyComparisonResult.EquivalentFXUnified)
 				{
 					return asm;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="3190" endline="3204">
<![CDATA[
 
 		void RemoveDependentTypes (List<TypeSpec> types, TypeSpec returnType)
 		{
 			int idx = IsUnfixed (returnType);
 			if (idx >= 0) {
 				types [idx] = null;
 				return;
 			}
 
 			if (TypeManager.IsGenericType (returnType)) {
 				foreach (TypeSpec t in TypeManager.GetTypeArguments (returnType)) {
 					RemoveDependentTypes (types, t);
 				}
 				foreach (TypeSpec t in TypeManager.GetTypeArguments (returnType)) {
 					RemoveDependentTypes (types, t);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="117" endline="132">
<![CDATA[
 
 		public override MethodInfo[] GetOtherMethods(bool nonPublic)
 		{
 			List<MethodInfo> list = new List<MethodInfo>();
 			if (otherMethods != null)
 			{
 				foreach (MethodInfo method in otherMethods)
 				{
 					if (nonPublic || method.IsPublic)
 					{
 						list.Add(method);
 					}
 				}
 				foreach (MethodInfo method in otherMethods)
 				{
 					if (nonPublic || method.IsPublic)
 					{
 						list.Add(method);
 					}
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="143" endline="157">
<![CDATA[
 
 		public override MethodInfo[] GetAccessors(bool nonPublic)
 		{
 			List<MethodInfo> list = new List<MethodInfo>();
 			AddAccessor(list, nonPublic, getter);
 			AddAccessor(list, nonPublic, setter);
 			if (otherMethods != null)
 			{
 				foreach (MethodInfo method in otherMethods)
 				{
 					AddAccessor(list, nonPublic, method);
 				}
 				foreach (MethodInfo method in otherMethods)
 				{
 					AddAccessor(list, nonPublic, method);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2292" endline="2307">
<![CDATA[
 		}
 
 		public override string ToString()
 		{
 			StringBuilder sb = new StringBuilder(type.FullName);
 			sb.Append('[');
 			string sep = "";
 			foreach (Type arg in args)
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			foreach (Type arg in args)
 			{
 				sb.Append(sep);
 				sb.Append(arg);
 				sep = ",";
 			}
 			sb.Append(']');
 			return sb.ToString();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="541" endline="555">
<![CDATA[
 
 	static public string CSharpName (IList<TypeSpec> types)
 	{
 		if (types.Count == 0)
 			return string.Empty;
 
 		StringBuilder sb = new StringBuilder ();
 		for (int i = 0; i < types.Count; ++i) {
 			if (i > 0)
 				sb.Append (",");
 
 			sb.Append (CSharpName (types [i]));
 		}
 		for (int i = 0; i < types.Count; ++i) {
 			if (i > 0)
 				sb.Append (",");
 
 			sb.Append (CSharpName (types [i]));
 		}
 		return sb.ToString ();
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="154" endline="169">
<![CDATA[
 		}
 
 		// TODO
 		// IsGenericType -- recursive
 		// HasTypeParameter -- non-recursive
 		public bool IsGenericOrParentIsGeneric {
 			get {
 				var ts = this;
 				do {
 					if (ts.IsGeneric)
 						return true;
 					ts = ts.declaringType;
 				} while (ts != null);
 
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2682" endline="2690">
<![CDATA[
 
 		public bool FixAllTypes (ResolveContext ec)
 		{
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (!FixType (ec, i))
 					return false;
 			}
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (!FixType (ec, i))
 					return false;
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="181" endline="196">
<![CDATA[
 
 		//
 		// This is used if the expression should be resolved as a type or namespace name.
 		// the default implementation fails.   
 		//
 		public virtual FullNamedExpression ResolveAsTypeStep (IMemberContext rc,  bool silent)
 		{
 			if (!silent) {
 				ResolveContext ec = new ResolveContext (rc);
 				Expression e = Resolve (ec);
 				if (e != null)
 					e.Error_UnexpectedKind (ec, ResolveFlags.Type, loc);
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="799" endline="811">
<![CDATA[
 
 		//
 		// Returns the parameter information based on the name
 		//
 		public int GetParameterIndexByName (string name)
 		{
 			for (int idx = 0; idx < Count; ++idx) {
 				if (parameters [idx].Name == name)
 					return idx;
 			}
 			for (int idx = 0; idx < Count; ++idx) {
 				if (parameters [idx].Name == name)
 					return idx;
 			}
 
 			return -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="288" endline="299">
<![CDATA[
 
 		internal int Hash()
 		{
 			int hash = 0;
 			int len = this.Length;
 			for (int i = 0; i < len; i++)
 			{
 				hash *= 37;
 				hash ^= buffer[i];
 			}
 			for (int i = 0; i < len; i++)
 			{
 				hash *= 37;
 				hash ^= buffer[i];
 			}
 			return hash;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="140" endline="151">
<![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.callingConvention = CallingConventions.Standard;
 			foreach (Type type in parameterTypes)
 			{
 				sig.AddArgument(type);
 			}
 			foreach (Type type in parameterTypes)
 			{
 				sig.AddArgument(type);
 			}
 			return sig;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="67" endline="78">
<![CDATA[
 
 		static private byte[] Trim (byte[] array) 
 		{
 			for (int i=0; i < array.Length; i++) {
 				if (array [i] != 0x00) {
 					byte[] result = new byte [array.Length - i];
 					Buffer.BlockCopy (array, i, result, 0, result.Length);
 					return result;
 				}
 			}
 			for (int i=0; i < array.Length; i++) {
 				if (array [i] != 0x00) {
 					byte[] result = new byte [array.Length - i];
 					Buffer.BlockCopy (array, i, result, 0, result.Length);
 					return result;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="610" endline="623">
<![CDATA[
 		}
 
 		internal override IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
 		{
 			List<CustomAttributeData> list = new List<CustomAttributeData>();
 			foreach (CustomAttributeBuilder cab in customAttributes)
 			{
 				if (attributeType == null || attributeType.IsAssignableFrom(cab.Constructor.DeclaringType))
 				{
 					list.Add(cab.ToData(this));
 				}
 			}
 			foreach (CustomAttributeBuilder cab in customAttributes)
 			{
 				if (attributeType == null || attributeType.IsAssignableFrom(cab.Constructor.DeclaringType))
 				{
 					list.Add(cab.ToData(this));
 				}
 			}
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2150" endline="2168">
<![CDATA[
 		}
 
 		public override bool IsVisible
 		{
 			get
 			{
 				if (base.IsVisible)
 				{
 					foreach (Type arg in args)
 					{
 						if (!arg.IsVisible)
 						{
 							return false;
 						}
 					}
 					foreach (Type arg in args)
 					{
 						if (!arg.IsVisible)
 						{
 							return false;
 						}
 					}
 					return true;
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="43" endline="447">
<![CDATA[
 		
 		Expression instance_expr;
 		ReturnParameter return_attributes;
 
 		const Modifiers MethodModifiers = Modifiers.PUBLIC | Modifiers.VIRTUAL;
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.UNSAFE |
 			Modifiers.PRIVATE;
 
  		public Delegate (NamespaceEntry ns, DeclSpace parent, FullNamedExpression type,
 				 Modifiers mod_flags, MemberName name, ParametersCompiled param_list,
 				 Attributes attrs)
 			
 
 		{
 			this.ReturnType = type;
 			ModFlags        = ModifiersExtensions.Check (AllowedModifiers, mod_flags,
 							   IsTopLevel ? Modifiers.INTERNAL 
 							   Modifiers.PRIVATE, name.Location, Report);
 			parameters      = param_list;
 			spec = new TypeSpec (Kind, null, this, null, ModFlags | Modifiers.SEALED);
 		}
 
 		#region Properties
 		public TypeSpec MemberType {
 			get {
 				return ReturnType.Type;
 			}
 		}
 
 		public AParametersCollection Parameters {
 			get {
 				return parameters;
 			}
 		}
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Delegate;
 			}
 		}
 
 		protected override bool DoDefineMembers ()
 		{
 			var ctor_parameters = ParametersCompiled.CreateFullyResolved (
 				new [] {
 					new Parameter (new TypeExpression (TypeManager.object_type, Location), "object", Parameter.Modifier.NONE, null, Location),
 					new Parameter (new TypeExpression (TypeManager.intptr_type, Location), "method", Parameter.Modifier.NONE, null, Location)
 				},
 				new [] {
 					TypeManager.object_type,
 					TypeManager.intptr_type
 				}
 			);
 
 			Constructor = new Constructor (this, Constructor.ConstructorName,
 				Modifiers.PUBLIC, null, ctor_parameters, null, Location);
 			Constructor.Define ();
 
 			//
 			// Here the various methods like Invoke, BeginInvoke etc are defined
 			//
 			// First, call the `out of band' special method for
 			// defining recursively any types we need
 			//
 			var p = parameters;
 
 			if (!p.Resolve (this))
 				return false;
 
 			//
 			// Invoke method
 			//
 
 			// Check accessibility
 			foreach (var partype in p.Types) {
 				if (!IsAccessibleAs (partype)) {
 					Report.SymbolRelatedToPreviousError (partype);
 					Report.Error (59, Location,
 						"Inconsistent accessibility
 						TypeManager.CSharpName (partype), GetSignatureForError ());
 				}
 			}
 
 			ReturnType = ReturnType.ResolveAsTypeTerminal (this, false);
 			if (ReturnType == null)
 				return false;
 
 			var ret_type = ReturnType.Type;
 
 			//
 			// We don't have to check any others because they are all
 			// guaranteed to be accessible - they are standard types.
 			//
 			if (!IsAccessibleAs (ret_type)) {
 				Report.SymbolRelatedToPreviousError (ret_type);
 				Report.Error (58, Location,
 						  "Inconsistent accessibility
 						  TypeManager.CSharpName (ret_type) + "' is less " +
 						  "accessible than delegate `" + GetSignatureForError () + "'");
 				return false;
 			}
 
 			CheckProtectedModifier ();
 
 			if (RootContext.StdLib && TypeManager.IsSpecialType (ret_type)) {
 				Method.Error1599 (Location, ret_type, Report);
 				return false;
 			}
 
 			TypeManager.CheckTypeVariance (ret_type, Variance.Covariant, this);
 
 			InvokeBuilder = new Method (this, null, ReturnType, MethodModifiers, new MemberName (InvokeMethodName), p, null);
 			InvokeBuilder.Define ();
 
 			//
 			// Don't emit async method for compiler generated delegates (e.g. dynamic site containers)
 			//
 			if (!IsCompilerGenerated) {
 				DefineAsyncMethods (Parameters.CallingConvention);
 			}
 
 			return true;
 		}
 
 		void DefineAsyncMethods (CallingConventions cc)
 		{
 			var iasync_result = Module.PredefinedTypes.IAsyncResult;
 			var async_callback = Module.PredefinedTypes.AsyncCallback;
 
 			//
 			// It's ok when async types don't exist, the delegate will have Invoke method only
 			//
 			if (!iasync_result.Define () || !async_callback.Define ())
 				return;
 
 			//
 			// BeginInvoke
 			//
 			ParametersCompiled async_parameters;
 			if (Parameters.Count == 0) {
 				async_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 			} else {
 				var compiled = new Parameter[Parameters.Count];
 				for (int i = 0; i < compiled.Length; ++i) {
 					var p = parameters[i];
 					compiled[i] = new Parameter (new TypeExpression (parameters.Types[i], Location),
 						p.Name,
 						p.ModFlags & (Parameter.Modifier.REF | Parameter.Modifier.OUT),
 						p.OptAttributes == null ? null 
 				}
 
 				async_parameters = new ParametersCompiled (compiled);
 			}
 
 			async_parameters = ParametersCompiled.MergeGenerated (Compiler, async_parameters, false,
 				new Parameter[] {
 					new Parameter (new TypeExpression (async_callback.TypeSpec, Location), "callback", Parameter.Modifier.NONE, null, Location),
 					new Parameter (new TypeExpression (TypeManager.object_type, Location), "object", Parameter.Modifier.NONE, null, Location)
 				},
 				new [] {
 					async_callback.TypeSpec,
 					TypeManager.object_type
 				}
 			);
 
 			BeginInvokeBuilder = new Method (this, null,
 				new TypeExpression (iasync_result.TypeSpec, Location), MethodModifiers,
 				new MemberName ("BeginInvoke"), async_parameters, null);
 			BeginInvokeBuilder.Define ();
 
 			//
 			// EndInvoke is a bit more interesting, all the parameters labeled as
 			// out or ref have to be duplicated here.
 			//
 
 			//
 			// Define parameters, and count out/ref parameters
 			//
 			ParametersCompiled end_parameters;
 			int out_params = 0;
 
 			foreach (Parameter p in Parameters.FixedParameters) {
 				if ((p.ModFlags & Parameter.Modifier.ISBYREF) != 0)
 					++out_params;
 			}
 
 			if (out_params > 0) {
 				Parameter[] end_params = new Parameter[out_params];
 
 				int param = 0;
 				for (int i = 0; i < Parameters.FixedParameters.Length; ++i) {
 					Parameter p = parameters [i];
 					if ((p.ModFlags & Parameter.Modifier.ISBYREF) == 0)
 						continue;
 
 					end_params [param++] = new Parameter (new TypeExpression (p.Type, Location),
 						p.Name,
 						p.ModFlags & (Parameter.Modifier.REF | Parameter.Modifier.OUT),
 						p.OptAttributes == null ? null 
 				}
 
 				end_parameters = new ParametersCompiled (end_params);
 			} else {
 				end_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 			}
 
 			end_parameters = ParametersCompiled.MergeGenerated (Compiler, end_parameters, false,
 				new Parameter (
 					new TypeExpression (iasync_result.TypeSpec, Location),
 					"result", Parameter.Modifier.NONE, null, Location),
 				iasync_result.TypeSpec);
 
 			//
 			// Create method, define parameters, register parameters with type system
 			//
 			EndInvokeBuilder = new Method (this, null, ReturnType, MethodModifiers, new MemberName ("EndInvoke"), end_parameters, null);
 			EndInvokeBuilder.Define ();
 		}
 
 		public override void DefineConstants ()
 		{
 			if (!Parameters.IsEmpty) {
 				parameters.ResolveDefaultValues (this);
 			}
 		}
 
 		public override void EmitType ()
 		{
 			if (ReturnType.Type != null) {
 				if (ReturnType.Type == InternalType.Dynamic) {
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 					Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 				} else if (ReturnType.Type.HasDynamicElement) {
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 					Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType.Type, Location);
 				}
 			}
 
 			Constructor.ParameterInfo.ApplyAttributes (this, Constructor.ConstructorBuilder);
 			Constructor.ConstructorBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 
 			parameters.ApplyAttributes (this, InvokeBuilder.MethodBuilder);
 			InvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 
 			if (BeginInvokeBuilder != null) {
 				BeginInvokeBuilder.ParameterInfo.ApplyAttributes (this, BeginInvokeBuilder.MethodBuilder);
 				EndInvokeBuilder.ParameterInfo.ApplyAttributes (this, EndInvokeBuilder.MethodBuilder);
 
 				BeginInvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 				EndInvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 			}
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			base.Emit ();
 		}
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			base_type = TypeManager.multicast_delegate_type;
 			base_class = null;
 			return null;
 		}
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed |
 					base.TypeAttr;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		//TODO
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			parameters.VerifyClsCompliance (this);
 
 			if (!ReturnType.Type.IsCLSCompliant ()) {
 				Report.Warning (3002, 1, Location, "Return type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
 
 
 		public static MethodSpec GetConstructor (CompilerContext ctx, TypeSpec container_type, TypeSpec delType)
 		{
 			var ctor = MemberCache.FindMember (delType, MemberFilter.Constructor (null), BindingRestriction.DeclaredOnly);
 			return (MethodSpec) ctor;
 		}
 
 		//
 		// Returns the "Invoke" from a delegate type
 		//
 		public static MethodSpec GetInvokeMethod (CompilerContext ctx, TypeSpec delType)
 		{
 			var invoke = MemberCache.FindMember (delType,
 				MemberFilter.Method (InvokeMethodName, 0, null, null),
 				BindingRestriction.DeclaredOnly);
 
 			return (MethodSpec) invoke;
 		}
 
 		public static AParametersCollection GetParameters (CompilerContext ctx, TypeSpec delType)
 		{
 			var invoke_mb = GetInvokeMethod (ctx, delType);
 			return invoke_mb.Parameters;
 		}
 
 		//
 		// 15.2 Delegate compatibility
 		//
 		public static bool IsTypeCovariant (Expression a, TypeSpec b)
 		{
 			//
 			// For each value parameter (a parameter with no ref or out modifier), an 
 			// identity conversion or implicit reference conversion exists from the
 			// parameter type in D to the corresponding parameter type in M
 			//
 			if (a.Type == b)
 				return true;
 
 			if (RootContext.Version == LanguageVersion.ISO_1)
 				return false;
 
 			return Convert.ImplicitReferenceConversionExists (a, b);
 		}
 
 		public static string FullDelegateDesc (MethodSpec invoke_method)
 		{
 			return TypeManager.GetFullNameSignature (invoke_method).Replace (".Invoke", "");
 		}
 		
 		public Expression InstanceExpression {
 			get {
 				return instance_expr;
 			}
 			set {
 				instance_expr = value;
 			}
 		}
 	}
 
 	//
 	// Base class for `NewDelegate' and `ImplicitDelegateCreation'
 	//
 	public abstract class DelegateCreation 
 	{
 		protected MethodSpec constructor_method;
 		protected MethodGroupExpr method_group;
 
 		public static Arguments CreateDelegateMethodArguments (AParametersCollection pd, TypeSpec[] types, Location loc)
 		{
 			Arguments delegate_arguments = new Arguments (pd.Count);
 			for (int i = 0; i < pd.Count; ++i) {
 				Argument.AType atype_modifier;
 				switch (pd.FixedParameters [i].ModFlags) {
 				case Parameter.Modifier.REF
 					atype_modifier = Argument.AType.Ref;
 					break;
 				case Parameter.Modifier.OUT
 					atype_modifier = Argument.AType.Out;
 					break;
 				default
 					atype_modifier = 0;
 					break;
 				}
 
 				delegate_arguments.Add (new Argument (new TypeExpression (types [i], loc), atype_modifier));
 			}
 			for (int i = 0; i < pd.Count; ++i) {
 				Argument.AType atype_modifier;
 				switch (pd.FixedParameters [i].ModFlags) {
 				case Parameter.Modifier.REF
 					atype_modifier = Argument.AType.Ref;
 					break;
 				case Parameter.Modifier.OUT
 					atype_modifier = Argument.AType.Out;
 					break;
 				default
 					atype_modifier = 0;
 					break;
 				}
 
 				delegate_arguments.Add (new Argument (new TypeExpression (types [i], loc), atype_modifier));
 			}
 
 			return delegate_arguments;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="223" endline="240">
<![CDATA[
 
 		internal static int GetHashCode(Type[] types)
 		{
 			if (types == null)
 			{
 				return 0;
 			}
 			int h = 0;
 			foreach (Type t in types)
 			{
 				if (t != null)
 				{
 					h *= 3;
 					h ^= t.GetHashCode();
 				}
 			}
 			foreach (Type t in types)
 			{
 				if (t != null)
 				{
 					h *= 3;
 					h ^= t.GetHashCode();
 				}
 			}
 			return h;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="341" endline="358">
<![CDATA[
 
 		private static bool ParsePublicKey(string str, out string publicKeyToken)
 		{
 			if (str == null)
 			{
 				publicKeyToken = null;
 				return false;
 			}
 			// HACK use AssemblyName to convert PublicKey to PublicKeyToken
 			byte[] token = new AssemblyName("Foo, PublicKey=" + str).GetPublicKeyToken();
 			StringBuilder sb = new StringBuilder(token.Length * 2);
 			for (int i = 0; i < token.Length; i++)
 			{
 				sb.AppendFormat("{0
 			}
 			for (int i = 0; i < token.Length; i++)
 			{
 				sb.AppendFormat("{0
 			}
 			publicKeyToken = sb.ToString();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1593" endline="1612">
<![CDATA[
 		}
 
 		#endregion
 
 		public override List<MissingType> ResolveMissingDependencies ()
 		{
 			var missing = base.ResolveMissingDependencies ();
 			foreach (var pt in parameters.Types) {
 				var m = pt.GetMissingDependencies ();
 				if (m == null)
 					continue;
 
 				if (missing == null)
 					missing = new List<MissingType> ();
 
 				missing.AddRange (m);
 			}
 			foreach (var pt in parameters.Types) {
 				var m = pt.GetMissingDependencies ();
 				if (m == null)
 					continue;
 
 				if (missing == null)
 					missing = new List<MissingType> ();
 
 				missing.AddRange (m);
 			}
 
 			return missing;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="147" endline="161">
<![CDATA[
 
 		private int GetLength(MetadataWriter mw)
 		{
 			int len = 4 + 4 + 8 + 8;
 			foreach (Table table in mw.ModuleBuilder.GetTables())
 			{
 				if (table != null && table.RowCount > 0)
 				{
 					len += 4;	// row count
 					len += table.GetLength(mw);
 				}
 			}
 			foreach (Table table in mw.ModuleBuilder.GetTables())
 			{
 				if (table != null && table.RowCount > 0)
 				{
 					len += 4;	// row count
 					len += table.GetLength(mw);
 				}
 			}
 			// note that we pad one extra (unexplained) byte
 			return len + 1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="911" endline="923">
<![CDATA[
 
 		public Constant GetNamedValue (string name)
 		{
 			if (named_values == null)
 				return null;
 
 			for (int i = 0; i < named_values.Count; ++i) {
 				if (named_values [i].Value.Name == name)
 					return named_values [i].Value.Expr as Constant;
 			}
 			for (int i = 0; i < named_values.Count; ++i) {
 				if (named_values [i].Value.Name == name)
 					return named_values [i].Value.Expr as Constant;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="670" endline="686">
<![CDATA[
 
 		public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
 		{
 			MethodInfo found = null;
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name && method.MethodSignature.MatchParameterTypes(types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			foreach (MethodInfo method in GetMethods(bindingAttr))
 			{
 				if (method.Name == name && method.MethodSignature.MatchParameterTypes(types))
 				{
 					if (found != null)
 					{
 						throw new AmbiguousMatchException();
 					}
 					found = method;
 				}
 			}
 			return found;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="369" endline="382">
<![CDATA[
 		}
 
 		public MemberInfo[] GetDefaultMembers()
 		{
 			Type defaultMemberAttribute = this.Module.universe.Import(typeof(System.Reflection.DefaultMemberAttribute));
 			foreach (CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(this))
 			{
 				if (cad.Constructor.DeclaringType.Equals(defaultMemberAttribute))
 				{
 					return GetMember((string)cad.ConstructorArguments[0].Value);
 				}
 			}
 			foreach (CustomAttributeData cad in CustomAttributeData.GetCustomAttributes(this))
 			{
 				if (cad.Constructor.DeclaringType.Equals(defaultMemberAttribute))
 				{
 					return GetMember((string)cad.ConstructorArguments[0].Value);
 				}
 			}
 			return Empty<MemberInfo>.Array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2056" endline="2062">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			for (int ix = 0; ix < statements.Count; ix++){
 				statements [ix].Emit (ec);
 			}
 			for (int ix = 0; ix < statements.Count; ix++){
 				statements [ix].Emit (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9346" endline="9355">
<![CDATA[
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			CollectionOrObjectInitializers t = (CollectionOrObjectInitializers) target;
 
 			t.initializers = new List<Expression> (initializers.Count);
 			foreach (var e in initializers)
 				t.initializers.Add (e.Clone (clonectx));
 			foreach (var e in initializers)
 				t.initializers.Add (e.Clone (clonectx));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="166" endline="185">
<![CDATA[
 		}
 
 		private int DirectoryLength
 		{
 			get
 			{
 				if (Data != null)
 				{
 					return 16;
 				}
 				else
 				{
 					int length = 16 + entries.Count * 8;
 					foreach (ResourceDirectoryEntry entry in entries)
 					{
 						length += entry.DirectoryLength;
 					}
 					foreach (ResourceDirectoryEntry entry in entries)
 					{
 						length += entry.DirectoryLength;
 					}
 					return length;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="575" endline="589">
<![CDATA[
 
 		public override void LoadReferences (ModuleContainer module)
 		{
 			Assembly corlib;
 			List<Tuple<RootNamespace, Assembly>> loaded;
 			base.LoadReferencesCore (module, out corlib, out loaded);
 
 			if (corlib == null)
 				return;
 
 			importer.ImportAssembly (corlib, module.GlobalRootNamespace);
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1418" endline="1428">
<![CDATA[
 
 		public static ReferenceContainer MakeType (TypeSpec element)
 		{
 			ReferenceContainer pc;
 			if (!instances.TryGetValue (element, out pc)) {
 				pc = new ReferenceContainer (element);
 				instances.Add (element, pc);
 			}
 
 			return pc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1460" endline="1470">
<![CDATA[
 
 		public static PointerContainer MakeType (TypeSpec element)
 		{
 			PointerContainer pc;
 			if (!instances.TryGetValue (element, out pc)) {
 				pc = new PointerContainer (element);
 				instances.Add (element, pc);
 			}
 
 			return pc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="445" endline="458">
<![CDATA[
 		}
 
 		//
 		// At least one argument is named argument
 		//
 		public bool HasNamed {
 			get {
 				foreach (Argument a in args) {
 					if (a is NamedArgument)
 						return true;
 				}
 				foreach (Argument a in args) {
 					if (a is NamedArgument)
 						return true;
 				}
 				
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="621" endline="632">
<![CDATA[
 
 		private static bool FindMethod(List<MethodInfo> methods, MethodInfo method)
 		{
 			foreach (MethodInfo m in methods)
 			{
 				if (m.Name == method.Name && m.MethodSignature.Equals(method.MethodSignature))
 				{
 					return true;
 				}
 			}
 			foreach (MethodInfo m in methods)
 			{
 				if (m.Name == method.Name && m.MethodSignature.Equals(method.MethodSignature))
 				{
 					return true;
 				}
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="983" endline="1000">
<![CDATA[
 
 		public override Type[] __GetDeclaredTypes()
 		{
 			if (this.HasNestedTypes)
 			{
 				List<Type> types = new List<Type>();
 				List<int> classes = this.ModuleBuilder.NestedClass.GetNestedClasses(token);
 				foreach (int nestedClass in classes)
 				{
 					types.Add(this.ModuleBuilder.ResolveType(nestedClass));
 				}
 				foreach (int nestedClass in classes)
 				{
 					types.Add(this.ModuleBuilder.ResolveType(nestedClass));
 				}
 				return types.ToArray();
 			}
 			else
 			{
 				return Type.EmptyTypes;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1296" endline="1307">
<![CDATA[
 
 		public Attribute Search (string explicitTarget, PredefinedAttribute t)
 		{
 			foreach (Attribute a in Attrs) {
 				if (explicitTarget != null && a.ExplicitTarget != explicitTarget)
 					continue;
 
 				if (a.ResolveType () == t)
 					return a;
 			}
 			foreach (Attribute a in Attrs) {
 				if (explicitTarget != null && a.ExplicitTarget != explicitTarget)
 					continue;
 
 				if (a.ResolveType () == t)
 					return a;
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="715" endline="727">
<![CDATA[
 
 		internal void WriteSymbolTokenMap()
 		{
 			for (int i = 0; i < resolvedTokens.Count; i++)
 			{
 				int newToken = resolvedTokens[i];
 				// The symbol API doesn't support remapping arbitrary integers, the types have to be the same,
 				// so we copy the type from the newToken, because our pseudo tokens don't have a type.
 				// (see MethodToken.SymbolToken)
 				int oldToken = (i + 1) | (newToken & ~0xFFFFFF);
 				SymbolSupport.RemapToken(symbolWriter, oldToken, newToken);
 			}
 			for (int i = 0; i < resolvedTokens.Count; i++)
 			{
 				int newToken = resolvedTokens[i];
 				// The symbol API doesn't support remapping arbitrary integers, the types have to be the same,
 				// so we copy the type from the newToken, because our pseudo tokens don't have a type.
 				// (see MethodToken.SymbolToken)
 				int oldToken = (i + 1) | (newToken & ~0xFFFFFF);
 				SymbolSupport.RemapToken(symbolWriter, oldToken, newToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="84" endline="96">
<![CDATA[
 
 		public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, Signature.PROPERTY);
 			sig.returnType = returnType;
 			sig.returnTypeOptionalCustomModifiers = Type.EmptyTypes;
 			sig.returnTypeRequiredCustomModifiers = Type.EmptyTypes;
 			foreach (Type type in parameterTypes)
 			{
 				sig.AddArgument(type);
 			}
 			foreach (Type type in parameterTypes)
 			{
 				sig.AddArgument(type);
 			}
 			return sig;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Impl\CryptoHack.cs" startline="35" endline="54">
<![CDATA[
 		{
 			// HACK use serialization to get at the private key or key container name,
 			// this should be more future proof than using reflection to access the fields directly.
 			SerializationInfo ser = new SerializationInfo(typeof(StrongNameKeyPair), new FormatterConverter());
 			((ISerializable)keyPair.keyPair).GetObjectData(ser, new StreamingContext());
 			byte[] key = (byte[])ser.GetValue("_keyPairArray", typeof(byte[]));
 			string keycontainer = ser.GetString("_keyPairContainer");
 			if (keycontainer != null)
 			{
 				CspParameters parm = new CspParameters();
 				parm.Flags = CspProviderFlags.UseMachineKeyStore;
 				parm.KeyContainerName = keycontainer;
 				parm.KeyNumber = 2;	// Signature
 				return new RSACryptoServiceProvider(parm);
 			}
 			else
 			{
 				return Mono.Security.Cryptography.CryptoConvert.FromCapiKeyBlob(key);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1698" endline="1713">
<![CDATA[
 		}
 
 		public string GetSignatureForError()
 		{
 			StringBuilder sb = new StringBuilder ();
 			for (int i = 0; i < Count; ++i) {
 				var expr = args[i];
 				if (expr != null)
 					sb.Append (expr.GetSignatureForError ());
 
 				if (i + 1 < Count)
 					sb.Append (',');
 			}
 			for (int i = 0; i < Count; ++i) {
 				var expr = args[i];
 				if (expr != null)
 					sb.Append (expr.GetSignatureForError ());
 
 				if (i + 1 < Count)
 					sb.Append (',');
 			}
 
 			return sb.ToString ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="477" endline="490">
<![CDATA[
 
 		public override Type[] GetTypes()
 		{
 			List<Type> list = new List<Type>();
 			foreach (ModuleBuilder module in modules)
 			{
 				module.GetTypesImpl(list);
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				module.GetTypesImpl(list);
 			}
 			foreach (Module module in addedModules)
 			{
 				module.GetTypesImpl(list);
 			}
 			foreach (Module module in addedModules)
 			{
 				module.GetTypesImpl(list);
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="282" endline="294">
<![CDATA[
 
 		public override void CloseType ()
 		{
 			HackCorlibEnums ();
 
 			foreach (TypeContainer tc in types) {
 				tc.CloseType ();
 			}
 			foreach (TypeContainer tc in types) {
 				tc.CloseType ();
 			}
 
 			if (compiler_generated != null)
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					c.CloseType ();
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					c.CloseType ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="185" endline="209">
<![CDATA[
 		
 		public Namespace GetNamespace (string name, bool create)
 		{
 			int pos = name.IndexOf ('.');
 
 			Namespace ns;
 			string first;
 			if (pos >= 0)
 				first = name.Substring (0, pos);
 			else
 				first = name;
 
 			if (!namespaces.TryGetValue (first, out ns)) {
 				if (!create)
 					return null;
 
 				ns = new Namespace (this, first);
 				namespaces.Add (first, ns);
 			}
 
 			if (pos >= 0)
 				ns = ns.GetNamespace (name.Substring (pos + 1), create);
 
 			return ns;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1155" endline="1177">
<![CDATA[
 		}
 
 		public Expression CreateExpressionTree (BlockContext ec, Location loc)
 		{
 			var initializers = new ArrayInitializer (Count, loc);
 			foreach (Parameter p in FixedParameters) {
 				//
 				// Each parameter expression is stored to local variable
 				// to save some memory when referenced later.
 				//
 				StatementExpression se = new StatementExpression (p.CreateExpressionTreeVariable (ec));
 				if (se.Resolve (ec)) {
 					ec.CurrentBlock.AddScopeStatement (new TemporaryVariableReference.Declarator (p.ExpressionTreeVariableReference ()));
 					ec.CurrentBlock.AddScopeStatement (se);
 				}
 				
 				initializers.Add (p.ExpressionTreeVariableReference ());
 			}
 			foreach (Parameter p in FixedParameters) {
 				//
 				// Each parameter expression is stored to local variable
 				// to save some memory when referenced later.
 				//
 				StatementExpression se = new StatementExpression (p.CreateExpressionTreeVariable (ec));
 				if (se.Resolve (ec)) {
 					ec.CurrentBlock.AddScopeStatement (new TemporaryVariableReference.Declarator (p.ExpressionTreeVariableReference ()));
 					ec.CurrentBlock.AddScopeStatement (se);
 				}
 				
 				initializers.Add (p.ExpressionTreeVariableReference ());
 			}
 
 			return new ArrayCreation (
 				Parameter.ResolveParameterExpressionType (ec, loc),
 				initializers, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3296" endline="3307">
<![CDATA[
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			if (GenericMethod != null)
 				GenericMethod.VerifyClsCompliance ();
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="374" endline="389">
<![CDATA[
 		}
 
 		internal int WriteBlob(ModuleBuilder moduleBuilder)
 		{
 			ByteBuffer bb = new ByteBuffer(100);
 			if (blob != null)
 			{
 				bb.Write(blob);
 			}
 			else
 			{
 				BlobWriter bw = new BlobWriter(moduleBuilder, this, bb);
 				bw.WriteCustomAttributeBlob();
 			}
 			return moduleBuilder.Blobs.Add(bb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="212" endline="223">
<![CDATA[
 
 		public ModuleBuilder GetDynamicModule(string name)
 		{
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name == name)
 				{
 					return module;
 				}
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name == name)
 				{
 					return module;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="898" endline="909">
<![CDATA[
 
 		/// <summary>
 		///    Loads the given assembly and exposes the API to the user.
 		/// </summary>
 		static public void LoadAssembly (string file)
 		{
 			lock (evaluator_lock){
 				var a = loader.LoadAssemblyFile (file);
 				if (a != null)
 					loader.Importer.ImportAssembly (a, RootContext.ToplevelTypes.GlobalRootNamespace);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="652" endline="665">
<![CDATA[
 
 		internal static void WriteLocalVarSig(ModuleBuilder module, ByteBuffer bb, IList<LocalBuilder> locals)
 		{
 			bb.Write(LOCAL_SIG);
 			bb.WriteCompressedInt(locals.Count);
 			foreach (LocalBuilder local in locals)
 			{
 				if (local.IsPinned)
 				{
 					bb.Write(ELEMENT_TYPE_PINNED);
 				}
 				WriteType(module, bb, local.LocalType);
 			}
 			foreach (LocalBuilder local in locals)
 			{
 				if (local.IsPinned)
 				{
 					bb.Write(ELEMENT_TYPE_PINNED);
 				}
 				WriteType(module, bb, local.LocalType);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="183" endline="207">
<![CDATA[
 
 		public static AssemblyName GetAssemblyName(string path)
 		{
 			try
 			{
 				path = Path.GetFullPath(path);
 				using (FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read))
 				{
 					ModuleReader module = new ModuleReader(null, null, fs, path);
 					if (module.Assembly == null)
 					{
 						throw new BadImageFormatException("Module does not contain a manifest");
 					}
 					return module.Assembly.GetName();
 				}
 			}
 			catch (IOException x)
 			{
 				throw new FileNotFoundException(x.Message, x);
 			}
 			catch (UnauthorizedAccessException x)
 			{
 				throw new FileNotFoundException(x.Message, x);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3593" endline="3604">
<![CDATA[
 
 		SwitchSection FindSection (SwitchLabel label)
 		{
 			foreach (SwitchSection ss in Sections){
 				foreach (SwitchLabel sl in ss.Labels){
 					if (label == sl)
 						return ss;
 				}
 				foreach (SwitchLabel sl in ss.Labels){
 					if (label == sl)
 						return ss;
 				}
 			}
 			foreach (SwitchSection ss in Sections){
 				foreach (SwitchLabel sl in ss.Labels){
 					if (label == sl)
 						return ss;
 				}
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2273" endline="2291">
<![CDATA[
 		}
 
 		public override string FullName
 		{
 			get
 			{
 				if (this.ContainsGenericParameters)
 				{
 					return null;
 				}
 				StringBuilder sb = new StringBuilder(base.FullName);
 				sb.Append('[');
 				foreach (Type type in args)
 				{
 					sb.Append('[').Append(type.AssemblyQualifiedName.Replace("]", "\\]")).Append(']');
 				}
 				foreach (Type type in args)
 				{
 					sb.Append('[').Append(type.AssemblyQualifiedName.Replace("]", "\\]")).Append(']');
 				}
 				sb.Append(']');
 				return sb.ToString();
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="564" endline="570">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (break_origins);
 			return vector;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="588" endline="594">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 			vector.MergeOrigins (continue_origins);
 			return vector;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="672" endline="678">
<![CDATA[
 
 	string GetFullName (Type t)
 	{
 		StringBuilder sb = new StringBuilder ();
 		GetFullName_recursed (sb, t, false);
 		return sb.ToString ();
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1379" endline="1393">
<![CDATA[
 
 		public static ArrayContainer MakeType (TypeSpec element, int rank)
 		{
 			ArrayContainer ac;
 			var key = new TypeRankPair (element, rank);
 			if (!instances.TryGetValue (key, out ac)) {
 				ac = new ArrayContainer (element, rank) {
 					BaseType = TypeManager.array_type
 				};
 
 				instances.Add (key, ac);
 			}
 
 			return ac;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1634" endline="1644">
<![CDATA[
 
 		internal MethodInfo[] GetMethods(Module module, int token, bool nonPublic, short semantics)
 		{
 			List<MethodInfo> methods = new List<MethodInfo>();
 			MethodInfo method;
 			for (int i = 0; (method = GetNextMethod(module, token, nonPublic, semantics, ref i)) != null; )
 			{
 				methods.Add(method);
 			}
 			for (int i = 0; (method = GetNextMethod(module, token, nonPublic, semantics, ref i)) != null; )
 			{
 				methods.Add(method);
 			}
 			return methods.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3110" endline="3119">
<![CDATA[
 
 		public SwitchSection Clone (CloneContext clonectx)
 		{
 			var cloned_labels = new List<SwitchLabel> ();
 
 			foreach (SwitchLabel sl in Labels)
 				cloned_labels.Add (sl.Clone (clonectx));
 			foreach (SwitchLabel sl in Labels)
 				cloned_labels.Add (sl.Clone (clonectx));
 			
 			return new SwitchSection (cloned_labels, clonectx.LookupBlock (Block));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="772" endline="783">
<![CDATA[
 
 		private Type ResolveModuleType(int token)
 		{
 			int index = (token & 0xFFFFFF) - 1;
 			string name = GetString(ModuleRef.records[index]);
 			Module module = assembly.GetModule(name);
 			if (module == null || module.IsResource())
 			{
 				throw new BadImageFormatException();
 			}
 			return module.GetModuleType();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="635" endline="652">
<![CDATA[
 
 		public void EmitAddressOf (EmitContext ec)
 		{
 			int arg_idx = idx;
 
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			bool is_ref = (ModFlags & Modifier.ISBYREF) != 0;
 			if (is_ref) {
 				ParameterReference.EmitLdArg (ec, arg_idx);
 			} else {
 				if (arg_idx <= 255)
 					ec.Emit (OpCodes.Ldarga_S, (byte) arg_idx);
 				else
 					ec.Emit (OpCodes.Ldarga, arg_idx);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="119" endline="129">
<![CDATA[
 		}
 
 		public override MethodBody GetMethodBody()
 		{
 			IKVM.Reflection.Reader.MethodDefImpl md = method as IKVM.Reflection.Reader.MethodDefImpl;
 			if (md != null)
 			{
 				return md.GetMethodBody(this);
 			}
 			throw new NotSupportedException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="195" endline="208">
<![CDATA[
 		}
 
 		public virtual string Namespace
 		{
 			get
 			{
 				if (IsNested)
 				{
 					return null;
 				}
 				string fullname = FullName;
 				int index = fullname.LastIndexOf('.');
 				return index < 0 ? null 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="710" endline="719">
<![CDATA[
 
 		internal static void WriteMethodSpec(ModuleBuilder module, ByteBuffer bb, Type[] genArgs)
 		{
 			bb.Write(GENERICINST);
 			bb.WriteCompressedInt(genArgs.Length);
 			foreach (Type arg in genArgs)
 			{
 				WriteType(module, bb, arg);
 			}
 			foreach (Type arg in genArgs)
 			{
 				WriteType(module, bb, arg);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="861" endline="872">
<![CDATA[
 
 		internal ManifestResourceInfo GetManifestResourceInfo(string resourceName)
 		{
 			for (int i = 0; i < ManifestResource.records.Length; i++)
 			{
 				if (resourceName == GetString(ManifestResource.records[i].Name))
 				{
 					return new ManifestResourceInfo(this, i);
 				}
 			}
 			for (int i = 0; i < ManifestResource.records.Length; i++)
 			{
 				if (resourceName == GetString(ManifestResource.records[i].Name))
 				{
 					return new ManifestResourceInfo(this, i);
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1130" endline="1145">
<![CDATA[
 
 		// Define each type attribute (in/out/ref) and
 		// the argument names.
 		public void ApplyAttributes (IMemberContext mc, MethodBase builder)
 		{
 			if (Count == 0)
 				return;
 
 			MethodBuilder mb = builder as MethodBuilder;
 			ConstructorBuilder cb = builder as ConstructorBuilder;
 			var pa = mc.Module.PredefinedAttributes;
 
 			for (int i = 0; i < Count; i++) {
 				this [i].ApplyAttributes (mb, cb, i + 1, pa);
 			}
 			for (int i = 0; i < Count; i++) {
 				this [i].ApplyAttributes (mb, cb, i + 1, pa);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="466" endline="479">
<![CDATA[
 
 		public static System.Linq.Expressions.Expression[] MakeExpression (Arguments args, BuilderContext ctx)
 		{
 			if (args == null || args.Count == 0)
 				return null;
 
 			var exprs = new System.Linq.Expressions.Expression [args.Count];
 			for (int i = 0; i < exprs.Length; ++i) {
 				Argument a = args.args [i];
 				exprs[i] = a.Expr.MakeExpression (ctx);
 			}
 			for (int i = 0; i < exprs.Length; ++i) {
 				Argument a = args.args [i];
 				exprs[i] = a.Expr.MakeExpression (ctx);
 			}
 
 			return exprs;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="262" endline="282">
<![CDATA[
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			if (Kind != MemberKind.Class)
 				throw new InternalErrorException ();
 
 			if (!pa.IsDefined)
 				return Attribute.DefaultUsageAttribute;
 
 			AttributeUsageAttribute aua = null;
 			var type = this;
 			while (type != null) {
 				aua = type.MemberDefinition.GetAttributeUsage (pa);
 				if (aua != null)
 					break;
 
 				type = type.BaseType;
 			}
 			while (type != null) {
 				aua = type.MemberDefinition.GetAttributeUsage (pa);
 				if (aua != null)
 					break;
 
 				type = type.BaseType;
 			}
 
 			return aua;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="570" endline="591">
<![CDATA[
 
 		/// <summary>
 		///   Returns a temporary storage for a variable of type t as 
 		///   a local variable in the current body.
 		/// </summary>
 		public LocalBuilder GetTemporaryLocal (TypeSpec t)
 		{
 			if (temporary_storage != null) {
 				object o;
 				if (temporary_storage.TryGetValue (t, out o)) {
 					if (o is Stack<LocalBuilder>) {
 						var s = (Stack<LocalBuilder>) o;
 						o = s.Count == 0 ? null 
 					} else {
 						temporary_storage.Remove (t);
 					}
 				}
 				if (o != null)
 					return (LocalBuilder) o;
 			}
 			return DeclareLocal (t, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="37" endline="50">
<![CDATA[
 
 		protected static MemberName MakeMemberName (MemberBase host, string name, int unique_id, TypeParameter[] tparams, Location loc)
 		{
 			string host_name = host == null ? null 
 			string tname = MakeName (host_name, "c", name, unique_id);
 			TypeArguments args = null;
 			if (tparams != null) {
 				args = new TypeArguments ();
 				foreach (TypeParameter tparam in tparams)
 					args.Add (new TypeParameterName (tparam.Name, null, loc));
 				foreach (TypeParameter tparam in tparams)
 					args.Add (new TypeParameterName (tparam.Name, null, loc));
 			}
 
 			return new MemberName (tname, args, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="594" endline="616">
<![CDATA[
 
 		public AttributeUsageAttribute GetAttributeUsageAttribute ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return DefaultUsageAttribute;
 
 			AttributeUsageAttribute usage_attribute = new AttributeUsageAttribute ((AttributeTargets)((Constant) PosArguments [0].Expr).GetValue ());
 
 			var field = GetNamedValue ("AllowMultiple") as BoolConstant;
 			if (field != null)
 				usage_attribute.AllowMultiple = field.Value;
 
 			field = GetNamedValue ("Inherited") as BoolConstant;
 			if (field != null)
 				usage_attribute.Inherited = field.Value;
 
 			return usage_attribute;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2526" endline="2552">
<![CDATA[
 
 		//
 		// The `|' operator used on types which were extended is dangerous
 		//
 		void CheckBitwiseOrOnSignExtended (ResolveContext ec)
 		{
 			OpcodeCast lcast = left as OpcodeCast;
 			if (lcast != null) {
 				if (IsUnsigned (lcast.UnderlyingType))
 					lcast = null;
 			}
 
 			OpcodeCast rcast = right as OpcodeCast;
 			if (rcast != null) {
 				if (IsUnsigned (rcast.UnderlyingType))
 					rcast = null;
 			}
 
 			if (lcast == null && rcast == null)
 				return;
 
 			// FIXME
 
 			ec.Report.Warning (675, 3, loc,
 				"The operator `|' used on the sign-extended type `{0}'. Consider casting to a smaller unsigned type first",
 				TypeManager.CSharpName (lcast != null ? lcast.UnderlyingType 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="28" endline="44">
<![CDATA[
 		{
 			foreach (string name in names) {
 				if (name == null)
 					continue;
 
 				if (prefix != null && !name.StartsWith (prefix))
 					continue;
 
 				if (results.Contains (name))
 					continue;
 
 				if (prefix != null)
 					results.Add (name.Substring (prefix.Length));
 				else
 					results.Add (name);
 			}
 			foreach (string name in names) {
 				if (name == null)
 					continue;
 
 				if (prefix != null && !name.StartsWith (prefix))
 					continue;
 
 				if (results.Contains (name))
 					continue;
 
 				if (prefix != null)
 					results.Add (name.Substring (prefix.Length));
 				else
 					results.Add (name);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1187" endline="1204">
<![CDATA[
 
 		// Returns the explicit operator that converts from an
 		// express of type System.Decimal to 'type'.
 		public Expression Resolve ()
 		{
 			if (operators == null) {
 				var all_oper = MemberCache.GetUserOperator (TypeManager.decimal_type, Operator.OpType.Explicit, true);
 
 				operators = new Dictionary<TypeSpec, MethodSpec> ();
 				foreach (MethodSpec oper in all_oper) {
 					AParametersCollection pd = oper.Parameters;
 					if (pd.Types [0] == TypeManager.decimal_type)
 						operators.Add (oper.ReturnType, oper);
 				}
 				foreach (MethodSpec oper in all_oper) {
 					AParametersCollection pd = oper.Parameters;
 					if (pd.Types [0] == TypeManager.decimal_type)
 						operators.Add (oper.ReturnType, oper);
 				}
 			}
 
 			return operators.ContainsKey (type) ? this 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="559" endline="589">
<![CDATA[
 
 		protected static void ReadCustomModifiers(ModuleReader module, ByteReader br, IGenericContext context, out Type[] requiredCustomModifiers, out Type[] optionalCustomModifiers)
 		{
 			byte b = br.PeekByte();
 			if (IsCustomModifier(b))
 			{
 				List<Type> required = new List<Type>();
 				List<Type> optional = new List<Type>();
 				while (IsCustomModifier(b))
 				{
 					br.ReadByte();
 					Type type = ReadTypeDefOrRefEncoded(module, br, context);
 					if (b == ELEMENT_TYPE_CMOD_REQD)
 					{
 						required.Add(type);
 					}
 					else
 					{
 						optional.Add(type);
 					}
 					b = br.PeekByte();
 				}
 				while (IsCustomModifier(b))
 				{
 					br.ReadByte();
 					Type type = ReadTypeDefOrRefEncoded(module, br, context);
 					if (b == ELEMENT_TYPE_CMOD_REQD)
 					{
 						required.Add(type);
 					}
 					else
 					{
 						optional.Add(type);
 					}
 					b = br.PeekByte();
 				}
 				requiredCustomModifiers = required.ToArray();
 				optionalCustomModifiers = optional.ToArray();
 			}
 			else
 			{
 				requiredCustomModifiers = null;
 				optionalCustomModifiers = null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="151" endline="182">
<![CDATA[
 
 		static Expression ExplicitTypeParameterConversion (Expression source, TypeSpec source_type, TypeSpec target_type)
 		{
 			var target_tp = target_type as TypeParameterSpec;
 			if (target_tp != null) {
 				if (target_tp.TypeArguments != null) {
 					foreach (var targ in target_tp.TypeArguments) {
 						if (!TypeSpecComparer.Override.IsEqual (source_type, targ))
 							continue;
 
 						return source == null ? EmptyExpression.Null 
 					foreach (var targ in target_tp.TypeArguments) {
 						if (!TypeSpecComparer.Override.IsEqual (source_type, targ))
 							continue;
 
 						return source == null ? EmptyExpression.Null 
 					}
 				}
 /*
 				if (target_tp.Interfaces != null) {
 					foreach (TypeSpec iface in target_tp.Interfaces) {
 						if (!TypeManager.IsGenericParameter (iface))
 							continue;
 
 						if (TypeManager.IsSubclassOf (source_type, iface))
 							return source == null ? EmptyExpression.Null 
 					}
 				}
 */
 				return null;
 			}
 
 			if (target_type.IsInterface)
 				return source == null ? EmptyExpression.Null 
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="253" endline="264">
<![CDATA[
 		}
 
 		public byte[] ResolveSignature(int metadataToken)
 		{
 			ModuleReader rdr = this as ModuleReader;
 			if (rdr != null)
 			{
 				ByteReader br = rdr.ResolveSignature(metadataToken);
 				return br.ReadBytes(br.Length);
 			}
 			throw new NotSupportedException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="867" endline="873">
<![CDATA[
 		
 		static internal string [] GetVarNames ()
 		{
 			lock (evaluator_lock){
 				return new List<string> (fields.Keys).ToArray ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="398" endline="520">
<![CDATA[
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly MethodBuilder method;
 			private readonly int parameter;
 
 			internal ParameterInfoImpl(MethodBuilder method, int parameter)
 			{
 				this.method = method;
 				this.parameter = parameter;
 			}
 
 			private ParameterBuilder ParameterBuilder
 			{
 				get
 				{
 					if (method.parameters != null)
 					{
 						foreach (ParameterBuilder pb in method.parameters)
 						{
 							if (pb.Position == parameter)
 							{
 								return pb;
 							}
 						}
 					}
 					return null;
 				}
 			}
 
 			public override string Name
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? pb.Name 
 				}
 			}
 
 			public override Type ParameterType
 			{
 				get { return parameter == -1 ? method.returnType 
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? (ParameterAttributes)pb.Attributes 
 				}
 			}
 
 			public override int Position
 			{
 				get { return parameter; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					if (pb != null && (pb.Attributes & (int)ParameterAttributes.HasDefault) != 0)
 					{
 						return method.ModuleBuilder.Constant.GetRawConstantValue(method.ModuleBuilder, pb.PseudoToken);
 					}
 					if (pb != null && (pb.Attributes & (int)ParameterAttributes.Optional) != 0)
 					{
 						return Missing.Value;
 					}
 					return null;
 				}
 			}
 
 			private Type[] GetCustomModifiers(int optOrReq)
 			{
 				if (method.modifiers == null || method.modifiers[parameter + 1] == null)
 				{
 					return Type.EmptyTypes;
 				}
 				return Util.Copy(method.modifiers[parameter + 1][optOrReq]);
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return GetCustomModifiers(0);
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return GetCustomModifiers(1);
 			}
 
 			public override MemberInfo Member
 			{
 				get { return method; }
 			}
 
 			public override int MetadataToken
 			{
 				get
 				{
 					ParameterBuilder pb = this.ParameterBuilder;
 					return pb != null ? pb.PseudoToken 
 				}
 			}
 
 			internal override Module Module
 			{
 				get { return method.Module; }
 			}
 		}
 
 		public override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = new ParameterInfo[parameterTypes.Length];
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="3205" endline="3214">
<![CDATA[
 
 		public bool UnfixedVariableExists {
 			get {
 				foreach (TypeSpec ut in fixed_types) {
 					if (ut == null)
 						return true;
 				}
 				foreach (TypeSpec ut in fixed_types) {
 					if (ut == null)
 						return true;
 				}
 
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1400" endline="1420">
<![CDATA[
 		}
 
 		#endregion
 
 		public static bool ContainsTypeParameter (TypeSpec type)
 		{
 			if (type.Kind == MemberKind.TypeParameter)
 				return true;
 
 			var element_container = type as ElementTypeSpec;
 			if (element_container != null)
 				return ContainsTypeParameter (element_container.Element);
 
 			foreach (var t in type.TypeArguments) {
 				if (ContainsTypeParameter (t)) {
 					return true;
 				}
 			}
 			foreach (var t in type.TypeArguments) {
 				if (ContainsTypeParameter (t)) {
 					return true;
 				}
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1415" endline="1430">
<![CDATA[
 
 		internal void FillInExplicitInterfaceMethods(MethodInfo[] interfaceMethods, MethodInfo[] targetMethods)
 		{
 			__MethodImplMap impl = __GetMethodImplMap();
 			for (int i = 0; i < impl.MethodDeclarations.Length; i++)
 			{
 				for (int j = 0; j < impl.MethodDeclarations[i].Length; j++)
 				{
 					int index = Array.IndexOf(interfaceMethods, impl.MethodDeclarations[i][j]);
 					if (index != -1 && targetMethods[index] == null)
 					{
 						targetMethods[index] = impl.MethodBodies[i];
 					}
 				}
 				for (int j = 0; j < impl.MethodDeclarations[i].Length; j++)
 				{
 					int index = Array.IndexOf(interfaceMethods, impl.MethodDeclarations[i][j]);
 					if (index != -1 && targetMethods[index] == null)
 					{
 						targetMethods[index] = impl.MethodBodies[i];
 					}
 				}
 			}
 			for (int i = 0; i < impl.MethodDeclarations.Length; i++)
 			{
 				for (int j = 0; j < impl.MethodDeclarations[i].Length; j++)
 				{
 					int index = Array.IndexOf(interfaceMethods, impl.MethodDeclarations[i][j]);
 					if (index != -1 && targetMethods[index] == null)
 					{
 						targetMethods[index] = impl.MethodBodies[i];
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="304" endline="318">
<![CDATA[
 
 		public void VerifyClsCompliance (Report report)
 		{
 			foreach (var c in constraints)
 			{
 				if (c == null)
 					continue;
 
 				if (!c.Type.IsCLSCompliant ()) {
 					report.SymbolRelatedToPreviousError (c.Type);
 					report.Warning (3024, 1, loc, "Constraint type `{0}' is not CLS-compliant",
 						c.Type.GetSignatureForError ());
 				}
 			}
 			foreach (var c in constraints)
 			{
 				if (c == null)
 					continue;
 
 				if (!c.Type.IsCLSCompliant ()) {
 					report.SymbolRelatedToPreviousError (c.Type);
 					report.Warning (3024, 1, loc, "Constraint type `{0}' is not CLS-compliant",
 						c.Type.GetSignatureForError ());
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1497" endline="1514">
<![CDATA[
 
 		internal bool IsAllowMultipleCustomAttribute
 		{
 			get
 			{
 				IList<CustomAttributeData> cad = GetCustomAttributesData(this.Module.universe.System_AttributeUsageAttribute);
 				if (cad.Count == 1)
 				{
 					foreach (CustomAttributeNamedArgument arg in cad[0].NamedArguments)
 					{
 						if (arg.MemberInfo.Name == "AllowMultiple")
 						{
 							return (bool)arg.TypedValue.Value;
 						}
 					}
 					foreach (CustomAttributeNamedArgument arg in cad[0].NamedArguments)
 					{
 						if (arg.MemberInfo.Name == "AllowMultiple")
 						{
 							return (bool)arg.TypedValue.Value;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="550" endline="569">
<![CDATA[
 
 		public override Module[] GetModules(bool getResourceModules)
 		{
 			List<Module> list = new List<Module>();
 			foreach (ModuleBuilder module in modules)
 			{
 				if (getResourceModules || !module.IsResource())
 				{
 					list.Add(module);
 				}
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				if (getResourceModules || !module.IsResource())
 				{
 					list.Add(module);
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (getResourceModules || !module.IsResource())
 				{
 					list.Add(module);
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (getResourceModules || !module.IsResource())
 				{
 					list.Add(module);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="570" endline="588">
<![CDATA[
 
 		public override Module GetModule(string name)
 		{
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (ModuleBuilder module in modules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				if (module.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
 				{
 					return module;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2359" endline="2368">
<![CDATA[
 
 		internal int[] GetIndexFixup()
 		{
 			int[] array = new int[rowCount];
 			for (int i = 0; i < rowCount; i++)
 			{
 				array[records[i].unsortedIndex] = i;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				array[records[i].unsortedIndex] = i;
 			}
 			return array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="463" endline="472">
<![CDATA[
 
 		public override MethodInfo[] GetAccessors(bool nonPublic)
 		{
 			MethodInfo[] accessors = property.GetAccessors(nonPublic);
 			for (int i = 0; i < accessors.Length; i++)
 			{
 				accessors[i] = Wrap(accessors[i]);
 			}
 			for (int i = 0; i < accessors.Length; i++)
 			{
 				accessors[i] = Wrap(accessors[i]);
 			}
 			return accessors;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="575" endline="584">
<![CDATA[
 
 		public override MethodInfo[] GetOtherMethods(bool nonPublic)
 		{
 			MethodInfo[] others = eventInfo.GetOtherMethods(nonPublic);
 			for (int i = 0; i < others.Length; i++)
 			{
 				others[i] = Wrap(others[i]);
 			}
 			for (int i = 0; i < others.Length; i++)
 			{
 				others[i] = Wrap(others[i]);
 			}
 			return others;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2369" endline="2381">
<![CDATA[
 
 		internal int FindFirstByOwner(int token)
 		{
 			// TODO use binary search (if sorted)
 			for (int i = 0; i < records.Length; i++)
 			{
 				if (records[i].Owner == token)
 				{
 					return i;
 				}
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				if (records[i].Owner == token)
 				{
 					return i;
 				}
 			}
 			return -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="39" endline="49">
<![CDATA[
 
 		protected override TypeExpr DoResolveAsTypeStep (IMemberContext ec)
 		{
 			var type = ec.Module.PredefinedTypes.Nullable.Resolve (loc);
 			if (type == null)
 				return null;
 
 			TypeArguments args = new TypeArguments (underlying);
 			GenericTypeExpr ctype = new GenericTypeExpr (type, args, loc);
 			return ctype.ResolveAsTypeTerminal (ec, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\MetadataRW.cs" startline="87" endline="99">
<![CDATA[
 
 		private static bool IsBig(int bitsUsed, params Table[] tables)
 		{
 			int limit = 1 << (16 - bitsUsed);
 			foreach (Table table in tables)
 			{
 				if (table.RowCount >= limit)
 				{
 					return true;
 				}
 			}
 			foreach (Table table in tables)
 			{
 				if (table.RowCount >= limit)
 				{
 					return true;
 				}
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="639" endline="651">
<![CDATA[
 
 		public MethodEntry[] Methods {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				lock (this) {
 					read_methods ();
 					MethodEntry[] retval = new MethodEntry [MethodCount];
 					method_list.CopyTo (retval, 0);
 					return retval;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6862" endline="6878">
<![CDATA[
 
 		public override HoistedVariable GetHoistedVariable (AnonymousExpression ae)
 		{
 			if (ae == null)
 				return null;
 
 			AnonymousMethodStorey storey = ae.Storey;
 			while (storey != null) {
 				AnonymousMethodStorey temp = storey.Parent as AnonymousMethodStorey;
 				if (temp == null)
 					return storey.HoistedThis;
 
 				storey = temp;
 			}
 			while (storey != null) {
 				AnonymousMethodStorey temp = storey.Parent as AnonymousMethodStorey;
 				if (temp == null)
 					return storey.HoistedThis;
 
 				storey = temp;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2127" endline="2154">
<![CDATA[
 
 		TypeSpec LookupNestedTypeInHierarchy (string name, int arity)
 		{
 			// TODO
 			if (PartialContainer == null)
 				return null;
 
 			// Has any nested type
 			// Does not work, because base type can have
 			//if (PartialContainer.Types == null)
 			//	return null;
 
 			var container = PartialContainer.CurrentType;
 
 			// Is not Root container
 			if (container == null)
 				return null;
 
 			var t = MemberCache.FindNestedType (container, name, arity);
 			if (t == null)
 				return null;
 
 			// FIXME
 			if (!t.IsAccessible (CurrentType))
 				return null;
 
 			return t;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2959" endline="2975">
<![CDATA[
 
 		int IsUnfixed (TypeSpec type)
 		{
 			if (!type.IsGenericParameter)
 				return -1;
 
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (tp_args[i] == type) {
 					if (fixed_types[i] != null)
 						break;
 
 					return i;
 				}
 			}
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (tp_args[i] == type) {
 					if (fixed_types[i] != null)
 						break;
 
 					return i;
 				}
 			}
 
 			return -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="713" endline="724">
<![CDATA[
 
 		static public string ToHex (byte[] input) 
 		{
 			if (input == null)
 				return null;
 
 			StringBuilder sb = new StringBuilder (input.Length * 2);
 			foreach (byte b in input) {
 				sb.Append (b.ToString ("X2", CultureInfo.InvariantCulture));
 			}
 			foreach (byte b in input) {
 				sb.Append (b.ToString ("X2", CultureInfo.InvariantCulture));
 			}
 			return sb.ToString ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2623" endline="2638">
<![CDATA[
 		
 		bool AllTypesAreFixed (TypeSpec[] types)
 		{
 			foreach (TypeSpec t in types) {
 				if (t.IsGenericParameter) {
 					if (!IsFixed (t))
 						return false;
 					continue;
 				}
 
 				if (TypeManager.IsGenericType (t))
 					return AllTypesAreFixed (TypeManager.GetTypeArguments (t));
 			}
 			foreach (TypeSpec t in types) {
 				if (t.IsGenericParameter) {
 					if (!IsFixed (t))
 						return false;
 					continue;
 				}
 
 				if (TypeManager.IsGenericType (t))
 					return AllTypesAreFixed (TypeManager.GetTypeArguments (t));
 			}
 			
 			return true;
 		}		
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7161" endline="7178">
<![CDATA[
 
 		static bool ContainsDynamicType (TypeSpec type)
 		{
 			if (type == InternalType.Dynamic)
 				return true;
 
 			var element_container = type as ElementTypeSpec;
 			if (element_container != null)
 				return ContainsDynamicType (element_container.Element);
 
 			foreach (var t in type.TypeArguments) {
 				if (ContainsDynamicType (t)) {
 					return true;
 				}
 			}
 			foreach (var t in type.TypeArguments) {
 				if (ContainsDynamicType (t)) {
 					return true;
 				}
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1089" endline="1111">
<![CDATA[
 
 		public bool Resolve (IMemberContext ec)
 		{
 			if (types != null)
 				return true;
 			
 			types = new TypeSpec [Count];
 			
 			bool ok = true;
 			Parameter p;
 			for (int i = 0; i < FixedParameters.Length; ++i) {
 				p = this [i];
 				TypeSpec t = p.Resolve (ec, i);
 				if (t == null) {
 					ok = false;
 					continue;
 				}
 
 				types [i] = t;
 			}
 			for (int i = 0; i < FixedParameters.Length; ++i) {
 				p = this [i];
 				TypeSpec t = p.Resolve (ec, i);
 				if (t == null) {
 					ok = false;
 					continue;
 				}
 
 				types [i] = t;
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="461" endline="481">
<![CDATA[
 
 		private static Type[] NormalizeAndCopy(Type[] array)
 		{
 			if (array == null || array.Length == 0)
 			{
 				return null;
 			}
 			Type[] copy = null;
 			for (int i = 0; i < array.Length; i++)
 			{
 				if (array[i] != null)
 				{
 					if (copy == null)
 					{
 						copy = new Type[array.Length];
 					}
 					copy[i] = array[i];
 				}
 			}
 			for (int i = 0; i < array.Length; i++)
 			{
 				if (array[i] != null)
 				{
 					if (copy == null)
 					{
 						copy = new Type[array.Length];
 					}
 					copy[i] = array[i];
 				}
 			}
 			return copy;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="323" endline="352">
<![CDATA[
 
 		private static IList<CustomAttributeNamedArgument> ReadNamedArguments(Assembly asm, ByteReader br, int named, Type type)
 		{
 			List<CustomAttributeNamedArgument> list = new List<CustomAttributeNamedArgument>(named);
 			for (int i = 0; i < named; i++)
 			{
 				byte fieldOrProperty = br.ReadByte();
 				Type fieldOrPropertyType = ReadFieldOrPropType(asm, br);
 				string name = br.ReadString();
 				CustomAttributeTypedArgument value = ReadFixedArg(asm, br, fieldOrPropertyType);
 				MemberInfo member;
 				switch (fieldOrProperty)
 				{
 					case 0x53
 						member = GetField(type, name);
 						break;
 					case 0x54
 						member = GetProperty(type, name);
 						break;
 					default
 						throw new BadImageFormatException();
 				}
 				if (member == null)
 				{
 					throw new BadImageFormatException();
 				}
 				list.Add(new CustomAttributeNamedArgument(member, value));
 			}
 			for (int i = 0; i < named; i++)
 			{
 				byte fieldOrProperty = br.ReadByte();
 				Type fieldOrPropertyType = ReadFieldOrPropType(asm, br);
 				string name = br.ReadString();
 				CustomAttributeTypedArgument value = ReadFixedArg(asm, br, fieldOrPropertyType);
 				MemberInfo member;
 				switch (fieldOrProperty)
 				{
 					case 0x53
 						member = GetField(type, name);
 						break;
 					case 0x54
 						member = GetProperty(type, name);
 						break;
 					default
 						throw new BadImageFormatException();
 				}
 				if (member == null)
 				{
 					throw new BadImageFormatException();
 				}
 				list.Add(new CustomAttributeNamedArgument(member, value));
 			}
 			return list.AsReadOnly();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="682" endline="708">
<![CDATA[
 
 		//
 		// Returns members of @iface only, base members are ignored
 		//
 		public static IList<MethodSpec> GetInterfaceMethods (TypeSpec iface)
 		{
 			//
 			// MemberCache flatten interfaces, therefore in cases like this one
 			// 
 			// interface IA 
 			// interface IB { void Foo () }
 			//
 			// we would return Foo inside IA which is not expected in this case
 			//
 			var methods = new List<MethodSpec> ();
 			foreach (var entry in iface.MemberCache.member_hash.Values) {
 				foreach (var name_entry in entry) {
 					if (iface == name_entry.DeclaringType) {
 						if (name_entry.Kind == MemberKind.Method) {
 							methods.Add ((MethodSpec) name_entry);
 						}
 					}
 				}
 				foreach (var name_entry in entry) {
 					if (iface == name_entry.DeclaringType) {
 						if (name_entry.Kind == MemberKind.Method) {
 							methods.Add ((MethodSpec) name_entry);
 						}
 					}
 				}
 			}
 			foreach (var entry in iface.MemberCache.member_hash.Values) {
 				foreach (var name_entry in entry) {
 					if (iface == name_entry.DeclaringType) {
 						if (name_entry.Kind == MemberKind.Method) {
 							methods.Add ((MethodSpec) name_entry);
 						}
 					}
 				}
 			}
 
 			return methods;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="844" endline="858">
<![CDATA[
 
 		static public string GetUsing ()
 		{
 			lock (evaluator_lock){
 				StringBuilder sb = new StringBuilder ();
 				
 				foreach (object x in using_alias_list)
 					sb.Append (String.Format ("using {0};\n", x));
 				foreach (object x in using_alias_list)
 					sb.Append (String.Format ("using {0};\n", x));
 				
 				foreach (object x in using_list)
 					sb.Append (String.Format ("using {0};\n", x));
 				foreach (object x in using_list)
 					sb.Append (String.Format ("using {0};\n", x));
 				
 				return sb.ToString ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1240" endline="1263">
<![CDATA[
 
 		public override AssemblyName[] __GetReferencedAssemblies()
 		{
 			List<AssemblyName> list = new List<AssemblyName>();
 			if (referencedAssemblyNames != null)
 			{
 				foreach (AssemblyName name in referencedAssemblyNames)
 				{
 					if (!list.Contains(name))
 					{
 						list.Add(name);
 					}
 				}
 				foreach (AssemblyName name in referencedAssemblyNames)
 				{
 					if (!list.Contains(name))
 					{
 						list.Add(name);
 					}
 				}
 			}
 			foreach (Assembly asm in referencedAssemblies.Keys)
 			{
 				AssemblyName name = asm.GetName();
 				if (!list.Contains(name))
 				{
 					list.Add(name);
 				}
 			}
 			foreach (Assembly asm in referencedAssemblies.Keys)
 			{
 				AssemblyName name = asm.GetName();
 				if (!list.Contains(name))
 				{
 					list.Add(name);
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1367" endline="1374">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1759" endline="1766">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteStringIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1799" endline="1806">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteBlobIndex(records[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="3399" endline="3412">
<![CDATA[
 
 		//
 		// Consumes the saved xml comment lines (if any)
 		// as for current target member or type.
 		//
 		public string consume_doc_comment ()
 		{
 			if (xml_comment_buffer.Length > 0) {
 				string ret = xml_comment_buffer.ToString ();
 				reset_doc_comment ();
 				return ret;
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="806" endline="818">
<![CDATA[
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			Attribute a = null;
 			if (OptAttributes != null) {
 				a = OptAttributes.Search (pa);
 			}
 
 			if (a == null)
 				return null;
 
 			return a.GetAttributeUsageAttribute ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="636" endline="646">
<![CDATA[
 
 		internal void WriteParamRecords(MetadataWriter mw)
 		{
 			if (parameters != null)
 			{
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.WriteParamRecord(mw);
 				}
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.WriteParamRecord(mw);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="712" endline="721">
<![CDATA[
 
 		public void ResolveFieldInitializers (BlockContext ec)
 		{
 			if (partial_parts != null) {
 				foreach (TypeContainer part in partial_parts) {
 					part.DoResolveFieldInitializers (ec);
 				}
 				foreach (TypeContainer part in partial_parts) {
 					part.DoResolveFieldInitializers (ec);
 				}
 			}
 			DoResolveFieldInitializers (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="441" endline="451">
<![CDATA[
 
 		internal override void GetTypesImpl(List<Type> list)
 		{
 			foreach (Type type in types)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 			foreach (Type type in types)
 			{
 				if (type != moduleType)
 				{
 					list.Add(type);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="647" endline="658">
<![CDATA[
 
 		internal void FixupToken(int token, ref int parameterToken)
 		{
 			typeBuilder.ModuleBuilder.RegisterTokenFixup(this.pseudoToken, token);
 			if (parameters != null)
 			{
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.FixupToken(parameterToken++);
 				}
 				foreach (ParameterBuilder pb in parameters)
 				{
 					pb.FixupToken(parameterToken++);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="700" endline="718">
<![CDATA[
 
 		static Expression GetOperatorTrueOrFalse (ResolveContext ec, Expression e, bool is_true, Location loc)
 		{
 			var op = is_true ? Operator.OpType.True 
 			var methods = MemberCache.GetUserOperator (e.type, op, false);
 			if (methods == null)
 				return null;
 
 			Arguments arguments = new Arguments (1);
 			arguments.Add (new Argument (e));
 
 			var res = new OverloadResolver (methods, OverloadResolver.Restrictions.BaseMembersIncluded | OverloadResolver.Restrictions.NoBaseMembers, loc);
 			var oper = res.ResolveOperator (ec, ref arguments);
 
 			if (oper == null)
 				return null;
 
 			return new UserOperatorCall (oper, arguments, null, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="207" endline="222">
<![CDATA[
 
 		private byte[] ReadHeap(Stream stream, StreamHeader sh)
 		{
 			byte[] buf = new byte[sh.Size];
 			stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaDataRVA + sh.Offset), SeekOrigin.Begin);
 			for (int pos = 0; pos < buf.Length; )
 			{
 				int read = stream.Read(buf, pos, buf.Length - pos);
 				if (read == 0)
 				{
 					throw new BadImageFormatException();
 				}
 				pos += read;
 			}
 			for (int pos = 0; pos < buf.Length; )
 			{
 				int read = stream.Read(buf, pos, buf.Length - pos);
 				if (read == 0)
 				{
 					throw new BadImageFormatException();
 				}
 				pos += read;
 			}
 			return buf;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="993" endline="1015">
<![CDATA[
 
 		public TypeSpec InferReturnType (ResolveContext ec, TypeInferenceContext tic, TypeSpec delegate_type)
 		{
 			Expression expr;
 			AnonymousExpression am;
 
 			if (compatibles.TryGetValue (delegate_type, out expr)) {
 				am = expr as AnonymousExpression;
 				return am == null ? null 
 			}
 
 			using (ec.Set (ResolveContext.Options.ProbingMode | ResolveContext.Options.InferReturnType)) {
 				am = CompatibleMethodBody (ec, tic, InternalType.Arglist, delegate_type);
 				if (am != null)
 					am = am.Compatible (ec);
 			}
 
 			if (am == null)
 				return null;
 
 //			compatibles.Add (delegate_type, am);
 			return am.ReturnType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2032" endline="2052">
<![CDATA[
 
 		/// <summary>
 		///   Performs checks for an explicit interface implementation.  First it
 		///   checks whether the `interface_type' is a base inteface implementation.
 		///   Then it checks whether `name' exists in the interface type.
 		/// </summary>
 		public bool VerifyImplements (InterfaceMemberBase mb)
 		{
 			var ifaces = spec.Interfaces;
 			if (ifaces != null) {
 				foreach (TypeSpec t in ifaces){
 					if (t == mb.InterfaceType)
 						return true;
 				}
 				foreach (TypeSpec t in ifaces){
 					if (t == mb.InterfaceType)
 						return true;
 				}
 			}
 			
 			Report.SymbolRelatedToPreviousError (mb.InterfaceType);
 			Report.Error (540, mb.Location, "`{0}'
 				mb.GetSignatureForError (), TypeManager.CSharpName (mb.InterfaceType));
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="151" endline="174">
<![CDATA[
 
 		private static StreamHeader[] ReadStreamHeaders(BinaryReader br, out string Version)
 		{
 			uint Signature = br.ReadUInt32();
 			if (Signature != 0x424A5342)
 			{
 				throw new BadImageFormatException("Invalid metadata signature");
 			}
 			ushort MajorVersion = br.ReadUInt16();
 			ushort MinorVersion = br.ReadUInt16();
 			uint Reserved = br.ReadUInt32();
 			uint Length = br.ReadUInt32();
 			byte[] buf = br.ReadBytes((int)Length);
 			Version = Encoding.UTF8.GetString(buf).TrimEnd('\u0000');
 			ushort Flags = br.ReadUInt16();
 			ushort Streams = br.ReadUInt16();
 			StreamHeader[] streamHeaders = new StreamHeader[Streams];
 			for (int i = 0; i < streamHeaders.Length; i++)
 			{
 				streamHeaders[i] = new StreamHeader();
 				streamHeaders[i].Read(br);
 			}
 			for (int i = 0; i < streamHeaders.Length; i++)
 			{
 				streamHeaders[i] = new StreamHeader();
 				streamHeaders[i].Read(br);
 			}
 			return streamHeaders;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="230" endline="250">
<![CDATA[
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if ((getter != null && getter.IsPublic) || (setter != null && setter.IsPublic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="251" endline="272">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if ((getter != null && getter.IsStatic) || (setter != null && setter.IsStatic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1125" endline="1150">
<![CDATA[
 		
 		void CheckLineNumberTable (LineNumberEntry[] line_numbers)
 		{
 			int last_offset = -1;
 			int last_row = -1;
 
 			if (line_numbers == null)
 				return;
 			
 			for (int i = 0; i < line_numbers.Length; i++) {
 				LineNumberEntry line = line_numbers [i];
 
 				if (line.Equals (LineNumberEntry.Null))
 					throw new MonoSymbolFileException ();
 
 				if (line.Offset < last_offset)
 					throw new MonoSymbolFileException ();
 
 				if (line.Offset > last_offset) {
 					last_row = line.Row;
 					last_offset = line.Offset;
 				} else if (line.Row > last_row) {
 					last_row = line.Row;
 				}
 			}
 			for (int i = 0; i < line_numbers.Length; i++) {
 				LineNumberEntry line = line_numbers [i];
 
 				if (line.Equals (LineNumberEntry.Null))
 					throw new MonoSymbolFileException ();
 
 				if (line.Offset < last_offset)
 					throw new MonoSymbolFileException ();
 
 				if (line.Offset > last_offset) {
 					last_row = line.Row;
 					last_offset = line.Offset;
 				} else if (line.Row > last_row) {
 					last_row = line.Row;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1365" endline="1384">
<![CDATA[
 
 		public bool ResolveTypeParameters ()
 		{
 			if (!DoResolveTypeParameters ())
 				return false;
 
 			if (types != null) {
 				foreach (var type in types)
 					if (!type.ResolveTypeParameters ())
 						return false;
 				foreach (var type in types)
 					if (!type.ResolveTypeParameters ())
 						return false;
 			}
 
 			if (compiler_generated != null) {
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					if (!c.ResolveTypeParameters ())
 						return false;
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					if (!c.ResolveTypeParameters ())
 						return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1138" endline="1145">
<![CDATA[
 
 		public bool GetBoolean () 
 		{
 			Expression e = GetValue ();
 			if (e is BoolConstant)
 				return ((BoolConstant)e).Value;
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="267" endline="292">
<![CDATA[
 
 		// <remarks>
 		//   This is used when we encounter a #line preprocessing directive.
 		// </remarks>
 		static public SourceFile LookupFile (CompilationUnit comp_unit, string name)
 		{
 			string path;
 			if (!Path.IsPathRooted (name)) {
 				string root = Path.GetDirectoryName (comp_unit.Path);
 				path = Path.Combine (root, name);
 			} else
 				path = name;
 
 			if (!source_files.ContainsKey (path)) {
 				if (source_count >= (1 << checkpoint_bits))
 					return new SourceFile (name, path, 0, true);
 
 				source_files.Add (path, ++source_count);
 				SourceFile retval = new SourceFile (name, path, source_count, true);
 				source_list.Add (retval);
 				return retval;
 			}
 
 			int index = (int) source_files [path];
 			return (SourceFile) source_list [index - 1];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1891" endline="1914">
<![CDATA[
 
 		static bool HasDynamicArguments (TypeSpec[] args)
 		{
 			for (int i = 0; i < args.Length; ++i) {
 				var item = args[i];
 
 				if (item == InternalType.Dynamic)
 					return true;
 
 				if (TypeManager.IsGenericType (item))
 					return HasDynamicArguments (TypeManager.GetTypeArguments (item));
 
 				if (item.IsArray) {
 					while (item.IsArray) {
 						item = ((ArrayContainer) item).Element;
 					}
 					while (item.IsArray) {
 						item = ((ArrayContainer) item).Element;
 					}
 
 					if (item == InternalType.Dynamic)
 						return true;
 				}
 			}
 			for (int i = 0; i < args.Length; ++i) {
 				var item = args[i];
 
 				if (item == InternalType.Dynamic)
 					return true;
 
 				if (TypeManager.IsGenericType (item))
 					return HasDynamicArguments (TypeManager.GetTypeArguments (item));
 
 				if (item.IsArray) {
 					while (item.IsArray) {
 						item = ((ArrayContainer) item).Element;
 					}
 
 					if (item == InternalType.Dynamic)
 						return true;
 				}
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="148" endline="189">
<![CDATA[
 		
 		//
 		// Factory method
 		// object, otherwise we return null.
 		//
 		// Register method implementations are either abstract methods
 		// flagged as such on the base class or interface methods
 		//
 		static public PendingImplementation GetPendingImplementations (TypeContainer container)
 		{
 			TypeSpec b = container.BaseType;
 
 			var missing_interfaces = GetMissingInterfaces (container);
 
 			//
 			// If we are implementing an abstract class, and we are not
 			// ourselves abstract, and there are abstract methods (C# allows
 			// abstract classes that have no abstract methods), then allocate
 			// one slot.
 			//
 			// We also pre-compute the methods.
 			//
 			bool implementing_abstract = ((b != null) && b.IsAbstract && (container.ModFlags & Modifiers.ABSTRACT) == 0);
 			MethodSpec[] abstract_methods = null;
 
 			if (implementing_abstract){
 				var am = MemberCache.GetNotImplementedAbstractMethods (b);
 
 				if (am == null) {
 					implementing_abstract = false;
 				} else {
 					abstract_methods = new MethodSpec[am.Count];
 					am.CopyTo (abstract_methods, 0);
 				}
 			}
 			
 			int total = missing_interfaces.Length +  (implementing_abstract ? 1 
 			if (total == 0)
 				return null;
 
 			return new PendingImplementation (container, missing_interfaces, abstract_methods, total);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="437" endline="461">
<![CDATA[
 		}
 
 		protected override string[] GetDefaultReferences ()
 		{
 			//
 			// For now the "default config" is harcoded into the compiler
 			// we can move this outside later
 			//
 			var default_references = new List<string> (8);
 
 			default_references.Add ("System");
 			default_references.Add ("System.Xml");
 #if NET_2_1
 			default_references.Add ("System.Net");
 			default_references.Add ("System.Windows");
 			default_references.Add ("System.Windows.Browser");
 #endif
 
 			if (RootContext.Version > LanguageVersion.ISO_2)
 				default_references.Add ("System.Core");
 			if (RootContext.Version > LanguageVersion.V_3)
 				default_references.Add ("Microsoft.CSharp");
 
 			return default_references.ToArray ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="294" endline="312">
<![CDATA[
 
 		protected override string[] GetDefaultReferences ()
 		{
 			//
 			// For now the "default config" is harcoded into the compiler
 			// we can move this outside later
 			//
 			var default_references = new List<string> (4);
 
 			default_references.Add ("System.dll");
 			default_references.Add ("System.Xml.dll");
 
 			if (RootContext.Version > LanguageVersion.ISO_2)
 				default_references.Add ("System.Core.dll");
 			if (RootContext.Version > LanguageVersion.V_3)
 				default_references.Add ("Microsoft.CSharp.dll");
 
 			return default_references.ToArray ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="103" endline="122">
<![CDATA[
 		}
 
 		public bool IsAttribute {
 			get {
 				if (!IsClass)
 					return false;
 
 				var type = this;
 				do {
 					if (type.IsGeneric)
 						return false;
 
 					if (type == TypeManager.attribute_type)
 						return true;
 					
 					type = type.base_type;
 				} while (type != null);
 
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1642" endline="1663">
<![CDATA[
 
 		private static Type[] BindArray(Type[] array, IGenericBinder binder)
 		{
 			if (array ==null || array.Length == 0)
 			{
 				return array;
 			}
 			Type[] result = array;
 			for (int i = 0; i < array.Length; i++)
 			{
 				Type type = array[i].BindTypeParameters(binder);
 				if (!ReferenceEquals(type, array[i]))
 				{
 					if (result == array)
 					{
 						result = (Type[])array.Clone();
 					}
 					result[i] = type;
 				}
 			}
 			for (int i = 0; i < array.Length; i++)
 			{
 				Type type = array[i].BindTypeParameters(binder);
 				if (!ReferenceEquals(type, array[i]))
 				{
 					if (result == array)
 					{
 						result = (Type[])array.Clone();
 					}
 					result[i] = type;
 				}
 			}
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="909" endline="920">
<![CDATA[
 
 		internal void ResolveMethodAndFieldTokens(ref int methodToken, ref int fieldToken, ref int parameterToken)
 		{
 			foreach (MethodBuilder method in methods)
 			{
 				method.FixupToken(methodToken++, ref parameterToken);
 			}
 			foreach (MethodBuilder method in methods)
 			{
 				method.FixupToken(methodToken++, ref parameterToken);
 			}
 			foreach (FieldBuilder field in fields)
 			{
 				field.FixupToken(fieldToken++);
 			}
 			foreach (FieldBuilder field in fields)
 			{
 				field.FixupToken(fieldToken++);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="119" endline="126">
<![CDATA[
 
 		public static void CloseScope (ILGenerator ig)
 		{
 			if (symwriter != null) {
 				int offset = GetILOffset (ig);
 				symwriter.CloseScope (offset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="432" endline="445">
<![CDATA[
 
 		private int ReadToken(int table, bool big)
 		{
 			int rid;
 			if (big)
 			{
 				rid = br.ReadInt32();
 			}
 			else
 			{
 				rid = br.ReadUInt16();
 			}
 			return rid | (table << 24);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="1109" endline="1118">
<![CDATA[
 
 		private void WriteCode(ByteBuffer bb)
 		{
 			int codeOffset = bb.Position;
 			foreach (int fixup in this.tokenFixups)
 			{
 				moduleBuilder.tokenFixupOffsets.Add(fixup + codeOffset);
 			}
 			foreach (int fixup in this.tokenFixups)
 			{
 				moduleBuilder.tokenFixupOffsets.Add(fixup + codeOffset);
 			}
 			bb.Write(code);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6724" endline="6735">
<![CDATA[
 
 		//
 		// Converts static initializer only
 		//
 		void UnifyInitializerElement (ResolveContext ec)
 		{
 			for (int i = 0; i < array_data.Count; ++i) {
 				Expression e = array_data[i];
 				if (e != null)
 					array_data [i] = Convert.ImplicitConversion (ec, e, array_element_type, Location.Null);
 			}
 			for (int i = 0; i < array_data.Count; ++i) {
 				Expression e = array_data[i];
 				if (e != null)
 					array_data [i] = Convert.ImplicitConversion (ec, e, array_element_type, Location.Null);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="875" endline="895">
<![CDATA[
 
 		public override TypeSpec AddDelegate (Delegate d)
 		{
 			TypeSpec inflated;
 
 			base.AddDelegate (d);
 
 			// Inflated type instance has to be updated manually
 			if (instance_type is InflatedTypeSpec) {
 				var inflator = new TypeParameterInflator (instance_type, TypeParameterSpec.EmptyTypes, TypeSpec.EmptyTypes);
 				inflated = (TypeSpec) d.CurrentType.InflateMember (inflator);
 				instance_type.MemberCache.AddMember (inflated);
 
 				//inflator = new TypeParameterInflator (d.Parent.CurrentType, TypeParameterSpec.EmptyTypes, TypeSpec.EmptyTypes);
 				//d.Parent.CurrentType.MemberCache.AddMember (d.CurrentType.InflateMember (inflator));
 			} else {
 				inflated = d.CurrentType;
 			}
 
 			return inflated;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="929" endline="941">
<![CDATA[
 
 		public bool HasField (string fieldName)
 		{
 			if (named_values == null)
 				return false;
 
 			foreach (var na in named_values) {
 				if (na.Value.Name == fieldName)
 					return true;
 			}
 			foreach (var na in named_values) {
 				if (na.Value.Name == fieldName)
 					return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="560" endline="574">
<![CDATA[
 
 		public void LoadModules (AssemblyDefinitionDynamic assembly, RootNamespace targetNamespace)
 		{
 			if (RootContext.Modules.Count == 0)
 				return;
 
 			foreach (var moduleName in RootContext.Modules) {
 				var m = LoadModuleFile (assembly, moduleName);
 				if (m == null)
 					continue;
 
 				var md = importer.ImportModule (m, targetNamespace);
 				assembly.AddModule (md);
 			}
 			foreach (var moduleName in RootContext.Modules) {
 				var m = LoadModuleFile (assembly, moduleName);
 				if (m == null)
 					continue;
 
 				var md = importer.ImportModule (m, targetNamespace);
 				assembly.AddModule (md);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1450" endline="1468">
<![CDATA[
 
 		/// <summary>
 		///   Populates our TypeBuilder with fields and methods
 		/// </summary>
 		public sealed override bool Define ()
 		{
 			if (members_defined)
 				return members_defined_ok;
 
 			members_defined_ok = DoDefineMembers ();
 			members_defined = true;
 
 			if (types != null) {
 				foreach (var nested in types)
 					nested.Define ();
 				foreach (var nested in types)
 					nested.Define ();
 			}
 
 			return members_defined_ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="594" endline="610">
<![CDATA[
 
 		private static bool IsInheritableAttribute(Type attribute)
 		{
 			Type attributeUsageAttribute = attribute.Module.universe.System_AttributeUsageAttribute;
 			IList<CustomAttributeData> attr = attribute.GetCustomAttributesData(attributeUsageAttribute);
 			if (attr.Count != 0)
 			{
 				foreach (CustomAttributeNamedArgument named in attr[0].NamedArguments)
 				{
 					if (named.MemberInfo.Name == "Inherited")
 					{
 						return (bool)named.TypedValue.Value;
 					}
 				}
 				foreach (CustomAttributeNamedArgument named in attr[0].NamedArguments)
 				{
 					if (named.MemberInfo.Name == "Inherited")
 					{
 						return (bool)named.TypedValue.Value;
 					}
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="710" endline="730">
<![CDATA[
 
 		//
 		// Populates the Namespace with some using declarations, used by the
 		// eval mode. 
 		//
 		public void Populate (List<UsingAliasEntry> source_using_aliases, List<UsingEntry> source_using_clauses)
 		{
 			foreach (UsingAliasEntry uae in source_using_aliases){
 				if (using_aliases == null)
 					using_aliases = new List<UsingAliasEntry> ();
 				
 				using_aliases.Add (uae);
 			}
 			foreach (UsingAliasEntry uae in source_using_aliases){
 				if (using_aliases == null)
 					using_aliases = new List<UsingAliasEntry> ();
 				
 				using_aliases.Add (uae);
 			}
 
 			foreach (UsingEntry ue in source_using_clauses){
 				if (using_clauses == null)
 					using_clauses = new List<UsingEntry> ();
 				
 				using_clauses.Add (ue);
 			}
 			foreach (UsingEntry ue in source_using_clauses){
 				if (using_clauses == null)
 					using_clauses = new List<UsingEntry> ();
 				
 				using_clauses.Add (ue);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4063" endline="4092">
<![CDATA[
 		
 		void Append (ResolveContext rc, Expression operand)
 		{
 			//
 			// Constant folding
 			//
 			StringConstant sc = operand as StringConstant;
 			if (sc != null) {
 				if (arguments.Count != 0) {
 					Argument last_argument = arguments [arguments.Count - 1];
 					StringConstant last_expr_constant = last_argument.Expr as StringConstant;
 					if (last_expr_constant != null) {
 						last_argument.Expr = new StringConstant (
 							last_expr_constant.Value + sc.Value, sc.Location).Resolve (rc);
 						return;
 					}
 				}
 			} else {
 				//
 				// Multiple (3+) concatenation are resolved as multiple StringConcat instances
 				//
 				StringConcat concat_oper = operand as StringConcat;
 				if (concat_oper != null) {
 					arguments.AddRange (concat_oper.arguments);
 					return;
 				}
 			}
 
 			arguments.Add (new Argument (operand));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="956" endline="969">
<![CDATA[
 		}
 
 		// helper for ModuleBuilder.ResolveMethod()
 		internal MethodBase LookupMethod(int token)
 		{
 			foreach (MethodBuilder method in methods)
 			{
 				if (method.MetadataToken == token)
 				{
 					return method;
 				}
 			}
 			foreach (MethodBuilder method in methods)
 			{
 				if (method.MetadataToken == token)
 				{
 					return method;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="500" endline="512">
<![CDATA[
 
 		//
 		// Returns dynamic when at least one argument is of dynamic type
 		//
 		public void Resolve (ResolveContext ec, out bool dynamic)
 		{
 			dynamic = false;
 			foreach (Argument a in args) {
 				a.Resolve (ec);
 				if (a.Type == InternalType.Dynamic && !a.IsByRef)
 					dynamic = true;
 			}
 			foreach (Argument a in args) {
 				a.Resolve (ec);
 				if (a.Type == InternalType.Dynamic && !a.IsByRef)
 					dynamic = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="749" endline="765">
<![CDATA[
 
 		internal void FixupMethodBodyTokens()
 		{
 			int methodToken = 0x06000001;
 			int fieldToken = 0x04000001;
 			int parameterToken = 0x08000001;
 			foreach (TypeBuilder type in types)
 			{
 				type.ResolveMethodAndFieldTokens(ref methodToken, ref fieldToken, ref parameterToken);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.ResolveMethodAndFieldTokens(ref methodToken, ref fieldToken, ref parameterToken);
 			}
 			foreach (int offset in tokenFixupOffsets)
 			{
 				methodBodies.Position = offset;
 				int pseudoToken = methodBodies.GetInt32AtCurrentPosition();
 				methodBodies.Write(ResolvePseudoToken(pseudoToken));
 			}
 			foreach (int offset in tokenFixupOffsets)
 			{
 				methodBodies.Position = offset;
 				int pseudoToken = methodBodies.GetInt32AtCurrentPosition();
 				methodBodies.Write(ResolvePseudoToken(pseudoToken));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="459" endline="478">
<![CDATA[
 
 		public void LoadModules (AssemblyDefinitionStatic assembly, RootNamespace targetNamespace)
 		{
 			if (RootContext.Modules.Count == 0)
 				return;
 
 			foreach (var moduleName in RootContext.Modules) {
 				var m = LoadModuleFile (moduleName);
 				if (m == null)
 					continue;
 
 				if (m.IsManifestModule) {
 					Error_FileCorrupted (moduleName);
 					continue;
 				}
 
 				var md = importer.ImportModule (assembly.IncludeModule (m), targetNamespace);
 				assembly.AddModule (md);
 			}
 			foreach (var moduleName in RootContext.Modules) {
 				var m = LoadModuleFile (moduleName);
 				if (m == null)
 					continue;
 
 				if (m.IsManifestModule) {
 					Error_FileCorrupted (moduleName);
 					continue;
 				}
 
 				var md = importer.ImportModule (assembly.IncludeModule (m), targetNamespace);
 				assembly.AddModule (md);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="329" endline="358">
<![CDATA[
 
 		public virtual string FullName
 		{
 			get
 			{
 				Type decl = this.DeclaringType;
 				string ns = this.Namespace;
 				if (ns == null)
 				{
 					if (decl == null)
 					{
 						return this.Name;
 					}
 					else
 					{
 						return decl.FullName + "+" + this.Name;
 					}
 				}
 				else
 				{
 					if (decl == null)
 					{
 						return ns + "." + this.Name;
 					}
 					else
 					{
 						return decl.FullName + "+" + ns + "." + this.Name;
 					}
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="1169" endline="1179">
<![CDATA[
 
 		public bool CheckExistingMembersOverloads (MemberCore member, AParametersCollection parameters)
 		{
 			var name = GetLookupName (member);
 			var imb = member as InterfaceMemberBase;
 			if (imb != null && imb.IsExplicitImpl) {
 				name = imb.GetFullName (name);
 			}
 
 			return CheckExistingMembersOverloads (member, name, parameters);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2494" endline="2503">
<![CDATA[
 
 		public ParameterInfo GetParameterInfo (Parameter p)
 		{
 			for (int i = 0; i < parameters.Count; ++i) {
 				if (parameters[i] == p)
 					return parameter_info[i];
 			}
 			for (int i = 0; i < parameters.Count; ++i) {
 				if (parameters[i] == p)
 					return parameter_info[i];
 			}
 
 			throw new ArgumentException ("Invalid parameter");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="613" endline="625">
<![CDATA[
 
 		public MethodEntry GetMethodByToken (int token)
 		{
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				read_methods ();
 				MethodEntry me;
 				method_token_hash.TryGetValue (token, out me);
 				return me;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="274" endline="291">
<![CDATA[
 
 		public WarningRegions RegisterWarningRegion (Location location)
 		{
 			WarningRegions regions;
 			if (warning_regions_table == null) {
 				regions = null;
 				warning_regions_table = new Dictionary<int, WarningRegions> ();
 			} else {
 				warning_regions_table.TryGetValue (location.File, out regions);
 			}
 
 			if (regions == null) {
 				regions = new WarningRegions ();
 				warning_regions_table.Add (location.File, regions);
 			}
 
 			return regions;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="186" endline="208">
<![CDATA[
 		}
 
 		internal void Write(ByteBuffer bb, List<int> linkOffsets)
 		{
 			if (entries.Count != 0)
 			{
 				int stringTableOffset = this.DirectoryLength;
 				Dictionary<string, int> strings = new Dictionary<string, int>();
 				ByteBuffer stringTable = new ByteBuffer(16);
 				int offset = 16 + entries.Count * 8;
 				for (int pass = 0; pass < 3; pass++)
 				{
 					Write(bb, pass, 0, ref offset, strings, ref stringTableOffset, stringTable);
 				}
 				for (int pass = 0; pass < 3; pass++)
 				{
 					Write(bb, pass, 0, ref offset, strings, ref stringTableOffset, stringTable);
 				}
 				// the pecoff spec says that the string table is between the directory entries and the data entries,
 				// but the windows linker puts them after the data entries, so we do too.
 				stringTable.Align(4);
 				offset += stringTable.Length;
 				WriteResourceDataEntries(bb, linkOffsets, ref offset);
 				bb.Write(stringTable);
 				WriteData(bb);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1910" endline="1934">
<![CDATA[
 
 		public PropertySpec GetProperty (string name, TypeSpec memberType, Location loc)
 		{
 			PropertySpec spec;
 
 			if (properties != null) {
 				spec = properties.Find (l => l.Name == name);
 			} else {
 				spec = null;
 			}
 
 			if (spec == null) {
 				spec = TypeManager.GetPredefinedProperty (type, name, loc, memberType);
 
 				if (spec != null) {
 					if (properties == null) {
 						properties = new List<PropertySpec> ();
 					}
 
 					properties.Add (spec);
 				}
 			}
 
 			return spec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="140" endline="160">
<![CDATA[
 
 		public override Module[] GetModules(bool getResourceModules)
 		{
 			if (externalModules.Length == 0)
 			{
 				return new Module[] { manifestModule };
 			}
 			else
 			{
 				List<Module> list = new List<Module>();
 				list.Add(manifestModule);
 				for (int i = 0; i < manifestModule.File.records.Length; i++)
 				{
 					if (getResourceModules || (manifestModule.File.records[i].Flags & ContainsNoMetaData) == 0)
 					{
 						list.Add(GetModule(i));
 					}
 				}
 				for (int i = 0; i < manifestModule.File.records.Length; i++)
 				{
 					if (getResourceModules || (manifestModule.File.records[i].Flags & ContainsNoMetaData) == 0)
 					{
 						list.Add(GetModule(i));
 					}
 				}
 				return list.ToArray();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertyInfo.cs" startline="33" endline="116">
<![CDATA[
 		}
 
 		public abstract PropertyAttributes Attributes { get; }
 		public abstract bool CanRead { get; }
 		public abstract bool CanWrite { get; }
 		public abstract MethodInfo GetGetMethod(bool nonPublic);
 		public abstract MethodInfo GetSetMethod(bool nonPublic);
 		public abstract MethodInfo[] GetAccessors(bool nonPublic);
 		public abstract object GetRawConstantValue();
 		internal abstract bool IsPublic { get; }
 		internal abstract bool IsStatic { get; }
 		internal abstract PropertySignature PropertySignature { get; }
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly PropertyInfo property;
 			private readonly int parameter;
 
 			internal ParameterInfoImpl(PropertyInfo property, int parameter)
 			{
 				this.property = property;
 				this.parameter = parameter;
 			}
 
 			public override string Name
 			{
 				get { return null; }
 			}
 
 			public override Type ParameterType
 			{
 				get { return property.PropertySignature.GetParameter(parameter); }
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get { return ParameterAttributes.None; }
 			}
 
 			public override int Position
 			{
 				get { return parameter; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return property.PropertySignature.GetOptionalCustomModifiers(parameter);
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return property.PropertySignature.GetRequiredCustomModifiers(parameter);
 			}
 
 			public override MemberInfo Member
 			{
 				get { return property; }
 			}
 
 			public override int MetadataToken
 			{
 				get { return 0x08000000; }
 			}
 
 			internal override Module Module
 			{
 				get { return property.Module; }
 			}
 		}
 
 		public ParameterInfo[] GetIndexParameters()
 		{
 			ParameterInfo[] parameters = new ParameterInfo[this.PropertySignature.ParameterCount];
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoImpl(this, i);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="44" endline="1638">
<![CDATA[
 
 		private Driver (CompilerContext ctx)
 		{
 			this.ctx = ctx;
 		}
 
 		public static Driver Create (string[] args, bool require_files, Func<string [], int, int> unknown_option_parser, ReportPrinter printer)
 		{
 			Driver d = new Driver (new CompilerContext (new Report (printer)));
 
 			if (!d.ParseArguments (args, require_files, unknown_option_parser))
 				return null;
 
 			return d;
 		}
 
 		Report Report {
 			get { return ctx.Report; }
 		}
 
 		void ShowTime (string msg)
 		{
 			if (!timestamps)
 				return;
 
 			stopwatch.Stop ();
 
 			Console.WriteLine ("{0,5}ms {1}", stopwatch.ElapsedMilliseconds, msg);
 
 			stopwatch = Stopwatch.StartNew ();
 		}
 
 		void ShowTotalTime (string msg)
 		{
 			if (!timestamps)
 				return;
 
 			DateTime now = DateTime.Now;
 			TimeSpan span = now - first_time;
 
 			Console.WriteLine (
 				"[{0
 				(int) span.TotalSeconds, span.Milliseconds, msg);
 		}	       
 	       
 		void tokenize_file (CompilationUnit file, CompilerContext ctx)
 		{
 			Stream input;
 
 			try {
 				input = File.OpenRead (file.Name);
 			} catch {
 				Report.Error (2001, "Source file `" + file.Name + "' could not be found");
 				return;
 			}
 
 			using (input){
 				SeekableStreamReader reader = new SeekableStreamReader (input, RootContext.Encoding);
 				Tokenizer lexer = new Tokenizer (reader, file, ctx);
 				int token, tokens = 0, errors = 0;
 
 				while ((token = lexer.token ()) != Token.EOF){
 					tokens++;
 					if (token == Token.ERROR)
 						errors++;
 				}
 				Console.WriteLine ("Tokenized
 			}
 			
 			return;
 		}
 
 		void Parse (CompilationUnit file, ModuleContainer module)
 		{
 			Stream input;
 
 			try {
 				input = File.OpenRead (file.Name);
 			} catch {
 				Report.Error (2001, "Source file `{0}' could not be found", file.Name);
 				return;
 			}
 
 			// Check 'MZ' header
 			if (input.ReadByte () == 77 && input.ReadByte () == 90) {
 				Report.Error (2015, "Source file `{0}' is a binary file and not a text file", file.Name);
 				input.Close ();
 				return;
 			}
 
 			input.Position = 0;
 			SeekableStreamReader reader = new SeekableStreamReader (input, RootContext.Encoding);
 
 			Parse (reader, file, module);
 			reader.Dispose ();
 			input.Close ();
 		}	
 		
 		void Parse (SeekableStreamReader reader, CompilationUnit file, ModuleContainer module)
 		{
 			CSharpParser parser = new CSharpParser (reader, file, module);
 			parser.parse ();
 		}
 
 		static void OtherFlags ()
 		{
 			Console.WriteLine (
 				"Other flags in the compiler\n" +
 				"   --fatal[=COUNT]    Makes errors after COUNT fatal\n" +
 				"   --lint             Enhanced warnings\n" +
 				"   --parse            Only parses the source file\n" +
 				"   --runtime
 				"   --stacktrace       Shows stack trace at error location\n" +
 				"   --timestamp        Displays time stamps of various compiler events\n" +
 				"   -v                 Verbose parsing (for debugging the parser)\n" + 
 				"   --mcs-debug X      Sets MCS debugging level to X\n");
 		}
 		
 		static void Usage ()
 		{
 			Console.WriteLine (
 				"Mono C# compiler, Copyright 2001 - 2011 Novell, Inc.\n" +
 				"mcs [options] source-files\n" +
 				"   --about              About the Mono C# compiler\n" +
 				"   -addmodule
 				"   -checked[+|-]        Sets default aritmetic overflow context\n" +
 				"   -clscheck[+|-]       Disables CLS Compliance verifications\n" +
 				"   -codepage
 				"   -define
 				"   -debug[+|-], -g      Generate debugging information\n" + 
 				"   -delaysign[+|-]      Only insert the public key into the assembly (no signing)\n" +
 				"   -doc
 				"   -help                Lists all compiler options (short
 				"   -keycontainer
 				"   -keyfile
 				"   -langversion
 				"   -lib
 				"   -main
 				"   -noconfig            Disables implicitly referenced assemblies\n" +
 				"   -nostdlib[+|-]       Does not reference mscorlib.dll library\n" +
 				"   -nowarn
 				"   -optimize[+|-]       Enables advanced compiler optimizations (short
 				"   -out
 #if !SMCS_SOURCE
 				"   -pkg
 #endif
 				"   -platform
 				"                        ARCH can be one of
 				"   -recurse
 				"   -reference
 				"   -reference
 				"   -sdk
 				"                        VERSION can be one of
 				"   -target
 				"                        KIND can be one of
 				"   -unsafe[+|-]         Allows to compile code which uses unsafe keyword\n" +
 				"   -warnaserror[+|-]    Treats all warnings as errors\n" +
 				"   -warnaserror[+|-]
 				"   -warn
 				"   -helpinternal        Shows internal and advanced compiler options\n" + 
 				"\n" +
 				"Resources
 				"   -linkresource
 				"   -resource
 				"   -win32res
 				"   -win32icon
                                 "   @file                   Read response file for more options\n\n" +
 				"Options can be of the form -option or /option");
 		}
 
 		void TargetUsage ()
 		{
 			Report.Error (2019, "Invalid target type for -target. Valid options are `exe', `winexe', `library' or `module'");
 		}
 		
 		static void About ()
 		{
 			Console.WriteLine (
 				"The Mono C# compiler is Copyright 2001-2011, Novell, Inc.\n\n" +
 				"The compiler source code is released under the terms of the \n"+
 				"MIT X11 or GNU GPL licenses\n\n" +
 
 				"For more information on Mono, visit the project Web site\n" +
 				"   http
 
 				"The compiler was written by Miguel de Icaza, Ravi Pratap, Martin Baulig, Marek Safar, Raja R Harinath, Atushi Enomoto");
 			Environment.Exit (0);
 		}
 
 		public static int Main (string[] args)
 		{
 			Location.InEmacs = Environment.GetEnvironmentVariable ("EMACS") == "t";
 			var crp = new ConsoleReportPrinter ();
 			Driver d = Driver.Create (args, true, null, crp);
 			if (d == null)
 				return 1;
 
 			crp.Fatal = d.fatal_errors;
 
 			if (d.Compile () && d.Report.Errors == 0) {
 				if (d.Report.Warnings > 0) {
 					Console.WriteLine ("Compilation succeeded - {0} warning(s)", d.Report.Warnings);
 				}
 				Environment.Exit (0);
 				return 0;
 			}
 			
 			
 			Console.WriteLine("Compilation failed
 				d.Report.Errors, d.Report.Warnings);
 			Environment.Exit (1);
 			return 1;
 		}
 
 		static string [] LoadArgs (string file)
 		{
 			StreamReader f;
 			var args = new List<string> ();
 			string line;
 			try {
 				f = new StreamReader (file);
 			} catch {
 				return null;
 			}
 
 			StringBuilder sb = new StringBuilder ();
 			
 			while ((line = f.ReadLine ()) != null){
 				int t = line.Length;
 
 				for (int i = 0; i < t; i++){
 					char c = line [i];
 					
 					if (c == '"' || c == '\''){
 						char end = c;
 						
 						for (i++; i < t; i++){
 							c = line [i];
 
 							if (c == end)
 								break;
 							sb.Append (c);
 						}
 					} else if (c == ' '){
 						if (sb.Length > 0){
 							args.Add (sb.ToString ());
 							sb.Length = 0;
 						}
 					} else
 						sb.Append (c);
 				}
 				if (sb.Length > 0){
 					args.Add (sb.ToString ());
 					sb.Length = 0;
 				}
 			}
 
 			return args.ToArray ();
 		}
 
 		//
 		// Given a path specification, splits the path from the file/pattern
 		//
 		static void SplitPathAndPattern (string spec, out string path, out string pattern)
 		{
 			int p = spec.LastIndexOf ('/');
 			if (p != -1){
 				//
 				// Windows does not like /file.cs, switch that to
 				// "\", "file.cs"
 				//
 				if (p == 0){
 					path = "\\";
 					pattern = spec.Substring (1);
 				} else {
 					path = spec.Substring (0, p);
 					pattern = spec.Substring (p + 1);
 				}
 				return;
 			}
 
 			p = spec.LastIndexOf ('\\');
 			if (p != -1){
 				path = spec.Substring (0, p);
 				pattern = spec.Substring (p + 1);
 				return;
 			}
 
 			path = ".";
 			pattern = spec;
 		}
 
 		void AddSourceFile (string f)
 		{
 			if (first_source == null)
 				first_source = f;
 
 			Location.AddFile (Report, f);
 		}
 
 		bool ParseArguments (string[] args, bool require_files, Func<string [], int, int> unknown_option_parser)
 		{
 			List<string> response_file_list = null;
 			bool parsing_options = true;
 
 			for (int i = 0; i < args.Length; i++) {
 				string arg = args [i];
 				if (arg.Length == 0)
 					continue;
 
 				if (arg [0] == '@') {
 					string [] extra_args;
 					string response_file = arg.Substring (1);
 
 					if (response_file_list == null)
 						response_file_list = new List<string> ();
 
 					if (response_file_list.Contains (response_file)) {
 						Report.Error (
 							1515, "Response file `" + response_file +
 							"' specified multiple times");
 						return false;
 					}
 
 					response_file_list.Add (response_file);
 
 					extra_args = LoadArgs (response_file);
 					if (extra_args == null) {
 						Report.Error (2011, "Unable to open response file
 								  response_file);
 						return false;
 					}
 
 					args = AddArgs (args, extra_args);
 					continue;
 				}
 
 				if (parsing_options) {
 					if (arg == "--") {
 						parsing_options = false;
 						continue;
 					}
 
 					if (arg [0] == '-') {
 						if (UnixParseOption (arg, ref args, ref i))
 							continue;
 
 						// Try a -CSCOPTION
 						string csc_opt = "/" + arg.Substring (1);
 						if (CSCParseOption (csc_opt, ref args))
 							continue;
 
 						if (unknown_option_parser != null){
 							var ret = unknown_option_parser (args, i);
 							if (ret != -1){
 								i = ret;
 								return true;
 							}
 						}
 						
 						Error_WrongOption (arg);
 						return false;
 					}
 					if (arg [0] == '/') {
 						if (CSCParseOption (arg, ref args))
 							continue;
 
 						// Need to skip `/home/test.cs' however /test.cs is considered as error
 						if (arg.Length < 2 || arg.IndexOf ('/', 2) == -1) {
 							Error_WrongOption (arg);
 							return false;
 						}
 					}
 				}
 
 				ProcessSourceFiles (arg, false);
 			}
 
 			if (require_files == false)
 				return true;
 					
 			//
 			// If we are an exe, require a source file for the entry point
 			//
 			if (RootContext.Target == Target.Exe || RootContext.Target == Target.WinExe || RootContext.Target == Target.Module) {
 				if (first_source == null) {
 					Report.Error (2008, "No files to compile were specified");
 					return false;
 				}
 
 			}
 
 			//
 			// If there is nothing to put in the assembly, and we are not a library
 			//
 			if (first_source == null && RootContext.Resources == null) {
 				Report.Error (2008, "No files to compile were specified");
 				return false;
 			}
 
 			return true;
 		}
 
 		public void Parse (ModuleContainer module)
 		{
 			Location.Initialize ();
 
 			var cu = Location.SourceFiles;
 			for (int i = 0; i < cu.Count; ++i) {
 				if (RootContext.TokenizeOnly) {
 					tokenize_file (cu [i], ctx);
 				} else {
 					Parse (cu [i], module);
 				}
 			}
 		}
 
 		void ProcessSourceFiles (string spec, bool recurse)
 		{
 			string path, pattern;
 
 			SplitPathAndPattern (spec, out path, out pattern);
 			if (pattern.IndexOf ('*') == -1){
 				AddSourceFile (spec);
 				return;
 			}
 
 			string [] files = null;
 			try {
 				files = Directory.GetFiles (path, pattern);
 			} catch (System.IO.DirectoryNotFoundException) {
 				Report.Error (2001, "Source file `" + spec + "' could not be found");
 				return;
 			} catch (System.IO.IOException){
 				Report.Error (2001, "Source file `" + spec + "' could not be found");
 				return;
 			}
 			foreach (string f in files) {
 				AddSourceFile (f);
 			}
 
 			if (!recurse)
 				return;
 			
 			string [] dirs = null;
 
 			try {
 				dirs = Directory.GetDirectories (path);
 			} catch {
 			}
 			
 			foreach (string d in dirs) {
 					
 				// Don't include path in this string, as each
 				// directory entry already does
 				ProcessSourceFiles (d + "/" + pattern, true);
 			}
 		}
 
 		void SetWarningLevel (string s)
 		{
 			int level = -1;
 
 			try {
 				level = Int32.Parse (s);
 			} catch {
 			}
 			if (level < 0 || level > 4){
 				Report.Error (1900, "Warning level must be in the range 0-4");
 				return;
 			}
 			Report.WarningLevel = level;
 		}
 
 		static void Version ()
 		{
 			string version = System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString ();
 			Console.WriteLine ("Mono C# compiler version {0}", version);
 			Environment.Exit (0);
 		}
 		
 		//
 		// Currently handles the Unix-like command line options, but will be
 		// deprecated in favor of the CSCParseOption, which will also handle the
 		// options that start with a dash in the future.
 		//
 		bool UnixParseOption (string arg, ref string [] args, ref int i)
 		{
 			switch (arg){
 			case "-v"
 				CSharpParser.yacc_verbose_flag++;
 				return true;
 
 			case "--version"
 				Version ();
 				return true;
 				
 			case "--parse"
 				RootContext.ParseOnly = true;
 				return true;
 				
 			case "--main"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.MainClass = args [++i];
 				return true;
 				
 			case "--unsafe"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.Unsafe = true;
 				return true;
 				
 			case "/?"
 			case "--help"
 				Usage ();
 				Environment.Exit (0);
 				return true;
 
 			case "--define"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.AddConditional (args [++i]);
 				return true;
 
 			case "--tokenize"
 				RootContext.TokenizeOnly = true;
 				return true;
 				
 			case "-o"
 			case "--output"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.OutputFile = args [++i];
 				return true;
 
 			case "--checked"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.Checked = true;
 				return true;
 				
 			case "--stacktrace"
 				Report.Printer.Stacktrace = true;
 				return true;
 				
 			case "--linkresource"
 			case "--linkres"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Report.Error (5, "Missing argument to --linkres"); 
 					Environment.Exit (1);
 				}
 
 				AddResource (new AssemblyResource (args[++i], args[i]));
 				return true;
 				
 			case "--resource"
 			case "--res"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Report.Error (5, "Missing argument to --resource"); 
 					Environment.Exit (1);
 				}
 
 				AddResource (new AssemblyResource (args[++i], args[i], true));
 				return true;
 				
 			case "--target"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Environment.Exit (1);
 					return true;
 				}
 				
 				string type = args [++i];
 				switch (type){
 				case "library"
 					RootContext.Target = Target.Library;
 					RootContext.TargetExt = ".dll";
 					break;
 					
 				case "exe"
 					RootContext.Target = Target.Exe;
 					break;
 					
 				case "winexe"
 					RootContext.Target = Target.WinExe;
 					break;
 					
 				case "module"
 					RootContext.Target = Target.Module;
 					RootContext.TargetExt = ".dll";
 					break;
 				default
 					TargetUsage ();
 					break;
 				}
 				return true;
 				
 			case "-r"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				
 				string val = args [++i];
 				int idx = val.IndexOf ('=');
 				if (idx > -1) {
 					string alias = val.Substring (0, idx);
 					string assembly = val.Substring (idx + 1);
 					AddAssemblyReference (alias, assembly);
 					return true;
 				}
 
 				AddAssemblyReference (val);
 				return true;
 				
 			case "-L"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();	
 					Environment.Exit (1);
 				}
 				RootContext.ReferencesLookupPaths.Add (args [++i]);
 				return true;
 
 			case "--lint"
 				RootContext.EnhancedWarnings = true;
 				return true;
 				
 			case "--nostdlib"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.StdLib = false;
 				return true;
 				
 			case "--nowarn"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				int warn = 0;
 				
 				try {
 					warn = Int32.Parse (args [++i]);
 				} catch {
 					Usage ();
 					Environment.Exit (1);
 				}
 				Report.SetIgnoreWarning (warn);
 				return true;
 
 			case "--wlevel"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Report.Error (
 						1900,
 						"--wlevel requires a value from 0 to 4");
 					Environment.Exit (1);
 				}
 
 				SetWarningLevel (args [++i]);
 				return true;
 
 			case "--mcs-debug"
 				if ((i + 1) >= args.Length){
 					Report.Error (5, "--mcs-debug requires an argument");
 					Environment.Exit (1);
 				}
 
 				try {
 					Report.DebugFlags = Int32.Parse (args [++i]);
 				} catch {
 					Report.Error (5, "Invalid argument to --mcs-debug");
 					Environment.Exit (1);
 				}
 				return true;
 				
 			case "--about"
 				About ();
 				return true;
 				
 			case "--recurse"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Report.Error (5, "--recurse requires an argument");
 					Environment.Exit (1);
 				}
 				ProcessSourceFiles (args [++i], true); 
 				return true;
 				
 			case "--timestamp"
 				timestamps = true;
 				return true;
 
 			case "--debug"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.GenerateDebugInfo = true;
 				return true;
 				
 			case "--noconfig"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.LoadDefaultReferences = false;
 				return true;
 
 			default
 				if (arg.StartsWith ("--fatal")){
 					if (arg.StartsWith ("--fatal=")){
 						if (!Int32.TryParse (arg.Substring (8), out fatal_errors))
 							fatal_errors = 1;
 					} else
 						fatal_errors = 1;
 					return true;
 				}
 				if (arg.StartsWith ("--runtime
 					string version = arg.Substring (10);
 
 					switch (version) {
 					case "v1"
 					case "V1"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v1;
 						break;
 					case "v2"
 					case "V2"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v2;
 						return true;
 					case "v4"
 					case "V4"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v4;
 						return true;
 					}
 					return true;
 				}
 
 				break;
 			}
 
 			return false;
 		}
 
 #if !SMCS_SOURCE
 		public static string GetPackageFlags (string packages, bool fatal, Report report)
 		{
 			ProcessStartInfo pi = new ProcessStartInfo ();
 			pi.FileName = "pkg-config";
 			pi.RedirectStandardOutput = true;
 			pi.UseShellExecute = false;
 			pi.Arguments = "--libs " + packages;
 			Process p = null;
 			try {
 				p = Process.Start (pi);
 			} catch (Exception e) {
 				report.Error (-27, "Couldn't run pkg-config
 				if (fatal)
 					Environment.Exit (1);
 				p.Close ();
 				return null;
 			}
 			
 			if (p.StandardOutput == null){
 				report.Warning (-27, 1, "Specified package did not return any information");
 				p.Close ();
 				return null;
 			}
 			string pkgout = p.StandardOutput.ReadToEnd ();
 			p.WaitForExit ();
 			if (p.ExitCode != 0) {
 				report.Error (-27, "Error running pkg-config. Check the above output.");
 				if (fatal)
 					Environment.Exit (1);
 				p.Close ();
 				return null;
 			}
 			p.Close ();
 
 			return pkgout;
 		}
 #endif
 
 		//
 		// This parses the -arg and /arg options to the compiler, even if the strings
 		// in the following text use "/arg" on the strings.
 		//
 		bool CSCParseOption (string option, ref string [] args)
 		{
 			int idx = option.IndexOf ('
 			string arg, value;
 
 			if (idx == -1){
 				arg = option;
 				value = "";
 			} else {
 				arg = option.Substring (0, idx);
 
 				value = option.Substring (idx + 1);
 			}
 
 			switch (arg.ToLowerInvariant ()){
 			case "/nologo"
 				return true;
 
 			case "/t"
 			case "/target"
 				switch (value){
 				case "exe"
 					RootContext.Target = Target.Exe;
 					break;
 
 				case "winexe"
 					RootContext.Target = Target.WinExe;
 					break;
 
 				case "library"
 					RootContext.Target = Target.Library;
 					RootContext.TargetExt = ".dll";
 					break;
 
 				case "module"
 					RootContext.Target = Target.Module;
 					RootContext.TargetExt = ".netmodule";
 					break;
 
 				default
 					TargetUsage ();
 					break;
 				}
 				return true;
 
 			case "/out"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				RootContext.OutputFile = value;
 				return true;
 
 			case "/o"
 			case "/o+"
 			case "/optimize"
 			case "/optimize+"
 				RootContext.Optimize = true;
 				return true;
 
 			case "/o-"
 			case "/optimize-"
 				RootContext.Optimize = false;
 				return true;
 
 			// TODO
 			case "/incremental"
 			case "/incremental+"
 			case "/incremental-"
 				// nothing.
 				return true;
 
 			case "/d"
 			case "/define"
 				if (value.Length == 0){
 					Usage ();
 					Environment.Exit (1);
 				}
 
 				foreach (string d in value.Split (argument_value_separator)) {
 					string conditional = d.Trim ();
 					if (!Tokenizer.IsValidIdentifier (conditional)) {
 						Report.Warning (2029, 1, "Invalid conditional define symbol `{0}'", conditional);
 						continue;
 					}
 					RootContext.AddConditional (conditional);
 				}
 				return true;
 			}
 
 			case "/bugreport"
 				//
 				// We should collect data, runtime, etc and store in the file specified
 				//
 				Console.WriteLine ("To file bug reports, please visit
 				return true;
 #if !SMCS_SOURCE
 			case "/pkg"
 				string packages;
 
 				if (value.Length == 0){
 					Usage ();
 					Environment.Exit (1);
 				}
 				packages = String.Join (" ", value.Split (new Char [] { ';', ',', '\n', '\r'}));
 				string pkgout = GetPackageFlags (packages, true, Report);
 				
 				if (pkgout != null){
 					string [] xargs = pkgout.Trim (new Char [] {' ', '\n', '\r', '\t'}).
 						Split (new Char [] { ' ', '\t'});
 					args = AddArgs (args, xargs);
 				}
 				
 				return true;
 			}
 #endif
 			case "/linkres"
 			case "/linkresource"
 			case "/res"
 			case "/resource"
 				AssemblyResource res = null;			
 				string[] s = value.Split (argument_value_separator, StringSplitOptions.RemoveEmptyEntries);
 				switch (s.Length) {
 				case 1
 					if (s[0].Length == 0)
 						goto default;
 					res = new AssemblyResource (s [0], Path.GetFileName (s[0]));
 					break;
 				case 2
 					res = new AssemblyResource (s [0], s [1]);
 					break;
 				case 3
 					if (s [2] != "public" && s [2] != "private") {
 						Report.Error (1906, "Invalid resource visibility option `{0}'. Use either `public' or `private' instead", s [2]);
 						return true;
 					}
 					res = new AssemblyResource (s[0], s[1], s[2] == "private");
 					break;
 				default
 					Report.Error (-2005, "Wrong number of arguments for option `{0}'", option);
 					break;
 				}
 
 				if (res != null) {
 					res.IsEmbeded = arg [1] == 'r' || arg [1] == 'R';
 					AddResource (res);
 				}
 
 				return true;
 				
 			case "/recurse"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				ProcessSourceFiles (value, true); 
 				return true;
 
 			case "/r"
 			case "/reference"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				string[] refs = value.Split (argument_value_separator);
 				foreach (string r in refs){
 					if (r.Length == 0)
 						continue;
 
 					string val = r;
 					int index = val.IndexOf ('=');
 					if (index > -1) {
 						string alias = r.Substring (0, index);
 						string assembly = r.Substring (index + 1);
 						AddAssemblyReference (alias, assembly);
 						if (refs.Length != 1) {
 							Report.Error (2034, "Cannot specify multiple aliases using single /reference option");
 							break;
 						}
 					} else {
 						AddAssemblyReference (val);
 					}
 				}
 				return true;
 			}
 			case "/addmodule"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				string[] refs = value.Split (argument_value_separator);
 				foreach (string r in refs){
 					RootContext.Modules.Add (r);
 				}
 				return true;
 			}
 			case "/win32res"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				
 				if (RootContext.Win32IconFile != null)
 					Report.Error (1565, "Cannot specify the `win32res' and the `win32ico' compiler option at the same time");
 
 				RootContext.Win32ResourceFile = value;
 				return true;
 			}
 			case "/win32icon"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				if (RootContext.Win32ResourceFile != null)
 					Report.Error (1565, "Cannot specify the `win32res' and the `win32ico' compiler option at the same time");
 
 				RootContext.Win32IconFile = value;
 				return true;
 			}
 			case "/doc"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				RootContext.Documentation = new Documentation (value);
 				return true;
 			}
 			case "/lib"
 				string [] libdirs;
 				
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				libdirs = value.Split (argument_value_separator);
 				foreach (string dir in libdirs)
 					RootContext.ReferencesLookupPaths.Add (dir);
 				return true;
 			}
 
 			case "/debug-"
 				RootContext.GenerateDebugInfo = false;
 				return true;
 				
 			case "/debug"
 				if (value == "full" || value == "")
 					RootContext.GenerateDebugInfo = true;
 
 				return true;
 				
 			case "/debug+"
 				RootContext.GenerateDebugInfo = true;
 				return true;
 
 			case "/checked"
 			case "/checked+"
 				RootContext.Checked = true;
 				return true;
 
 			case "/checked-"
 				RootContext.Checked = false;
 				return true;
 
 			case "/clscheck"
 			case "/clscheck+"
 				RootContext.VerifyClsCompliance = true;
 				return true;
 
 			case "/clscheck-"
 				RootContext.VerifyClsCompliance = false;
 				return true;
 
 			case "/unsafe"
 			case "/unsafe+"
 				RootContext.Unsafe = true;
 				return true;
 
 			case "/unsafe-"
 				RootContext.Unsafe = false;
 				return true;
 
 			case "/warnaserror"
 			case "/warnaserror+"
 				if (value.Length == 0) {
 					Report.WarningsAreErrors = true;
 				} else {
 					foreach (string wid in value.Split (argument_value_separator))
 						Report.AddWarningAsError (wid);
 				}
 				return true;
 
 			case "/warnaserror-"
 				if (value.Length == 0) {
 					Report.WarningsAreErrors = false;
 				} else {
 					foreach (string wid in value.Split (argument_value_separator))
 						Report.RemoveWarningAsError (wid);
 				}
 				return true;
 
 			case "/warn"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				SetWarningLevel (value);
 				return true;
 
 			case "/nowarn"
 				if (value.Length == 0){
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				var warns = value.Split (argument_value_separator);
 				foreach (string wc in warns){
 					try {
 						if (wc.Trim ().Length == 0)
 							continue;
 
 						int warn = Int32.Parse (wc);
 						if (warn < 1) {
 							throw new ArgumentOutOfRangeException("warn");
 						}
 						Report.SetIgnoreWarning (warn);
 					} catch {
 						Report.Error (1904, "`{0}' is not a valid warning number", wc);
 					}
 				}
 				return true;
 			}
 
 			case "/noconfig"
 				RootContext.LoadDefaultReferences = false;
 				return true;
 
 			case "/platform"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLower (CultureInfo.InvariantCulture)) {
 				case "anycpu"
 					RootContext.Platform = Platform.AnyCPU;
 					break;
 				case "x86"
 					RootContext.Platform = Platform.X86;
 					break;
 				case "x64"
 					RootContext.Platform = Platform.X64;
 					break;
 				case "itanium"
 					RootContext.Platform = Platform.IA64;
 					break;
 				default
 					Report.Error (1672, "Invalid platform type for -platform. Valid options are `anycpu', `x86', `x64' or `itanium'");
 					break;
 				}
 
 				return true;
 
 			case "/sdk"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLowerInvariant ()) {
 					case "2"
 						RootContext.SdkVersion = SdkVersion.v2;
 						break;
 					case "4"
 						RootContext.SdkVersion = SdkVersion.v4;
 						break;
 					default
 						Report.Error (-26, "Invalid sdk version name");
 						break;
 				}
 
 				return true;
 
 				// We just ignore this.
 			case "/errorreport"
 			case "/filealign"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				return true;
 				
 			case "/helpinternal"
 				OtherFlags ();
 				Environment.Exit(0);
 				return true;
 				
 			case "/help"
 			case "/?"
 				Usage ();
 				Environment.Exit (0);
 				return true;
 
 			case "/main"
 			case "/m"
 				if (value.Length == 0){
 					Error_RequiresArgument (option);
 					break;
 				}
 				RootContext.MainClass = value;
 				return true;
 
 			case "/nostdlib"
 			case "/nostdlib+"
 				RootContext.StdLib = false;
 				return true;
 
 			case "/nostdlib-"
 				RootContext.StdLib = true;
 				return true;
 
 			case "/fullpaths"
 				return true;
 
 			case "/keyfile"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				RootContext.StrongNameKeyFile = value;
 				return true;
 
 			case "/keycontainer"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				RootContext.StrongNameKeyContainer = value;
 				return true;
 			case "/delaysign+"
 			case "/delaysign"
 				RootContext.StrongNameDelaySign = true;
 				return true;
 			case "/delaysign-"
 				RootContext.StrongNameDelaySign = false;
 				return true;
 
 			case "/langversion"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLowerInvariant ()) {
 				case "iso-1"
 					RootContext.Version = LanguageVersion.ISO_1;
 					return true;	
 				case "default"
 					RootContext.Version = LanguageVersion.Default;
 					RootContext.AddConditional ("__V2__");
 					return true;
 				case "iso-2"
 					RootContext.Version = LanguageVersion.ISO_2;
 					return true;
 				case "3"
 					RootContext.Version = LanguageVersion.V_3;
 					return true;
 				case "future"
 					RootContext.Version = LanguageVersion.Future;
 					return true;
 				}
 
 				Report.Error (1617, "Invalid -langversion option `{0}'. It must be `ISO-1', `ISO-2', `3' or `Default'", value);
 				return true;
 
 			case "/codepage"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value) {
 				case "utf8"
 					RootContext.Encoding = new UTF8Encoding();
 					break;
 				case "reset"
 					RootContext.Encoding = Encoding.Default;
 					break;
 				default
 					try {
 						RootContext.Encoding = Encoding.GetEncoding (Int32.Parse (value));
 					} catch {
 						Report.Error (2016, "Code page `{0}' is invalid or not installed", value);
 					}
 					break;
 				}
 				return true;
 
 			default
 				return false;
 			}
 
 			return true;
 		}
 
 		void Error_WrongOption (string option)
 		{
 			Report.Error (2007, "Unrecognized command-line option
 		}
 
 		void Error_RequiresFileName (string option)
 		{
 			Report.Error (2005, "Missing file specification for `{0}' option", option);
 		}
 
 		void Error_RequiresArgument (string option)
 		{
 			Report.Error (2006, "Missing argument for `{0}' option", option);
 		}
 
 		static string [] AddArgs (string [] args, string [] extra_args)
 		{
 			string [] new_args;
 			new_args = new string [extra_args.Length + args.Length];
 
 			// if args contains '--' we have to take that into account
 			// split args into first half and second half based on '--'
 			// and add the extra_args before --
 			int split_position = Array.IndexOf (args, "--");
 			if (split_position != -1)
 			{
 				Array.Copy (args, new_args, split_position);
 				extra_args.CopyTo (new_args, split_position);
 				Array.Copy (args, split_position, new_args, split_position + extra_args.Length, args.Length - split_position);
 			}
 			else
 			{
 				args.CopyTo (new_args, 0);
 				extra_args.CopyTo (new_args, args.Length);
 			}
 
 			return new_args;
 		}
 
 		void AddAssemblyReference (string assembly)
 		{
 			RootContext.AssemblyReferences.Add (assembly);
 		}
 
 		void AddAssemblyReference (string alias, string assembly)
 		{
 			if (assembly.Length == 0) {
 				Report.Error (1680, "Invalid reference alias `{0}='. Missing filename", alias);
 				return;
 			}
 
 			if (!IsExternAliasValid (alias)) {
 				Report.Error (1679, "Invalid extern alias for -reference. Alias `{0}' is not a valid identifier", alias);
 				return;
 			}
 
 			RootContext.AssemblyReferencesAliases.Add (Tuple.Create (alias, assembly));
 		}
 
 		void AddResource (AssemblyResource res)
 		{
 			if (RootContext.Resources == null) {
 				RootContext.Resources = new List<AssemblyResource> ();
 				RootContext.Resources.Add (res);
 				return;
 			}
 
 			if (RootContext.Resources.Contains (res)) {
 				ctx.Report.Error (1508, "The resource identifier `{0}' has already been used in this assembly", res.Name);
 				return;
 			}
 
 			RootContext.Resources.Add (res);
 		}
 		
 		static bool IsExternAliasValid (string identifier)
 		{
 			if (identifier.Length == 0)
 				return false;
 			if (identifier [0] != '_' && !Char.IsLetter (identifier [0]))
 				return false;
 
 			for (int i = 1; i < identifier.Length; i++) {
 				char c = identifier [i];
 				if (Char.IsLetter (c) || Char.IsDigit (c))
 					continue;
 
 				UnicodeCategory category = Char.GetUnicodeCategory (c);
 				if (category != UnicodeCategory.Format || category != UnicodeCategory.NonSpacingMark ||
 						category != UnicodeCategory.SpacingCombiningMark ||
 						category != UnicodeCategory.ConnectorPunctuation)
 					return false;
 			}
 			
 			return true;
 		}
 
 		//
 		// Main compilation method
 		//
 		public bool Compile ()
 		{
 			var module = new ModuleContainer (ctx);
 			RootContext.ToplevelTypes = module;
 
 			if (timestamps) {
 				stopwatch = Stopwatch.StartNew ();
 				first_time = DateTime.Now;
 			}
 
 			Parse (module);
 			ShowTime ("Parsing source files");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (RootContext.TokenizeOnly || RootContext.ParseOnly)
 				return true;
 
 			if (RootContext.ToplevelTypes.NamespaceEntry != null)
 				throw new InternalErrorException ("who set it?");
 
 			//
 			// Quick hack
 			//
 			var output_file = RootContext.OutputFile;
 			string output_file_name;
 			if (output_file == null) {
 				if (first_source == null) {
 					Report.Error (1562, "If no source files are specified you must specify the output file with -out
 					return false;
 				}
 
 				int pos = first_source.LastIndexOf ('.');
 
 				if (pos > 0)
 					output_file = first_source.Substring (0, pos) + RootContext.TargetExt;
 				else
 					output_file = first_source + RootContext.TargetExt;
 
 				output_file_name = output_file;
 			} else {
 				output_file_name = Path.GetFileName (output_file);
 			}
 
 			//
 			// Load assemblies required
 			//
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 #if STATIC
 			var assembly = new AssemblyDefinitionStatic (module, output_file_name, output_file);
 			module.SetDeclaringAssembly (assembly);
 
 			var importer = new StaticImporter ();
 			assembly.Importer = importer;
 
 			var loader = new StaticLoader (importer, ctx);
 			loader.LoadReferences (module);
 
 			ShowTime ("Imporing referenced assemblies");
 
 			if (!ctx.BuildinTypes.CheckDefinitions (module))
 				return false;
 
 			ShowTime ("Initializing predefined types");
 
 			if (!assembly.Create (loader))
 				return false;
 
 			// System.Object was not loaded, use compiled assembly as corlib
 			if (loader.Corlib == null)
 				loader.Corlib = assembly.Builder;
 
 			loader.LoadModules (assembly, module.GlobalRootNamespace);
 #else
 			var assembly = new AssemblyDefinitionDynamic (module, output_file_name, output_file);
 			module.SetDeclaringAssembly (assembly);
 
 			var importer = new ReflectionImporter (ctx.BuildinTypes);
 			assembly.Importer = importer;
 
 			var loader = new DynamicLoader (importer, ctx);
 			loader.LoadReferences (module);
 
 			ShowTime ("Imporing referenced assemblies");
 
 			if (!ctx.BuildinTypes.CheckDefinitions (module))
 				return false;
 
 			ShowTime ("Initializing predefined types");
 
 			if (!assembly.Create (AppDomain.CurrentDomain, AssemblyBuilderAccess.Save))
 				return false;
 
 			loader.LoadModules (assembly, module.GlobalRootNamespace);
 #endif
 			module.Define ();
 
 			ShowTime ("Types definition");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (Report.Errors == 0 &&
 				RootContext.Documentation != null &&
 				!RootContext.Documentation.OutputDocComment (
 					output_file, Report))
 				return false;
 
 			//
 			// Verify using aliases now
 			//
 			NamespaceEntry.VerifyAllUsing ();
 			
 			if (Report.Errors > 0){
 				return false;
 			}
 
 			assembly.Resolve ();
 			
 			if (Report.Errors > 0)
 				return false;
 			
 			//
 			// The code generator
 			//
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 			assembly.Emit ();
 
 			ShowTime ("Resolving and emitting members blocks");
 
 			if (Report.Errors > 0){
 				return false;
 			}
 
 			module.CloseType ();
 
 			ShowTime ("Closing types");
 
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 			assembly.EmbedResources ();
 			ShowTime ("Embedding resources");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 			
 			assembly.Save ();
 
 #if STATIC
 			loader.Dispose ();
 #endif
 
 			ShowTime ("Saving output assembly");
 
 			ShowTotalTime ("Total");
 
 			Timer.ShowTimers ();
 
 			return (Report.Errors == 0);
 		}
 	}
 
 	//
 	// This is the only public entry point
 	//
 	public class CompilerCallableEntryPoint 
 		public static bool InvokeCompiler (string [] args, TextWriter error)
 		{
 			try {
 				StreamReportPrinter srp = new StreamReportPrinter (error);
 				Driver d = Driver.Create (args, true, null, srp);
 				if (d == null)
 					return false;
 
 				return d.Compile () && srp.ErrorsCount == 0;
 			} finally {
 				Reset ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1336" endline="1348">
<![CDATA[
 
 		protected void Initialize ()
 		{
 			TypeInfo[] sub_fields = TypeInfo.SubStructInfo;
 			if (sub_fields != null) {
 				sub_info = new VariableInfo [sub_fields.Length];
 				for (int i = 0; i < sub_fields.Length; i++) {
 					if (sub_fields [i] != null)
 						sub_info [i] = new VariableInfo (this, sub_fields [i]);
 				}
 				for (int i = 0; i < sub_fields.Length; i++) {
 					if (sub_fields [i] != null)
 						sub_info [i] = new VariableInfo (this, sub_fields [i]);
 				}
 			} else
 				sub_info = new VariableInfo [0];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7599" endline="7618">
<![CDATA[
 
 		Expression DoResolveName (ResolveContext rc, Expression right_side)
 		{
 			Expression e = LookupNameExpression (rc, right_side == null ? MemberLookupRestrictions.ReadAccess 
 			if (e == null)
 				return null;
 
 			if (right_side != null) {
 				if (e is TypeExpr) {
 					e.Error_UnexpectedKind (rc, ResolveFlags.VariableOrValue, loc);
 					return null;
 				}
 
 				e = e.ResolveLValue (rc, right_side);
 			} else {
 				e = e.Resolve (rc, ResolveFlags.VariableOrValue | ResolveFlags.Type);
 			}
 
 			return e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="633" endline="657">
<![CDATA[
 
 		static string GetParametersFormatted (MemberSpec mi)
 		{
 			var pm = mi as IParametersMember;
 			if (pm == null || pm.Parameters.IsEmpty)
 				return string.Empty;
 
 			AParametersCollection parameters = pm.Parameters;
 /*
 			if (parameters == null || parameters.Count == 0)
 				return String.Empty;
 */
 			StringBuilder sb = new StringBuilder ();
 			sb.Append ('(');
 			for (int i = 0; i < parameters.Count; i++) {
 //				if (is_setter && i + 1 == parameters.Count)
 //					break; // skip "value".
 				if (i > 0)
 					sb.Append (',');
 				TypeSpec t = parameters.Types [i];
 				sb.Append (GetSignatureForDoc (t));
 			}
 			for (int i = 0; i < parameters.Count; i++) {
 //				if (is_setter && i + 1 == parameters.Count)
 //					break; // skip "value".
 				if (i > 0)
 					sb.Append (',');
 				TypeSpec t = parameters.Types [i];
 				sb.Append (GetSignatureForDoc (t));
 			}
 			sb.Append (')');
 			return sb.ToString ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="634" endline="656">
<![CDATA[
 
 	public static string RemoveGenericArity (string name)
 	{
 		int start = 0;
 		StringBuilder sb = new StringBuilder ();
 		while (start < name.Length) {
 			int pos = name.IndexOf ('`', start);
 			if (pos < 0) {
 				sb.Append (name.Substring (start));
 				break;
 			}
 			sb.Append (name.Substring (start, pos-start));
 
 			pos++;
 
 			while ((pos < name.Length) && Char.IsNumber (name [pos]))
 				pos++;
 			while ((pos < name.Length) && Char.IsNumber (name [pos]))
 				pos++;
 
 			start = pos;
 		}
 		while (start < name.Length) {
 			int pos = name.IndexOf ('`', start);
 			if (pos < 0) {
 				sb.Append (name.Substring (start));
 				break;
 			}
 			sb.Append (name.Substring (start, pos-start));
 
 			pos++;
 
 			while ((pos < name.Length) && Char.IsNumber (name [pos]))
 				pos++;
 
 			start = pos;
 		}
 
 		return sb.ToString ();
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2047" endline="2088">
<![CDATA[
 	}
 
 	sealed class GenericTypeInstance 
 	{
 		private readonly Type type;
 		private readonly Type[] args;
 		private readonly Type[][] requiredCustomModifiers;
 		private readonly Type[][] optionalCustomModifiers;
 		private Type baseType;
 		private int token;
 
 		internal static Type Make(Type type, Type[] typeArguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
 		{
 			bool identity = true;
 			if (type is TypeBuilder || type is BakedType)
 			{
 				// a TypeBuiler identity must be instantiated
 				identity = false;
 			}
 			else
 			{
 				// we must not instantiate the identity instance, because typeof(Foo<>).MakeGenericType(typeof(Foo<>).GetGenericArguments()) == typeof(Foo<>)
 				for (int i = 0; i < typeArguments.Length; i++)
 				{
 					if (typeArguments[i] != type.GetGenericTypeArgument(i)
 						|| !IsEmpty(requiredCustomModifiers, i)
 						|| !IsEmpty(optionalCustomModifiers, i))
 					{
 						identity = false;
 						break;
 					}
 				}
 				for (int i = 0; i < typeArguments.Length; i++)
 				{
 					if (typeArguments[i] != type.GetGenericTypeArgument(i)
 						|| !IsEmpty(requiredCustomModifiers, i)
 						|| !IsEmpty(optionalCustomModifiers, i))
 					{
 						identity = false;
 						break;
 					}
 				}
 			}
 			if (identity)
 			{
 				return type;
 			}
 			else
 			{
 				return type.Module.CanonicalizeType(new GenericTypeInstance(type, typeArguments, requiredCustomModifiers, optionalCustomModifiers));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="979" endline="989">
<![CDATA[
 		{
 			Expression e = Resolve (ec);
 			if (e == null)
 				return null;
 
 			ExpressionStatement es = e as ExpressionStatement;
 			if (es == null)
 				Error_InvalidExpressionStatement (ec);
 
 			return es;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3518" endline="3541">
<![CDATA[
 
 		//
 		// Merge two sets of user operators into one, they are mostly distinguish
 		// expect when they share base type and it contains an operator
 		//
 		static IList<MemberSpec> CombineUserOperators (IList<MemberSpec> left, IList<MemberSpec> right)
 		{
 			var combined = new List<MemberSpec> (left.Count + right.Count);
 			combined.AddRange (left);
 			foreach (var r in right) {
 				bool same = false;
 				foreach (var l in left) {
 					if (l.DeclaringType == r.DeclaringType) {
 						same = true;
 						break;
 					}
 				}
 				foreach (var l in left) {
 					if (l.DeclaringType == r.DeclaringType) {
 						same = true;
 						break;
 					}
 				}
 
 				if (!same)
 					combined.Add (r);
 			}
 			foreach (var r in right) {
 				bool same = false;
 				foreach (var l in left) {
 					if (l.DeclaringType == r.DeclaringType) {
 						same = true;
 						break;
 					}
 				}
 
 				if (!same)
 					combined.Add (r);
 			}
 
 			return combined;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="874" endline="897">
<![CDATA[
 		
 		static public string GetVars ()
 		{
 			lock (evaluator_lock){
 				StringBuilder sb = new StringBuilder ();
 				
 				foreach (var de in fields){
 					var fi = LookupField (de.Key);
 					object value;
 					try {
 						value = fi.Item2.GetValue (null);
 						if (value is string)
 							value = Quote ((string)value);
 					} catch {
 						value = "<error reading value>";
 					}
 
 					sb.AppendFormat ("{0} {1} = {2}", fi.Item1.MemberType.GetSignatureForError (), de.Key, value);
 					sb.AppendLine ();
 				}
 				foreach (var de in fields){
 					var fi = LookupField (de.Key);
 					object value;
 					try {
 						value = fi.Item2.GetValue (null);
 						if (value is string)
 							value = Quote ((string)value);
 					} catch {
 						value = "<error reading value>";
 					}
 
 					sb.AppendFormat ("{0} {1} = {2}", fi.Item1.MemberType.GetSignatureForError (), de.Key, value);
 					sb.AppendLine ();
 				}
 				
 				return sb.ToString ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2977" endline="2985">
<![CDATA[
 
 		protected override void EmitSymbolInfo (EmitContext ec)
 		{
 			AnonymousExpression ae = ec.CurrentAnonymousMethod;
 			if ((ae != null) && (ae.Storey != null))
 				SymbolWriter.DefineScopeVariable (ae.Storey.ID);
 
 			base.EmitSymbolInfo (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="147" endline="161">
<![CDATA[
 
 		public virtual void Emit (EmitContext ec)
 		{
 			if (!IsByRef) {
 				Expr.Emit (ec);
 				return;
 			}
 
 			AddressOp mode = AddressOp.Store;
 			if (ArgType == AType.Ref)
 				mode |= AddressOp.Load;
 
 			IMemoryLocation ml = (IMemoryLocation) Expr;
 			ml.AddressOf (ec, mode);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="355" endline="366">
<![CDATA[
 
 		public void CheckArrayAsAttribute (CompilerContext ctx)
 		{
 			foreach (Argument arg in args) {
 				// Type is undefined (was error 246)
 				if (arg.Type == null)
 					continue;
 
 				if (arg.Type.IsArray)
 					ctx.Report.Warning (3016, 1, arg.Expr.Location, "Arrays as attribute arguments are not CLS-compliant");
 			}
 			foreach (Argument arg in args) {
 				// Type is undefined (was error 246)
 				if (arg.Type == null)
 					continue;
 
 				if (arg.Type.IsArray)
 					ctx.Report.Warning (3016, 1, arg.Expr.Location, "Arrays as attribute arguments are not CLS-compliant");
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="225" endline="240">
<![CDATA[
 
 		public void WriteSymbolFile (Guid guid)
 		{
 			foreach (SourceMethodBuilder method in methods)
 				method.DefineMethod (file);
 			foreach (SourceMethodBuilder method in methods)
 				method.DefineMethod (file);
 
 			try {
 				// We mmap the file, so unlink the previous version since it may be in use
 				File.Delete (filename);
 			} catch {
 				// We can safely ignore
 			}
 			using (FileStream fs = new FileStream (filename, FileMode.Create, FileAccess.Write)) {
 				file.CreateSymbolFile (guid, fs);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="491" endline="511">
<![CDATA[
 
 		internal override Type GetTypeImpl(string typeName)
 		{
 			foreach (ModuleBuilder mb in modules)
 			{
 				Type type = mb.GetTypeImpl(typeName);
 				if (type != null)
 				{
 					return type;
 				}
 			}
 			foreach (ModuleBuilder mb in modules)
 			{
 				Type type = mb.GetTypeImpl(typeName);
 				if (type != null)
 				{
 					return type;
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				Type type = module.GetTypeImpl(typeName);
 				if (type != null)
 				{
 					return type;
 				}
 			}
 			foreach (Module module in addedModules)
 			{
 				Type type = module.GetTypeImpl(typeName);
 				if (type != null)
 				{
 					return type;
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="205" endline="225">
<![CDATA[
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if ((addOnMethod != null && addOnMethod.IsPublic) || (removeOnMethod != null && removeOnMethod.IsPublic) || (fireMethod != null && fireMethod.IsPublic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsPublic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="226" endline="247">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if ((addOnMethod != null && addOnMethod.IsStatic) || (removeOnMethod != null && removeOnMethod.IsStatic) || (fireMethod != null && fireMethod.IsStatic))
 				{
 					return true;
 				}
 				if (otherMethods != null)
 				{
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 					foreach (MethodBuilder method in otherMethods)
 					{
 						if (method.IsStatic)
 						{
 							return true;
 						}
 					}
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1112" endline="1142">
<![CDATA[
 
 		// <summary>
 		//   A struct's constructor must always assign all fields.
 		//   This method checks whether it actually does so.
 		// </summary>
 		public bool IsFullyInitialized (BlockContext ec, VariableInfo vi, Location loc)
 		{
 			if (struct_info == null)
 				return true;
 
 			bool ok = true;
 			FlowBranching branching = ec.CurrentBranching;
 			for (int i = 0; i < struct_info.Count; i++) {
 				var field = struct_info.Fields [i];
 
 				if (!branching.IsFieldAssigned (vi, field.Name)) {
 					if (field.MemberDefinition is Property.BackingField) {
 						ec.Report.Error (843, loc,
 							"An automatically implemented property `{0}' must be fully assigned before control leaves the constructor. Consider calling the default struct contructor from a constructor initializer",
 							field.GetSignatureForError ());
 					} else {
 						ec.Report.Error (171, loc,
 							"Field `{0}' must be fully assigned before control leaves the constructor",
 							field.GetSignatureForError ());
 					}
 					ok = false;
 				}
 			}
 			for (int i = 0; i < struct_info.Count; i++) {
 				var field = struct_info.Fields [i];
 
 				if (!branching.IsFieldAssigned (vi, field.Name)) {
 					if (field.MemberDefinition is Property.BackingField) {
 						ec.Report.Error (843, loc,
 							"An automatically implemented property `{0}' must be fully assigned before control leaves the constructor. Consider calling the default struct contructor from a constructor initializer",
 							field.GetSignatureForError ());
 					} else {
 						ec.Report.Error (171, loc,
 							"Field `{0}' must be fully assigned before control leaves the constructor",
 							field.GetSignatureForError ());
 					}
 					ok = false;
 				}
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1872" endline="1881">
<![CDATA[
 
 		public override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameterInfos = new ParameterInfo[parameterTypes.Length];
 			for (int i = 0; i < parameterInfos.Length; i++)
 			{
 				parameterInfos[i] = new ParameterInfoImpl(this, parameterTypes[i], i);
 			}
 			for (int i = 0; i < parameterInfos.Length; i++)
 			{
 				parameterInfos[i] = new ParameterInfoImpl(this, parameterTypes[i], i);
 			}
 			return parameterInfos;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="250" endline="271">
<![CDATA[
 
 		internal int ReadMethodDefOrRef()
 		{
 			int codedIndex;
 			if (bigMethodDefOrRef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MemberRefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="296" endline="317">
<![CDATA[
 
 		internal int ReadHasSemantics()
 		{
 			int codedIndex;
 			if (bigHasSemantics)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (EventTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (PropertyTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="318" endline="339">
<![CDATA[
 
 		internal int ReadHasFieldMarshal()
 		{
 			int codedIndex;
 			if (bigHasFieldMarshal)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (ParamTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="364" endline="385">
<![CDATA[
 
 		internal int ReadTypeOrMethodDef()
 		{
 			int codedIndex;
 			if (bigTypeOrMethodDef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="386" endline="407">
<![CDATA[
 
 		internal int ReadMemberForwarded()
 		{
 			int codedIndex;
 			if (bigMemberForwarded)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 1)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 1);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 1);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="519" endline="537">
<![CDATA[
 
 		private string PublicKeyOrTokenToString(int publicKeyOrToken)
 		{
 			if (publicKeyOrToken == 0)
 			{
 				return "null";
 			}
 			ByteReader br = GetBlob(publicKeyOrToken);
 			if (br.Length == 0)
 			{
 				return "null";
 			}
 			StringBuilder sb = new StringBuilder(br.Length * 2);
 			while (br.Length > 0)
 			{
 				sb.AppendFormat("{0
 			}
 			while (br.Length > 0)
 			{
 				sb.AppendFormat("{0
 			}
 			return sb.ToString();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="351" endline="380">
<![CDATA[
 
 		//
 		// When using assembly public key attributes InternalsVisibleTo key
 		// was not checked, we have to do it later when we actually know what
 		// our public key token is
 		//
 		void CheckReferencesPublicToken ()
 		{
 			// TODO
 			// no working SRE API
 			foreach (var a in Importer.Assemblies) {
 				if (public_key != null && !a.HasStrongName) {
 					Report.Error (1577, "Referenced assembly `{0}' does not have a strong name",
 						a.FullName);
 				}
 
 				if (!a.IsFriendAssemblyTo (this))
 					continue;
 
 				var attr = a.GetAssemblyVisibleToName (this);
 				var atoken = attr.GetPublicKeyToken ();
 
 				if (ArrayComparer.IsEqual (GetPublicKeyToken (), atoken))
 					continue;
 
 				Report.Error (281,
 					"Friend access was granted to `{0}', but the output assembly is named `{1}'. Try adding a reference to `{0}' or change the output assembly name to match it",
 					attr.FullName, FullName);
 			}
 			foreach (var a in Importer.Assemblies) {
 				if (public_key != null && !a.HasStrongName) {
 					Report.Error (1577, "Referenced assembly `{0}' does not have a strong name",
 						a.FullName);
 				}
 
 				if (!a.IsFriendAssemblyTo (this))
 					continue;
 
 				var attr = a.GetAssemblyVisibleToName (this);
 				var atoken = attr.GetPublicKeyToken ();
 
 				if (ArrayComparer.IsEqual (GetPublicKeyToken (), atoken))
 					continue;
 
 				Report.Error (281,
 					"Friend access was granted to `{0}', but the output assembly is named `{1}'. Try adding a reference to `{0}' or change the output assembly name to match it",
 					attr.FullName, FullName);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2372" endline="2391">
<![CDATA[
 
 		internal override Type BindTypeParameters(IGenericBinder binder)
 		{
 			for (int i = 0; i < args.Length; i++)
 			{
 				Type xarg = args[i].BindTypeParameters(binder);
 				if (!ReferenceEquals(xarg, args[i]))
 				{
 					Type[] xargs = new Type[args.Length];
 					Array.Copy(args, xargs, i);
 					xargs[i++] = xarg;
 					for (; i < args.Length; i++)
 					{
 						xargs[i] = args[i].BindTypeParameters(binder);
 					}
 					for (; i < args.Length; i++)
 					{
 						xargs[i] = args[i].BindTypeParameters(binder);
 					}
 					return Make(type, xargs, null, null);
 				}
 			}
 			for (int i = 0; i < args.Length; i++)
 			{
 				Type xarg = args[i].BindTypeParameters(binder);
 				if (!ReferenceEquals(xarg, args[i]))
 				{
 					Type[] xargs = new Type[args.Length];
 					Array.Copy(args, xargs, i);
 					xargs[i++] = xarg;
 					for (; i < args.Length; i++)
 					{
 						xargs[i] = args[i].BindTypeParameters(binder);
 					}
 					return Make(type, xargs, null, null);
 				}
 			}
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="720" endline="745">
<![CDATA[
 
 		// this reads just the optional parameter types, from a MethodRefSig
 		internal static Type[] ReadOptionalParameterTypes(ModuleReader module, ByteReader br)
 		{
 			br.ReadByte();
 			int paramCount = br.ReadCompressedInt();
 			SkipCustomModifiers(br);
 			ReadRetType(module, br, null);
 			for (int i = 0; i < paramCount; i++)
 			{
 				if (br.PeekByte() == SENTINEL)
 				{
 					br.ReadByte();
 					Type[] types = new Type[paramCount - i];
 					for (int j = 0; j < types.Length; j++)
 					{
 						SkipCustomModifiers(br);
 						types[j] = ReadType(module, br, null);
 					}
 					for (int j = 0; j < types.Length; j++)
 					{
 						SkipCustomModifiers(br);
 						types[j] = ReadType(module, br, null);
 					}
 					return types;
 				}
 				SkipCustomModifiers(br);
 				ReadType(module, br, null);
 			}
 			for (int i = 0; i < paramCount; i++)
 			{
 				if (br.PeekByte() == SENTINEL)
 				{
 					br.ReadByte();
 					Type[] types = new Type[paramCount - i];
 					for (int j = 0; j < types.Length; j++)
 					{
 						SkipCustomModifiers(br);
 						types[j] = ReadType(module, br, null);
 					}
 					return types;
 				}
 				SkipCustomModifiers(br);
 				ReadType(module, br, null);
 			}
 			return Type.EmptyTypes;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2241" endline="2259">
<![CDATA[
 
 		public override void VerifyMembers ()
 		{
 			base.VerifyMembers ();
 
 			if ((events != null) && Report.WarningLevel >= 3) {
 				foreach (Event e in events){
 					// Note
 					// this warning for all accessibility modes
 					if ((e.caching_flags & Flags.IsUsed) == 0)
 						Report.Warning (67, 3, e.Location, "The event `{0}' is never used", e.GetSignatureForError ());
 				}
 				foreach (Event e in events){
 					// Note
 					// this warning for all accessibility modes
 					if ((e.caching_flags & Flags.IsUsed) == 0)
 						Report.Warning (67, 3, e.Location, "The event `{0}' is never used", e.GetSignatureForError ());
 				}
 			}
 
 			if (types != null) {
 				foreach (var t in types)
 					t.VerifyMembers ();
 				foreach (var t in types)
 					t.VerifyMembers ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="445" endline="473">
<![CDATA[
 			
 		[Conditional ("MCS_DEBUG")]
 		static public void Debug (int category, string message, params object[] args)
 		{
 			if ((category & DebugFlags) == 0)
 				return;
 
 			StringBuilder sb = new StringBuilder (message);
 
 			if ((args != null) && (args.Length > 0)) {
 				sb.Append ("
 
 				bool first = true;
 				foreach (object arg in args) {
 					if (first)
 						first = false;
 					else
 						sb.Append (", ");
 					if (arg == null)
 						sb.Append ("null");
 //					else if (arg is ICollection)
 //						sb.Append (PrintCollection ((ICollection) arg));
 					else
 						sb.Append (arg);
 				}
 				foreach (object arg in args) {
 					if (first)
 						first = false;
 					else
 						sb.Append (", ");
 					if (arg == null)
 						sb.Append ("null");
 //					else if (arg is ICollection)
 //						sb.Append (PrintCollection ((ICollection) arg));
 					else
 						sb.Append (arg);
 				}
 			}
 
 			Console.WriteLine (sb.ToString ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="851" endline="860">
<![CDATA[
 
 		internal string[] GetManifestResourceNames()
 		{
 			string[] names = new string[ManifestResource.records.Length];
 			for (int i = 0; i < ManifestResource.records.Length; i++)
 			{
 				names[i] = GetString(ManifestResource.records[i].Name);
 			}
 			for (int i = 0; i < ManifestResource.records.Length; i++)
 			{
 				names[i] = GetString(ManifestResource.records[i].Name);
 			}
 			return names;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="817" endline="828">
<![CDATA[
 
 		public string GetSignatureForError (string start, string end, int count)
 		{
 			StringBuilder sb = new StringBuilder (start);
 			for (int i = 0; i < count; ++i) {
 				if (i != 0)
 					sb.Append (", ");
 				sb.Append (ParameterDesc (i));
 			}
 			for (int i = 0; i < count; ++i) {
 				if (i != 0)
 					sb.Append (", ");
 				sb.Append (ParameterDesc (i));
 			}
 			sb.Append (end);
 			return sb.ToString ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2691" endline="2713">
<![CDATA[
 
 		//
 		// All unfixed type variables Xi are fixed for which all of the following hold
 		// a, There is at least one type variable Xj that depends on Xi
 		// b, Xi has a non-empty set of bounds
 		// 
 		public bool FixDependentTypes (ResolveContext ec, ref bool fixed_any)
 		{
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (fixed_types[i] != null)
 					continue;
 
 				if (bounds[i] == null)
 					continue;
 
 				if (!FixType (ec, i))
 					return false;
 				
 				fixed_any = true;
 			}
 			for (int i = 0; i < tp_args.Length; ++i) {
 				if (fixed_types[i] != null)
 					continue;
 
 				if (bounds[i] == null)
 					continue;
 
 				if (!FixType (ec, i))
 					return false;
 				
 				fixed_any = true;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\TypeNameParser.cs" startline="67" endline="86">
<![CDATA[
 
 		internal static string Unescape(string name)
 		{
 			int pos = name.IndexOf('\\');
 			if (pos == -1)
 			{
 				return name;
 			}
 			StringBuilder sb = new StringBuilder(name, 0, pos, name.Length - 1);
 			for (; pos < name.Length; pos++)
 			{
 				char c = name[pos];
 				if (c == '\\')
 				{
 					c = name[++pos];
 				}
 				sb.Append(c);
 			}
 			for (; pos < name.Length; pos++)
 			{
 				char c = name[pos];
 				if (c == '\\')
 				{
 					c = name[++pos];
 				}
 				sb.Append(c);
 			}
 			return sb.ToString();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="528" endline="564">
<![CDATA[
 
 		public static IList<CustomAttributeData> __GetCustomAttributes(MemberInfo member, Type attributeType, bool inherit)
 		{
 			if (!inherit || !IsInheritableAttribute(attributeType))
 			{
 				return member.GetCustomAttributesData(attributeType);
 			}
 			List<CustomAttributeData> list = new List<CustomAttributeData>();
 			for (; ; )
 			{
 				list.AddRange(member.GetCustomAttributesData(attributeType));
 				Type type = member as Type;
 				if (type != null)
 				{
 					type = type.BaseType;
 					if (type == null)
 					{
 						return list;
 					}
 					member = type;
 					continue;
 				}
 				MethodInfo method = member as MethodInfo;
 				if (method != null)
 				{
 					MemberInfo prev = member;
 					method = method.GetBaseDefinition();
 					if (method == null || method == prev)
 					{
 						return list;
 					}
 					member = method;
 					continue;
 				}
 				return list;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="989" endline="1017">
<![CDATA[
 
 		public static TypeParameterSpec[] InflateConstraints<T> (TypeParameterSpec[] tparams, Func<T, TypeParameterInflator> inflatorFactory, T arg)
 		{
 			TypeParameterSpec[] constraints = null;
 			TypeParameterInflator? inflator = null;
 
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 				if (tp.HasTypeConstraint || tp.Interfaces != null || tp.TypeArguments != null) {
 					if (constraints == null) {
 						constraints = new TypeParameterSpec[tparams.Length];
 						Array.Copy (tparams, constraints, constraints.Length);
 					}
 
 					//
 					// Using a factory to avoid possibly expensive inflator build up
 					//
 					if (inflator == null)
 						inflator = inflatorFactory (arg);
 
 					constraints[i] = (TypeParameterSpec) constraints[i].InflateMember (inflator.Value);
 				}
 			}
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 				if (tp.HasTypeConstraint || tp.Interfaces != null || tp.TypeArguments != null) {
 					if (constraints == null) {
 						constraints = new TypeParameterSpec[tparams.Length];
 						Array.Copy (tparams, constraints, constraints.Length);
 					}
 
 					//
 					// Using a factory to avoid possibly expensive inflator build up
 					//
 					if (inflator == null)
 						inflator = inflatorFactory (arg);
 
 					constraints[i] = (TypeParameterSpec) constraints[i].InflateMember (inflator.Value);
 				}
 			}
 
 			if (constraints == null)
 				constraints = tparams;
 
 			return constraints;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="653" endline="664">
<![CDATA[
 		}
 
 		public SourceFileEntry[] IncludeFiles {
 			get {
 				ReadData ();
 				if (include_files == null)
 					return new SourceFileEntry [0];
 
 				SourceFileEntry[] retval = new SourceFileEntry [include_files.Count];
 				include_files.CopyTo (retval, 0);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1289" endline="1298">
<![CDATA[
 
 		public TypeParameterSpec Mutate (TypeParameterSpec tp)
 		{
 			for (int i = 0; i < mvar.Length; ++i) {
 				if (mvar[i].Type == tp)
 					return var[i].Type;
 			}
 			for (int i = 0; i < mvar.Length; ++i) {
 				if (mvar[i].Type == tp)
 					return var[i].Type;
 			}
 
 			return tp;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="276" endline="287">
<![CDATA[
 
 		internal bool Match(int pos, ByteBuffer bb2, int pos2, int len)
 		{
 			for (int i = 0; i < len; i++)
 			{
 				if (buffer[pos + i] != bb2.buffer[pos2 + i])
 				{
 					return false;
 				}
 			}
 			for (int i = 0; i < len; i++)
 			{
 				if (buffer[pos + i] != bb2.buffer[pos2 + i])
 				{
 					return false;
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2053" endline="2073">
<![CDATA[
 
 		//
 		// Used for visiblity checks to tests whether this definition shares
 		// base type baseType, it does member-definition search
 		//
 		public bool IsBaseTypeDefinition (TypeSpec baseType)
 		{
 			// RootContext check
 			if (TypeBuilder == null)
 				return false;
 
 			var type = spec;
 			do {
 				if (type.MemberDefinition == baseType.MemberDefinition)
 					return true;
 
 				type = type.BaseType;
 			} while (type != null);
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2454" endline="2480">
<![CDATA[
 		}
 
 		#endregion
 
 		// <summary>
 		//   Check whether all `out' parameters have been assigned.
 		// </summary>
 		public void CheckOutParameters (FlowBranching.UsageVector vector, Location loc)
 		{
 			if (vector.IsUnreachable)
 				return;
 
 			int n = parameter_info == null ? 0 
 
 			for (int i = 0; i < n; i++) {
 				VariableInfo var = parameter_info[i].VariableInfo;
 
 				if (var == null)
 					continue;
 
 				if (vector.IsAssigned (var, false))
 					continue;
 
 				TopBlock.Report.Error (177, loc, "The out parameter `{0}' must be assigned to before control leaves the current method",
 					var.Name);
 			}
 			for (int i = 0; i < n; i++) {
 				VariableInfo var = parameter_info[i].VariableInfo;
 
 				if (var == null)
 					continue;
 
 				if (vector.IsAssigned (var, false))
 					continue;
 
 				TopBlock.Report.Error (177, loc, "The out parameter `{0}' must be assigned to before control leaves the current method",
 					var.Name);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2436" endline="2457">
<![CDATA[
 		
 		Expression SimpleNameResolve (ResolveContext ec, Expression right_side, bool intermediate)
 		{
 			Expression e = LookupNameExpression (ec, right_side == null ? MemberLookupRestrictions.ReadAccess 
 
 			if (e == null)
 				return null;
 
 			if (right_side != null) {
 				if (e is TypeExpr) {
 				    e.Error_UnexpectedKind (ec, ResolveFlags.VariableOrValue, loc);
 				    return null;
 				}
 
 				e = e.ResolveLValue (ec, right_side);
 			} else {
 				e = e.Resolve (ec);
 			}
 
 			//if (ec.CurrentBlock == null || ec.CurrentBlock.CheckInvariantMeaningInBlock (Name, e, Location))
 			return e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="569" endline="589">
<![CDATA[
 
 		private Assembly GetLoadedAssembly(string refname)
 		{
 			Assembly asm;
 			if (!assembliesByName.TryGetValue(refname, out asm))
 			{
 				for (int i = 0; i < assemblies.Count; i++)
 				{
 					AssemblyComparisonResult result;
 					// We won't allow FX unification here, because our own (non-Fusion) implementation of CompareAssemblyIdentity doesn't support it and
 					// we don't want to create a fundamental functional difference based on that.
 					if (CompareAssemblyIdentity(refname, false, assemblies[i].FullName, false, out result) && result != AssemblyComparisonResult.EquivalentFXUnified)
 					{
 						asm = assemblies[i];
 						assembliesByName.Add(refname, asm);
 						break;
 					}
 				}
 				for (int i = 0; i < assemblies.Count; i++)
 				{
 					AssemblyComparisonResult result;
 					// We won't allow FX unification here, because our own (non-Fusion) implementation of CompareAssemblyIdentity doesn't support it and
 					// we don't want to create a fundamental functional difference based on that.
 					if (CompareAssemblyIdentity(refname, false, assemblies[i].FullName, false, out result) && result != AssemblyComparisonResult.EquivalentFXUnified)
 					{
 						asm = assemblies[i];
 						assembliesByName.Add(refname, asm);
 						break;
 					}
 				}
 			}
 			return asm;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="770" endline="798">
<![CDATA[
 
 		// Very expensive operation
 		public MetaType[] GetMetaInfo ()
 		{
 			MetaType[] types;
 			if (has_arglist) {
 				if (Count == 1)
 					return MetaType.EmptyTypes;
 
 				types = new MetaType[Count - 1];
 			} else {
 				if (Count == 0)
 					return MetaType.EmptyTypes;
 
 				types = new MetaType[Count];
 			}
 
 			for (int i = 0; i < types.Length; ++i) {
 				types[i] = Types[i].GetMetaInfo ();
 
 				if ((FixedParameters [i].ModFlags & Parameter.Modifier.ISBYREF) == 0)
 					continue;
 
 				// TODO MemberCache
 				types [i] = types [i].MakeByRefType ();
 			}
 			for (int i = 0; i < types.Length; ++i) {
 				types[i] = Types[i].GetMetaInfo ();
 
 				if ((FixedParameters [i].ModFlags & Parameter.Modifier.ISBYREF) == 0)
 					continue;
 
 				// TODO MemberCache
 				types [i] = types [i].MakeByRefType ();
 			}
 
 			return types;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2061" endline="2070">
<![CDATA[
 
 		bool IsTokenIdentifierEqual (char[] identifier)
 		{
 			for (int i = 0; i < identifier.Length; ++i) {
 				if (identifier[i] != id_builder[i])
 					return false;
 			}
 			for (int i = 0; i < identifier.Length; ++i) {
 				if (identifier[i] != id_builder[i])
 					return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2529" endline="2538">
<![CDATA[
 
 		public static OpType? GetType (string metadata_name)
 		{
 			for (int i = 0; i < names.Length; ++i) {
 				if (names[i][1] == metadata_name)
 					return (OpType) i;
 			}
 			for (int i = 0; i < names.Length; ++i) {
 				if (names[i][1] == metadata_name)
 					return (OpType) i;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="975" endline="990">
<![CDATA[
 	
 	static int ComparePropertyInfo (object a, object b)
 	{
 		PropertyInfo aa = (PropertyInfo) a, bb = (PropertyInfo) b;
 		
 		bool astatic = (aa.CanRead ? aa.GetGetMethod (true) 
 		bool bstatic = (bb.CanRead ? bb.GetGetMethod (true) 
 		
 		if (astatic == bstatic)
 			return CompareMemberInfo (a, b);
 		
 		if (astatic)
 			return -1;
 		
 		return 1;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="307" endline="338">
<![CDATA[
 
 		TypeExpr CreateStoreyTypeExpression (EmitContext ec)
 		{
 			//
 			// Create an instance of storey type
 			//
 			TypeExpr storey_type_expr;
 			if (CurrentTypeParameters != null) {
 				//
 				// Use current method type parameter (MVAR) for top level storey only. All
 				// nested storeys use class type parameter (VAR)
 				//
 				TypeParameter[] tparams = ec.CurrentAnonymousMethod != null && ec.CurrentAnonymousMethod.Storey != null ?
 					ec.CurrentAnonymousMethod.Storey.TypeParameters 
 					ec.CurrentTypeParameters;
 
 				TypeArguments targs = new TypeArguments ();
 
 				//
 				// Use type parameter name instead of resolved type parameter
 				// specification to resolve to correctly nested type parameters
 				//
 				for (int i = 0; i < tparams.Length; ++i)
 					targs.Add (new SimpleName (tparams [i].Name, Location)); //  new TypeParameterExpr (tparams[i], Location));
 				for (int i = 0; i < tparams.Length; ++i)
 					targs.Add (new SimpleName (tparams [i].Name, Location)); //  new TypeParameterExpr (tparams[i], Location));
 
 				storey_type_expr = new GenericTypeExpr (Definition, targs, Location);
 			} else {
 				storey_type_expr = new TypeExpression (CurrentType, Location);
 			}
 
 			return storey_type_expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="376" endline="383">
<![CDATA[
 		}
 
 		public override Type[] GetOptionalCustomModifiers()
 		{
 			Type[] modifiers = parameterInfo.GetOptionalCustomModifiers();
 			Type.InplaceBindTypeParameters(method, modifiers);
 			return modifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="384" endline="390">
<![CDATA[
 
 		public override Type[] GetRequiredCustomModifiers()
 		{
 			Type[] modifiers = parameterInfo.GetRequiredCustomModifiers();
 			Type.InplaceBindTypeParameters(method, modifiers);
 			return modifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="331" endline="343">
<![CDATA[
 		}
 
 		public LocalVariableEntry[] Locals {
 			get {
 				if (_locals == null)
 					return new LocalVariableEntry [0];
 				else {
 					LocalVariableEntry[] retval =
 						new LocalVariableEntry [_locals.Count];
 					_locals.CopyTo (retval, 0);
 					return retval;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="189" endline="199">
<![CDATA[
 
 		internal int DefineType (Type type)
 		{
 			int index;
 			if (type_hash.TryGetValue (type, out index))
 				return index;
 
 			index = ++last_type_index;
 			type_hash.Add (type, index);
 			return index;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="434" endline="449">
<![CDATA[
 
 		internal IList<CustomAttributeData> GetDeclarativeSecurity(int metadataToken)
 		{
 			List<CustomAttributeData> list = new List<CustomAttributeData>();
 			// TODO use binary search?
 			for (int i = 0; i < DeclSecurity.records.Length; i++)
 			{
 				if (DeclSecurity.records[i].Parent == metadataToken)
 				{
 					int action = DeclSecurity.records[i].Action;
 					int permissionSet = DeclSecurity.records[i].PermissionSet;
 					CustomAttributeData.ReadDeclarativeSecurity(this.Assembly, list, action, GetBlob(permissionSet));
 				}
 			}
 			for (int i = 0; i < DeclSecurity.records.Length; i++)
 			{
 				if (DeclSecurity.records[i].Parent == metadataToken)
 				{
 					int action = DeclSecurity.records[i].Action;
 					int permissionSet = DeclSecurity.records[i].PermissionSet;
 					CustomAttributeData.ReadDeclarativeSecurity(this.Assembly, list, action, GetBlob(permissionSet));
 				}
 			}
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1375" endline="1393">
<![CDATA[
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (li.IsConstant)
 				return;
 
 			li.CreateBuilder (ec);
 
 			if (Initializer != null)
 				((ExpressionStatement) Initializer).EmitStatement (ec);
 
 			if (declarators != null) {
 				foreach (var d in declarators) {
 					d.Variable.CreateBuilder (ec);
 					if (d.Initializer != null)
 						((ExpressionStatement) d.Initializer).EmitStatement (ec);
 				}
 				foreach (var d in declarators) {
 					d.Variable.CreateBuilder (ec);
 					if (d.Initializer != null)
 						((ExpressionStatement) d.Initializer).EmitStatement (ec);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="409" endline="433">
<![CDATA[
 
 		internal List<CustomAttributeData> GetCustomAttributes(int metadataToken, Type attributeType)
 		{
 			List<CustomAttributeData> list = new List<CustomAttributeData>();
 			// TODO use binary search?
 			for (int i = 0; i < CustomAttribute.records.Length; i++)
 			{
 				if (CustomAttribute.records[i].Parent == metadataToken)
 				{
 					if (attributeType == null)
 					{
 						list.Add(new CustomAttributeData(this, i));
 					}
 					else
 					{
 						ConstructorInfo constructor = (ConstructorInfo)ResolveMethod(CustomAttribute.records[i].Type);
 						if (attributeType.IsAssignableFrom(constructor.DeclaringType))
 						{
 							list.Add(new CustomAttributeData(this.Assembly, constructor, GetBlob(CustomAttribute.records[i].Value)));
 						}
 					}
 				}
 			}
 			for (int i = 0; i < CustomAttribute.records.Length; i++)
 			{
 				if (CustomAttribute.records[i].Parent == metadataToken)
 				{
 					if (attributeType == null)
 					{
 						list.Add(new CustomAttributeData(this, i));
 					}
 					else
 					{
 						ConstructorInfo constructor = (ConstructorInfo)ResolveMethod(CustomAttribute.records[i].Type);
 						if (attributeType.IsAssignableFrom(constructor.DeclaringType))
 						{
 							list.Add(new CustomAttributeData(this.Assembly, constructor, GetBlob(CustomAttribute.records[i].Value)));
 						}
 					}
 				}
 			}
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="116" endline="127">
<![CDATA[
 		}
 
 		#endregion
 
 		public HoistedStoreyClass GetGenericStorey ()
 		{
 			DeclSpace storey = this;
 			while (storey != null && storey.CurrentTypeParameters == null)
 				storey = storey.Parent;
 			while (storey != null && storey.CurrentTypeParameters == null)
 				storey = storey.Parent;
 
 			return storey as HoistedStoreyClass;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1352" endline="1386">
<![CDATA[
 
 		//
 		// Reads assembly attributes which where attached to a special type because
 		// module does have assembly manifest
 		//
 		public List<Attribute> ReadAssemblyAttributes ()
 		{
 			var t = module.GetType (AssemblyAttributesPlaceholder.GetGeneratedName (Name));
 			if (t == null)
 				return null;
 
 			var field = t.GetField (AssemblyAttributesPlaceholder.AssemblyFieldName, BindingFlags.NonPublic | BindingFlags.Static);
 			if (field == null)
 				return null;
 
 			// TODO
 			// add it to OptAttributes before resolving the source code attributes
 			// Need to build module location as well for correct error reporting
 
 			//var assembly_attributes = CustomAttributeData.GetCustomAttributes (field);
 			//var attrs = new List<Attribute> (assembly_attributes.Count);
 			//foreach (var a in assembly_attributes)
 			//{
 			//    var type = metaImporter.ImportType (a.Constructor.DeclaringType);
 			//    var ctor = metaImporter.CreateMethod (a.Constructor, type);
 
 			//    foreach (var carg in a.ConstructorArguments) {
 			//        carg.Value
 			//    }
 
 			//    attrs.Add (new Attribute ("assembly", ctor, null, Location.Null, true));
 			//}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2109" endline="2122">
<![CDATA[
 
 		static bool HasDynamicTypeArgument (TypeSpec[] targs)
 		{
 			for (int i = 0; i < targs.Length; ++i) {
 				var targ = targs [i];
 				if (targ == InternalType.Dynamic)
 					return true;
 
 				if (HasDynamicTypeArgument (targ.TypeArguments))
 					return true;
 			}
 			for (int i = 0; i < targs.Length; ++i) {
 				var targ = targs [i];
 				if (targ == InternalType.Dynamic)
 					return true;
 
 				if (HasDynamicTypeArgument (targ.TypeArguments))
 					return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="760" endline="773">
<![CDATA[
 
 		protected static Type[][] BindTypeParameters(IGenericBinder binder, Type[][] types)
 		{
 			if (types == null)
 			{
 				return null;
 			}
 			Type[][] expanded = new Type[types.Length][];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="774" endline="787">
<![CDATA[
 
 		protected static Type[][][] BindTypeParameters(IGenericBinder binder, Type[][][] types)
 		{
 			if (types == null)
 			{
 				return null;
 			}
 			Type[][][] expanded = new Type[types.Length][][];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = BindTypeParameters(binder, types[i]);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="72" endline="90">
<![CDATA[
 	}
 
 	static class ArrayComparer
 	{
 		public static bool IsEqual<T> (T[] array1, T[] array2)
 		{
 			if (array1 == null || array2 == null)
 				return array1 == array2;
 
 			var eq = EqualityComparer<T>.Default;
 
 			for (int i = 0; i < array1.Length; ++i) {
 				if (!eq.Equals (array1[i], array2[i])) {
 					return false;
 				}
 			}
 			for (int i = 0; i < array1.Length; ++i) {
 				if (!eq.Equals (array1[i], array2[i])) {
 					return false;
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="422" endline="450">
<![CDATA[
 
 		public MethodSpec Mutate (TypeParameterMutator mutator)
 		{
 			var targs = TypeArguments;
 			if (targs != null)
 				targs = mutator.Mutate (targs);
 
 			var decl = DeclaringType;
 			if (DeclaringType.IsGenericOrParentIsGeneric) {
 				decl = mutator.Mutate (decl);
 			}
 
 			if (targs == TypeArguments && decl == DeclaringType)
 				return this;
 
 			var ms = (MethodSpec) MemberwiseClone ();
 			if (decl != DeclaringType) {
 				ms.inflatedMetaInfo = null;
 				ms.declaringType = decl;
 				ms.state |= StateFlags.PendingMetaInflate;
 			}
 
 			if (targs != null) {
 				ms.targs = targs;
 				ms.state |= StateFlags.PendingMakeMethod;
 			}
 
 			return ms;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="84" endline="119">
<![CDATA[
 		{
 			switch (br.ReadByte())
 			{
 				case ELEMENT_TYPE_CLASS
 				case ELEMENT_TYPE_VALUETYPE
 					break;
 				default
 					throw new BadImageFormatException();
 			}
 			Type type = ReadTypeDefOrRefEncoded(module, br, context);
 			if (!type.IsGenericTypeDefinition)
 			{
 				throw new BadImageFormatException();
 			}
 			int genArgCount = br.ReadCompressedInt();
 			Type[] args = new Type[genArgCount];
 			Type[][] reqmod = null;
 			Type[][] optmod = null;
 			for (int i = 0; i < genArgCount; i++)
 			{
 				// LAMESPEC the Type production (23.2.12) doesn't include CustomMod* for genericinst, but C++ uses it, the verifier allows it and ildasm also supports it
 				CustomModifiers mods = ReadCustomModifiers(module, br, context);
 				if (mods.required != null || mods.optional != null)
 				{
 					if (reqmod == null)
 					{
 						reqmod = new Type[genArgCount][];
 						optmod = new Type[genArgCount][];
 					}
 					reqmod[i] = mods.required;
 					optmod[i] = mods.optional;
 				}
 				args[i] = ReadType(module, br, context);
 			}
 			for (int i = 0; i < genArgCount; i++)
 			{
 				// LAMESPEC the Type production (23.2.12) doesn't include CustomMod* for genericinst, but C++ uses it, the verifier allows it and ildasm also supports it
 				CustomModifiers mods = ReadCustomModifiers(module, br, context);
 				if (mods.required != null || mods.optional != null)
 				{
 					if (reqmod == null)
 					{
 						reqmod = new Type[genArgCount][];
 						optmod = new Type[genArgCount][];
 					}
 					reqmod[i] = mods.required;
 					optmod[i] = mods.optional;
 				}
 				args[i] = ReadType(module, br, context);
 			}
 			return GenericTypeInstance.Make(type, args, reqmod, optmod);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1385" endline="1408">
<![CDATA[
 
 		protected virtual bool DoResolveTypeParameters ()
 		{
 			if (CurrentTypeParameters == null)
 				return true;
 
 			if (PartialContainer != this)
 				throw new InternalErrorException ();
 
 			var base_context = new BaseContext (this);
 			foreach (TypeParameter type_param in CurrentTypeParameters) {
 				if (!type_param.ResolveConstraints (base_context)) {
 					error = true;
 					return false;
 				}
 			}
 			foreach (TypeParameter type_param in CurrentTypeParameters) {
 				if (!type_param.ResolveConstraints (base_context)) {
 					error = true;
 					return false;
 				}
 			}
 
 			if (partial_parts != null) {
 				foreach (TypeContainer part in partial_parts)
 					UpdateTypeParameterConstraints (part);
 				foreach (TypeContainer part in partial_parts)
 					UpdateTypeParameterConstraints (part);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="543" endline="553">
<![CDATA[
 
 		public SourceFileEntry[] Sources {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				SourceFileEntry[] retval = new SourceFileEntry [SourceCount];
 				for (int i = 0; i < SourceCount; i++)
 					retval [i] = GetSourceFile (i + 1);
 				for (int i = 0; i < SourceCount; i++)
 					retval [i] = GetSourceFile (i + 1);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="579" endline="589">
<![CDATA[
 
 		public CompileUnitEntry[] CompileUnits {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				CompileUnitEntry[] retval = new CompileUnitEntry [CompileUnitCount];
 				for (int i = 0; i < CompileUnitCount; i++)
 					retval [i] = GetCompileUnit (i + 1);
 				for (int i = 0; i < CompileUnitCount; i++)
 					retval [i] = GetCompileUnit (i + 1);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="210" endline="223">
<![CDATA[
 
 		public override Module LoadModule(string moduleName, byte[] rawModule)
 		{
 			int index = GetModuleIndex(moduleName);
 			if (index == -1)
 			{
 				throw new ArgumentException();
 			}
 			if (externalModules[index] != null)
 			{
 				return externalModules[index];
 			}
 			return LoadModule(index, rawModule, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="746" endline="759">
<![CDATA[
 
 		protected static Type[] BindTypeParameters(IGenericBinder binder, Type[] types)
 		{
 			if (types == null || types.Length == 0)
 			{
 				return Type.EmptyTypes;
 			}
 			Type[] expanded = new Type[types.Length];
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = types[i].BindTypeParameters(binder);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				expanded[i] = types[i].BindTypeParameters(binder);
 			}
 			return expanded;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="103" endline="115">
<![CDATA[
 
 		internal override Type GetTypeImpl(string typeName)
 		{
 			Type type = manifestModule.GetType(typeName);
 			for (int i = 0; type == null && i < externalModules.Length; i++)
 			{
 				if ((manifestModule.File.records[i].Flags & ContainsNoMetaData) == 0)
 				{
 					type = GetModule(i).GetType(typeName);
 				}
 			}
 			for (int i = 0; type == null && i < externalModules.Length; i++)
 			{
 				if ((manifestModule.File.records[i].Flags & ContainsNoMetaData) == 0)
 				{
 					type = GetModule(i).GetType(typeName);
 				}
 			}
 			return type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="271" endline="290">
<![CDATA[
 
 		internal string GetString(int index)
 		{
 			if (index == 0)
 			{
 				return null;
 			}
 			string str;
 			if (!strings.TryGetValue(index, out str))
 			{
 				int len = 0;
 				while (stringHeap[index + len] != 0)
 				{
 					len++;
 				}
 				while (stringHeap[index + len] != 0)
 				{
 					len++;
 				}
 				str = Encoding.UTF8.GetString(stringHeap, index, len);
 				strings.Add(index, str);
 			}
 			return str;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1032" endline="1060">
<![CDATA[
 
 		//
 		// Returns a list of missing dependencies of this member. The list
 		// will contain types only but it can have numerous values for members
 		// like methods where both return type and all parameters are checked
 		//
 		public List<MissingType> GetMissingDependencies ()
 		{
 			if ((state & (StateFlags.MissingDependency | StateFlags.MissingDependency_Undetected)) == 0)
 				return null;
 
 			state &= ~StateFlags.MissingDependency_Undetected;
 
 			var imported = definition as ImportedDefinition;
 			List<MissingType> missing;
 			if (imported != null) {
 				missing = imported.ResolveMissingDependencies ();
 			} else if (this is ElementTypeSpec) {
 				missing = ((ElementTypeSpec) this).Element.GetMissingDependencies ();
 			} else {
 				missing = null;
 			}
 
 			if (missing != null) {
 				state |= StateFlags.MissingDependency;
 			}
 
 			return missing;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="808" endline="831">
<![CDATA[
 
 		//
 		// Finds effective base class
 		//
 		public TypeSpec GetEffectiveBase ()
 		{
 			if (HasSpecialStruct) {
 				return TypeManager.value_type;
 			}
 
 			if (BaseType != null && targs == null)
 				return BaseType;
 
 			var types = targs;
 			if (HasTypeConstraint) {
 				Array.Resize (ref types, types.Length + 1);
 				types[types.Length - 1] = BaseType;
 			}
 
 			if (types != null)
 				return Convert.FindMostEncompassedType (types.Select (l => l.BaseType));
 
 			return TypeManager.object_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="450" endline="492">
<![CDATA[
 
 		/// <summary>
 		///   Resolves an expression for LValue assignment
 		/// </summary>
 		///
 		/// <remarks>
 		///   Currently ResolveLValue wraps DoResolveLValue to perform sanity
 		///   checking and assertion checking on what we expect from Resolve
 		/// </remarks>
 		public Expression ResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			int errors = ec.Report.Errors;
 			bool out_access = right_side == EmptyExpression.OutAccess.Instance;
 
 			Expression e = DoResolveLValue (ec, right_side);
 
 			if (e != null && out_access && !(e is IMemoryLocation)) {
 				// FIXME
 				//        Enabling this 'throw' will "only" result in deleting useless code elsewhere,
 
 				//throw new InternalErrorException ("ResolveLValue didn't return an IMemoryLocation
 				//				  e.GetType () + " " + e.GetSignatureForError ());
 				e = null;
 			}
 
 			if (e == null) {
 				if (errors == ec.Report.Errors) {
 					if (out_access)
 						ec.Report.Error (1510, loc, "A ref or out argument must be an assignable variable");
 					else
 						Error_ValueAssignment (ec, loc);
 				}
 				return null;
 			}
 
 			if (e.eclass == ExprClass.Unresolved)
 				throw new Exception ("Expression " + e + " ExprClass is Invalid after resolve");
 
 			if ((e.type == null) && !(e is GenericTypeExpr))
 				throw new Exception ("Expression " + e + " did not set its type after Resolve");
 
 			return e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="623" endline="634">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			if (arg_idx <= 255)
 				ec.Emit (OpCodes.Starg_S, (byte) arg_idx);
 			else
 				ec.Emit (OpCodes.Starg, arg_idx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="175" endline="199">
<![CDATA[
 
 		public void SymbolRelatedToPreviousError (MemberSpec ms)
 		{
 			if (reporting_disabled > 0 || !printer.HasRelatedSymbolSupport)
 				return;
 
 			var mc = ms.MemberDefinition as MemberCore;
 			while (ms is ElementTypeSpec) {
 				ms = ((ElementTypeSpec) ms).Element;
 				mc = ms.MemberDefinition as MemberCore;
 			}
 			while (ms is ElementTypeSpec) {
 				ms = ((ElementTypeSpec) ms).Element;
 				mc = ms.MemberDefinition as MemberCore;
 			}
 
 			if (mc != null) {
 				SymbolRelatedToPreviousError (mc);
 			} else {
 				if (ms.DeclaringType != null)
 					ms = ms.DeclaringType;
 
 				var imported_type = ms.MemberDefinition as ImportedTypeDefinition;
 				if (imported_type != null) {
 					var iad = imported_type.DeclaringAssembly as ImportedAssemblyDefinition;
 					SymbolRelatedToPreviousError (iad.Location);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="137" endline="151">
<![CDATA[
 
 		public bool IsConditionalDefined (string value)
 		{
 			if (conditionals != null) {
 				bool res;
 				if (conditionals.TryGetValue (value, out res))
 					return res;
 				
 				// When conditional was undefined
 				if (conditionals.ContainsKey (value))
 					return false;					
 			}
 
 			return RootContext.IsConditionalDefined (value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1206" endline="1225">
<![CDATA[
 
 		public LineNumberTable GetLineNumberTable ()
 		{
 			lock (SymbolFile) {
 				if (lnt != null)
 					return lnt;
 
 				if (LineNumberTableOffset == 0)
 					return null;
 
 				MyBinaryReader reader = SymbolFile.BinaryReader;
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = LineNumberTableOffset;
 
 				lnt = LineNumberTable.Read (SymbolFile, reader);
 
 				reader.BaseStream.Position = old_pos;
 				return lnt;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1394" endline="1410">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement target)
 		{
 			BlockVariableDeclaration t = (BlockVariableDeclaration) target;
 
 			if (type_expr != null)
 				t.type_expr = (FullNamedExpression) type_expr.Clone (clonectx);
 
 			if (initializer != null)
 				t.initializer = initializer.Clone (clonectx);
 
 			if (declarators != null) {
 				t.declarators = null;
 				foreach (var d in declarators)
 					t.AddDeclarator (new Declarator (d, d.Initializer == null ? null 
 				foreach (var d in declarators)
 					t.AddDeclarator (new Declarator (d, d.Initializer == null ? null 
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1155" endline="1171">
<![CDATA[
 
 		public bool IsConditionallyExcluded (Location loc)
 		{
 			if ((Kind & (MemberKind.Class | MemberKind.Method)) == 0)
 				return false;
 
 			var conditions = MemberDefinition.ConditionalConditions ();
 			if (conditions == null)
 				return false;
 
 			foreach (var condition in conditions) {
 				if (loc.CompilationUnit.IsConditionalDefined (condition))
 					return false;
 			}
 			foreach (var condition in conditions) {
 				if (loc.CompilationUnit.IsConditionalDefined (condition))
 					return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6250" endline="6281">
<![CDATA[
 
 		//
 		// Resolved the type of the array
 		//
 		bool ResolveArrayType (ResolveContext ec)
 		{
 			//
 			// Lookup the type
 			//
 			FullNamedExpression array_type_expr;
 			if (num_arguments > 0) {
 				array_type_expr = new ComposedCast (requested_base_type, rank);
 			} else {
 				array_type_expr = requested_base_type;
 			}
 
 			array_type_expr = array_type_expr.ResolveAsTypeTerminal (ec, false);
 			if (array_type_expr == null)
 				return false;
 
 			type = array_type_expr.Type;
 			var ac = type as ArrayContainer;
 			if (ac == null) {
 				ec.Report.Error (622, loc, "Can only use array initializer expressions to assign to array types. Try using a new expression instead");
 				return false;
 			}
 
 			array_element_type = ac.Element;
 			dimensions = ac.Rank;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="143" endline="165">
<![CDATA[
 
 		internal ResourceDirectoryEntry this[OrdinalOrName id]
 		{
 			get
 			{
 				foreach (ResourceDirectoryEntry entry in entries)
 				{
 					if (entry.OrdinalOrName.Ordinal == id.Ordinal && entry.OrdinalOrName.Name == id.Name)
 					{
 						return entry;
 					}
 				}
 				foreach (ResourceDirectoryEntry entry in entries)
 				{
 					if (entry.OrdinalOrName.Ordinal == id.Ordinal && entry.OrdinalOrName.Name == id.Name)
 					{
 						return entry;
 					}
 				}
 				ResourceDirectoryEntry newEntry = new ResourceDirectoryEntry(id);
 				if (id.Name == null)
 				{
 					entries.Add(newEntry);
 				}
 				else
 				{
 					entries.Insert(namedEntries++, newEntry);
 				}
 				return newEntry;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1940" endline="1973">
<![CDATA[
 
 		//
 		// Emits the code
 		// 
 		public void Emit (DeclSpace parent)
 		{
 			if (GenericMethod != null)
 				GenericMethod.EmitAttributes ();
 
 			var mc = (IMemberContext) method;
 
 			method.ParameterInfo.ApplyAttributes (mc, MethodBuilder);
 
 			SourceMethod source = SourceMethod.Create (parent, MethodBuilder, method.Block);
 
 			ToplevelBlock block = method.Block;
 			if (block != null) {
 				BlockContext bc = new BlockContext (mc, block, method.ReturnType);
 				if (block.Resolve (null, bc, method)) {
 					EmitContext ec = method.CreateEmitContext (MethodBuilder.GetILGenerator ());
 					if (!ec.HasReturnLabel && bc.HasReturnLabel) {
 						ec.ReturnLabel = bc.ReturnLabel;
 						ec.HasReturnLabel = true;
 					}
 
 					block.Emit (ec);
 				}
 			}
 
 			if (source != null) {
 				method.EmitExtraSymbolInfo (source);
 				source.CloseMethod ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="958" endline="992">
<![CDATA[
 
 		//
 		// Infers type arguments based on explicit arguments
 		//
 		public bool ExplicitTypeInference (ResolveContext ec, TypeInferenceContext type_inference, TypeSpec delegate_type)
 		{
 			if (!HasExplicitParameters)
 				return false;
 
 			if (!delegate_type.IsDelegate) {
 				if (delegate_type.GetDefinition () != TypeManager.expression_type)
 					return false;
 
 				delegate_type = TypeManager.GetTypeArguments (delegate_type) [0];
 				if (!delegate_type.IsDelegate)
 					return false;
 			}
 			
 			AParametersCollection d_params = Delegate.GetParameters (ec.Compiler, delegate_type);
 			if (d_params.Count != Parameters.Count)
 				return false;
 
 			for (int i = 0; i < Parameters.Count; ++i) {
 				TypeSpec itype = d_params.Types [i];
 				if (!TypeManager.IsGenericParameter (itype)) {
 					if (!TypeManager.HasElementType (itype))
 						continue;
 					
 					if (!TypeManager.IsGenericParameter (TypeManager.GetElementType (itype)))
 					    continue;
 				}
 				type_inference.ExactInference (Parameters.Types [i], itype);
 			}
 			for (int i = 0; i < Parameters.Count; ++i) {
 				TypeSpec itype = d_params.Types [i];
 				if (!TypeManager.IsGenericParameter (itype)) {
 					if (!TypeManager.HasElementType (itype))
 						continue;
 					
 					if (!TypeManager.IsGenericParameter (TypeManager.GetElementType (itype)))
 					    continue;
 				}
 				type_inference.ExactInference (Parameters.Types [i], itype);
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="312" endline="319">
<![CDATA[
 
 		internal byte[] GetBlobCopy(int blobIndex)
 		{
 			int len = ReadCompressedInt(blobHeap, ref blobIndex);
 			byte[] buf = new byte[len];
 			Buffer.BlockCopy(blobHeap, blobIndex, buf, 0, len);
 			return buf;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7037" endline="7048">
<![CDATA[
 
 		public MetaType[] ArgumentTypes {
 		    get {
 				if (Arguments == null)
 					return MetaType.EmptyTypes;
 
 				var retval = new MetaType[Arguments.Count];
 		        for (int i = 0; i < retval.Length; i++)
 					retval[i] = Arguments[i].Expr.Type.GetMetaInfo ();
 		        for (int i = 0; i < retval.Length; i++)
 					retval[i] = Arguments[i].Expr.Type.GetMetaInfo ();
 
 		        return retval;
 		    }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="882" endline="908">
<![CDATA[
 
 		internal void ExportTypes(Type[] types, int fileToken)
 		{
 			Dictionary<Type, int> declaringTypes = new Dictionary<Type, int>();
 			foreach (Type type in types)
 			{
 				if (!type.IsModulePseudoType && IsVisible(type))
 				{
 					ExportedTypeTable.Record rec = new ExportedTypeTable.Record();
 					rec.Flags = (int)type.Attributes;
 					rec.TypeDefId = type.MetadataToken & 0xFFFFFF;
 					rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 					string ns = type.Namespace;
 					rec.TypeNamespace = ns == null ? 0 
 					if (type.IsNested)
 					{
 						rec.Implementation = declaringTypes[type.DeclaringType];
 					}
 					else
 					{
 						rec.Implementation = fileToken;
 					}
 					int exportTypeToken = 0x27000000 | this.ExportedType.AddRecord(rec);
 					declaringTypes.Add(type, exportTypeToken);
 				}
 			}
 			foreach (Type type in types)
 			{
 				if (!type.IsModulePseudoType && IsVisible(type))
 				{
 					ExportedTypeTable.Record rec = new ExportedTypeTable.Record();
 					rec.Flags = (int)type.Attributes;
 					rec.TypeDefId = type.MetadataToken & 0xFFFFFF;
 					rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 					string ns = type.Namespace;
 					rec.TypeNamespace = ns == null ? 0 
 					if (type.IsNested)
 					{
 						rec.Implementation = declaringTypes[type.DeclaringType];
 					}
 					else
 					{
 						rec.Implementation = fileToken;
 					}
 					int exportTypeToken = 0x27000000 | this.ExportedType.AddRecord(rec);
 					declaringTypes.Add(type, exportTypeToken);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="183" endline="219">
<![CDATA[
 
 		public static Expression ImplicitReferenceConversion (Expression expr, TypeSpec target_type, bool explicit_cast)
 		{
 			TypeSpec expr_type = expr.Type;
 
 			if (expr_type == null && expr.eclass == ExprClass.MethodGroup){
 				// if we are a method group, emit a warning
 
 				expr.Emit (null);
 			}
 
 			if (expr_type == TypeManager.void_type)
 				return null;
 
 			if (expr_type.Kind == MemberKind.TypeParameter)
 				return ImplicitTypeParameterConversion (expr, target_type);
 
 			//
 			// from the null type to any reference-type.
 			//
 			NullLiteral nl = expr as NullLiteral;
 			if (nl != null) {
 				return nl.ConvertImplicitly (null, target_type);
 			}
 
 			if (ImplicitReferenceConversionExists (expr, target_type)) {
 				// 
 				// Avoid wrapping implicitly convertible reference type
 				//
 				if (!explicit_cast)
 					return expr;
 
 				return EmptyCast.Create (expr, target_type);
 			}
 
 			return ImplicitBoxingConversion (expr, expr_type, target_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="78" endline="117">
<![CDATA[
 
 		// MemberCore
 		private static readonly string line_head =
 			Environment.NewLine + "            ";
 
 		private static XmlNode GetDocCommentNode (MemberCore mc,
 			string name, Report Report)
 		{
 			// FIXME
 			// to use XmlDocument. But anyways the nodes
 			// are not kept in memory.
 			XmlDocument doc = RootContext.Documentation.XmlDocumentation;
 			try {
 				XmlElement el = doc.CreateElement ("member");
 				el.SetAttribute ("name", name);
 				string normalized = mc.DocComment;
 				el.InnerXml = normalized;
 				// csc keeps lines as written in the sources
 				// and inserts formatting indentation (which 
 				// is different from XmlTextWriter.Formatting
 				// one), but when a start tag contains an 
 				// endline, it joins the next line. We don't
 				// have to follow such a hacky behavior.
 				string [] split =
 					normalized.Split ('\n');
 				int j = 0;
 				for (int i = 0; i < split.Length; i++) {
 					string s = split [i].TrimEnd ();
 					if (s.Length > 0)
 						split [j++] = s;
 				}
 				for (int i = 0; i < split.Length; i++) {
 					string s = split [i].TrimEnd ();
 					if (s.Length > 0)
 						split [j++] = s;
 				}
 				el.InnerXml = line_head + String.Join (
 					line_head, split, 0, j);
 				return el;
 			} catch (Exception ex) {
 				Report.Warning (1570, 1, mc.Location, "XML comment on `{0}' has non-well-formed XML ({1})", name, ex.Message);
 				XmlComment com = doc.CreateComment (String.Format ("FIXME
 				return com;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="657" endline="663">
<![CDATA[
 
 	string GetTypeName (Type t)
 	{
 		StringBuilder sb = new StringBuilder ();
 		GetTypeName (sb, t);
 		return sb.ToString ();
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="134" endline="149">
<![CDATA[
 
 		internal static int GetCompressedIntLength(int value)
 		{
 			if (value <= 0x7F)
 			{
 				return 1;
 			}
 			else if (value <= 0x3FFF)
 			{
 				return 2;
 			}
 			else
 			{
 				return 4;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="367" endline="375">
<![CDATA[
 
 		public Arguments Clone (CloneContext ctx)
 		{
 			Arguments cloned = new Arguments (args.Count);
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 			foreach (Argument a in args)
 				cloned.Add (a.Clone (ctx));
 
 			return cloned;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="668" endline="676">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement target)
 		{
 			StatementList t = (StatementList) target;
 
 			t.statements = new List<Statement> (statements.Count);
 			foreach (Statement s in statements)
 				t.statements.Add (s.Clone (clonectx));
 			foreach (Statement s in statements)
 				t.statements.Add (s.Clone (clonectx));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5952" endline="5961">
<![CDATA[
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			var target = (ArrayInitializer) t;
 
 			target.elements = new List<Expression> (elements.Count);
 			foreach (var element in elements)
 				target.elements.Add (element.Clone (clonectx));
 			foreach (var element in elements)
 				target.elements.Add (element.Clone (clonectx));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2125" endline="2144">
<![CDATA[
 		}
 
 		public override Type BaseType
 		{
 			get
 			{
 				if (baseType == null)
 				{
 					Type rawBaseType = type.BaseType;
 					if (rawBaseType == null)
 					{
 						baseType = rawBaseType;
 					}
 					else
 					{
 						baseType = rawBaseType.BindTypeParameters(this);
 					}
 				}
 				return baseType;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4841" endline="4856">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Expression instance;
 			if (InstanceExpression == null) {
 				instance = new NullLiteral (loc);
 			} else {
 				instance = InstanceExpression.CreateExpressionTree (ec);
 			}
 
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				instance,
 				CreateTypeOfExpression ());
 
 			return CreateExpressionFactoryCall (ec, "Field", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="200" endline="235">
<![CDATA[
 
 		private void SetMethodImplAttribute(CustomAttributeBuilder customBuilder)
 		{
 			MethodImplOptions opt;
 			switch (customBuilder.Constructor.ParameterCount)
 			{
 				case 0
 					opt = 0;
 					break;
 				case 1
 					{
 						object val = customBuilder.GetConstructorArgument(0);
 						if (val is short)
 						{
 							opt = (MethodImplOptions)(short)val;
 						}
 						else if (val is int)
 						{
 							opt = (MethodImplOptions)(int)val;
 						}
 						else
 						{
 							opt = (MethodImplOptions)val;
 						}
 						break;
 					}
 				default
 					throw new NotSupportedException();
 			}
 			MethodCodeType? type = customBuilder.GetFieldValue<MethodCodeType>("MethodCodeType");
 			implFlags = (MethodImplAttributes)opt;
 			if (type.HasValue)
 			{
 				implFlags |= (MethodImplAttributes)type;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="1070" endline="1093">
<![CDATA[
 
 		Namespace [] GetUsingTable ()
 		{
 			if (namespace_using_table != null)
 				return namespace_using_table;
 
 			if (using_clauses == null) {
 				namespace_using_table = empty_namespaces;
 				return namespace_using_table;
 			}
 
 			var list = new List<Namespace> (using_clauses.Count);
 
 			foreach (UsingEntry ue in using_clauses) {
 				Namespace using_ns = ue.Resolve (Doppelganger);
 				if (using_ns == null)
 					continue;
 
 				list.Add (using_ns);
 			}
 			foreach (UsingEntry ue in using_clauses) {
 				Namespace using_ns = ue.Resolve (Doppelganger);
 				if (using_ns == null)
 					continue;
 
 				list.Add (using_ns);
 			}
 
 			namespace_using_table = list.ToArray ();
 			return namespace_using_table;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="866" endline="887">
<![CDATA[
 
 	static Type [] TypeGetInterfaces (Type t, bool declonly)
 	{
 		if (t.IsGenericParameter)
 			return new Type [0];
 
 		Type [] ifaces = t.GetInterfaces ();
 		if (! declonly)
 			return ifaces;
 
 		// Handle Object. Also, optimize for no interfaces
 		if (t.BaseType == null || ifaces.Length == 0)
 			return ifaces;
 
 		ArrayList ar = new ArrayList ();
 
 		foreach (Type i in ifaces)
 			if (! i.IsAssignableFrom (t.BaseType))
 				ar.Add (i);
 		foreach (Type i in ifaces)
 			if (! i.IsAssignableFrom (t.BaseType))
 				ar.Add (i);
 
 		return (Type []) ar.ToArray (typeof (Type));
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1619" endline="1648">
<![CDATA[
 
 		public override TypeSpec Mutate (TypeParameterMutator mutator)
 		{
 			var targs = TypeArguments;
 			if (targs != null)
 				targs = mutator.Mutate (targs);
 
 			var decl = DeclaringType;
 			if (IsNested && DeclaringType.IsGenericOrParentIsGeneric)
 				decl = mutator.Mutate (decl);
 
 			if (targs == TypeArguments && decl == DeclaringType)
 				return this;
 
 			var mutated = (InflatedTypeSpec) MemberwiseClone ();
 			if (decl != DeclaringType) {
 				// Gets back MethodInfo in case of metaInfo was inflated
 				//mutated.info = MemberCache.GetMember<TypeSpec> (DeclaringType.GetDefinition (), this).info;
 
 				mutated.declaringType = decl;
 				mutated.state |= StateFlags.PendingMetaInflate;
 			}
 
 			if (targs != null) {
 				mutated.targs = targs;
 				mutated.info = null;
 			}
 
 			return mutated;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="675" endline="710">
<![CDATA[
 
 		//
 		// Perform user-operator overload resolution
 		//
 		protected virtual Expression ResolveUserOperator (ResolveContext ec, Expression expr)
 		{
 			CSharp.Operator.OpType op_type;
 			switch (Oper) {
 			case Operator.LogicalNot
 				op_type = CSharp.Operator.OpType.LogicalNot; break;
 			case Operator.OnesComplement
 				op_type = CSharp.Operator.OpType.OnesComplement; break;
 			case Operator.UnaryNegation
 				op_type = CSharp.Operator.OpType.UnaryNegation; break;
 			case Operator.UnaryPlus
 				op_type = CSharp.Operator.OpType.UnaryPlus; break;
 			default
 				throw new InternalErrorException (Oper.ToString ());
 			}
 
 			var methods = MemberCache.GetUserOperator (expr.Type, op_type, false);
 			if (methods == null)
 				return null;
 
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (expr));
 
 			var res = new OverloadResolver (methods, OverloadResolver.Restrictions.BaseMembersIncluded | OverloadResolver.Restrictions.NoBaseMembers, loc);
 			var oper = res.ResolveOperator (ec, ref args);
 
 			if (oper == null)
 				return null;
 
 			Expr = args [0].Expr;
 			return new UserOperatorCall (oper, args, CreateExpressionTree, expr.Location);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="460" endline="487">
<![CDATA[
 
 		private static void WriteGenericSignature(ModuleBuilder module, ByteBuffer bb, Type type)
 		{
 			Type[] typeArguments = type.GetGenericArguments();
 			Type[][] requiredCustomModifiers = type.__GetGenericArgumentsRequiredCustomModifiers();
 			Type[][] optionalCustomModifiers = type.__GetGenericArgumentsOptionalCustomModifiers();
 			if (!type.IsGenericTypeDefinition)
 			{
 				type = type.GetGenericTypeDefinition();
 			}
 			bb.Write(ELEMENT_TYPE_GENERICINST);
 			if (type.IsValueType)
 			{
 				bb.Write(ELEMENT_TYPE_VALUETYPE);
 			}
 			else
 			{
 				bb.Write(ELEMENT_TYPE_CLASS);
 			}
 			bb.WriteTypeDefOrRefEncoded(module.GetTypeToken(type).Token);
 			bb.WriteCompressedInt(typeArguments.Length);
 			for (int i = 0; i < typeArguments.Length; i++)
 			{
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers[i]);
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers[i]);
 				WriteType(module, bb, typeArguments[i]);
 			}
 			for (int i = 0; i < typeArguments.Length; i++)
 			{
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers[i]);
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers[i]);
 				WriteType(module, bb, typeArguments[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="363" endline="395">
<![CDATA[
 
 		internal void AddDeclarativeSecurity(int token, List<CustomAttributeBuilder> declarativeSecurity)
 		{
 			Dictionary<int, List<CustomAttributeBuilder>> ordered = new Dictionary<int, List<CustomAttributeBuilder>>();
 			foreach (CustomAttributeBuilder cab in declarativeSecurity)
 			{
 				int action;
 				// check for HostProtectionAttribute without SecurityAction
 				if (cab.ConstructorArgumentCount == 0)
 				{
 					action = (int)System.Security.Permissions.SecurityAction.LinkDemand;
 				}
 				else
 				{
 					action = (int)cab.GetConstructorArgument(0);
 				}
 				List<CustomAttributeBuilder> list;
 				if (!ordered.TryGetValue(action, out list))
 				{
 					list = new List<CustomAttributeBuilder>();
 					ordered.Add(action, list);
 				}
 				list.Add(cab);
 			}
 			foreach (CustomAttributeBuilder cab in declarativeSecurity)
 			{
 				int action;
 				// check for HostProtectionAttribute without SecurityAction
 				if (cab.ConstructorArgumentCount == 0)
 				{
 					action = (int)System.Security.Permissions.SecurityAction.LinkDemand;
 				}
 				else
 				{
 					action = (int)cab.GetConstructorArgument(0);
 				}
 				List<CustomAttributeBuilder> list;
 				if (!ordered.TryGetValue(action, out list))
 				{
 					list = new List<CustomAttributeBuilder>();
 					ordered.Add(action, list);
 				}
 				list.Add(cab);
 			}
 			foreach (KeyValuePair<int, List<CustomAttributeBuilder>> kv in ordered)
 			{
 				DeclSecurityTable.Record rec = new DeclSecurityTable.Record();
 				rec.Action = (short)kv.Key;
 				rec.Parent = token;
 				rec.PermissionSet = WriteDeclSecurityBlob(kv.Value);
 				this.DeclSecurity.AddRecord(rec);
 			}
 			foreach (KeyValuePair<int, List<CustomAttributeBuilder>> kv in ordered)
 			{
 				DeclSecurityTable.Record rec = new DeclSecurityTable.Record();
 				rec.Action = (short)kv.Key;
 				rec.Parent = token;
 				rec.PermissionSet = WriteDeclSecurityBlob(kv.Value);
 				this.DeclSecurity.AddRecord(rec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="483" endline="514">
<![CDATA[
 
 		//
 		// Looks for extension methods with defined name and extension type
 		//
 		public List<MethodSpec> FindExtensionMethods (TypeContainer invocationType, TypeSpec extensionType, string name, int arity)
 		{
 			IList<MemberSpec> entries;
 			if (!member_hash.TryGetValue (name, out entries))
 				return null;
 
 			List<MethodSpec> candidates = null;
 			foreach (var entry in entries) {
 				if (entry.Kind != MemberKind.Method || (arity > 0 && entry.Arity != arity))
 					continue;
 
 				var ms = (MethodSpec) entry;
 				if (!ms.IsExtensionMethod)
 					continue;
 
 				if (!ms.IsAccessible (invocationType.CurrentType))
 					continue;
 
 				if ((ms.DeclaringType.Modifiers & Modifiers.INTERNAL) != 0 && !ms.DeclaringType.MemberDefinition.IsInternalAsPublic (invocationType.DeclaringAssembly))
 					continue;
 
 				if (candidates == null)
 					candidates = new List<MethodSpec> ();
 				candidates.Add (ms);
 			}
 			foreach (var entry in entries) {
 				if (entry.Kind != MemberKind.Method || (arity > 0 && entry.Arity != arity))
 					continue;
 
 				var ms = (MethodSpec) entry;
 				if (!ms.IsExtensionMethod)
 					continue;
 
 				if (!ms.IsAccessible (invocationType.CurrentType))
 					continue;
 
 				if ((ms.DeclaringType.Modifiers & Modifiers.INTERNAL) != 0 && !ms.DeclaringType.MemberDefinition.IsInternalAsPublic (invocationType.DeclaringAssembly))
 					continue;
 
 				if (candidates == null)
 					candidates = new List<MethodSpec> ();
 				candidates.Add (ms);
 			}
 
 			return candidates;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1354" endline="1366">
<![CDATA[
 	}
 
 	sealed class StandAloneSigTable 
 	{
 		internal const int Index = 0x11;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1746" endline="1758">
<![CDATA[
 	}
 
 	sealed class ModuleRefTable 
 	{
 		internal const int Index = 0x1A;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1786" endline="1798">
<![CDATA[
 	}
 
 	sealed class TypeSpecTable 
 	{
 		internal const int Index = 0x1B;
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i] = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="985" endline="997">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = try_vector.Clone ();
 
 			if (finally_vector != null)
 				vector.MergeChild (finally_vector, false);
 
 			for (SavedOrigin origin = saved_origins; origin != null; origin = origin.Next)
 				origin.PropagateFinally (finally_vector, Parent);
 			for (SavedOrigin origin = saved_origins; origin != null; origin = origin.Next)
 				origin.PropagateFinally (finally_vector, Parent);
 
 			return vector;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="175" endline="186">
<![CDATA[
 
 		private int GetModuleIndex(string name)
 		{
 			for (int i = 0; i < manifestModule.File.records.Length; i++)
 			{
 				if (name.Equals(manifestModule.GetString(manifestModule.File.records[i].Name), StringComparison.InvariantCultureIgnoreCase))
 				{
 					return i;
 				}
 			}
 			for (int i = 0; i < manifestModule.File.records.Length; i++)
 			{
 				if (name.Equals(manifestModule.GetString(manifestModule.File.records[i].Name), StringComparison.InvariantCultureIgnoreCase))
 				{
 					return i;
 				}
 			}
 			return -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="718" endline="728">
<![CDATA[
 
 		public Assembly[] GetAssemblies()
 		{
 			Assembly[] array = new Assembly[assemblies.Count + dynamicAssemblies.Count];
 			assemblies.CopyTo(array);
 			for (int i = 0, j = assemblies.Count; j < array.Length; i++, j++)
 			{
 				array[j] = dynamicAssemblies[i];
 			}
 			for (int i = 0, j = assemblies.Count; j < array.Length; i++, j++)
 			{
 				array[j] = dynamicAssemblies[i];
 			}
 			return array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="175" endline="197">
<![CDATA[
 
 		private void PopulateGenericArguments()
 		{
 			if (typeArgs == null)
 			{
 				int token = this.MetadataToken;
 				int first = module.GenericParam.FindFirstByOwner(token);
 				if (first == -1)
 				{
 					typeArgs = Type.EmptyTypes;
 				}
 				else
 				{
 					List<Type> list = new List<Type>();
 					int len = module.GenericParam.records.Length;
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					typeArgs = list.ToArray();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="220" endline="242">
<![CDATA[
 
 		private void PopulateGenericArguments()
 		{
 			if (typeArgs == null)
 			{
 				int token = this.MetadataToken;
 				int first = module.GenericParam.FindFirstByOwner(token);
 				if (first == -1)
 				{
 					typeArgs = Type.EmptyTypes;
 				}
 				else
 				{
 					List<Type> list = new List<Type>();
 					int len = module.GenericParam.records.Length;
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					for (int i = first; i < len && module.GenericParam.records[i].Owner == token; i++)
 					{
 						list.Add(new GenericTypeParameter(module, i));
 					}
 					typeArgs = list.ToArray();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="866" endline="910">
<![CDATA[
 
 		//
 		// Finds the most specific source Sx according to the rules of the spec (13.4.4)
 		// by making use of FindMostEncomp* methods. Applies the correct rules separately
 		// for explicit and implicit conversion operators.
 		//
 		static TypeSpec FindMostSpecificSource (List<MethodSpec> list, TypeSpec sourceType, Expression source, bool apply_explicit_conv_rules)
 		{
 			var src_types_set = new TypeSpec [list.Count];
 
 			//
 			// Try exact match first, if any operator converts from S then Sx = S
 			//
 			for (int i = 0; i < src_types_set.Length; ++i) {
 				TypeSpec param_type = list [i].Parameters.Types [0];
 
 				if (param_type == sourceType)
 					return param_type;
 
 				src_types_set [i] = param_type;
 			}
 			for (int i = 0; i < src_types_set.Length; ++i) {
 				TypeSpec param_type = list [i].Parameters.Types [0];
 
 				if (param_type == sourceType)
 					return param_type;
 
 				src_types_set [i] = param_type;
 			}
 
 			//
 			// Explicit Conv rules
 			//
 			if (apply_explicit_conv_rules) {
 				var candidate_set = new List<TypeSpec> ();
 
 				foreach (TypeSpec param_type in src_types_set){
 					if (ImplicitStandardConversionExists (source, param_type))
 						candidate_set.Add (param_type);
 				}
 				foreach (TypeSpec param_type in src_types_set){
 					if (ImplicitStandardConversionExists (source, param_type))
 						candidate_set.Add (param_type);
 				}
 
 				if (candidate_set.Count != 0)
 					return FindMostEncompassedType (candidate_set);
 			}
 
 			//
 			// Final case
 			//
 			if (apply_explicit_conv_rules)
 				return FindMostEncompassingType (src_types_set);
 			else
 				return FindMostEncompassedType (src_types_set);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="348" endline="379">
<![CDATA[
 
 		protected override bool DoResolveTypeParameters ()
 		{
 			// Although any storey can have type parameters they are all clones of method type
 			// parameters therefore have to mutate MVAR references in any of cloned constraints
 			if (type_params != null) {
 				for (int i = 0; i < type_params.Length; ++i) {
 					var spec = type_params[i].Type;
 					spec.BaseType = mutator.Mutate (spec.BaseType);
 					if (spec.InterfacesDefined != null) {
 						var mutated = new TypeSpec[spec.InterfacesDefined.Length];
 						for (int ii = 0; ii < mutated.Length; ++ii) {
 							mutated[ii] = mutator.Mutate (spec.InterfacesDefined[ii]);
 						}
 						for (int ii = 0; ii < mutated.Length; ++ii) {
 							mutated[ii] = mutator.Mutate (spec.InterfacesDefined[ii]);
 						}
 
 						spec.InterfacesDefined = mutated;
 					}
 
 					if (spec.TypeArguments != null) {
 						spec.TypeArguments = mutator.Mutate (spec.TypeArguments);
 					}
 				}
 				for (int i = 0; i < type_params.Length; ++i) {
 					var spec = type_params[i].Type;
 					spec.BaseType = mutator.Mutate (spec.BaseType);
 					if (spec.InterfacesDefined != null) {
 						var mutated = new TypeSpec[spec.InterfacesDefined.Length];
 						for (int ii = 0; ii < mutated.Length; ++ii) {
 							mutated[ii] = mutator.Mutate (spec.InterfacesDefined[ii]);
 						}
 
 						spec.InterfacesDefined = mutated;
 					}
 
 					if (spec.TypeArguments != null) {
 						spec.TypeArguments = mutator.Mutate (spec.TypeArguments);
 					}
 				}
 			}
 
 			//
 			// Update parent cache as we most likely passed the point
 			// where the cache was constructed
 			//
 			Parent.CurrentType.MemberCache.AddMember (this.spec);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7301" endline="7327">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			bool is_generic = member.DeclaringType.IsGenericOrParentIsGeneric;
 			var mi = is_generic ? TypeFromHandleGeneric 
 
 			if (mi == null) {
 				TypeSpec declaring_type = GetDeclaringType (ec.Module.PredefinedTypes).Resolve (loc);
 				TypeSpec handle_type = GetRuntimeHandle (ec.Module.PredefinedTypes).Resolve (loc);
 
 				if (handle_type == null || declaring_type == null)
 					return null;
 
 				mi = TypeManager.GetPredefinedMethod (declaring_type, GetMethodName, loc,
 					is_generic ?
 					new TypeSpec[] { handle_type, TypeManager.runtime_handle_type } 
 					new TypeSpec[] { handle_type } );
 
 				if (is_generic)
 					TypeFromHandleGeneric = mi;
 				else
 					TypeFromHandle = mi;
 			}
 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="287" endline="332">
<![CDATA[
 
 		TypeSpec[] CreateGenericArguments (int first, MetaType[] tparams, DynamicTypeReader dtype)
 		{
 			++dtype.Position;
 
 			var tspec = new TypeSpec [tparams.Length - first];
 			for (int pos = first; pos < tparams.Length; ++pos) {
 				var type = tparams[pos];
 				int index = pos - first;
 
 				TypeSpec spec;
 				if (type.HasElementType) {
 					var element = type.GetElementType ();
 					++dtype.Position;
 					spec = ImportType (element, dtype);
 
 					if (!type.IsArray) {
 						throw new NotImplementedException ("Unknown element type " + type.ToString ());
 					}
 
 					spec = ArrayContainer.MakeType (spec, type.GetArrayRank ());
 				} else {
 					spec = CreateType (type, dtype, true);
 
 					//
 					// We treat nested generic types as inflated internally where
 					// reflection uses type definition
 					//
 					// class A<T> {
 					//    IFoo<A<T>> foo;	// A<T> is definition in this case
 					// }
 					//
 					// TODO
 					//
 					if (type.IsGenericTypeDefinition) {
 						var targs = CreateGenericArguments (0, type.GetGenericArguments (), dtype);
 						spec = spec.MakeGenericType (targs);
 					}
 				}
 
 				++dtype.Position;
 				tspec[index] = spec;
 			}
 			for (int pos = first; pos < tparams.Length; ++pos) {
 				var type = tparams[pos];
 				int index = pos - first;
 
 				TypeSpec spec;
 				if (type.HasElementType) {
 					var element = type.GetElementType ();
 					++dtype.Position;
 					spec = ImportType (element, dtype);
 
 					if (!type.IsArray) {
 						throw new NotImplementedException ("Unknown element type " + type.ToString ());
 					}
 
 					spec = ArrayContainer.MakeType (spec, type.GetArrayRank ());
 				} else {
 					spec = CreateType (type, dtype, true);
 
 					//
 					// We treat nested generic types as inflated internally where
 					// reflection uses type definition
 					//
 					// class A<T> {
 					//    IFoo<A<T>> foo;	// A<T> is definition in this case
 					// }
 					//
 					// TODO
 					//
 					if (type.IsGenericTypeDefinition) {
 						var targs = CreateGenericArguments (0, type.GetGenericArguments (), dtype);
 						spec = spec.MakeGenericType (targs);
 					}
 				}
 
 				++dtype.Position;
 				tspec[index] = spec;
 			}
 
 			return tspec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2885" endline="2924">
<![CDATA[
 		
 		//
 		// Uses inferred or partially infered types to inflate delegate type argument. Returns
 		// null when type parameter has not been fixed
 		//
 		public TypeSpec InflateGenericArgument (TypeSpec parameter)
 		{
 			var tp = parameter as TypeParameterSpec;
 			if (tp != null) {
 				//
 				// Type inference works on generic arguments (MVAR) only
 				//
 				if (!tp.IsMethodOwned)
 					return parameter;
 
 				//
 				// Ensure the type parameter belongs to same container
 				//
 				if (tp.DeclaredPosition < tp_args.Length && tp_args[tp.DeclaredPosition] == parameter)
 					return fixed_types[tp.DeclaredPosition] ?? parameter;
 
 				return parameter;
 			}
 
 			var gt = parameter as InflatedTypeSpec;
 			if (gt != null) {
 				var inflated_targs = new TypeSpec [gt.TypeArguments.Length];
 				for (int ii = 0; ii < inflated_targs.Length; ++ii) {
 					var inflated = InflateGenericArgument (gt.TypeArguments [ii]);
 					if (inflated == null)
 						return null;
 
 					inflated_targs[ii] = inflated;
 				}
 				for (int ii = 0; ii < inflated_targs.Length; ++ii) {
 					var inflated = InflateGenericArgument (gt.TypeArguments [ii]);
 					if (inflated == null)
 						return null;
 
 					inflated_targs[ii] = inflated;
 				}
 
 				return gt.GetDefinition ().MakeGenericType (inflated_targs);
 			}
 
 			return parameter;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="767" endline="808">
<![CDATA[
 
 		public void Save ()
 		{
 			PortableExecutableKinds pekind;
 			ImageFileMachine machine;
 
 			switch (RootContext.Platform) {
 			case Platform.X86
 				pekind = PortableExecutableKinds.Required32Bit | PortableExecutableKinds.ILOnly;
 				machine = ImageFileMachine.I386;
 				break;
 			case Platform.X64
 				pekind = PortableExecutableKinds.ILOnly;
 				machine = ImageFileMachine.AMD64;
 				break;
 			case Platform.IA64
 				pekind = PortableExecutableKinds.ILOnly;
 				machine = ImageFileMachine.IA64;
 				break;
 			case Platform.AnyCPU
 			default
 				pekind = PortableExecutableKinds.ILOnly;
 				machine = ImageFileMachine.I386;
 				break;
 			}
 
 			try {
 				if (RootContext.Target == Target.Module) {
 					SaveModule (pekind, machine);
 				} else {
 					Builder.Save (module.Builder.ScopeName, pekind, machine);
 				}
 			} catch (Exception e) {
 				Report.Error (16, "Could not write to file `" + name + "', cause
 			}
 
 			// Save debug symbols file
 			if (symbol_writer != null) {
 				// TODO
 				symbol_writer.WriteSymbolFile (SymbolWriter.GetGuid (module.Builder));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="88" endline="113">
<![CDATA[
 
 		public override string ToString()
 		{
 			StringBuilder sb = new StringBuilder();
 			sb.Append('[');
 			sb.Append(Constructor.DeclaringType.FullName);
 			sb.Append('(');
 			string sep = "";
 			foreach (CustomAttributeTypedArgument arg in ConstructorArguments)
 			{
 				sb.Append(sep);
 				sep = ", ";
 				AppendValue(sb, arg);
 			}
 			foreach (CustomAttributeTypedArgument arg in ConstructorArguments)
 			{
 				sb.Append(sep);
 				sep = ", ";
 				AppendValue(sb, arg);
 			}
 			foreach (CustomAttributeNamedArgument named in NamedArguments)
 			{
 				sb.Append(sep);
 				sep = ", ";
 				sb.Append(named.MemberInfo.Name);
 				sb.Append(" = ");
 				AppendValue(sb, named.TypedValue);
 			}
 			foreach (CustomAttributeNamedArgument named in NamedArguments)
 			{
 				sb.Append(sep);
 				sep = ", ";
 				sb.Append(named.MemberInfo.Name);
 				sb.Append(" = ");
 				AppendValue(sb, named.TypedValue);
 			}
 			sb.Append(')');
 			sb.Append(']');
 			return sb.ToString();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="57" endline="103">
<![CDATA[
 		}
 
 		protected override ParametersCompiled ResolveParameters (ResolveContext ec, TypeInferenceContext tic, TypeSpec delegateType)
 		{
 			if (!delegateType.IsDelegate)
 				return null;
 
 			AParametersCollection d_params = Delegate.GetParameters (ec.Compiler, delegateType);
 
 			if (HasExplicitParameters) {
 				if (!VerifyExplicitParameters (ec, delegateType, d_params))
 					return null;
 
 				return Parameters;
 			}
 
 			//
 			// If L has an implicitly typed parameter list we make implicit parameters explicit
 			// Set each parameter of L is given the type of the corresponding parameter in D
 			//
 			if (!VerifyParameterCompatibility (ec, delegateType, d_params, ec.IsInProbingMode))
 				return null;
 
 			TypeSpec [] ptypes = new TypeSpec [Parameters.Count];
 			for (int i = 0; i < d_params.Count; i++) {
 				// D has no ref or out parameters
 				if ((d_params.FixedParameters [i].ModFlags & Parameter.Modifier.ISBYREF) != 0)
 					return null;
 
 				TypeSpec d_param = d_params.Types [i];
 
 				//
 				// When type inference context exists try to apply inferred type arguments
 				//
 				if (tic != null) {
 					d_param = tic.InflateGenericArgument (d_param);
 				}
 
 				ptypes [i] = d_param;
 				ImplicitLambdaParameter ilp = (ImplicitLambdaParameter) Parameters.FixedParameters [i];
 				ilp.SetParameterType (d_param);
 				ilp.Resolve (null, i);
 			}
 			for (int i = 0; i < d_params.Count; i++) {
 				// D has no ref or out parameters
 				if ((d_params.FixedParameters [i].ModFlags & Parameter.Modifier.ISBYREF) != 0)
 					return null;
 
 				TypeSpec d_param = d_params.Types [i];
 
 				//
 				// When type inference context exists try to apply inferred type arguments
 				//
 				if (tic != null) {
 					d_param = tic.InflateGenericArgument (d_param);
 				}
 
 				ptypes [i] = d_param;
 				ImplicitLambdaParameter ilp = (ImplicitLambdaParameter) Parameters.FixedParameters [i];
 				ilp.SetParameterType (d_param);
 				ilp.Resolve (null, i);
 			}
 
 			Parameters.Types = ptypes;
 			return Parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="414" endline="435">
<![CDATA[
 	
 	void OutlineParams (ParameterInfo [] pi)
 	{
 		int i = 0;
 		foreach (ParameterInfo p in pi) {
 			if (p.ParameterType.IsByRef) {
 				o.Write (p.IsOut ? "out " 
 				o.Write (FormatType (p.ParameterType.GetElementType ()));
 			} else if (p.IsDefined (typeof (ParamArrayAttribute), false)) {
 				o.Write ("params ");
 				o.Write (FormatType (p.ParameterType));
 			} else {
 				o.Write (FormatType (p.ParameterType));
 			}
 			
 			o.Write (" ");
 			o.Write (p.Name);
 			if (i + 1 < pi.Length)
 				o.Write (", ");
 			i++;
 		}
 		foreach (ParameterInfo p in pi) {
 			if (p.ParameterType.IsByRef) {
 				o.Write (p.IsOut ? "out " 
 				o.Write (FormatType (p.ParameterType.GetElementType ()));
 			} else if (p.IsDefined (typeof (ParamArrayAttribute), false)) {
 				o.Write ("params ");
 				o.Write (FormatType (p.ParameterType));
 			} else {
 				o.Write (FormatType (p.ParameterType));
 			}
 			
 			o.Write (" ");
 			o.Write (p.Name);
 			if (i + 1 < pi.Length)
 				o.Write (", ");
 			i++;
 		}
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="209" endline="242">
<![CDATA[
 
 		//
 		// For cases where we need to union cache members
 		//
 		public void AddBaseType (TypeSpec baseType)
 		{
 			var cache = baseType.MemberCache;
 
 			IList<MemberSpec> list;
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (list is MemberSpec[]) {
 						list = new List<MemberSpec> () { list [0] };
 						member_hash[entry.Key] = list;
 					}
 
 					list.Add (ce);
 				}
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (list is MemberSpec[]) {
 						list = new List<MemberSpec> () { list [0] };
 						member_hash[entry.Key] = list;
 					}
 
 					list.Add (ce);
 				}
 			}
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (list is MemberSpec[]) {
 						list = new List<MemberSpec> () { list [0] };
 						member_hash[entry.Key] = list;
 					}
 
 					list.Add (ce);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1776" endline="1811">
<![CDATA[
 
 		// TODO
 		void EmitConstructors ()
 		{
 			if (instance_constructors == null)
 				return;
 
 			if (spec.IsAttribute && IsExposedFromAssembly () && RootContext.VerifyClsCompliance && IsClsComplianceRequired ()) {
 				bool has_compliant_args = false;
 
 				foreach (Constructor c in instance_constructors) {
 					try {
 						c.Emit ();
 					}
 					catch (Exception e) {
 						throw new InternalErrorException (c, e);
 					}
 
 					if (has_compliant_args)
 						continue;
 
 					has_compliant_args = c.HasCompliantArgs;
 				}
 				foreach (Constructor c in instance_constructors) {
 					try {
 						c.Emit ();
 					}
 					catch (Exception e) {
 						throw new InternalErrorException (c, e);
 					}
 
 					if (has_compliant_args)
 						continue;
 
 					has_compliant_args = c.HasCompliantArgs;
 				}
 				if (!has_compliant_args)
 					Report.Warning (3015, 1, Location, "`{0}' has no accessible constructors which use only CLS-compliant types", GetSignatureForError ());
 			} else {
 				foreach (Constructor c in instance_constructors) {
 					try {
 						c.Emit ();
 					}
 					catch (Exception e) {
 						throw new InternalErrorException (c, e);
 					}
 				}
 				foreach (Constructor c in instance_constructors) {
 					try {
 						c.Emit ();
 					}
 					catch (Exception e) {
 						throw new InternalErrorException (c, e);
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1120" endline="1130">
<![CDATA[
 		
 		public int peek_token ()
 		{
 			int the_token;
 
 			PushPosition ();
 			the_token = token ();
 			PopPosition ();
 			
 			return the_token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="161" endline="174">
<![CDATA[
 
 		public override Module GetModule(string name)
 		{
 			if (name.Equals(manifestModule.ScopeName, StringComparison.InvariantCultureIgnoreCase))
 			{
 				return manifestModule;
 			}
 			int index = GetModuleIndex(name);
 			if (index != -1)
 			{
 				return GetModule(index);
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="999" endline="1014">
<![CDATA[
 	
 	static int CompareEventInfo (object a, object b)
 	{
 		EventInfo aa = (EventInfo) a, bb = (EventInfo) b;
 		
 		bool astatic = aa.GetAddMethod (true).IsStatic;
 		bool bstatic = bb.GetAddMethod (true).IsStatic;
 		
 		if (astatic == bstatic)
 			return CompareMemberInfo (a, b);
 		
 		if (astatic)
 			return -1;
 		
 		return 1;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1971" endline="1990">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		// Checks all type arguments againts type parameters constraints
 		// NOTE
 		//
 		public bool CheckAll (MemberSpec context, TypeSpec[] targs, TypeParameterSpec[] tparams, Location loc)
 		{
 			for (int i = 0; i < tparams.Length; i++) {
 				if (ignore_inferred_dynamic && targs[i] == InternalType.Dynamic)
 					continue;
 
 				if (!CheckConstraint (context, targs [i], tparams [i], loc))
 					return false;
 			}
 			for (int i = 0; i < tparams.Length; i++) {
 				if (ignore_inferred_dynamic && targs[i] == InternalType.Dynamic)
 					continue;
 
 				if (!CheckConstraint (context, targs [i], tparams [i], loc))
 					return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5442" endline="5461">
<![CDATA[
 		}
 
 		#endregion
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, null);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.Resolve (ec);
 			}
 
 			if (!ResolveGetter (ec))
 				return null;
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="566" endline="585">
<![CDATA[
 
 	static MemberSpec GetPredefinedMember (TypeSpec t, MemberFilter filter, bool optional, Location loc)
 	{
 		var member = MemberCache.FindMember (t, filter, BindingRestriction.DeclaredOnly);
 
 		if (member != null && member.IsAccessible (InternalType.FakeInternalType))
 			return member;
 
 		if (optional)
 			return member;
 
 		string method_args = null;
 		if (filter.Parameters != null)
 			method_args = filter.Parameters.GetSignatureForError ();
 
 		RootContext.ToplevelTypes.Compiler.Report.Error (656, loc, "The compiler required member `{0}.{1}{2}' could not be found or is inaccessible",
 			TypeManager.CSharpName (t), filter.Name, method_args);
 
 		return null;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="348" endline="376">
<![CDATA[
 
 #if NET_4_0
 		public override System.Linq.Expressions.Expression MakeExpression (BuilderContext ctx)
 		{
 			var tassign = target as IDynamicAssign;
 			if (tassign == null)
 				throw new InternalErrorException (target.GetType () + " does not support dynamic assignment");
 
 			var target_object = tassign.MakeAssignExpression (ctx, source);
 
 			//
 			// Some hacking is needed as DLR does not support void type and requires
 			// always have object convertible return type to support caching and chaining
 			//
 			// We do this by introducing an explicit block which returns RHS value when
 			// available or null
 			//
 			if (target_object.NodeType == System.Linq.Expressions.ExpressionType.Block)
 				return target_object;
 
 			System.Linq.Expressions.UnaryExpression source_object;
 			if (ctx.HasSet (BuilderContext.Options.CheckedScope)) {
 				source_object = System.Linq.Expressions.Expression.ConvertChecked (source.MakeExpression (ctx), target_object.Type);
 			} else {
 				source_object = System.Linq.Expressions.Expression.Convert (source.MakeExpression (ctx), target_object.Type);
 			}
 
 			return System.Linq.Expressions.Expression.Assign (target_object, source_object);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="331" endline="399">
<![CDATA[
 
 		//
 		// Todo
 		// the recording themselves?
 		//
 
 		/// <summary>
 		///   Evaluates and expression or statement and returns any result values.
 		/// </summary>
 		/// <remarks>
 		///   Evaluates the input string as a C# expression or
 		///   statement.  If the input string is an expression
 		///   the result will be stored in the result variable
 		///   and the result_set variable will be set to true.
 		///
 		///   It is necessary to use the result/result_set
 		///   pair to identify when a result was set (for
 		///   example, execution of user-provided input can be
 		///   an expression, a statement or others, and
 		///   result_set would only be set if the input was an
 		///   expression.
 		///
 		///   If the return value of this function is null,
 		///   this indicates that the parsing was complete.
 		///   If the return value is a string, it indicates
 		///   that the input is partial and that the user
 		///   should provide an updated string.
 		/// </remarks>
 		public static string Evaluate (string input, out object result, out bool result_set)
 		{
 			CompiledMethod compiled;
 
 			result_set = false;
 			result = null;
 
 			input = Compile (input, out compiled);
 			if (input != null)
 				return input;
 			
 			if (compiled == null)
 				return null;
 				
 			//
 			// The code execution does not need to keep the compiler lock
 			//
 			object retval = typeof (NoValueSet);
 
 			try {
 				invoke_thread = System.Threading.Thread.CurrentThread;
 				invoking = true;
 				compiled (ref retval);
 			} catch (ThreadAbortException e){
 				Thread.ResetAbort ();
 				Console.WriteLine ("Interrupted!\n{0}", e);
 			} finally {
 				invoking = false;
 			}
 
 			//
 			// We use a reference to a compiler type, in this case
 			// Driver as a flag to indicate that this was a statement
 			//
 			if (retval != typeof (NoValueSet)){
 				result_set = true;
 				result = retval; 
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="479" endline="509">
<![CDATA[
 
 		public EventInfo[] GetEvents(BindingFlags bindingAttr)
 		{
 			List<EventInfo> list = new List<EventInfo>();
 			Type type = this;
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (EventInfo evt in type.__GetDeclaredEvents())
 				{
 					if (BindingFlagsMatch(evt.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(evt.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(evt);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="779" endline="809">
<![CDATA[
 
 		public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
 		{
 			List<PropertyInfo> list = new List<PropertyInfo>();
 			Type type = this;
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (type != null)
 			{
 				type.CheckBaked();
 				foreach (PropertyInfo property in type.__GetDeclaredProperties())
 				{
 					if (BindingFlagsMatch(property.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 						&& BindingFlagsMatch(property.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 					{
 						list.Add(property);
 					}
 				}
 				if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 				{
 					if ((bindingAttr & BindingFlags.FlattenHierarchy) == 0)
 					{
 						bindingAttr &= ~BindingFlags.Static;
 					}
 					type = type.BaseType;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="460" endline="501">
<![CDATA[
 
 		void ProcessSourceFiles (string spec, bool recurse)
 		{
 			string path, pattern;
 
 			SplitPathAndPattern (spec, out path, out pattern);
 			if (pattern.IndexOf ('*') == -1){
 				AddSourceFile (spec);
 				return;
 			}
 
 			string [] files = null;
 			try {
 				files = Directory.GetFiles (path, pattern);
 			} catch (System.IO.DirectoryNotFoundException) {
 				Report.Error (2001, "Source file `" + spec + "' could not be found");
 				return;
 			} catch (System.IO.IOException){
 				Report.Error (2001, "Source file `" + spec + "' could not be found");
 				return;
 			}
 			foreach (string f in files) {
 				AddSourceFile (f);
 			}
 			foreach (string f in files) {
 				AddSourceFile (f);
 			}
 
 			if (!recurse)
 				return;
 			
 			string [] dirs = null;
 
 			try {
 				dirs = Directory.GetDirectories (path);
 			} catch {
 			}
 			
 			foreach (string d in dirs) {
 					
 				// Don't include path in this string, as each
 				// directory entry already does
 				ProcessSourceFiles (d + "/" + pattern, true);
 			}
 			foreach (string d in dirs) {
 					
 				// Don't include path in this string, as each
 				// directory entry already does
 				ProcessSourceFiles (d + "/" + pattern, true);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="893" endline="935">
<![CDATA[
 
 		///
 		/// Does extension methods look up to find a method which matches name and extensionType.
 		/// Search starts from this namespace and continues hierarchically up to top level.
 		///
 		public IList<MethodSpec> LookupExtensionMethod (TypeSpec extensionType, string name, int arity, ref NamespaceEntry scope)
 		{
 			List<MethodSpec> candidates = null;
 			foreach (Namespace n in GetUsingTable ()) {
 				var a = n.LookupExtensionMethod (extensionType, RootContext.ToplevelTypes, name, arity);
 				if (a == null)
 					continue;
 
 				if (candidates == null)
 					candidates = a;
 				else
 					candidates.AddRange (a);
 			}
 			foreach (Namespace n in GetUsingTable ()) {
 				var a = n.LookupExtensionMethod (extensionType, RootContext.ToplevelTypes, name, arity);
 				if (a == null)
 					continue;
 
 				if (candidates == null)
 					candidates = a;
 				else
 					candidates.AddRange (a);
 			}
 
 			scope = parent;
 			if (candidates != null)
 				return candidates;
 
 			if (parent == null)
 				return null;
 
 			//
 			// Inspect parent namespaces in namespace expression
 			//
 			Namespace parent_ns = ns.Parent;
 			do {
 				candidates = parent_ns.LookupExtensionMethod (extensionType, RootContext.ToplevelTypes, name, arity);
 				if (candidates != null)
 					return candidates;
 
 				parent_ns = parent_ns.Parent;
 			} while (parent_ns != null);
 
 			//
 			// Continue in parent scope
 			//
 			return parent.LookupExtensionMethod (extensionType, name, arity, ref scope);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="940" endline="972">
<![CDATA[
 
 		protected void ImportTypes (MetaType[] types, Namespace targetNamespace, bool hasExtensionTypes)
 		{
 			Namespace ns = targetNamespace;
 			string prev_namespace = null;
 			foreach (var t in types) {
 				if (t == null)
 					continue;
 
 				// Be careful not to trigger full parent type loading
 				if (t.MemberType == MemberTypes.NestedType)
 					continue;
 
 				if (t.Name[0] == '<')
 					continue;
 
 				var it = CreateType (t, null, new DynamicTypeReader (t), true);
 				if (it == null)
 					continue;
 
 				if (prev_namespace != t.Namespace) {
 					ns = t.Namespace == null ? targetNamespace 
 					prev_namespace = t.Namespace;
 				}
 
 				ns.AddType (it);
 
 				if (it.IsStatic && hasExtensionTypes &&
 					HasAttribute (CustomAttributeData.GetCustomAttributes (t), "ExtensionAttribute", CompilerServicesNamespace)) {
 					it.SetExtensionMethodContainer ();
 				}
 			}
 			foreach (var t in types) {
 				if (t == null)
 					continue;
 
 				// Be careful not to trigger full parent type loading
 				if (t.MemberType == MemberTypes.NestedType)
 					continue;
 
 				if (t.Name[0] == '<')
 					continue;
 
 				var it = CreateType (t, null, new DynamicTypeReader (t), true);
 				if (it == null)
 					continue;
 
 				if (prev_namespace != t.Namespace) {
 					ns = t.Namespace == null ? targetNamespace 
 					prev_namespace = t.Namespace;
 				}
 
 				ns.AddType (it);
 
 				if (it.IsStatic && hasExtensionTypes &&
 					HasAttribute (CustomAttributeData.GetCustomAttributes (t), "ExtensionAttribute", CompilerServicesNamespace)) {
 					it.SetExtensionMethodContainer ();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="175" endline="206">
<![CDATA[
 
 		private void ReadTables(BinaryReader br)
 		{
 			Table[] tables = GetTables();
 			uint Reserved0 = br.ReadUInt32();
 			byte MajorVersion = br.ReadByte();
 			byte MinorVersion = br.ReadByte();
 			metadataStreamVersion = MajorVersion << 16 | MinorVersion;
 			byte HeapSizes = br.ReadByte();
 			byte Reserved7 = br.ReadByte();
 			ulong Valid = br.ReadUInt64();
 			ulong Sorted = br.ReadUInt64();
 			for (int i = 0; i < 64; i++)
 			{
 				if ((Valid & (1UL << i)) != 0)
 				{
 					tables[i].RowCount = br.ReadInt32();
 				}
 				else if (tables[i] != null)
 				{
 					tables[i].RowCount = 0;
 				}
 			}
 			for (int i = 0; i < 64; i++)
 			{
 				if ((Valid & (1UL << i)) != 0)
 				{
 					tables[i].RowCount = br.ReadInt32();
 				}
 				else if (tables[i] != null)
 				{
 					tables[i].RowCount = 0;
 				}
 			}
 			MetadataReader mr = new MetadataReader(this, br, HeapSizes);
 			for (int i = 0; i < 64; i++)
 			{
 				if ((Valid & (1UL << i)) != 0)
 				{
 					tables[i].Read(mr);
 				}
 			}
 			for (int i = 0; i < 64; i++)
 			{
 				if ((Valid & (1UL << i)) != 0)
 				{
 					tables[i].Read(mr);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2853" endline="2887">
<![CDATA[
 
 		public LabeledStatement GetLabel (string name, Block block)
 		{
 			if (labels == null)
 				return null;
 
 			object value;
 			if (!labels.TryGetValue (name, out value)) {
 				return null;
 			}
 
 			var label = value as LabeledStatement;
 			Block b = block;
 			if (label != null) {
 				if (label.Block == b.Original)
 					return label;
 
 				// TODO
 				if (label.Block.IsCompilerGenerated && label.Block.Parent == b.Original)
 					return label;
 			} else {
 				List<LabeledStatement> list = (List<LabeledStatement>) value;
 				for (int i = 0; i < list.Count; ++i) {
 					label = list[i];
 					if (label.Block == b.Original)
 						return label;
 
 					// TODO
 					if (label.Block.IsCompilerGenerated && label.Block.Parent == b.Original)
 						return label;
 				}
 				for (int i = 0; i < list.Count; ++i) {
 					label = list[i];
 					if (label.Block == b.Original)
 						return label;
 
 					// TODO
 					if (label.Block.IsCompilerGenerated && label.Block.Parent == b.Original)
 						return label;
 				}
 			}
 				
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="3331" endline="3361">
<![CDATA[
 
 		//
 		// Remove heading "*" in Javadoc-like xml documentation.
 		//
 		private void update_formatted_doc_comment (int current_comment_start)
 		{
 			int length = xml_comment_buffer.Length - current_comment_start;
 			string [] lines = xml_comment_buffer.ToString (
 				current_comment_start,
 				length).Replace ("\r", "").Split ('\n');
 			
 			// The first line starts with /**, thus it is not target
 			// for the format check.
 			for (int i = 1; i < lines.Length; i++) {
 				string s = lines [i];
 				int idx = s.IndexOf ('*');
 				string head = null;
 				if (idx < 0) {
 					if (i < lines.Length - 1)
 						return;
 					head = s;
 				} else
 					head = s.Substring (0, idx);
 				foreach (char c in head)
 					if (c != ' ')
 						return;
 				foreach (char c in head)
 					if (c != ' ')
 						return;
 				lines [i] = s.Substring (idx + 1);
 			}
 			for (int i = 1; i < lines.Length; i++) {
 				string s = lines [i];
 				int idx = s.IndexOf ('*');
 				string head = null;
 				if (idx < 0) {
 					if (i < lines.Length - 1)
 						return;
 					head = s;
 				} else
 					head = s.Substring (0, idx);
 				foreach (char c in head)
 					if (c != ' ')
 						return;
 				lines [i] = s.Substring (idx + 1);
 			}
 			xml_comment_buffer.Remove (current_comment_start, length);
 			xml_comment_buffer.Insert (current_comment_start, String.Join (Environment.NewLine, lines));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="574" endline="584">
<![CDATA[
 
 		void ReadModulesAssemblyAttributes ()
 		{
 			foreach (var m in added_modules) {
 				var cattrs = m.ReadAssemblyAttributes ();
 				if (cattrs == null)
 					continue;
 
 				module.OptAttributes.AddAttributes (cattrs);
 			}
 			foreach (var m in added_modules) {
 				var cattrs = m.ReadAssemblyAttributes ();
 				if (cattrs == null)
 					continue;
 
 				module.OptAttributes.AddAttributes (cattrs);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="122" endline="136">
<![CDATA[
 		}
 
 		public override void DefineSymbolInfo (MonoSymbolWriter symwriter)
 		{
 			base.DefineSymbolInfo (symwriter);
 
 			comp_unit = symwriter.DefineCompilationUnit (SourceFileEntry);
 
 			if (include_files != null) {
 				foreach (SourceFile include in include_files.Values) {
 					include.DefineSymbolInfo (symwriter);
 					comp_unit.AddFile (include.SourceFileEntry);
 				}
 				foreach (SourceFile include in include_files.Values) {
 					include.DefineSymbolInfo (symwriter);
 					comp_unit.AddFile (include.SourceFileEntry);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="89" endline="102">
<![CDATA[
 
 		internal void ExtractResources(byte[] buf)
 		{
 			ByteReader br = new ByteReader(buf, 0, buf.Length);
 			while (br.Length >= 32)
 			{
 				br.Align(4);
 				RESOURCEHEADER hdr = new RESOURCEHEADER(br);
 				if (hdr.DataSize != 0)
 				{
 					root[hdr.TYPE][hdr.NAME][new OrdinalOrName(hdr.LanguageId)].Data = ByteBuffer.Wrap(br.ReadBytes(hdr.DataSize));
 				}
 			}
 			while (br.Length >= 32)
 			{
 				br.Align(4);
 				RESOURCEHEADER hdr = new RESOURCEHEADER(br);
 				if (hdr.DataSize != 0)
 				{
 					root[hdr.TYPE][hdr.NAME][new OrdinalOrName(hdr.LanguageId)].Data = ByteBuffer.Wrap(br.ReadBytes(hdr.DataSize));
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="1119" endline="1142">
<![CDATA[
 
 		private void WriteScope(Scope scope, int localVarSigTok)
 		{
 			moduleBuilder.symbolWriter.OpenScope(scope.startOffset);
 			foreach (LocalBuilder local in scope.locals)
 			{
 				if (local.name != null)
 				{
 					int startOffset = local.startOffset;
 					int endOffset = local.endOffset;
 					if (startOffset == 0 && endOffset == 0)
 					{
 						startOffset = scope.startOffset;
 						endOffset = scope.endOffset;
 					}
 					moduleBuilder.symbolWriter.DefineLocalVariable2(local.name, 0, localVarSigTok, SymAddressKind.ILOffset, local.LocalIndex, 0, 0, startOffset, endOffset);
 				}
 			}
 			foreach (LocalBuilder local in scope.locals)
 			{
 				if (local.name != null)
 				{
 					int startOffset = local.startOffset;
 					int endOffset = local.endOffset;
 					if (startOffset == 0 && endOffset == 0)
 					{
 						startOffset = scope.startOffset;
 						endOffset = scope.endOffset;
 					}
 					moduleBuilder.symbolWriter.DefineLocalVariable2(local.name, 0, localVarSigTok, SymAddressKind.ILOffset, local.LocalIndex, 0, 0, startOffset, endOffset);
 				}
 			}
 			foreach (Scope child in scope.children)
 			{
 				WriteScope(child, localVarSigTok);
 			}
 			foreach (Scope child in scope.children)
 			{
 				WriteScope(child, localVarSigTok);
 			}
 			moduleBuilder.symbolWriter.CloseScope(scope.endOffset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1130" endline="1137">
<![CDATA[
 
 		public string GetString () 
 		{
 			Expression e = GetValue ();
 			if (e is StringConstant)
 				return ((StringConstant)e).Value;
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1450" endline="1464">
<![CDATA[
 		}
 
 		internal virtual Type BindTypeParameters(IGenericBinder binder)
 		{
 			if (IsGenericTypeDefinition)
 			{
 				Type[] args = GetGenericArguments();
 				Type.InplaceBindTypeParameters(binder, args);
 				return GenericTypeInstance.Make(this, args, null, null);
 			}
 			else
 			{
 				return this;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="520" endline="532">
<![CDATA[
 
 		public MethodToken GetMethodToken(MethodInfo method)
 		{
 			MethodBuilder mb = method as MethodBuilder;
 			if (mb != null && mb.ModuleBuilder == this)
 			{
 				return new MethodToken(mb.MetadataToken);
 			}
 			else
 			{
 				return new MethodToken(ImportMember(method));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="230" endline="237">
<![CDATA[
 
 		public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
 		{
 			for (int i = 0; i < arguments.Length; i++)
 			{
 				AddArgument(arguments[i], false, requiredCustomModifiers[i], optionalCustomModifiers[i]);
 			}
 			for (int i = 0; i < arguments.Length; i++)
 			{
 				AddArgument(arguments[i], false, requiredCustomModifiers[i], optionalCustomModifiers[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1295" endline="1310">
<![CDATA[
 
 		public MethodInfo GetAddressMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var address = mb.GetArrayMethod (
 				GetMetaInfo (), "Address",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				ReferenceContainer.MakeType (Element).GetMetaInfo (), arg_types);
 
 			return address;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="225" endline="297">
<![CDATA[
 
 		/// <summary>
 		///   Compiles the input string and returns a delegate that represents the compiled code.
 		/// </summary>
 		/// <remarks>
 		///
 		///   Compiles the input string as a C# expression or
 		///   statement, unlike the Evaluate method, the
 		///   resulting delegate can be invoked multiple times
 		///   without incurring in the compilation overhead.
 		///
 		///   If the return value of this function is null,
 		///   this indicates that the parsing was complete.
 		///   If the return value is a string it indicates
 		///   that the input string was partial and that the
 		///   invoking code should provide more code before
 		///   the code can be successfully compiled.
 		///
 		///   If you know that you will always get full expressions or
 		///   statements and do not care about partial input, you can use
 		///   the other Compile overload. 
 		///
 		///   On success, in addition to returning null, the
 		///   compiled parameter will be set to the delegate
 		///   that can be invoked to execute the code.
 		///
 	        /// </remarks>
 		static public string Compile (string input, out CompiledMethod compiled)
 		{
 			if (input == null || input.Length == 0){
 				compiled = null;
 				return null;
 			}
 
 			lock (evaluator_lock){
 				if (!inited)
 					Init ();
 				else
 					ctx.Report.Printer.Reset ();
 
 			//	RootContext.ToplevelTypes = new ModuleContainer (ctx);
 
 				bool partial_input;
 				CSharpParser parser = ParseString (ParseMode.Silent, input, out partial_input);
 				if (parser == null){
 					compiled = null;
 					if (partial_input)
 						return input;
 					
 					ParseString (ParseMode.ReportErrors, input, out partial_input);
 					return null;
 				}
 				
 				object parser_result = parser.InteractiveResult;
 				
 				if (!(parser_result is Class)){
 					int errors = ctx.Report.Errors;
 
 					NamespaceEntry.VerifyAllUsing ();
 					if (errors == ctx.Report.Errors)
 						parser.CurrentNamespace.Extract (using_alias_list, using_list);
 					else
 						NamespaceEntry.Reset ();
 				}
 
 #if STATIC
 				throw new NotSupportedException ();
 #else
 				compiled = CompileBlock (parser_result as Class, parser.undo, ctx.Report);
 				return null;
 #endif
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="466" endline="492">
<![CDATA[
 
 		public CustomAttributeBuilder __ToBuilder()
 		{
 			object[] args = new object[ConstructorArguments.Count];
 			for (int i = 0; i < args.Length; i++)
 			{
 				args[i] = ConstructorArguments[i].Value;
 			}
 			for (int i = 0; i < args.Length; i++)
 			{
 				args[i] = ConstructorArguments[i].Value;
 			}
 			List<PropertyInfo> namedProperties = new List<PropertyInfo>();
 			List<object> propertyValues = new List<object>();
 			List<FieldInfo> namedFields = new List<FieldInfo>();
 			List<object> fieldValues = new List<object>();
 			foreach (CustomAttributeNamedArgument named in NamedArguments)
 			{
 				if (named.MemberInfo is PropertyInfo)
 				{
 					namedProperties.Add((PropertyInfo)named.MemberInfo);
 					propertyValues.Add(named.TypedValue.Value);
 				}
 				else
 				{
 					namedFields.Add((FieldInfo)named.MemberInfo);
 					fieldValues.Add(named.TypedValue.Value);
 				}
 			}
 			foreach (CustomAttributeNamedArgument named in NamedArguments)
 			{
 				if (named.MemberInfo is PropertyInfo)
 				{
 					namedProperties.Add((PropertyInfo)named.MemberInfo);
 					propertyValues.Add(named.TypedValue.Value);
 				}
 				else
 				{
 					namedFields.Add((FieldInfo)named.MemberInfo);
 					fieldValues.Add(named.TypedValue.Value);
 				}
 			}
 			return new CustomAttributeBuilder(Constructor, args, namedProperties.ToArray(), propertyValues.ToArray(), namedFields.ToArray(), fieldValues.ToArray());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1146" endline="1153">
<![CDATA[
 
 		public TypeSpec GetArgumentType ()
 		{
 			TypeOf e = GetValue () as TypeOf;
 			if (e == null)
 				return null;
 			return e.TypeArgument;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodInfo.cs" startline="47" endline="74">
<![CDATA[
 		}
 
 		public override string ToString()
 		{
 			StringBuilder sb = new StringBuilder();
 			sb.Append(this.ReturnType.Name).Append(' ').Append(this.Name);
 			string sep;
 			if (this.IsGenericMethod)
 			{
 				sb.Append('[');
 				sep = "";
 				foreach (Type arg in GetGenericArguments())
 				{
 					sb.Append(sep).Append(arg);
 					sep = ", ";
 				}
 				foreach (Type arg in GetGenericArguments())
 				{
 					sb.Append(sep).Append(arg);
 					sep = ", ";
 				}
 				sb.Append(']');
 			}
 			sb.Append('(');
 			sep = "";
 			foreach (ParameterInfo arg in GetParameters())
 			{
 				sb.Append(sep).Append(arg.ParameterType);
 				sep = ", ";
 			}
 			foreach (ParameterInfo arg in GetParameters())
 			{
 				sb.Append(sep).Append(arg.ParameterType);
 				sep = ", ";
 			}
 			sb.Append(')');
 			return sb.ToString();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="504" endline="519">
<![CDATA[
 
 		public FieldToken GetFieldToken(FieldInfo field)
 		{
 			// NOTE for some reason, when TypeBuilder.GetFieldToken() is used on a field in a generic type definition,
 			// a memberref token is returned (confirmed on .NET) unlike for Get(Method|Constructor)Token which always
 			// simply returns the MethodDef token (if the method is from the same module).
 			FieldBuilder fb = field as FieldBuilder;
 			if (fb != null && fb.Module == this && !IsFromGenericTypeDefinition(fb))
 			{
 				return new FieldToken(fb.MetadataToken);
 			}
 			else
 			{
 				return new FieldToken(ImportMember(field));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6077" endline="6095">
<![CDATA[
 
 // <summary>
 //   Given the @class_name name, it creates a fully qualified name
 //   based on the containing declaration space
 // </summary>
 MemberName
 MakeName (MemberName class_name)
 {
 	Namespace ns = current_namespace.NS;
 
 	if (current_container == RootContext.ToplevelTypes) {
 		if (ns.Name.Length != 0)
 			return new MemberName (ns.MemberName, class_name);
 		else
 			return class_name;
 	} else {
 		return new MemberName (current_container.MemberName, class_name);
 	}
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="361" endline="473">
<![CDATA[
 
 		private static MemberSpec FindDocumentedMemberNoNest (
 			MemberCore mc, TypeSpec type, string member_name,
 			AParametersCollection param_list, DeclSpace ds, out int warning_type, 
 			string cref, bool warn419, string name_for_error, Report Report)
 		{
 			warning_type = 0;
 //			var filter = new MemberFilter (member_name, 0, MemberKind.All, param_list, null);
 			IList<MemberSpec> found = null;
 			while (type != null && found == null) {
 				found = MemberCache.FindMembers (type, member_name, false);
 				type = type.DeclaringType;
 			}
 			while (type != null && found == null) {
 				found = MemberCache.FindMembers (type, member_name, false);
 				type = type.DeclaringType;
 			}
 
 			if (found == null)
 				return null;
 
 			if (warn419 && found.Count > 1) {
 				Report419 (mc, name_for_error, found.ToArray (), Report);
 			}
 
 			return found [0];
 
 /*
 			if (param_list == null) {
 				// search for fields/events etc.
 				mis = TypeManager.MemberLookup (type, null,
 					type, MemberKind.All,
 					BindingRestriction.None,
 					member_name, null);
 				mis = FilterOverridenMembersOut (mis);
 				if (mis == null || mis.Length == 0)
 					return null;
 				if (warn419 && IsAmbiguous (mis))
 					Report419 (mc, name_for_error, mis, Report);
 				return mis [0];
 			}
 
 			MethodSignature msig = new MethodSignature (member_name, null, param_list);
 			mis = FindMethodBase (type, 
 				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
 				msig);
 
 			if (warn419 && mis.Length > 0) {
 				if (IsAmbiguous (mis))
 					Report419 (mc, name_for_error, mis, Report);
 				return mis [0];
 			}
 
 			// search for operators (whose parameters exactly
 			// matches with the list) and possibly report CS1581.
 			string oper = null;
 			string return_type_name = null;
 			if (member_name.StartsWith ("implicit operator ")) {
 				Operator.GetMetadataName (Operator.OpType.Implicit);
 				return_type_name = member_name.Substring (18).Trim (wsChars);
 			}
 			else if (member_name.StartsWith ("explicit operator ")) {
 				oper = Operator.GetMetadataName (Operator.OpType.Explicit);
 				return_type_name = member_name.Substring (18).Trim (wsChars);
 			}
 			else if (member_name.StartsWith ("operator ")) {
 				oper = member_name.Substring (9).Trim (wsChars);
 				switch (oper) {
 				// either unary or binary
 				case "+"
 					oper = param_list.Length == 2 ?
 						Operator.GetMetadataName (Operator.OpType.Addition) 
 						Operator.GetMetadataName (Operator.OpType.UnaryPlus);
 					break;
 				case "-"
 					oper = param_list.Length == 2 ?
 						Operator.GetMetadataName (Operator.OpType.Subtraction) 
 						Operator.GetMetadataName (Operator.OpType.UnaryNegation);
 					break;
 				default
 					oper = Operator.GetMetadataName (oper);
 					if (oper != null)
 						break;
 
 					warning_type = 1584;
 					Report.Warning (1020, 1, mc.Location, "Overloadable {0} operator is expected", param_list.Length == 2 ? "binary" 
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					return null;
 				}
 			}
 			// here we still don't consider return type (to
 			// detect CS1581 or CS1002+CS1584).
 			msig = new MethodSignature (oper, null, param_list);
 
 			mis = FindMethodBase (type, 
 				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
 				msig);
 			if (mis.Length == 0)
 				return null; // CS1574
 			var mi = mis [0];
 			TypeSpec expected = mi is MethodSpec ?
 				((MethodSpec) mi).ReturnType 
 				mi is PropertySpec ?
 				((PropertySpec) mi).PropertyType 
 				null;
 			if (return_type_name != null) {
 				TypeSpec returnType = FindDocumentedType (mc, return_type_name, ds, cref, Report);
 				if (returnType == null || returnType != expected) {
 					warning_type = 1581;
 					Report.Warning (1581, 1, mc.Location, "Invalid return type in XML comment cref attribute `{0}'", cref);
 					return null;
 				}
 			}
 			return mis [0];
 */ 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="833" endline="854">
<![CDATA[
 
 		void ImportTypeBase (TypeSpec spec, MetaType type)
 		{
 			if (spec.Kind == MemberKind.Interface)
 				spec.BaseType = TypeManager.object_type;
 			else if (type.BaseType != null) {
 				TypeSpec base_type;
 				if (type.BaseType.IsGenericType)
 					base_type = CreateType (type.BaseType, new DynamicTypeReader (type), true);
 				else
 					base_type = CreateType (type.BaseType);
 
 				spec.BaseType = base_type;
 			}
 
 			var ifaces = type.GetInterfaces ();
 			if (ifaces.Length > 0) {
 				foreach (var iface in ifaces) {
 					spec.AddInterface (CreateType (iface));
 				}
 				foreach (var iface in ifaces) {
 					spec.AddInterface (CreateType (iface));
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="822" endline="876">
<![CDATA[
 
 		void SetEntryPoint ()
 		{
 			if (!RootContext.NeedsEntryPoint) {
 				if (RootContext.MainClass != null)
 					Report.Error (2017, "Cannot specify -main if building a module or library");
 
 				return;
 			}
 
 			PEFileKinds file_kind;
 
 			switch (RootContext.Target) {
 			case Target.Library
 			case Target.Module
 				file_kind = PEFileKinds.Dll;
 				break;
 			case Target.WinExe
 				file_kind = PEFileKinds.WindowApplication;
 				break;
 			default
 				file_kind = PEFileKinds.ConsoleApplication;
 				break;
 			}
 
 			if (entry_point == null) {
 				if (RootContext.MainClass != null) {
 					// TODO
 					DeclSpace main_cont = module.GetDefinition (RootContext.MainClass) as DeclSpace;
 					if (main_cont == null) {
 						Report.Error (1555, "Could not find `{0}' specified for Main method", RootContext.MainClass);
 						return;
 					}
 
 					if (!(main_cont is ClassOrStruct)) {
 						Report.Error (1556, "`{0}' specified for Main method must be a valid class or struct", RootContext.MainClass);
 						return;
 					}
 
 					Report.Error (1558, main_cont.Location, "`{0}' does not have a suitable static Main method", main_cont.GetSignatureForError ());
 					return;
 				}
 
 				if (Report.Errors == 0) {
 					string pname = file_name == null ? name 
 
 					Report.Error (5001, "Program `{0}' does not contain a static `Main' method suitable for an entry point",
 						pname);
 				}
 
 				return;
 			}
 
 			Builder.SetEntryPoint (entry_point.MethodBuilder, file_kind);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="1154" endline="1194">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			CloneContext cc = new CloneContext ();
 			Expression clone = source.Clone (cc);
 
 			//
 			// A useful feature for the REPL
 			// as a type, Describe the type;
 			//
 			if (Evaluator.DescribeTypeExpressions){
 				var old_printer = Evaluator.SetPrinter (new StreamReportPrinter (TextWriter.Null));
 				clone = clone.Resolve (ec);
 				if (clone == null){
 					clone = source.Clone (cc);
 					clone = clone.Resolve (ec, ResolveFlags.Type);
 					if (clone == null){
 						Evaluator.SetPrinter (old_printer);
 						clone = source.Clone (cc);
 						clone = clone.Resolve (ec);
 						return null;
 					}
 					
 					Arguments args = new Arguments (1);
 					args.Add (new Argument (new TypeOf ((TypeExpr) clone, Location)));
 					source = new Invocation (new SimpleName ("Describe", Location), args).Resolve (ec);
 				}
 				Evaluator.SetPrinter (old_printer);
 			} else {
 				clone = clone.Resolve (ec);
 				if (clone == null)
 					return null;
 			}
 	
 			// This means its really a statement.
 			if (clone.Type == TypeManager.void_type || clone is DynamicInvocation || clone is Assign) {
 				return clone;
 			}
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="610" endline="652">
<![CDATA[
 
 		internal Assembly Load(string refname, Assembly requestingAssembly, bool throwOnError)
 		{
 			Assembly asm = GetLoadedAssembly(refname);
 			if (asm != null)
 			{
 				return asm;
 			}
 			if (resolvers.Count == 0)
 			{
 				asm = DefaultResolver(refname, throwOnError);
 			}
 			else
 			{
 				ResolveEventArgs args = new ResolveEventArgs(refname, requestingAssembly);
 				foreach (ResolveEventHandler evt in resolvers)
 				{
 					asm = evt(this, args);
 					if (asm != null)
 					{
 						break;
 					}
 				}
 				foreach (ResolveEventHandler evt in resolvers)
 				{
 					asm = evt(this, args);
 					if (asm != null)
 					{
 						break;
 					}
 				}
 				if (asm == null)
 				{
 					asm = GetDynamicAssembly(refname);
 				}
 			}
 			if (asm != null)
 			{
 				string defname = asm.FullName;
 				if (refname != defname)
 				{
 					assembliesByName.Add(refname, asm);
 				}
 				return asm;
 			}
 			if (throwOnError)
 			{
 				throw new FileNotFoundException(refname);
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="654" endline="661">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			foreach (var s in statements)
 				s.Resolve (ec);
 			foreach (var s in statements)
 				s.Resolve (ec);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9603" endline="9613">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			if (parameters == null)
 				return;
 
 			NewAnonymousType t = (NewAnonymousType) target;
 			t.parameters = new List<AnonymousTypeParameter> (parameters.Count);
 			foreach (AnonymousTypeParameter atp in parameters)
 				t.parameters.Add ((AnonymousTypeParameter) atp.Clone (clonectx));
 			foreach (AnonymousTypeParameter atp in parameters)
 				t.parameters.Add ((AnonymousTypeParameter) atp.Clone (clonectx));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="528" endline="559">
<![CDATA[
 
 		Module LoadModuleFile (AssemblyDefinitionDynamic assembly, string module)
 		{
 			string total_log = "";
 
 			try {
 				try {
 					return assembly.IncludeModule (module);
 				} catch (FileNotFoundException) {
 					bool err = true;
 					foreach (string dir in paths) {
 						string full_path = Path.Combine (dir, module);
 						if (!module.EndsWith (".netmodule"))
 							full_path += ".netmodule";
 
 						try {
 							return assembly.IncludeModule (full_path);
 						} catch (FileNotFoundException ff) {
 							total_log += ff.FusionLog;
 						}
 					}
 					foreach (string dir in paths) {
 						string full_path = Path.Combine (dir, module);
 						if (!module.EndsWith (".netmodule"))
 							full_path += ".netmodule";
 
 						try {
 							return assembly.IncludeModule (full_path);
 						} catch (FileNotFoundException ff) {
 							total_log += ff.FusionLog;
 						}
 					}
 					if (err) {
 						Error_FileNotFound (module);
 						return null;
 					}
 				}
 			} catch (BadImageFormatException) {
 				Error_FileCorrupted (module);
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="681" endline="706">
<![CDATA[
 
 		internal void PopulatePropertyAndEventTables()
 		{
 			if (properties != null)
 			{
 				PropertyMapTable.Record rec = new PropertyMapTable.Record();
 				rec.Parent = token;
 				rec.PropertyList = this.ModuleBuilder.Property.RowCount + 1;
 				this.ModuleBuilder.PropertyMap.AddRecord(rec);
 				foreach (PropertyBuilder pb in properties)
 				{
 					pb.Bake();
 				}
 				foreach (PropertyBuilder pb in properties)
 				{
 					pb.Bake();
 				}
 			}
 			if (events != null)
 			{
 				EventMapTable.Record rec = new EventMapTable.Record();
 				rec.Parent = token;
 				rec.EventList = this.ModuleBuilder.Event.RowCount + 1;
 				this.ModuleBuilder.EventMap.AddRecord(rec);
 				foreach (EventBuilder eb in events)
 				{
 					eb.Bake();
 				}
 				foreach (EventBuilder eb in events)
 				{
 					eb.Bake();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1326" endline="1351">
<![CDATA[
 
 		public void Emit ()
 		{
 			CheckTargets ();
 
 			Dictionary<Attribute, List<Attribute>> ld = Attrs.Count > 1 ? new Dictionary<Attribute, List<Attribute>> () 
 
 			foreach (Attribute a in Attrs)
 				a.Emit (ld);
 			foreach (Attribute a in Attrs)
 				a.Emit (ld);
 
 			if (ld == null || ld.Count == 0)
 				return;
 
 			foreach (var d in ld) {
 				if (d.Value == null)
 					continue;
 
 				Attribute a = d.Key;
 
 				foreach (Attribute collision in d.Value)
 					a.Report.SymbolRelatedToPreviousError (collision.Location, "");
 				foreach (Attribute collision in d.Value)
 					a.Report.SymbolRelatedToPreviousError (collision.Location, "");
 
 				a.Report.Error (579, a.Location, "The attribute `{0}' cannot be applied multiple times",
 					a.GetSignatureForError ());
 			}
 			foreach (var d in ld) {
 				if (d.Value == null)
 					continue;
 
 				Attribute a = d.Key;
 
 				foreach (Attribute collision in d.Value)
 					a.Report.SymbolRelatedToPreviousError (collision.Location, "");
 
 				a.Report.Error (579, a.Location, "The attribute `{0}' cannot be applied multiple times",
 					a.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1279" endline="1290">
<![CDATA[
 
 		/// <summary>
 		/// Checks whether attribute target is valid for the current element
 		/// </summary>
 		public bool CheckTargets ()
 		{
 			foreach (Attribute a in Attrs) {
 				if (!a.CheckTarget ())
 					return false;
 			}
 			foreach (Attribute a in Attrs) {
 				if (!a.CheckTarget ())
 					return false;
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="1217" endline="1229">
<![CDATA[
 
 		public void ExecuteUndo ()
 		{
 			if (undo_types == null)
 				return;
 
 			foreach (var p in undo_types){
 				TypeContainer current_container = p.Key;
 
 				current_container.RemoveTypeContainer (p.Value);
 			}
 			foreach (var p in undo_types){
 				TypeContainer current_container = p.Key;
 
 				current_container.RemoveTypeContainer (p.Value);
 			}
 			undo_types = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="760" endline="775">
<![CDATA[
 
 		internal void RenameAssembly(Assembly assembly, AssemblyName oldName)
 		{
 			List<string> remove = new List<string>();
 			foreach (KeyValuePair<string, Assembly> kv in assembliesByName)
 			{
 				if (kv.Value == assembly)
 				{
 					remove.Add(kv.Key);
 				}
 			}
 			foreach (KeyValuePair<string, Assembly> kv in assembliesByName)
 			{
 				if (kv.Value == assembly)
 				{
 					remove.Add(kv.Key);
 				}
 			}
 			foreach (string key in remove)
 			{
 				assembliesByName.Remove(key);
 			}
 			foreach (string key in remove)
 			{
 				assembliesByName.Remove(key);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="649" endline="677">
<![CDATA[
 
 		/// <summary>
 		/// Creates the instance of ObsoleteAttribute from this attribute instance
 		/// </summary>
 		public ObsoleteAttribute GetObsoleteAttribute ()
 		{
 			if (!arg_resolved) {
 				// corlib only case when obsolete is used before is resolved
 				var c = type.MemberDefinition as Class;
 				if (c != null && !c.HasMembersDefined)
 					c.Define ();
 				
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 			}
 
 			if (resolve_error)
 				return null;
 
 			if (PosArguments == null)
 				return new ObsoleteAttribute ();
 
 			string msg = ((Constant) PosArguments[0].Expr).GetValue () as string;
 			if (PosArguments.Count == 1)
 				return new ObsoleteAttribute (msg);
 
 			return new ObsoleteAttribute (msg, ((BoolConstant) PosArguments[1].Expr).Value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2328" endline="2356">
<![CDATA[
 		{
 			var tp = t as TypeParameterSpec;
 			if (tp != null) {
 				Variance v = tp.Variance;
 				if (expected == Variance.None && v != expected ||
 					expected == Variance.Covariant && v == Variance.Contravariant ||
 					expected == Variance.Contravariant && v == Variance.Covariant) {
 					((TypeParameter)tp.MemberDefinition).ErrorInvalidVariance (member, expected);
 				}
 
 				return expected;
 			}
 
 			if (t.TypeArguments.Length > 0) {
 				var targs_definition = t.MemberDefinition.TypeParameters;
 				TypeSpec[] targs = GetTypeArguments (t);
 				for (int i = 0; i < targs.Length; ++i) {
 					Variance v = targs_definition[i].Variance;
 					CheckTypeVariance (targs[i], (Variance) ((int)v * (int)expected), member);
 				}
 				for (int i = 0; i < targs.Length; ++i) {
 					Variance v = targs_definition[i].Variance;
 					CheckTypeVariance (targs[i], (Variance) ((int)v * (int)expected), member);
 				}
 
 				return expected;
 			}
 
 			if (t.IsArray)
 				return CheckTypeVariance (GetElementType (t), expected, member);
 
 			return Variance.None;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="612" endline="644">
<![CDATA[
 
 		void ReadData ()
 		{
 			if (creating)
 				throw new InvalidOperationException ();
 
 			lock (file) {
 				if (namespaces != null)
 					return;
 
 				MyBinaryReader reader = file.BinaryReader;
 				int old_pos = (int) reader.BaseStream.Position;
 
 				reader.BaseStream.Position = DataOffset;
 
 				int source_idx = reader.ReadLeb128 ();
 				source = file.GetSourceFile (source_idx);
 
 				int count_includes = reader.ReadLeb128 ();
 				if (count_includes > 0) {
 					include_files = new List<SourceFileEntry> ();
 					for (int i = 0; i < count_includes; i++)
 						include_files.Add (file.GetSourceFile (reader.ReadLeb128 ()));
 					for (int i = 0; i < count_includes; i++)
 						include_files.Add (file.GetSourceFile (reader.ReadLeb128 ()));
 				}
 
 				int count_ns = reader.ReadLeb128 ();
 				namespaces = new List<NamespaceEntry> ();
 				for (int i = 0; i < count_ns; i ++)
 					namespaces.Add (new NamespaceEntry (file, reader));
 				for (int i = 0; i < count_ns; i ++)
 					namespaces.Add (new NamespaceEntry (file, reader));
 
 				reader.BaseStream.Position = old_pos;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="849" endline="886">
<![CDATA[
 		}
 
 		public AParametersCollection Inflate (TypeParameterInflator inflator)
 		{
 			TypeSpec[] inflated_types = null;
 			bool default_value = false;
 
 			for (int i = 0; i < Count; ++i) {
 				var inflated_param = inflator.Inflate (types[i]);
 				if (inflated_types == null) {
 					if (inflated_param == types[i])
 						continue;
 
 					default_value |= FixedParameters[i] is DefaultValueExpression;
 					inflated_types = new TypeSpec[types.Length];
 					Array.Copy (types, inflated_types, types.Length);	
 				}
 
 				inflated_types[i] = inflated_param;
 			}
 			for (int i = 0; i < Count; ++i) {
 				var inflated_param = inflator.Inflate (types[i]);
 				if (inflated_types == null) {
 					if (inflated_param == types[i])
 						continue;
 
 					default_value |= FixedParameters[i] is DefaultValueExpression;
 					inflated_types = new TypeSpec[types.Length];
 					Array.Copy (types, inflated_types, types.Length);	
 				}
 
 				inflated_types[i] = inflated_param;
 			}
 
 			if (inflated_types == null)
 				return this;
 
 			var clone = (AParametersCollection) MemberwiseClone ();
 			clone.types = inflated_types;
 			if (default_value) {
 				for (int i = 0; i < Count; ++i) {
 					var dve = clone.FixedParameters[i] as DefaultValueExpression;
 					if (dve != null) {
 						throw new NotImplementedException ("net");
 						//	clone.FixedParameters [i].DefaultValue = new DefaultValueExpression ();
 					}
 				}
 				for (int i = 0; i < Count; ++i) {
 					var dve = clone.FixedParameters[i] as DefaultValueExpression;
 					if (dve != null) {
 						throw new NotImplementedException ("net");
 						//	clone.FixedParameters [i].DefaultValue = new DefaultValueExpression ();
 					}
 				}
 			}
 
 			return clone;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="480" endline="522">
<![CDATA[
 
 		Assembly LoadAssemblyFile (string assembly, bool soft)
 		{
 			Assembly a = null;
 
 			try {
 				try {
 					char[] path_chars = { '/', '\\' };
 
 					if (assembly.IndexOfAny (path_chars) != -1) {
 						a = Assembly.LoadFrom (assembly);
 					} else {
 						string ass = assembly;
 						if (ass.EndsWith (".dll") || ass.EndsWith (".exe"))
 							ass = assembly.Substring (0, assembly.Length - 4);
 						a = Assembly.Load (ass);
 					}
 				} catch (FileNotFoundException) {
 					bool err = !soft;
 					foreach (string dir in paths) {
 						string full_path = Path.Combine (dir, assembly);
 						if (!assembly.EndsWith (".dll") && !assembly.EndsWith (".exe"))
 							full_path += ".dll";
 
 						try {
 							a = Assembly.LoadFrom (full_path);
 							err = false;
 							break;
 						} catch (FileNotFoundException) {
 						}
 					}
 					foreach (string dir in paths) {
 						string full_path = Path.Combine (dir, assembly);
 						if (!assembly.EndsWith (".dll") && !assembly.EndsWith (".exe"))
 							full_path += ".dll";
 
 						try {
 							a = Assembly.LoadFrom (full_path);
 							err = false;
 							break;
 						} catch (FileNotFoundException) {
 						}
 					}
 
 					if (err) {
 						Error_FileNotFound (assembly);
 						return a;
 					}
 				}
 			} catch (BadImageFormatException) {
 				Error_FileCorrupted (assembly);
 			}
 
 			return a;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2714" endline="2755">
<![CDATA[
 
 		//
 		// All unfixed type variables Xi which depend on no Xj are fixed
 		//
 		public bool FixIndependentTypeArguments (ResolveContext ec, TypeSpec[] methodParameters, ref bool fixed_any)
 		{
 			var types_to_fix = new List<TypeSpec> (tp_args);
 			for (int i = 0; i < methodParameters.Length; ++i) {
 				TypeSpec t = methodParameters[i];
 
 				if (!TypeManager.IsDelegateType (t)) {
 					if (TypeManager.expression_type == null || t.MemberDefinition != TypeManager.expression_type.MemberDefinition)
 						continue;
 
 					t =  TypeManager.GetTypeArguments (t) [0];
 				}
 
 				if (t.IsGenericParameter)
 					continue;
 
 				var invoke = Delegate.GetInvokeMethod (ec.Compiler, t);
 				TypeSpec rtype = invoke.ReturnType;
 				if (!rtype.IsGenericParameter && !TypeManager.IsGenericType (rtype))
 					continue;
 
 				// Remove dependent types, they cannot be fixed yet
 				RemoveDependentTypes (types_to_fix, rtype);
 			}
 			for (int i = 0; i < methodParameters.Length; ++i) {
 				TypeSpec t = methodParameters[i];
 
 				if (!TypeManager.IsDelegateType (t)) {
 					if (TypeManager.expression_type == null || t.MemberDefinition != TypeManager.expression_type.MemberDefinition)
 						continue;
 
 					t =  TypeManager.GetTypeArguments (t) [0];
 				}
 
 				if (t.IsGenericParameter)
 					continue;
 
 				var invoke = Delegate.GetInvokeMethod (ec.Compiler, t);
 				TypeSpec rtype = invoke.ReturnType;
 				if (!rtype.IsGenericParameter && !TypeManager.IsGenericType (rtype))
 					continue;
 
 				// Remove dependent types, they cannot be fixed yet
 				RemoveDependentTypes (types_to_fix, rtype);
 			}
 
 			foreach (TypeSpec t in types_to_fix) {
 				if (t == null)
 					continue;
 
 				int idx = IsUnfixed (t);
 				if (idx >= 0 && !FixType (ec, idx)) {
 					return false;
 				}
 			}
 			foreach (TypeSpec t in types_to_fix) {
 				if (t == null)
 					continue;
 
 				int idx = IsUnfixed (t);
 				if (idx >= 0 && !FixType (ec, idx)) {
 					return false;
 				}
 			}
 
 			fixed_any = types_to_fix.Count > 0;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3262" endline="3304">
<![CDATA[
 
 		//
 		// Performs the basic sanity checks on the switch statement
 		// (looks for duplicate keys and non-constant expressions).
 		//
 		// It also returns a hashtable with the keys that we will later
 		// use to compute the switch tables
 		//
 		bool CheckSwitch (ResolveContext ec)
 		{
 			bool error = false;
 			Elements = new Dictionary<object, SwitchLabel> ();
 				
 			foreach (SwitchSection ss in Sections){
 				foreach (SwitchLabel sl in ss.Labels){
 					if (sl.Label == null){
 						if (default_section != null){
 							sl.Error_AlreadyOccurs (ec, SwitchType, (SwitchLabel)default_section.Labels [0]);
 							error = true;
 						}
 						default_section = ss;
 						continue;
 					}
 
 					if (!sl.ResolveAndReduce (ec, SwitchType, HaveUnwrap)) {
 						error = true;
 						continue;
 					}
 					
 					object key = sl.Converted;
 					if (key == SwitchLabel.NullStringCase)
 						has_null_case = true;
 
 					try {
 						Elements.Add (key, sl);
 					} catch (ArgumentException) {
 						sl.Error_AlreadyOccurs (ec, SwitchType, Elements [key]);
 						error = true;
 					}
 				}
 				foreach (SwitchLabel sl in ss.Labels){
 					if (sl.Label == null){
 						if (default_section != null){
 							sl.Error_AlreadyOccurs (ec, SwitchType, (SwitchLabel)default_section.Labels [0]);
 							error = true;
 						}
 						default_section = ss;
 						continue;
 					}
 
 					if (!sl.ResolveAndReduce (ec, SwitchType, HaveUnwrap)) {
 						error = true;
 						continue;
 					}
 					
 					object key = sl.Converted;
 					if (key == SwitchLabel.NullStringCase)
 						has_null_case = true;
 
 					try {
 						Elements.Add (key, sl);
 					} catch (ArgumentException) {
 						sl.Error_AlreadyOccurs (ec, SwitchType, Elements [key]);
 						error = true;
 					}
 				}
 			}
 			foreach (SwitchSection ss in Sections){
 				foreach (SwitchLabel sl in ss.Labels){
 					if (sl.Label == null){
 						if (default_section != null){
 							sl.Error_AlreadyOccurs (ec, SwitchType, (SwitchLabel)default_section.Labels [0]);
 							error = true;
 						}
 						default_section = ss;
 						continue;
 					}
 
 					if (!sl.ResolveAndReduce (ec, SwitchType, HaveUnwrap)) {
 						error = true;
 						continue;
 					}
 					
 					object key = sl.Converted;
 					if (key == SwitchLabel.NullStringCase)
 						has_null_case = true;
 
 					try {
 						Elements.Add (key, sl);
 					} catch (ArgumentException) {
 						sl.Error_AlreadyOccurs (ec, SwitchType, Elements [key]);
 						error = true;
 					}
 				}
 			}
 			return !error;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1041" endline="1076">
<![CDATA[
 
 		//
 		// Populates type parameter members using type parameter constraints
 		// The trick here is to be called late enough but not too late to
 		// populate member cache with all members from other types
 		//
 		protected override void InitializeMemberCache (bool onlyTypes)
 		{
 			cache = new MemberCache ();
 
 			//
 			// For a type parameter the membercache is the union of the sets of members of the types
 			// specified as a primary constraint or secondary constraint
 			//
 			if (BaseType != TypeManager.object_type && BaseType != TypeManager.value_type)
 				cache.AddBaseType (BaseType);
 
 			if (ifaces != null) {
 				foreach (var iface_type in Interfaces) {
 					cache.AddInterface (iface_type);
 				}
 				foreach (var iface_type in Interfaces) {
 					cache.AddInterface (iface_type);
 				}
 			}
 
 			if (targs != null) {
 				foreach (var ta in targs) {
 					if (ta.BaseType != TypeManager.object_type && ta.BaseType != TypeManager.value_type)
 						cache.AddBaseType (ta.BaseType);
 
 					if (ta.Interfaces != null) {
 						foreach (var iface_type in ta.Interfaces) {
 							cache.AddInterface (iface_type);
 						}
 						foreach (var iface_type in ta.Interfaces) {
 							cache.AddInterface (iface_type);
 						}
 					}
 				}
 				foreach (var ta in targs) {
 					if (ta.BaseType != TypeManager.object_type && ta.BaseType != TypeManager.value_type)
 						cache.AddBaseType (ta.BaseType);
 
 					if (ta.Interfaces != null) {
 						foreach (var iface_type in ta.Interfaces) {
 							cache.AddInterface (iface_type);
 						}
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1497" endline="1543">
<![CDATA[
 		
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!DefineParameters (parameters))
 				return false;
 
 			if (OptAttributes != null) {
 				Attribute indexer_attr = OptAttributes.Search (Module.PredefinedAttributes.IndexerName);
 				if (indexer_attr != null) {
 					var compiling = indexer_attr.Type.MemberDefinition as TypeContainer;
 					if (compiling != null)
 						compiling.Define ();
 
 					string name = indexer_attr.GetIndexerAttributeValue ();
 					if ((ModFlags & Modifiers.OVERRIDE) != 0) {
 						Report.Error (609, indexer_attr.Location,
 							"Cannot set the `IndexerName' attribute on an indexer marked override");
 					}
 
 					if (!string.IsNullOrEmpty (name))
 						ShortName = name;
 				}
 			}
 
 			if (InterfaceType != null) {
 				string base_IndexerName = InterfaceType.MemberDefinition.GetAttributeDefaultMember ();
 				if (base_IndexerName != Name)
 					ShortName = base_IndexerName;
 			}
 
 			if (!Parent.PartialContainer.AddMember (this))
 				return false;
 
 			flags |= MethodAttributes.HideBySig | MethodAttributes.SpecialName;
 			
 			if (!DefineAccessors ())
 				return false;
 
 			if (!CheckBase ())
 				return false;
 
 			DefineBuilders (MemberKind.Indexer, parameters);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="841" endline="849">
<![CDATA[
 
 		public override bool Define()
 		{
 			if (!base.Define ())
 				return false;
 
 			SetIsUsed ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="293" endline="310">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			string s;
 
 			if (IsNested) {
 				s = DeclaringType.GetSignatureForError ();
 			} else if (MemberDefinition is AnonymousTypeClass) {
 				return ((AnonymousTypeClass) MemberDefinition).GetSignatureForError ();
 			} else {
 				s = MemberDefinition.Namespace;
 			}
 
 			if (!string.IsNullOrEmpty (s))
 				s += ".";
 
 			return s + Name + GetTypeNameSignature ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2318" endline="2337">
<![CDATA[
 
 		public override void Emit ()
 		{
 			if (default_static_constructor == null && PartialContainer.HasStaticFieldInitializer) {
 				DefineDefaultConstructor (true);
 				default_static_constructor.Define ();
 			}
 
 			base.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					TypeBuilder.__AddDeclarativeSecurity (de);
 #else
 					TypeBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 				foreach (var de in declarative_security) {
 #if STATIC
 					TypeBuilder.__AddDeclarativeSecurity (de);
 #else
 					TypeBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2632" endline="2656">
<![CDATA[
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 
 			//
 			// When struct constains fixed fixed and struct layout has explicitly
 			// set CharSet, its value has to be propagated to compiler generated
 			// fixed types
 			//
 			if (a.Type == pa.StructLayout && Fields != null) {
 				var value = a.GetNamedValue ("CharSet");
 				if (value == null)
 					return;
 
 				for (int i = 0; i < Fields.Count; ++i) {
 					FixedField ff = Fields [i] as FixedField;
 					if (ff == null)
 						continue;
 
 					ff.CharSet = (CharSet) System.Enum.Parse (typeof (CharSet), value.GetValue ().ToString ());
 				}
 				for (int i = 0; i < Fields.Count; ++i) {
 					FixedField ff = Fields [i] as FixedField;
 					if (ff == null)
 						continue;
 
 					ff.CharSet = (CharSet) System.Enum.Parse (typeof (CharSet), value.GetValue ().ToString ());
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="319" endline="349">
<![CDATA[
 
 		public new void Define ()
 		{
 			builder = assembly.CreateModuleBuilder ();
 
 			// FIXME
 			static_data = null;
 
 			// TODO
 			// but that require DefineType clean-up
 			ResolveGlobalAttributes ();
 
 			foreach (TypeContainer tc in types)
 				tc.CreateType ();
 			foreach (TypeContainer tc in types)
 				tc.CreateType ();
 
 			InitializePredefinedTypes ();
 
 			foreach (TypeContainer tc in types)
 				tc.DefineType ();
 			foreach (TypeContainer tc in types)
 				tc.DefineType ();
 
 			foreach (TypeContainer tc in types)
 				tc.ResolveTypeParameters ();
 			foreach (TypeContainer tc in types)
 				tc.ResolveTypeParameters ();
 
 			foreach (TypeContainer tc in types) {
 				try {
 					tc.Define ();
 				} catch (Exception e) {
 					throw new InternalErrorException (tc, e);
 				}
 			}
 			foreach (TypeContainer tc in types) {
 				try {
 					tc.Define ();
 				} catch (Exception e) {
 					throw new InternalErrorException (tc, e);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="107" endline="154">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression expr_resolved = expr.Resolve (ec,
 				ResolveFlags.VariableOrValue | ResolveFlags.Type);
 
 			if (expr_resolved == null)
 				return null;
 
 			TypeSpec expr_type = expr_resolved.Type;
 			if (expr_type.IsPointer || expr_type == TypeManager.void_type || expr_type == InternalType.Null || expr_type == InternalType.AnonymousMethod) {
 				Unary.Error_OperatorCannotBeApplied (ec, loc, ".", expr_type);
 				return null;
 			}
 
 			if (targs != null) {
 				if (!targs.Resolve (ec))
 					return null;
 			}
 
 			var results = new List<string> ();
 			if (expr_resolved is Namespace){
 				Namespace nexpr = expr_resolved as Namespace;
 				string namespaced_partial;
 
 				if (partial_name == null)
 					namespaced_partial = nexpr.Name;
 				else
 					namespaced_partial = nexpr.Name + "." + partial_name;
 
 #if false
 				Console.WriteLine ("Workign with
 				foreach (var x in ec.TypeContainer.NamespaceEntry.CompletionGetTypesStartingWith (ec.TypeContainer, namespaced_partial)){
 					Console.WriteLine ("    {0}", x);
 				}
 #endif
 
 				CompletionSimpleName.AppendResults (
 					results,
 					partial_name, 
 					ec.CurrentMemberDefinition.Parent.NamespaceEntry.CompletionGetTypesStartingWith (namespaced_partial));
 			} else {
 				var r = MemberCache.GetCompletitionMembers (expr_type, partial_name).Select (l => l.Name);
 				AppendResults (results, partial_name, r);
 			}
 
 			throw new CompletionResult (partial_name == null ? "" 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="350" endline="379">
<![CDATA[
 
 		public override void Emit ()
 		{
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (RootContext.Unsafe) {
 				var pa = PredefinedAttributes.UnverifiableCode;
 				if (pa.IsDefined)
 					pa.EmitAttribute (builder);
 			}
 
 			foreach (var tc in types)
 				tc.DefineConstants ();
 			foreach (var tc in types)
 				tc.DefineConstants ();
 
 			HackCorlib ();
 
 			foreach (TypeContainer tc in types)
 				tc.EmitType ();
 			foreach (TypeContainer tc in types)
 				tc.EmitType ();
 
 			if (Compiler.Report.Errors > 0)
 				return;
 
 			foreach (TypeContainer tc in types)
 				tc.VerifyMembers ();
 			foreach (TypeContainer tc in types)
 				tc.VerifyMembers ();
 
 			if (compiler_generated != null)
 				foreach (var c in compiler_generated)
 					c.EmitType ();
 				foreach (var c in compiler_generated)
 					c.EmitType ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="243" endline="280">
<![CDATA[
 
 		//
 		// Member-cache does not contain base members but it does
 		// contain all base interface members, so the Lookup code
 		// can use simple inheritance rules.
 		//
 		public void AddInterface (TypeSpec iface)
 		{
 			var cache = iface.MemberCache;
 
 			IList<MemberSpec> list;
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (AddInterfaceMember (ce, ref list))
 						member_hash[entry.Key] = list;
 				}
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (AddInterfaceMember (ce, ref list))
 						member_hash[entry.Key] = list;
 				}
 			}
 			foreach (var entry in cache.member_hash) {
 				if (!member_hash.TryGetValue (entry.Key, out list)) {
 					if (entry.Value.Count == 1) {
 						list = entry.Value;
 					} else {
 						list = new List<MemberSpec> (entry.Value);
 					}
 
 					member_hash.Add (entry.Key, list);
 					continue;
 				}
 
 				foreach (var ce in entry.Value) {
 					if (list.Contains (ce))
 						continue;
 
 					if (AddInterfaceMember (ce, ref list))
 						member_hash[entry.Key] = list;
 				}
 			}
 
 			// Add also all base interfaces
 			if (iface.Interfaces != null) {
 				foreach (var base_iface in iface.Interfaces)
 					AddInterface (base_iface);
 				foreach (var base_iface in iface.Interfaces)
 					AddInterface (base_iface);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2185" endline="2194">
<![CDATA[
 
 		public override FieldInfo[] __GetDeclaredFields()
 		{
 			FieldInfo[] fields = type.__GetDeclaredFields();
 			for (int i = 0; i < fields.Length; i++)
 			{
 				fields[i] = fields[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < fields.Length; i++)
 			{
 				fields[i] = fields[i].BindTypeParameters(this);
 			}
 			return fields;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2195" endline="2204">
<![CDATA[
 
 		public override Type[] __GetDeclaredInterfaces()
 		{
 			Type[] interfaces = type.__GetDeclaredInterfaces();
 			for (int i = 0; i < interfaces.Length; i++)
 			{
 				interfaces[i] = interfaces[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < interfaces.Length; i++)
 			{
 				interfaces[i] = interfaces[i].BindTypeParameters(this);
 			}
 			return interfaces;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2205" endline="2214">
<![CDATA[
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			MethodBase[] methods = type.__GetDeclaredMethods();
 			for (int i = 0; i < methods.Length; i++)
 			{
 				methods[i] = methods[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < methods.Length; i++)
 			{
 				methods[i] = methods[i].BindTypeParameters(this);
 			}
 			return methods;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2220" endline="2229">
<![CDATA[
 
 		public override EventInfo[] __GetDeclaredEvents()
 		{
 			EventInfo[] events = type.__GetDeclaredEvents();
 			for (int i = 0; i < events.Length; i++)
 			{
 				events[i] = events[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < events.Length; i++)
 			{
 				events[i] = events[i].BindTypeParameters(this);
 			}
 			return events;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2230" endline="2239">
<![CDATA[
 
 		public override PropertyInfo[] __GetDeclaredProperties()
 		{
 			PropertyInfo[] properties = type.__GetDeclaredProperties();
 			for (int i = 0; i < properties.Length; i++)
 			{
 				properties[i] = properties[i].BindTypeParameters(this);
 			}
 			for (int i = 0; i < properties.Length; i++)
 			{
 				properties[i] = properties[i].BindTypeParameters(this);
 			}
 			return properties;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ConstructorInfo.cs" startline="49" endline="59">
<![CDATA[
 		}
 
 		public sealed override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = GetMethodInfo().GetParameters();
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoWrapper(this, parameters[i]);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new ParameterInfoWrapper(this, parameters[i]);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="444" endline="464">
<![CDATA[
 
 		static void AddKeyword<T> (KeywordEntry<T>[][] keywords, string kw, T token)
 		{
 			int length = kw.Length;
 			if (keywords[length] == null) {
 				keywords[length] = new KeywordEntry<T>['z' - '_' + 1];
 			}
 
 			int char_index = kw[0] - '_';
 			var kwe = keywords[length][char_index];
 			if (kwe == null) {
 				keywords[length][char_index] = new KeywordEntry<T> (kw, token);
 				return;
 			}
 
 			while (kwe.Next != null) {
 				kwe = kwe.Next;
 			}
 			while (kwe.Next != null) {
 				kwe = kwe.Next;
 			}
 
 			kwe.Next = new KeywordEntry<T> (kw, token);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="936" endline="966">
<![CDATA[
 	
 	static int CompareMethodBase (object a, object b)
 	{
 		MethodBase aa = (MethodBase) a, bb = (MethodBase) b;
 		
 		if (aa.IsStatic == bb.IsStatic) {
 			int c = CompareMemberInfo (a, b);
 			if (c != 0)
 				return c;
 			ParameterInfo [] ap, bp;
 
 			//
 			// Sort overloads by the names of their types
 			// put methods with fewer params first.
 			//
 			
 			ap = aa.GetParameters ();
 			bp = bb.GetParameters ();
 			int n = System.Math.Min (ap.Length, bp.Length);
 
 			for (int i = 0; i < n; i ++)
 				if ((c = CompareType (ap [i].ParameterType, bp [i].ParameterType)) != 0)
 					return c;
 			for (int i = 0; i < n; i ++)
 				if ((c = CompareType (ap [i].ParameterType, bp [i].ParameterType)) != 0)
 					return c;
 
 			return ap.Length.CompareTo (bp.Length);
 		}
 		if (aa.IsStatic)
 			return -1;
 		
 		return 1;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1085" endline="1129">
<![CDATA[
 
 		//
 		// Is this member accessible from invocationType
 		//
 		public bool IsAccessible (TypeSpec invocationType)
 		{
 			var ma = Modifiers & Modifiers.AccessibilityMask;
 			if (ma == Modifiers.PUBLIC)
 				return true;
 
 			var parentType = /* this as TypeSpec ?? */ DeclaringType;
 
 			// It's null for module context
 			if (invocationType == null)
 				invocationType = InternalType.FakeInternalType;
 		
 			//
 			// If only accessible to the current class or children
 			//
 			if (ma == Modifiers.PRIVATE)
 				return invocationType.MemberDefinition == parentType.MemberDefinition ||
 					TypeManager.IsNestedChildOf (invocationType, parentType.MemberDefinition);
 
 			if ((ma & Modifiers.INTERNAL) != 0) {
 				bool b;
 				var assembly = invocationType == InternalType.FakeInternalType ?
 					RootContext.ToplevelTypes.DeclaringAssembly 
 					invocationType.MemberDefinition.DeclaringAssembly;
 
 				if (parentType == null) {
 					b = ((ITypeDefinition) MemberDefinition).IsInternalAsPublic (assembly);
 				} else {
 					b = DeclaringType.MemberDefinition.IsInternalAsPublic (assembly);
 				}
 
 				if (b || ma == Modifiers.INTERNAL)
 					return b;
 			}
 
 			// PROTECTED
 			if (!TypeManager.IsNestedFamilyAccessible (invocationType, parentType))
 				return false;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="98" endline="147">
<![CDATA[
 
 		struct MissingInterfacesInfo {
 			public TypeSpec Type;
 			public bool Optional;
 
 			public MissingInterfacesInfo (TypeSpec t)
 			{
 				Type = t;
 				Optional = false;
 			}
 		}
 
 		static MissingInterfacesInfo [] EmptyMissingInterfacesInfo = new MissingInterfacesInfo [0];
 		
 		static MissingInterfacesInfo [] GetMissingInterfaces (TypeContainer container)
 		{
 			//
 			// Notice that Interfaces will only return the interfaces that the Type
 			// is supposed to implement, not all the interfaces that the type implements.
 			//
 			var impl = container.Definition.Interfaces;
 
 			if (impl == null || impl.Count == 0)
 				return EmptyMissingInterfacesInfo;
 
 			MissingInterfacesInfo[] ret = new MissingInterfacesInfo[impl.Count];
 
 			for (int i = 0; i < impl.Count; i++)
 				ret [i] = new MissingInterfacesInfo (impl [i]);
 			for (int i = 0; i < impl.Count; i++)
 				ret [i] = new MissingInterfacesInfo (impl [i]);
 
 			// we really should not get here because Object doesnt implement any
 			// interfaces. But it could implement something internal, so we have
 			// to handle that case.
 			if (container.BaseType == null)
 				return ret;
 			
 			var base_impls = container.BaseType.Interfaces;
 			if (base_impls != null) {
 				foreach (TypeSpec t in base_impls) {
 					for (int i = 0; i < ret.Length; i++) {
 						if (t == ret[i].Type) {
 							ret[i].Optional = true;
 							break;
 						}
 					}
 					for (int i = 0; i < ret.Length; i++) {
 						if (t == ret[i].Type) {
 							ret[i].Optional = true;
 							break;
 						}
 					}
 				}
 				foreach (TypeSpec t in base_impls) {
 					for (int i = 0; i < ret.Length; i++) {
 						if (t == ret[i].Type) {
 							ret[i].Optional = true;
 							break;
 						}
 					}
 				}
 			}
 
 			return ret;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="243" endline="268">
<![CDATA[
 
 		protected override void WriteImpl(MetadataWriter mw)
 		{
 			mw.Write((byte)0);
 			foreach (string str in list)
 			{
 				mw.WriteCompressedInt(str.Length * 2 + 1);
 				byte hasSpecialChars = 0;
 				foreach (char ch in str)
 				{
 					mw.Write((ushort)ch);
 					if (hasSpecialChars == 0 && (ch < 0x20 || ch > 0x7E))
 					{
 						if (ch > 0x7E
 							|| (ch >= 0x01 && ch <= 0x08)
 							|| (ch >= 0x0E && ch <= 0x1F)
 							|| ch == 0x27
 							|| ch == 0x2D)
 						{
 							hasSpecialChars = 1;
 						}
 					}
 				}
 				foreach (char ch in str)
 				{
 					mw.Write((ushort)ch);
 					if (hasSpecialChars == 0 && (ch < 0x20 || ch > 0x7E))
 					{
 						if (ch > 0x7E
 							|| (ch >= 0x01 && ch <= 0x08)
 							|| (ch >= 0x0E && ch <= 0x1F)
 							|| ch == 0x27
 							|| ch == 0x2D)
 						{
 							hasSpecialChars = 1;
 						}
 					}
 				}
 				mw.Write(hasSpecialChars);
 			}
 			foreach (string str in list)
 			{
 				mw.WriteCompressedInt(str.Length * 2 + 1);
 				byte hasSpecialChars = 0;
 				foreach (char ch in str)
 				{
 					mw.Write((ushort)ch);
 					if (hasSpecialChars == 0 && (ch < 0x20 || ch > 0x7E))
 					{
 						if (ch > 0x7E
 							|| (ch >= 0x01 && ch <= 0x08)
 							|| (ch >= 0x0E && ch <= 0x1F)
 							|| ch == 0x27
 							|| ch == 0x2D)
 						{
 							hasSpecialChars = 1;
 						}
 					}
 				}
 				mw.Write(hasSpecialChars);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="913" endline="948">
<![CDATA[
 
 		static string FriendlyStackTrace (StackTrace t)
 		{		
 			StringBuilder sb = new StringBuilder ();
 			
 			bool foundUserCode = false;
 			
 			for (int i = 0; i < t.FrameCount; i++) {
 				StackFrame f = t.GetFrame (i);
 				var mb = f.GetMethod ();
 				
 				if (!foundUserCode && mb.ReflectedType == typeof (Report))
 					continue;
 				
 				foundUserCode = true;
 				
 				sb.Append ("\tin ");
 				
 				if (f.GetFileLineNumber () > 0)
 					sb.AppendFormat ("(at {0}
 				
 				sb.AppendFormat ("{0}.{1} (", mb.ReflectedType.Name, mb.Name);
 				
 				bool first = true;
 				foreach (var pi in mb.GetParameters ()) {
 					if (!first)
 						sb.Append (", ");
 					first = false;
 
 					sb.Append (pi.ParameterType.FullName);
 				}
 				foreach (var pi in mb.GetParameters ()) {
 					if (!first)
 						sb.Append (", ");
 					first = false;
 
 					sb.Append (pi.ParameterType.FullName);
 				}
 				sb.Append (")\n");
 			}
 			for (int i = 0; i < t.FrameCount; i++) {
 				StackFrame f = t.GetFrame (i);
 				var mb = f.GetMethod ();
 				
 				if (!foundUserCode && mb.ReflectedType == typeof (Report))
 					continue;
 				
 				foundUserCode = true;
 				
 				sb.Append ("\tin ");
 				
 				if (f.GetFileLineNumber () > 0)
 					sb.AppendFormat ("(at {0}
 				
 				sb.AppendFormat ("{0}.{1} (", mb.ReflectedType.Name, mb.Name);
 				
 				bool first = true;
 				foreach (var pi in mb.GetParameters ()) {
 					if (!first)
 						sb.Append (", ");
 					first = false;
 
 					sb.Append (pi.ParameterType.FullName);
 				}
 				sb.Append (")\n");
 			}
 	
 			return sb.ToString ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1714" endline="1755">
<![CDATA[
 
 		/// <summary>
 		///   Resolve the type arguments.
 		/// </summary>
 		public virtual bool Resolve (IMemberContext ec)
 		{
 			if (atypes != null)
 			    return atypes.Length != 0;
 
 			int count = args.Count;
 			bool ok = true;
 
 			atypes = new TypeSpec [count];
 
 			for (int i = 0; i < count; i++){
 				TypeExpr te = args[i].ResolveAsTypeTerminal (ec, false);
 				if (te == null) {
 					ok = false;
 					continue;
 				}
 
 				atypes[i] = te.Type;
 
 				if (te.Type.IsStatic) {
 					ec.Compiler.Report.Error (718, te.Location, "`{0}'
 						te.GetSignatureForError ());
 					ok = false;
 				}
 
 				if (te.Type.IsPointer || TypeManager.IsSpecialType (te.Type)) {
 					ec.Compiler.Report.Error (306, te.Location,
 						"The type `{0}' may not be used as a type argument",
 						te.GetSignatureForError ());
 					ok = false;
 				}
 			}
 			for (int i = 0; i < count; i++){
 				TypeExpr te = args[i].ResolveAsTypeTerminal (ec, false);
 				if (te == null) {
 					ok = false;
 					continue;
 				}
 
 				atypes[i] = te.Type;
 
 				if (te.Type.IsStatic) {
 					ec.Compiler.Report.Error (718, te.Location, "`{0}'
 						te.GetSignatureForError ());
 					ok = false;
 				}
 
 				if (te.Type.IsPointer || TypeManager.IsSpecialType (te.Type)) {
 					ec.Compiler.Report.Error (306, te.Location,
 						"The type `{0}' may not be used as a type argument",
 						te.GetSignatureForError ());
 					ok = false;
 				}
 			}
 
 			if (!ok)
 				atypes = TypeSpec.EmptyTypes;
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="172" endline="216">
<![CDATA[
 
 		internal static PropertySignature ReadSig(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			byte flags = br.ReadByte();
 			if ((flags & PROPERTY) == 0)
 			{
 				throw new BadImageFormatException();
 			}
 			CallingConventions callingConvention = CallingConventions.Standard;
 			if ((flags & HASTHIS) != 0)
 			{
 				callingConvention |= CallingConventions.HasThis;
 			}
 			if ((flags & EXPLICITTHIS) != 0)
 			{
 				callingConvention |= CallingConventions.ExplicitThis;
 			}
 			Type returnType;
 			Type[] returnTypeRequiredCustomModifiers;
 			Type[] returnTypeOptionalCustomModifiers;
 			Type[] parameterTypes;
 			Type[][] parameterRequiredCustomModifiers;
 			Type[][] parameterOptionalCustomModifiers;
 			int paramCount = br.ReadCompressedInt();
 			ReadCustomModifiers(module, br, context, out returnTypeRequiredCustomModifiers, out returnTypeOptionalCustomModifiers);
 			returnType = ReadRetType(module, br, context);
 			parameterTypes = new Type[paramCount];
 			parameterRequiredCustomModifiers = null;
 			parameterOptionalCustomModifiers = null;
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if (IsCustomModifier(br.PeekByte()))
 				{
 					if (parameterOptionalCustomModifiers == null)
 					{
 						parameterOptionalCustomModifiers = new Type[parameterTypes.Length][];
 						parameterRequiredCustomModifiers = new Type[parameterTypes.Length][];
 					}
 					ReadCustomModifiers(module, br, context, out parameterRequiredCustomModifiers[i], out parameterOptionalCustomModifiers[i]);
 				}
 				parameterTypes[i] = ReadParam(module, br, context);
 			}
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if (IsCustomModifier(br.PeekByte()))
 				{
 					if (parameterOptionalCustomModifiers == null)
 					{
 						parameterOptionalCustomModifiers = new Type[parameterTypes.Length][];
 						parameterRequiredCustomModifiers = new Type[parameterTypes.Length][];
 					}
 					ReadCustomModifiers(module, br, context, out parameterRequiredCustomModifiers[i], out parameterOptionalCustomModifiers[i]);
 				}
 				parameterTypes[i] = ReadParam(module, br, context);
 			}
 			return new PropertySignature(callingConvention, returnType, returnTypeOptionalCustomModifiers, returnTypeRequiredCustomModifiers,
 				parameterTypes, parameterOptionalCustomModifiers, parameterRequiredCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2683" endline="2727">
<![CDATA[
 
 		//
 		// 7.2.6.2 Binary numeric promotions
 		//
 		public bool DoBinaryOperatorPromotion (ResolveContext ec)
 		{
 			TypeSpec ltype = left.Type;
 			TypeSpec rtype = right.Type;
 			Expression temp;
 
 			foreach (TypeSpec t in ConstantFold.BinaryPromotionsTypes) {
 				if (t == ltype)
 					return t == rtype || DoNumericPromotion (ec, ref right, ref left, t);
 
 				if (t == rtype)
 					return t == ltype || DoNumericPromotion (ec, ref left, ref right, t);
 			}
 			foreach (TypeSpec t in ConstantFold.BinaryPromotionsTypes) {
 				if (t == ltype)
 					return t == rtype || DoNumericPromotion (ec, ref right, ref left, t);
 
 				if (t == rtype)
 					return t == ltype || DoNumericPromotion (ec, ref left, ref right, t);
 			}
 
 			TypeSpec int32 = TypeManager.int32_type;
 			if (ltype != int32) {
 				Constant c = left as Constant;
 				if (c != null)
 					temp = c.ConvertImplicitly (ec, int32);
 				else
 					temp = Convert.ImplicitNumericConversion (left, int32);
 
 				if (temp == null)
 					return false;
 				left = temp;
 			}
 
 			if (rtype != int32) {
 				Constant c = right as Constant;
 				if (c != null)
 					temp = c.ConvertImplicitly (ec, int32);
 				else
 					temp = Convert.ImplicitNumericConversion (right, int32);
 
 				if (temp == null)
 					return false;
 				right = temp;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="711" endline="766">
<![CDATA[
 
 		//
 		// Unary user type overload resolution
 		//
 		Expression ResolveUserType (ResolveContext ec, Expression expr)
 		{
 			Expression best_expr = ResolveUserOperator (ec, expr);
 			if (best_expr != null)
 				return best_expr;
 
 			TypeSpec[] predefined = predefined_operators [(int) Oper];
 			foreach (TypeSpec t in predefined) {
 				Expression oper_expr = Convert.ImplicitUserConversion (ec, expr, t, expr.Location);
 				if (oper_expr == null)
 					continue;
 
 				//
 				// decimal type is predefined but has user-operators
 				//
 				if (oper_expr.Type == TypeManager.decimal_type)
 					oper_expr = ResolveUserType (ec, oper_expr);
 				else
 					oper_expr = ResolvePrimitivePredefinedType (oper_expr);
 
 				if (oper_expr == null)
 					continue;
 
 				if (best_expr == null) {
 					best_expr = oper_expr;
 					continue;
 				}
 
 				int result = OverloadResolver.BetterTypeConversion (ec, best_expr.Type, t);
 				if (result == 0) {
 					ec.Report.Error (35, loc, "Operator `{0}' is ambiguous on an operand of type `{1}'",
 						OperName (Oper), TypeManager.CSharpName (expr.Type));
 					break;
 				}
 
 				if (result == 2)
 					best_expr = oper_expr;
 			}
 			foreach (TypeSpec t in predefined) {
 				Expression oper_expr = Convert.ImplicitUserConversion (ec, expr, t, expr.Location);
 				if (oper_expr == null)
 					continue;
 
 				//
 				// decimal type is predefined but has user-operators
 				//
 				if (oper_expr.Type == TypeManager.decimal_type)
 					oper_expr = ResolveUserType (ec, oper_expr);
 				else
 					oper_expr = ResolvePrimitivePredefinedType (oper_expr);
 
 				if (oper_expr == null)
 					continue;
 
 				if (best_expr == null) {
 					best_expr = oper_expr;
 					continue;
 				}
 
 				int result = OverloadResolver.BetterTypeConversion (ec, best_expr.Type, t);
 				if (result == 0) {
 					ec.Report.Error (35, loc, "Operator `{0}' is ambiguous on an operand of type `{1}'",
 						OperName (Oper), TypeManager.CSharpName (expr.Type));
 					break;
 				}
 
 				if (result == 2)
 					best_expr = oper_expr;
 			}
 			
 			if (best_expr == null)
 				return null;
 			
 			//
 			// HACK
 			//
 			if (best_expr.Type == TypeManager.decimal_type)
 				return best_expr;			
 
 			Expr = best_expr;
 			type = best_expr.Type;
 			return this;			
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6498" endline="6550">
<![CDATA[
 
 		//
 		// Emits pieces of the array that can not be computed at compile
 		// time (variables and string locations).
 		//
 		// This always expect the top value on the stack to be the array
 		//
 		void EmitDynamicInitializers (EmitContext ec, bool emitConstants)
 		{
 			int dims = bounds.Count;
 			var current_pos = new int [dims];
 
 			for (int i = 0; i < array_data.Count; i++){
 
 				Expression e = array_data [i];
 				var c = e as Constant;
 
 				// Constant can be initialized via StaticInitializer
 				if (c == null || (c != null && emitConstants && !c.IsDefaultInitializer (array_element_type))) {
 					TypeSpec etype = e.Type;
 
 					ec.Emit (OpCodes.Dup);
 
 					for (int idx = 0; idx < dims; idx++) 
 						ec.EmitInt (current_pos [idx]);
 					for (int idx = 0; idx < dims; idx++) 
 						ec.EmitInt (current_pos [idx]);
 
 					//
 					// If we are dealing with a struct, get the
 					// address of it, so we can store it.
 					//
 					if ((dims == 1) && TypeManager.IsStruct (etype) &&
 					    (!TypeManager.IsBuiltinOrEnum (etype) ||
 					     etype == TypeManager.decimal_type)) {
 
 						ec.Emit (OpCodes.Ldelema, etype);
 					}
 
 					e.Emit (ec);
 
 					ec.EmitArrayStore ((ArrayContainer) type);
 				}
 				
 				//
 				// Advance counter
 				//
 				for (int j = dims - 1; j >= 0; j--){
 					current_pos [j]++;
 					if (current_pos [j] < bounds [j])
 						break;
 					current_pos [j] = 0;
 				}
 				for (int j = dims - 1; j >= 0; j--){
 					current_pos [j]++;
 					if (current_pos [j] < bounds [j])
 						break;
 					current_pos [j] = 0;
 				}
 			}
 			for (int i = 0; i < array_data.Count; i++){
 
 				Expression e = array_data [i];
 				var c = e as Constant;
 
 				// Constant can be initialized via StaticInitializer
 				if (c == null || (c != null && emitConstants && !c.IsDefaultInitializer (array_element_type))) {
 					TypeSpec etype = e.Type;
 
 					ec.Emit (OpCodes.Dup);
 
 					for (int idx = 0; idx < dims; idx++) 
 						ec.EmitInt (current_pos [idx]);
 
 					//
 					// If we are dealing with a struct, get the
 					// address of it, so we can store it.
 					//
 					if ((dims == 1) && TypeManager.IsStruct (etype) &&
 					    (!TypeManager.IsBuiltinOrEnum (etype) ||
 					     etype == TypeManager.decimal_type)) {
 
 						ec.Emit (OpCodes.Ldelema, etype);
 					}
 
 					e.Emit (ec);
 
 					ec.EmitArrayStore ((ArrayContainer) type);
 				}
 				
 				//
 				// Advance counter
 				//
 				for (int j = dims - 1; j >= 0; j--){
 					current_pos [j]++;
 					if (current_pos [j] < bounds [j])
 						break;
 					current_pos [j] = 0;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="585" endline="620">
<![CDATA[
 
 		public MethodInfo[] GetMethods(BindingFlags bindingAttr)
 		{
 			CheckBaked();
 			List<MethodInfo> list = new List<MethodInfo>();
 			foreach (MethodBase mb in __GetDeclaredMethods())
 			{
 				MethodInfo mi = mb as MethodInfo;
 				if (mi != null
 					&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(mi);
 				}
 			}
 			foreach (MethodBase mb in __GetDeclaredMethods())
 			{
 				MethodInfo mi = mb as MethodInfo;
 				if (mi != null
 					&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 					&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static, BindingFlags.Instance))
 				{
 					list.Add(mi);
 				}
 			}
 			if ((bindingAttr & BindingFlags.DeclaredOnly) == 0)
 			{
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (MethodBase mb in type.__GetDeclaredMethods())
 					{
 						MethodInfo mi = mb as MethodInfo;
 						if (mi != null
 							&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
 							&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 							&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
 							&& !FindMethod(list, mi))
 						{
 							list.Add(mi);
 						}
 					}
 					foreach (MethodBase mb in type.__GetDeclaredMethods())
 					{
 						MethodInfo mi = mb as MethodInfo;
 						if (mi != null
 							&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
 							&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 							&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
 							&& !FindMethod(list, mi))
 						{
 							list.Add(mi);
 						}
 					}
 				}
 				for (Type type = this.BaseType; type != null; type = type.BaseType)
 				{
 					type.CheckBaked();
 					foreach (MethodBase mb in type.__GetDeclaredMethods())
 					{
 						MethodInfo mi = mb as MethodInfo;
 						if (mi != null
 							&& (mi.Attributes & MethodAttributes.MemberAccessMask) > MethodAttributes.Private
 							&& BindingFlagsMatch(mi.IsPublic, bindingAttr, BindingFlags.Public, BindingFlags.NonPublic)
 							&& BindingFlagsMatch(mi.IsStatic, bindingAttr, BindingFlags.Static | BindingFlags.FlattenHierarchy, BindingFlags.Instance)
 							&& !FindMethod(list, mi))
 						{
 							list.Add(mi);
 						}
 					}
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="94" endline="150">
<![CDATA[
 
 		public static Expression ImplicitTypeParameterConversion (Expression expr, TypeSpec target_type)
 		{
 			var expr_type = (TypeParameterSpec) expr.Type;
 
 			//
 			// From T to a type parameter U, provided T depends on U
 			//
 			var ttype = target_type as TypeParameterSpec;
 			if (ttype != null) {
 				if (expr_type.TypeArguments != null) {
 					foreach (var targ in expr_type.TypeArguments) {
 						if (!TypeSpecComparer.Override.IsEqual (ttype, targ))
 							continue;
 
 						if (expr_type.IsReferenceType && !ttype.IsReferenceType)
 							return new BoxedCast (expr, target_type);
 
 						return new ClassCast (expr, target_type);
 					foreach (var targ in expr_type.TypeArguments) {
 						if (!TypeSpecComparer.Override.IsEqual (ttype, targ))
 							continue;
 
 						if (expr_type.IsReferenceType && !ttype.IsReferenceType)
 							return new BoxedCast (expr, target_type);
 
 						return new ClassCast (expr, target_type);
 					}
 				}
 
 				return null;
 			}
 
 			//
 			// LAMESPEC
 			//
 			if (target_type == InternalType.Dynamic) {
 				if (expr_type.IsReferenceType)
 					return new ClassCast (expr, target_type);
 
 				return new BoxedCast (expr, target_type);
 			}
 
 			//
 			// From T to its effective base class C
 			// From T to any base class of C (it cannot contain dynamic of be of dynamic type)
 			// From T to any interface implemented by C
 			//
 			var base_type = expr_type.GetEffectiveBase ();
 			if (base_type == target_type || TypeSpec.IsBaseClass (base_type, target_type, false) || base_type.ImplementsInterface (target_type, true)) {
 				if (expr_type.IsReferenceType)
 					return new ClassCast (expr, target_type);
 
 				return new BoxedCast (expr, target_type);
 			}
 
 			if (target_type.IsInterface && expr_type.IsConvertibleToInterface (target_type)) {
 				if (expr_type.IsReferenceType)
 					return new ClassCast (expr, target_type);
 
 				return new BoxedCast (expr, target_type);
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="244" endline="278">
<![CDATA[
 #else
 			ResolveAssemblySecurityAttributes ();
 			var an = CreateAssemblyName ();
 
 			try {
 				Builder = file_name == null ?
 					domain.DefineDynamicAssembly (an, access) 
 					domain.DefineDynamicAssembly (an, access, Dirname (file_name));
 			} catch (ArgumentException) {
 				// specified key may not be exportable outside it's container
 				if (RootContext.StrongNameKeyContainer != null) {
 					Report.Error (1548, "Could not access the key inside the container `" +
 						RootContext.StrongNameKeyContainer + "'.");
 				}
 				throw;
 			}
 
 			builder_extra = new AssemblyBuilderMonoSpecific (Builder, Compiler);
 			return true;
 #endif
 		}
 
 		static string Dirname (string name)
 		{
 			int pos = name.LastIndexOf ('/');
 
 			if (pos != -1)
 				return name.Substring (0, pos);
 
 			pos = name.LastIndexOf ('\\');
 			if (pos != -1)
 				return name.Substring (0, pos);
 
 			return ".";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="936" endline="947">
<![CDATA[
 
 		public FullNamedExpression LookupNamespaceOrType (string name, int arity, Location loc, bool ignore_cs0104)
 		{
 			// Precondition
 			FullNamedExpression resolved = null;
 			for (NamespaceEntry curr_ns = this; curr_ns != null; curr_ns = curr_ns.ImplicitParent) {
 				if ((resolved = curr_ns.Lookup (name, arity, loc, ignore_cs0104)) != null)
 					break;
 			}
 			for (NamespaceEntry curr_ns = this; curr_ns != null; curr_ns = curr_ns.ImplicitParent) {
 				if ((resolved = curr_ns.Lookup (name, arity, loc, ignore_cs0104)) != null)
 					break;
 			}
 
 			return resolved;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1970" endline="1989">
<![CDATA[
 
 		public void EmitAttribute (ParameterBuilder builder, decimal value, Location loc)
 		{
 			if (Resolve (loc) == null)
 				return;
 
 			if (ctor == null && !ResolveConstructor (loc, TypeManager.byte_type, TypeManager.byte_type, TypeManager.uint32_type, TypeManager.uint32_type, TypeManager.uint32_type))
 				return;
 
 			int[] bits = decimal.GetBits (value);
 			AttributeEncoder encoder = new AttributeEncoder ();
 			encoder.Encode ((byte) (bits[3] >> 16));
 			encoder.Encode ((byte) (bits[3] >> 31));
 			encoder.Encode ((uint) bits[2]);
 			encoder.Encode ((uint) bits[1]);
 			encoder.Encode ((uint) bits[0]);
 			encoder.EncodeEmptyNamedArguments ();
 
 			EmitAttribute (builder, encoder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1990" endline="2009">
<![CDATA[
 
 		public void EmitAttribute (FieldBuilder builder, decimal value, Location loc)
 		{
 			if (Resolve (loc) == null)
 				return;
 
 			if (ctor == null && !ResolveConstructor (loc, TypeManager.byte_type, TypeManager.byte_type, TypeManager.uint32_type, TypeManager.uint32_type, TypeManager.uint32_type))
 				return;
 
 			int[] bits = decimal.GetBits (value);
 			AttributeEncoder encoder = new AttributeEncoder ();
 			encoder.Encode ((byte) (bits[3] >> 16));
 			encoder.Encode ((byte) (bits[3] >> 31));
 			encoder.Encode ((uint) bits[2]);
 			encoder.Encode ((uint) bits[1]);
 			encoder.Encode ((uint) bits[0]);
 			encoder.EncodeEmptyNamedArguments ();
 
 			EmitAttribute (builder, encoder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="669" endline="697">
<![CDATA[
 		}
 
 		public override IList<TypeSpec> Interfaces {
 			get {
 				if ((state & StateFlags.InterfacesExpanded) == 0) {
 					if (ifaces != null) {
 						for (int i = 0; i < ifaces.Count; ++i ) {
 							var iface_type = ifaces[i];
 							if (iface_type.Interfaces != null) {
 								if (ifaces_defined == null)
 									ifaces_defined = ifaces.ToArray ();
 
 								for (int ii = 0; ii < iface_type.Interfaces.Count; ++ii) {
 									var ii_iface_type = iface_type.Interfaces [ii];
 
 									AddInterface (ii_iface_type);
 								}
 								for (int ii = 0; ii < iface_type.Interfaces.Count; ++ii) {
 									var ii_iface_type = iface_type.Interfaces [ii];
 
 									AddInterface (ii_iface_type);
 								}
 							}
 						}
 						for (int i = 0; i < ifaces.Count; ++i ) {
 							var iface_type = ifaces[i];
 							if (iface_type.Interfaces != null) {
 								if (ifaces_defined == null)
 									ifaces_defined = ifaces.ToArray ();
 
 								for (int ii = 0; ii < iface_type.Interfaces.Count; ++ii) {
 									var ii_iface_type = iface_type.Interfaces [ii];
 
 									AddInterface (ii_iface_type);
 								}
 							}
 						}
 					}
 
 					if (ifaces_defined == null && ifaces != null)
 						ifaces_defined = ifaces.ToArray ();
 
 					state |= StateFlags.InterfacesExpanded;
 				}
 
 				return ifaces;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1612" endline="1668">
<![CDATA[
 	}
 
 
 	/// <summary>
 	/// Helper class for attribute verification routine.
 	/// </summary>
 	static class AttributeTester
 	{
 		public enum Result {
 			Ok,
 			RefOutArrayError,
 			ArrayArrayError
 		}
 
 		/// <summary>
 		/// Returns true if parameters of two compared methods are CLS-Compliant.
 		/// It tests differing only in ref or out, or in array rank.
 		/// </summary>
 		public static Result AreOverloadedMethodParamsClsCompliant (AParametersCollection pa, AParametersCollection pb) 
 		{
 			TypeSpec [] types_a = pa.Types;
 			TypeSpec [] types_b = pb.Types;
 			if (types_a == null || types_b == null)
 				return Result.Ok;
 
 			if (types_a.Length != types_b.Length)
 				return Result.Ok;
 
 			Result result = Result.Ok;
 			for (int i = 0; i < types_b.Length; ++i) {
 				TypeSpec aType = types_a [i];
 				TypeSpec bType = types_b [i];
 
 				var ac_a = aType as ArrayContainer;
 				var ac_b = aType as ArrayContainer;
 
 				if (ac_a != null && ac_b != null) {
 					if (ac_a.Rank != ac_b.Rank && ac_a.Element == ac_b.Element) {
 						result = Result.RefOutArrayError;
 						continue;
 					}
 
 					if (ac_a.Element.IsArray || ac_b.Element.IsArray) {
 						result = Result.ArrayArrayError;
 						continue;
 					}
 				}
 
 				if (aType != bType)
 					return Result.Ok;
 
 				const Parameter.Modifier out_ref_mod = (Parameter.Modifier.OUTMASK | Parameter.Modifier.REFMASK);
 				if ((pa.FixedParameters[i].ModFlags & out_ref_mod) != (pb.FixedParameters[i].ModFlags & out_ref_mod))
 					result = Result.RefOutArrayError;
 			}
 			for (int i = 0; i < types_b.Length; ++i) {
 				TypeSpec aType = types_a [i];
 				TypeSpec bType = types_b [i];
 
 				var ac_a = aType as ArrayContainer;
 				var ac_b = aType as ArrayContainer;
 
 				if (ac_a != null && ac_b != null) {
 					if (ac_a.Rank != ac_b.Rank && ac_a.Element == ac_b.Element) {
 						result = Result.RefOutArrayError;
 						continue;
 					}
 
 					if (ac_a.Element.IsArray || ac_b.Element.IsArray) {
 						result = Result.ArrayArrayError;
 						continue;
 					}
 				}
 
 				if (aType != bType)
 					return Result.Ok;
 
 				const Parameter.Modifier out_ref_mod = (Parameter.Modifier.OUTMASK | Parameter.Modifier.REFMASK);
 				if ((pa.FixedParameters[i].ModFlags & out_ref_mod) != (pb.FixedParameters[i].ModFlags & out_ref_mod))
 					result = Result.RefOutArrayError;
 			}
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4092" endline="4130">
<![CDATA[
 
 		static TypeSpec MoreSpecific (TypeSpec p, TypeSpec q)
 		{
 			if (TypeManager.IsGenericParameter (p) && !TypeManager.IsGenericParameter (q))
 				return q;
 			if (!TypeManager.IsGenericParameter (p) && TypeManager.IsGenericParameter (q))
 				return p;
 
 			var ac_p = p as ArrayContainer;
 			if (ac_p != null) {
 				var ac_q = ((ArrayContainer) q);
 				TypeSpec specific = MoreSpecific (ac_p.Element, ac_q.Element);
 				if (specific == ac_p.Element)
 					return p;
 				if (specific == ac_q.Element)
 					return q;
 			} else if (TypeManager.IsGenericType (p)) {
 				var pargs = TypeManager.GetTypeArguments (p);
 				var qargs = TypeManager.GetTypeArguments (q);
 
 				bool p_specific_at_least_once = false;
 				bool q_specific_at_least_once = false;
 
 				for (int i = 0; i < pargs.Length; i++) {
 					TypeSpec specific = MoreSpecific (pargs[i], qargs[i]);
 					if (specific == pargs[i])
 						p_specific_at_least_once = true;
 					if (specific == qargs[i])
 						q_specific_at_least_once = true;
 				}
 				for (int i = 0; i < pargs.Length; i++) {
 					TypeSpec specific = MoreSpecific (pargs[i], qargs[i]);
 					if (specific == pargs[i])
 						p_specific_at_least_once = true;
 					if (specific == qargs[i])
 						q_specific_at_least_once = true;
 				}
 
 				if (p_specific_at_least_once && !q_specific_at_least_once)
 					return p;
 				if (!p_specific_at_least_once && q_specific_at_least_once)
 					return q;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1568" endline="1612">
<![CDATA[
 		}
 
 		// <summary>
 		//   Performs an `or' operation on the bit vector.  The `new_vector' may have a
 		//   different size than the current one.
 		// </summary>
 		private MyBitVector Or (MyBitVector new_vector)
 		{
 			if (Count == 0 || new_vector.Count == 0)
 				return this;
 
 			var o = new_vector.vector != null ? new_vector.vector 
 
 			if (o == null) {
 				int n = new_vector.Count;
 				if (n < Count) {
 					for (int i = 0; i < n; ++i)
 						this [i] = true;
 					for (int i = 0; i < n; ++i)
 						this [i] = true;
 				} else {
 					SetAll (true);
 				}
 				return this;
 			}
 
 			if (Count == o.Count) {
 				if (vector == null) {
 					if (shared == null)
 						return this;
 					initialize_vector ();
 				}
 				vector.Or (o);
 				return this;
 			}
 
 			int min = o.Count;
 			if (Count < min)
 				min = Count;
 
 			for (int i = 0; i < min; i++) {
 				if (o [i])
 					this [i] = true;
 			}
 			for (int i = 0; i < min; i++) {
 				if (o [i])
 					this [i] = true;
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2657" endline="2697">
<![CDATA[
 
 		bool CheckStructCycles (Struct s)
 		{
 			if (s.Fields == null)
 				return true;
 
 			if (s.InTransit)
 				return false;
 
 			s.InTransit = true;
 			foreach (FieldBase field in s.Fields) {
 				TypeSpec ftype = field.Spec.MemberType;
 				if (!ftype.IsStruct)
 					continue;
 
 				if (ftype is BuildinTypeSpec)
 					continue;
 
 				foreach (var targ in ftype.TypeArguments) {
 					if (!CheckFieldTypeCycle (targ)) {
 						Report.Error (523, field.Location,
 							"Struct member `{0}' of type `{1}' causes a cycle in the struct layout",
 							field.GetSignatureForError (), ftype.GetSignatureForError ());
 						break;
 					}
 				}
 				foreach (var targ in ftype.TypeArguments) {
 					if (!CheckFieldTypeCycle (targ)) {
 						Report.Error (523, field.Location,
 							"Struct member `{0}' of type `{1}' causes a cycle in the struct layout",
 							field.GetSignatureForError (), ftype.GetSignatureForError ());
 						break;
 					}
 				}
 
 				if ((field.IsStatic && (!ftype.IsGeneric || ftype == CurrentType)))
 					continue;
 
 				if (!CheckFieldTypeCycle (ftype)) {
 					Report.Error (523, field.Location,
 						"Struct member `{0}' of type `{1}' causes a cycle in the struct layout",
 						field.GetSignatureForError (), ftype.GetSignatureForError ());
 					break;
 				}
 			}
 			foreach (FieldBase field in s.Fields) {
 				TypeSpec ftype = field.Spec.MemberType;
 				if (!ftype.IsStruct)
 					continue;
 
 				if (ftype is BuildinTypeSpec)
 					continue;
 
 				foreach (var targ in ftype.TypeArguments) {
 					if (!CheckFieldTypeCycle (targ)) {
 						Report.Error (523, field.Location,
 							"Struct member `{0}' of type `{1}' causes a cycle in the struct layout",
 							field.GetSignatureForError (), ftype.GetSignatureForError ());
 						break;
 					}
 				}
 
 				if ((field.IsStatic && (!ftype.IsGeneric || ftype == CurrentType)))
 					continue;
 
 				if (!CheckFieldTypeCycle (ftype)) {
 					Report.Error (523, field.Location,
 						"Struct member `{0}' of type `{1}' causes a cycle in the struct layout",
 						field.GetSignatureForError (), ftype.GetSignatureForError ());
 					break;
 				}
 			}
 
 			s.InTransit = false;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2168" endline="2213">
<![CDATA[
 
 		bool HasDefaultConstructor (TypeSpec atype)
 		{
 			var tp = atype as TypeParameterSpec;
 			if (tp != null) {
 				return tp.HasSpecialConstructor || tp.HasSpecialStruct;
 			}
 
 			if (atype.IsStruct || atype.IsEnum)
 				return true;
 
 			if (atype.IsAbstract)
 				return false;
 
 			var tdef = atype.GetDefinition ();
 
 			//
 			// In some circumstances MemberCache is not yet populated and members
 			// cannot be defined yet (recursive type new constraints)
 			//
 			// class A<T> where T 
 			// class B<T> where T 
 			//
 			var tc = tdef.MemberDefinition as Class;
 			if (tc != null) {
 				if (tc.InstanceConstructors == null) {
 					// Default ctor will be generated later
 					return true;
 				}
 
 				foreach (var c in tc.InstanceConstructors) {
 					if (c.ParameterInfo.IsEmpty) {
 						if ((c.ModFlags & Modifiers.PUBLIC) != 0)
 							return true;
 					}
 				}
 				foreach (var c in tc.InstanceConstructors) {
 					if (c.ParameterInfo.IsEmpty) {
 						if ((c.ModFlags & Modifiers.PUBLIC) != 0)
 							return true;
 					}
 				}
 
 				return false;
 			}
 
 			var found = MemberCache.FindMember (tdef,
 				MemberFilter.Constructor (ParametersCompiled.EmptyReadOnlyParameters),
 				BindingRestriction.DeclaredOnly | BindingRestriction.InstanceOnly);
 
 			return found != null && (found.Modifiers & Modifiers.PUBLIC) != 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="664" endline="688">
<![CDATA[
 
 		private void UpdateStack(OpCode opc, bool hasthis, Type returnType, int parameterCount)
 		{
 			if (opc == OpCodes.Jmp)
 			{
 				stackHeight = -1;
 			}
 			else if (opc.FlowControl == FlowControl.Call)
 			{
 				int stackdiff = 0;
 				if ((hasthis && opc != OpCodes.Newobj) || opc == OpCodes.Calli)
 				{
 					// pop this
 					stackdiff--;
 				}
 				// pop parameters
 				stackdiff -= parameterCount;
 				if (returnType != moduleBuilder.universe.System_Void)
 				{
 					// push return value
 					stackdiff++;
 				}
 				UpdateStack(stackdiff);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="447" endline="473">
<![CDATA[
 
 		internal CustomAttributeData ToData(Assembly asm)
 		{
 			if (blob != null)
 			{
 				return new CustomAttributeData(asm, con, new IKVM.Reflection.Reader.ByteReader(blob, 0, blob.Length));
 			}
 			else
 			{
 				List<CustomAttributeNamedArgument> namedArgs = new List<CustomAttributeNamedArgument>();
 				if (namedProperties != null)
 				{
 					for (int i = 0; i < namedProperties.Length; i++)
 					{
 						namedArgs.Add(new CustomAttributeNamedArgument(namedProperties[i], new CustomAttributeTypedArgument(namedProperties[i].PropertyType, propertyValues[i])));
 					}
 					for (int i = 0; i < namedProperties.Length; i++)
 					{
 						namedArgs.Add(new CustomAttributeNamedArgument(namedProperties[i], new CustomAttributeTypedArgument(namedProperties[i].PropertyType, propertyValues[i])));
 					}
 				}
 				if (namedFields != null)
 				{
 					for (int i = 0; i < namedFields.Length; i++)
 					{
 						namedArgs.Add(new CustomAttributeNamedArgument(namedFields[i], new CustomAttributeTypedArgument(namedFields[i].FieldType, fieldValues[i])));
 					}
 					for (int i = 0; i < namedFields.Length; i++)
 					{
 						namedArgs.Add(new CustomAttributeNamedArgument(namedFields[i], new CustomAttributeTypedArgument(namedFields[i].FieldType, fieldValues[i])));
 					}
 				}
 				return new CustomAttributeData(con, constructorArgs, namedArgs);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2793" endline="2852">
<![CDATA[
 
 		//
 		// Lookup inside a block, the returned value can represent 3 states
 		//
 		// true+variable
 		// false+variable
 		// false+null
 		//
 		public bool GetLocalName (string name, Block block, ref INamedBlockVariable variable)
 		{
 			if (names == null)
 				return false;
 
 			object value;
 			if (!names.TryGetValue (name, out value))
 				return false;
 
 			variable = value as INamedBlockVariable;
 			Block b = block;
 			if (variable != null) {
 				do {
 					if (variable.Block == b.Original)
 						return true;
 
 					b = b.Parent;
 				} while (b != null);
 
 				b = variable.Block;
 				do {
 					if (block == b)
 						return false;
 
 					b = b.Parent;
 				} while (b != null);
 			} else {
 				List<INamedBlockVariable> list = (List<INamedBlockVariable>) value;
 				for (int i = 0; i < list.Count; ++i) {
 					variable = list[i];
 					do {
 						if (variable.Block == b.Original)
 							return true;
 
 						b = b.Parent;
 					} while (b != null);
 
 					b = variable.Block;
 					do {
 						if (block == b)
 							return false;
 
 						b = b.Parent;
 					} while (b != null);
 
 					b = block;
 				}
 				for (int i = 0; i < list.Count; ++i) {
 					variable = list[i];
 					do {
 						if (variable.Block == b.Original)
 							return true;
 
 						b = b.Parent;
 					} while (b != null);
 
 					b = variable.Block;
 					do {
 						if (block == b)
 							return false;
 
 						b = b.Parent;
 					} while (b != null);
 
 					b = block;
 				}
 			}
 
 			variable = null;
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="722" endline="777">
<![CDATA[
 
 		void DoResolveFieldInitializers (BlockContext ec)
 		{
 			if (ec.IsStatic) {
 				if (initialized_static_fields == null)
 					return;
 
 				bool has_complex_initializer = !RootContext.Optimize;
 				int i;
 				ExpressionStatement [] init = new ExpressionStatement [initialized_static_fields.Count];
 				for (i = 0; i < initialized_static_fields.Count; ++i) {
 					FieldInitializer fi = initialized_static_fields [i];
 					ExpressionStatement s = fi.ResolveStatement (ec);
 					if (s == null) {
 						s = EmptyExpressionStatement.Instance;
 					} else if (fi.IsComplexInitializer) {
 						has_complex_initializer |= true;
 					}
 
 					init [i] = s;
 				}
 				for (i = 0; i < initialized_static_fields.Count; ++i) {
 					FieldInitializer fi = initialized_static_fields [i];
 					ExpressionStatement s = fi.ResolveStatement (ec);
 					if (s == null) {
 						s = EmptyExpressionStatement.Instance;
 					} else if (fi.IsComplexInitializer) {
 						has_complex_initializer |= true;
 					}
 
 					init [i] = s;
 				}
 
 				for (i = 0; i < initialized_static_fields.Count; ++i) {
 					FieldInitializer fi = initialized_static_fields [i];
 					//
 					// Need special check to not optimize code like this
 					// static int a = b = 5;
 					// static int b = 0;
 					//
 					if (!has_complex_initializer && fi.IsDefaultInitializer)
 						continue;
 
 					ec.CurrentBlock.AddScopeStatement (new StatementExpression (init [i]));
 				}
 				for (i = 0; i < initialized_static_fields.Count; ++i) {
 					FieldInitializer fi = initialized_static_fields [i];
 					//
 					// Need special check to not optimize code like this
 					// static int a = b = 5;
 					// static int b = 0;
 					//
 					if (!has_complex_initializer && fi.IsDefaultInitializer)
 						continue;
 
 					ec.CurrentBlock.AddScopeStatement (new StatementExpression (init [i]));
 				}
 
 				return;
 			}
 
 			if (initialized_fields == null)
 				return;
 
 			for (int i = 0; i < initialized_fields.Count; ++i) {
 				FieldInitializer fi = initialized_fields [i];
 				ExpressionStatement s = fi.ResolveStatement (ec);
 				if (s == null)
 					continue;
 
 				//
 				// Field is re-initialized to its default value => removed
 				//
 				if (fi.IsDefaultInitializer && RootContext.Optimize)
 					continue;
 
 				ec.CurrentBlock.AddScopeStatement (new StatementExpression (s));
 			}
 			for (int i = 0; i < initialized_fields.Count; ++i) {
 				FieldInitializer fi = initialized_fields [i];
 				ExpressionStatement s = fi.ResolveStatement (ec);
 				if (s == null)
 					continue;
 
 				//
 				// Field is re-initialized to its default value => removed
 				//
 				if (fi.IsDefaultInitializer && RootContext.Optimize)
 					continue;
 
 				ec.CurrentBlock.AddScopeStatement (new StatementExpression (s));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2659" endline="2716">
<![CDATA[
 
 		public override void AddLocalName (string name, INamedBlockVariable li)
 		{
 			if (names == null)
 				names = new Dictionary<string, object> ();
 
 			object value;
 			if (!names.TryGetValue (name, out value)) {
 				names.Add (name, li);
 				return;
 			}
 
 			INamedBlockVariable existing = value as INamedBlockVariable;
 			List<INamedBlockVariable> existing_list;
 			if (existing != null) {
 				existing_list = new List<INamedBlockVariable> ();
 				existing_list.Add (existing);
 				names[name] = existing_list;
 			} else {
 				existing_list = (List<INamedBlockVariable>) value;
 			}
 
 			//
 			// A collision checking between local names
 			//
 			for (int i = 0; i < existing_list.Count; ++i) {
 				existing = existing_list[i];
 				Block b = existing.Block;
 
 				// Collision at same level
 				if (li.Block == b) {
 					li.Block.Error_AlreadyDeclared (name, li);
 					break;
 				}
 
 				// Collision with parent
 				b = li.Block;
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "parent or current");
 						i = existing_list.Count;
 						break;
 					}
 				}
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "parent or current");
 						i = existing_list.Count;
 						break;
 					}
 				}
 
 				// Collision with with children
 				b = existing.Block;
 				while ((b = b.Parent) != null) {
 					if (li.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "child");
 						i = existing_list.Count;
 						break;
 					}
 				}
 				while ((b = b.Parent) != null) {
 					if (li.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "child");
 						i = existing_list.Count;
 						break;
 					}
 				}
 			}
 			for (int i = 0; i < existing_list.Count; ++i) {
 				existing = existing_list[i];
 				Block b = existing.Block;
 
 				// Collision at same level
 				if (li.Block == b) {
 					li.Block.Error_AlreadyDeclared (name, li);
 					break;
 				}
 
 				// Collision with parent
 				b = li.Block;
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "parent or current");
 						i = existing_list.Count;
 						break;
 					}
 				}
 
 				// Collision with with children
 				b = existing.Block;
 				while ((b = b.Parent) != null) {
 					if (li.Block == b) {
 						li.Block.Error_AlreadyDeclared (name, li, "child");
 						i = existing_list.Count;
 						break;
 					}
 				}
 			}
 
 			existing_list.Add (li);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="97" endline="110">
<![CDATA[
 
 		internal static Type[][] Copy(Type[][] types)
 		{
 			if (types == null || types.Length == 0)
 			{
 				return types;
 			}
 			Type[][] newArray = new Type[types.Length][];
 			for (int i = 0; i < newArray.Length; i++)
 			{
 				newArray[i] = Copy(types[i]);
 			}
 			for (int i = 0; i < newArray.Length; i++)
 			{
 				newArray[i] = Copy(types[i]);
 			}
 			return newArray;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="619" endline="651">
<![CDATA[
 
 		// managed calling convention
 		internal static void WriteStandAloneMethodSig(ModuleBuilder module, ByteBuffer bb, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
 		{
 			byte flags = 0;
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				flags |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				flags |= EXPLICITTHIS;
 			}
 			if ((callingConvention & CallingConventions.VarArgs) != 0)
 			{
 				flags |= VARARG;
 			}
 			bb.Write(flags);
 			bb.WriteCompressedInt(parameterTypes.Length + optionalParameterTypes.Length);
 			WriteType(module, bb, returnType);
 			foreach (Type t in parameterTypes)
 			{
 				WriteType(module, bb, t);
 			}
 			foreach (Type t in parameterTypes)
 			{
 				WriteType(module, bb, t);
 			}
 			if (optionalParameterTypes.Length > 0)
 			{
 				bb.Write(SENTINEL);
 				foreach (Type t in optionalParameterTypes)
 				{
 					WriteType(module, bb, t);
 				}
 				foreach (Type t in optionalParameterTypes)
 				{
 					WriteType(module, bb, t);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1020" endline="1052">
<![CDATA[
 
 		public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 		{
 			if (genericTypeArguments != null || genericMethodArguments != null)
 			{
 				throw new NotImplementedException();
 			}
 			// this method is inefficient, but since it isn't used we don't care
 			if ((metadataToken >> 24) == MemberRefTable.Index)
 			{
 				foreach (KeyValuePair<MemberInfo, int> kv in importedMembers)
 				{
 					if (kv.Value == metadataToken)
 					{
 						return (MethodBase)kv.Key;
 					}
 				}
 				foreach (KeyValuePair<MemberInfo, int> kv in importedMembers)
 				{
 					if (kv.Value == metadataToken)
 					{
 						return (MethodBase)kv.Key;
 					}
 				}
 			}
 			// HACK if we're given a SymbolToken, we need to convert back
 			if ((metadataToken & 0xFF000000) == 0x06000000)
 			{
 				metadataToken = -(metadataToken & 0x00FFFFFF);
 			}
 			foreach (Type type in types)
 			{
 				MethodBase method = ((TypeBuilder)type).LookupMethod(metadataToken);
 				if (method != null)
 				{
 					return method;
 				}
 			}
 			foreach (Type type in types)
 			{
 				MethodBase method = ((TypeBuilder)type).LookupMethod(metadataToken);
 				if (method != null)
 				{
 					return method;
 				}
 			}
 			return ((TypeBuilder)moduleType).LookupMethod(metadataToken);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5748" endline="5807">
<![CDATA[
 
 		//
 		// This Emit can be invoked in two contexts
 		//    * As a mechanism that will leave a value on the stack (new object)
 		//    * As one that wont (init struct)
 		//
 		// If we are dealing with a ValueType, we have a few
 		// situations to deal with
 		//
 		//    * The target is a ValueType, and we have been provided
 		//      the instance (this is easy, we are being assigned).
 		//
 		//    * The target of New is being passed as an argument,
 		//      to a boxing operation or a function that takes a
 		//      ValueType.
 		//
 		//      In this case, we need to create a temporary variable
 		//      that is the argument of New.
 		//
 		// Returns whether a value is left on the stack
 		//
 		// *** Implementation note ***
 		//
 		// To benefit from this optimization, each assignable expression
 		// has to manually cast to New and call this Emit.
 		//
 		// TODO
 		//
 		public virtual bool Emit (EmitContext ec, IMemoryLocation target)
 		{
 			bool is_value_type = TypeManager.IsValueType (type);
 			VariableReference vr = target as VariableReference;
 
 			if (target != null && is_value_type && (vr != null || method == null)) {
 				target.AddressOf (ec, AddressOp.Store);
 			} else if (vr != null && vr.IsRef) {
 				vr.EmitLoad (ec);
 			}
 			
 			if (arguments != null)
 				arguments.Emit (ec);
 
 			if (is_value_type) {
 				if (method == null) {
 					ec.Emit (OpCodes.Initobj, type);
 					return false;
 				}
 
 				if (vr != null) {
 					ec.Emit (OpCodes.Call, method);
 					return false;
 				}
 			}
 			
 			if (type is TypeParameterSpec)
 				return DoEmitTypeParameter (ec);			
 
 			ec.Emit (OpCodes.Newobj, method);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1016" endline="1094">
<![CDATA[
 
 		//
 		// Returns AnonymousMethod container if this anonymous method
 		// expression can be implicitly converted to the delegate type `delegate_type'
 		//
 		public Expression Compatible (ResolveContext ec, TypeSpec type)
 		{
 			Expression am;
 			if (compatibles.TryGetValue (type, out am))
 				return am;
 
 			TypeSpec delegate_type = CompatibleChecks (ec, type);
 			if (delegate_type == null)
 				return null;
 
 			//
 			// At this point its the first time we know the return type that is 
 			// needed for the anonymous method.  We create the method here.
 			//
 
 			var invoke_mb = Delegate.GetInvokeMethod (ec.Compiler, delegate_type);
 			TypeSpec return_type = invoke_mb.ReturnType;
 
 			//
 			// Second
 			// the anonymous type.   Instead of doing a pass to examine the block
 			// we satisfy the rule by setting the return type on the EmitContext
 			// to be the delegate type return type.
 			//
 
 			var body = CompatibleMethodBody (ec, null, return_type, delegate_type);
 			if (body == null)
 				return null;
 
 			bool etree_conversion = delegate_type != type;
 
 			try {
 				if (etree_conversion) {
 					if (ec.HasSet (ResolveContext.Options.ExpressionTreeConversion)) {
 						//
 						// Nested expression tree lambda use same scope as parent
 						// lambda, this also means no variable capturing between this
 						// and parent scope
 						//
 						am = body.Compatible (ec, ec.CurrentAnonymousMethod);
 
 						//
 						// Quote nested expression tree
 						//
 						if (am != null)
 							am = new Quote (am);
 					} else {
 						int errors = ec.Report.Errors;
 
 						using (ec.Set (ResolveContext.Options.ExpressionTreeConversion)) {
 							am = body.Compatible (ec);
 						}
 
 						//
 						// Rewrite expressions into expression tree when targeting Expression<T>
 						//
 						if (am != null && errors == ec.Report.Errors)
 							am = CreateExpressionTree (ec, delegate_type);
 					}
 				} else {
 					am = body.Compatible (ec);
 				}
 			} catch (CompletionResult) {
 				throw;
 			} catch (Exception e) {
 				throw new InternalErrorException (e, loc);
 			}
 
 			if (!ec.IsInProbingMode) {
 				compatibles.Add (type, am ?? EmptyExpression.Null);
 			}
 
 			return am;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="488" endline="503">
<![CDATA[
 
 		//
 		// Returns a field which holds referenced storey instance
 		//
 		Field GetReferencedStoreyField (AnonymousMethodStorey storey)
 		{
 			if (used_parent_storeys == null)
 				return null;
 
 			foreach (StoreyFieldPair sf in used_parent_storeys) {
 				if (sf.Storey == storey)
 					return sf.Field;
 			}
 			foreach (StoreyFieldPair sf in used_parent_storeys) {
 				if (sf.Storey == storey)
 					return sf.Field;
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="721" endline="766">
<![CDATA[
 
 		public void EmbedResources ()
 		{
 			//
 			// Add Win32 resources
 			//
 			if (RootContext.Win32ResourceFile != null) {
 				Builder.DefineUnmanagedResource (RootContext.Win32ResourceFile);
 			} else {
 				Builder.DefineVersionInfoResource ();
 			}
 
 			if (RootContext.Win32IconFile != null) {
 				builder_extra.DefineWin32IconResource (RootContext.Win32IconFile);
 			}
 
 			if (RootContext.Resources != null) {
 				if (RootContext.Target == Target.Module) {
 					Report.Error (1507, "Cannot link resource file when building a module");
 				} else {
 					int counter = 0;
 					foreach (var res in RootContext.Resources) {
 						if (!File.Exists (res.FileName)) {
 							Report.Error (1566, "Error reading resource file `{0}'", res.FileName);
 							continue;
 						}
 
 						if (res.IsEmbeded) {
 							Stream stream;
 							if (counter++ < 10) {
 								stream = File.OpenRead (res.FileName);
 							} else {
 								// TODO
 								// we workaround it by reading everything into memory to compile projects with
 								// many embedded resource (over 3500) references
 								stream = new MemoryStream (File.ReadAllBytes (res.FileName));
 							}
 
 							module.Builder.DefineManifestResource (res.Name, stream, res.Attributes);
 						} else {
 							Builder.AddResourceFile (res.Name, Path.GetFileName (res.FileName), res.Attributes);
 						}
 					}
 					foreach (var res in RootContext.Resources) {
 						if (!File.Exists (res.FileName)) {
 							Report.Error (1566, "Error reading resource file `{0}'", res.FileName);
 							continue;
 						}
 
 						if (res.IsEmbeded) {
 							Stream stream;
 							if (counter++ < 10) {
 								stream = File.OpenRead (res.FileName);
 							} else {
 								// TODO
 								// we workaround it by reading everything into memory to compile projects with
 								// many embedded resource (over 3500) references
 								stream = new MemoryStream (File.ReadAllBytes (res.FileName));
 							}
 
 							module.Builder.DefineManifestResource (res.Name, stream, res.Attributes);
 						} else {
 							Builder.AddResourceFile (res.Name, Path.GetFileName (res.FileName), res.Attributes);
 						}
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1421" endline="1472">
<![CDATA[
 
 		TypeParameterInflator CreateLocalInflator ()
 		{
 			TypeParameterSpec[] tparams_full;
 			TypeSpec[] targs_full = targs;
 			if (IsNested) {
 				//
 				// Special case is needed when we are inflating an open type (nested type definition)
 				// on inflated parent. Consider following case
 				//
 				// Foo<T>.Bar<U> => Foo<string>.Bar<U>
 				//
 				// Any later inflation of Foo<string>.Bar<U> has to also inflate T if used inside Bar<U>
 				//
 				List<TypeSpec> merged_targs = null;
 				List<TypeParameterSpec> merged_tparams = null;
 
 				var type = DeclaringType;
 
 				do {
 					if (type.TypeArguments.Length > 0) {
 						if (merged_targs == null) {
 							merged_targs = new List<TypeSpec> ();
 							merged_tparams = new List<TypeParameterSpec> ();
 							if (targs.Length > 0) {
 								merged_targs.AddRange (targs);
 								merged_tparams.AddRange (open_type.MemberDefinition.TypeParameters);
 							}
 						}
 						merged_tparams.AddRange (type.MemberDefinition.TypeParameters);
 						merged_targs.AddRange (type.TypeArguments);
 					}
 					type = type.DeclaringType;
 				} while (type != null);
 
 				if (merged_targs != null) {
 					// Type arguments are not in the right order but it should not matter in this case
 					targs_full = merged_targs.ToArray ();
 					tparams_full = merged_tparams.ToArray ();
 				} else if (targs.Length == 0) {
 					tparams_full = TypeParameterSpec.EmptyTypes;
 				} else {
 					tparams_full = open_type.MemberDefinition.TypeParameters;
 				}
 			} else if (targs.Length == 0) {
 				tparams_full = TypeParameterSpec.EmptyTypes;
 			} else {
 				tparams_full = open_type.MemberDefinition.TypeParameters;
 			}
 
 			return new TypeParameterInflator (this, tparams_full, targs_full);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1368" endline="1414">
<![CDATA[
 
 		public InterfaceMapping GetInterfaceMap(Type interfaceType)
 		{
 			CheckBaked();
 			InterfaceMapping map = new InterfaceMapping();
 			if (!IsDirectlyImplementedInterface(interfaceType))
 			{
 				Type baseType = this.BaseType;
 				if (baseType == null)
 				{
 					throw new ArgumentException();
 				}
 				else
 				{
 					map = baseType.GetInterfaceMap(interfaceType);
 				}
 			}
 			else
 			{
 				map.InterfaceMethods = interfaceType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
 				map.InterfaceType = interfaceType;
 				map.TargetMethods = new MethodInfo[map.InterfaceMethods.Length];
 				FillInExplicitInterfaceMethods(map.InterfaceMethods, map.TargetMethods);
 				MethodInfo[] methods = GetMethods(BindingFlags.Instance | BindingFlags.Public);
 				for (int i = 0; i < map.TargetMethods.Length; i++)
 				{
 					if (map.TargetMethods[i] == null)
 					{
 						// TODO use proper method resolution (also take into account that no implicit base class implementation is used across assembly boundaries)
 						for (int j = 0; j < methods.Length; j++)
 						{
 							if (methods[j].Name == map.InterfaceMethods[i].Name
 								&& methods[j].MethodSignature.Equals(map.InterfaceMethods[i].MethodSignature))
 							{
 								map.TargetMethods[i] = methods[j];
 							}
 						}
 						for (int j = 0; j < methods.Length; j++)
 						{
 							if (methods[j].Name == map.InterfaceMethods[i].Name
 								&& methods[j].MethodSignature.Equals(map.InterfaceMethods[i].MethodSignature))
 							{
 								map.TargetMethods[i] = methods[j];
 							}
 						}
 					}
 				}
 				for (int i = 0; i < map.TargetMethods.Length; i++)
 				{
 					if (map.TargetMethods[i] == null)
 					{
 						// TODO use proper method resolution (also take into account that no implicit base class implementation is used across assembly boundaries)
 						for (int j = 0; j < methods.Length; j++)
 						{
 							if (methods[j].Name == map.InterfaceMethods[i].Name
 								&& methods[j].MethodSignature.Equals(map.InterfaceMethods[i].MethodSignature))
 							{
 								map.TargetMethods[i] = methods[j];
 							}
 						}
 					}
 				}
 				for (Type baseType = this.BaseType; baseType != null && interfaceType.IsAssignableFrom(baseType); baseType = baseType.BaseType)
 				{
 					baseType.FillInExplicitInterfaceMethods(map.InterfaceMethods, map.TargetMethods);
 				}
 				for (Type baseType = this.BaseType; baseType != null && interfaceType.IsAssignableFrom(baseType); baseType = baseType.BaseType)
 				{
 					baseType.FillInExplicitInterfaceMethods(map.InterfaceMethods, map.TargetMethods);
 				}
 			}
 			map.TargetType = this;
 			return map;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="1157" endline="1173">
<![CDATA[
 
 		/// <summary>
 		///   Used to validate that all the using clauses are correct
 		///   after we are finished parsing all the files.  
 		/// </summary>
 		void VerifyUsing ()
 		{
 			if (using_aliases != null) {
 				foreach (UsingAliasEntry ue in using_aliases)
 					ue.Resolve (Doppelganger, Doppelganger == null);
 				foreach (UsingAliasEntry ue in using_aliases)
 					ue.Resolve (Doppelganger, Doppelganger == null);
 			}
 
 			if (using_clauses != null) {
 				foreach (UsingEntry ue in using_clauses)
 					ue.Resolve (Doppelganger);
 				foreach (UsingEntry ue in using_clauses)
 					ue.Resolve (Doppelganger);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1311" endline="1326">
<![CDATA[
 
 		public MethodInfo GetGetMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var get = mb.GetArrayMethod (
 				GetMetaInfo (), "Get",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				Element.GetMetaInfo (), arg_types);
 
 			return get;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="423" endline="433">
<![CDATA[
 
 		bool CheckEqualAssign (Expression t)
 		{
 			if (source is Assign) {
 				Assign a = (Assign) source;
 				if (t.Equals (a.Target))
 					return true;
 				return a is SimpleAssign && ((SimpleAssign) a).CheckEqualAssign (t);
 			}
 			return t.Equals (source);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="693" endline="711">
<![CDATA[
 
 		public override bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			string name = goto_stmt.Target;
 			LabeledStatement s = Block.LookupLabel (name);
 			if (s != null)
 				throw new InternalErrorException ("Shouldn't get here");
 
 			if (Parent == null) {
 				Error_UnknownLabel (goto_stmt.loc, name, Report);
 				return false;
 			}
 
 			int errors = Report.Errors;
 			Parent.AddGotoOrigin (vector, goto_stmt);
 			if (errors == Report.Errors)
 				Report.Error (1632, goto_stmt.loc, "Control cannot leave the body of an anonymous method");
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1557" endline="1577">
<![CDATA[
 
 		public void EncodeNamedArguments<T> (T[] members, Constant[] values) where T 
 		{
 			Encode ((ushort) members.Length);
 
 			for (int i = 0; i < members.Length; ++i)
 			{
 				var member = members[i];
 
 				if (member.Kind == MemberKind.Field)
 					Encode ((byte) 0x53);
 				else if (member.Kind == MemberKind.Property)
 					Encode ((byte) 0x54);
 				else
 					throw new NotImplementedException (member.Kind.ToString ());
 
 				Encode (member.MemberType);
 				Encode (member.Name);
 				values [i].EncodeAttributeValue (null, this, member.MemberType);
 			}
 			for (int i = 0; i < members.Length; ++i)
 			{
 				var member = members[i];
 
 				if (member.Kind == MemberKind.Field)
 					Encode ((byte) 0x53);
 				else if (member.Kind == MemberKind.Property)
 					Encode ((byte) 0x54);
 				else
 					throw new NotImplementedException (member.Kind.ToString ());
 
 				Encode (member.MemberType);
 				Encode (member.Name);
 				values [i].EncodeAttributeValue (null, this, member.MemberType);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9550" endline="9586">
<![CDATA[
 
 		public override bool Emit (EmitContext ec, IMemoryLocation target)
 		{
 			bool left_on_stack = base.Emit (ec, target);
 
 			if (initializers.IsEmpty)
 				return left_on_stack;
 
 			LocalTemporary temp = target as LocalTemporary;
 			if (temp == null) {
 				if (!left_on_stack) {
 					VariableReference vr = target as VariableReference;
 					
 					// FIXME
 					if (vr != null && vr.IsRef)
 						target.AddressOf (ec, AddressOp.Load);
 
 					((Expression) target).Emit (ec);
 					left_on_stack = true;
 				}
 
 				temp = new LocalTemporary (type);
 			}
 
 			instance = temp;
 			if (left_on_stack)
 				temp.Store (ec);
 
 			initializers.Emit (ec);
 
 			if (left_on_stack) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 
 			return left_on_stack;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2473" endline="2511">
<![CDATA[
 
 		bool DoSecondPhase (ResolveContext ec, TypeInferenceContext tic, TypeSpec[] methodParameters, bool fixDependent)
 		{
 			bool fixed_any = false;
 			if (fixDependent && !tic.FixDependentTypes (ec, ref fixed_any))
 				return false;
 
 			// If no further unfixed type variables exist, type inference succeeds
 			if (!tic.UnfixedVariableExists)
 				return true;
 
 			if (!fixed_any && fixDependent)
 				return false;
 			
 			// For all arguments where the corresponding argument output types
 			// contain unfixed type variables but the input types do not,
 			// an output type inference is made
 			for (int i = 0; i < arg_count; i++) {
 				
 				// Align params arguments
 				TypeSpec t_i = methodParameters [i >= methodParameters.Length ? methodParameters.Length - 1
 				
 				if (!TypeManager.IsDelegateType (t_i)) {
 					if (t_i.GetDefinition () != TypeManager.expression_type)
 						continue;
 
 					t_i = TypeManager.GetTypeArguments (t_i) [0];
 				}
 
 				var mi = Delegate.GetInvokeMethod (ec.Compiler, t_i);
 				TypeSpec rtype = mi.ReturnType;
 
 				if (tic.IsReturnTypeNonDependent (ec, mi, rtype))
 					score -= tic.OutputTypeInference (ec, arguments [i].Expr, t_i);
 			}
 			for (int i = 0; i < arg_count; i++) {
 				
 				// Align params arguments
 				TypeSpec t_i = methodParameters [i >= methodParameters.Length ? methodParameters.Length - 1
 				
 				if (!TypeManager.IsDelegateType (t_i)) {
 					if (t_i.GetDefinition () != TypeManager.expression_type)
 						continue;
 
 					t_i = TypeManager.GetTypeArguments (t_i) [0];
 				}
 
 				var mi = Delegate.GetInvokeMethod (ec.Compiler, t_i);
 				TypeSpec rtype = mi.ReturnType;
 
 				if (tic.IsReturnTypeNonDependent (ec, mi, rtype))
 					score -= tic.OutputTypeInference (ec, arguments [i].Expr, t_i);
 			}
 
 
 			return DoSecondPhase (ec, tic, methodParameters, true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="99" endline="159">
<![CDATA[
 
 		/// <summary>
 		///   Optional initialization for the Evaluator.
 		/// </summary>
 		/// <remarks>
 		///  Initializes the Evaluator with the command line
 		///  options that would be processed by the command
 		///  line compiler.  Only the first call to
 		///  InitAndGetStartupFiles or Init will work, any future
 		///  invocations are ignored.
 		///
 		///  You can safely avoid calling this method if your application
 		///  does not need any of the features exposed by the command line
 		///  interface.
 		///
 		///  This method return an array of strings that contains any
 		///  files that were specified in `args'.
 		///
 		///  If the unknownOptionParser is not null, this function is invoked
 		///  with the current args array and the index of the option that is not
 		///  known.  A value of true means that the value was processed, otherwise
 		///  it will be reported as an error
 		/// </remarks>
 		public static string [] InitAndGetStartupFiles (string [] args, Func<string [], int, int> unknownOptionParser)
 		{
 			lock (evaluator_lock){
 				if (inited)
 					return new string [0];
 
 				CompilerCallableEntryPoint.Reset ();
 				var crp = new ConsoleReportPrinter ();
 				driver = Driver.Create (args, false, unknownOptionParser, crp);
 				if (driver == null)
 					throw new Exception ("Failed to create compiler driver with the given arguments");
 
 				crp.Fatal = driver.fatal_errors;
 				ctx = driver.ctx;
 
 				RootContext.ToplevelTypes = new ModuleContainer (ctx);
 				
 				var startup_files = new List<string> ();
 				foreach (CompilationUnit file in Location.SourceFiles)
 					startup_files.Add (file.Path);
 				foreach (CompilationUnit file in Location.SourceFiles)
 					startup_files.Add (file.Path);
 				
 				CompilerCallableEntryPoint.PartialReset ();
 
 				var importer = new ReflectionImporter (ctx.BuildinTypes);
 				loader = new DynamicLoader (importer, ctx);
 
 				RootContext.ToplevelTypes.SetDeclaringAssembly (new AssemblyDefinitionDynamic (RootContext.ToplevelTypes, "temp"));
 
 				loader.LoadReferences (RootContext.ToplevelTypes);
 				ctx.BuildinTypes.CheckDefinitions (RootContext.ToplevelTypes);
 				RootContext.ToplevelTypes.InitializePredefinedTypes ();
 
 				RootContext.EvalMode = true;
 				inited = true;
 
 				return startup_files.ToArray ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="197" endline="243">
<![CDATA[
 
 		//
 		// This is used to resolve the expression as a type, a null
 		// value will be returned if the expression is not a type
 		// reference
 		//
 		public virtual TypeExpr ResolveAsTypeTerminal (IMemberContext ec , bool silent)
 		{
 			int errors = ec.Compiler.Report.Errors;
 
 			FullNamedExpression fne = ResolveAsTypeStep (ec, silent);
 
 			if (fne == null)
 				return null;
 				
 			TypeExpr te = fne as TypeExpr;				
 			if (te == null) {
 				if (!silent && errors == ec.Compiler.Report.Errors)
 					fne.Error_UnexpectedKind (ec.Compiler.Report, null, "type", loc);
 				return null;
 			}
 
 			if (!te.type.IsAccessible (ec.CurrentType)) {
 				ec.Compiler.Report.SymbolRelatedToPreviousError (te.Type);
 				ErrorIsInaccesible (ec, te.Type.GetSignatureForError (), loc);
 			}
 
 			te.loc = loc;
 
 			var dep = te.type.GetMissingDependencies ();
 			if (dep != null) {
 				ImportedTypeDefinition.Error_MissingDependency (ec, dep, loc);
 			}
 
 			//
 			// Obsolete checks cannot be done when resolving base context as they
 			// require type dependecies to be set but we are just resolving them
 			//
 			if (!silent && !(ec is TypeContainer.BaseContext)) {
 				ObsoleteAttribute obsolete_attr = te.Type.GetAttributeObsolete ();
 				if (obsolete_attr != null && !ec.IsObsolete) {
 					AttributeTester.Report_ObsoleteMessage (obsolete_attr, te.GetSignatureForError (), Location, ec.Compiler.Report);
 				}
 			}
 
 			return te;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="420" endline="475">
<![CDATA[
 
 		public static Expression ImplicitNulableConversion (ResolveContext ec, Expression expr, TypeSpec target_type)
 		{
 			TypeSpec expr_type = expr.Type;
 
 			//
 			// From null to any nullable type
 			//
 			if (expr_type == InternalType.Null)
 				return ec == null ? EmptyExpression.Null 
 
 			// S -> T?
 			TypeSpec t_el = Nullable.NullableInfo.GetUnderlyingType (target_type);
 
 			// S? -> T?
 			if (TypeManager.IsNullableType (expr_type))
 				expr_type = Nullable.NullableInfo.GetUnderlyingType (expr_type);
 
 			//
 			// Predefined implicit identity or implicit numeric conversion
 			// has to exist between underlying type S and underlying type T
 			//
 
 			// conversion exists only mode
 			if (ec == null) {
 				if (TypeSpecComparer.IsEqual (expr_type, t_el))
 					return EmptyExpression.Null;
 
 				if (expr is Constant)
 					return ((Constant) expr).ConvertImplicitly (ec, t_el);
 
 				return ImplicitNumericConversion (null, expr_type, t_el);
 			}
 
 			Expression unwrap;
 			if (expr_type != expr.Type)
 				unwrap = Nullable.Unwrap.Create (expr);
 			else
 				unwrap = expr;
 
 			Expression conv = unwrap;
 			if (!TypeSpecComparer.IsEqual (expr_type, t_el)) {
 				if (conv is Constant)
 					conv = ((Constant)conv).ConvertImplicitly (ec, t_el);
 				else
 					conv = ImplicitNumericConversion (conv, expr_type, t_el);
 
 				if (conv == null)
 					return null;
 			}
 			
 			if (expr_type != expr.Type)
 				return new Nullable.Lifted (conv, unwrap, target_type).Resolve (ec);
 
 			return Nullable.Wrap.Create (conv, target_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="459" endline="505">
<![CDATA[
 
 		void EmitFieldSize (int buffer_size)
 		{
 			PredefinedAttribute pa;
 			AttributeEncoder encoder;
 
 			pa = Module.PredefinedAttributes.StructLayout;
 			if (pa.Constructor == null && !pa.ResolveConstructor (Location, TypeManager.short_type))
 				return;
 
 			var char_set_type = Module.PredefinedTypes.CharSet.Resolve (Location);
 			if (char_set_type == null)
 				return;
 
 			var field_size = pa.GetField ("Size", TypeManager.int32_type, Location);
 			var field_charset = pa.GetField ("CharSet", char_set_type, Location);
 			if (field_size == null || field_charset == null)
 				return;
 
 			var char_set = CharSet ?? Module.DefaultCharSet;
 
 			encoder = new AttributeEncoder ();
 			encoder.Encode ((short)LayoutKind.Sequential);
 			encoder.EncodeNamedArguments (
 				new [] { field_size, field_charset },
 				new Constant [] { new IntConstant (buffer_size, Location), new IntConstant ((int) char_set, Location) }
 			);
 
 			pa.EmitAttribute (fixed_buffer_type, encoder);
 
 			//
 			// Don't emit FixedBufferAttribute attribute for private types
 			//
 			if ((ModFlags & Modifiers.PRIVATE) != 0)
 				return;
 
 			pa = Module.PredefinedAttributes.FixedBuffer;
 			if (pa.Constructor == null && !pa.ResolveConstructor (Location, TypeManager.type_type, TypeManager.int32_type))
 				return;
 
 			encoder = new AttributeEncoder ();
 			encoder.EncodeTypeName (MemberType);
 			encoder.Encode (buffer_size);
 			encoder.EncodeEmptyNamedArguments ();
 
 			pa.EmitAttribute (FieldBuilder, encoder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2586" endline="2601">
<![CDATA[
 
 		void ResolveMeta (BlockContext ec)
 		{
 			int orig_count = parameters.Count;
 
 			for (int i = 0; i < orig_count; ++i) {
 				Parameter.Modifier mod = parameters.FixedParameters[i].ModFlags;
 
 				if ((mod & Parameter.Modifier.OUT) != Parameter.Modifier.OUT)
 					continue;
 
 				VariableInfo vi = new VariableInfo (parameters, i, ec.FlowOffset);
 				parameter_info[i].VariableInfo = vi;
 				ec.FlowOffset += vi.Length;
 			}
 			for (int i = 0; i < orig_count; ++i) {
 				Parameter.Modifier mod = parameters.FixedParameters[i].ModFlags;
 
 				if ((mod & Parameter.Modifier.OUT) != Parameter.Modifier.OUT)
 					continue;
 
 				VariableInfo vi = new VariableInfo (parameters, i, ec.FlowOffset);
 				parameter_info[i].VariableInfo = vi;
 				ec.FlowOffset += vi.Length;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2655" endline="2674">
<![CDATA[
 
 		protected void CheckProtectedMemberAccess<T> (ResolveContext rc, T member) where T 
 		{
 			if (InstanceExpression == null)
 				return;
 
 			if ((member.Modifiers & Modifiers.AccessibilityMask) == Modifiers.PROTECTED && !(InstanceExpression is This)) {
 				var ct = rc.CurrentType;
 				var expr_type = InstanceExpression.Type;
 				if (ct != expr_type) {
 					expr_type = expr_type.GetDefinition ();
 					if (ct != expr_type && !IsSameOrBaseQualifier (ct, expr_type)) {
 						rc.Report.SymbolRelatedToPreviousError (member);
 						rc.Report.Error (1540, loc,
 							"Cannot access protected member `{0}' via a qualifier of type `{1}'. The qualifier must be of type `{2}' or derived from it",
 							member.GetSignatureForError (), expr_type.GetSignatureForError (), ct.GetSignatureForError ());
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4210" endline="4241">
<![CDATA[
 
 		int ResolvePredefinedMethods (ResolveContext rc)
 		{
 			if (TypeManager.void_monitor_enter_object == null || TypeManager.void_monitor_exit_object == null) {
 				TypeSpec monitor_type = rc.Module.PredefinedTypes.Monitor.Resolve (loc);
 
 				if (monitor_type == null)
 					return 0;
 
 				// Try 4.0 Monitor.Enter (object, ref bool) overload first
 				var filter = MemberFilter.Method ("Enter", 0, new ParametersImported (
 					new[] {
 							new ParameterData (null, Parameter.Modifier.NONE),
 							new ParameterData (null, Parameter.Modifier.REF)
 						},
 					new[] {
 							TypeManager.object_type,
 							TypeManager.bool_type
 						}, false), null);
 
 				TypeManager.void_monitor_enter_object = TypeManager.GetPredefinedMethod (monitor_type, filter, true, loc);
 				if (TypeManager.void_monitor_enter_object == null) {
 					TypeManager.void_monitor_enter_object = TypeManager.GetPredefinedMethod (
 						monitor_type, "Enter", loc, TypeManager.object_type);
 				}
 
 				TypeManager.void_monitor_exit_object = TypeManager.GetPredefinedMethod (
 					monitor_type, "Exit", loc, TypeManager.object_type);
 			}
 
 			return TypeManager.void_monitor_enter_object.Parameters.Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1419" endline="1449">
<![CDATA[
 
 		TypeSpec CheckRecursiveDefinition (TypeContainer tc)
 		{
 			if (InTransit != null)
 				return spec;
 
 			InTransit = tc;
 
 			if (base_type_expr != null) {
 				var ptc = base_type.MemberDefinition as TypeContainer;
 				if (ptc != null && ptc.CheckRecursiveDefinition (this) != null)
 					return base_type;
 			}
 
 			if (iface_exprs != null) {
 				foreach (TypeExpr iface in iface_exprs) {
 					// the interface might not have been resolved, prevents a crash, see #442144
 					if (iface == null)
 						continue;
 					var ptc = iface.Type.MemberDefinition as Interface;
 					if (ptc != null && ptc.CheckRecursiveDefinition (this) != null)
 						return iface.Type;
 				}
 				foreach (TypeExpr iface in iface_exprs) {
 					// the interface might not have been resolved, prevents a crash, see #442144
 					if (iface == null)
 						continue;
 					var ptc = iface.Type.MemberDefinition as Interface;
 					if (ptc != null && ptc.CheckRecursiveDefinition (this) != null)
 						return iface.Type;
 				}
 			}
 
 			if (!IsTopLevel && Parent.PartialContainer.CheckRecursiveDefinition (this) != null)
 				return spec;
 
 			InTransit = null;
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="148" endline="213">
<![CDATA[
 
 		internal static __StandAloneMethodSig ReadStandAloneMethodSig(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			CallingConventions callingConvention = 0;
 			System.Runtime.InteropServices.CallingConvention unmanagedCallingConvention = 0;
 			bool unmanaged;
 			byte flags = br.ReadByte();
 			switch (flags & 7)
 			{
 				case DEFAULT
 					callingConvention = CallingConventions.Standard;
 					unmanaged = false;
 					break;
 				case 0x01
 					unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl;
 					unmanaged = true;
 					break;
 				case 0x02
 					unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall;
 					unmanaged = true;
 					break;
 				case 0x03
 					unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.ThisCall;
 					unmanaged = true;
 					break;
 				case 0x04
 					unmanagedCallingConvention = System.Runtime.InteropServices.CallingConvention.FastCall;
 					unmanaged = true;
 					break;
 				case VARARG
 					callingConvention = CallingConventions.VarArgs;
 					unmanaged = false;
 					break;
 				default
 					throw new BadImageFormatException();
 			}
 			if ((flags & HASTHIS) != 0)
 			{
 				callingConvention |= CallingConventions.HasThis;
 			}
 			if ((flags & EXPLICITTHIS) != 0)
 			{
 				callingConvention |= CallingConventions.ExplicitThis;
 			}
 			if ((flags & GENERIC) != 0)
 			{
 				throw new BadImageFormatException();
 			}
 			int paramCount = br.ReadCompressedInt();
 			SkipCustomModifiers(br);
 			Type returnType = ReadRetType(module, br, context);
 			List<Type> parameterTypes = new List<Type>();
 			List<Type> optionalParameterTypes = new List<Type>();
 			List<Type> curr = parameterTypes;
 			for (int i = 0; i < paramCount; i++)
 			{
 				if (br.PeekByte() == SENTINEL)
 				{
 					br.ReadByte();
 					curr = optionalParameterTypes;
 				}
 				SkipCustomModifiers(br);
 				curr.Add(ReadParam(module, br, context));
 			}
 			for (int i = 0; i < paramCount; i++)
 			{
 				if (br.PeekByte() == SENTINEL)
 				{
 					br.ReadByte();
 					curr = optionalParameterTypes;
 				}
 				SkipCustomModifiers(br);
 				curr.Add(ReadParam(module, br, context));
 			}
 			return new __StandAloneMethodSig(unmanaged, unmanagedCallingConvention, callingConvention, returnType, parameterTypes.ToArray(), optionalParameterTypes.ToArray());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="317" endline="360">
<![CDATA[
 
 		internal int Add(ByteBuffer bb)
 		{
 			Debug.Assert(!frozen);
 			if (bb.Length == 0)
 			{
 				return 0;
 			}
 			int lenlen = MetadataWriter.GetCompressedIntLength(bb.Length);
 			int hash = bb.Hash();
 			int index = (hash & 0x7FFFFFFF) % map.Length;
 			Key[] keys = map;
 			int last = index;
 			while (keys[index].offset != 0)
 			{
 				if (keys[index].hash == hash
 					&& keys[index].len == bb.Length
 					&& buf.Match(keys[index].offset + lenlen, bb, 0, bb.Length))
 				{
 					return keys[index].offset;
 				}
 				if (index == last)
 				{
 					if (keys[index].next == null)
 					{
 						keys[index].next = new Key[4];
 						keys = keys[index].next;
 						index = 0;
 						break;
 					}
 					keys = keys[index].next;
 					index = -1;
 					last = keys.Length - 1;
 				}
 				index++;
 			}
 			while (keys[index].offset != 0)
 			{
 				if (keys[index].hash == hash
 					&& keys[index].len == bb.Length
 					&& buf.Match(keys[index].offset + lenlen, bb, 0, bb.Length))
 				{
 					return keys[index].offset;
 				}
 				if (index == last)
 				{
 					if (keys[index].next == null)
 					{
 						keys[index].next = new Key[4];
 						keys = keys[index].next;
 						index = 0;
 						break;
 					}
 					keys = keys[index].next;
 					index = -1;
 					last = keys.Length - 1;
 				}
 				index++;
 			}
 			int offset = buf.Position;
 			buf.WriteCompressedInt(bb.Length);
 			buf.Write(bb);
 			keys[index].len = bb.Length;
 			keys[index].hash = hash;
 			keys[index].offset = offset;
 			return offset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1613" endline="1661">
<![CDATA[
 
 		// <summary>
 		//   Performs an `and' operation on the bit vector.  The `new_vector' may have
 		//   a different size than the current one.
 		// </summary>
 		private MyBitVector And (MyBitVector new_vector)
 		{
 			if (Count == 0)
 				return this;
 
 			var o = new_vector.vector != null ? new_vector.vector 
 
 			if (o == null) {
 				for (int i = new_vector.Count; i < Count; ++i)
 					this [i] = false;
 				for (int i = new_vector.Count; i < Count; ++i)
 					this [i] = false;
 				return this;
 			}
 
 			if (o.Count == 0) {
 				SetAll (false);
 				return this;
 			}
 
 			if (Count == o.Count) {
 				if (vector == null) {
 					if (shared == null) {
 						shared = new_vector.MakeShared (Count);
 						return this;
 					}
 					initialize_vector ();
 				}
 				vector.And (o);
 				return this;
 			}
 
 			int min = o.Count;
 			if (Count < min)
 				min = Count;
 
 			for (int i = 0; i < min; i++) {
 				if (! o [i])
 					this [i] = false;
 			}
 			for (int i = 0; i < min; i++) {
 				if (! o [i])
 					this [i] = false;
 			}
 
 			for (int i = min; i < Count; i++)
 				this [i] = false;
 			for (int i = min; i < Count; i++)
 				this [i] = false;
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1738" endline="1775">
<![CDATA[
 
 		public override void Emit ()
 		{
 			if (!IsTopLevel) {
 				MemberSpec candidate;
 				var conflict_symbol = MemberCache.FindBaseMember (this, out candidate);
 				if (conflict_symbol == null && candidate == null) {
 					if ((ModFlags & Modifiers.NEW) != 0)
 						Report.Warning (109, 4, Location, "The member `{0}' does not hide an inherited member. The new keyword is not required",
 							GetSignatureForError ());
 				} else {
 					if ((ModFlags & Modifiers.NEW) == 0) {
 						if (candidate == null)
 							candidate = conflict_symbol;
 
 						Report.SymbolRelatedToPreviousError (candidate);
 						Report.Warning (108, 2, Location, "`{0}' hides inherited member `{1}'. Use the new keyword if hiding was intended",
 							GetSignatureForError (), candidate.GetSignatureForError ());
 					}
 				}
 			}
 
 			if (all_tp_builders != null) {
 				int current_starts_index = CurrentTypeParametersStartIndex;
 				for (int i = 0; i < all_tp_builders.Length; i++) {
 					if (i < current_starts_index) {
 						TypeParameters[i].EmitConstraints (all_tp_builders [i]);
 					} else {
 						CurrentTypeParameters [i - current_starts_index].Emit ();
 					}
 				}
 				for (int i = 0; i < all_tp_builders.Length; i++) {
 					if (i < current_starts_index) {
 						TypeParameters[i].EmitConstraints (all_tp_builders [i]);
 					} else {
 						CurrentTypeParameters [i - current_starts_index].Emit ();
 					}
 				}
 			}
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (TypeBuilder);
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="927" endline="960">
<![CDATA[
 
 		private void ResolveBranches()
 		{
 			foreach (LabelFixup fixup in labelFixups)
 			{
 				// is it a switch?
 				if (fixup.label == -1)
 				{
 					code.Position = fixup.offset;
 					int count = code.GetInt32AtCurrentPosition();
 					int offset = fixup.offset + 4 + 4 * count;
 					code.Position += 4;
 					for (int i = 0; i < count; i++)
 					{
 						int index = code.GetInt32AtCurrentPosition();
 						code.Write(labels[index] - offset);
 					}
 					for (int i = 0; i < count; i++)
 					{
 						int index = code.GetInt32AtCurrentPosition();
 						code.Write(labels[index] - offset);
 					}
 				}
 				else
 				{
 					code.Position = fixup.offset;
 					byte size = code.GetByteAtCurrentPosition();
 					int branchOffset = labels[fixup.label] - (code.Position + size);
 					if (size == 1)
 					{
 						WriteByteBranchOffset(branchOffset);
 					}
 					else
 					{
 						code.Write(branchOffset);
 					}
 				}
 			}
 			foreach (LabelFixup fixup in labelFixups)
 			{
 				// is it a switch?
 				if (fixup.label == -1)
 				{
 					code.Position = fixup.offset;
 					int count = code.GetInt32AtCurrentPosition();
 					int offset = fixup.offset + 4 + 4 * count;
 					code.Position += 4;
 					for (int i = 0; i < count; i++)
 					{
 						int index = code.GetInt32AtCurrentPosition();
 						code.Write(labels[index] - offset);
 					}
 				}
 				else
 				{
 					code.Position = fixup.offset;
 					byte size = code.GetByteAtCurrentPosition();
 					int branchOffset = labels[fixup.label] - (code.Position + size);
 					if (size == 1)
 					{
 						WriteByteBranchOffset(branchOffset);
 					}
 					else
 					{
 						code.Write(branchOffset);
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="462" endline="487">
<![CDATA[
 
 		public override void EmitType ()
 		{
 			SymbolWriter.DefineAnonymousScope (ID);
 
 			if (hoisted_this != null)
 				hoisted_this.EmitSymbolInfo ();
 
 			if (hoisted_locals != null) {
 				foreach (HoistedVariable local in hoisted_locals)
 					local.EmitSymbolInfo ();
 				foreach (HoistedVariable local in hoisted_locals)
 					local.EmitSymbolInfo ();
 			}
 
 			if (hoisted_params != null) {
 				foreach (HoistedParameter param in hoisted_params)
 					param.EmitSymbolInfo ();
 				foreach (HoistedParameter param in hoisted_params)
 					param.EmitSymbolInfo ();
 			}
 
 			if (used_parent_storeys != null) {
 				foreach (StoreyFieldPair sf in used_parent_storeys) {
 					SymbolWriter.DefineCapturedScope (ID, sf.Storey.ID, sf.Field.Name);
 				}
 				foreach (StoreyFieldPair sf in used_parent_storeys) {
 					SymbolWriter.DefineCapturedScope (ID, sf.Storey.ID, sf.Field.Name);
 				}
 			}
 
 			base.EmitType ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1226" endline="1263">
<![CDATA[
 
 		public virtual void DefineConstants ()
 		{
 			if (constants != null) {
 				foreach (Const c in constants) {
 					c.DefineValue ();
 				}
 				foreach (Const c in constants) {
 					c.DefineValue ();
 				}
 			}
 
 			if (instance_constructors != null) {
 				foreach (MethodCore m in instance_constructors) {
 					var p = m.ParameterInfo;
 					if (!p.IsEmpty) {
 						p.ResolveDefaultValues (m);
 					}
 				}
 				foreach (MethodCore m in instance_constructors) {
 					var p = m.ParameterInfo;
 					if (!p.IsEmpty) {
 						p.ResolveDefaultValues (m);
 					}
 				}
 			}
 
 			if (methods != null) {
 				foreach (MethodCore m in methods) {
 					var p = m.ParameterInfo;
 					if (!p.IsEmpty) {
 						p.ResolveDefaultValues (m);
 					}
 				}
 				foreach (MethodCore m in methods) {
 					var p = m.ParameterInfo;
 					if (!p.IsEmpty) {
 						p.ResolveDefaultValues (m);
 					}
 				}
 			}
 
 			if (indexers != null) {
 				foreach (Indexer i in indexers) {
 					i.ParameterInfo.ResolveDefaultValues (i);
 				}
 				foreach (Indexer i in indexers) {
 					i.ParameterInfo.ResolveDefaultValues (i);
 				}
 			}
 
 			if (types != null) {
 				foreach (var t in types)
 					t.DefineConstants ();
 				foreach (var t in types)
 					t.DefineConstants ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2717" endline="2777">
<![CDATA[
 
 		public void AddLabel (string name, LabeledStatement label)
 		{
 			if (labels == null)
 				labels = new Dictionary<string, object> ();
 
 			object value;
 			if (!labels.TryGetValue (name, out value)) {
 				labels.Add (name, label);
 				return;
 			}
 
 			LabeledStatement existing = value as LabeledStatement;
 			List<LabeledStatement> existing_list;
 			if (existing != null) {
 				existing_list = new List<LabeledStatement> ();
 				existing_list.Add (existing);
 				labels[name] = existing_list;
 			} else {
 				existing_list = (List<LabeledStatement>) value;
 			}
 
 			//
 			// A collision checking between labels
 			//
 			for (int i = 0; i < existing_list.Count; ++i) {
 				existing = existing_list[i];
 				Block b = existing.Block;
 
 				// Collision at same level
 				if (label.Block == b) {
 					Report.SymbolRelatedToPreviousError (existing.loc, name);
 					Report.Error (140, label.loc, "The label `{0}' is a duplicate", name);
 					break;
 				}
 
 				// Collision with parent
 				b = label.Block;
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 
 				// Collision with with children
 				b = existing.Block;
 				while ((b = b.Parent) != null) {
 					if (label.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 				while ((b = b.Parent) != null) {
 					if (label.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 			}
 			for (int i = 0; i < existing_list.Count; ++i) {
 				existing = existing_list[i];
 				Block b = existing.Block;
 
 				// Collision at same level
 				if (label.Block == b) {
 					Report.SymbolRelatedToPreviousError (existing.loc, name);
 					Report.Error (140, label.loc, "The label `{0}' is a duplicate", name);
 					break;
 				}
 
 				// Collision with parent
 				b = label.Block;
 				while ((b = b.Parent) != null) {
 					if (existing.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 
 				// Collision with with children
 				b = existing.Block;
 				while ((b = b.Parent) != null) {
 					if (label.Block == b) {
 						Report.Error (158, label.loc,
 							"The label `{0}' shadows another label by the same name in a contained scope", name);
 						i = existing_list.Count;
 						break;
 					}
 				}
 			}
 
 			existing_list.Add (label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6893" endline="6914">
<![CDATA[
 
 		public virtual void ResolveBase (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 			type = ec.CurrentType;
 
 			if (!IsThisAvailable (ec, false)) {
 				Error_ThisNotAvailable (ec);
 				return;
 			}
 
 			var block = ec.CurrentBlock;
 			if (block != null) {
 				if (block.ParametersBlock.TopBlock.ThisVariable != null)
 					variable_info = block.ParametersBlock.TopBlock.ThisVariable.VariableInfo;
 
 				AnonymousExpression am = ec.CurrentAnonymousMethod;
 				if (am != null && ec.IsVariableCapturingRequired) {
 					am.SetHasThisAccess ();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="281" endline="301">
<![CDATA[
 
 		public new Constant Resolve (ResolveContext rc)
 		{
 			if (eclass != ExprClass.Unresolved)
 				return this;
 
 			// Resolved constant has to be still a constant
 			Constant c = (Constant) DoResolve (rc);
 			if (c == null)
 				return null;
 
 			if ((c.eclass & ExprClass.Value) == 0) {
 				c.Error_UnexpectedKind (rc, ResolveFlags.VariableOrValue, loc);
 				return null;
 			}
 
 			if (c.type == null)
 				throw new InternalErrorException ("Expression `{0}' did not set its type after Resolve", c.GetType ());
 
 			return c;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="590" endline="612">
<![CDATA[
 		}
 
 		void read_methods ()
 		{
 			lock (this) {
 				if (method_token_hash != null)
 					return;
 
 				method_token_hash = new Dictionary<int, MethodEntry> ();
 				method_list = new List<MethodEntry> ();
 
 				long old_pos = reader.BaseStream.Position;
 				reader.BaseStream.Position = ot.MethodTableOffset;
 
 				for (int i = 0; i < MethodCount; i++) {
 					MethodEntry entry = new MethodEntry (this, reader, i + 1);
 					method_token_hash.Add (entry.Token, entry);
 					method_list.Add (entry);
 				}
 				for (int i = 0; i < MethodCount; i++) {
 					MethodEntry entry = new MethodEntry (this, reader, i + 1);
 					method_token_hash.Add (entry.Token, entry);
 					method_list.Add (entry);
 				}
 
 				reader.BaseStream.Position = old_pos;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="383" endline="409">
<![CDATA[
 
 		public void __ReadTypeName(out string ns, out string name)
 		{
 			if (lazyConstructor == null)
 			{
 				ModuleReader mod = module as ModuleReader;
 				if (mod != null)
 				{
 					int methodToken = mod.CustomAttribute.records[index].Type;
 					if ((methodToken >> 24) == MemberRefTable.Index)
 					{
 						int methodIndex = (methodToken & 0xFFFFFF) - 1;
 						int typeToken = mod.MemberRef.records[methodIndex].Class;
 						if ((typeToken >> 24) == TypeRefTable.Index)
 						{
 							int typeIndex = (typeToken & 0xFFFFFF) - 1;
 							int typeNameSpace = mod.TypeRef.records[typeIndex].TypeNameSpace;
 							ns = typeNameSpace == 0 ? null 
 							name = mod.GetString(mod.TypeRef.records[typeIndex].TypeName);
 							return;
 						}
 					}
 				}
 			}
 			ns = Constructor.DeclaringType.Namespace;
 			name = Constructor.DeclaringType.Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="614" endline="662">
<![CDATA[
 
 		Expression ResolveAddressOf (ResolveContext ec)
 		{
 			if (!ec.IsUnsafe)
 				UnsafeError (ec, loc);
 
 			Expr = Expr.DoResolveLValue (ec, EmptyExpression.UnaryAddress);
 			if (Expr == null || Expr.eclass != ExprClass.Variable) {
 				ec.Report.Error (211, loc, "Cannot take the address of the given expression");
 				return null;
 			}
 
 			if (!TypeManager.VerifyUnmanaged (ec.Compiler, Expr.Type, loc)) {
 				return null;
 			}
 
 			IVariableReference vr = Expr as IVariableReference;
 			bool is_fixed;
 			if (vr != null) {
 				VariableInfo vi = vr.VariableInfo;
 				if (vi != null) {
 					if (vi.LocalInfo != null)
 						vi.LocalInfo.SetIsUsed ();
 
 					//
 					// A variable is considered definitely assigned if you take its address.
 					//
 					vi.SetAssigned (ec);
 				}
 
 				is_fixed = vr.IsFixed;
 				vr.SetHasAddressTaken ();
 
 				if (vr.IsHoisted) {
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, vr, loc);
 				}
 			} else {
 				IFixedExpression fe = Expr as IFixedExpression;
 				is_fixed = fe != null && fe.IsFixed;
 			}
 
 			if (!is_fixed && !ec.HasSet (ResolveContext.Options.FixedInitializerScope)) {
 				ec.Report.Error (212, loc, "You can only take the address of unfixed expression inside of a fixed statement initializer");
 			}
 
 			type = PointerContainer.MakeType (Expr.Type);
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4034" endline="4093">
<![CDATA[
 
 		public override void EmitForDispose (EmitContext ec, Iterator iterator, Label end, bool have_dispatcher)
 		{
 			if (emitted_dispose)
 				return;
 
 			emitted_dispose = true;
 
 			Label end_of_try = ec.DefineLabel ();
 
 			// Ensure that the only way we can get into this code is through a dispatcher
 			if (have_dispatcher)
 				ec.Emit (OpCodes.Br, end);
 
 			ec.BeginExceptionBlock ();
 
 			ec.MarkLabel (dispose_try_block);
 
 			Label [] labels = null;
 			for (int i = 0; i < resume_points.Count; ++i) {
 				ResumableStatement s = (ResumableStatement) resume_points [i];
 				Label ret = s.PrepareForDispose (ec, end_of_try);
 				if (ret.Equals (end_of_try) && labels == null)
 					continue;
 				if (labels == null) {
 					labels = new Label [resume_points.Count];
 					for (int j = 0; j < i; ++j)
 						labels [j] = end_of_try;
 					for (int j = 0; j < i; ++j)
 						labels [j] = end_of_try;
 				}
 				labels [i] = ret;
 			}
 			for (int i = 0; i < resume_points.Count; ++i) {
 				ResumableStatement s = (ResumableStatement) resume_points [i];
 				Label ret = s.PrepareForDispose (ec, end_of_try);
 				if (ret.Equals (end_of_try) && labels == null)
 					continue;
 				if (labels == null) {
 					labels = new Label [resume_points.Count];
 					for (int j = 0; j < i; ++j)
 						labels [j] = end_of_try;
 				}
 				labels [i] = ret;
 			}
 
 			if (labels != null) {
 				int j;
 				for (j = 1; j < labels.Length; ++j)
 					if (!labels [0].Equals (labels [j]))
 						break;
 				for (j = 1; j < labels.Length; ++j)
 					if (!labels [0].Equals (labels [j]))
 						break;
 				bool emit_dispatcher = j < labels.Length;
 
 				if (emit_dispatcher) {
 					//SymbolWriter.StartIteratorDispatcher (ec.ig);
 					ec.Emit (OpCodes.Ldloc, iterator.CurrentPC);
 					ec.EmitInt (first_resume_pc);
 					ec.Emit (OpCodes.Sub);
 					ec.Emit (OpCodes.Switch, labels);
 					//SymbolWriter.EndIteratorDispatcher (ec.ig);
 				}
 
 				foreach (ResumableStatement s in resume_points)
 					s.EmitForDispose (ec, iterator, end_of_try, emit_dispatcher);
 				foreach (ResumableStatement s in resume_points)
 					s.EmitForDispose (ec, iterator, end_of_try, emit_dispatcher);
 			}
 
 			ec.MarkLabel (end_of_try);
 
 			ec.BeginFinallyBlock ();
 
 			EmitFinallyBody (ec);
 
 			ec.EndExceptionBlock ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="69" endline="79">
<![CDATA[
 		}
 
 		public override ParameterInfo[] GetParameters()
 		{
 			ParameterInfo[] parameters = method.GetParameters();
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new GenericParameterInfoImpl(this, parameters[i]);
 			}
 			for (int i = 0; i < parameters.Length; i++)
 			{
 				parameters[i] = new GenericParameterInfoImpl(this, parameters[i]);
 			}
 			return parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="701" endline="750">
<![CDATA[
 
 		// MethodCore
 
 		//
 		// Returns a string that represents the signature for this 
 		// member which should be used in XML documentation.
 		//
 		public static string GetMethodDocCommentName (MemberCore mc, ParametersCompiled parameters, DeclSpace ds)
 		{
 			IParameterData [] plist = parameters.FixedParameters;
 			string paramSpec = String.Empty;
 			if (plist != null) {
 				StringBuilder psb = new StringBuilder ();
 				int i = 0;
 				foreach (Parameter p in plist) {
 					psb.Append (psb.Length != 0 ? "," 
 					psb.Append (GetSignatureForDoc (parameters.Types [i++]));
 					if ((p.ModFlags & Parameter.Modifier.ISBYREF) != 0)
 						psb.Append ('@');
 				}
 				foreach (Parameter p in plist) {
 					psb.Append (psb.Length != 0 ? "," 
 					psb.Append (GetSignatureForDoc (parameters.Types [i++]));
 					if ((p.ModFlags & Parameter.Modifier.ISBYREF) != 0)
 						psb.Append ('@');
 				}
 				paramSpec = psb.ToString ();
 			}
 
 			if (paramSpec.Length > 0)
 				paramSpec += ")";
 
 			string name = mc.Name;
 			if (mc is Constructor)
 				name = "#ctor";
 			else if (mc is InterfaceMemberBase) {
 				var imb = (InterfaceMemberBase) mc;
 				name = imb.GetFullName (imb.ShortName);
 			}
 			name = name.Replace ('.', '#');
 
 			if (mc.MemberName.TypeArguments != null && mc.MemberName.TypeArguments.Count > 0)
 				name += "``" + mc.MemberName.CountTypeArguments;
 
 			string suffix = String.Empty;
 			Operator op = mc as Operator;
 			if (op != null) {
 				switch (op.OperatorType) {
 				case Operator.OpType.Implicit
 				case Operator.OpType.Explicit
 					suffix = "~" + GetSignatureForDoc (op.ReturnType);
 					break;
 				}
 			}
 			return String.Concat (mc.DocCommentHeader, ds.Name, ".", name, paramSpec, suffix);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1137" endline="1223">
<![CDATA[
 		}
 
 		#endregion
 
 		public TypeSpec Inflate (TypeSpec type)
 		{
 			var tp = type as TypeParameterSpec;
 			if (tp != null)
 				return Inflate (tp);
 
 			var ac = type as ArrayContainer;
 			if (ac != null) {
 				var et = Inflate (ac.Element);
 				if (et != ac.Element)
 					return ArrayContainer.MakeType (et, ac.Rank);
 
 				return ac;
 			}
 
 			//
 			// When inflating a nested type, inflate its parent first
 			// in case it's using same type parameters (was inflated within the type)
 			//
 			TypeSpec[] targs;
 			int i = 0;
 			if (type.IsNested) {
 				var parent = Inflate (type.DeclaringType);
 
 				//
 				// Keep the inflated type arguments
 				// 
 				targs = type.TypeArguments;
 
 				//
 				// Parent was inflated, find the same type on inflated type
 				// to use same cache for nested types on same generic parent
 				//
 				type = MemberCache.FindNestedType (parent, type.Name, type.Arity);
 
 				//
 				// Handle the tricky case where parent shares local type arguments
 				// which means inflating inflated type
 				//
 				// class Test<T> {
 				//		public static Nested<T> Foo () { return null; }
 				//
 				//		public class Nested<U> {}
 				//	}
 				//
 				//  return type of Test<string>.Foo() has to be Test<string>.Nested<string> 
 				//
 				if (targs.Length > 0) {
 					var inflated_targs = new TypeSpec[targs.Length];
 					for (; i < targs.Length; ++i)
 						inflated_targs[i] = Inflate (targs[i]);
 					for (; i < targs.Length; ++i)
 						inflated_targs[i] = Inflate (targs[i]);
 
 					type = type.MakeGenericType (inflated_targs);
 				}
 
 				return type;
 			}
 
 			// Nothing to do for non-generic type
 			if (type.Arity == 0)
 				return type;
 
 			targs = new TypeSpec[type.Arity];
 
 			//
 			// Inflating using outside type arguments, var v = new Foo<int> (), class Foo<T> {}
 			//
 			if (type is InflatedTypeSpec) {
 				for (; i < targs.Length; ++i)
 					targs[i] = Inflate (type.TypeArguments[i]);
 				for (; i < targs.Length; ++i)
 					targs[i] = Inflate (type.TypeArguments[i]);
 
 				type = type.GetDefinition ();
 			} else {
 				//
 				// Inflating parent using inside type arguments, class Foo<T> { ITest<T> foo; }
 				//
 				var args = type.MemberDefinition.TypeParameters;
 				foreach (var ds_tp in args)
 					targs[i++] = Inflate (ds_tp);
 				foreach (var ds_tp in args)
 					targs[i++] = Inflate (ds_tp);
 			}
 
 			return type.MakeGenericType (targs);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2397" endline="2472">
<![CDATA[
 
 		//
 		// Implements method type arguments inference
 		//
 		bool InferInPhases (ResolveContext ec, TypeInferenceContext tic, AParametersCollection methodParameters)
 		{
 			int params_arguments_start;
 			if (methodParameters.HasParams) {
 				params_arguments_start = methodParameters.Count - 1;
 			} else {
 				params_arguments_start = arg_count;
 			}
 
 			TypeSpec [] ptypes = methodParameters.Types;
 			
 			//
 			// The first inference phase
 			//
 			TypeSpec method_parameter = null;
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments [i];
 				if (a == null)
 					continue;
 				
 				if (i < params_arguments_start) {
 					method_parameter = methodParameters.Types [i];
 				} else if (i == params_arguments_start) {
 					if (arg_count == params_arguments_start + 1 && TypeManager.HasElementType (a.Type))
 						method_parameter = methodParameters.Types [params_arguments_start];
 					else
 						method_parameter = TypeManager.GetElementType (methodParameters.Types [params_arguments_start]);
 
 					ptypes = (TypeSpec[]) ptypes.Clone ();
 					ptypes [i] = method_parameter;
 				}
 
 				//
 				// When a lambda expression, an anonymous method
 				// is used an explicit argument type inference takes a place
 				//
 				AnonymousMethodExpression am = a.Expr as AnonymousMethodExpression;
 				if (am != null) {
 					if (am.ExplicitTypeInference (ec, tic, method_parameter))
 						--score; 
 					continue;
 				}
 
 				if (a.IsByRef) {
 					score -= tic.ExactInference (a.Type, method_parameter);
 					continue;
 				}
 
 				if (a.Expr.Type == InternalType.Null)
 					continue;
 
 				if (TypeManager.IsValueType (method_parameter)) {
 					score -= tic.LowerBoundInference (a.Type, method_parameter);
 					continue;
 				}
 
 				//
 				// Otherwise an output type inference is made
 				//
 				score -= tic.OutputTypeInference (ec, a.Expr, method_parameter);
 			}
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments [i];
 				if (a == null)
 					continue;
 				
 				if (i < params_arguments_start) {
 					method_parameter = methodParameters.Types [i];
 				} else if (i == params_arguments_start) {
 					if (arg_count == params_arguments_start + 1 && TypeManager.HasElementType (a.Type))
 						method_parameter = methodParameters.Types [params_arguments_start];
 					else
 						method_parameter = TypeManager.GetElementType (methodParameters.Types [params_arguments_start]);
 
 					ptypes = (TypeSpec[]) ptypes.Clone ();
 					ptypes [i] = method_parameter;
 				}
 
 				//
 				// When a lambda expression, an anonymous method
 				// is used an explicit argument type inference takes a place
 				//
 				AnonymousMethodExpression am = a.Expr as AnonymousMethodExpression;
 				if (am != null) {
 					if (am.ExplicitTypeInference (ec, tic, method_parameter))
 						--score; 
 					continue;
 				}
 
 				if (a.IsByRef) {
 					score -= tic.ExactInference (a.Type, method_parameter);
 					continue;
 				}
 
 				if (a.Expr.Type == InternalType.Null)
 					continue;
 
 				if (TypeManager.IsValueType (method_parameter)) {
 					score -= tic.LowerBoundInference (a.Type, method_parameter);
 					continue;
 				}
 
 				//
 				// Otherwise an output type inference is made
 				//
 				score -= tic.OutputTypeInference (ec, a.Expr, method_parameter);
 			}
 
 			//
 			// Part of the second phase but because it happens only once
 			// we don't need to call it in cycle
 			//
 			bool fixed_any = false;
 			if (!tic.FixIndependentTypeArguments (ec, ptypes, ref fixed_any))
 				return false;
 
 			return DoSecondPhase (ec, tic, ptypes, !fixed_any);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="476" endline="482">
<![CDATA[
 
 		public CapturedVariable[] CapturedVariables {
 			get {
 				CapturedVariable[] retval = new CapturedVariable [captured_vars.Count];
 				captured_vars.CopyTo (retval, 0);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="489" endline="495">
<![CDATA[
 
 		public CapturedScope[] CapturedScopes {
 			get {
 				CapturedScope[] retval = new CapturedScope [captured_scopes.Count];
 				captured_scopes.CopyTo (retval, 0);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1224" endline="1234">
<![CDATA[
 
 		public TypeSpec Inflate (TypeParameterSpec tp)
 		{
 			for (int i = 0; i < tparams.Length; ++i)
 				if (tparams [i] == tp)
 					return targs[i];
 			for (int i = 0; i < tparams.Length; ++i)
 				if (tparams [i] == tp)
 					return targs[i];
 
 			// This can happen when inflating nested types
 			// without type arguments specified
 			return tp;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1231" endline="1255">
<![CDATA[
 	}
 
 	sealed class ClassLayoutTable 
 	{
 		internal const int Index = 0x0f;
 
 		internal struct Record
 		{
 			internal short PackingSize;
 			internal int ClassSize;
 			internal int Parent;
 		}
 
 		internal void AddOrReplaceRecord(Record rec)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				if (records[i].Parent == rec.Parent)
 				{
 					records[i] = rec;
 					return;
 				}
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				if (records[i].Parent == rec.Parent)
 				{
 					records[i] = rec;
 					return;
 				}
 			}
 			AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2419" endline="2431">
<![CDATA[
 
 		internal int FindOrAddRecord(Record record)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Method == record.Method
 					&& records[i].Instantiation == record.Instantiation)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Method == record.Method
 					&& records[i].Instantiation == record.Instantiation)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(record);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1351" endline="1364">
<![CDATA[
 
 		void UpdateTypeParameterConstraints (TypeContainer part)
 		{
 			TypeParameter[] current_params = type_params;
 			for (int i = 0; i < current_params.Length; i++) {
 				if (current_params [i].AddPartialConstraints (part, part.type_params [i]))
 					continue;
 
 				Report.SymbolRelatedToPreviousError (Location, "");
 				Report.Error (265, part.Location,
 					"Partial declarations of `{0}' have inconsistent constraints for type parameter `{1}'",
 					GetSignatureForError (), current_params [i].GetSignatureForError ());
 			}
 			for (int i = 0; i < current_params.Length; i++) {
 				if (current_params [i].AddPartialConstraints (part, part.type_params [i]))
 					continue;
 
 				Report.SymbolRelatedToPreviousError (Location, "");
 				Report.Error (265, part.Location,
 					"Partial declarations of `{0}' have inconsistent constraints for type parameter `{1}'",
 					GetSignatureForError (), current_params [i].GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="48" endline="67">
<![CDATA[
 
 		internal CustomAttributeData(ConstructorInfo constructor, object[] args, List<CustomAttributeNamedArgument> namedArguments)
 		{
 			this.lazyConstructor = constructor;
 			MethodSignature sig = constructor.MethodSignature;
 			List<CustomAttributeTypedArgument> list = new List<CustomAttributeTypedArgument>();
 			for (int i = 0; i < args.Length; i++)
 			{
 				list.Add(new CustomAttributeTypedArgument(sig.GetParameterType(i), args[i]));
 			}
 			for (int i = 0; i < args.Length; i++)
 			{
 				list.Add(new CustomAttributeTypedArgument(sig.GetParameterType(i), args[i]));
 			}
 			lazyConstructorArguments = list.AsReadOnly();
 			if (namedArguments == null)
 			{
 				this.lazyNamedArguments = Empty<CustomAttributeNamedArgument>.Array;
 			}
 			else
 			{
 				this.lazyNamedArguments = namedArguments.AsReadOnly();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="907" endline="964">
<![CDATA[
 
 		internal object GetRawConstantValue(Module module, int parent)
 		{
 			// TODO use binary search (if sorted)
 			for (int i = 0; i < module.Constant.records.Length; i++)
 			{
 				if (module.Constant.records[i].Parent == parent)
 				{
 					ByteReader br = module.GetBlob(module.Constant.records[i].Value);
 					switch (module.Constant.records[i].Type)
 					{
 						// see ModuleBuilder.AddConstant for the encodings
 						case Signature.ELEMENT_TYPE_BOOLEAN
 							return br.ReadByte() != 0;
 						case Signature.ELEMENT_TYPE_I1
 							return br.ReadSByte();
 						case Signature.ELEMENT_TYPE_I2
 							return br.ReadInt16();
 						case Signature.ELEMENT_TYPE_I4
 							return br.ReadInt32();
 						case Signature.ELEMENT_TYPE_I8
 							return br.ReadInt64();
 						case Signature.ELEMENT_TYPE_U1
 							return br.ReadByte();
 						case Signature.ELEMENT_TYPE_U2
 							return br.ReadUInt16();
 						case Signature.ELEMENT_TYPE_U4
 							return br.ReadUInt32();
 						case Signature.ELEMENT_TYPE_U8
 							return br.ReadUInt64();
 						case Signature.ELEMENT_TYPE_R4
 							return br.ReadSingle();
 						case Signature.ELEMENT_TYPE_R8
 							return br.ReadDouble();
 						case Signature.ELEMENT_TYPE_CHAR
 							return br.ReadChar();
 						case Signature.ELEMENT_TYPE_STRING
 							{
 								char[] chars = new char[br.Length / 2];
 								for (int j = 0; j < chars.Length; j++)
 								{
 									chars[j] = br.ReadChar();
 								}
 								for (int j = 0; j < chars.Length; j++)
 								{
 									chars[j] = br.ReadChar();
 								}
 								return new String(chars);
 							}
 						case Signature.ELEMENT_TYPE_CLASS
 							if (br.ReadInt32() != 0)
 							{
 								throw new BadImageFormatException();
 							}
 							return null;
 						default
 							throw new BadImageFormatException();
 					}
 				}
 			}
 			for (int i = 0; i < module.Constant.records.Length; i++)
 			{
 				if (module.Constant.records[i].Parent == parent)
 				{
 					ByteReader br = module.GetBlob(module.Constant.records[i].Value);
 					switch (module.Constant.records[i].Type)
 					{
 						// see ModuleBuilder.AddConstant for the encodings
 						case Signature.ELEMENT_TYPE_BOOLEAN
 							return br.ReadByte() != 0;
 						case Signature.ELEMENT_TYPE_I1
 							return br.ReadSByte();
 						case Signature.ELEMENT_TYPE_I2
 							return br.ReadInt16();
 						case Signature.ELEMENT_TYPE_I4
 							return br.ReadInt32();
 						case Signature.ELEMENT_TYPE_I8
 							return br.ReadInt64();
 						case Signature.ELEMENT_TYPE_U1
 							return br.ReadByte();
 						case Signature.ELEMENT_TYPE_U2
 							return br.ReadUInt16();
 						case Signature.ELEMENT_TYPE_U4
 							return br.ReadUInt32();
 						case Signature.ELEMENT_TYPE_U8
 							return br.ReadUInt64();
 						case Signature.ELEMENT_TYPE_R4
 							return br.ReadSingle();
 						case Signature.ELEMENT_TYPE_R8
 							return br.ReadDouble();
 						case Signature.ELEMENT_TYPE_CHAR
 							return br.ReadChar();
 						case Signature.ELEMENT_TYPE_STRING
 							{
 								char[] chars = new char[br.Length / 2];
 								for (int j = 0; j < chars.Length; j++)
 								{
 									chars[j] = br.ReadChar();
 								}
 								return new String(chars);
 							}
 						case Signature.ELEMENT_TYPE_CLASS
 							if (br.ReadInt32() != 0)
 							{
 								throw new BadImageFormatException();
 							}
 							return null;
 						default
 							throw new BadImageFormatException();
 					}
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="335" endline="384">
<![CDATA[
 
 		//
 		// Ignores any base interface member which can be hidden
 		// by this interface
 		//
 		static bool AddInterfaceMember (MemberSpec member, ref IList<MemberSpec> existing)
 		{
 			var member_param = member is IParametersMember ? ((IParametersMember) member).Parameters 
 
 			//
 			// interface IA 
 			// interface IB { bool Prop { get; } }
 			//
 			// IB.Prop is never accessible from IA interface
 			//
 			for (int i = 0; i < existing.Count; ++i) {
 				var entry = existing[i];
 
 				if (entry.Arity != member.Arity)
 					continue;
 
 				if (entry is IParametersMember) {
 					var entry_param = ((IParametersMember) entry).Parameters;
 					if (!TypeSpecComparer.Override.IsEqual (entry_param, member_param))
 						continue;
 				}
 
 				if (member.DeclaringType.ImplementsInterface (entry.DeclaringType, false)) {
 					if (existing is MemberSpec[]) {
 						existing = new MemberSpec[] { member };
 						return true;
 					}
 
 					existing.RemoveAt (i--);
 					continue;
 				}
 
 				if ((entry.DeclaringType == member.DeclaringType && entry.IsAccessor == member.IsAccessor) ||
 					entry.DeclaringType.ImplementsInterface (member.DeclaringType, false))
 					return false;
 			}
 			for (int i = 0; i < existing.Count; ++i) {
 				var entry = existing[i];
 
 				if (entry.Arity != member.Arity)
 					continue;
 
 				if (entry is IParametersMember) {
 					var entry_param = ((IParametersMember) entry).Parameters;
 					if (!TypeSpecComparer.Override.IsEqual (entry_param, member_param))
 						continue;
 				}
 
 				if (member.DeclaringType.ImplementsInterface (entry.DeclaringType, false)) {
 					if (existing is MemberSpec[]) {
 						existing = new MemberSpec[] { member };
 						return true;
 					}
 
 					existing.RemoveAt (i--);
 					continue;
 				}
 
 				if ((entry.DeclaringType == member.DeclaringType && entry.IsAccessor == member.IsAccessor) ||
 					entry.DeclaringType.ImplementsInterface (member.DeclaringType, false))
 					return false;
 			}
 
 			if (existing is MemberSpec[]) {
 				existing = new List<MemberSpec> () { existing[0], member };
 				return true;
 			}
 
 			existing.Add (member);
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1319" endline="1365">
<![CDATA[
 
 		public AnonymousExpression Compatible (ResolveContext ec, AnonymousExpression ae)
 		{
 			if (block.Resolved)
 				return this;
 
 			// TODO
 			BlockContext aec = new BlockContext (ec, block, ReturnType);
 			aec.CurrentAnonymousMethod = ae;
 
 			ResolveContext.Options flags = 0;
 
 			var am = this as AnonymousMethodBody;
 
 			if (ec.HasSet (ResolveContext.Options.InferReturnType) && am != null) {
 				am.ReturnTypeInference = new TypeInferenceContext ();
 			}
 
 			if (ec.IsInProbingMode)
 				flags |= ResolveContext.Options.ProbingMode;
 
 			if (ec.HasSet (ResolveContext.Options.FieldInitializerScope))
 				flags |= ResolveContext.Options.FieldInitializerScope;
 
 			if (ec.HasSet (ResolveContext.Options.ExpressionTreeConversion))
 				flags |= ResolveContext.Options.ExpressionTreeConversion;
 
 			aec.Set (flags);
 
 			var errors = ec.Report.Errors;
 
 			bool res = Block.Resolve (ec.CurrentBranching, aec, null);
 
 			if (aec.HasReturnLabel)
 				return_label = aec.ReturnLabel;
 
 			if (am != null && am.ReturnTypeInference != null) {
 				am.ReturnTypeInference.FixAllTypes (ec);
 				ReturnType = am.ReturnTypeInference.InferredTypeArguments [0];
 				am.ReturnTypeInference = null;
 			}
 
 			if (res && errors != ec.Report.Errors)
 				return null;
 
 			return res ? this 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="986" endline="1029">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			if (ec.Switch == null){
 				ec.Report.Error (153, loc, "A goto case is only valid inside a switch statement");
 				return false;
 			}
 
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return false;
 
 			Constant c = expr as Constant;
 			if (c == null) {
 				ec.Report.Error (150, expr.Location, "A constant value is expected");
 				return false;
 			}
 
 			TypeSpec type = ec.Switch.SwitchType;
 			Constant res = c.TryReduce (ec, type, c.Location);
 			if (res == null) {
 				c.Error_ValueCannotBeConverted (ec, loc, type, true);
 				return false;
 			}
 
 			if (!Convert.ImplicitStandardConversionExists (c, type))
 				ec.Report.Warning (469, 2, loc,
 					"The `goto case' value is not implicitly convertible to type `{0}'",
 					TypeManager.CSharpName (type));
 
 			object val = res.GetValue ();
 			if (val == null)
 				val = SwitchLabel.NullStringCase;
 					
 			if (!ec.Switch.Elements.TryGetValue (val, out sl)) {
 				FlowBranchingBlock.Error_UnknownLabel (loc, "case " + 
 					(c.GetValue () == null ? "null" 
 				return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2426" endline="2486">
<![CDATA[
 
 		Expression ResolveOperator (ResolveContext ec)
 		{
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Expression expr;
 			bool primitives_only = false;
 
 			if (standard_operators == null)
 				CreateStandardOperatorsTable ();
 
 			//
 			// Handles predefined primitive types
 			//
 			if (TypeManager.IsPrimitiveType (l) && TypeManager.IsPrimitiveType (r)) {
 				if ((oper & Operator.ShiftMask) == 0) {
 					if (l != TypeManager.bool_type && !DoBinaryOperatorPromotion (ec))
 						return null;
 
 					primitives_only = true;
 				}
 			} else {
 				// Pointers
 				if (l.IsPointer || r.IsPointer)
 					return ResolveOperatorPointer (ec, l, r);
 
 				// Enums
 				bool lenum = l.IsEnum;
 				bool renum = r.IsEnum;
 				if (lenum || renum) {
 					expr = ResolveOperatorEnum (ec, lenum, renum, l, r);
 
 					if (expr != null)
 						return expr;
 				}
 
 				// Delegates
 				if ((oper == Operator.Addition || oper == Operator.Subtraction) && (l.IsDelegate || r.IsDelegate)) {
 						
 					expr = ResolveOperatorDelegate (ec, l, r);
 
 					// TODO
 					if (expr != null)
 						return expr;
 				}
 
 				// User operators
 				expr = ResolveUserOperator (ec, left, right);
 				if (expr != null)
 					return expr;
 
 				// Predefined reference types equality
 				if ((oper & Operator.EqualityMask) != 0) {
 					expr = ResolveOperatorEquality (ec, l, r);
 					if (expr != null)
 						return expr;
 				}
 			}
 
 			return ResolveOperatorPredefined (ec, standard_operators, primitives_only, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="855" endline="920">
<![CDATA[
 
 		TypeParameterSpec CreateTypeParameter (MetaType type, TypeSpec declaringType)
 		{
 			Variance variance;
 			switch (type.GenericParameterAttributes & GenericParameterAttributes.VarianceMask) {
 			case GenericParameterAttributes.Covariant
 				variance = Variance.Covariant;
 				break;
 			case GenericParameterAttributes.Contravariant
 				variance = Variance.Contravariant;
 				break;
 			default
 				variance = Variance.None;
 				break;
 			}
 
 			SpecialConstraint special = SpecialConstraint.None;
 			var import_special = type.GenericParameterAttributes & GenericParameterAttributes.SpecialConstraintMask;
 
 			if ((import_special & GenericParameterAttributes.NotNullableValueTypeConstraint) != 0) {
 				special |= SpecialConstraint.Struct;
 			} else if ((import_special & GenericParameterAttributes.DefaultConstructorConstraint) != 0) {
 				special = SpecialConstraint.Constructor;
 			}
 
 			if ((import_special & GenericParameterAttributes.ReferenceTypeConstraint) != 0) {
 				special |= SpecialConstraint.Class;
 			}
 
 			TypeParameterSpec spec;
 			var def = new ImportedTypeParameterDefinition (type, this);
 			if (type.DeclaringMethod != null)
 				spec = new TypeParameterSpec (type.GenericParameterPosition, def, special, variance, type);
 			else
 				spec = new TypeParameterSpec (declaringType, type.GenericParameterPosition, def, special, variance, type);
 
 			// Add it now, so any constraint can reference it and get same instance
 			import_cache.Add (type, spec);
 
 			var constraints = type.GetGenericParameterConstraints ();
 			List<TypeSpec> tparams = null;
 			foreach (var ct in constraints) {
 				if (ct.IsGenericParameter) {
 					if (tparams == null)
 						tparams = new List<TypeSpec> ();
 
 					tparams.Add (CreateType (ct));
 					continue;
 				}
 
 				if (ct.IsClass) {
 					spec.BaseType = CreateType (ct);
 					continue;
 				}
 
 				spec.AddInterface (CreateType (ct));
 			}
 			foreach (var ct in constraints) {
 				if (ct.IsGenericParameter) {
 					if (tparams == null)
 						tparams = new List<TypeSpec> ();
 
 					tparams.Add (CreateType (ct));
 					continue;
 				}
 
 				if (ct.IsClass) {
 					spec.BaseType = CreateType (ct);
 					continue;
 				}
 
 				spec.AddInterface (CreateType (ct));
 			}
 
 			if (spec.BaseType == null)
 				spec.BaseType = TypeManager.object_type;
 
 			if (tparams != null)
 				spec.TypeArguments = tparams.ToArray ();
 
 			return spec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="645" endline="652">
<![CDATA[
 
 		public NamespaceEntry[] Namespaces {
 			get {
 				ReadData ();
 				NamespaceEntry[] retval = new NamespaceEntry [namespaces.Count];
 				namespaces.CopyTo (retval, 0);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1278" endline="1294">
<![CDATA[
 		}
 
 		public MethodInfo GetConstructor ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			var ctor = mb.GetArrayMethod (
 				GetMetaInfo (), Constructor.ConstructorName,
 				CallingConventions.HasThis,
 				null, arg_types);
 
 			return ctor;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="125" endline="157">
<![CDATA[
 
 		public override __MethodImplMap __GetMethodImplMap()
 		{
 			List<MethodInfo> bodies = new List<MethodInfo>();
 			List<List<MethodInfo>> declarations = new List<List<MethodInfo>>();
 			int token = this.MetadataToken;
 			// TODO use binary search?
 			for (int i = 0; i < module.MethodImpl.records.Length; i++)
 			{
 				if (module.MethodImpl.records[i].Class == token)
 				{
 					MethodInfo body = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodBody, typeArgs, null);
 					int index = bodies.IndexOf(body);
 					if (index == -1)
 					{
 						index = bodies.Count;
 						bodies.Add(body);
 						declarations.Add(new List<MethodInfo>());
 					}
 					MethodInfo declaration = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodDeclaration, typeArgs, null);
 					declarations[index].Add(declaration);
 				}
 			}
 			for (int i = 0; i < module.MethodImpl.records.Length; i++)
 			{
 				if (module.MethodImpl.records[i].Class == token)
 				{
 					MethodInfo body = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodBody, typeArgs, null);
 					int index = bodies.IndexOf(body);
 					if (index == -1)
 					{
 						index = bodies.Count;
 						bodies.Add(body);
 						declarations.Add(new List<MethodInfo>());
 					}
 					MethodInfo declaration = (MethodInfo)module.ResolveMethod(module.MethodImpl.records[i].MethodDeclaration, typeArgs, null);
 					declarations[index].Add(declaration);
 				}
 			}
 			__MethodImplMap map = new __MethodImplMap();
 			map.TargetType = this;
 			map.MethodBodies = bodies.ToArray();
 			map.MethodDeclarations = new MethodInfo[declarations.Count][];
 			for (int i = 0; i < map.MethodDeclarations.Length; i++)
 			{
 				map.MethodDeclarations[i] = declarations[i].ToArray();
 			}
 			for (int i = 0; i < map.MethodDeclarations.Length; i++)
 			{
 				map.MethodDeclarations[i] = declarations[i].ToArray();
 			}
 			return map;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="45" endline="88">
<![CDATA[
 
 		internal void AddIcon(byte[] iconFile)
 		{
 			BinaryReader br = new BinaryReader(new MemoryStream(iconFile));
 			ushort idReserved = br.ReadUInt16();
 			ushort idType = br.ReadUInt16();
 			ushort idCount = br.ReadUInt16();
 			if (idReserved != 0 || idType != 1)
 			{
 				throw new ArgumentException("The supplied byte array is not a valid .ico file.");
 			}
 			ByteBuffer group = new ByteBuffer(6 + 14 * idCount);
 			group.Write(idReserved);
 			group.Write(idType);
 			group.Write(idCount);
 			for (int i = 0; i < idCount; i++)
 			{
 				byte bWidth = br.ReadByte();
 				byte bHeight = br.ReadByte();
 				byte bColorCount = br.ReadByte();
 				byte bReserved = br.ReadByte();
 				ushort wPlanes = br.ReadUInt16();
 				ushort wBitCount = br.ReadUInt16();
 				uint dwBytesInRes = br.ReadUInt32();
 				uint dwImageOffset = br.ReadUInt32();
 
 				// we start the icon IDs at 2
 				ushort id = (ushort)(2 + i);
 
 				group.Write(bWidth);
 				group.Write(bHeight);
 				group.Write(bColorCount);
 				group.Write(bReserved);
 				group.Write(wPlanes);
 				group.Write(wBitCount);
 				group.Write(dwBytesInRes);
 				group.Write(id);
 
 				byte[] icon = new byte[dwBytesInRes];
 				Buffer.BlockCopy(iconFile, (int)dwImageOffset, icon, 0, icon.Length);
 				root[new OrdinalOrName(RT_ICON)][new OrdinalOrName(id)][new OrdinalOrName(0)].Data = ByteBuffer.Wrap(icon);
 			}
 			for (int i = 0; i < idCount; i++)
 			{
 				byte bWidth = br.ReadByte();
 				byte bHeight = br.ReadByte();
 				byte bColorCount = br.ReadByte();
 				byte bReserved = br.ReadByte();
 				ushort wPlanes = br.ReadUInt16();
 				ushort wBitCount = br.ReadUInt16();
 				uint dwBytesInRes = br.ReadUInt32();
 				uint dwImageOffset = br.ReadUInt32();
 
 				// we start the icon IDs at 2
 				ushort id = (ushort)(2 + i);
 
 				group.Write(bWidth);
 				group.Write(bHeight);
 				group.Write(bColorCount);
 				group.Write(bReserved);
 				group.Write(wPlanes);
 				group.Write(wBitCount);
 				group.Write(dwBytesInRes);
 				group.Write(id);
 
 				byte[] icon = new byte[dwBytesInRes];
 				Buffer.BlockCopy(iconFile, (int)dwImageOffset, icon, 0, icon.Length);
 				root[new OrdinalOrName(RT_ICON)][new OrdinalOrName(id)][new OrdinalOrName(0)].Data = ByteBuffer.Wrap(icon);
 			}
 			root[new OrdinalOrName(RT_GROUP_ICON)][new OrdinalOrName(32512)][new OrdinalOrName(0)].Data = group;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="306" endline="358">
<![CDATA[
 
 		/// <summary>
 		///   C# allows this kind of scenarios
 		///   interface I { void M (); }
 		///   class X { public void M (); }
 		///   class Y 
 		///
 		///   For that case, we create an explicit implementation function
 		///   I.M in Y.
 		/// </summary>
 		void DefineProxy (TypeSpec iface, MethodSpec base_method, MethodSpec iface_method)
 		{
 			// TODO
 			string proxy_name;
 			var ns = iface.MemberDefinition.Namespace;
 			if (string.IsNullOrEmpty (ns))
 				proxy_name = iface.MemberDefinition.Name + "." + iface_method.Name;
 			else
 				proxy_name = ns + "." + iface.MemberDefinition.Name + "." + iface_method.Name;
 
 			var param = iface_method.Parameters;
 
 			MethodBuilder proxy = container.TypeBuilder.DefineMethod (
 				proxy_name,
 				MethodAttributes.HideBySig |
 				MethodAttributes.NewSlot |
 				MethodAttributes.CheckAccessOnOverride |
 				MethodAttributes.Virtual,
 				CallingConventions.Standard | CallingConventions.HasThis,
 				base_method.ReturnType.GetMetaInfo (), param.GetMetaInfo ());
 
 			if (iface_method.IsGeneric) {
 				var gnames = iface_method.GenericDefinition.TypeParameters.Select (l => l.Name).ToArray ();
 				proxy.DefineGenericParameters (gnames);
 			}
 
 			for (int i = 0; i < param.Count; i++) {
 				string name = param.FixedParameters [i].Name;
 				ParameterAttributes attr = ParametersCompiled.GetParameterAttribute (param.FixedParameters [i].ModFlags);
 				proxy.DefineParameter (i + 1, attr, name);
 			}
 			for (int i = 0; i < param.Count; i++) {
 				string name = param.FixedParameters [i].Name;
 				ParameterAttributes attr = ParametersCompiled.GetParameterAttribute (param.FixedParameters [i].ModFlags);
 				proxy.DefineParameter (i + 1, attr, name);
 			}
 
 			int top = param.Count;
 			var ec = new EmitContext (null, proxy.GetILGenerator (), null);
 			// TODO
 			for (int i = 0; i <= top; i++)
 				ParameterReference.EmitLdArg (ec, i);
 			for (int i = 0; i <= top; i++)
 				ParameterReference.EmitLdArg (ec, i);
 
 			ec.Emit (OpCodes.Call, base_method);
 			ec.Emit (OpCodes.Ret);
 
 			container.TypeBuilder.DefineMethodOverride (proxy, (MethodInfo) iface_method.GetMetaInfo ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="3118" endline="3189">
<![CDATA[
 
 		//
 		// 26.3.3.6 Output Type Inference
 		//
 		public int OutputTypeInference (ResolveContext ec, Expression e, TypeSpec t)
 		{
 			// If e is a lambda or anonymous method with inferred return type
 			AnonymousMethodExpression ame = e as AnonymousMethodExpression;
 			if (ame != null) {
 				TypeSpec rt = ame.InferReturnType (ec, this, t);
 				var invoke = Delegate.GetInvokeMethod (ec.Compiler, t);
 
 				if (rt == null) {
 					AParametersCollection pd = invoke.Parameters;
 					return ame.Parameters.Count == pd.Count ? 1 
 				}
 
 				TypeSpec rtype = invoke.ReturnType;
 				return LowerBoundInference (rt, rtype) + 1;
 			}
 
 			//
 			// if E is a method group and T is a delegate type or expression tree type
 			// return type Tb with parameter types T1..Tk and return type Tb, and overload
 			// resolution of E with the types T1..Tk yields a single method with return type U,
 			// then a lower-bound inference is made from U for Tb.
 			//
 			if (e is MethodGroupExpr) {
 				if (!TypeManager.IsDelegateType (t)) {
 					if (TypeManager.expression_type == null || t.MemberDefinition != TypeManager.expression_type.MemberDefinition)
 						return 0;
 
 					t = TypeManager.GetTypeArguments (t)[0];
 				}
 
 				var invoke = Delegate.GetInvokeMethod (ec.Compiler, t);
 				TypeSpec rtype = invoke.ReturnType;
 
 				if (!rtype.IsGenericParameter && !TypeManager.IsGenericType (rtype))
 					return 0;
 
 				// LAMESPEC
 				// has to be fixed but it does not specify how to do recursive type inference
 				// either. We choose the simple option and infer return type only
 				// if all delegate generic arguments are fixed.
 				TypeSpec[] param_types = new TypeSpec [invoke.Parameters.Count];
 				for (int i = 0; i < param_types.Length; ++i) {
 					var inflated = InflateGenericArgument (invoke.Parameters.Types[i]);
 					if (inflated == null)
 						return 0;
 
 					if (IsUnfixed (inflated) >= 0)
 						return 0;
 
 					param_types[i] = inflated;
 				}
 				for (int i = 0; i < param_types.Length; ++i) {
 					var inflated = InflateGenericArgument (invoke.Parameters.Types[i]);
 					if (inflated == null)
 						return 0;
 
 					if (IsUnfixed (inflated) >= 0)
 						return 0;
 
 					param_types[i] = inflated;
 				}
 
 				MethodGroupExpr mg = (MethodGroupExpr) e;
 				Arguments args = DelegateCreation.CreateDelegateMethodArguments (invoke.Parameters, param_types, e.Location);
 				mg = mg.OverloadResolve (ec, ref args, null, OverloadResolver.Restrictions.CovariantDelegate | OverloadResolver.Restrictions.ProbingOnly);
 				if (mg == null)
 					return 0;
 
 				return LowerBoundInference (mg.BestCandidateReturnType, rtype) + 1;
 			}
 
 			//
 			// if e is an expression with type U, then
 			// a lower-bound inference is made from U for T
 			//
 			return LowerBoundInference (e.Type, t) * 2;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9614" endline="9635">
<![CDATA[
 
 		AnonymousTypeClass CreateAnonymousType (ResolveContext ec, IList<AnonymousTypeParameter> parameters)
 		{
 			AnonymousTypeClass type = parent.Module.GetAnonymousType (parameters);
 			if (type != null)
 				return type;
 
 			type = AnonymousTypeClass.Create (ec.Compiler, parent, parameters, loc);
 			if (type == null)
 				return null;
 
 			type.CreateType ();
 			type.DefineType ();
 			type.ResolveTypeParameters ();
 			type.Define ();
 			type.EmitType ();
 			if (ec.Report.Errors == 0)
 				type.CloseType ();
 
 			parent.Module.AddAnonymousType (type);
 			return type;
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6356" endline="6402">
<![CDATA[
 
 string GetExpecting ()
 {
 	int [] tokens = yyExpectingTokens (yyExpectingState);
 	var names = new List<string> (tokens.Length);
 	bool has_type = false;
 	bool has_identifier = false;
 	for (int i = 0; i < tokens.Length; i++){
 		int token = tokens [i];
 		has_identifier |= token == Token.IDENTIFIER;
 		
 		string name = GetTokenName (token);
 		if (name == "<internal>")
 			continue;
 			
 		has_type |= name == "type";
 		if (names.Contains (name))
 			continue;
 		
 		names.Add (name);
 	}
 	for (int i = 0; i < tokens.Length; i++){
 		int token = tokens [i];
 		has_identifier |= token == Token.IDENTIFIER;
 		
 		string name = GetTokenName (token);
 		if (name == "<internal>")
 			continue;
 			
 		has_type |= name == "type";
 		if (names.Contains (name))
 			continue;
 		
 		names.Add (name);
 	}
 
 	//
 	// Too many tokens to enumerate
 	//
 	if (names.Count > 8)
 		return null;
 
 	if (has_type && has_identifier)
 		names.Remove ("identifier");
 
 	if (names.Count == 1)
 		return "`" + GetTokenName (tokens [0]) + "'";
 	
 	StringBuilder sb = new StringBuilder ();
 	names.Sort ();
 	int count = names.Count;
 	for (int i = 0; i < count; i++){
 		bool last = i + 1 == count;
 		if (last)
 			sb.Append ("or ");
 		sb.Append ('`');
 		sb.Append (names [i]);
 		sb.Append (last ? "'" 
 	}
 	for (int i = 0; i < count; i++){
 		bool last = i + 1 == count;
 		if (last)
 			sb.Append ("or ");
 		sb.Append ('`');
 		sb.Append (names [i]);
 		sb.Append (last ? "'" 
 	}
 	return sb.ToString ();
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4833" endline="4895">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			ec.StartFlowBranching (this);
 
 			if (!Block.Resolve (ec))
 				ok = false;
 
 			TypeSpec[] prev_catches = new TypeSpec [Specific.Count];
 			int last_index = 0;
 			foreach (Catch c in Specific){
 				ec.CurrentBranching.CreateSibling (c.Block, FlowBranching.SiblingType.Catch);
 
 				if (!c.Resolve (ec)) {
 					ok = false;
 					continue;
 				}
 
 				TypeSpec resolved_type = c.CatchType;
 				for (int ii = 0; ii < last_index; ++ii) {
 					if (resolved_type == prev_catches[ii] || TypeSpec.IsBaseClass (resolved_type, prev_catches[ii], true)) {
 						ec.Report.Error (160, c.loc,
 							"A previous catch clause already catches all exceptions of this or a super type `{0}'",
 							TypeManager.CSharpName (prev_catches [ii]));
 						ok = false;
 					}
 				}
 				for (int ii = 0; ii < last_index; ++ii) {
 					if (resolved_type == prev_catches[ii] || TypeSpec.IsBaseClass (resolved_type, prev_catches[ii], true)) {
 						ec.Report.Error (160, c.loc,
 							"A previous catch clause already catches all exceptions of this or a super type `{0}'",
 							TypeManager.CSharpName (prev_catches [ii]));
 						ok = false;
 					}
 				}
 
 				prev_catches [last_index++] = resolved_type;
 			}
 			foreach (Catch c in Specific){
 				ec.CurrentBranching.CreateSibling (c.Block, FlowBranching.SiblingType.Catch);
 
 				if (!c.Resolve (ec)) {
 					ok = false;
 					continue;
 				}
 
 				TypeSpec resolved_type = c.CatchType;
 				for (int ii = 0; ii < last_index; ++ii) {
 					if (resolved_type == prev_catches[ii] || TypeSpec.IsBaseClass (resolved_type, prev_catches[ii], true)) {
 						ec.Report.Error (160, c.loc,
 							"A previous catch clause already catches all exceptions of this or a super type `{0}'",
 							TypeManager.CSharpName (prev_catches [ii]));
 						ok = false;
 					}
 				}
 
 				prev_catches [last_index++] = resolved_type;
 			}
 
 			if (General != null) {
 				foreach (Catch c in Specific) {
 					if (c.CatchType != TypeManager.exception_type)
 						continue;
 
 					if (!ec.Module.DeclaringAssembly.WrapNonExceptionThrows)
 						continue;
 
 					if (!ec.Module.PredefinedAttributes.RuntimeCompatibility.IsDefined)
 						continue;
 
 					ec.Report.Warning (1058, 1, c.loc,
 						"A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a `System.Runtime.CompilerServices.RuntimeWrappedException'");
 				}
 				foreach (Catch c in Specific) {
 					if (c.CatchType != TypeManager.exception_type)
 						continue;
 
 					if (!ec.Module.DeclaringAssembly.WrapNonExceptionThrows)
 						continue;
 
 					if (!ec.Module.PredefinedAttributes.RuntimeCompatibility.IsDefined)
 						continue;
 
 					ec.Report.Warning (1058, 1, c.loc,
 						"A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a `System.Runtime.CompilerServices.RuntimeWrappedException'");
 				}
 
 				ec.CurrentBranching.CreateSibling (General.Block, FlowBranching.SiblingType.Catch);
 
 				if (!General.Resolve (ec))
 					ok = false;
 			}
 
 			ec.EndFlowBranching ();
 
 			// System.Reflection.Emit automatically emits a 'leave' at the end of a try/catch clause
 			// So, ensure there's some IL code after this statement
 			if (!inside_try_finally && !code_follows && ec.CurrentBranching.CurrentUsageVector.IsUnreachable)
 				ec.NeedReturnLabel ();
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="976" endline="1049">
<![CDATA[
 
 		static void FindApplicableUserDefinedConversionOperators (IList<MemberSpec> operators, Expression source, TypeSpec target, bool implicitOnly, ref List<MethodSpec> candidates)
 		{
 			//
 			// LAMESPEC
 			// IntPtr -> uint uses int
 			// UIntPtr -> long uses ulong
 			//
 			if (source.Type == TypeManager.intptr_type) {
 				if (target == TypeManager.uint32_type)
 					target = TypeManager.int32_type;
 			} else if (source.Type == TypeManager.uintptr_type) {
 				if (target == TypeManager.int64_type)
 					target = TypeManager.uint64_type;
 			}
 
 			// Neither A nor B are interface-types
 			if (source.Type.IsInterface)
 				return;
 
 			// For a conversion operator to be applicable, it must be possible
 			// to perform a standard conversion from the source type to
 			// the operand type of the operator, and it must be possible
 			// to perform a standard conversion from the result type of
 			// the operator to the target type.
 
 			Expression texpr = null;
 
 			foreach (MethodSpec op in operators) {
 				
 				// Can be null because MemberCache.GetUserOperator does not resize the array
 				if (op == null)
 					continue;
 
 				var t = op.Parameters.Types[0];
 				if (source.Type != t && !ImplicitStandardConversionExists (source, t)) {
 					if (implicitOnly)
 						continue;
 
 					if (!ImplicitStandardConversionExists (new EmptyExpression (t), source.Type))
 						continue;
 				}
 
 				t = op.ReturnType;
 
 				// LAMESPEC
 				if (t == TypeManager.uint32_type && source.Type == TypeManager.uintptr_type)
 					continue;
 
 				if (t.IsInterface)
 					continue;
 
 				if (target != t) {
 					if (TypeManager.IsNullableType (t))
 						t = Nullable.NullableInfo.GetUnderlyingType (t);
 
 					if (!ImplicitStandardConversionExists (new EmptyExpression (t), target)) {
 						if (implicitOnly)
 							continue;
 
 						if (texpr == null)
 							texpr = new EmptyExpression (target);
 
 						if (!ImplicitStandardConversionExists (texpr, t))
 							continue;
 					}
 				}
 
 				if (candidates == null)
 					candidates = new List<MethodSpec> ();
 
 				candidates.Add (op);
 			}
 			foreach (MethodSpec op in operators) {
 				
 				// Can be null because MemberCache.GetUserOperator does not resize the array
 				if (op == null)
 					continue;
 
 				var t = op.Parameters.Types[0];
 				if (source.Type != t && !ImplicitStandardConversionExists (source, t)) {
 					if (implicitOnly)
 						continue;
 
 					if (!ImplicitStandardConversionExists (new EmptyExpression (t), source.Type))
 						continue;
 				}
 
 				t = op.ReturnType;
 
 				// LAMESPEC
 				if (t == TypeManager.uint32_type && source.Type == TypeManager.uintptr_type)
 					continue;
 
 				if (t.IsInterface)
 					continue;
 
 				if (target != t) {
 					if (TypeManager.IsNullableType (t))
 						t = Nullable.NullableInfo.GetUnderlyingType (t);
 
 					if (!ImplicitStandardConversionExists (new EmptyExpression (t), target)) {
 						if (implicitOnly)
 							continue;
 
 						if (texpr == null)
 							texpr = new EmptyExpression (target);
 
 						if (!ImplicitStandardConversionExists (texpr, t))
 							continue;
 					}
 				}
 
 				if (candidates == null)
 					candidates = new List<MethodSpec> ();
 
 				candidates.Add (op);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1605" endline="1611">
<![CDATA[
 
 		public byte[] ToArray ()
 		{
 			byte[] buf = new byte[pos];
 			Array.Copy (buffer, buf, pos);
 			return buf;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="259" endline="265">
<![CDATA[
 
 		internal byte[] ToArray()
 		{
 			byte[] buf = new byte[pos];
 			Buffer.BlockCopy(buffer, 0, buf, 0, pos);
 			return buf;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1327" endline="1344">
<![CDATA[
 
 		public MethodInfo GetSetMethod ()
 		{
 			var mb = RootContext.ToplevelTypes.Builder;
 
 			var arg_types = new MetaType[rank + 1];
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 			for (int i = 0; i < rank; i++)
 				arg_types[i] = TypeManager.int32_type.GetMetaInfo ();
 
 			arg_types[rank] = Element.GetMetaInfo ();
 
 			var set = mb.GetArrayMethod (
 				GetMetaInfo (), "Set",
 				CallingConventions.HasThis | CallingConventions.Standard,
 				TypeManager.void_type.GetMetaInfo (), arg_types);
 
 			return set;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="736" endline="752">
<![CDATA[
 
 		static public byte[] FromHex (string hex) 
 		{
 			if (hex == null)
 				return null;
 			if ((hex.Length & 0x1) == 0x1)
 				throw new ArgumentException ("Length must be a multiple of 2");
 
 			byte[] result = new byte [hex.Length >> 1];
 			int n = 0;
 			int i = 0;
 			while (n < result.Length) {
 				result [n] = (byte) (FromHexChar (hex [i++]) << 4);
 				result [n++] += FromHexChar (hex [i++]);
 			}
 			while (n < result.Length) {
 				result [n] = (byte) (FromHexChar (hex [i++]) << 4);
 				result [n++] += FromHexChar (hex [i++]);
 			}
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="504" endline="544">
<![CDATA[
 
 		//
 		// Creates storey instance expression regardless of currect IP
 		//
 		public Expression GetStoreyInstanceExpression (EmitContext ec)
 		{
 			AnonymousExpression am = ec.CurrentAnonymousMethod;
 
 			//
 			// Access from original block -> storey
 			//
 			if (am == null)
 				return Instance;
 
 			//
 			// Access from anonymous method implemented as a static -> storey
 			//
 			if (am.Storey == null)
 				return Instance;
 
 			Field f = am.Storey.GetReferencedStoreyField (this);
 			if (f == null) {
 				if (am.Storey == this) {
 					//
 					// Access inside of same storey (S -> S)
 					//
 					return new CompilerGeneratedThis (CurrentType, Location);
 				}
 				//
 				// External field access
 				//
 				return Instance;
 			}
 
 			//
 			// Storey was cached to local field
 			//
 			FieldExpr f_ind = new FieldExpr (f, Location);
 			f_ind.InstanceExpression = new CompilerGeneratedThis (CurrentType, Location);
 			return f_ind;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="624" endline="639">
<![CDATA[
 
 		private TypeDefImpl FindFieldOwner(int fieldIndex)
 		{
 			// TODO use binary search?
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int field = TypeDef.records[i].FieldList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1 
 				if (field <= fieldIndex && fieldIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int field = TypeDef.records[i].FieldList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].FieldList - 1 
 				if (field <= fieldIndex && fieldIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="724" endline="740">
<![CDATA[
 		}
 
 		private TypeDefImpl FindMethodOwner(int methodIndex)
 		{
 			// TODO use binary search?
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int method = TypeDef.records[i].MethodList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1 
 				if (method <= methodIndex && methodIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			for (int i = 0; i < TypeDef.records.Length; i++)
 			{
 				int method = TypeDef.records[i].MethodList - 1;
 				int end = TypeDef.records.Length > i + 1 ? TypeDef.records[i + 1].MethodList - 1 
 				if (method <= methodIndex && methodIndex < end)
 				{
 					PopulateTypeDef();
 					return typeDefs[i];
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="592" endline="623">
<![CDATA[
 
 		protected override Arguments CreateSetterArguments (ResolveContext rc, Expression rhs)
 		{
 			//
 			// Indexer has arguments which complicates things as the setter and getter
 			// are called in two steps when unary mutator is used. We have to make a
 			// copy of all variable arguments to not duplicate any side effect.
 			//
 			// ++d[++arg, Foo ()]
 			//
 
 			if (!can_be_mutator)
 				return base.CreateSetterArguments (rc, rhs);
 
 			var setter_args = new Arguments (Arguments.Count + 1);
 			for (int i = 0; i < Arguments.Count; ++i) {
 				var expr = Arguments[i].Expr;
 
 				if (expr is Constant || expr is VariableReference || expr is This) {
 					setter_args.Add (Arguments [i]);
 					continue;
 				}
 
 				LocalVariable temp = LocalVariable.CreateCompilerGenerated (expr.Type, rc.CurrentBlock, loc);
 				expr = new SimpleAssign (temp.CreateReferenceExpression (rc, expr.Location), expr).Resolve (rc);
 				Arguments[i].Expr = temp.CreateReferenceExpression (rc, expr.Location).Resolve (rc);
 				setter_args.Add (Arguments [i].Clone (expr));
 			}
 			for (int i = 0; i < Arguments.Count; ++i) {
 				var expr = Arguments[i].Expr;
 
 				if (expr is Constant || expr is VariableReference || expr is This) {
 					setter_args.Add (Arguments [i]);
 					continue;
 				}
 
 				LocalVariable temp = LocalVariable.CreateCompilerGenerated (expr.Type, rc.CurrentBlock, loc);
 				expr = new SimpleAssign (temp.CreateReferenceExpression (rc, expr.Location), expr).Resolve (rc);
 				Arguments[i].Expr = temp.CreateReferenceExpression (rc, expr.Location).Resolve (rc);
 				setter_args.Add (Arguments [i].Clone (expr));
 			}
 
 			setter_args.Add (new Argument (rhs));
 			return setter_args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="79" endline="105">
<![CDATA[
 		}
 
 		protected TypeParameterMutator mutator;
 
 		public HoistedStoreyClass (DeclSpace parent, MemberName name, TypeParameter[] tparams, Modifiers mod)
 			
 		{
 			if (tparams != null) {
 				type_params = new TypeParameter[tparams.Length];
 				var src = new TypeParameterSpec[tparams.Length];
 				var dst = new TypeParameterSpec[tparams.Length];
 
 				for (int i = 0; i < type_params.Length; ++i) {
 					type_params[i] = tparams[i].CreateHoistedCopy (this, spec);
 
 					src[i] = tparams[i].Type;
 					dst[i] = type_params[i].Type;
 				}
 				for (int i = 0; i < type_params.Length; ++i) {
 					type_params[i] = tparams[i].CreateHoistedCopy (this, spec);
 
 					src[i] = tparams[i].Type;
 					dst[i] = type_params[i].Type;
 				}
 
 				// A copy is not enough, inflate any type parameter constraints
 				// using a new type parameters
 				var inflator = new TypeParameterInflator (null, src, dst);
 				for (int i = 0; i < type_params.Length; ++i) {
 					src[i].InflateConstraints (inflator, dst[i]);
 				}
 				for (int i = 0; i < type_params.Length; ++i) {
 					src[i].InflateConstraints (inflator, dst[i]);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="853" endline="894">
<![CDATA[
 
 		//
 		// Converts `source' to an int, uint, long or ulong.
 		//
 		protected Expression ConvertExpressionToArrayIndex (ResolveContext ec, Expression source)
 		{
 			if (source.type == InternalType.Dynamic) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (source));
 				return new DynamicConversion (TypeManager.int32_type, CSharpBinderFlags.ConvertArrayIndex, args, loc).Resolve (ec);
 			}
 
 			Expression converted;
 			
 			using (ec.Set (ResolveContext.Options.CheckedScope)) {
 				converted = Convert.ImplicitConversion (ec, source, TypeManager.int32_type, source.loc);
 				if (converted == null)
 					converted = Convert.ImplicitConversion (ec, source, TypeManager.uint32_type, source.loc);
 				if (converted == null)
 					converted = Convert.ImplicitConversion (ec, source, TypeManager.int64_type, source.loc);
 				if (converted == null)
 					converted = Convert.ImplicitConversion (ec, source, TypeManager.uint64_type, source.loc);
 
 				if (converted == null) {
 					source.Error_ValueCannotBeConverted (ec, source.loc, TypeManager.int32_type, false);
 					return null;
 				}
 			}
 
 			//
 			// Only positive constants are allowed at compile time
 			//
 			Constant c = converted as Constant;
 			if (c != null && c.IsNegative)
 				Error_NegativeArrayIndex (ec, source.loc);
 
 			// No conversion needed to array index
 			if (converted.Type == TypeManager.int32_type)
 				return converted;
 
 			return new ArrayIndexCast (converted).Resolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="791" endline="821">
<![CDATA[
 
 		//
 		// Raised (and passed an XmlElement that contains the comment)
 		// when GenerateDocComment is writing documentation expectedly.
 		//
 		// FIXME
 		// that means removal of DOM use.
 		//
 		internal static void OnMethodGenerateDocComment (
 			MethodCore mc, XmlElement el, Report Report)
 		{
 			var paramTags = new Dictionary<string, string> ();
 			foreach (XmlElement pelem in el.SelectNodes ("param")) {
 				string xname = pelem.GetAttribute ("name");
 				if (xname.Length == 0)
 					continue; // really? but MS looks doing so
 				if (xname != "" && mc.ParameterInfo.GetParameterIndexByName (xname) < 0)
 					Report.Warning (1572, 2, mc.Location, "XML comment on `{0}' has a param tag for `{1}', but there is no parameter by that name",
 						mc.GetSignatureForError (), xname);
 				else if (paramTags.ContainsKey (xname))
 					Report.Warning (1571, 2, mc.Location, "XML comment on `{0}' has a duplicate param tag for `{1}'",
 						mc.GetSignatureForError (), xname);
 				paramTags [xname] = xname;
 			}
 			foreach (XmlElement pelem in el.SelectNodes ("param")) {
 				string xname = pelem.GetAttribute ("name");
 				if (xname.Length == 0)
 					continue; // really? but MS looks doing so
 				if (xname != "" && mc.ParameterInfo.GetParameterIndexByName (xname) < 0)
 					Report.Warning (1572, 2, mc.Location, "XML comment on `{0}' has a param tag for `{1}', but there is no parameter by that name",
 						mc.GetSignatureForError (), xname);
 				else if (paramTags.ContainsKey (xname))
 					Report.Warning (1571, 2, mc.Location, "XML comment on `{0}' has a duplicate param tag for `{1}'",
 						mc.GetSignatureForError (), xname);
 				paramTags [xname] = xname;
 			}
 			IParameterData [] plist = mc.ParameterInfo.FixedParameters;
 			foreach (Parameter p in plist) {
 				if (paramTags.Count > 0 && !paramTags.ContainsKey (p.Name))
 					Report.Warning (1573, 4, mc.Location, "Parameter `{0}' has no matching param tag in the XML comment for `{1}'",
 						p.Name, mc.GetSignatureForError ());
 			}
 			foreach (Parameter p in plist) {
 				if (paramTags.Count > 0 && !paramTags.ContainsKey (p.Name))
 					Report.Warning (1573, 4, mc.Location, "Parameter `{0}' has no matching param tag in the XML comment for `{1}'",
 						p.Name, mc.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="84" endline="117">
<![CDATA[
 
 		private void PopulateParameters()
 		{
 			if (parameters == null)
 			{
 				MethodSignature methodSignature = this.MethodSignature;
 				parameters = new ParameterInfo[methodSignature.GetParameterCount()];
 				int parameter = module.MethodDef.records[index].ParamList - 1;
 				int end = module.MethodDef.records.Length > index + 1 ? module.MethodDef.records[index + 1].ParamList - 1 
 				for (; parameter < end; parameter++)
 				{
 					int seq = module.Param.records[parameter].Sequence - 1;
 					if (seq == -1)
 					{
 						returnParameter = new ParameterInfoImpl(this, seq, parameter);
 					}
 					else
 					{
 						parameters[seq] = new ParameterInfoImpl(this, seq, parameter);
 					}
 				}
 				for (; parameter < end; parameter++)
 				{
 					int seq = module.Param.records[parameter].Sequence - 1;
 					if (seq == -1)
 					{
 						returnParameter = new ParameterInfoImpl(this, seq, parameter);
 					}
 					else
 					{
 						parameters[seq] = new ParameterInfoImpl(this, seq, parameter);
 					}
 				}
 				for (int i = 0; i < parameters.Length; i++)
 				{
 					if (parameters[i] == null)
 					{
 						parameters[i] = new ParameterInfoImpl(this, i, -1);
 					}
 				}
 				for (int i = 0; i < parameters.Length; i++)
 				{
 					if (parameters[i] == null)
 					{
 						parameters[i] = new ParameterInfoImpl(this, i, -1);
 					}
 				}
 				if (returnParameter == null)
 				{
 					returnParameter = new ParameterInfoImpl(this, -1, -1);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="687" endline="729">
<![CDATA[
 
 		public void EmitDispose (EmitContext ec)
 		{
 			Label end = ec.DefineLabel ();
 
 			Label [] labels = null;
 			int n_resume_points = resume_points == null ? 0 
 			for (int i = 0; i < n_resume_points; ++i) {
 				ResumableStatement s = (ResumableStatement) resume_points [i];
 				Label ret = s.PrepareForDispose (ec, end);
 				if (ret.Equals (end) && labels == null)
 					continue;
 				if (labels == null) {
 					labels = new Label [resume_points.Count + 1];
 					for (int j = 0; j <= i; ++j)
 						labels [j] = end;
 					for (int j = 0; j <= i; ++j)
 						labels [j] = end;
 				}
 				labels [i+1] = ret;
 			}
 			for (int i = 0; i < n_resume_points; ++i) {
 				ResumableStatement s = (ResumableStatement) resume_points [i];
 				Label ret = s.PrepareForDispose (ec, end);
 				if (ret.Equals (end) && labels == null)
 					continue;
 				if (labels == null) {
 					labels = new Label [resume_points.Count + 1];
 					for (int j = 0; j <= i; ++j)
 						labels [j] = end;
 				}
 				labels [i+1] = ret;
 			}
 
 			if (labels != null) {
 				current_pc = ec.GetTemporaryLocal (TypeManager.uint32_type);
 				ec.Emit (OpCodes.Ldarg_0);
 				ec.Emit (OpCodes.Ldfld, IteratorHost.PC.Spec);
 				ec.Emit (OpCodes.Stloc, current_pc);
 			}
 
 			ec.Emit (OpCodes.Ldarg_0);
 			ec.EmitInt ((int) State.After);
 			ec.Emit (OpCodes.Stfld, IteratorHost.PC.Spec);
 
 			if (labels != null) {
 				//SymbolWriter.StartIteratorDispatcher (ec.ig);
 				ec.Emit (OpCodes.Ldloc, current_pc);
 				ec.Emit (OpCodes.Switch, labels);
 				//SymbolWriter.EndIteratorDispatcher (ec.ig);
 
 				foreach (ResumableStatement s in resume_points)
 					s.EmitForDispose (ec, this, end, true);
 				foreach (ResumableStatement s in resume_points)
 					s.EmitForDispose (ec, this, end, true);
 			}
 
 			ec.MarkLabel (end);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="751" endline="790">
<![CDATA[
 
 		static string GetSignatureForDoc (TypeSpec type)
 		{
 			var tp = type as TypeParameterSpec;
 			if (tp != null) {
 				int c = 0;
 				type = type.DeclaringType;
 				while (type != null && type.DeclaringType != null) {
 					type = type.DeclaringType;
 					c += type.MemberDefinition.TypeParametersCount;
 				}
 				while (type != null && type.DeclaringType != null) {
 					type = type.DeclaringType;
 					c += type.MemberDefinition.TypeParametersCount;
 				}
 				var prefix = tp.IsMethodOwned ? "``" 
 				return prefix + (c + tp.DeclaredPosition);
 			}
 
 			var pp = type as PointerContainer;
 			if (pp != null)
 				return GetSignatureForDoc (pp.Element) + "*";
 
 			ArrayContainer ap = type as ArrayContainer;
 			if (ap != null)
 				return GetSignatureForDoc (ap.Element) +
 					ArrayContainer.GetPostfixSignature (ap.Rank);
 
 			if (TypeManager.IsGenericType (type)) {
 				string g = type.MemberDefinition.Namespace;
 				if (g != null && g.Length > 0)
 					g += '.';
 				int idx = type.Name.LastIndexOf ('`');
 				g += (idx < 0 ? type.Name 
 				int argpos = 0;
 				foreach (TypeSpec t in TypeManager.GetTypeArguments (type))
 					g += (argpos++ > 0 ? "," 
 				foreach (TypeSpec t in TypeManager.GetTypeArguments (type))
 					g += (argpos++ > 0 ? "," 
 				g += '}';
 				return g;
 			}
 
 			string name = type.GetMetaInfo ().FullName != null ? type.GetMetaInfo ().FullName 
 			return name.Replace ("+", ".").Replace ('&', '@');
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="138" endline="220">
<![CDATA[
 		}
 
 		public bool IgnorePrivateMembers { get; set; }
 
 		#endregion
 
 		protected abstract MemberKind DetermineKindFromBaseType (MetaType baseType);
 		protected abstract bool HasVolatileModifier (MetaType[] modifiers);
 		public abstract void GetCustomAttributeTypeName (CustomAttributeData cad, out string typeNamespace, out string typeName);
 
 		public FieldSpec CreateField (FieldInfo fi, TypeSpec declaringType)
 		{
 			Modifiers mod = 0;
 			var fa = fi.Attributes;
 			switch (fa & FieldAttributes.FieldAccessMask) {
 				case FieldAttributes.Public
 					mod = Modifiers.PUBLIC;
 					break;
 				case FieldAttributes.Assembly
 					mod = Modifiers.INTERNAL;
 					break;
 				case FieldAttributes.Family
 					mod = Modifiers.PROTECTED;
 					break;
 				case FieldAttributes.FamORAssem
 					mod = Modifiers.PROTECTED | Modifiers.INTERNAL;
 					break;
 				default
 					// Ignore private fields (even for error reporting) to not require extra dependencies
 					if (IgnorePrivateMembers || HasAttribute (CustomAttributeData.GetCustomAttributes (fi), "CompilerGeneratedAttribute", CompilerServicesNamespace))
 						return null;
 
 					mod = Modifiers.PRIVATE;
 					break;
 			}
 
 			TypeSpec field_type;
 
 			try {
 				field_type = ImportType (fi.FieldType, new DynamicTypeReader (fi));
 			} catch (Exception e) {
 				// TODO
 				// but there is no way to do it with System.Reflection
 				throw new InternalErrorException (e, "Cannot import field `{0}.{1}' referenced in assembly `{2}'",
 					declaringType.GetSignatureForError (), fi.Name, declaringType.MemberDefinition.DeclaringAssembly);
 			}
 
 			var definition = new ImportedMemberDefinition (fi, field_type, this);
 
 			if ((fa & FieldAttributes.Literal) != 0) {
 				var c = Constant.CreateConstantFromValue (field_type, fi.GetRawConstantValue (), Location.Null);
 				return new ConstSpec (declaringType, definition, field_type, fi, mod, c);
 			}
 
 			if ((fa & FieldAttributes.InitOnly) != 0) {
 				if (field_type == TypeManager.decimal_type) {
 					var dc = ReadDecimalConstant (CustomAttributeData.GetCustomAttributes (fi));
 					if (dc != null)
 						return new ConstSpec (declaringType, definition, field_type, fi, mod, dc);
 				}
 
 				mod |= Modifiers.READONLY;
 			} else {
 				var req_mod = fi.GetRequiredCustomModifiers ();
 				if (req_mod.Length > 0 && HasVolatileModifier (req_mod))
 					mod |= Modifiers.VOLATILE;
 			}
 
 			if ((fa & FieldAttributes.Static) != 0) {
 				mod |= Modifiers.STATIC;
 			} else {
 				// Fixed buffers cannot be static
 				if (declaringType.IsStruct && field_type.IsStruct && field_type.IsNested &&
 					HasAttribute (CustomAttributeData.GetCustomAttributes (fi), "FixedBufferAttribute", CompilerServicesNamespace)) {
 
 					// TODO
 					var element_field = CreateField (fi.FieldType.GetField (FixedField.FixedElementName), declaringType);
 					return new FixedFieldSpec (declaringType, definition, fi, element_field, mod);
 				}
 			}
 
 			return new FieldSpec (declaringType, definition, field_type, fi, mod);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="52" endline="61">
<![CDATA[
 
 		public override string ToString()
 		{
 			string str = name.ToString();
 			if (culture != null)
 			{
 				str = str.Replace("Culture=neutral", "Culture=" + culture);
 			}
 			return str;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\AssemblyName.cs" startline="148" endline="160">
<![CDATA[
 		}
 
 		public string FullName
 		{
 			get
 			{
 				string str = name.FullName;
 				if (culture != null)
 				{
 					str = str.Replace("Culture=neutral", "Culture=" + culture);
 				}
 				return str;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2854" endline="2877">
<![CDATA[
 
 		protected void EmitInstance (EmitContext ec, bool prepare_for_load)
 		{
 			TypeSpec instance_type = InstanceExpression.Type;
 			if (TypeManager.IsValueType (instance_type)) {
 				if (InstanceExpression is IMemoryLocation) {
 					((IMemoryLocation) InstanceExpression).AddressOf (ec, AddressOp.LoadStore);
 				} else {
 					LocalTemporary t = new LocalTemporary (instance_type);
 					InstanceExpression.Emit (ec);
 					t.Store (ec);
 					t.AddressOf (ec, AddressOp.Store);
 				}
 			} else {
 				InstanceExpression.Emit (ec);
 
 				// Only to make verifier happy
 				if (instance_type.IsGenericParameter && !(InstanceExpression is This) && TypeManager.IsReferenceType (instance_type))
 					ec.Emit (OpCodes.Box, instance_type);
 			}
 
 			if (prepare_for_load)
 				ec.Emit (OpCodes.Dup);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Field.cs" startline="80" endline="112">
<![CDATA[
 
 		public override void __GetDataFromRVA(byte[] data, int offset, int length)
 		{
 			int rid = index + 1;
 			// TODO binary search?
 			for (int i = 0; i < module.FieldRVA.records.Length; i++)
 			{
 				if (module.FieldRVA.records[i].Field == rid)
 				{
 					int rva = module.FieldRVA.records[i].RVA;
 					if (rva == 0)
 					{
 						// C++ assemblies can have fields that have an RVA that is zero
 						Array.Clear(data, offset, length);
 						return;
 					}
 					module.SeekRVA(rva);
 					while (length > 0)
 					{
 						int read = module.stream.Read(data, offset, length);
 						if (read == 0)
 						{
 							// C++ assemblies can have fields that have an RVA that lies outside of the file
 							break;
 						}
 						offset += read;
 						length -= read;
 					}
 					while (length > 0)
 					{
 						int read = module.stream.Read(data, offset, length);
 						if (read == 0)
 						{
 							// C++ assemblies can have fields that have an RVA that lies outside of the file
 							break;
 						}
 						offset += read;
 						length -= read;
 					}
 					return;
 				}
 			}
 			for (int i = 0; i < module.FieldRVA.records.Length; i++)
 			{
 				if (module.FieldRVA.records[i].Field == rid)
 				{
 					int rva = module.FieldRVA.records[i].RVA;
 					if (rva == 0)
 					{
 						// C++ assemblies can have fields that have an RVA that is zero
 						Array.Clear(data, offset, length);
 						return;
 					}
 					module.SeekRVA(rva);
 					while (length > 0)
 					{
 						int read = module.stream.Read(data, offset, length);
 						if (read == 0)
 						{
 							// C++ assemblies can have fields that have an RVA that lies outside of the file
 							break;
 						}
 						offset += read;
 						length -= read;
 					}
 					return;
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="288" endline="315">
<![CDATA[
 
 		public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string strParamName)
 		{
 			// the parameter is named "position", but it is actually a sequence number (i.e. 0 = return parameter, 1 = first parameter)
 			int sequence = position--;
 			if (parameters == null)
 			{
 				parameters = new List<ParameterBuilder>();
 			}
 			this.ModuleBuilder.Param.AddVirtualRecord();
 			ParameterBuilder pb = new ParameterBuilder(this.ModuleBuilder, sequence, attributes, strParamName);
 			if (parameters.Count == 0 || position > parameters[parameters.Count - 1].Position)
 			{
 				parameters.Add(pb);
 			}
 			else
 			{
 				for (int i = 0; i < parameters.Count; i++)
 				{
 					if (parameters[i].Position > position)
 					{
 						parameters.Insert(i, pb);
 						break;
 					}
 				}
 				for (int i = 0; i < parameters.Count; i++)
 				{
 					if (parameters[i].Position > position)
 					{
 						parameters.Insert(i, pb);
 						break;
 					}
 				}
 			}
 			return pb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8232" endline="8261">
<![CDATA[
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			var ac = ea.Expr.Type as ArrayContainer;
 
 			if (prepared) {
 				ec.EmitLoadFromPtr (type);
 			} else {
 				if (prepared_arguments == null) {
 					LoadArrayAndArguments (ec);
 				} else {
 					expr_copy.Emit (ec);
 					LocalTemporary lt;
 					foreach (var expr in prepared_arguments) {
 						expr.Emit (ec);
 						lt = expr as LocalTemporary;
 						if (lt != null)
 							lt.Release (ec);
 					}
 					foreach (var expr in prepared_arguments) {
 						expr.Emit (ec);
 						lt = expr as LocalTemporary;
 						if (lt != null)
 							lt.Release (ec);
 					}
 				}
 
 				ec.EmitArrayLoad (ac);
 			}	
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				temp = new LocalTemporary (this.type);
 				temp.Store (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="323" endline="360">
<![CDATA[
 
 		private ExceptionBlock BeginFinallyFilterFaultBlock()
 		{
 			ExceptionBlock block = exceptionStack.Peek();
 			if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
 			{
 				Emit(OpCodes.Leave, block.labelEnd);
 			}
 			if (block.handlerOffset == 0)
 			{
 				block.tryLength = code.Position - block.tryOffset;
 			}
 			else
 			{
 				block.handlerLength = code.Position - block.handlerOffset;
 				Label labelEnd;
 				if (exceptionBlockAssistanceMode != EBAM_COMPAT)
 				{
 					labelEnd = block.labelEnd;
 				}
 				else
 				{
 					MarkLabel(block.labelEnd);
 					labelEnd = DefineLabel();
 					Emit(OpCodes.Leave, labelEnd);
 				}
 				exceptionStack.Pop();
 				ExceptionBlock newBlock = new ExceptionBlock(exceptions.Count);
 				newBlock.labelEnd = labelEnd;
 				newBlock.tryOffset = block.tryOffset;
 				newBlock.tryLength = code.Position - block.tryOffset;
 				block = newBlock;
 				exceptions.Add(block);
 				exceptionStack.Push(block);
 			}
 			stackHeight = 0;
 			return block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5701" endline="5747">
<![CDATA[
 
 		bool DoEmitTypeParameter (EmitContext ec)
 		{
 			var activator = ec.MemberContext.Module.PredefinedTypes.Activator;
 			var t = activator.Resolve (loc);
 			if (t == null)
 				return true;
 
 			if (TypeManager.activator_create_instance == null) {
 				TypeManager.activator_create_instance = TypeManager.GetPredefinedMethod (
 					t, MemberFilter.Method ("CreateInstance", 1, ParametersCompiled.EmptyReadOnlyParameters, null), loc);
 			}
 
 			var ctor_factory = TypeManager.activator_create_instance.MakeGenericMethod (type);
 			var tparam = (TypeParameterSpec) type;
 
 			if (tparam.IsReferenceType) {
 				ec.Emit (OpCodes.Call, ctor_factory);
 				return true;
 			}
 
 			// Allow DoEmit() to be called multiple times.
 			// We need to create a new LocalTemporary each time since
 			// you can't share LocalBuilders among ILGeneators.
 			LocalTemporary temp = new LocalTemporary (type);
 
 			Label label_activator = ec.DefineLabel ();
 			Label label_end = ec.DefineLabel ();
 
 			temp.AddressOf (ec, AddressOp.Store);
 			ec.Emit (OpCodes.Initobj, type);
 
 			temp.Emit (ec);
 			ec.Emit (OpCodes.Box, type);
 			ec.Emit (OpCodes.Brfalse, label_activator);
 
 			temp.AddressOf (ec, AddressOp.Store);
 			ec.Emit (OpCodes.Initobj, type);
 			temp.Emit (ec);
 			ec.Emit (OpCodes.Br_S, label_end);
 
 			ec.MarkLabel (label_activator);
 
 			ec.Emit (OpCodes.Call, ctor_factory);
 			ec.MarkLabel (label_end);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="315" endline="354">
<![CDATA[
 
 		protected void EmitCall (EmitContext ec, Expression binder, Arguments arguments, bool isStatement)
 		{
 			int dyn_args_count = arguments == null ? 0 
 			TypeExpr site_type = CreateSiteType (ec, arguments, dyn_args_count, isStatement);
 
 			FieldExpr site_field_expr = new FieldExpr (CreateSiteField (ec, site_type), loc);
 
 			SymbolWriter.OpenCompilerGeneratedBlock (ec);
 
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (binder));
 			StatementExpression s = new StatementExpression (new SimpleAssign (site_field_expr, new Invocation (new MemberAccess (site_type, "Create"), args)));
 			
 			BlockContext bc = new BlockContext (ec.MemberContext, null, TypeManager.void_type);		
 			if (s.Resolve (bc)) {
 				Statement init = new If (new Binary (Binary.Operator.Equality, site_field_expr, new NullLiteral (loc), loc), s, loc);
 				init.Emit (ec);
 			}
 
 			args = new Arguments (1 + dyn_args_count);
 			args.Add (new Argument (site_field_expr));
 			if (arguments != null) {
 				foreach (Argument a in arguments) {
 					if (a is NamedArgument) {
 						// Name is not valid in this context
 						args.Add (new Argument (a.Expr, a.ArgType));
 						continue;
 					}
 
 					args.Add (a);
 				}
 				foreach (Argument a in arguments) {
 					if (a is NamedArgument) {
 						// Name is not valid in this context
 						args.Add (new Argument (a.Expr, a.ArgType));
 						continue;
 					}
 
 					args.Add (a);
 				}
 			}
 
 			Expression target = new DelegateInvocation (new MemberAccess (site_field_expr, "Target", loc).Resolve (bc), args, loc).Resolve (bc);
 			if (target != null)
 				target.Emit (ec);
 
 			SymbolWriter.CloseCompilerGeneratedBlock (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5201" endline="5254">
<![CDATA[
 
 		protected virtual Expression DoResolveDynamic (ResolveContext ec, Expression memberExpr)
 		{
 			Arguments args;
 			DynamicMemberBinder dmb = memberExpr as DynamicMemberBinder;
 			if (dmb != null) {
 				args = dmb.Arguments;
 				if (arguments != null)
 					args.AddRange (arguments);
 			} else if (mg == null) {
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				args.Insert (0, new Argument (memberExpr));
 				this.expr = null;
 			} else {
 				if (mg.IsBase) {
 					ec.Report.Error (1971, loc,
 						"The base call to method `{0}' cannot be dynamically dispatched. Consider casting the dynamic arguments or eliminating the base access",
 						mg.Name);
 					return null;
 				}
 
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				MemberAccess ma = expr as MemberAccess;
 				if (ma != null) {
 					var left_type = ma.LeftExpression as TypeExpr;
 					if (left_type != null) {
 						args.Insert (0, new Argument (new TypeOf (left_type, loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						//
 						// Any value type has to be pass as by-ref to get back the same
 						// instance on which the member was called
 						//
 						var mod = TypeManager.IsValueType (ma.LeftExpression.Type) ? Argument.AType.Ref 
 						args.Insert (0, new Argument (ma.LeftExpression.Resolve (ec), mod));
 					}
 				} else {	// is SimpleName
 					if (ec.IsStatic) {
 						args.Insert (0, new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						args.Insert (0, new Argument (new This (loc).Resolve (ec)));
 					}
 				}
 			}
 
 			return new DynamicInvocation (expr as ATypeNameExpression, args, loc).Resolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="481" endline="536">
<![CDATA[
 
 		public void VerifyClsCompliance ()
 		{
 			if (types == null || cls_checked)
 				return;
 
 			cls_checked = true;
 
 			// TODO
 
 			var locase_types = new Dictionary<string, List<TypeSpec>> (StringComparer.OrdinalIgnoreCase);
 			foreach (var tgroup in types.Values) {
 				foreach (var tm in tgroup) {
 					if ((tm.Modifiers & Modifiers.PUBLIC) == 0 || !tm.IsCLSCompliant ())
 						continue;
 
 					List<TypeSpec> found;
 					if (!locase_types.TryGetValue (tm.Name, out found)) {
 						found = new List<TypeSpec> ();
 						locase_types.Add (tm.Name, found);
 					}
 
 					found.Add (tm);
 				}
 				foreach (var tm in tgroup) {
 					if ((tm.Modifiers & Modifiers.PUBLIC) == 0 || !tm.IsCLSCompliant ())
 						continue;
 
 					List<TypeSpec> found;
 					if (!locase_types.TryGetValue (tm.Name, out found)) {
 						found = new List<TypeSpec> ();
 						locase_types.Add (tm.Name, found);
 					}
 
 					found.Add (tm);
 				}
 			}
 			foreach (var tgroup in types.Values) {
 				foreach (var tm in tgroup) {
 					if ((tm.Modifiers & Modifiers.PUBLIC) == 0 || !tm.IsCLSCompliant ())
 						continue;
 
 					List<TypeSpec> found;
 					if (!locase_types.TryGetValue (tm.Name, out found)) {
 						found = new List<TypeSpec> ();
 						locase_types.Add (tm.Name, found);
 					}
 
 					found.Add (tm);
 				}
 			}
 
 			foreach (var locase in locase_types.Values) {
 				if (locase.Count < 2)
 					continue;
 
 				bool all_same = true;
 				foreach (var notcompliant in locase) {
 					all_same = notcompliant.Name == locase[0].Name;
 					if (!all_same)
 						break;
 				}
 				foreach (var notcompliant in locase) {
 					all_same = notcompliant.Name == locase[0].Name;
 					if (!all_same)
 						break;
 				}
 
 				if (all_same)
 					continue;
 
 				TypeContainer compiled = null;
 				foreach (var notcompliant in locase) {
 					if (!notcompliant.MemberDefinition.IsImported) {
 						if (compiled != null)
 							compiled.Compiler.Report.SymbolRelatedToPreviousError (compiled);
 
 						compiled = notcompliant.MemberDefinition as TypeContainer;
 					} else {
 						compiled.Compiler.Report.SymbolRelatedToPreviousError (notcompliant);
 					}
 				}
 				foreach (var notcompliant in locase) {
 					if (!notcompliant.MemberDefinition.IsImported) {
 						if (compiled != null)
 							compiled.Compiler.Report.SymbolRelatedToPreviousError (compiled);
 
 						compiled = notcompliant.MemberDefinition as TypeContainer;
 					} else {
 						compiled.Compiler.Report.SymbolRelatedToPreviousError (notcompliant);
 					}
 				}
 
 				compiled.Compiler.Report.Warning (3005, 1, compiled.Location,
 					"Identifier `{0}' differing only in case is not CLS-compliant", compiled.GetSignatureForError ());
 			}
 			foreach (var locase in locase_types.Values) {
 				if (locase.Count < 2)
 					continue;
 
 				bool all_same = true;
 				foreach (var notcompliant in locase) {
 					all_same = notcompliant.Name == locase[0].Name;
 					if (!all_same)
 						break;
 				}
 
 				if (all_same)
 					continue;
 
 				TypeContainer compiled = null;
 				foreach (var notcompliant in locase) {
 					if (!notcompliant.MemberDefinition.IsImported) {
 						if (compiled != null)
 							compiled.Compiler.Report.SymbolRelatedToPreviousError (compiled);
 
 						compiled = notcompliant.MemberDefinition as TypeContainer;
 					} else {
 						compiled.Compiler.Report.SymbolRelatedToPreviousError (notcompliant);
 					}
 				}
 
 				compiled.Compiler.Report.Warning (3005, 1, compiled.Location,
 					"Identifier `{0}' differing only in case is not CLS-compliant", compiled.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3360" endline="3433">
<![CDATA[
 
 		//
 		// Build-in operators method overloading
 		//
 		protected virtual Expression ResolveOperatorPredefined (ResolveContext ec, PredefinedOperator [] operators, bool primitives_only, TypeSpec enum_type)
 		{
 			PredefinedOperator best_operator = null;
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Operator oper_mask = oper & ~Operator.ValuesOnlyMask;
 
 			foreach (PredefinedOperator po in operators) {
 				if ((po.OperatorsMask & oper_mask) == 0)
 					continue;
 
 				if (primitives_only) {
 					if (!po.IsPrimitiveApplicable (l, r))
 						continue;
 				} else {
 					if (!po.IsApplicable (ec, left, right))
 						continue;
 				}
 
 				if (best_operator == null) {
 					best_operator = po;
 					if (primitives_only)
 						break;
 
 					continue;
 				}
 
 				best_operator = po.ResolveBetterOperator (ec, best_operator);
 
 				if (best_operator == null) {
 					ec.Report.Error (34, loc, "Operator `{0}' is ambiguous on operands of type `{1}' and `{2}'",
 						OperName (oper), TypeManager.CSharpName (l), TypeManager.CSharpName (r));
 
 					best_operator = po;
 					break;
 				}
 			}
 			foreach (PredefinedOperator po in operators) {
 				if ((po.OperatorsMask & oper_mask) == 0)
 					continue;
 
 				if (primitives_only) {
 					if (!po.IsPrimitiveApplicable (l, r))
 						continue;
 				} else {
 					if (!po.IsApplicable (ec, left, right))
 						continue;
 				}
 
 				if (best_operator == null) {
 					best_operator = po;
 					if (primitives_only)
 						break;
 
 					continue;
 				}
 
 				best_operator = po.ResolveBetterOperator (ec, best_operator);
 
 				if (best_operator == null) {
 					ec.Report.Error (34, loc, "Operator `{0}' is ambiguous on operands of type `{1}' and `{2}'",
 						OperName (oper), TypeManager.CSharpName (l), TypeManager.CSharpName (r));
 
 					best_operator = po;
 					break;
 				}
 			}
 
 			if (best_operator == null)
 				return null;
 
 			Expression expr = best_operator.ConvertResult (ec, this);
 
 			//
 			// Optimize &/&& constant expressions with 0 value
 			//
 			if (oper == Operator.BitwiseAnd || oper == Operator.LogicalAnd) {
 				Constant rc = right as Constant;
 				Constant lc = left as Constant;
 				if (((lc != null && lc.IsDefaultValue) || (rc != null && rc.IsDefaultValue)) && !(this is Nullable.LiftedBinaryOperator)) {
 					//
 					// The result is a constant with side-effect
 					//
 					Constant side_effect = rc == null ?
 						new SideEffectConstant (lc, right, loc) 
 						new SideEffectConstant (rc, left, loc);
 
 					return ReducedExpression.Create (side_effect.Resolve (ec), expr);
 				}
 			}
 
 			if (enum_type == null)
 				return expr;
 
 			//
 			// HACK
 			//
 			expr.Type = enum_type;
 			return EmptyCast.Create (expr, enum_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="578" endline="671">
<![CDATA[
 
 		[Flags]
 		public enum MemberLookupRestrictions
 		{
 			None = 0,
 			InvocableOnly = 1,
 			ExactArity = 1 << 2,
 			ReadAccess = 1 << 3
 		}
 
 		//
 		// Lookup type `queried_type' for code in class `container_type' with a qualifier of
 		// `qualifier_type' or null to lookup members in the current class.
 		//
 		public static Expression MemberLookup (ResolveContext rc, TypeSpec currentType, TypeSpec queried_type, string name, int arity, MemberLookupRestrictions restrictions, Location loc)
 		{
 			var members = MemberCache.FindMembers (queried_type, name, false);
 			if (members == null)
 				return null;
 
 			MemberSpec non_method = null;
 			MemberSpec ambig_non_method = null;
 			currentType = currentType ?? InternalType.FakeInternalType;
 			do {
 				for (int i = 0; i < members.Count; ++i) {
 					var member = members[i];
 
 					// HACK
 					if ((member.Modifiers & Modifiers.OVERRIDE) != 0 && member.Kind != MemberKind.Event)
 						continue;
 
 					if ((arity > 0 || (restrictions & MemberLookupRestrictions.ExactArity) != 0) && member.Arity != arity)
 						continue;
 
 					if (rc != null) {
 						if (!member.IsAccessible (currentType))
 							continue;
 
 						//
 						// With runtime binder we can have a situation where queried type is inaccessible
 						// because it came via dynamic object, the check about inconsisted accessibility
 						// had no effect as the type was unknown during compilation
 						//
 						// class A {
 						//		private class N { }
 						//
 						//		public dynamic Foo ()
 						//		{
 						//			return new N ();
 						//		}
 						//	}
 						//
 						if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (currentType))
 							continue;
 					}
 
 					if ((restrictions & MemberLookupRestrictions.InvocableOnly) != 0) {
 						if (member is MethodSpec)
 							return new MethodGroupExpr (members, queried_type, loc);
 
 						if (!Invocation.IsMemberInvocable (member))
 							continue;
 					}
 
 					if (non_method == null || member is MethodSpec) {
 						non_method = member;
 					} else if (currentType != null) {
 						ambig_non_method = member;
 					}
 				}
 				for (int i = 0; i < members.Count; ++i) {
 					var member = members[i];
 
 					// HACK
 					if ((member.Modifiers & Modifiers.OVERRIDE) != 0 && member.Kind != MemberKind.Event)
 						continue;
 
 					if ((arity > 0 || (restrictions & MemberLookupRestrictions.ExactArity) != 0) && member.Arity != arity)
 						continue;
 
 					if (rc != null) {
 						if (!member.IsAccessible (currentType))
 							continue;
 
 						//
 						// With runtime binder we can have a situation where queried type is inaccessible
 						// because it came via dynamic object, the check about inconsisted accessibility
 						// had no effect as the type was unknown during compilation
 						//
 						// class A {
 						//		private class N { }
 						//
 						//		public dynamic Foo ()
 						//		{
 						//			return new N ();
 						//		}
 						//	}
 						//
 						if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (currentType))
 							continue;
 					}
 
 					if ((restrictions & MemberLookupRestrictions.InvocableOnly) != 0) {
 						if (member is MethodSpec)
 							return new MethodGroupExpr (members, queried_type, loc);
 
 						if (!Invocation.IsMemberInvocable (member))
 							continue;
 					}
 
 					if (non_method == null || member is MethodSpec) {
 						non_method = member;
 					} else if (currentType != null) {
 						ambig_non_method = member;
 					}
 				}
 
 				if (non_method != null) {
 					if (ambig_non_method != null && rc != null) {
 						rc.Report.SymbolRelatedToPreviousError (non_method);
 						rc.Report.SymbolRelatedToPreviousError (ambig_non_method);
 						rc.Report.Error (229, loc, "Ambiguity between `{0}' and `{1}'",
 							non_method.GetSignatureForError (), ambig_non_method.GetSignatureForError ());
 					}
 
 					if (non_method is MethodSpec)
 						return new MethodGroupExpr (members, queried_type, loc);
 
 					return ExprClassFromMemberInfo (non_method, loc);
 				}
 
 				if (members[0].DeclaringType.BaseType == null)
 					members = null;
 				else
 					members = MemberCache.FindMembers (members[0].DeclaringType.BaseType, name, false);
 
 			} while (members != null);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="299" endline="334">
<![CDATA[
 
 		void AddMember (string name, MemberSpec member)
 		{
 			if (member.Kind == MemberKind.Operator) {
 				var dt = member.DeclaringType;
 				if (dt == TypeManager.string_type || dt == TypeManager.delegate_type || dt == TypeManager.multicast_delegate_type) {
 					// Some core types have user operators but they cannot be used as normal
 					// user operators as they are predefined and therefore having different
 					// rules (e.g. binary operators) by not setting the flag we hide them for
 					// user conversions
 					// TODO
 				} else if (name == Operator.GetMetadataName (Operator.OpType.Implicit) || name == Operator.GetMetadataName (Operator.OpType.Explicit)) {
 					state |= StateFlags.HasConversionOperator;
 				} else {
 					state |= StateFlags.HasUserOperator;
 				}
 			}
 
 			IList<MemberSpec> list;
 			if (!member_hash.TryGetValue (name, out list)) {
 				member_hash.Add (name, new MemberSpec[] { member });
 				return;
 			}
 
 			if (member.DeclaringType.IsInterface) {
 				if (AddInterfaceMember (member, ref list))
 					member_hash[name] = list;
 			} else {
 				if (list is MemberSpec[]) {
 					list = new List<MemberSpec> () { list[0] };
 					member_hash[name] = list;
 				}
 
 				list.Add (member);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="507" endline="558">
<![CDATA[
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			var ok = base.CheckOverrideAgainstBase (base_member);
 
 			//
 			// Check base property accessors conflict
 			//
 			var base_prop = (PropertySpec) base_member;
 			if (Get != null) {
 				if (!base_prop.HasGet) {
 					if (ok) {
 						Report.SymbolRelatedToPreviousError (base_prop);
 						Report.Error (545, Get.Location,
 							"`{0}'
 							Get.GetSignatureForError (), base_prop.GetSignatureForError ());
 						ok = false;
 					}
 				} else if (Get.HasCustomAccessModifier || base_prop.HasDifferentAccessibility) {
 					if (!CheckAccessModifiers (Get, base_prop.Get)) {
 						Error_CannotChangeAccessModifiers (Get, base_prop.Get);
 						ok = false;
 					}
 				}
 			}
 
 			if (Set != null) {
 				if (!base_prop.HasSet) {
 					if (ok) {
 						Report.SymbolRelatedToPreviousError (base_prop);
 						Report.Error (546, Set.Location,
 							"`{0}'
 							Set.GetSignatureForError (), base_prop.GetSignatureForError ());
 						ok = false;
 					}
 				} else if (Set.HasCustomAccessModifier || base_prop.HasDifferentAccessibility) {
 					if (!CheckAccessModifiers (Set, base_prop.Set)) {
 						Error_CannotChangeAccessModifiers (Set, base_prop.Set);
 						ok = false;
 					}
 				}
 			}
 
 			if ((Set == null || !Set.HasCustomAccessModifier) && (Get == null || !Get.HasCustomAccessModifier)) {
 				if (!CheckAccessModifiers (this, base_prop)) {
 					Error_CannotChangeAccessModifiers (this, base_prop);
 					ok = false;
 				}
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="201" endline="280">
<![CDATA[
 
 		static public DSA FromCapiPrivateKeyBlobDSA (byte[] blob, int offset)
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			DSAParameters dsap = new DSAParameters ();
 			try {
 				if ((blob [offset] != 0x07) ||				// PRIVATEKEYBLOB (0x07)
 				    (blob [offset + 1] != 0x02) ||			// Version (0x02)
 				    (blob [offset + 2] != 0x00) ||			// Reserved (word)
 				    (blob [offset + 3] != 0x00) ||
 				    (ToUInt32LE (blob, offset + 8) != 0x32535344))	// DWORD magic
 					throw new CryptographicException ("Invalid blob header");
 
 				int bitlen = ToInt32LE (blob, offset + 12);
 				int bytelen = bitlen >> 3;
 				int pos = offset + 16;
 
 				dsap.P = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.P, 0, bytelen);
 				Array.Reverse (dsap.P);
 				pos += bytelen;
 
 				dsap.Q = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Q, 0, 20);
 				Array.Reverse (dsap.Q);
 				pos += 20;
 
 				dsap.G = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.G, 0, bytelen);
 				Array.Reverse (dsap.G);
 				pos += bytelen;
 
 				dsap.X = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.X, 0, 20);
 				Array.Reverse (dsap.X);
 				pos += 20;
 
 				dsap.Counter = ToInt32LE (blob, pos);
 				pos += 4;
 
 				dsap.Seed = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Seed, 0, 20);
 				Array.Reverse (dsap.Seed);
 				pos += 20;
 			}
 			catch (Exception e) {
 				throw new CryptographicException ("Invalid blob.", e);
 			}
 
 #if NET_2_1
 			DSA dsa = (DSA)DSA.Create ();
 			dsa.ImportParameters (dsap);
 #else
 			DSA dsa = null;
 			try {
 				dsa = (DSA)DSA.Create ();
 				dsa.ImportParameters (dsap);
 			}
 			catch (CryptographicException ce) {
 				// this may cause problem when this code is run under
 				// the SYSTEM identity on Windows (e.g. ASP.NET). See
 				// http
 				try {
 					CspParameters csp = new CspParameters ();
 					csp.Flags = CspProviderFlags.UseMachineKeyStore;
 					dsa = new DSACryptoServiceProvider (csp);
 					dsa.ImportParameters (dsap);
 				}
 				catch {
 					// rethrow original, not the later, exception if this fails
 					throw ce;
 				}
 			}
 #endif
 			return dsa;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="585" endline="645">
<![CDATA[
 
 		public void Resolve ()
 		{
 			if (RootContext.Unsafe && module.PredefinedTypes.SecurityAction.Define ()) {
 				//
 				// Emits [assembly
 				// when -unsafe option was specified
 				//
 				Location loc = Location.Null;
 
 				MemberAccess system_security_permissions = new MemberAccess (new MemberAccess (
 					new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Security", loc), "Permissions", loc);
 
 				var req_min = (ConstSpec) module.PredefinedTypes.SecurityAction.GetField ("RequestMinimum", module.PredefinedTypes.SecurityAction.TypeSpec, loc);
 
 				Arguments pos = new Arguments (1);
 				pos.Add (new Argument (req_min.GetConstant (null)));
 
 				Arguments named = new Arguments (1);
 				named.Add (new NamedArgument ("SkipVerification", loc, new BoolLiteral (true, loc)));
 
 				GlobalAttribute g = new GlobalAttribute (new NamespaceEntry (module, null, null, null), "assembly",
 					new MemberAccess (system_security_permissions, "SecurityPermissionAttribute"),
 					new Arguments[] { pos, named }, loc, false);
 				g.AttachTo (module, module);
 				var ctor = g.Resolve ();
 				if (ctor != null) {
 					g.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				}
 			}
 
 			if (module.OptAttributes == null)
 				return;
 
 			// Ensure that we only have GlobalAttributes, since the Search isn't safe with other types.
 			if (!module.OptAttributes.CheckTargets())
 				return;
 
 			cls_attribute = module.ResolveAssemblyAttribute (module.PredefinedAttributes.CLSCompliant);
 
 			if (cls_attribute != null) {
 				is_cls_compliant = cls_attribute.GetClsCompliantAttributeValue ();
 			}
 
 			if (added_modules != null && RootContext.VerifyClsCompliance && is_cls_compliant) {
 				foreach (var m in added_modules) {
 					if (!m.IsCLSCompliant) {
 						Report.Error (3013,
 							"Added modules must be marked with the CLSCompliant attribute to match the assembly",
 							m.Name);
 					}
 				}
 				foreach (var m in added_modules) {
 					if (!m.IsCLSCompliant) {
 						Report.Error (3013,
 							"Added modules must be marked with the CLSCompliant attribute to match the assembly",
 							m.Name);
 					}
 				}
 			}
 
 			Attribute a = module.ResolveAssemblyAttribute (module.PredefinedAttributes.RuntimeCompatibility);
 			if (a != null) {
 				var val = a.GetNamedValue ("WrapNonExceptionThrows") as BoolConstant;
 				if (val != null)
 					wrap_non_exception_throws = val.Value;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9368" endline="9431">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			List<string> element_names = null;
 			for (int i = 0; i < initializers.Count; ++i) {
 				Expression initializer = initializers [i];
 				ElementInitializer element_initializer = initializer as ElementInitializer;
 
 				if (i == 0) {
 					if (element_initializer != null) {
 						element_names = new List<string> (initializers.Count);
 						element_names.Add (element_initializer.Name);
 					} else if (initializer is CompletingExpression){
 						initializer.Resolve (ec);
 						throw new InternalErrorException ("This line should never be reached");
 					} else {
 						var t = ec.CurrentInitializerVariable.Type;
 						// LAMESPEC
 						if (!t.ImplementsInterface (TypeManager.ienumerable_type, false) && t != InternalType.Dynamic) {
 							ec.Report.Error (1922, loc, "A field or property `{0}' cannot be initialized with a collection " +
 								"object initializer because type `{1}' does not implement `{2}' interface",
 								ec.CurrentInitializerVariable.GetSignatureForError (),
 								TypeManager.CSharpName (ec.CurrentInitializerVariable.Type),
 								TypeManager.CSharpName (TypeManager.ienumerable_type));
 							return null;
 						}
 						is_collection_initialization = true;
 					}
 				} else {
 					if (is_collection_initialization != (element_initializer == null)) {
 						ec.Report.Error (747, initializer.Location, "Inconsistent `{0}' member declaration",
 							is_collection_initialization ? "collection initializer" 
 						continue;
 					}
 
 					if (!is_collection_initialization) {
 						if (element_names.Contains (element_initializer.Name)) {
 							ec.Report.Error (1912, element_initializer.Location,
 								"An object initializer includes more than one member `{0}' initialization",
 								element_initializer.Name);
 						} else {
 							element_names.Add (element_initializer.Name);
 						}
 					}
 				}
 
 				Expression e = initializer.Resolve (ec);
 				if (e == EmptyExpressionStatement.Instance)
 					initializers.RemoveAt (i--);
 				else
 					initializers [i] = e;
 			}
 			for (int i = 0; i < initializers.Count; ++i) {
 				Expression initializer = initializers [i];
 				ElementInitializer element_initializer = initializer as ElementInitializer;
 
 				if (i == 0) {
 					if (element_initializer != null) {
 						element_names = new List<string> (initializers.Count);
 						element_names.Add (element_initializer.Name);
 					} else if (initializer is CompletingExpression){
 						initializer.Resolve (ec);
 						throw new InternalErrorException ("This line should never be reached");
 					} else {
 						var t = ec.CurrentInitializerVariable.Type;
 						// LAMESPEC
 						if (!t.ImplementsInterface (TypeManager.ienumerable_type, false) && t != InternalType.Dynamic) {
 							ec.Report.Error (1922, loc, "A field or property `{0}' cannot be initialized with a collection " +
 								"object initializer because type `{1}' does not implement `{2}' interface",
 								ec.CurrentInitializerVariable.GetSignatureForError (),
 								TypeManager.CSharpName (ec.CurrentInitializerVariable.Type),
 								TypeManager.CSharpName (TypeManager.ienumerable_type));
 							return null;
 						}
 						is_collection_initialization = true;
 					}
 				} else {
 					if (is_collection_initialization != (element_initializer == null)) {
 						ec.Report.Error (747, initializer.Location, "Inconsistent `{0}' member declaration",
 							is_collection_initialization ? "collection initializer" 
 						continue;
 					}
 
 					if (!is_collection_initialization) {
 						if (element_names.Contains (element_initializer.Name)) {
 							ec.Report.Error (1912, element_initializer.Location,
 								"An object initializer includes more than one member `{0}' initialization",
 								element_initializer.Name);
 						} else {
 							element_names.Add (element_initializer.Name);
 						}
 					}
 				}
 
 				Expression e = initializer.Resolve (ec);
 				if (e == EmptyExpressionStatement.Instance)
 					initializers.RemoveAt (i--);
 				else
 					initializers [i] = e;
 			}
 
 			type = ec.CurrentInitializerVariable.Type;
 			if (is_collection_initialization) {
 				if (TypeManager.HasElementType (type)) {
 					ec.Report.Error (1925, loc, "Cannot initialize object of type `{0}' with a collection initializer",
 						TypeManager.CSharpName (type));
 				}
 			}
 
 			eclass = ExprClass.Variable;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="204" endline="217">
<![CDATA[
 
 		public override int GetHashCode ()
 		{
 			int hash = Name.GetHashCode ();
 			for (MemberName n = Left; n != null; n = n.Left)
 				hash ^= n.Name.GetHashCode ();
 			for (MemberName n = Left; n != null; n = n.Left)
 				hash ^= n.Name.GetHashCode ();
 			if (is_double_colon)
 				hash ^= 0xbadc01d;
 
 			if (TypeArguments != null)
 				hash ^= TypeArguments.Count << 5;
 
 			return hash & 0x7FFFFFFF;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="30" endline="51">
<![CDATA[
 
 		protected override Expression CreateExpressionTree (ResolveContext ec, TypeSpec delegate_type)
 		{
 			if (ec.IsInProbingMode)
 				return this;
 
 			BlockContext bc = new BlockContext (ec.MemberContext, ec.ConstructorBlock, TypeManager.void_type) {
 				CurrentAnonymousMethod = ec.CurrentAnonymousMethod
 			};
 
 			Expression args = Parameters.CreateExpressionTree (bc, loc);
 			Expression expr = Block.CreateExpressionTree (ec);
 			if (expr == null)
 				return null;
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (expr));
 			arguments.Add (new Argument (args));
 			return CreateExpressionFactoryCall (ec, "Lambda",
 				new TypeArguments (new TypeExpression (delegate_type, loc)),
 				arguments);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="240" endline="270">
<![CDATA[
 
 		private void PopulateTypeDef()
 		{
 			if (typeDefs == null)
 			{
 				typeDefs = new TypeDefImpl[TypeDef.records.Length];
 				for (int i = 0; i < typeDefs.Length; i++)
 				{
 					TypeDefImpl type = new TypeDefImpl(this, i);
 					typeDefs[i] = type;
 					if (type.IsModulePseudoType)
 					{
 						moduleType = type;
 					}
 					else
 					{
 						types.Add(type.FullName, type);
 					}
 				}
 				for (int i = 0; i < typeDefs.Length; i++)
 				{
 					TypeDefImpl type = new TypeDefImpl(this, i);
 					typeDefs[i] = type;
 					if (type.IsModulePseudoType)
 					{
 						moduleType = type;
 					}
 					else
 					{
 						types.Add(type.FullName, type);
 					}
 				}
 				// add forwarded types to forwardedTypes dictionary (because Module.GetType(string) should return them)
 				for (int i = 0; i < ExportedType.records.Length; i++)
 				{
 					int implementation = ExportedType.records[i].Implementation;
 					if (implementation >> 24 == AssemblyRefTable.Index)
 					{
 						string typeName = GetTypeName(ExportedType.records[i].TypeNamespace, ExportedType.records[i].TypeName);
 						forwardedTypes.Add(typeName, new LazyForwardedType((implementation & 0xFFFFFF) - 1));
 					}
 				}
 				for (int i = 0; i < ExportedType.records.Length; i++)
 				{
 					int implementation = ExportedType.records[i].Implementation;
 					if (implementation >> 24 == AssemblyRefTable.Index)
 					{
 						string typeName = GetTypeName(ExportedType.records[i].TypeNamespace, ExportedType.records[i].TypeName);
 						forwardedTypes.Add(typeName, new LazyForwardedType((implementation & 0xFFFFFF) - 1));
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="651" endline="691">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (Arguments == null || Arguments.Count != 1) {
 				ec.Report.Error (149, loc, "Method name expected");
 				return null;
 			}
 
 			Argument a = Arguments [0];
 			if (!a.ResolveMethodGroup (ec))
 				return null;
 
 			Expression e = a.Expr;
 
 			AnonymousMethodExpression ame = e as AnonymousMethodExpression;
 			if (ame != null && RootContext.Version != LanguageVersion.ISO_1) {
 				e = ame.Compatible (ec, type);
 				if (e == null)
 					return null;
 
 				return e.Resolve (ec);
 			}
 
 			method_group = e as MethodGroupExpr;
 			if (method_group == null) {
 				if (e.Type == InternalType.Dynamic) {
 					e = Convert.ImplicitConversionRequired (ec, e, type, loc);
 				} else if (!e.Type.IsDelegate) {
 					e.Error_UnexpectedKind (ec, ResolveFlags.MethodGroup | ResolveFlags.Type, loc);
 					return null;
 				}
 
 				//
 				// An argument is not a method but another delegate
 				//
 				method_group = new MethodGroupExpr (Delegate.GetInvokeMethod (ec.Compiler, e.Type), e.Type, loc);
 				method_group.InstanceExpression = e;
 			}
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="939" endline="1009">
<![CDATA[
 
 		//
 		// Checks that some operators come in pairs
 		//  == and !=
 		// > and <
 		// >= and <=
 		// true and false
 		//
 		// They are matched based on the return type and the argument types
 		//
 		void CheckPairedOperators ()
 		{
 			bool has_equality_or_inequality = false;
 			var operators = this.operators.ToArray ();
 			bool[] has_pair = new bool[operators.Length];
 
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null)
 					continue;
 
 				Operator o_a = (Operator) operators[i];
 				Operator.OpType o_type = o_a.OperatorType;
 				if (o_type == Operator.OpType.Equality || o_type == Operator.OpType.Inequality)
 					has_equality_or_inequality = true;
 
 				Operator.OpType matching_type = o_a.GetMatchingOperator ();
 				if (matching_type == Operator.OpType.TOP) {
 					operators[i] = null;
 					continue;
 				}
 
 				for (int ii = 0; ii < operators.Length; ++ii) {
 					Operator o_b = (Operator) operators[ii];
 					if (o_b == null || o_b.OperatorType != matching_type)
 						continue;
 
 					if (!TypeSpecComparer.IsEqual (o_a.ReturnType, o_b.ReturnType))
 						continue;
 
 					if (!TypeSpecComparer.Equals (o_a.ParameterTypes, o_b.ParameterTypes))
 						continue;
 
 					operators[i] = null;
 
 					//
 					// Used to ignore duplicate user conversions
 					//
 					has_pair[ii] = true;
 				}
 				for (int ii = 0; ii < operators.Length; ++ii) {
 					Operator o_b = (Operator) operators[ii];
 					if (o_b == null || o_b.OperatorType != matching_type)
 						continue;
 
 					if (!TypeSpecComparer.IsEqual (o_a.ReturnType, o_b.ReturnType))
 						continue;
 
 					if (!TypeSpecComparer.Equals (o_a.ParameterTypes, o_b.ParameterTypes))
 						continue;
 
 					operators[i] = null;
 
 					//
 					// Used to ignore duplicate user conversions
 					//
 					has_pair[ii] = true;
 				}
 			}
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null)
 					continue;
 
 				Operator o_a = (Operator) operators[i];
 				Operator.OpType o_type = o_a.OperatorType;
 				if (o_type == Operator.OpType.Equality || o_type == Operator.OpType.Inequality)
 					has_equality_or_inequality = true;
 
 				Operator.OpType matching_type = o_a.GetMatchingOperator ();
 				if (matching_type == Operator.OpType.TOP) {
 					operators[i] = null;
 					continue;
 				}
 
 				for (int ii = 0; ii < operators.Length; ++ii) {
 					Operator o_b = (Operator) operators[ii];
 					if (o_b == null || o_b.OperatorType != matching_type)
 						continue;
 
 					if (!TypeSpecComparer.IsEqual (o_a.ReturnType, o_b.ReturnType))
 						continue;
 
 					if (!TypeSpecComparer.Equals (o_a.ParameterTypes, o_b.ParameterTypes))
 						continue;
 
 					operators[i] = null;
 
 					//
 					// Used to ignore duplicate user conversions
 					//
 					has_pair[ii] = true;
 				}
 			}
 
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null || has_pair[i])
 					continue;
 
 				Operator o = (Operator) operators [i];
 				Report.Error (216, o.Location,
 					"The operator `{0}' requires a matching operator `{1}' to also be defined",
 					o.GetSignatureForError (), Operator.GetName (o.GetMatchingOperator ()));
 			}
 			for (int i = 0; i < operators.Length; ++i) {
 				if (operators[i] == null || has_pair[i])
 					continue;
 
 				Operator o = (Operator) operators [i];
 				Report.Error (216, o.Location,
 					"The operator `{0}' requires a matching operator `{1}' to also be defined",
 					o.GetSignatureForError (), Operator.GetName (o.GetMatchingOperator ()));
 			}
 
 			if (has_equality_or_inequality) {
 				if (Methods == null || !HasEquals)
 					Report.Warning (660, 2, Location, "`{0}' defines operator == or operator != but does not override Object.Equals(object o)",
 						GetSignatureForError ());
 
 				if (Methods == null || !HasGetHashCode)
 					Report.Warning (661, 2, Location, "`{0}' defines operator == or operator != but does not override Object.GetHashCode()",
 						GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="572" endline="584">
<![CDATA[
 		
 		//
 		// For queries like `from a orderby a select a'
 		// the projection is transparent and select clause can be safely removed 
 		//
 		public bool IsRequired (Parameter parameter)
 		{
 			SimpleName sn = expr as SimpleName;
 			if (sn == null)
 				return true;
 
 			return sn.Name != parameter.Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2314" endline="2339">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Owner;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the TypeOrMethodDef encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case TypeDefTable.Index
 						records[i].Owner = (token & 0xFFFFFF) << 1 | 0;
 						break;
 					case MethodDefTable.Index
 						records[i].Owner = (token & 0xFFFFFF) << 1 | 1;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].unsortedIndex = i;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Owner;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the TypeOrMethodDef encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case TypeDefTable.Index
 						records[i].Owner = (token & 0xFFFFFF) << 1 | 0;
 						break;
 					case MethodDefTable.Index
 						records[i].Owner = (token & 0xFFFFFF) << 1 | 1;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].unsortedIndex = i;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="66" endline="97">
<![CDATA[
 		PendingImplementation (TypeContainer container, MissingInterfacesInfo[] missing_ifaces, MethodSpec[] abstract_methods, int total)
 		{
 			var type_builder = container.Definition;
 			
 			this.container = container;
 			pending_implementations = new TypeAndMethods [total];
 
 			int i = 0;
 			if (abstract_methods != null) {
 				int count = abstract_methods.Length;
 				pending_implementations [i].methods = new MethodSpec [count];
 				pending_implementations [i].need_proxy = new MethodSpec [count];
 
 				pending_implementations [i].methods = abstract_methods;
 				pending_implementations [i].found = new MethodData [count];
 				pending_implementations [i].type = type_builder;
 				++i;
 			}
 
 			foreach (MissingInterfacesInfo missing in missing_ifaces) {
 				var iface = missing.Type;
 				var mi = MemberCache.GetInterfaceMethods (iface);
 
 				int count = mi.Count;
 				pending_implementations [i].type = iface;
 				pending_implementations [i].optional = missing.Optional;
 				pending_implementations [i].methods = mi;
 				pending_implementations [i].found = new MethodData [count];
 				pending_implementations [i].need_proxy = new MethodSpec [count];
 				i++;
 			}
 			foreach (MissingInterfacesInfo missing in missing_ifaces) {
 				var iface = missing.Type;
 				var mi = MemberCache.GetInterfaceMethods (iface);
 
 				int count = mi.Count;
 				pending_implementations [i].type = iface;
 				pending_implementations [i].optional = missing.Optional;
 				pending_implementations [i].methods = mi;
 				pending_implementations [i].found = new MethodData [count];
 				pending_implementations [i].need_proxy = new MethodSpec [count];
 				i++;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1209" endline="1258">
<![CDATA[
 
 		public void Resolve (ResolveContext rc, Parameter p)
 		{
 			var expr = Resolve (rc);
 			if (expr == null)
 				return;
 
 			expr = Child;
 
 			if (!(expr is Constant || expr is DefaultValueExpression || (expr is New && ((New) expr).IsDefaultStruct))) {
 				rc.Compiler.Report.Error (1736, Location,
 					"The expression being assigned to optional parameter `{0}' must be a constant or default value",
 					p.Name);
 
 				return;
 			}
 
 			var parameter_type = p.Type;
 			if (type == parameter_type)
 				return;
 
 			var res = Convert.ImplicitConversionStandard (rc, expr, parameter_type, Location);
 			if (res != null) {
 				if (TypeManager.IsNullableType (parameter_type) && res is Nullable.Wrap) {
 					Nullable.Wrap wrap = (Nullable.Wrap) res;
 					res = wrap.Child;
 					if (!(res is Constant)) {
 						rc.Compiler.Report.Error (1770, Location,
 							"The expression being assigned to nullable optional parameter `{0}' must be default value",
 							p.Name);
 						return;
 					}
 				}
 
 				if (!expr.IsNull && TypeManager.IsReferenceType (parameter_type) && parameter_type != TypeManager.string_type) {
 					rc.Compiler.Report.Error (1763, Location,
 						"Optional parameter `{0}' of type `{1}' can only be initialized with `null'",
 						p.Name, parameter_type.GetSignatureForError ());
 
 					return;
 				}
 
 				this.expr = res;
 				return;
 			}
 
 			rc.Compiler.Report.Error (1750, Location,
 				"Optional parameter expression of type `{0}' cannot be converted to parameter type `{1}'",
 				type.GetSignatureForError (), parameter_type.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="570" endline="625">
<![CDATA[
 
 		static public byte[] ToCapiPublicKeyBlob (DSA dsa)
 		{
 			DSAParameters p = dsa.ExportParameters (false);
 			int keyLength = p.P.Length; // in bytes
 
 			// header + P + Q + G + Y + count + seed
 			byte[] blob = new byte [16 + keyLength + 20 + keyLength + keyLength + 4 + 20];
 
 			blob [0] = 0x06;	// Type - PUBLICKEYBLOB (0x06)
 			blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
 			// [2], [3]		// RESERVED - Always 0
 			blob [5] = 0x22;	// ALGID
 			blob [8] = 0x44;	// Magic
 			blob [9] = 0x53;
 			blob [10] = 0x53;
 			blob [11] = 0x31;
 
 			byte[] bitlen = GetBytesLE (keyLength << 3);
 			blob [12] = bitlen [0];
 			blob [13] = bitlen [1];
 			blob [14] = bitlen [2];
 			blob [15] = bitlen [3];
 
 			int pos = 16;
 			byte[] part;
 
 			part = p.P;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.Q;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 			pos += 20;
 
 			part = p.G;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.Y;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			Buffer.BlockCopy (GetBytesLE (p.Counter), 0, blob, pos, 4);
 			pos += 4;
 
 			part = p.Seed;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 
 			return blob;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="68" endline="147">
<![CDATA[
 
 		private sealed class UnboundGenericMethodContext 
 		{
 			private readonly IGenericContext original;
 
 			internal UnboundGenericMethodContext(IGenericContext original)
 			{
 				this.original = original;
 			}
 
 			public Type GetGenericTypeArgument(int index)
 			{
 				return original.GetGenericTypeArgument(index);
 			}
 
 			public Type GetGenericMethodArgument(int index)
 			{
 				return UnboundGenericMethodParameter.Make(index);
 			}
 		}
 
 		internal static MethodSignature ReadSig(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			CallingConventions callingConvention;
 			int genericParamCount;
 			Type returnType;
 			Type[] parameterTypes;
 			byte flags = br.ReadByte();
 			switch (flags & 7)
 			{
 				case DEFAULT
 					callingConvention = CallingConventions.Standard;
 					break;
 				case VARARG
 					callingConvention = CallingConventions.VarArgs;
 					break;
 				default
 					throw new BadImageFormatException();
 			}
 			if ((flags & HASTHIS) != 0)
 			{
 				callingConvention |= CallingConventions.HasThis;
 			}
 			if ((flags & EXPLICITTHIS) != 0)
 			{
 				callingConvention |= CallingConventions.ExplicitThis;
 			}
 			genericParamCount = 0;
 			if ((flags & GENERIC) != 0)
 			{
 				genericParamCount = br.ReadCompressedInt();
 				context = new UnboundGenericMethodContext(context);
 			}
 			int paramCount = br.ReadCompressedInt();
 			Type[][][] modifiers = null;
 			Type[] optionalCustomModifiers;
 			Type[] requiredCustomModifiers;
 			ReadCustomModifiers(module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
 			returnType = ReadRetType(module, br, context);
 			parameterTypes = new Type[paramCount];
 			PackedCustomModifiers.SetModifiers(ref modifiers, 0, 0, optionalCustomModifiers, paramCount + 1);
 			PackedCustomModifiers.SetModifiers(ref modifiers, 0, 1, requiredCustomModifiers, paramCount + 1);
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if ((callingConvention & CallingConventions.VarArgs) != 0 && br.PeekByte() == SENTINEL)
 				{
 					Array.Resize(ref parameterTypes, i);
 					if (modifiers != null)
 					{
 						Array.Resize(ref modifiers, i + 1);
 					}
 					break;
 				}
 				ReadCustomModifiers(module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
 				PackedCustomModifiers.SetModifiers(ref modifiers, i + 1, 0, optionalCustomModifiers, paramCount + 1);
 				PackedCustomModifiers.SetModifiers(ref modifiers, i + 1, 1, requiredCustomModifiers, paramCount + 1);
 				parameterTypes[i] = ReadParam(module, br, context);
 			}
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if ((callingConvention & CallingConventions.VarArgs) != 0 && br.PeekByte() == SENTINEL)
 				{
 					Array.Resize(ref parameterTypes, i);
 					if (modifiers != null)
 					{
 						Array.Resize(ref modifiers, i + 1);
 					}
 					break;
 				}
 				ReadCustomModifiers(module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
 				PackedCustomModifiers.SetModifiers(ref modifiers, i + 1, 0, optionalCustomModifiers, paramCount + 1);
 				PackedCustomModifiers.SetModifiers(ref modifiers, i + 1, 1, requiredCustomModifiers, paramCount + 1);
 				parameterTypes[i] = ReadParam(module, br, context);
 			}
 			return new MethodSignature(returnType, parameterTypes, modifiers, callingConvention, genericParamCount);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="218" endline="299">
<![CDATA[
 
 		// note that this is the fusion specific parser, it is not the same as System.Reflection.AssemblyName
 		private static bool ParseAssemblyName(string fullName, out ParsedAssemblyName parsedName)
 		{
 			parsedName = new ParsedAssemblyName();
 			StringBuilder sb = new StringBuilder();
 			int pos = 0;
 			while (pos < fullName.Length)
 			{
 				char ch = fullName[pos++];
 				if (ch == '\\')
 				{
 					if (pos == fullName.Length)
 					{
 						return false;
 					}
 					ch = fullName[pos++];
 				}
 				else if (ch == ',')
 				{
 					break;
 				}
 				sb.Append(ch);
 			}
 			while (pos < fullName.Length)
 			{
 				char ch = fullName[pos++];
 				if (ch == '\\')
 				{
 					if (pos == fullName.Length)
 					{
 						return false;
 					}
 					ch = fullName[pos++];
 				}
 				else if (ch == ',')
 				{
 					break;
 				}
 				sb.Append(ch);
 			}
 			parsedName.Name = sb.ToString().Trim();
 			if (pos < fullName.Length)
 			{
 				string[] parts = fullName.Substring(pos).Split(',');
 				for (int i = 0; i < parts.Length; i++)
 				{
 					string[] kv = parts[i].Split('=');
 					if (kv.Length != 2)
 					{
 						return false;
 					}
 					switch (kv[0].Trim().ToLowerInvariant())
 					{
 						case "version"
 							if (parsedName.Version != null)
 							{
 								return false;
 							}
 							if (!ParseVersion(kv[1].Trim(), out parsedName.Version))
 							{
 								return false;
 							}
 							break;
 						case "culture"
 							if (parsedName.Culture != null)
 							{
 								return false;
 							}
 							if (!ParseCulture(kv[1].Trim(), out parsedName.Culture))
 							{
 								return false;
 							}
 							break;
 						case "publickeytoken"
 							if (parsedName.PublicKeyToken != null)
 							{
 								return false;
 							}
 							if (!ParsePublicKeyToken(kv[1].Trim(), out parsedName.PublicKeyToken))
 							{
 								return false;
 							}
 							break;
 						case "publickey"
 							if (parsedName.PublicKeyToken != null)
 							{
 								return false;
 							}
 							if (!ParsePublicKey(kv[1].Trim(), out parsedName.PublicKeyToken))
 							{
 								return false;
 							}
 							break;
 					}
 				}
 				for (int i = 0; i < parts.Length; i++)
 				{
 					string[] kv = parts[i].Split('=');
 					if (kv.Length != 2)
 					{
 						return false;
 					}
 					switch (kv[0].Trim().ToLowerInvariant())
 					{
 						case "version"
 							if (parsedName.Version != null)
 							{
 								return false;
 							}
 							if (!ParseVersion(kv[1].Trim(), out parsedName.Version))
 							{
 								return false;
 							}
 							break;
 						case "culture"
 							if (parsedName.Culture != null)
 							{
 								return false;
 							}
 							if (!ParseCulture(kv[1].Trim(), out parsedName.Culture))
 							{
 								return false;
 							}
 							break;
 						case "publickeytoken"
 							if (parsedName.PublicKeyToken != null)
 							{
 								return false;
 							}
 							if (!ParsePublicKeyToken(kv[1].Trim(), out parsedName.PublicKeyToken))
 							{
 								return false;
 							}
 							break;
 						case "publickey"
 							if (parsedName.PublicKeyToken != null)
 							{
 								return false;
 							}
 							if (!ParsePublicKey(kv[1].Trim(), out parsedName.PublicKeyToken))
 							{
 								return false;
 							}
 							break;
 					}
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1679" endline="1756">
<![CDATA[
 
 		public static AnonymousTypeClass Create (CompilerContext ctx, TypeContainer parent, IList<AnonymousTypeParameter> parameters, Location loc)
 		{
 			string name = ClassNamePrefix + types_counter++;
 
 			ParametersCompiled all_parameters;
 			TypeParameterName[] t_params;
 			SimpleName[] t_args;
 
 			if (parameters.Count == 0) {
 				all_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 				t_params = new TypeParameterName[0];
 				t_args = null;
 			} else {
 				t_args = new SimpleName[parameters.Count];
 				t_params = new TypeParameterName[parameters.Count];
 				Parameter[] ctor_params = new Parameter[parameters.Count];
 				for (int i = 0; i < parameters.Count; ++i) {
 					AnonymousTypeParameter p = parameters[i];
 
 					t_args[i] = new SimpleName ("<" + p.Name + ">__T", p.Location);
 					t_params[i] = new TypeParameterName (t_args[i].Name, null, p.Location);
 					ctor_params[i] = new GeneratedParameter (t_args[i], p);
 				}
 				for (int i = 0; i < parameters.Count; ++i) {
 					AnonymousTypeParameter p = parameters[i];
 
 					t_args[i] = new SimpleName ("<" + p.Name + ">__T", p.Location);
 					t_params[i] = new TypeParameterName (t_args[i].Name, null, p.Location);
 					ctor_params[i] = new GeneratedParameter (t_args[i], p);
 				}
 
 				all_parameters = new ParametersCompiled (ctor_params);
 			}
 
 			//
 			// Create generic anonymous type host with generic arguments
 			// named upon properties names
 			//
 			AnonymousTypeClass a_type = new AnonymousTypeClass (parent.NamespaceEntry.SlaveDeclSpace,
 				new MemberName (name, new TypeArguments (t_params), loc), parameters, loc);
 
 			if (parameters.Count > 0)
 				a_type.SetParameterInfo (null);
 
 			Constructor c = new Constructor (a_type, name, Modifiers.PUBLIC | Modifiers.DEBUGGER_HIDDEN,
 				null, all_parameters, null, loc);
 			c.Block = new ToplevelBlock (ctx, c.ParameterInfo, loc);
 
 			// 
 			// Create fields and contructor body with field initialization
 			//
 			bool error = false;
 			for (int i = 0; i < parameters.Count; ++i) {
 				AnonymousTypeParameter p = parameters [i];
 
 				Field f = new Field (a_type, t_args [i], Modifiers.PRIVATE | Modifiers.READONLY,
 					new MemberName ("<" + p.Name + ">", p.Location), null);
 
 				if (!a_type.AddField (f)) {
 					error = true;
 					continue;
 				}
 
 				c.Block.AddStatement (new StatementExpression (
 					new SimpleAssign (new MemberAccess (new This (p.Location), f.Name),
 						c.Block.GetParameterReference (i, p.Location))));
 
 				ToplevelBlock get_block = new ToplevelBlock (ctx, p.Location);
 				get_block.AddStatement (new Return (
 					new MemberAccess (new This (p.Location), f.Name), p.Location));
 
 				Property prop = new Property (a_type, t_args [i], Modifiers.PUBLIC,
 					new MemberName (p.Name, p.Location), null);
 				prop.Get = new Property.GetMethod (prop, 0, null, p.Location);
 				prop.Get.Block = get_block;
 				a_type.AddProperty (prop);
 			}
 			for (int i = 0; i < parameters.Count; ++i) {
 				AnonymousTypeParameter p = parameters [i];
 
 				Field f = new Field (a_type, t_args [i], Modifiers.PRIVATE | Modifiers.READONLY,
 					new MemberName ("<" + p.Name + ">", p.Location), null);
 
 				if (!a_type.AddField (f)) {
 					error = true;
 					continue;
 				}
 
 				c.Block.AddStatement (new StatementExpression (
 					new SimpleAssign (new MemberAccess (new This (p.Location), f.Name),
 						c.Block.GetParameterReference (i, p.Location))));
 
 				ToplevelBlock get_block = new ToplevelBlock (ctx, p.Location);
 				get_block.AddStatement (new Return (
 					new MemberAccess (new This (p.Location), f.Name), p.Location));
 
 				Property prop = new Property (a_type, t_args [i], Modifiers.PUBLIC,
 					new MemberName (p.Name, p.Location), null);
 				prop.Get = new Property.GetMethod (prop, 0, null, p.Location);
 				prop.Get.Block = get_block;
 				a_type.AddProperty (prop);
 			}
 
 			if (error)
 				return null;
 
 			a_type.AddConstructor (c);
 			return a_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1051" endline="1136">
<![CDATA[
 
 		//
 		// Creates a proxy base method call inside this container for hoisted base member calls
 		//
 		public MethodSpec CreateHoistedBaseCallProxy (ResolveContext rc, MethodSpec method)
 		{
 			Method proxy_method;
 
 			//
 			// One proxy per base method is enough
 			//
 			if (hoisted_base_call_proxies == null) {
 				hoisted_base_call_proxies = new Dictionary<MethodSpec, Method> ();
 				proxy_method = null;
 			} else {
 				hoisted_base_call_proxies.TryGetValue (method, out proxy_method);
 			}
 
 			if (proxy_method == null) {
 				string name = CompilerGeneratedClass.MakeName (method.Name, null, "BaseCallProxy", hoisted_base_call_proxies.Count);
 				var base_parameters = new Parameter[method.Parameters.Count];
 				for (int i = 0; i < base_parameters.Length; ++i) {
 					var base_param = method.Parameters.FixedParameters[i];
 					base_parameters[i] = new Parameter (new TypeExpression (method.Parameters.Types[i], Location),
 						base_param.Name, base_param.ModFlags, null, Location);
 					base_parameters[i].Resolve (this, i);
 				}
 				for (int i = 0; i < base_parameters.Length; ++i) {
 					var base_param = method.Parameters.FixedParameters[i];
 					base_parameters[i] = new Parameter (new TypeExpression (method.Parameters.Types[i], Location),
 						base_param.Name, base_param.ModFlags, null, Location);
 					base_parameters[i].Resolve (this, i);
 				}
 
 				var cloned_params = ParametersCompiled.CreateFullyResolved (base_parameters, method.Parameters.Types);
 				if (method.Parameters.HasArglist) {
 					cloned_params.FixedParameters[0] = new Parameter (null, "__arglist", Parameter.Modifier.NONE, null, Location);
 					cloned_params.Types[0] = Module.PredefinedTypes.RuntimeArgumentHandle.Resolve (Location);
 				}
 
 				GenericMethod generic_method;
 				MemberName member_name;
 				if (method.IsGeneric) {
 					//
 					// Copy all base generic method type parameters info
 					//
 					var hoisted_tparams = method.GenericDefinition.TypeParameters;
 					var targs = new TypeArguments ();
 					var type_params = new TypeParameter[hoisted_tparams.Length];
 					for (int i = 0; i < type_params.Length; ++i) {
 						var tp = hoisted_tparams[i];
 						targs.Add (new TypeParameterName (tp.Name, null, Location));
 						type_params[i] = new TypeParameter (tp, null, null, new MemberName (tp.Name), null);
 					}
 					for (int i = 0; i < type_params.Length; ++i) {
 						var tp = hoisted_tparams[i];
 						targs.Add (new TypeParameterName (tp.Name, null, Location));
 						type_params[i] = new TypeParameter (tp, null, null, new MemberName (tp.Name), null);
 					}
 
 					member_name = new MemberName (name, targs, Location);
 					generic_method = new GenericMethod (NamespaceEntry, this, member_name, type_params,
 						new TypeExpression (method.ReturnType, Location), cloned_params);
 				} else {
 					member_name = new MemberName (name);
 					generic_method = null;
 				}
 
 				// Compiler generated proxy
 				proxy_method = new Method (this, generic_method, new TypeExpression (method.ReturnType, Location),
 					Modifiers.PRIVATE | Modifiers.COMPILER_GENERATED | Modifiers.DEBUGGER_HIDDEN,
 					member_name, cloned_params, null);
 
 				var block = new ToplevelBlock (Compiler, proxy_method.ParameterInfo, Location);
 
 				var mg = MethodGroupExpr.CreatePredefined (method, method.DeclaringType, Location);
 				mg.InstanceExpression = new BaseThis (method.DeclaringType, Location);
 
 				// Get all the method parameters and pass them as arguments
 				var real_base_call = new Invocation (mg, block.GetAllParametersArguments ());
 				Statement statement;
 				if (method.ReturnType == TypeManager.void_type)
 					statement = new StatementExpression (real_base_call);
 				else
 					statement = new Return (real_base_call, Location);
 
 				block.AddStatement (statement);
 				proxy_method.Block = block;
 
 				methods.Add (proxy_method);
 				proxy_method.Define ();
 
 				hoisted_base_call_proxies.Add (method, proxy_method);
 			}
 
 			return proxy_method.Spec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="826" endline="900">
<![CDATA[
 
 		/// <summary>
 		///   This function computes the Base class and also the
 		///   list of interfaces that the class or struct @c implements.
 		///   
 		///   The return value is an array (might be null) of
 		///   interfaces implemented (as Types).
 		///   
 		///   The @base_class argument is set to the base object or null
 		///   if this is `System.Object'. 
 		/// </summary>
 		protected virtual TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			base_class = null;
 			if (type_bases == null)
 				return null;
 
 			int count = type_bases.Count;
 			TypeExpr [] ifaces = null;
 			var base_context = new BaseContext (this);
 			for (int i = 0, j = 0; i < count; i++){
 				FullNamedExpression fne = type_bases [i];
 
 				TypeExpr fne_resolved = fne.ResolveAsTypeTerminal (base_context, false);
 				if (fne_resolved == null)
 					continue;
 
 				if (i == 0 && Kind == MemberKind.Class && !fne_resolved.Type.IsInterface) {
 					if (fne_resolved.Type == InternalType.Dynamic) {
 						Report.Error (1965, Location, "Class `{0}' cannot derive from the dynamic type",
 							GetSignatureForError ());
 
 						continue;
 					}
 					
 					base_type = fne_resolved.Type;
 					base_class = fne_resolved;
 					continue;
 				}
 
 				if (ifaces == null)
 					ifaces = new TypeExpr [count - i];
 
 				if (fne_resolved.Type.IsInterface) {
 					for (int ii = 0; ii < j; ++ii) {
 						if (fne_resolved.Type == ifaces [ii].Type) {
 							Report.Error (528, Location, "`{0}' is already listed in interface list",
 								fne_resolved.GetSignatureForError ());
 							break;
 						}
 					}
 					for (int ii = 0; ii < j; ++ii) {
 						if (fne_resolved.Type == ifaces [ii].Type) {
 							Report.Error (528, Location, "`{0}' is already listed in interface list",
 								fne_resolved.GetSignatureForError ());
 							break;
 						}
 					}
 
 					if (Kind == MemberKind.Interface && !IsAccessibleAs (fne_resolved.Type)) {
 						Report.Error (61, fne.Location,
 							"Inconsistent accessibility
 							fne_resolved.GetSignatureForError (), GetSignatureForError ());
 					}
 				} else {
 					Report.SymbolRelatedToPreviousError (fne_resolved.Type);
 					if (Kind != MemberKind.Class) {
 						Report.Error (527, fne.Location, "Type `{0}' in interface list is not an interface", fne_resolved.GetSignatureForError ());
 					} else if (base_class != null)
 						Report.Error (1721, fne.Location, "`{0}'
 							GetSignatureForError (), base_class.GetSignatureForError (), fne_resolved.GetSignatureForError ());
 					else {
 						Report.Error (1722, fne.Location, "`{0}'
 							GetSignatureForError (), fne_resolved.GetSignatureForError ());
 					}
 				}
 
 				ifaces [j++] = fne_resolved;
 			}
 			for (int i = 0, j = 0; i < count; i++){
 				FullNamedExpression fne = type_bases [i];
 
 				TypeExpr fne_resolved = fne.ResolveAsTypeTerminal (base_context, false);
 				if (fne_resolved == null)
 					continue;
 
 				if (i == 0 && Kind == MemberKind.Class && !fne_resolved.Type.IsInterface) {
 					if (fne_resolved.Type == InternalType.Dynamic) {
 						Report.Error (1965, Location, "Class `{0}' cannot derive from the dynamic type",
 							GetSignatureForError ());
 
 						continue;
 					}
 					
 					base_type = fne_resolved.Type;
 					base_class = fne_resolved;
 					continue;
 				}
 
 				if (ifaces == null)
 					ifaces = new TypeExpr [count - i];
 
 				if (fne_resolved.Type.IsInterface) {
 					for (int ii = 0; ii < j; ++ii) {
 						if (fne_resolved.Type == ifaces [ii].Type) {
 							Report.Error (528, Location, "`{0}' is already listed in interface list",
 								fne_resolved.GetSignatureForError ());
 							break;
 						}
 					}
 
 					if (Kind == MemberKind.Interface && !IsAccessibleAs (fne_resolved.Type)) {
 						Report.Error (61, fne.Location,
 							"Inconsistent accessibility
 							fne_resolved.GetSignatureForError (), GetSignatureForError ());
 					}
 				} else {
 					Report.SymbolRelatedToPreviousError (fne_resolved.Type);
 					if (Kind != MemberKind.Class) {
 						Report.Error (527, fne.Location, "Type `{0}' in interface list is not an interface", fne_resolved.GetSignatureForError ());
 					} else if (base_class != null)
 						Report.Error (1721, fne.Location, "`{0}'
 							GetSignatureForError (), base_class.GetSignatureForError (), fne_resolved.GetSignatureForError ());
 					else {
 						Report.Error (1722, fne.Location, "`{0}'
 							GetSignatureForError (), fne_resolved.GetSignatureForError ());
 					}
 				}
 
 				ifaces [j++] = fne_resolved;
 			}
 
 			return ifaces;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1346" endline="1435">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (base.DoResolve (ec) == null)
 				return null;
 
 			TypeSpec d = expr.Type;
 			bool d_is_nullable = false;
 
 			//
 			// If E is a method group or the null literal, or if the type of E is a reference
 			// type or a nullable type and the value of E is null, the result is false
 			//
 			if (expr.IsNull || expr.eclass == ExprClass.MethodGroup)
 				return CreateConstantResult (ec, false);
 
 			if (TypeManager.IsNullableType (d)) {
 				var ut = Nullable.NullableInfo.GetUnderlyingType (d);
 				if (!ut.IsGenericParameter) {
 					d = ut;
 					d_is_nullable = true;
 				}
 			}
 
 			type = TypeManager.bool_type;
 			eclass = ExprClass.Value;
 			TypeSpec t = probe_type_expr.Type;
 			bool t_is_nullable = false;
 			if (TypeManager.IsNullableType (t)) {
 				var ut = Nullable.NullableInfo.GetUnderlyingType (t);
 				if (!ut.IsGenericParameter) {
 					t = ut;
 					t_is_nullable = true;
 				}
 			}
 
 			if (TypeManager.IsStruct (t)) {
 				if (d == t) {
 					//
 					// D and T are the same value types but D can be null
 					//
 					if (d_is_nullable && !t_is_nullable) {
 						expr_unwrap = Nullable.Unwrap.Create (expr, false);
 						return this;
 					}
 					
 					//
 					// The result is true if D and T are the same value types
 					//
 					return CreateConstantResult (ec, true);
 				}
 
 				var tp = d as TypeParameterSpec;
 				if (tp != null)
 					return ResolveGenericParameter (ec, t, tp);
 
 				//
 				// An unboxing conversion exists
 				//
 				if (Convert.ExplicitReferenceConversionExists (d, t))
 					return this;
 			} else {
 				if (TypeManager.IsGenericParameter (t))
 					return ResolveGenericParameter (ec, d, (TypeParameterSpec) t);
 
 				if (t == InternalType.Dynamic) {
 					ec.Report.Warning (1981, 3, loc,
 						"Using `{0}' to test compatibility with `{1}' is identical to testing compatibility with `object'",
 						OperatorName, t.GetSignatureForError ());
 				}
 
 				if (TypeManager.IsStruct (d) && d != TypeManager.void_type) {
 					if (Convert.ImplicitBoxingConversion (null, d, t) != null)
 						return CreateConstantResult (ec, true);
 				} else {
 					if (TypeManager.IsGenericParameter (d))
 						return ResolveGenericParameter (ec, t, (TypeParameterSpec) d);
 
 					if (InflatedTypeSpec.ContainsTypeParameter (d))
 						return this;
 
 					if (Convert.ImplicitReferenceConversionExists (expr, t) ||
 						Convert.ExplicitReferenceConversionExists (d, t)) {
 						return this;
 					}
 				}
 			}
 
 			return CreateConstantResult (ec, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5121" endline="5200">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression member_expr;
 			var atn = expr as ATypeNameExpression;
 			if (atn != null) {
 				member_expr = atn.LookupNameExpression (ec, MemberLookupRestrictions.InvocableOnly | MemberLookupRestrictions.ReadAccess);
 				if (member_expr != null)
 					member_expr = member_expr.Resolve (ec);
 			} else {
 				member_expr = expr.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.MethodGroup);
 			}
 
 			if (member_expr == null)
 				return null;
 
 			//
 			// Next, evaluate all the expressions in the argument list
 			//
 			bool dynamic_arg = false;
 			if (arguments != null)
 				arguments.Resolve (ec, out dynamic_arg);
 
 			TypeSpec expr_type = member_expr.Type;
 			if (expr_type == InternalType.Dynamic)
 				return DoResolveDynamic (ec, member_expr);
 
 			mg = member_expr as MethodGroupExpr;
 			Expression invoke = null;
 
 			if (mg == null) {
 				if (expr_type != null && TypeManager.IsDelegateType (expr_type)) {
 					invoke = new DelegateInvocation (member_expr, arguments, loc);
 					invoke = invoke.Resolve (ec);
 					if (invoke == null || !dynamic_arg)
 						return invoke;
 				} else {
 					if (member_expr is RuntimeValueExpression) {
 						ec.Report.Error (Report.RuntimeErrorId, loc, "Cannot invoke a non-delegate type `{0}'",
 							member_expr.Type.GetSignatureForError ()); ;
 						return null;
 					}
 
 					MemberExpr me = member_expr as MemberExpr;
 					if (me == null) {
 						member_expr.Error_UnexpectedKind (ec, ResolveFlags.MethodGroup, loc);
 						return null;
 					}
 
 					ec.Report.Error (1955, loc, "The member `{0}' cannot be used as method or delegate",
 							member_expr.GetSignatureForError ());
 					return null;
 				}
 			}
 
 			if (invoke == null) {
 				mg = DoResolveOverload (ec);
 				if (mg == null)
 					return null;
 			}
 
 			if (dynamic_arg)
 				return DoResolveDynamic (ec, member_expr);
 
 			var method = mg.BestCandidate;
 			type = mg.BestCandidateReturnType;
 		
 			if (arguments == null && method.DeclaringType == TypeManager.object_type && method.Name == Destructor.MetadataName) {
 				if (mg.IsBase)
 					ec.Report.Error (250, loc, "Do not directly call your base class Finalize method. It is called automatically from your destructor");
 				else
 					ec.Report.Error (245, loc, "Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available");
 				return null;
 			}
 
 			IsSpecialMethodInvocation (ec, method, loc);
 			
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="309" endline="366">
<![CDATA[
 	
 	
 	void OutlineProperty (PropertyInfo pi)
 	{
 		ParameterInfo [] idxp = pi.GetIndexParameters ();
 		MethodBase g = pi.GetGetMethod (true);
 		MethodBase s = pi.GetSetMethod (true);
 		MethodBase accessor = g != null ? g 
 		
 		if (pi.CanRead && pi.CanWrite) {
 
 			
 			// Get the more accessible accessor
 			if ((g.Attributes & MethodAttributes.MemberAccessMask) !=
 			    (s.Attributes & MethodAttributes.MemberAccessMask)) {
 				
 				if (g.IsPublic) accessor = g;
 				else if (s.IsPublic) accessor = s;
 				else if (g.IsFamilyOrAssembly) accessor = g;
 				else if (s.IsFamilyOrAssembly) accessor = s;
 				else if (g.IsAssembly || g.IsFamily) accessor = g;
 				else if (s.IsAssembly || s.IsFamily) accessor = s;
 			}
 		}
 		
 		o.Write (GetMethodVisibility (accessor));
 		o.Write (GetMethodModifiers  (accessor));
 		o.Write (FormatType (pi.PropertyType));
 		o.Write (" ");
 		
 		if (idxp.Length == 0)
 			o.Write (pi.Name);
 		else {
 			o.Write ("this [");
 			OutlineParams (idxp);
 			o.Write ("]");
 		}
 		
 		o.WriteLine (" {");
 		o.Indent ++;
 		
 		if (g != null && ShowMember (g)) {
 			if ((g.Attributes & MethodAttributes.MemberAccessMask) !=
 			    (accessor.Attributes & MethodAttributes.MemberAccessMask))
 				o.Write (GetMethodVisibility (g));
 			o.WriteLine ("get;");
 		}
 		
 		if (s != null && ShowMember (s)) {
 			if ((s.Attributes & MethodAttributes.MemberAccessMask) !=
 			    (accessor.Attributes & MethodAttributes.MemberAccessMask))
 				o.Write (GetMethodVisibility (s));
 			o.WriteLine ("set;");
 		}
 		
 		o.Indent --;
 		o.Write ("}");
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="985" endline="1069">
<![CDATA[
 
 		private FullNamedExpression Lookup (string name, int arity, Location loc, bool ignore_cs0104)
 		{
 			//
 			// Check whether it's in the namespace.
 			//
 			FullNamedExpression fne = ns.Lookup (Compiler, name, arity, loc);
 
 			//
 			// Check aliases. 
 			//
 			if (using_aliases != null && arity == 0) {
 				foreach (UsingAliasEntry ue in using_aliases) {
 					if (ue.Alias == name) {
 						if (fne != null) {
 							if (Doppelganger != null) {
 								// TODO
 								//Report.SymbolRelatedToPreviousError (fne.Location, null);
 								Compiler.Report.SymbolRelatedToPreviousError (ue.Location, null);
 								Compiler.Report.Error (576, loc,
 									"Namespace `{0}' contains a definition with same name as alias `{1}'",
 									GetSignatureForError (), name);
 							} else {
 								return fne;
 							}
 						}
 
 						return ue.Resolve (Doppelganger ?? this, Doppelganger == null);
 					}
 				}
 				foreach (UsingAliasEntry ue in using_aliases) {
 					if (ue.Alias == name) {
 						if (fne != null) {
 							if (Doppelganger != null) {
 								// TODO
 								//Report.SymbolRelatedToPreviousError (fne.Location, null);
 								Compiler.Report.SymbolRelatedToPreviousError (ue.Location, null);
 								Compiler.Report.Error (576, loc,
 									"Namespace `{0}' contains a definition with same name as alias `{1}'",
 									GetSignatureForError (), name);
 							} else {
 								return fne;
 							}
 						}
 
 						return ue.Resolve (Doppelganger ?? this, Doppelganger == null);
 					}
 				}
 			}
 
 			if (fne != null) {
 				if (!((fne.Type.Modifiers & Modifiers.INTERNAL) != 0 && !fne.Type.MemberDefinition.IsInternalAsPublic (RootContext.ToplevelTypes.DeclaringAssembly)))
 					return fne;
 			}
 
 			if (IsImplicit)
 				return null;
 
 			//
 			// Check using entries.
 			//
 			FullNamedExpression match = null;
 			foreach (Namespace using_ns in GetUsingTable ()) {
 				// A using directive imports only types contained in the namespace, it
 				// does not import any nested namespaces
 				fne = using_ns.LookupType (Compiler, name, arity, false, loc);
 				if (fne == null)
 					continue;
 
 				if (match == null) {
 					match = fne;
 					continue;
 				}
 
 				// Prefer types over namespaces
 				var texpr_fne = fne as TypeExpr;
 				var texpr_match = match as TypeExpr;
 				if (texpr_fne != null && texpr_match == null) {
 					match = fne;
 					continue;
 				} else if (texpr_fne == null) {
 					continue;
 				}
 
 				if (ignore_cs0104)
 					return match;
 
 				// It can be top level accessibility only
 				var better = Namespace.IsImportedTypeOverride (texpr_match.Type, texpr_fne.Type);
 				if (better == null) {
 					Compiler.Report.SymbolRelatedToPreviousError (texpr_match.Type);
 					Compiler.Report.SymbolRelatedToPreviousError (texpr_fne.Type);
 					Compiler.Report.Error (104, loc, "`{0}' is an ambiguous reference between `{1}' and `{2}'",
 						name, texpr_match.GetSignatureForError (), texpr_fne.GetSignatureForError ());
 					return match;
 				}
 
 				if (better == texpr_fne.Type)
 					match = texpr_fne;
 			}
 			foreach (Namespace using_ns in GetUsingTable ()) {
 				// A using directive imports only types contained in the namespace, it
 				// does not import any nested namespaces
 				fne = using_ns.LookupType (Compiler, name, arity, false, loc);
 				if (fne == null)
 					continue;
 
 				if (match == null) {
 					match = fne;
 					continue;
 				}
 
 				// Prefer types over namespaces
 				var texpr_fne = fne as TypeExpr;
 				var texpr_match = match as TypeExpr;
 				if (texpr_fne != null && texpr_match == null) {
 					match = fne;
 					continue;
 				} else if (texpr_fne == null) {
 					continue;
 				}
 
 				if (ignore_cs0104)
 					return match;
 
 				// It can be top level accessibility only
 				var better = Namespace.IsImportedTypeOverride (texpr_match.Type, texpr_fne.Type);
 				if (better == null) {
 					Compiler.Report.SymbolRelatedToPreviousError (texpr_match.Type);
 					Compiler.Report.SymbolRelatedToPreviousError (texpr_fne.Type);
 					Compiler.Report.Error (104, loc, "`{0}' is an ambiguous reference between `{1}' and `{2}'",
 						name, texpr_match.GetSignatureForError (), texpr_fne.GetSignatureForError ());
 					return match;
 				}
 
 				if (better == texpr_fne.Type)
 					match = texpr_fne;
 			}
 
 			return match;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="428" endline="438">
<![CDATA[
 
 		private Module ResolveModuleRef(int moduleNameIndex)
 		{
 			string moduleName = GetString(moduleNameIndex);
 			Module module = assembly.GetModule(moduleName);
 			if (module == null)
 			{
 				throw new FileNotFoundException(moduleName);
 			}
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="499" endline="514">
<![CDATA[
 		}
 
 		public virtual string GetSignatureForError ()
 		{
 			string type_name;
 			if (parameter_type != null)
 				type_name = TypeManager.CSharpName (parameter_type);
 			else
 				type_name = texpr.GetSignatureForError ();
 
 			string mod = GetModifierSignature (modFlags);
 			if (mod.Length > 0)
 				return String.Concat (mod, " ", type_name);
 
 			return type_name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="148" endline="161">
<![CDATA[
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (base.Resolve (ec, index) == null)
 				return null;
 
 			var ac = parameter_type as ArrayContainer;
 			if (ac == null || ac.Rank != 1) {
 				ec.Compiler.Report.Error (225, Location, "The params parameter must be a single dimensional array");
 				return null;
 			}
 
 			return parameter_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="241" endline="261">
<![CDATA[
 		}
 
 		#endregion
 
 		public bool AddInterface (TypeSpec iface)
 		{
 			if ((state & StateFlags.InterfacesExpanded) != 0)
 				throw new InternalErrorException ("Modifying expanded interface list");
 
 			if (ifaces == null) {
 				ifaces = new List<TypeSpec> () { iface };
 				return true;
 			}
 
 			if (!ifaces.Contains (iface)) {
 				ifaces.Add (iface);
 				return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2515" endline="2531">
<![CDATA[
 
 		protected void ProcessParameters ()
 		{
 			if (parameters.Count == 0)
 				return;
 
 			parameter_info = new ParameterInfo[parameters.Count];
 			for (int i = 0; i < parameter_info.Length; ++i) {
 				var p = parameters.FixedParameters[i];
 				if (p == null)
 					continue;
 
 				// TODO
 				parameter_info[i] = new ParameterInfo (this, i);
 				AddLocalName (p.Name, parameter_info[i]);
 			}
 			for (int i = 0; i < parameter_info.Length; ++i) {
 				var p = parameters.FixedParameters[i];
 				if (p == null)
 					continue;
 
 				// TODO
 				parameter_info[i] = new ParameterInfo (this, i);
 				AddLocalName (p.Name, parameter_info[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1334" endline="1358">
<![CDATA[
 	}
 
 	public class InflatedTypeSpec 
 	{
 		TypeSpec[] targs;
 		TypeParameterSpec[] constraints;
 		readonly TypeSpec open_type;
 
 		public InflatedTypeSpec (TypeSpec openType, TypeSpec declaringType, TypeSpec[] targs)
 			
 		{
 			if (targs == null)
 				throw new ArgumentNullException ("targs");
 
 //			this.state = openType.state;
 			this.open_type = openType;
 			this.targs = targs;
 
 			foreach (var arg in targs) {
 				if (arg.HasDynamicElement || arg == InternalType.Dynamic) {
 					state |= StateFlags.HasDynamicElement;
 					break;
 				}
 			}
 			foreach (var arg in targs) {
 				if (arg.HasDynamicElement || arg == InternalType.Dynamic) {
 					state |= StateFlags.HasDynamicElement;
 					break;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="1094" endline="1112">
<![CDATA[
 
 		static readonly string [] empty_using_list = new string [0];
 
 		public int SymbolFileID {
 			get {
 				if (symfile_id == 0 && file.SourceFileEntry != null) {
 					int parent_id = parent == null ? 0 
 
 					string [] using_list = empty_using_list;
 					if (using_clauses != null) {
 						using_list = new string [using_clauses.Count];
 						for (int i = 0; i < using_clauses.Count; i++)
 							using_list [i] = ((UsingEntry) using_clauses [i]).MemberName.GetName ();
 						for (int i = 0; i < using_clauses.Count; i++)
 							using_list [i] = ((UsingEntry) using_clauses [i]).MemberName.GetName ();
 					}
 
 					symfile_id = SymbolWriter.DefineNamespace (ns.Name, file.CompileUnitEntry, using_list, parent_id);
 				}
 				return symfile_id;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1597" endline="1622">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Method))
 				{
 					records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
 				}
 				int token = records[i].Association;
 				// do the HasSemantics encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case EventTable.Index
 						token = (token & 0xFFFFFF) << 1 | 0;
 						break;
 					case PropertyTable.Index
 						token = (token & 0xFFFFFF) << 1 | 1;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Association = token;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Method))
 				{
 					records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
 				}
 				int token = records[i].Association;
 				// do the HasSemantics encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case EventTable.Index
 						token = (token & 0xFFFFFF) << 1 | 0;
 						break;
 					case PropertyTable.Index
 						token = (token & 0xFFFFFF) << 1 | 1;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Association = token;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2564" endline="2587">
<![CDATA[
 
 		/// Search for at least one defined condition in ConditionalAttribute of attribute class
 		/// Valid only for attribute classes.
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 
 			if (OptAttributes == null)
 				return null;
 
 			Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 			if (attrs == null)
 				return null;
 
 			string[] conditions = new string[attrs.Length];
 			for (int i = 0; i < conditions.Length; ++i)
 				conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			for (int i = 0; i < conditions.Length; ++i)
 				conditions[i] = attrs[i].GetConditionalAttributeValue ();
 
 			caching_flags |= Flags.Excluded;
 			return conditions;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="202" endline="245">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			Label false_target = ec.DefineLabel ();
 			Label end;
 
 			//
 			// If we're a boolean constant, Resolve() already
 			// eliminated dead code for us.
 			//
 			Constant c = expr as Constant;
 			if (c != null){
 				c.EmitSideEffect (ec);
 
 				if (!c.IsDefaultValue)
 					TrueStatement.Emit (ec);
 				else if (FalseStatement != null)
 					FalseStatement.Emit (ec);
 
 				return;
 			}			
 			
 			expr.EmitBranchable (ec, false_target, false);
 			
 			TrueStatement.Emit (ec);
 
 			if (FalseStatement != null){
 				bool branch_emitted = false;
 				
 				end = ec.DefineLabel ();
 				if (!is_true_ret){
 					ec.Emit (OpCodes.Br, end);
 					branch_emitted = true;
 				}
 
 				ec.MarkLabel (false_target);
 				FalseStatement.Emit (ec);
 
 				if (branch_emitted)
 					ec.MarkLabel (end);
 			} else {
 				ec.MarkLabel (false_target);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="403" endline="441">
<![CDATA[
 		}
 	       
 		/// <summary>
 		///   Resolves an expression and performs semantic analysis on it.
 		/// </summary>
 		///
 		/// <remarks>
 		///   Currently Resolve wraps DoResolve to perform sanity
 		///   checking and assertion checking on what we expect from Resolve.
 		/// </remarks>
 		public Expression Resolve (ResolveContext ec, ResolveFlags flags)
 		{
 			if (eclass != ExprClass.Unresolved)
 				return this;
 			
 			Expression e;
 			try {
 				e = DoResolve (ec);
 
 				if (e == null)
 					return null;
 
 				if ((flags & e.ExprClassToResolveFlags) == 0) {
 					e.Error_UnexpectedKind (ec, flags, loc);
 					return null;
 				}
 
 				if (e.type == null)
 					throw new InternalErrorException ("Expression `{0}' didn't set its type in DoResolve", e.GetType ());
 
 				return e;
 			} catch (Exception ex) {
 				if (loc.IsNull || Report.DebugFlags > 0 || ex is CompletionResult || ec.Report.IsDisabled)
 					throw;
 
 				ec.Report.Error (584, loc, "Internal compiler error
 				return EmptyExpression.Null;	// TODO
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="410" endline="454">
<![CDATA[
 
 		void EmitHoistedFieldsInitialization (ResolveContext rc, EmitContext ec)
 		{
 			//
 			// Initialize all storey reference fields by using local or hoisted variables
 			//
 			if (used_parent_storeys != null) {
 				foreach (StoreyFieldPair sf in used_parent_storeys) {
 					//
 					// Get instance expression of storey field
 					//
 					Expression instace_expr = GetStoreyInstanceExpression (ec);
 					var fs = sf.Field.Spec;
 					if (TypeManager.IsGenericType (instace_expr.Type))
 						fs = MemberCache.GetMember (instace_expr.Type, fs);
 
 					FieldExpr f_set_expr = new FieldExpr (fs, Location);
 					f_set_expr.InstanceExpression = instace_expr;
 
 					SimpleAssign a = new SimpleAssign (f_set_expr, sf.Storey.GetStoreyInstanceExpression (ec));
 					if (a.Resolve (rc) != null)
 						a.EmitStatement (ec);
 				}
 				foreach (StoreyFieldPair sf in used_parent_storeys) {
 					//
 					// Get instance expression of storey field
 					//
 					Expression instace_expr = GetStoreyInstanceExpression (ec);
 					var fs = sf.Field.Spec;
 					if (TypeManager.IsGenericType (instace_expr.Type))
 						fs = MemberCache.GetMember (instace_expr.Type, fs);
 
 					FieldExpr f_set_expr = new FieldExpr (fs, Location);
 					f_set_expr.InstanceExpression = instace_expr;
 
 					SimpleAssign a = new SimpleAssign (f_set_expr, sf.Storey.GetStoreyInstanceExpression (ec));
 					if (a.Resolve (rc) != null)
 						a.EmitStatement (ec);
 				}
 			}
 
 			//
 			// Define hoisted `this' in top-level storey only 
 			//
 			if (OriginalSourceBlock.Explicit.HasCapturedThis && !(Parent is AnonymousMethodStorey)) {
 				AddCapturedThisField (ec);
 				rc.CurrentBlock.AddScopeStatement (new ThisInitializer (hoisted_this));
 			}
 
 			//
 			// Setting currect anonymous method to null blocks any further variable hoisting
 			//
 			AnonymousExpression ae = ec.CurrentAnonymousMethod;
 			ec.CurrentAnonymousMethod = null;
 
 			if (hoisted_params != null) {
 				EmitHoistedParameters (ec, hoisted_params);
 			}
 
 			ec.CurrentAnonymousMethod = ae;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="161" endline="195">
<![CDATA[
 		}
 
 		internal void Bake()
 		{
 			EventTable.Record rec = new EventTable.Record();
 			rec.EventFlags = (short)attributes;
 			rec.Name = typeBuilder.ModuleBuilder.Strings.Add(name);
 			rec.EventType = eventtype;
 			int token = 0x14000000 | typeBuilder.ModuleBuilder.Event.AddRecord(rec);
 
 			if (lazyPseudoToken != 0)
 			{
 				typeBuilder.ModuleBuilder.RegisterTokenFixup(lazyPseudoToken, token);
 			}
 
 			if (addOnMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.AddOn, addOnMethod.MetadataToken, token);
 			}
 			if (removeOnMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.RemoveOn, removeOnMethod.MetadataToken, token);
 			}
 			if (fireMethod != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Fire, fireMethod.MetadataToken, token);
 			}
 			if (otherMethods != null)
 			{
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1454" endline="1510">
<![CDATA[
 
 		//
 		// Creates a host for the anonymous method
 		//
 		AnonymousMethodMethod DoCreateMethodHost (EmitContext ec)
 		{
 			//
 			// Anonymous method body can be converted to
 			//
 			// 1, an instance method in current scope when only `this' is hoisted
 			// 2, a static method in current scope when neither `this' nor any variable is hoisted
 			// 3, an instance method in compiler generated storey when any hoisted variable exists
 			//
 
 			Modifiers modifiers;
 			if (Block.HasCapturedVariable || Block.HasCapturedThis) {
 				storey = FindBestMethodStorey ();
 				modifiers = storey != null ? Modifiers.INTERNAL 
 			} else {
 				if (ec.CurrentAnonymousMethod != null)
 					storey = ec.CurrentAnonymousMethod.Storey;
 
 				modifiers = Modifiers.STATIC | Modifiers.PRIVATE;
 			}
 
 			TypeContainer parent = storey != null ? storey 
 
 			MemberCore mc = ec.MemberContext as MemberCore;
 			string name = CompilerGeneratedClass.MakeName (parent != storey ? block_name 
 				"m", null, unique_id++);
 
 			MemberName member_name;
 			GenericMethod generic_method;
 			if (storey == null && mc.MemberName.TypeArguments != null) {
 				member_name = new MemberName (name, mc.MemberName.TypeArguments.Clone (), Location);
 
 				var hoisted_tparams = ec.CurrentTypeParameters;
 				var type_params = new TypeParameter[hoisted_tparams.Length];
 				for (int i = 0; i < type_params.Length; ++i) {
 					type_params[i] = hoisted_tparams[i].CreateHoistedCopy (null, null);
 				}
 				for (int i = 0; i < type_params.Length; ++i) {
 					type_params[i] = hoisted_tparams[i].CreateHoistedCopy (null, null);
 				}
 
 				generic_method = new GenericMethod (parent.NamespaceEntry, parent, member_name, type_params,
 					new TypeExpression (ReturnType, Location), parameters);
 			} else {
 				member_name = new MemberName (name, Location);
 				generic_method = null;
 			}
 
 			string real_name = String.Format (
 				"{0}~{1}{2}", mc.GetSignatureForError (), GetSignatureForError (),
 				parameters.GetSignatureForError ());
 
 			return new AnonymousMethodMethod (parent,
 				this, storey, generic_method, new TypeExpression (ReturnType, Location), modifiers,
 				real_name, member_name, parameters);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8906" endline="8952">
<![CDATA[
 
 		protected override TypeExpr DoResolveAsTypeStep (IMemberContext ec)
 		{
 			TypeExpr lexpr = left.ResolveAsTypeTerminal (ec, false);
 			if (lexpr == null)
 				return null;
 
 			type = lexpr.Type;
 			eclass = ExprClass.Type;
 
 			var single_spec = spec;
 
 			if (single_spec.IsNullable) {
 				lexpr = new Nullable.NullableType (lexpr, loc);
 				lexpr = lexpr.ResolveAsTypeTerminal (ec, false);
 				if (lexpr != null)
 					type = lexpr.Type;
 
 				single_spec = single_spec.Next;
 			} else if (single_spec.IsPointer) {
 				if (!TypeManager.VerifyUnmanaged (ec.Compiler, type, loc))
 					return null;
 
 				if (!ec.IsUnsafe) {
 					UnsafeError (ec.Compiler.Report, loc);
 				}
 
 				do {
 					type = PointerContainer.MakeType (type);
 					single_spec = single_spec.Next;
 				} while (single_spec != null && single_spec.IsPointer);
 			}
 
 			if (single_spec != null && single_spec.Dimension > 0) {
 				if (TypeManager.IsSpecialType (type)) {
 					ec.Compiler.Report.Error (611, loc, "Array elements cannot be of type `{0}'", type.GetSignatureForError ());
 				} else if (type.IsStatic) {
 					ec.Compiler.Report.SymbolRelatedToPreviousError (type);
 					ec.Compiler.Report.Error (719, loc, "Array elements cannot be of static type `{0}'",
 						type.GetSignatureForError ());
 				} else {
 					MakeArray (single_spec);
 				}
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="318" endline="389">
<![CDATA[
 
 		public override Assembly LoadAssemblyFile (string fileName)
 		{
 			bool? has_extension = null;
 			foreach (var path in paths) {
 				var file = Path.Combine (path, fileName);
 				if (!File.Exists (file)) {
 					if (!has_extension.HasValue)
 						has_extension = fileName.EndsWith (".dll", StringComparison.Ordinal) || fileName.EndsWith (".exe", StringComparison.Ordinal);
 
 					if (has_extension.Value)
 						continue;
 
 					file += ".dll";
 					if (!File.Exists (file))
 						continue;
 				}
 
 				try {
 					using (RawModule module = domain.OpenRawModule (file)) {
 						if (!module.IsManifestModule) {
 							Error_AssemblyIsModule (fileName);
 							return null;
 						}
 
 						//
 						// check whether the assembly can be actually imported without
 						// collision
 						//
 						var an = module.GetAssemblyName ();
 						foreach (var entry in loaded_names) {
 							var loaded_name = entry.Item1;
 							if (an.Name != loaded_name.Name)
 								continue;
 
 							if (an.CodeBase == loaded_name.CodeBase)
 								return null;
 							
 							if (((an.Flags | loaded_name.Flags) & AssemblyNameFlags.PublicKey) == 0) {
 								compiler.Report.SymbolRelatedToPreviousError (entry.Item2);
 								compiler.Report.SymbolRelatedToPreviousError (fileName);
 								compiler.Report.Error (1704,
 									"An assembly with the same name `{0}' has already been imported. Consider removing one of the references or sign the assembly",
 									an.Name);
 								return null;
 							}
 
 							if ((an.Flags & AssemblyNameFlags.PublicKey) == (loaded_name.Flags & AssemblyNameFlags.PublicKey) && an.Version.Equals (loaded_name.Version)) {
 								compiler.Report.SymbolRelatedToPreviousError (entry.Item2);
 								compiler.Report.SymbolRelatedToPreviousError (fileName);
 								compiler.Report.Error (1703,
 									"An assembly with the same identity `{0}' has already been imported. Consider removing one of the references",
 									an.FullName);
 								return null;
 							}
 						}
 						foreach (var entry in loaded_names) {
 							var loaded_name = entry.Item1;
 							if (an.Name != loaded_name.Name)
 								continue;
 
 							if (an.CodeBase == loaded_name.CodeBase)
 								return null;
 							
 							if (((an.Flags | loaded_name.Flags) & AssemblyNameFlags.PublicKey) == 0) {
 								compiler.Report.SymbolRelatedToPreviousError (entry.Item2);
 								compiler.Report.SymbolRelatedToPreviousError (fileName);
 								compiler.Report.Error (1704,
 									"An assembly with the same name `{0}' has already been imported. Consider removing one of the references or sign the assembly",
 									an.Name);
 								return null;
 							}
 
 							if ((an.Flags & AssemblyNameFlags.PublicKey) == (loaded_name.Flags & AssemblyNameFlags.PublicKey) && an.Version.Equals (loaded_name.Version)) {
 								compiler.Report.SymbolRelatedToPreviousError (entry.Item2);
 								compiler.Report.SymbolRelatedToPreviousError (fileName);
 								compiler.Report.Error (1703,
 									"An assembly with the same identity `{0}' has already been imported. Consider removing one of the references",
 									an.FullName);
 								return null;
 							}
 						}
 
 						if (Report.DebugFlags > 0)
 							Console.WriteLine ("Loading assembly `{0}'", fileName);
 
 						loaded_names.Add (Tuple.Create (an, fileName));
 						return domain.LoadAssembly (module);
 					}
 				} catch {
 					Error_FileCorrupted (file);
 					return null;
 			foreach (var path in paths) {
 				var file = Path.Combine (path, fileName);
 				if (!File.Exists (file)) {
 					if (!has_extension.HasValue)
 						has_extension = fileName.EndsWith (".dll", StringComparison.Ordinal) || fileName.EndsWith (".exe", StringComparison.Ordinal);
 
 					if (has_extension.Value)
 						continue;
 
 					file += ".dll";
 					if (!File.Exists (file))
 						continue;
 				}
 
 				try {
 					using (RawModule module = domain.OpenRawModule (file)) {
 						if (!module.IsManifestModule) {
 							Error_AssemblyIsModule (fileName);
 							return null;
 						}
 
 						//
 						// check whether the assembly can be actually imported without
 						// collision
 						//
 						var an = module.GetAssemblyName ();
 						foreach (var entry in loaded_names) {
 							var loaded_name = entry.Item1;
 							if (an.Name != loaded_name.Name)
 								continue;
 
 							if (an.CodeBase == loaded_name.CodeBase)
 								return null;
 							
 							if (((an.Flags | loaded_name.Flags) & AssemblyNameFlags.PublicKey) == 0) {
 								compiler.Report.SymbolRelatedToPreviousError (entry.Item2);
 								compiler.Report.SymbolRelatedToPreviousError (fileName);
 								compiler.Report.Error (1704,
 									"An assembly with the same name `{0}' has already been imported. Consider removing one of the references or sign the assembly",
 									an.Name);
 								return null;
 							}
 
 							if ((an.Flags & AssemblyNameFlags.PublicKey) == (loaded_name.Flags & AssemblyNameFlags.PublicKey) && an.Version.Equals (loaded_name.Version)) {
 								compiler.Report.SymbolRelatedToPreviousError (entry.Item2);
 								compiler.Report.SymbolRelatedToPreviousError (fileName);
 								compiler.Report.Error (1703,
 									"An assembly with the same identity `{0}' has already been imported. Consider removing one of the references",
 									an.FullName);
 								return null;
 							}
 						}
 
 						if (Report.DebugFlags > 0)
 							Console.WriteLine ("Loading assembly `{0}'", fileName);
 
 						loaded_names.Add (Tuple.Create (an, fileName));
 						return domain.LoadAssembly (module);
 					}
 				} catch {
 					Error_FileCorrupted (file);
 					return null;
 				}
 			}
 
 			Error_FileNotFound (fileName);
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7800" endline="7870">
<![CDATA[
 
 		public FullNamedExpression ResolveNamespaceOrType (IMemberContext rc, bool silent)
 		{
 			FullNamedExpression expr_resolved = expr.ResolveAsTypeStep (rc, silent);
 
 			if (expr_resolved == null)
 				return null;
 
 			Namespace ns = expr_resolved as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					if (!silent)
 						ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 				} else if (HasTypeArguments) {
 					retval = new GenericTypeExpr (retval.Type, targs, loc).ResolveAsTypeStep (rc, silent);
 				}
 
 				return retval;
 			}
 
 			TypeExpr tnew_expr = expr_resolved.ResolveAsTypeTerminal (rc, false);
 			if (tnew_expr == null)
 				return null;
 
 			TypeSpec expr_type = tnew_expr.Type;
 			if (TypeManager.IsGenericParameter (expr_type)) {
 				rc.Compiler.Report.Error (704, loc, "A nested type cannot be specified through a type parameter `{0}'",
 					tnew_expr.GetSignatureForError ());
 				return null;
 			}
 
 			TypeSpec nested = null;
 			while (expr_type != null) {
 				nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 				if (nested == null) {
 					if (silent)
 						return null;
 
 					if (expr_type == tnew_expr.Type) {
 						Error_IdentifierNotFound (rc, expr_type, Name);
 						return null;
 					}
 
 					expr_type = tnew_expr.Type;
 					nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 					ErrorIsInaccesible (rc, nested.GetSignatureForError (), loc);
 					break;
 				}
 
 				if (nested.IsAccessible (rc.CurrentType))
 					break;
 
 				// Keep looking after inaccessible candidate
 				expr_type = nested.DeclaringType.BaseType;
 			}
 			while (expr_type != null) {
 				nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 				if (nested == null) {
 					if (silent)
 						return null;
 
 					if (expr_type == tnew_expr.Type) {
 						Error_IdentifierNotFound (rc, expr_type, Name);
 						return null;
 					}
 
 					expr_type = tnew_expr.Type;
 					nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 					ErrorIsInaccesible (rc, nested.GetSignatureForError (), loc);
 					break;
 				}
 
 				if (nested.IsAccessible (rc.CurrentType))
 					break;
 
 				// Keep looking after inaccessible candidate
 				expr_type = nested.DeclaringType.BaseType;
 			}
 			
 			TypeExpr texpr;
 			if (Arity > 0) {
 				if (HasTypeArguments) {
 					texpr = new GenericTypeExpr (nested, targs, loc);
 				} else {
 					texpr = new GenericOpenTypeExpr (nested, loc);
 				}
 			} else {
 				texpr = new TypeExpression (nested, loc);
 			}
 
 			return texpr.ResolveAsTypeStep (rc, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodBody.cs" startline="40" endline="121">
<![CDATA[
 		internal MethodBody(ModuleReader module, int rva, IGenericContext context)
 		{
 			const byte CorILMethod_TinyFormat = 0x02;
 			const byte CorILMethod_FatFormat = 0x03;
 			const byte CorILMethod_MoreSects = 0x08;
 			const byte CorILMethod_InitLocals = 0x10;
 			const byte CorILMethod_Sect_EHTable = 0x01;
 			const byte CorILMethod_Sect_FatFormat = 0x40;
 			const byte CorILMethod_Sect_MoreSects = 0x80;
 
 			List<ExceptionHandlingClause> exceptionClauses = new List<ExceptionHandlingClause>();
 			List<LocalVariableInfo> locals = new List<LocalVariableInfo>();
 			module.SeekRVA(rva);
 			BinaryReader br = new BinaryReader(module.stream);
 			byte b = br.ReadByte();
 			if ((b & 3) == CorILMethod_TinyFormat)
 			{
 				initLocals = true;
 				body = br.ReadBytes(b >> 2);
 			}
 			else if ((b & 3) == CorILMethod_FatFormat)
 			{
 				initLocals = (b & CorILMethod_InitLocals) != 0;
 				short flagsAndSize = (short)(b | (br.ReadByte() << 8));
 				if ((flagsAndSize >> 12) != 3)
 				{
 					throw new BadImageFormatException("Fat format method header size should be 3");
 				}
 				maxStack = br.ReadUInt16();
 				int codeLength = br.ReadInt32();
 				localVarSigTok = br.ReadInt32();
 				body = br.ReadBytes(codeLength);
 				if ((b & CorILMethod_MoreSects) != 0)
 				{
 					module.stream.Position = (module.stream.Position + 3) & ~3;
 					int hdr = br.ReadInt32();
 					if ((hdr & CorILMethod_Sect_MoreSects) != 0 || (hdr & CorILMethod_Sect_EHTable) == 0)
 					{
 						throw new NotImplementedException();
 					}
 					else if ((hdr & CorILMethod_Sect_FatFormat) != 0)
 					{
 						int count = ComputeExceptionCount((hdr >> 8) & 0xFFFFFF, 24);
 						for (int i = 0; i < count; i++)
 						{
 							int flags = br.ReadInt32();
 							int tryOffset = br.ReadInt32();
 							int tryLength = br.ReadInt32();
 							int handlerOffset = br.ReadInt32();
 							int handlerLength = br.ReadInt32();
 							int classTokenOrFilterOffset = br.ReadInt32();
 							exceptionClauses.Add(new ExceptionHandlingClause(module, flags, tryOffset, tryLength, handlerOffset, handlerLength, classTokenOrFilterOffset, context));
 						}
 						for (int i = 0; i < count; i++)
 						{
 							int flags = br.ReadInt32();
 							int tryOffset = br.ReadInt32();
 							int tryLength = br.ReadInt32();
 							int handlerOffset = br.ReadInt32();
 							int handlerLength = br.ReadInt32();
 							int classTokenOrFilterOffset = br.ReadInt32();
 							exceptionClauses.Add(new ExceptionHandlingClause(module, flags, tryOffset, tryLength, handlerOffset, handlerLength, classTokenOrFilterOffset, context));
 						}
 					}
 					else
 					{
 						int count = ComputeExceptionCount((hdr >> 8) & 0xFF, 12);
 						for (int i = 0; i < count; i++)
 						{
 							int flags = br.ReadUInt16();
 							int tryOffset = br.ReadUInt16();
 							int tryLength = br.ReadByte();
 							int handlerOffset = br.ReadUInt16();
 							int handlerLength = br.ReadByte();
 							int classTokenOrFilterOffset = br.ReadInt32();
 							exceptionClauses.Add(new ExceptionHandlingClause(module, flags, tryOffset, tryLength, handlerOffset, handlerLength, classTokenOrFilterOffset, context));
 						}
 						for (int i = 0; i < count; i++)
 						{
 							int flags = br.ReadUInt16();
 							int tryOffset = br.ReadUInt16();
 							int tryLength = br.ReadByte();
 							int handlerOffset = br.ReadUInt16();
 							int handlerLength = br.ReadByte();
 							int classTokenOrFilterOffset = br.ReadInt32();
 							exceptionClauses.Add(new ExceptionHandlingClause(module, flags, tryOffset, tryLength, handlerOffset, handlerLength, classTokenOrFilterOffset, context));
 						}
 					}
 				}
 				if (localVarSigTok != 0)
 				{
 					ByteReader sig = module.ResolveSignature(localVarSigTok);
 					Signature.ReadLocalVarSig(module, sig, context, locals);
 				}
 			}
 			else
 			{
 				throw new BadImageFormatException();
 			}
 			this.exceptionClauses = exceptionClauses.AsReadOnly();
 			this.locals = locals.AsReadOnly();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="402" endline="415">
<![CDATA[
 
 		public virtual ModuleBuilder CreateModuleBuilder ()
 		{
 			if (file_name == null)
 				throw new NotSupportedException ("transient module in static assembly");
 
 			var module_name = Path.GetFileName (file_name);
 
 			// Always initialize module without symbolInfo. We could be framework dependent
 			// but returned ISymbolWriter does not have all what we need therefore some
 			// adaptor will be needed for now we alwayas emit MDB format when generating
 			// debug info
 			return Builder.DefineDynamicModule (module_name, module_name, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="219" endline="240">
<![CDATA[
 
 		// <summary>
 		//   This must be called before parsing/tokenizing any files.
 		// </summary>
 		static public void AddFile (Report r, string name)
 		{
 			string path = Path.GetFullPath (name);
 			int id;
 			if (source_files.TryGetValue (path, out id)){
 				string other_name = source_list [id - 1].Name;
 				if (name.Equals (other_name))
 					r.Warning (2002, 1, "Source file `{0}' specified multiple times", other_name);
 				else
 					r.Warning (2002, 1, "Source filenames `{0}' and `{1}' both refer to the same file
 				return;
 			}
 
 			source_files.Add (path, ++source_count);
 			CompilationUnit unit = new CompilationUnit (name, path, source_count);
 			source_list.Add (unit);
 			compile_units.Add (unit);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="675" endline="697">
<![CDATA[
 
 		public AnonymousScopeEntry GetAnonymousScope (int id)
 		{
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope;
 			lock (this) {
 				if (anonymous_scopes != null) {
 					anonymous_scopes.TryGetValue (id, out scope);
 					return scope;
 				}
 
 				anonymous_scopes = new Dictionary<int, AnonymousScopeEntry> ();
 				reader.BaseStream.Position = ot.AnonymousScopeTableOffset;
 				for (int i = 0; i < ot.AnonymousScopeCount; i++) {
 					scope = new AnonymousScopeEntry (reader);
 					anonymous_scopes.Add (scope.ID, scope);
 				}
 				for (int i = 0; i < ot.AnonymousScopeCount; i++) {
 					scope = new AnonymousScopeEntry (reader);
 					anonymous_scopes.Add (scope.ID, scope);
 				}
 
 				return anonymous_scopes [id];
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3042" endline="3076">
<![CDATA[
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1780" endline="1835">
<![CDATA[
 
 		PreprocessorDirective get_cmd_arg (out string arg)
 		{
 			int c;		
 
 			tokens_seen = false;
 			arg = "";
 
 			var cmd = GetPreprocessorDirective (id_builder, TokenizePreprocessorIdentifier (out c));
 
 			if ((cmd & PreprocessorDirective.CustomArgumentsParsing) != 0)
 				return cmd;
 
 			// skip over white space
 			while (c == '\r' || c == ' ' || c == '\t')
 				c = get_char ();
 			while (c == '\r' || c == ' ' || c == '\t')
 				c = get_char ();
 
 			static_cmd_arg.Length = 0;
 			int has_identifier_argument = (int)(cmd & PreprocessorDirective.RequiresArgument);
 
 			while (c != -1 && c != '\n' && c != '\r') {
 				if (c == '\\' && has_identifier_argument >= 0) {
 					if (has_identifier_argument != 0) {
 						has_identifier_argument = 1;
 
 						int peek = peek_char ();
 						if (peek == 'U' || peek == 'u') {
 							int surrogate;
 							c = EscapeUnicode (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									static_cmd_arg.Append ((char) c);
 								c = surrogate;
 							}
 						}
 					} else {
 						has_identifier_argument = -1;
 					}
 				}
 				static_cmd_arg.Append ((char) c);
 				c = get_char ();
 			}
 			while (c != -1 && c != '\n' && c != '\r') {
 				if (c == '\\' && has_identifier_argument >= 0) {
 					if (has_identifier_argument != 0) {
 						has_identifier_argument = 1;
 
 						int peek = peek_char ();
 						if (peek == 'U' || peek == 'u') {
 							int surrogate;
 							c = EscapeUnicode (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									static_cmd_arg.Append ((char) c);
 								c = surrogate;
 							}
 						}
 					} else {
 						has_identifier_argument = -1;
 					}
 				}
 				static_cmd_arg.Append ((char) c);
 				c = get_char ();
 			}
 
 			if (static_cmd_arg.Length != 0) {
 				arg = static_cmd_arg.ToString ();
 
 				// Eat any trailing whitespaces and single-line comments
 				if (arg.IndexOf ("//") != -1) {
 					arg = arg.Substring (0, arg.IndexOf ("//"));
 				}
 
 				arg = arg.Trim (simple_whitespaces);
 			}
 
 			return cmd;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6066" endline="6155">
<![CDATA[
 
 		bool CheckIndices (ResolveContext ec, ArrayInitializer probe, int idx, bool specified_dims, int child_bounds)
 		{
 			if (initializers != null && bounds == null) {
 				//
 				// We use this to store all the date values in the order in which we
 				// will need to store them in the byte blob later
 				//
 				array_data = new List<Expression> ();
 				bounds = new Dictionary<int, int> ();
 			}
 
 			if (specified_dims) { 
 				Expression a = arguments [idx];
 				a = a.Resolve (ec);
 				if (a == null)
 					return false;
 
 				a = ConvertExpressionToArrayIndex (ec, a);
 				if (a == null)
 					return false;
 
 				arguments[idx] = a;
 
 				if (initializers != null) {
 					Constant c = a as Constant;
 					if (c == null && a is ArrayIndexCast)
 						c = ((ArrayIndexCast) a).Child as Constant;
 
 					if (c == null) {
 						ec.Report.Error (150, a.Location, "A constant value is expected");
 						return false;
 					}
 
 					int value;
 					try {
 						value = System.Convert.ToInt32 (c.GetValue ());
 					} catch {
 						ec.Report.Error (150, a.Location, "A constant value is expected");
 						return false;
 					}
 
 					// TODO
 					if (value != probe.Count) {
 						ec.Report.Error (847, loc, "An array initializer of length `{0}' was expected", value.ToString ());
 						return false;
 					}
 
 					bounds[idx] = value;
 				}
 			}
 
 			if (initializers == null)
 				return true;
 
 			for (int i = 0; i < probe.Count; ++i) {
 				var o = probe [i];
 				if (o is ArrayInitializer) {
 					var sub_probe = o as ArrayInitializer;
 					if (idx + 1 >= dimensions){
 						ec.Report.Error (623, loc, "Array initializers can only be used in a variable or field initializer. Try using a new expression instead");
 						return false;
 					}
 					
 					bool ret = CheckIndices (ec, sub_probe, idx + 1, specified_dims, child_bounds - 1);
 					if (!ret)
 						return false;
 				} else if (child_bounds > 1) {
 					ec.Report.Error (846, o.Location, "A nested array initializer was expected");
 				} else {
 					Expression element = ResolveArrayElement (ec, o);
 					if (element == null)
 						continue;
 
 					// Initializers with the default values can be ignored
 					Constant c = element as Constant;
 					if (c != null) {
 						if (!c.IsDefaultInitializer (array_element_type)) {
 							++const_initializers_count;
 						}
 					} else {
 						only_constant_initializers = false;
 					}
 					
 					array_data.Add (element);
 				}
 			}
 			for (int i = 0; i < probe.Count; ++i) {
 				var o = probe [i];
 				if (o is ArrayInitializer) {
 					var sub_probe = o as ArrayInitializer;
 					if (idx + 1 >= dimensions){
 						ec.Report.Error (623, loc, "Array initializers can only be used in a variable or field initializer. Try using a new expression instead");
 						return false;
 					}
 					
 					bool ret = CheckIndices (ec, sub_probe, idx + 1, specified_dims, child_bounds - 1);
 					if (!ret)
 						return false;
 				} else if (child_bounds > 1) {
 					ec.Report.Error (846, o.Location, "A nested array initializer was expected");
 				} else {
 					Expression element = ResolveArrayElement (ec, o);
 					if (element == null)
 						continue;
 
 					// Initializers with the default values can be ignored
 					Constant c = element as Constant;
 					if (c != null) {
 						if (!c.IsDefaultInitializer (array_element_type)) {
 							++const_initializers_count;
 						}
 					} else {
 						only_constant_initializers = false;
 					}
 					
 					array_data.Add (element);
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="186" endline="280">
<![CDATA[
 
 		void DefineAsyncMethods (CallingConventions cc)
 		{
 			var iasync_result = Module.PredefinedTypes.IAsyncResult;
 			var async_callback = Module.PredefinedTypes.AsyncCallback;
 
 			//
 			// It's ok when async types don't exist, the delegate will have Invoke method only
 			//
 			if (!iasync_result.Define () || !async_callback.Define ())
 				return;
 
 			//
 			// BeginInvoke
 			//
 			ParametersCompiled async_parameters;
 			if (Parameters.Count == 0) {
 				async_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 			} else {
 				var compiled = new Parameter[Parameters.Count];
 				for (int i = 0; i < compiled.Length; ++i) {
 					var p = parameters[i];
 					compiled[i] = new Parameter (new TypeExpression (parameters.Types[i], Location),
 						p.Name,
 						p.ModFlags & (Parameter.Modifier.REF | Parameter.Modifier.OUT),
 						p.OptAttributes == null ? null 
 				}
 				for (int i = 0; i < compiled.Length; ++i) {
 					var p = parameters[i];
 					compiled[i] = new Parameter (new TypeExpression (parameters.Types[i], Location),
 						p.Name,
 						p.ModFlags & (Parameter.Modifier.REF | Parameter.Modifier.OUT),
 						p.OptAttributes == null ? null 
 				}
 
 				async_parameters = new ParametersCompiled (compiled);
 			}
 
 			async_parameters = ParametersCompiled.MergeGenerated (Compiler, async_parameters, false,
 				new Parameter[] {
 					new Parameter (new TypeExpression (async_callback.TypeSpec, Location), "callback", Parameter.Modifier.NONE, null, Location),
 					new Parameter (new TypeExpression (TypeManager.object_type, Location), "object", Parameter.Modifier.NONE, null, Location)
 				},
 				new [] {
 					async_callback.TypeSpec,
 					TypeManager.object_type
 				}
 			);
 
 			BeginInvokeBuilder = new Method (this, null,
 				new TypeExpression (iasync_result.TypeSpec, Location), MethodModifiers,
 				new MemberName ("BeginInvoke"), async_parameters, null);
 			BeginInvokeBuilder.Define ();
 
 			//
 			// EndInvoke is a bit more interesting, all the parameters labeled as
 			// out or ref have to be duplicated here.
 			//
 
 			//
 			// Define parameters, and count out/ref parameters
 			//
 			ParametersCompiled end_parameters;
 			int out_params = 0;
 
 			foreach (Parameter p in Parameters.FixedParameters) {
 				if ((p.ModFlags & Parameter.Modifier.ISBYREF) != 0)
 					++out_params;
 			}
 			foreach (Parameter p in Parameters.FixedParameters) {
 				if ((p.ModFlags & Parameter.Modifier.ISBYREF) != 0)
 					++out_params;
 			}
 
 			if (out_params > 0) {
 				Parameter[] end_params = new Parameter[out_params];
 
 				int param = 0;
 				for (int i = 0; i < Parameters.FixedParameters.Length; ++i) {
 					Parameter p = parameters [i];
 					if ((p.ModFlags & Parameter.Modifier.ISBYREF) == 0)
 						continue;
 
 					end_params [param++] = new Parameter (new TypeExpression (p.Type, Location),
 						p.Name,
 						p.ModFlags & (Parameter.Modifier.REF | Parameter.Modifier.OUT),
 						p.OptAttributes == null ? null 
 				}
 				for (int i = 0; i < Parameters.FixedParameters.Length; ++i) {
 					Parameter p = parameters [i];
 					if ((p.ModFlags & Parameter.Modifier.ISBYREF) == 0)
 						continue;
 
 					end_params [param++] = new Parameter (new TypeExpression (p.Type, Location),
 						p.Name,
 						p.ModFlags & (Parameter.Modifier.REF | Parameter.Modifier.OUT),
 						p.OptAttributes == null ? null 
 				}
 
 				end_parameters = new ParametersCompiled (end_params);
 			} else {
 				end_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 			}
 
 			end_parameters = ParametersCompiled.MergeGenerated (Compiler, end_parameters, false,
 				new Parameter (
 					new TypeExpression (iasync_result.TypeSpec, Location),
 					"result", Parameter.Modifier.NONE, null, Location),
 				iasync_result.TypeSpec);
 
 			//
 			// Create method, define parameters, register parameters with type system
 			//
 			EndInvokeBuilder = new Method (this, null, ReturnType, MethodModifiers, new MemberName ("EndInvoke"), end_parameters, null);
 			EndInvokeBuilder.Define ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="366" endline="445">
<![CDATA[
 
 		TypeExpr CreateSiteType (EmitContext ec, Arguments arguments, int dyn_args_count, bool is_statement)
 		{
 			int default_args = is_statement ? 1 
 			var module = ec.MemberContext.Module;
 
 			bool has_ref_out_argument = false;
 			var targs = new TypeExpression[dyn_args_count + default_args];
 			targs [0] = new TypeExpression (module.PredefinedTypes.CallSite.TypeSpec, loc);
 			for (int i = 0; i < dyn_args_count; ++i) {
 				Argument a = arguments [i];
 				if (a.ArgType == Argument.AType.Out || a.ArgType == Argument.AType.Ref)
 					has_ref_out_argument = true;
 
 				var t = a.Type;
 
 				// Convert any internal type like dynamic or null to object
 				if (t.Kind == MemberKind.InternalCompilerType)
 					t = TypeManager.object_type;
 
 				targs [i + 1] = new TypeExpression (t, loc);
 			}
 			for (int i = 0; i < dyn_args_count; ++i) {
 				Argument a = arguments [i];
 				if (a.ArgType == Argument.AType.Out || a.ArgType == Argument.AType.Ref)
 					has_ref_out_argument = true;
 
 				var t = a.Type;
 
 				// Convert any internal type like dynamic or null to object
 				if (t.Kind == MemberKind.InternalCompilerType)
 					t = TypeManager.object_type;
 
 				targs [i + 1] = new TypeExpression (t, loc);
 			}
 
 			TypeExpr del_type = null;
 			if (!has_ref_out_argument) {
 				string d_name = is_statement ? "Action" 
 
 				TypeExpr te = null;
 				Namespace type_ns = module.GlobalRootNamespace.GetNamespace ("System", true);
 				if (type_ns != null) {
 					te = type_ns.LookupType (module.Compiler, d_name, dyn_args_count + default_args, true, Location.Null);
 				}
 			
 				if (te != null) {
 					if (!is_statement)
 						targs [targs.Length - 1] = new TypeExpression (type, loc);
 
 					del_type = new GenericTypeExpr (te.Type, new TypeArguments (targs), loc);
 				}
 			}
 
 			//
 			// Create custom delegate when no appropriate predefined one is found
 			//
 			if (del_type == null) {
 				TypeSpec rt = is_statement ? TypeManager.void_type 
 				Parameter[] p = new Parameter [dyn_args_count + 1];
 				p[0] = new Parameter (targs [0], "p0", Parameter.Modifier.NONE, null, loc);
 
 				var site = ec.CreateDynamicSite ();
 				int index = site.Types == null ? 0 
 
 				if (site.Mutator != null)
 					rt = site.Mutator.Mutate (rt);
 
 				for (int i = 1; i < dyn_args_count + 1; ++i) {
 					var t = targs[i];
 					if (site.Mutator != null)
 						t.Type = site.Mutator.Mutate (t.Type);
 
 					p[i] = new Parameter (t, "p" + i.ToString ("X"), arguments[i - 1].Modifier, null, loc);
 				}
 				for (int i = 1; i < dyn_args_count + 1; ++i) {
 					var t = targs[i];
 					if (site.Mutator != null)
 						t.Type = site.Mutator.Mutate (t.Type);
 
 					p[i] = new Parameter (t, "p" + i.ToString ("X"), arguments[i - 1].Modifier, null, loc);
 				}
 
 				Delegate d = new Delegate (site.NamespaceEntry, site, new TypeExpression (rt, loc),
 					Modifiers.INTERNAL | Modifiers.COMPILER_GENERATED,
 					new MemberName ("Container" + index.ToString ("X")),
 					new ParametersCompiled (p), null);
 
 				d.CreateType ();
 				d.DefineType ();
 				d.Define ();
 				d.Emit ();
 
 				var inflated = site.AddDelegate (d);
 				del_type = new TypeExpression (inflated, loc);
 			}
 
 			TypeExpr site_type = new GenericTypeExpr (module.PredefinedTypes.CallSiteGeneric.TypeSpec, new TypeArguments (del_type), loc);
 			return site_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="851" endline="874">
<![CDATA[
 
 		public void AddUsingExternalAlias (string alias, Location loc, Report Report)
 		{
 			// TODO
 			bool not_first = using_clauses != null || DeclarationFound;
 			if (using_aliases != null && !not_first) {
 				foreach (UsingAliasEntry uae in using_aliases) {
 					if (uae is LocalUsingAliasEntry) {
 						not_first = true;
 						break;
 					}
 				}
 				foreach (UsingAliasEntry uae in using_aliases) {
 					if (uae is LocalUsingAliasEntry) {
 						not_first = true;
 						break;
 					}
 				}
 			}
 
 			if (not_first)
 				Report.Error (439, loc, "An extern alias declaration must precede all other elements");
 
 			if (alias == "global") {
 				Error_GlobalNamespaceRedefined (loc, Report);
 				return;
 			}
 
 			AddUsingAlias (new UsingAliasEntry (alias, loc));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2249" endline="2290">
<![CDATA[
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			int errors = ec.Compiler.Report.Errors;
 			FullNamedExpression fne = ec.LookupNamespaceOrType (Name, Arity, loc, /*ignore_cs0104=*/ false);
 
 			if (fne != null) {
 				if (fne.Type != null && Arity > 0) {
 					if (HasTypeArguments) {
 						GenericTypeExpr ct = new GenericTypeExpr (fne.Type, targs, loc);
 						return ct.ResolveAsTypeStep (ec, false);
 					}
 
 					return new GenericOpenTypeExpr (fne.Type, loc);
 				}
 
 				//
 				// dynamic namespace is ignored when dynamic is allowed (does not apply to types)
 				//
 				if (!(fne is Namespace))
 					return fne;
 			}
 
 			if (Arity == 0 && Name == "dynamic" && RootContext.Version > LanguageVersion.V_3) {
 				if (!ec.Module.PredefinedAttributes.Dynamic.IsDefined) {
 					ec.Compiler.Report.Error (1980, Location,
 						"Dynamic keyword requires `{0}' to be defined. Are you missing System.Core.dll assembly reference?",
 						ec.Module.PredefinedAttributes.Dynamic.GetSignatureForError ());
 				}
 
 				return new DynamicTypeExpr (loc);
 			}
 
 			if (fne != null)
 				return fne;
 
 			if (silent || errors != ec.Compiler.Report.Errors)
 				return null;
 
 			Error_TypeOrNamespaceNotFound (ec);
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="344" endline="360">
<![CDATA[
 		}
 
 		public override Type[] GetGenericParameterConstraints()
 		{
 			IGenericContext context = (this.DeclaringMethod as IGenericContext) ?? this.DeclaringType;
 			List<Type> list = new List<Type>();
 			int token = this.MetadataToken;
 			// TODO use binary search
 			for (int i = 0; i < module.GenericParamConstraint.records.Length; i++)
 			{
 				if (module.GenericParamConstraint.records[i].Owner == token)
 				{
 					list.Add(module.ResolveType(module.GenericParamConstraint.records[i].Constraint, context));
 				}
 			}
 			for (int i = 0; i < module.GenericParamConstraint.records.Length; i++)
 			{
 				if (module.GenericParamConstraint.records[i].Owner == token)
 				{
 					list.Add(module.ResolveType(module.GenericParamConstraint.records[i].Constraint, context));
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="297" endline="317">
<![CDATA[
 
 		public override Type DeclaringType
 		{
 			get
 			{
 				// note that we cannot use Type.IsNested for this, because that calls DeclaringType
 				if ((this.Attributes & TypeAttributes.VisibilityMask & ~TypeAttributes.Public) == 0)
 				{
 					return null;
 				}
 				// TODO use binary search (if sorted)
 				int token = this.MetadataToken;
 				for (int i = 0; i < module.NestedClass.records.Length; i++)
 				{
 					if (module.NestedClass.records[i].NestedClass == token)
 					{
 						return module.ResolveType(module.NestedClass.records[i].EnclosingClass, null, null);
 					}
 				}
 				for (int i = 0; i < module.NestedClass.records.Length; i++)
 				{
 					if (module.NestedClass.records[i].NestedClass == token)
 					{
 						return module.ResolveType(module.NestedClass.records[i].EnclosingClass, null, null);
 					}
 				}
 				throw new InvalidOperationException();
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6156" endline="6185">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args;
 
 			if (array_data == null) {
 				args = new Arguments (arguments.Count + 1);
 				args.Add (new Argument (new TypeOf (new TypeExpression (array_element_type, loc), loc)));
 				foreach (Expression a in arguments)
 					args.Add (new Argument (a.CreateExpressionTree (ec)));
 				foreach (Expression a in arguments)
 					args.Add (new Argument (a.CreateExpressionTree (ec)));
 
 				return CreateExpressionFactoryCall (ec, "NewArrayBounds", args);
 			}
 
 			if (dimensions > 1) {
 				ec.Report.Error (838, loc, "An expression tree cannot contain a multidimensional array initializer");
 				return null;
 			}
 
 			args = new Arguments (array_data == null ? 1 
 			args.Add (new Argument (new TypeOf (new TypeExpression (array_element_type, loc), loc)));
 			if (array_data != null) {
 				for (int i = 0; i < array_data.Count; ++i) {
 					Expression e = array_data [i];
 					args.Add (new Argument (e.CreateExpressionTree (ec)));
 				}
 				for (int i = 0; i < array_data.Count; ++i) {
 					Expression e = array_data [i];
 					args.Add (new Argument (e.CreateExpressionTree (ec)));
 				}
 			}
 
 			return CreateExpressionFactoryCall (ec, "NewArrayInit", args);
 		}		
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="472" endline="528">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			constructor_method = Delegate.GetConstructor (ec.Compiler, ec.CurrentType, type);
 
 			var invoke_method = Delegate.GetInvokeMethod (ec.Compiler, type);
 
 			Arguments arguments = CreateDelegateMethodArguments (invoke_method.Parameters, invoke_method.Parameters.Types, loc);
 			method_group = method_group.OverloadResolve (ec, ref arguments, this, OverloadResolver.Restrictions.CovariantDelegate);
 			if (method_group == null)
 				return null;
 
 			var delegate_method = method_group.BestCandidate;
 			
 			if (TypeManager.IsNullableType (delegate_method.DeclaringType)) {
 				ec.Report.Error (1728, loc, "Cannot create delegate from method `{0}' because it is a member of System.Nullable<T> type",
 					delegate_method.GetSignatureForError ());
 				return null;
 			}		
 			
 			Invocation.IsSpecialMethodInvocation (ec, delegate_method, loc);
 
 			ExtensionMethodGroupExpr emg = method_group as ExtensionMethodGroupExpr;
 			if (emg != null) {
 				method_group.InstanceExpression = emg.ExtensionExpression;
 				TypeSpec e_type = emg.ExtensionExpression.Type;
 				if (TypeManager.IsValueType (e_type)) {
 					ec.Report.Error (1113, loc, "Extension method `{0}' of value type `{1}' cannot be used to create delegates",
 						delegate_method.GetSignatureForError (), TypeManager.CSharpName (e_type));
 				}
 			}
 
 			TypeSpec rt = delegate_method.ReturnType;
 			Expression ret_expr = new TypeExpression (rt, loc);
 			if (!Delegate.IsTypeCovariant (ret_expr, invoke_method.ReturnType)) {
 				Error_ConversionFailed (ec, delegate_method, ret_expr);
 			}
 
 			if (delegate_method.IsConditionallyExcluded (loc)) {
 				ec.Report.SymbolRelatedToPreviousError (delegate_method);
 				MethodOrOperator m = delegate_method.MemberDefinition as MethodOrOperator;
 				if (m != null && m.IsPartialDefinition) {
 					ec.Report.Error (762, loc, "Cannot create delegate from partial method declaration `{0}'",
 						delegate_method.GetSignatureForError ());
 				} else {
 					ec.Report.Error (1618, loc, "Cannot create delegate with `{0}' because it has a Conditional attribute",
 						TypeManager.CSharpSignature (delegate_method));
 				}
 			}
 
 			var expr = method_group.InstanceExpression;
 			if (expr != null && (expr.Type.IsGenericParameter || !TypeManager.IsReferenceType (expr.Type)))
 				method_group.InstanceExpression = new BoxedCast (expr, TypeManager.object_type);
 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="835" endline="899">
<![CDATA[
 
 		internal void Write (MonoSymbolFile file, MyBinaryWriter bw)
 		{
 			int start = (int) bw.BaseStream.Position;
 
 			bool last_is_hidden = false;
 			int last_line = 1, last_offset = 0, last_file = 1;
 			for (int i = 0; i < LineNumbers.Length; i++) {
 				int line_inc = LineNumbers [i].Row - last_line;
 				int offset_inc = LineNumbers [i].Offset - last_offset;
 
 				if (SuppressDuplicates && (i+1 < LineNumbers.Length)) {
 					if (LineNumbers [i+1].Equals (LineNumbers [i]))
 						continue;
 				}
 
 				if (LineNumbers [i].File != last_file) {
 					bw.Write (DW_LNS_set_file);
 					bw.WriteLeb128 (LineNumbers [i].File);
 					last_file = LineNumbers [i].File;
 				}
 
 				if (LineNumbers [i].IsHidden != last_is_hidden) {
 					bw.Write ((byte) 0);
 					bw.Write ((byte) 1);
 					bw.Write (DW_LNE_MONO_negate_is_hidden);
 					last_is_hidden = LineNumbers [i].IsHidden;
 				}
 
 				if (offset_inc >= MaxAddressIncrement) {
 					if (offset_inc < 2 * MaxAddressIncrement) {
 						bw.Write (DW_LNS_const_add_pc);
 						offset_inc -= MaxAddressIncrement;
 					} else {
 						bw.Write (DW_LNS_advance_pc);
 						bw.WriteLeb128 (offset_inc);
 						offset_inc = 0;
 					}
 				}
 
 				if ((line_inc < LineBase) || (line_inc >= LineBase + LineRange)) {
 					bw.Write (DW_LNS_advance_line);
 					bw.WriteLeb128 (line_inc);
 					if (offset_inc != 0) {
 						bw.Write (DW_LNS_advance_pc);
 						bw.WriteLeb128 (offset_inc);
 					}
 					bw.Write (DW_LNS_copy);
 				} else {
 					byte opcode;
 					opcode = (byte) (line_inc - LineBase + (LineRange * offset_inc) +
 							 OpcodeBase);
 					bw.Write (opcode);
 				}
 
 				last_line = LineNumbers [i].Row;
 				last_offset = LineNumbers [i].Offset;
 			}
 			for (int i = 0; i < LineNumbers.Length; i++) {
 				int line_inc = LineNumbers [i].Row - last_line;
 				int offset_inc = LineNumbers [i].Offset - last_offset;
 
 				if (SuppressDuplicates && (i+1 < LineNumbers.Length)) {
 					if (LineNumbers [i+1].Equals (LineNumbers [i]))
 						continue;
 				}
 
 				if (LineNumbers [i].File != last_file) {
 					bw.Write (DW_LNS_set_file);
 					bw.WriteLeb128 (LineNumbers [i].File);
 					last_file = LineNumbers [i].File;
 				}
 
 				if (LineNumbers [i].IsHidden != last_is_hidden) {
 					bw.Write ((byte) 0);
 					bw.Write ((byte) 1);
 					bw.Write (DW_LNE_MONO_negate_is_hidden);
 					last_is_hidden = LineNumbers [i].IsHidden;
 				}
 
 				if (offset_inc >= MaxAddressIncrement) {
 					if (offset_inc < 2 * MaxAddressIncrement) {
 						bw.Write (DW_LNS_const_add_pc);
 						offset_inc -= MaxAddressIncrement;
 					} else {
 						bw.Write (DW_LNS_advance_pc);
 						bw.WriteLeb128 (offset_inc);
 						offset_inc = 0;
 					}
 				}
 
 				if ((line_inc < LineBase) || (line_inc >= LineBase + LineRange)) {
 					bw.Write (DW_LNS_advance_line);
 					bw.WriteLeb128 (line_inc);
 					if (offset_inc != 0) {
 						bw.Write (DW_LNS_advance_pc);
 						bw.WriteLeb128 (offset_inc);
 					}
 					bw.Write (DW_LNS_copy);
 				} else {
 					byte opcode;
 					opcode = (byte) (line_inc - LineBase + (LineRange * offset_inc) +
 							 OpcodeBase);
 					bw.Write (opcode);
 				}
 
 				last_line = LineNumbers [i].Row;
 				last_offset = LineNumbers [i].Offset;
 			}
 
 			bw.Write ((byte) 0);
 			bw.Write ((byte) 1);
 			bw.Write (DW_LNE_end_sequence);
 
 			file.ExtendedLineNumberSize += (int) bw.BaseStream.Position - start;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="393" endline="468">
<![CDATA[
 
 		/// <summary>
 		///   Verifies that any pending abstract methods or interface methods
 		///   were implemented.
 		/// </summary>
 		public bool VerifyPendingMethods (Report Report)
 		{
 			int top = pending_implementations.Length;
 			bool errors = false;
 			int i;
 			
 			for (i = 0; i < top; i++){
 				TypeSpec type = pending_implementations [i].type;
 
 				bool base_implements_type = type.IsInterface &&
 					container.BaseType != null &&
 					container.BaseType.ImplementsInterface (type, false);
 
 				for (int j = 0; j < pending_implementations [i].methods.Count; ++j) {
 					var mi = pending_implementations[i].methods[j];
 					if (mi == null)
 						continue;
 
 					if (type.IsInterface){
 						var need_proxy =
 							pending_implementations [i].need_proxy [j];
 
 						if (need_proxy != null) {
 							DefineProxy (type, need_proxy, mi);
 							continue;
 						}
 
 						if (pending_implementations [i].optional)
 							continue;
 
 						MethodSpec candidate = null;
 						if (base_implements_type || BaseImplements (type, mi, out candidate))
 							continue;
 
 						if (candidate == null) {
 							MethodData md = pending_implementations [i].found [j];
 							if (md != null)
 								candidate = md.method.Spec;
 						}
 
 						Report.SymbolRelatedToPreviousError (mi);
 						if (candidate != null) {
 							Report.SymbolRelatedToPreviousError (candidate);
 							if (candidate.IsStatic) {
 								Report.Error (736, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' is static",
 									container.GetSignatureForError (), mi.GetSignatureForError (), TypeManager.CSharpSignature (candidate));
 							} else if ((candidate.Modifiers & Modifiers.PUBLIC) == 0) {
 								Report.Error (737, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' in not public",
 									container.GetSignatureForError (), mi.GetSignatureForError (), candidate.GetSignatureForError ());
 							} else {
 								Report.Error (738, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' return type `{3}' does not match interface member return type `{4}'",
 									container.GetSignatureForError (), mi.GetSignatureForError (), TypeManager.CSharpSignature (candidate),
 									TypeManager.CSharpName (candidate.ReturnType), TypeManager.CSharpName (mi.ReturnType));
 							}
 						} else {
 							Report.Error (535, container.Location, "`{0}' does not implement interface member `{1}'",
 								container.GetSignatureForError (), mi.GetSignatureForError ());
 						}
 					} else {
 						Report.SymbolRelatedToPreviousError (mi);
 						Report.Error (534, container.Location, "`{0}' does not implement inherited abstract member `{1}'",
 							container.GetSignatureForError (), mi.GetSignatureForError ());
 					}
 					errors = true;
 				}
 				for (int j = 0; j < pending_implementations [i].methods.Count; ++j) {
 					var mi = pending_implementations[i].methods[j];
 					if (mi == null)
 						continue;
 
 					if (type.IsInterface){
 						var need_proxy =
 							pending_implementations [i].need_proxy [j];
 
 						if (need_proxy != null) {
 							DefineProxy (type, need_proxy, mi);
 							continue;
 						}
 
 						if (pending_implementations [i].optional)
 							continue;
 
 						MethodSpec candidate = null;
 						if (base_implements_type || BaseImplements (type, mi, out candidate))
 							continue;
 
 						if (candidate == null) {
 							MethodData md = pending_implementations [i].found [j];
 							if (md != null)
 								candidate = md.method.Spec;
 						}
 
 						Report.SymbolRelatedToPreviousError (mi);
 						if (candidate != null) {
 							Report.SymbolRelatedToPreviousError (candidate);
 							if (candidate.IsStatic) {
 								Report.Error (736, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' is static",
 									container.GetSignatureForError (), mi.GetSignatureForError (), TypeManager.CSharpSignature (candidate));
 							} else if ((candidate.Modifiers & Modifiers.PUBLIC) == 0) {
 								Report.Error (737, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' in not public",
 									container.GetSignatureForError (), mi.GetSignatureForError (), candidate.GetSignatureForError ());
 							} else {
 								Report.Error (738, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' return type `{3}' does not match interface member return type `{4}'",
 									container.GetSignatureForError (), mi.GetSignatureForError (), TypeManager.CSharpSignature (candidate),
 									TypeManager.CSharpName (candidate.ReturnType), TypeManager.CSharpName (mi.ReturnType));
 							}
 						} else {
 							Report.Error (535, container.Location, "`{0}' does not implement interface member `{1}'",
 								container.GetSignatureForError (), mi.GetSignatureForError ());
 						}
 					} else {
 						Report.SymbolRelatedToPreviousError (mi);
 						Report.Error (534, container.Location, "`{0}' does not implement inherited abstract member `{1}'",
 							container.GetSignatureForError (), mi.GetSignatureForError ());
 					}
 					errors = true;
 				}
 			}
 			for (i = 0; i < top; i++){
 				TypeSpec type = pending_implementations [i].type;
 
 				bool base_implements_type = type.IsInterface &&
 					container.BaseType != null &&
 					container.BaseType.ImplementsInterface (type, false);
 
 				for (int j = 0; j < pending_implementations [i].methods.Count; ++j) {
 					var mi = pending_implementations[i].methods[j];
 					if (mi == null)
 						continue;
 
 					if (type.IsInterface){
 						var need_proxy =
 							pending_implementations [i].need_proxy [j];
 
 						if (need_proxy != null) {
 							DefineProxy (type, need_proxy, mi);
 							continue;
 						}
 
 						if (pending_implementations [i].optional)
 							continue;
 
 						MethodSpec candidate = null;
 						if (base_implements_type || BaseImplements (type, mi, out candidate))
 							continue;
 
 						if (candidate == null) {
 							MethodData md = pending_implementations [i].found [j];
 							if (md != null)
 								candidate = md.method.Spec;
 						}
 
 						Report.SymbolRelatedToPreviousError (mi);
 						if (candidate != null) {
 							Report.SymbolRelatedToPreviousError (candidate);
 							if (candidate.IsStatic) {
 								Report.Error (736, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' is static",
 									container.GetSignatureForError (), mi.GetSignatureForError (), TypeManager.CSharpSignature (candidate));
 							} else if ((candidate.Modifiers & Modifiers.PUBLIC) == 0) {
 								Report.Error (737, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' in not public",
 									container.GetSignatureForError (), mi.GetSignatureForError (), candidate.GetSignatureForError ());
 							} else {
 								Report.Error (738, container.Location,
 									"`{0}' does not implement interface member `{1}' and the best implementing candidate `{2}' return type `{3}' does not match interface member return type `{4}'",
 									container.GetSignatureForError (), mi.GetSignatureForError (), TypeManager.CSharpSignature (candidate),
 									TypeManager.CSharpName (candidate.ReturnType), TypeManager.CSharpName (mi.ReturnType));
 							}
 						} else {
 							Report.Error (535, container.Location, "`{0}' does not implement interface member `{1}'",
 								container.GetSignatureForError (), mi.GetSignatureForError ());
 						}
 					} else {
 						Report.SymbolRelatedToPreviousError (mi);
 						Report.Error (534, container.Location, "`{0}' does not implement inherited abstract member `{1}'",
 							container.GetSignatureForError (), mi.GetSignatureForError ());
 					}
 					errors = true;
 				}
 			}
 			return errors;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="447" endline="537">
<![CDATA[
 
 		protected virtual bool ResolveNamedArguments (ResolveContext ec)
 		{
 			int named_arg_count = NamedArguments.Count;
 			var seen_names = new List<string> (named_arg_count);
 
 			named_values = new List<KeyValuePair<MemberExpr, NamedArgument>> (named_arg_count);
 			
 			foreach (NamedArgument a in NamedArguments) {
 				string name = a.Name;
 				if (seen_names.Contains (name)) {
 					ec.Report.Error (643, a.Location, "Duplicate named attribute `{0}' argument", name);
 					continue;
 				}			
 	
 				seen_names.Add (name);
 
 				a.Resolve (ec);
 
 				Expression member = Expression.MemberLookup (ec, ec.CurrentType, Type, name, 0, MemberLookupRestrictions.ExactArity, loc);
 
 				if (member == null) {
 					member = Expression.MemberLookup (null, ec.CurrentType, Type, name, 0, MemberLookupRestrictions.ExactArity, loc);
 
 					if (member != null) {
 						// TODO
 						Expression.ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						return false;
 					}
 				}
 
 				if (member == null){
 					Expression.Error_TypeDoesNotContainDefinition (ec, Location, Type, name);
 					return false;
 				}
 				
 				if (!(member is PropertyExpr || member is FieldExpr)) {
 					Error_InvalidNamedArgument (ec, a);
 					return false;
 				}
 
 				ObsoleteAttribute obsolete_attr;
 
 				if (member is PropertyExpr) {
 					var pi = ((PropertyExpr) member).PropertyInfo;
 
 					if (!pi.HasSet || !pi.HasGet || pi.IsStatic || !pi.Get.IsPublic || !pi.Set.IsPublic) {
 						ec.Report.SymbolRelatedToPreviousError (pi);
 						Error_InvalidNamedArgument (ec, a);
 						return false;
 					}
 
 					if (!IsValidArgumentType (member.Type)) {
 						ec.Report.SymbolRelatedToPreviousError (pi);
 						Error_InvalidNamedArgumentType (ec, a);
 						return false;
 					}
 
 					obsolete_attr = pi.GetAttributeObsolete ();
 					pi.MemberDefinition.SetIsAssigned ();
 				} else {
 					var fi = ((FieldExpr) member).Spec;
 
 					if (fi.IsReadOnly || fi.IsStatic || !fi.IsPublic) {
 						Error_InvalidNamedArgument (ec, a);
 						return false;
 					}
 
 					if (!IsValidArgumentType (member.Type)) {
 						ec.Report.SymbolRelatedToPreviousError (fi);
 						Error_InvalidNamedArgumentType (ec, a);
 						return false;
 					}
 
 					obsolete_attr = fi.GetAttributeObsolete ();
 					fi.MemberDefinition.SetIsAssigned ();
 				}
 
 				if (obsolete_attr != null && !context.IsObsolete)
 					AttributeTester.Report_ObsoleteMessage (obsolete_attr, member.GetSignatureForError (), member.Location, Report);
 
 				if (a.Type != member.Type) {
 					a.Expr = Convert.ImplicitConversionRequired (ec, a.Expr, member.Type, a.Expr.Location);
 				}
 
 				if (a.Expr != null)
 					named_values.Add (new KeyValuePair<MemberExpr, NamedArgument> ((MemberExpr) member, a));
 			}
 			foreach (NamedArgument a in NamedArguments) {
 				string name = a.Name;
 				if (seen_names.Contains (name)) {
 					ec.Report.Error (643, a.Location, "Duplicate named attribute `{0}' argument", name);
 					continue;
 				}			
 	
 				seen_names.Add (name);
 
 				a.Resolve (ec);
 
 				Expression member = Expression.MemberLookup (ec, ec.CurrentType, Type, name, 0, MemberLookupRestrictions.ExactArity, loc);
 
 				if (member == null) {
 					member = Expression.MemberLookup (null, ec.CurrentType, Type, name, 0, MemberLookupRestrictions.ExactArity, loc);
 
 					if (member != null) {
 						// TODO
 						Expression.ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						return false;
 					}
 				}
 
 				if (member == null){
 					Expression.Error_TypeDoesNotContainDefinition (ec, Location, Type, name);
 					return false;
 				}
 				
 				if (!(member is PropertyExpr || member is FieldExpr)) {
 					Error_InvalidNamedArgument (ec, a);
 					return false;
 				}
 
 				ObsoleteAttribute obsolete_attr;
 
 				if (member is PropertyExpr) {
 					var pi = ((PropertyExpr) member).PropertyInfo;
 
 					if (!pi.HasSet || !pi.HasGet || pi.IsStatic || !pi.Get.IsPublic || !pi.Set.IsPublic) {
 						ec.Report.SymbolRelatedToPreviousError (pi);
 						Error_InvalidNamedArgument (ec, a);
 						return false;
 					}
 
 					if (!IsValidArgumentType (member.Type)) {
 						ec.Report.SymbolRelatedToPreviousError (pi);
 						Error_InvalidNamedArgumentType (ec, a);
 						return false;
 					}
 
 					obsolete_attr = pi.GetAttributeObsolete ();
 					pi.MemberDefinition.SetIsAssigned ();
 				} else {
 					var fi = ((FieldExpr) member).Spec;
 
 					if (fi.IsReadOnly || fi.IsStatic || !fi.IsPublic) {
 						Error_InvalidNamedArgument (ec, a);
 						return false;
 					}
 
 					if (!IsValidArgumentType (member.Type)) {
 						ec.Report.SymbolRelatedToPreviousError (fi);
 						Error_InvalidNamedArgumentType (ec, a);
 						return false;
 					}
 
 					obsolete_attr = fi.GetAttributeObsolete ();
 					fi.MemberDefinition.SetIsAssigned ();
 				}
 
 				if (obsolete_attr != null && !context.IsObsolete)
 					AttributeTester.Report_ObsoleteMessage (obsolete_attr, member.GetSignatureForError (), member.Location, Report);
 
 				if (a.Type != member.Type) {
 					a.Expr = Convert.ImplicitConversionRequired (ec, a.Expr, member.Type, a.Expr.Location);
 				}
 
 				if (a.Expr != null)
 					named_values.Add (new KeyValuePair<MemberExpr, NamedArgument> ((MemberExpr) member, a));
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="715" endline="723">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteEncodedTypeDefOrRef(records[i].Interface);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteEncodedTypeDefOrRef(records[i].Interface);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1113" endline="1121">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasFieldMarshal(records[i].Parent);
 				mw.WriteBlobIndex(records[i].NativeType);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasFieldMarshal(records[i].Parent);
 				mw.WriteBlobIndex(records[i].NativeType);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1323" endline="1331">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.WriteField(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.WriteField(records[i].Field);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1412" endline="1420">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteEvent(records[i].EventList);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteEvent(records[i].EventList);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1490" endline="1498">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteProperty(records[i].PropertyList);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Parent);
 				mw.WriteProperty(records[i].PropertyList);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1894" endline="1902">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].RVA);
 				mw.WriteField(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].RVA);
 				mw.WriteField(records[i].Field);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2238" endline="2246">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].NestedClass);
 				mw.WriteTypeDef(records[i].EnclosingClass);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].NestedClass);
 				mw.WriteTypeDef(records[i].EnclosingClass);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2402" endline="2410">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMethodDefOrRef(records[i].Method);
 				mw.WriteBlobIndex(records[i].Instantiation);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMethodDefOrRef(records[i].Method);
 				mw.WriteBlobIndex(records[i].Instantiation);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2463" endline="2471">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteGenericParam(records[i].Owner);
 				mw.WriteTypeDefOrRef(records[i].Constraint);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteGenericParam(records[i].Owner);
 				mw.WriteTypeDefOrRef(records[i].Constraint);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="47" endline="58">
<![CDATA[
 
 		public override Type BaseType
 		{
 			get
 			{
 				int extends = module.TypeDef.records[index].Extends;
 				if ((extends & 0xFFFFFF) == 0)
 				{
 					return null;
 				}
 				return module.ResolveType(extends, this);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="822" endline="832">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Class))
 				{
 					records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Class))
 				{
 					records[i].Class = moduleBuilder.ResolvePseudoToken(records[i].Class);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2432" endline="2442">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Method))
 				{
 					records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].Method))
 				{
 					records[i].Method = moduleBuilder.ResolvePseudoToken(records[i].Method);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="325" endline="341">
<![CDATA[
 
 		public override string ResolveString(int metadataToken)
 		{
 			string str;
 			if (!strings.TryGetValue(metadataToken, out str))
 			{
 				if ((metadataToken >> 24) != 0x70)
 				{
 					throw new ArgumentOutOfRangeException();
 				}
 				int index = metadataToken & 0xFFFFFF;
 				int len = ReadCompressedInt(userStringHeap, ref index) & ~1;
 				str = Encoding.Unicode.GetString(userStringHeap, index, len);
 				strings.Add(metadataToken, str);
 			}
 			return str;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4918" endline="4931">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			TryCatch target = (TryCatch) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 			if (General != null)
 				target.General = (Catch) General.Clone (clonectx);
 			if (Specific != null){
 				target.Specific = new List<Catch> ();
 				foreach (Catch c in Specific)
 					target.Specific.Add ((Catch) c.Clone (clonectx));
 				foreach (Catch c in Specific)
 					target.Specific.Add ((Catch) c.Clone (clonectx));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8050" endline="8079">
<![CDATA[
 
 		//
 		// We perform some simple tests, and then to "split" the emit and store
 		// code we create an instance of a different class, and return that.
 		//
 		Expression CreateAccessExpression (ResolveContext ec)
 		{
 			if (type.IsArray)
 				return (new ArrayAccess (this, loc));
 
 			if (type.IsPointer)
 				return MakePointerAccess (ec, type);
 
 			FieldExpr fe = Expr as FieldExpr;
 			if (fe != null) {
 				var ff = fe.Spec as FixedFieldSpec;
 				if (ff != null) {
 					return MakePointerAccess (ec, ff.ElementType);
 				}
 			}
 
 			var indexers = MemberCache.FindMembers (type, MemberCache.IndexerNameAlias, false);
 			if (indexers != null || type == InternalType.Dynamic) {
 				return new IndexerExpr (indexers, type, this);
 			}
 
 			ec.Report.Error (21, loc, "Cannot apply indexing with [] to an expression of type `{0}'",
 				type.GetSignatureForError ());
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="979" endline="1018">
<![CDATA[
 
 		protected override Expression ResolveUserOperator (ResolveContext ec, Expression left, Expression right)
 		{
 			//
 			// Try original types first for exact match without unwrapping
 			//
 			Expression expr = base.ResolveUserOperator (ec, left_orig, right_orig);
 			if (expr != null)
 				return expr;
 
 			State orig_state = state;
 
 			//
 			// One side is a nullable type, try to match underlying types
 			//
 			if (left_unwrap != null || right_unwrap != null || (state & (State.RightNullLifted | State.LeftNullLifted)) != 0) {
 				expr = base.ResolveUserOperator (ec, left, right);
 			}
 
 			if (expr == null)
 				return null;
 
 			//
 			// Lift the result in the case it can be null and predefined or user operator
 			// result type is of a value type
 			//
 			if (!TypeManager.IsValueType (expr.Type))
 				return null;
 
 			if (state != orig_state)
 				return expr;
 
 			expr = LiftResult (ec, expr);
 			if (expr is Constant)
 				return expr;
 
 			type = expr.Type;
 			user_operator = expr;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="301" endline="344">
<![CDATA[
 
 		public MethodBase GetMetaInfo ()
 		{
 			//
 			// inflatedMetaInfo is extra field needed for cases where we
 			// inflate method but another nested type can later inflate
 			// again (the cache would be build with inflated metaInfo) and
 			// TypeBuilder can work with method definitions only
 			//
 			if (inflatedMetaInfo == null) {
 				if ((state & StateFlags.PendingMetaInflate) != 0) {
 					var dt_meta = DeclaringType.GetMetaInfo ();
 
 					if (DeclaringType.IsTypeBuilder) {
 						if (IsConstructor)
 							inflatedMetaInfo = TypeBuilder.GetConstructor (dt_meta, (ConstructorInfo) metaInfo);
 						else
 							inflatedMetaInfo = TypeBuilder.GetMethod (dt_meta, (MethodInfo) metaInfo);
 					} else {
 #if STATIC
 						// it should not be reached
 						throw new NotImplementedException ();
 #else
 						inflatedMetaInfo = MethodInfo.GetMethodFromHandle (metaInfo.MethodHandle, dt_meta.TypeHandle);
 #endif
 					}
 
 					state &= ~StateFlags.PendingMetaInflate;
 				} else {
 					inflatedMetaInfo = metaInfo;
 				}
 			}
 
 			if ((state & StateFlags.PendingMakeMethod) != 0) {
 				var sre_targs = new MetaType[targs.Length];
 				for (int i = 0; i < sre_targs.Length; ++i)
 					sre_targs[i] = targs[i].GetMetaInfo ();
 				for (int i = 0; i < sre_targs.Length; ++i)
 					sre_targs[i] = targs[i].GetMetaInfo ();
 
 				inflatedMetaInfo = ((MethodInfo) inflatedMetaInfo).MakeGenericMethod (sre_targs);
 				state &= ~StateFlags.PendingMakeMethod;
 			}
 
 			return inflatedMetaInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Field.cs" startline="113" endline="140">
<![CDATA[
 
 		internal override IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
 		{
 			List<CustomAttributeData> list = module.GetCustomAttributes(this.MetadataToken, attributeType);
 			if ((this.Attributes & FieldAttributes.HasFieldMarshal) != 0
 				&& (attributeType == null || attributeType.IsAssignableFrom(module.universe.System_Runtime_InteropServices_MarshalAsAttribute)))
 			{
 				list.Add(MarshalSpec.GetMarshalAsAttribute(module, this.MetadataToken));
 			}
 			if (declaringType.IsExplicitLayout
 				&& (attributeType == null || attributeType.IsAssignableFrom(module.universe.System_Runtime_InteropServices_FieldOffsetAttribute)))
 			{
 				int rid = index + 1;
 				// TODO use binary search?
 				for (int i = 0; i < module.FieldLayout.records.Length; i++)
 				{
 					if (module.FieldLayout.records[i].Field == rid)
 					{
 						ConstructorInfo constructor = module.universe.System_Runtime_InteropServices_FieldOffsetAttribute.GetConstructor(new Type[] { module.universe.System_Int32 });
 						list.Add(new CustomAttributeData(constructor,
 							new object[] { module.FieldLayout.records[i].Offset },
 							null));
 						break;
 					}
 				}
 				for (int i = 0; i < module.FieldLayout.records.Length; i++)
 				{
 					if (module.FieldLayout.records[i].Field == rid)
 					{
 						ConstructorInfo constructor = module.universe.System_Runtime_InteropServices_FieldOffsetAttribute.GetConstructor(new Type[] { module.universe.System_Int32 });
 						list.Add(new CustomAttributeData(constructor,
 							new object[] { module.FieldLayout.records[i].Offset },
 							null));
 						break;
 					}
 				}
 			}
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1057" endline="1105">
<![CDATA[
 
 		public override bool Define()
 		{
 			var mod_flags_src = ModFlags;
 
 			if (!base.Define ())
 				return false;
 
 			if (declarators != null) {
 				if ((mod_flags_src & Modifiers.DEFAULT_ACCESS_MODIFER) != 0)
 					mod_flags_src &= ~(Modifiers.AccessibilityMask | Modifiers.DEFAULT_ACCESS_MODIFER);
 
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Events.IndexOf (this);
 				foreach (var d in declarators) {
 					var ef = new EventField (Parent, t, mod_flags_src, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 
 					if (d.Initializer != null)
 						ef.initializer = d.Initializer;
 
 					Parent.PartialContainer.Events.Insert (++index, ef);
 				}
 				foreach (var d in declarators) {
 					var ef = new EventField (Parent, t, mod_flags_src, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 
 					if (d.Initializer != null)
 						ef.initializer = d.Initializer;
 
 					Parent.PartialContainer.Events.Insert (++index, ef);
 				}
 			}
 
 			if (!HasBackingField) {
 				SetIsUsed ();
 				return true;
 			}
 
 			if (Add.IsInterfaceImplementation)
 				SetIsUsed ();
 
 			backing_field = new Field (Parent,
 				new TypeExpression (MemberType, Location),
 				Modifiers.BACKING_FIELD | Modifiers.COMPILER_GENERATED | Modifiers.PRIVATE | (ModFlags & (Modifiers.STATIC | Modifiers.UNSAFE)),
 				MemberName, null);
 
 			Parent.PartialContainer.AddField (backing_field);
 			backing_field.Initializer = Initializer;
 			backing_field.ModFlags &= ~Modifiers.COMPILER_GENERATED;
 
 			// Call define because we passed fields definition
 			backing_field.Define ();
 
 			// Set backing field for event fields
 			spec.BackingField = backing_field.Spec;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="576" endline="617">
<![CDATA[
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			MetaType[] required_modifier = null;
 			if ((ModFlags & Modifiers.VOLATILE) != 0) {
 				var mod = Module.PredefinedTypes.IsVolatile.Resolve (Location);
 				if (mod != null)
 					required_modifier = new MetaType[] { mod.GetMetaInfo () };
 			}
 
 			FieldBuilder = Parent.TypeBuilder.DefineField (
 				Name, member_type.GetMetaInfo (), required_modifier, null, ModifiersExtensions.FieldAttr (ModFlags));
 
 			spec = new FieldSpec (Parent.Definition, this, MemberType, FieldBuilder, ModFlags);
 
 			// Don't cache inaccessible fields
 			if ((ModFlags & Modifiers.BACKING_FIELD) == 0) {
 				Parent.MemberCache.AddMember (spec);
 			}
 
 			if (initializer != null) {
 				((TypeContainer) Parent).RegisterFieldForInitialization (this,
 					new FieldInitializer (spec, initializer, this));
 			}
 
 			if (declarators != null) {
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Fields.IndexOf (this);
 				foreach (var d in declarators) {
 					var f = new Field (Parent, t, ModFlags, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					if (d.Initializer != null)
 						f.initializer = d.Initializer;
 
 					Parent.PartialContainer.Fields.Insert (++index, f);
 				}
 				foreach (var d in declarators) {
 					var f = new Field (Parent, t, ModFlags, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					if (d.Initializer != null)
 						f.initializer = d.Initializer;
 
 					Parent.PartialContainer.Fields.Insert (++index, f);
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="873" endline="926">
<![CDATA[
 
 		internal int WriteBody(bool initLocals)
 		{
 			if (moduleBuilder.symbolWriter != null)
 			{
 				Debug.Assert(scope != null && scope.parent == null);
 				scope.endOffset = code.Position;
 			}
 
 			ResolveBranches();
 
 			ByteBuffer bb = moduleBuilder.methodBodies;
 
 			int localVarSigTok = 0;
 
 			int rva;
 			if (locals.Count == 0 && exceptions.Count == 0 && maxStack <= 8 && code.Length < 64)
 			{
 				rva = WriteTinyHeaderAndCode(bb);
 			}
 			else
 			{
 				rva = WriteFatHeaderAndCode(bb, ref localVarSigTok, initLocals);
 			}
 
 			if (moduleBuilder.symbolWriter != null)
 			{
 				if (sequencePoints.Count != 0)
 				{
 					ISymbolDocumentWriter document = sequencePoints[0].document;
 					int[] offsets = new int[sequencePoints.Count];
 					int[] lines = new int[sequencePoints.Count];
 					int[] columns = new int[sequencePoints.Count];
 					int[] endLines = new int[sequencePoints.Count];
 					int[] endColumns = new int[sequencePoints.Count];
 					for (int i = 0; i < sequencePoints.Count; i++)
 					{
 						if (sequencePoints[i].document != document)
 						{
 							throw new NotImplementedException();
 						}
 						offsets[i] = sequencePoints[i].offset;
 						lines[i] = sequencePoints[i].startLine;
 						columns[i] = sequencePoints[i].startColumn;
 						endLines[i] = sequencePoints[i].endLine;
 						endColumns[i] = sequencePoints[i].endColumn;
 					}
 					for (int i = 0; i < sequencePoints.Count; i++)
 					{
 						if (sequencePoints[i].document != document)
 						{
 							throw new NotImplementedException();
 						}
 						offsets[i] = sequencePoints[i].offset;
 						lines[i] = sequencePoints[i].startLine;
 						columns[i] = sequencePoints[i].startColumn;
 						endLines[i] = sequencePoints[i].endLine;
 						endColumns[i] = sequencePoints[i].endColumn;
 					}
 					moduleBuilder.symbolWriter.DefineSequencePoints(document, offsets, lines, columns, endLines, endColumns);
 				}
 
 				WriteScope(scope, localVarSigTok);
 			}
 			return rva;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="720" endline="779">
<![CDATA[
 		}
 		#endregion
 
 		protected override bool DoResolve (BlockContext ec)
 		{
 			if (Expr == null) {
 				if (ec.ReturnType == TypeManager.void_type)
 					return true;
 
 				if (ec.CurrentIterator != null) {
 					Error_ReturnFromIterator (ec);
 				} else {
 					ec.Report.Error (126, loc,
 						"An object of a type convertible to `{0}' is required for the return statement",
 						ec.ReturnType.GetSignatureForError ());
 				}
 
 				return false;
 			}
 
 			Expr = Expr.Resolve (ec);
 
 			AnonymousExpression am = ec.CurrentAnonymousMethod;
 			if (am == null) {
 				if (ec.ReturnType == TypeManager.void_type) {
 					ec.Report.Error (127, loc,
 						"`{0}'
 						ec.GetSignatureForError ());
 				}
 			} else {
 				if (am.IsIterator) {
 					Error_ReturnFromIterator (ec);
 					return false;
 				}
 
 				var l = am as AnonymousMethodBody;
 				if (l != null && l.ReturnTypeInference != null && Expr != null) {
 					l.ReturnTypeInference.AddCommonTypeBound (Expr.Type);
 					return true;
 				}
 			}
 
 			if (Expr == null)
 				return false;
 
 			if (Expr.Type != ec.ReturnType) {
 				Expr = Convert.ImplicitConversionRequired (ec, Expr, ec.ReturnType, loc);
 
 				if (Expr == null) {
 					if (am != null) {
 						ec.Report.Error (1662, loc,
 							"Cannot convert `{0}' to delegate type `{1}' because some of the return types in the block are not implicitly convertible to the delegate return type",
 							am.ContainerType, am.GetSignatureForError ());
 					}
 					return false;
 				}
 			}
 
 			return true;			
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1544" endline="1618">
<![CDATA[
 
 		protected override void InitializeMemberCache (bool onlyTypes)
 		{
 			if (cache == null)
 				cache = new MemberCache (onlyTypes ? open_type.MemberCacheTypes 
 
 			var inflator = CreateLocalInflator ();
 
 			//
 			// Two stage inflate due to possible nested types recursive
 			// references
 			//
 			// class A<T> {
 			//    B b;
 			//    class B {
 			//      T Value;
 			//    }
 			// }
 			//
 			// When resolving type of `b' members of `B' cannot be 
 			// inflated because are not yet available in membercache
 			//
 			if ((state & StateFlags.PendingMemberCacheMembers) == 0) {
 				open_type.MemberCacheTypes.InflateTypes (cache, inflator);
 
 				//
 				// Inflate any implemented interfaces
 				//
 				if (open_type.Interfaces != null) {
 					ifaces = new List<TypeSpec> (open_type.Interfaces.Count);
 					foreach (var iface in open_type.Interfaces) {
 						var iface_inflated = inflator.Inflate (iface);
 						AddInterface (iface_inflated);
 					}
 					foreach (var iface in open_type.Interfaces) {
 						var iface_inflated = inflator.Inflate (iface);
 						AddInterface (iface_inflated);
 					}
 				}
 
 				//
 				// Handles the tricky case of recursive nested base generic type
 				//
 				// class A<T> 
 				//    class Nested {}
 				// }
 				//
 				// When inflating A<T>. base type is not yet known, secondary
 				// inflation is required (not common case) once base scope
 				// is known
 				//
 				if (open_type.BaseType == null) {
 					if (IsClass)
 						state |= StateFlags.PendingBaseTypeInflate;
 				} else {
 					BaseType = inflator.Inflate (open_type.BaseType);
 				}
 			} else if ((state & StateFlags.PendingBaseTypeInflate) != 0) {
 				BaseType = inflator.Inflate (open_type.BaseType);
 				state &= ~StateFlags.PendingBaseTypeInflate;
 			}
 
 			if (onlyTypes) {
 				state |= StateFlags.PendingMemberCacheMembers;
 				return;
 			}
 
 			var tc = open_type.MemberDefinition as TypeContainer;
 			if (tc != null && !tc.HasMembersDefined)
 				throw new InternalErrorException ("Inflating MemberCache with undefined members");
 
 			if ((state & StateFlags.PendingBaseTypeInflate) != 0) {
 				BaseType = inflator.Inflate (open_type.BaseType);
 				state &= ~StateFlags.PendingBaseTypeInflate;
 			}
 
 			state &= ~StateFlags.PendingMemberCacheMembers;
 			open_type.MemberCache.InflateMembers (cache, open_type, inflator);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="345" endline="381">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			string name;
 			if (IsConstructor) {
 				name = DeclaringType.GetSignatureForError () + "." + DeclaringType.Name;
 			} else if (Kind == MemberKind.Operator) {
 				var op = Operator.GetType (Name).Value;
 				if (op == Operator.OpType.Implicit || op == Operator.OpType.Explicit) {
 					name = DeclaringType.GetSignatureForError () + "." + Operator.GetName (op) + " operator " + returnType.GetSignatureForError ();
 				} else {
 					name = DeclaringType.GetSignatureForError () + ".operator " + Operator.GetName (op);
 				}
 			} else if (IsAccessor) {
 				int split = Name.IndexOf ('_');
 				name = Name.Substring (split + 1);
 				var postfix = Name.Substring (0, split);
 				if (split == 3) {
 					var pc = parameters.Count;
 					if (pc > 0 && postfix == "get") {
 						name = "this" + parameters.GetSignatureForError ("[", "]", pc);
 					} else if (pc > 1 && postfix == "set") {
 						name = "this" + parameters.GetSignatureForError ("[", "]", pc - 1);
 					}
 				}
 
 				return DeclaringType.GetSignatureForError () + "." + name + "." + postfix;
 			} else {
 				name = base.GetSignatureForError ();
 				if (targs != null)
 					name += "<" + TypeManager.CSharpName (targs) + ">";
 				else if (IsGeneric)
 					name += "<" + TypeManager.CSharpName (GenericDefinition.TypeParameters) + ">";
 			}
 
 			return name + parameters.GetSignatureForError ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="240" endline="332">
<![CDATA[
 
 		private void CreateDllImportPseudoCustomAttribute(List<CustomAttributeData> attribs)
 		{
 			int token = this.MetadataToken;
 			// TODO use binary search?
 			for (int i = 0; i < module.ImplMap.records.Length; i++)
 			{
 				if (module.ImplMap.records[i].MemberForwarded == token)
 				{
 					const short NoMangle = 0x0001;
 					const short CharSetMask = 0x0006;
 					const short CharSetNotSpec = 0x0000;
 					const short CharSetAnsi = 0x0002;
 					const short CharSetUnicode = 0x0004;
 					const short CharSetAuto = 0x0006;
 					const short SupportsLastError = 0x0040;
 					const short CallConvMask = 0x0700;
 					const short CallConvWinapi = 0x0100;
 					const short CallConvCdecl = 0x0200;
 					const short CallConvStdcall = 0x0300;
 					const short CallConvThiscall = 0x0400;
 					const short CallConvFastcall = 0x0500;
 					// non-standard flags
 					const short BestFitOn = 0x0010;
 					const short BestFitOff = 0x0020;
 					const short CharMapErrorOn = 0x1000;
 					const short CharMapErrorOff = 0x2000;
 
 					Type type = module.universe.System_Runtime_InteropServices_DllImportAttribute;
 					ConstructorInfo constructor = type.GetConstructor(new Type[] { module.universe.System_String });
 					List<CustomAttributeNamedArgument> list = new List<CustomAttributeNamedArgument>();
 					int flags = module.ImplMap.records[i].MappingFlags;
 					string entryPoint = module.GetString(module.ImplMap.records[i].ImportName);
 					string dllName = module.GetString(module.ModuleRef.records[(module.ImplMap.records[i].ImportScope & 0xFFFFFF) - 1]);
 					System.Runtime.InteropServices.CharSet? charSet;
 					switch (flags & CharSetMask)
 					{
 						case CharSetAnsi
 							charSet = System.Runtime.InteropServices.CharSet.Ansi;
 							break;
 						case CharSetUnicode
 							charSet = System.Runtime.InteropServices.CharSet.Unicode;
 							break;
 						case CharSetAuto
 							charSet = System.Runtime.InteropServices.CharSet.Auto;
 							break;
 						case CharSetNotSpec
 						default
 							charSet = null;
 							break;
 					}
 					System.Runtime.InteropServices.CallingConvention callingConvention;
 					switch (flags & CallConvMask)
 					{
 						case CallConvCdecl
 							callingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl;
 							break;
 						case CallConvFastcall
 							callingConvention = System.Runtime.InteropServices.CallingConvention.FastCall;
 							break;
 						case CallConvStdcall
 							callingConvention = System.Runtime.InteropServices.CallingConvention.StdCall;
 							break;
 						case CallConvThiscall
 							callingConvention = System.Runtime.InteropServices.CallingConvention.ThisCall;
 							break;
 						case CallConvWinapi
 						default
 							callingConvention = System.Runtime.InteropServices.CallingConvention.Winapi;
 							break;
 					}
 					list.Add(MakeNamedArgument(type, "EntryPoint", entryPoint));
 					list.Add(MakeNamedArgument(type, "ExactSpelling", flags, NoMangle));
 					list.Add(MakeNamedArgument(type, "SetLastError", flags, SupportsLastError));
 					list.Add(MakeNamedArgument(type, "PreserveSig", (int)GetMethodImplementationFlags(), (int)MethodImplAttributes.PreserveSig));
 					list.Add(MakeNamedArgument(type, "CallingConvention", (int)callingConvention));
 					if (charSet.HasValue)
 					{
 						list.Add(MakeNamedArgument(type, "CharSet", (int)charSet.Value));
 					}
 					if ((flags & (BestFitOn | BestFitOff)) != 0)
 					{
 						list.Add(MakeNamedArgument(type, "BestFitMapping", flags, BestFitOn));
 					}
 					if ((flags & (CharMapErrorOn | CharMapErrorOff)) != 0)
 					{
 						list.Add(MakeNamedArgument(type, "ThrowOnUnmappableChar", flags, CharMapErrorOn));
 					}
 					attribs.Add(new CustomAttributeData(constructor, new object[] { dllName }, list));
 					return;
 				}
 			}
 			for (int i = 0; i < module.ImplMap.records.Length; i++)
 			{
 				if (module.ImplMap.records[i].MemberForwarded == token)
 				{
 					const short NoMangle = 0x0001;
 					const short CharSetMask = 0x0006;
 					const short CharSetNotSpec = 0x0000;
 					const short CharSetAnsi = 0x0002;
 					const short CharSetUnicode = 0x0004;
 					const short CharSetAuto = 0x0006;
 					const short SupportsLastError = 0x0040;
 					const short CallConvMask = 0x0700;
 					const short CallConvWinapi = 0x0100;
 					const short CallConvCdecl = 0x0200;
 					const short CallConvStdcall = 0x0300;
 					const short CallConvThiscall = 0x0400;
 					const short CallConvFastcall = 0x0500;
 					// non-standard flags
 					const short BestFitOn = 0x0010;
 					const short BestFitOff = 0x0020;
 					const short CharMapErrorOn = 0x1000;
 					const short CharMapErrorOff = 0x2000;
 
 					Type type = module.universe.System_Runtime_InteropServices_DllImportAttribute;
 					ConstructorInfo constructor = type.GetConstructor(new Type[] { module.universe.System_String });
 					List<CustomAttributeNamedArgument> list = new List<CustomAttributeNamedArgument>();
 					int flags = module.ImplMap.records[i].MappingFlags;
 					string entryPoint = module.GetString(module.ImplMap.records[i].ImportName);
 					string dllName = module.GetString(module.ModuleRef.records[(module.ImplMap.records[i].ImportScope & 0xFFFFFF) - 1]);
 					System.Runtime.InteropServices.CharSet? charSet;
 					switch (flags & CharSetMask)
 					{
 						case CharSetAnsi
 							charSet = System.Runtime.InteropServices.CharSet.Ansi;
 							break;
 						case CharSetUnicode
 							charSet = System.Runtime.InteropServices.CharSet.Unicode;
 							break;
 						case CharSetAuto
 							charSet = System.Runtime.InteropServices.CharSet.Auto;
 							break;
 						case CharSetNotSpec
 						default
 							charSet = null;
 							break;
 					}
 					System.Runtime.InteropServices.CallingConvention callingConvention;
 					switch (flags & CallConvMask)
 					{
 						case CallConvCdecl
 							callingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl;
 							break;
 						case CallConvFastcall
 							callingConvention = System.Runtime.InteropServices.CallingConvention.FastCall;
 							break;
 						case CallConvStdcall
 							callingConvention = System.Runtime.InteropServices.CallingConvention.StdCall;
 							break;
 						case CallConvThiscall
 							callingConvention = System.Runtime.InteropServices.CallingConvention.ThisCall;
 							break;
 						case CallConvWinapi
 						default
 							callingConvention = System.Runtime.InteropServices.CallingConvention.Winapi;
 							break;
 					}
 					list.Add(MakeNamedArgument(type, "EntryPoint", entryPoint));
 					list.Add(MakeNamedArgument(type, "ExactSpelling", flags, NoMangle));
 					list.Add(MakeNamedArgument(type, "SetLastError", flags, SupportsLastError));
 					list.Add(MakeNamedArgument(type, "PreserveSig", (int)GetMethodImplementationFlags(), (int)MethodImplAttributes.PreserveSig));
 					list.Add(MakeNamedArgument(type, "CallingConvention", (int)callingConvention));
 					if (charSet.HasValue)
 					{
 						list.Add(MakeNamedArgument(type, "CharSet", (int)charSet.Value));
 					}
 					if ((flags & (BestFitOn | BestFitOff)) != 0)
 					{
 						list.Add(MakeNamedArgument(type, "BestFitMapping", flags, BestFitOn));
 					}
 					if ((flags & (CharMapErrorOn | CharMapErrorOff)) != 0)
 					{
 						list.Add(MakeNamedArgument(type, "ThrowOnUnmappableChar", flags, CharMapErrorOn));
 					}
 					attribs.Add(new CustomAttributeData(constructor, new object[] { dllName }, list));
 					return;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="87" endline="195">
<![CDATA[
 
 		static public RSA FromCapiPrivateKeyBlob (byte[] blob, int offset) 
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			RSAParameters rsap = new RSAParameters ();
 			try {
 				if ((blob [offset]   != 0x07) ||				// PRIVATEKEYBLOB (0x07)
 				    (blob [offset+1] != 0x02) ||				// Version (0x02)
 				    (blob [offset+2] != 0x00) ||				// Reserved (word)
 				    (blob [offset+3] != 0x00) ||
 				    (ToUInt32LE (blob, offset+8) != 0x32415352))	// DWORD magic = RSA2
 					throw new CryptographicException ("Invalid blob header");
 				
 				// ALGID (CALG_RSA_SIGN, CALG_RSA_KEYX, ...)
 				// int algId = ToInt32LE (blob, offset+4);
 
 				// DWORD bitlen
 				int bitLen = ToInt32LE (blob, offset+12);
 
 				// DWORD public exponent
 				byte[] exp = new byte [4];
 				Buffer.BlockCopy (blob, offset+16, exp, 0, 4);
 				Array.Reverse (exp);
 				rsap.Exponent = Trim (exp);
 			
 				int pos = offset+20;
 				// BYTE modulus[rsapubkey.bitlen/8];
 				int byteLen = (bitLen >> 3);
 				rsap.Modulus = new byte [byteLen];
 				Buffer.BlockCopy (blob, pos, rsap.Modulus, 0, byteLen);
 				Array.Reverse (rsap.Modulus);
 				pos += byteLen;
 
 				// BYTE prime1[rsapubkey.bitlen/16];
 				int byteHalfLen = (byteLen >> 1);
 				rsap.P = new byte [byteHalfLen];
 				Buffer.BlockCopy (blob, pos, rsap.P, 0, byteHalfLen);
 				Array.Reverse (rsap.P);
 				pos += byteHalfLen;
 
 				// BYTE prime2[rsapubkey.bitlen/16];
 				rsap.Q = new byte [byteHalfLen];
 				Buffer.BlockCopy (blob, pos, rsap.Q, 0, byteHalfLen);
 				Array.Reverse (rsap.Q);
 				pos += byteHalfLen;
 
 				// BYTE exponent1[rsapubkey.bitlen/16];
 				rsap.DP = new byte [byteHalfLen];
 				Buffer.BlockCopy (blob, pos, rsap.DP, 0, byteHalfLen);
 				Array.Reverse (rsap.DP);
 				pos += byteHalfLen;
 
 				// BYTE exponent2[rsapubkey.bitlen/16];
 				rsap.DQ = new byte [byteHalfLen];
 				Buffer.BlockCopy (blob, pos, rsap.DQ, 0, byteHalfLen);
 				Array.Reverse (rsap.DQ);
 				pos += byteHalfLen;
 
 				// BYTE coefficient[rsapubkey.bitlen/16];
 				rsap.InverseQ = new byte [byteHalfLen];
 				Buffer.BlockCopy (blob, pos, rsap.InverseQ, 0, byteHalfLen);
 				Array.Reverse (rsap.InverseQ);
 				pos += byteHalfLen;
 
 				// ok, this is hackish but CryptoAPI support it so...
 				// note
 				// http
 				rsap.D = new byte [byteLen]; // must be allocated
 				if (pos + byteLen + offset <= blob.Length) {
 					// BYTE privateExponent[rsapubkey.bitlen/8];
 					Buffer.BlockCopy (blob, pos, rsap.D, 0, byteLen);
 					Array.Reverse (rsap.D);
 				}
 			}
 			catch (Exception e) {
 				throw new CryptographicException ("Invalid blob.", e);
 			}
 
 #if NET_2_1
 			RSA rsa = RSA.Create ();
 			rsa.ImportParameters (rsap);
 #else
 			RSA rsa = null;
 			try {
 				rsa = RSA.Create ();
 				rsa.ImportParameters (rsap);
 			}
 			catch (CryptographicException ce) {
 				// this may cause problem when this code is run under
 				// the SYSTEM identity on Windows (e.g. ASP.NET). See
 				// http
 				try {
 					CspParameters csp = new CspParameters ();
 					csp.Flags = CspProviderFlags.UseMachineKeyStore;
 					rsa = new RSACryptoServiceProvider (csp);
 					rsa.ImportParameters (rsap);
 				}
 				catch {
 					// rethrow original, not the later, exception if this fails
 					throw ce;
 				}
 			}
 #endif
 			return rsa;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1812" endline="1876">
<![CDATA[
 
 		/// <summary>
 		///   Emits the code, this step is performed after all
 		///   the types, enumerations, constructors
 		/// </summary>
 		public virtual void EmitType ()
 		{
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			Emit ();
 
 			EmitConstructors ();
 
 			if (constants != null)
 				foreach (Const con in constants)
 					con.Emit ();
 				foreach (Const con in constants)
 					con.Emit ();
 
 			if (default_static_constructor != null)
 				default_static_constructor.Emit ();
 			
 			if (operators != null)
 				foreach (Operator o in operators)
 					o.Emit ();
 				foreach (Operator o in operators)
 					o.Emit ();
 
 			if (properties != null)
 				foreach (Property p in properties)
 					p.Emit ();
 				foreach (Property p in properties)
 					p.Emit ();
 
 			if (indexers != null) {
 				foreach (Indexer indx in indexers)
 					indx.Emit ();
 				foreach (Indexer indx in indexers)
 					indx.Emit ();
 				EmitIndexerName ();
 			}
 
 			if (events != null){
 				foreach (Event e in Events)
 					e.Emit ();
 				foreach (Event e in Events)
 					e.Emit ();
 			}
 
 			if (methods != null) {
 				for (int i = 0; i < methods.Count; ++i)
 					((MethodOrOperator) methods [i]).Emit ();
 				for (int i = 0; i < methods.Count; ++i)
 					((MethodOrOperator) methods [i]).Emit ();
 			}
 			
 			if (fields != null)
 				foreach (FieldBase f in fields)
 					f.Emit ();
 				foreach (FieldBase f in fields)
 					f.Emit ();
 
 			if (types != null) {
 				foreach (TypeContainer t in types)
 					t.EmitType ();
 				foreach (TypeContainer t in types)
 					t.EmitType ();
 			}
 
 			if (pending != null)
 				pending.VerifyPendingMethods (Report);
 
 			if (Report.Errors > 0)
 				return;
 
 			if (compiler_generated != null) {
 				for (int i = 0; i < compiler_generated.Count; ++i)
 					compiler_generated [i].EmitType ();
 				for (int i = 0; i < compiler_generated.Count; ++i)
 					compiler_generated [i].EmitType ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\VersionInfo.cs" startline="95" endline="217">
<![CDATA[
 
 		internal void Write(ByteBuffer bb)
 		{
 			if (fileVersion == null)
 			{
 				if (name.Version != null)
 				{
 					fileVersion = name.Version.ToString();
 				}
 				else
 				{
 					fileVersion = "0.0.0.0";
 				}
 			}
 
 			int codepage = 1200;	// Unicode codepage
 			int lcid = 0x7f;
 			if (name.CultureInfo != null)
 			{
 				lcid = name.CultureInfo.LCID;
 			}
 			if (culture != null)
 			{
 				lcid = new CultureInfo(culture).LCID;
 			}
 
 			Version filever = ParseVersionRobust(fileVersion);
 			int fileVersionMajor = filever.Major;
 			int fileVersionMinor = filever.Minor;
 			int fileVersionBuild = filever.Build;
 			int fileVersionRevision = filever.Revision;
 
 			int productVersionMajor = fileVersionMajor;
 			int productVersionMinor = fileVersionMinor;
 			int productVersionBuild = fileVersionBuild;
 			int productVersionRevision = fileVersionRevision;
 			if (informationalVersion != null)
 			{
 				Version productver = ParseVersionRobust(informationalVersion);
 				productVersionMajor = productver.Major;
 				productVersionMinor = productver.Minor;
 				productVersionBuild = productver.Build;
 				productVersionRevision = productver.Revision;
 			}
 
 			ByteBuffer stringTable = new ByteBuffer(512);
 			stringTable.Write((short)0);	// wLength (placeholder)
 			stringTable.Write((short)0);	// wValueLength
 			stringTable.Write((short)1);	// wType
 			WriteUTF16Z(stringTable, string.Format("{0
 			stringTable.Align(4);
 
 			WriteString(stringTable, "Comments", description);
 			WriteString(stringTable, "CompanyName", company);
 			WriteString(stringTable, "FileDescription", title);
 			WriteString(stringTable, "FileVersion", fileVersion);
 			WriteString(stringTable, "InternalName", name.Name);
 			WriteString(stringTable, "LegalCopyright", copyright);
 			WriteString(stringTable, "LegalTrademarks", trademark);
 			WriteString(stringTable, "OriginalFilename", fileName);
 			WriteString(stringTable, "ProductName", product);
 			WriteString(stringTable, "ProductVersion", informationalVersion);
 
 			stringTable.Position = 0;
 			stringTable.Write((short)stringTable.Length);
 
 			ByteBuffer stringFileInfo = new ByteBuffer(512);
 			stringFileInfo.Write((short)0);	// wLength (placeholder)
 			stringFileInfo.Write((short)0);	// wValueLength
 			stringFileInfo.Write((short)1);	// wType
 			WriteUTF16Z(stringFileInfo, "StringFileInfo");
 			stringFileInfo.Align(4);
 			stringFileInfo.Write(stringTable);
 			stringFileInfo.Position = 0;
 			stringFileInfo.Write((short)stringFileInfo.Length);
 
 			byte[] preamble1 = new byte[] {
 			  // VS_VERSIONINFO (platform SDK)
 			  0x34, 0x00,				// wValueLength
 			  0x00, 0x00,				// wType
 			  0x56, 0x00, 0x53, 0x00, 0x5F, 0x00, 0x56, 0x00, 0x45, 0x00, 0x52, 0x00, 0x53, 0x00, 0x49, 0x00, 0x4F, 0x00, 0x4E, 0x00, 0x5F, 0x00, 0x49, 0x00, 0x4E, 0x00, 0x46, 0x00, 0x4F, 0x00, 0x00, 0x00,  // "VS_VERSION_INFO\0"
 			  0x00, 0x00,				// Padding1 (32 bit alignment)
 			  // VS_FIXEDFILEINFO starts
 			  0xBD, 0x04, 0xEF, 0xFE,	// dwSignature (0xFEEF04BD)
 			  0x00, 0x00, 0x01, 0x00,	// dwStrucVersion
 			};
 			byte[] preamble2 = new byte[] {
 			  0x3F, 0x00, 0x00, 0x00,	// dwFileFlagsMask (??)
 			  0x00, 0x00, 0x00, 0x00,	// dwFileFlags (??)
 			  0x04, 0x00, 0x00, 0x00,	// dwFileOS
 			  0x02, 0x00, 0x00, 0x00,	// dwFileType
 			  0x00, 0x00, 0x00, 0x00,	// dwFileSubtype
 			  0x00, 0x00, 0x00, 0x00,	// dwFileDateMS
 			  0x00, 0x00, 0x00, 0x00,	// dwFileDateLS
 										// Padding2 (32 bit alignment)
 			  // VarFileInfo
 			  0x44, 0x00,				// wLength
 			  0x00, 0x00,				// wValueLength
 			  0x01, 0x00,				// wType
 			  0x56, 0x00, 0x61, 0x00, 0x72, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x00, 0x00,	// "VarFileInfo\0"
 			  0x00, 0x00,				// Padding
 			  // Var
 			  0x24, 0x00,				// wLength
 			  0x04, 0x00,				// wValueLength
 			  0x00, 0x00,				// wType
 			  0x54, 0x00, 0x72, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x73, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00,	// "Translation\0"
 			  0x00, 0x00,				// Padding (32 bit alignment)
 			};
 			bb.Write((short)(2 + preamble1.Length + 8 + 8 + preamble2.Length + 4 + stringFileInfo.Length));
 			bb.Write(preamble1);
 			bb.Write((short)fileVersionMinor);
 			bb.Write((short)fileVersionMajor);
 			bb.Write((short)fileVersionRevision);
 			bb.Write((short)fileVersionBuild);
 			bb.Write((short)productVersionMinor);
 			bb.Write((short)productVersionMajor);
 			bb.Write((short)productVersionRevision);
 			bb.Write((short)productVersionBuild);
 			bb.Write(preamble2);
 			bb.Write((short)lcid);
 			bb.Write((short)codepage);
 			bb.Write(stringFileInfo);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2653" endline="2756">
<![CDATA[
 
 		int consume_identifier (int c, bool quoted) 
 		{
 			//
 			// This method is very performance sensitive. It accounts
 			// for approximately 25% of all parser time
 			//
 
 			int pos = 0;
 			int column = col;
 
 			if (c == '\\') {
 				int surrogate;
 				c = escape (c, out surrogate);
 				if (surrogate != 0) {
 					id_builder [pos++] = (char) c;
 					c = surrogate;
 				}
 			}
 
 			id_builder [pos++] = (char) c;
 
 			try {
 				while (true) {
 					c = reader.Read ();
 
 					if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || (c >= '0' && c <= '9')) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					if (c < 0x80) {
 						if (c == '\\') {
 							int surrogate;
 							c = escape (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									id_builder[pos++] = (char) c;
 								c = surrogate;
 							}
 
 							continue;
 						}
 					} else if (Char.IsLetter ((char) c) || Char.GetUnicodeCategory ((char) c) == UnicodeCategory.ConnectorPunctuation) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					putback_char = c;
 					break;
 				while (true) {
 					c = reader.Read ();
 
 					if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || (c >= '0' && c <= '9')) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					if (c < 0x80) {
 						if (c == '\\') {
 							int surrogate;
 							c = escape (c, out surrogate);
 							if (surrogate != 0) {
 								if (is_identifier_part_character ((char) c))
 									id_builder[pos++] = (char) c;
 								c = surrogate;
 							}
 
 							continue;
 						}
 					} else if (Char.IsLetter ((char) c) || Char.GetUnicodeCategory ((char) c) == UnicodeCategory.ConnectorPunctuation) {
 						id_builder [pos++] = (char) c;
 						continue;
 					}
 
 					putback_char = c;
 					break;
 				}
 			} catch (IndexOutOfRangeException) {
 				Report.Error (645, Location, "Identifier too long (limit is 512 chars)");
 				--pos;
 				col += pos;
 			}
 
 			col += pos - 1;
 
 			//
 			// Optimization
 			// on uppercase letters
 			//
 			if (id_builder [0] >= '_' && !quoted) {
 				int keyword = GetKeyword (id_builder, pos);
 				if (keyword != -1) {
 					val = LocatedToken.Create (null, ref_line, column);
 					return keyword;
 				}
 			}
 
 			//
 			// Keep identifiers in an array of hashtables to avoid needless
 			// allocations
 			//
 			var identifiers_group = identifiers [pos];
 			string s;
 			if (identifiers_group != null) {
 				if (identifiers_group.TryGetValue (id_builder, out s)) {
 					val = LocatedToken.Create (s, ref_line, column);
 					if (quoted)
 						AddEscapedIdentifier (((LocatedToken) val).Location);
 					return Token.IDENTIFIER;
 				}
 			} else {
 				// TODO
 				// corlib compilation peaks at 1000 and System.Core at 150
 				int capacity = pos > 20 ? 10 
 				identifiers_group = new Dictionary<char[],string> (capacity, new IdentifiersComparer (pos));
 				identifiers [pos] = identifiers_group;
 			}
 
 			char [] chars = new char [pos];
 			Array.Copy (id_builder, chars, pos);
 
 			s = new string (id_builder, 0, pos);
 			identifiers_group.Add (chars, s);
 
 			val = LocatedToken.Create (s, ref_line, column);
 			if (quoted)
 				AddEscapedIdentifier (((LocatedToken) val).Location);
 
 			return Token.IDENTIFIER;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="1447" endline="1619">
<![CDATA[
 
 		//
 		// Main compilation method
 		//
 		public bool Compile ()
 		{
 			var module = new ModuleContainer (ctx);
 			RootContext.ToplevelTypes = module;
 
 			if (timestamps) {
 				stopwatch = Stopwatch.StartNew ();
 				first_time = DateTime.Now;
 			}
 
 			Parse (module);
 			ShowTime ("Parsing source files");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (RootContext.TokenizeOnly || RootContext.ParseOnly)
 				return true;
 
 			if (RootContext.ToplevelTypes.NamespaceEntry != null)
 				throw new InternalErrorException ("who set it?");
 
 			//
 			// Quick hack
 			//
 			var output_file = RootContext.OutputFile;
 			string output_file_name;
 			if (output_file == null) {
 				if (first_source == null) {
 					Report.Error (1562, "If no source files are specified you must specify the output file with -out
 					return false;
 				}
 
 				int pos = first_source.LastIndexOf ('.');
 
 				if (pos > 0)
 					output_file = first_source.Substring (0, pos) + RootContext.TargetExt;
 				else
 					output_file = first_source + RootContext.TargetExt;
 
 				output_file_name = output_file;
 			} else {
 				output_file_name = Path.GetFileName (output_file);
 			}
 
 			//
 			// Load assemblies required
 			//
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 #if STATIC
 			var assembly = new AssemblyDefinitionStatic (module, output_file_name, output_file);
 			module.SetDeclaringAssembly (assembly);
 
 			var importer = new StaticImporter ();
 			assembly.Importer = importer;
 
 			var loader = new StaticLoader (importer, ctx);
 			loader.LoadReferences (module);
 
 			ShowTime ("Imporing referenced assemblies");
 
 			if (!ctx.BuildinTypes.CheckDefinitions (module))
 				return false;
 
 			ShowTime ("Initializing predefined types");
 
 			if (!assembly.Create (loader))
 				return false;
 
 			// System.Object was not loaded, use compiled assembly as corlib
 			if (loader.Corlib == null)
 				loader.Corlib = assembly.Builder;
 
 			loader.LoadModules (assembly, module.GlobalRootNamespace);
 #else
 			var assembly = new AssemblyDefinitionDynamic (module, output_file_name, output_file);
 			module.SetDeclaringAssembly (assembly);
 
 			var importer = new ReflectionImporter (ctx.BuildinTypes);
 			assembly.Importer = importer;
 
 			var loader = new DynamicLoader (importer, ctx);
 			loader.LoadReferences (module);
 
 			ShowTime ("Imporing referenced assemblies");
 
 			if (!ctx.BuildinTypes.CheckDefinitions (module))
 				return false;
 
 			ShowTime ("Initializing predefined types");
 
 			if (!assembly.Create (AppDomain.CurrentDomain, AssemblyBuilderAccess.Save))
 				return false;
 
 			loader.LoadModules (assembly, module.GlobalRootNamespace);
 #endif
 			module.Define ();
 
 			ShowTime ("Types definition");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (Report.Errors == 0 &&
 				RootContext.Documentation != null &&
 				!RootContext.Documentation.OutputDocComment (
 					output_file, Report))
 				return false;
 
 			//
 			// Verify using aliases now
 			//
 			NamespaceEntry.VerifyAllUsing ();
 			
 			if (Report.Errors > 0){
 				return false;
 			}
 
 			assembly.Resolve ();
 			
 			if (Report.Errors > 0)
 				return false;
 			
 			//
 			// The code generator
 			//
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 			assembly.Emit ();
 
 			ShowTime ("Resolving and emitting members blocks");
 
 			if (Report.Errors > 0){
 				return false;
 			}
 
 			module.CloseType ();
 
 			ShowTime ("Closing types");
 
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 
 			assembly.EmbedResources ();
 			ShowTime ("Embedding resources");
 
 			if (Report.Errors > 0)
 				return false;
 
 			if (timestamps)
 				stopwatch = Stopwatch.StartNew ();
 			
 			assembly.Save ();
 
 #if STATIC
 			loader.Dispose ();
 #endif
 
 			ShowTime ("Saving output assembly");
 
 			ShowTotalTime ("Total");
 
 			Timer.ShowTimers ();
 
 			return (Report.Errors == 0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1469" endline="1573">
<![CDATA[
 
 		protected virtual bool DoDefineMembers ()
 		{
 			if (iface_exprs != null) {
 				foreach (TypeExpr iface in iface_exprs) {
 					if (iface == null)
 						continue;
 
 					var iface_type = iface.Type;
 
 					// Ensure the base is always setup
 					var compiled_iface = iface_type.MemberDefinition as Interface;
 					if (compiled_iface != null)
 						compiled_iface.Define ();
 
 					if (Kind == MemberKind.Interface)
 						MemberCache.AddInterface (iface_type);
 
 					ObsoleteAttribute oa = iface_type.GetAttributeObsolete ();
 					if (oa != null && !IsObsolete)
 						AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 
 					GenericTypeExpr ct = iface as GenericTypeExpr;
 					if (ct != null) {
 						// TODO
 						TypeManager.CheckTypeVariance (ct.Type, Variance.Covariant, this);
 
 						ct.CheckConstraints (this);
 
 						if (ct.HasDynamicArguments () && !IsCompilerGenerated) {
 							Report.Error (1966, iface.Location,
 								"`{0}'
 								GetSignatureForError (), iface.GetSignatureForError ());
 							return false;
 						}
 					}
 				}
 				foreach (TypeExpr iface in iface_exprs) {
 					if (iface == null)
 						continue;
 
 					var iface_type = iface.Type;
 
 					// Ensure the base is always setup
 					var compiled_iface = iface_type.MemberDefinition as Interface;
 					if (compiled_iface != null)
 						compiled_iface.Define ();
 
 					if (Kind == MemberKind.Interface)
 						MemberCache.AddInterface (iface_type);
 
 					ObsoleteAttribute oa = iface_type.GetAttributeObsolete ();
 					if (oa != null && !IsObsolete)
 						AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 
 					GenericTypeExpr ct = iface as GenericTypeExpr;
 					if (ct != null) {
 						// TODO
 						TypeManager.CheckTypeVariance (ct.Type, Variance.Covariant, this);
 
 						ct.CheckConstraints (this);
 
 						if (ct.HasDynamicArguments () && !IsCompilerGenerated) {
 							Report.Error (1966, iface.Location,
 								"`{0}'
 								GetSignatureForError (), iface.GetSignatureForError ());
 							return false;
 						}
 					}
 				}
 			}
 
 			if (base_type != null) {
 				ObsoleteAttribute obsolete_attr = base_type.GetAttributeObsolete ();
 				if (obsolete_attr != null && !IsObsolete)
 					AttributeTester.Report_ObsoleteMessage (obsolete_attr, base_type.GetSignatureForError (), Location, Report);
 
 				var ct = base_type_expr as GenericTypeExpr;
 				if (ct != null)
 					ct.CheckConstraints (this);
 
 				if (base_type.Interfaces != null) {
 					foreach (var iface in base_type.Interfaces)
 						spec.AddInterface (iface);
 					foreach (var iface in base_type.Interfaces)
 						spec.AddInterface (iface);
 				}
 
 				var baseContainer = base_type.MemberDefinition as ClassOrStruct;
 				if (baseContainer != null) {
 					baseContainer.Define ();
 
 					//
 					// It can trigger define of this type (for generic types only)
 					//
 					if (HasMembersDefined)
 						return true;
 				}
 			}
 
 			if (type_params != null) {
 				foreach (var tp in type_params) {
 					tp.CheckGenericConstraints ();
 				}
 				foreach (var tp in type_params) {
 					tp.CheckGenericConstraints ();
 				}
 			}
 
 			DefineContainerMembers (constants);
 			DefineContainerMembers (fields);
 
 			if (Kind == MemberKind.Struct || Kind == MemberKind.Class) {
 				pending = PendingImplementation.GetPendingImplementations (this);
 
 				if (requires_delayed_unmanagedtype_check) {
 					requires_delayed_unmanagedtype_check = false;
 					foreach (FieldBase f in fields) {
 						if (f.MemberType != null && f.MemberType.IsPointer)
 							TypeManager.VerifyUnmanaged (Compiler, f.MemberType, f.Location);
 					}
 					foreach (FieldBase f in fields) {
 						if (f.MemberType != null && f.MemberType.IsPointer)
 							TypeManager.VerifyUnmanaged (Compiler, f.MemberType, f.Location);
 					}
 				}
 			}
 		
 			//
 			// Constructors are not in the defined_names array
 			//
 			DefineContainerMembers (instance_constructors);
 		
 			DefineContainerMembers (events);
 			DefineContainerMembers (ordered_explicit_member_list);
 			DefineContainerMembers (ordered_member_list);
 
 			if (operators != null) {
 				DefineContainerMembers (operators);
 				CheckPairedOperators ();
 			}
 
 			ComputeIndexerName();
 			CheckEqualsAndGetHashCode();
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2436" endline="2482">
<![CDATA[
 		}
 
 		protected override void DefineContainerMembers (System.Collections.IList list)
 		{
 			if (list == null)
 				return;
 
 			if (!IsStatic) {
 				base.DefineContainerMembers (list);
 				return;
 			}
 
 			foreach (MemberCore m in list) {
 				if (m is Operator) {
 					Report.Error (715, m.Location, "`{0}'
 					continue;
 				}
 
 				if (m is Destructor) {
 					Report.Error (711, m.Location, "`{0}'
 					continue;
 				}
 
 				if (m is Indexer) {
 					Report.Error (720, m.Location, "`{0}'
 					continue;
 				}
 
 				if ((m.ModFlags & Modifiers.STATIC) != 0 || m is Enum || m is Delegate)
 					continue;
 
 				if (m is Constructor) {
 					Report.Error (710, m.Location, "`{0}'
 					continue;
 				}
 
 				Method method = m as Method;
 				if (method != null && method.ParameterInfo.HasExtensionMethodType) {
 					Report.Error (1105, m.Location, "`{0}'
 					continue;
 				}
 
 				Report.Error (708, m.Location, "`{0}'
 			}
 			foreach (MemberCore m in list) {
 				if (m is Operator) {
 					Report.Error (715, m.Location, "`{0}'
 					continue;
 				}
 
 				if (m is Destructor) {
 					Report.Error (711, m.Location, "`{0}'
 					continue;
 				}
 
 				if (m is Indexer) {
 					Report.Error (720, m.Location, "`{0}'
 					continue;
 				}
 
 				if ((m.ModFlags & Modifiers.STATIC) != 0 || m is Enum || m is Delegate)
 					continue;
 
 				if (m is Constructor) {
 					Report.Error (710, m.Location, "`{0}'
 					continue;
 				}
 
 				Method method = m as Method;
 				if (method != null && method.ParameterInfo.HasExtensionMethodType) {
 					Report.Error (1105, m.Location, "`{0}'
 					continue;
 				}
 
 				Report.Error (708, m.Location, "`{0}'
 			}
 
 			base.DefineContainerMembers (list);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1050" endline="1205">
<![CDATA[
 
 		//
 		// User-defined conversions
 		//
 		static Expression UserDefinedConversion (ResolveContext ec, Expression source, TypeSpec target, bool implicitOnly, Location loc)
 		{
 			List<MethodSpec> candidates = null;
 
 			//
 			// If S or T are nullable types, source_type and target_type are their underlying types
 			// otherwise source_type and target_type are equal to S and T respectively.
 			//
 			TypeSpec source_type = source.Type;
 			TypeSpec target_type = target;
 			Expression source_type_expr;
 
 			if (TypeManager.IsNullableType (source_type)) {
 				// No implicit conversion S? -> T for non-reference types
 				if (implicitOnly && !TypeManager.IsReferenceType (target_type) && !TypeManager.IsNullableType (target_type))
 					return null;
 
 				source_type_expr = Nullable.Unwrap.Create (source);
 				source_type = source_type_expr.Type;
 			} else {
 				source_type_expr = source;
 			}
 
 			if (TypeManager.IsNullableType (target_type))
 				target_type = Nullable.NullableInfo.GetUnderlyingType (target_type);
 
 			// Only these containers can contain a user defined implicit or explicit operators
 			const MemberKind user_conversion_kinds = MemberKind.Class | MemberKind.Struct | MemberKind.TypeParameter;
 
 			if ((source_type.Kind & user_conversion_kinds) != 0 && source_type != TypeManager.decimal_type) {
 				bool declared_only = source_type.IsStruct;
 
 				var operators = MemberCache.GetUserOperator (source_type, Operator.OpType.Implicit, declared_only);
 				if (operators != null) {
 					FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, implicitOnly, ref candidates);
 				}
 
 				if (!implicitOnly) {
 					operators = MemberCache.GetUserOperator (source_type, Operator.OpType.Explicit, declared_only);
 					if (operators != null) {
 						FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, false, ref candidates);
 					}
 				}
 			}
 
 			if ((target.Kind & user_conversion_kinds) != 0 && target_type != TypeManager.decimal_type) {
 				bool declared_only = target.IsStruct || implicitOnly;
 
 				var operators = MemberCache.GetUserOperator (target_type, Operator.OpType.Implicit, declared_only);
 				if (operators != null) {
 					FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, implicitOnly, ref candidates);
 				}
 
 				if (!implicitOnly) {
 					operators = MemberCache.GetUserOperator (target_type, Operator.OpType.Explicit, declared_only);
 					if (operators != null) {
 						FindApplicableUserDefinedConversionOperators (operators, source_type_expr, target_type, false, ref candidates);
 					}
 				}
 			}
 
 			if (candidates == null)
 				return null;
 
 			//
 			// Find the most specific conversion operator
 			//
 			MethodSpec most_specific_operator;
 			TypeSpec s_x, t_x;
 			if (candidates.Count == 1) {
 				most_specific_operator = candidates[0];
 				s_x = most_specific_operator.Parameters.Types[0];
 				t_x = most_specific_operator.ReturnType;
 			} else {
 				//
 				// Pass original source type to find the best match against input type and
 				// not the unwrapped expression
 				//
 				s_x = FindMostSpecificSource (candidates, source.Type, source_type_expr, !implicitOnly);
 				if (s_x == null)
 					return null;
 
 				t_x = FindMostSpecificTarget (candidates, target, !implicitOnly);
 				if (t_x == null)
 					return null;
 
 				most_specific_operator = null;
 				for (int i = 0; i < candidates.Count; ++i) {
 					if (candidates[i].ReturnType == t_x && candidates[i].Parameters.Types[0] == s_x) {
 						most_specific_operator = candidates[i];
 						break;
 					}
 				}
 				for (int i = 0; i < candidates.Count; ++i) {
 					if (candidates[i].ReturnType == t_x && candidates[i].Parameters.Types[0] == s_x) {
 						most_specific_operator = candidates[i];
 						break;
 					}
 				}
 
 				if (most_specific_operator == null) {
 					MethodSpec ambig_arg = null;
 					foreach (var candidate in candidates) {
 						if (candidate.ReturnType == t_x)
 							most_specific_operator = candidate;
 						else if (candidate.Parameters.Types[0] == s_x)
 							ambig_arg = candidate;
 					}
 					foreach (var candidate in candidates) {
 						if (candidate.ReturnType == t_x)
 							most_specific_operator = candidate;
 						else if (candidate.Parameters.Types[0] == s_x)
 							ambig_arg = candidate;
 					}
 
 					ec.Report.Error (457, loc,
 						"Ambiguous user defined operators `{0}' and `{1}' when converting from `{2}' to `{3}'",
 						ambig_arg.GetSignatureForError (), most_specific_operator.GetSignatureForError (),
 						source.Type.GetSignatureForError (), target.GetSignatureForError ());
 				}
 			}
 
 			//
 			// Convert input type when it's different to best operator argument
 			//
 			if (s_x != source_type)
 				source = implicitOnly ?
 					ImplicitConversionStandard (ec, source_type_expr, s_x, loc) 
 					ExplicitConversionStandard (ec, source_type_expr, s_x, loc);
 			else {
 				source = source_type_expr;
 			}
 
 			source = new UserCast (most_specific_operator, source, loc).Resolve (ec);
 
 			//
 			// Convert result type when it's different to best operator return type
 			//
 			if (t_x != target_type) {
 				//
 				// User operator is of T?, no need to lift it
 				//
 				if (TypeManager.IsNullableType (t_x) && t_x == target)
 					return source;
 
 				source = implicitOnly ?
 					ImplicitConversionStandard (ec, source, target_type, loc) 
 					ExplicitConversionStandard (ec, source, target_type, loc);
 
 				if (source == null)
 					return null;
 			}
 
 			//
 			// Source expression is of nullable type, lift the result in the case it's null and
 			// not nullable/lifted user operator is used
 			//
 			if (source_type_expr is Nullable.Unwrap && !TypeManager.IsNullableType (s_x) && (TypeManager.IsReferenceType (target) || target_type != target))
 				source = new Nullable.Lifted (source, source_type_expr, target).Resolve (ec);
 			else if (target_type != target)
 				source = Nullable.Wrap.Create (source, target);
 
 			return source;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="36" endline="77">
<![CDATA[
 		{
 			GenerateDocComment (t, ds, Report);
 
 			if (t.DefaultStaticConstructor != null)
 				t.DefaultStaticConstructor.GenerateDocComment (t);
 
 			if (t.InstanceConstructors != null)
 				foreach (Constructor c in t.InstanceConstructors)
 					c.GenerateDocComment (t);
 				foreach (Constructor c in t.InstanceConstructors)
 					c.GenerateDocComment (t);
 
 			if (t.Types != null)
 				foreach (TypeContainer tc in t.Types)
 					tc.GenerateDocComment (t);
 				foreach (TypeContainer tc in t.Types)
 					tc.GenerateDocComment (t);
 
 			if (t.Constants != null)
 				foreach (Const c in t.Constants)
 					c.GenerateDocComment (t);
 				foreach (Const c in t.Constants)
 					c.GenerateDocComment (t);
 
 			if (t.Fields != null)
 				foreach (FieldBase f in t.Fields)
 					f.GenerateDocComment (t);
 				foreach (FieldBase f in t.Fields)
 					f.GenerateDocComment (t);
 
 			if (t.Events != null)
 				foreach (Event e in t.Events)
 					e.GenerateDocComment (t);
 				foreach (Event e in t.Events)
 					e.GenerateDocComment (t);
 
 			if (t.Indexers != null)
 				foreach (Indexer ix in t.Indexers)
 					ix.GenerateDocComment (t);
 				foreach (Indexer ix in t.Indexers)
 					ix.GenerateDocComment (t);
 
 			if (t.Properties != null)
 				foreach (Property p in t.Properties)
 					p.GenerateDocComment (t);
 				foreach (Property p in t.Properties)
 					p.GenerateDocComment (t);
 
 			if (t.Methods != null)
 				foreach (MethodOrOperator m in t.Methods)
 					m.GenerateDocComment (t);
 				foreach (MethodOrOperator m in t.Methods)
 					m.GenerateDocComment (t);
 
 			if (t.Operators != null)
 				foreach (Operator o in t.Operators)
 					o.GenerateDocComment (t);
 				foreach (Operator o in t.Operators)
 					o.GenerateDocComment (t);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2291" endline="2435">
<![CDATA[
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			int lookup_arity = Arity;
 			bool errorMode = false;
 			Expression e;
 			Block current_block = rc.CurrentBlock;
 			INamedBlockVariable variable = null;
 			bool variable_found = false;
 
 			while (true) {
 				//
 				// Stage 1
 				//
 				// LAMESPEC
 				//
 				if (current_block != null && lookup_arity == 0) {
 					if (current_block.ParametersBlock.TopBlock.GetLocalName (Name, current_block.Original, ref variable)) {
 						if (!variable.IsDeclared) {
 							// We found local name in accessible block but it's not
 							// initialized yet, maybe the user wanted to bind to something else
 							errorMode = true;
 							variable_found = true;
 						} else {
 							e = variable.CreateReferenceExpression (rc, loc);
 							if (e != null) {
 								if (Arity > 0)
 									Error_TypeArgumentsCannotBeUsed (rc.Report, "variable", Name, loc);
 
 								return e;
 							}
 						}
 					}
 				}
 
 				//
 				// Stage 2
 				//
 				TypeSpec member_type = rc.CurrentType;
 				TypeSpec current_type = member_type;
 				for (; member_type != null; member_type = member_type.DeclaringType) {
 					e = MemberLookup (errorMode ? null 
 					if (e == null)
 						continue;
 
 					var me = e as MemberExpr;
 					if (me == null) {
 						// The name matches a type, defer to ResolveAsTypeStep
 						if (e is TypeExpr)
 							break;
 
 						continue;
 					}
 
 					if (errorMode) {
 						if (variable != null) {
 							if (me is FieldExpr || me is ConstantExpr || me is EventExpr || me is PropertyExpr) {
 								rc.Report.Error (844, loc,
 									"A local variable `{0}' cannot be used before it is declared. Consider renaming the local variable when it hides the member `{1}'",
 									Name, me.GetSignatureForError ());
 							} else {
 								break;
 							}
 						} else if (me is MethodGroupExpr) {
 							// Leave it to overload resolution to report correct error
 						} else {
 							// TODO
 							ErrorIsInaccesible (rc, me.GetSignatureForError (), loc);
 						}
 					} else {
 						// LAMESPEC
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						//
 						// MemberLookup does not check accessors availability, this is actually needed for properties only
 						//
 						var pe = me as PropertyExpr;
 						if (pe != null) {
 
 							// Break as there is no other overload available anyway
 							if ((restrictions & MemberLookupRestrictions.ReadAccess) != 0) {
 								if (!pe.PropertyInfo.HasGet || !pe.PropertyInfo.Get.IsAccessible (current_type))
 									break;
 
 								pe.Getter = pe.PropertyInfo.Get;
 							} else {
 								if (!pe.PropertyInfo.HasSet || !pe.PropertyInfo.Set.IsAccessible (current_type))
 									break;
 
 								pe.Setter = pe.PropertyInfo.Set;
 							}
 						}
 					}
 
 					// TODO
 					// TODO
 					me = me.ResolveMemberAccess (rc, null, null);
 
 					if (Arity > 0) {
 						targs.Resolve (rc);
 						me.SetTypeArguments (rc, targs);
 					}
 
 					return me;
 				for (; member_type != null; member_type = member_type.DeclaringType) {
 					e = MemberLookup (errorMode ? null 
 					if (e == null)
 						continue;
 
 					var me = e as MemberExpr;
 					if (me == null) {
 						// The name matches a type, defer to ResolveAsTypeStep
 						if (e is TypeExpr)
 							break;
 
 						continue;
 					}
 
 					if (errorMode) {
 						if (variable != null) {
 							if (me is FieldExpr || me is ConstantExpr || me is EventExpr || me is PropertyExpr) {
 								rc.Report.Error (844, loc,
 									"A local variable `{0}' cannot be used before it is declared. Consider renaming the local variable when it hides the member `{1}'",
 									Name, me.GetSignatureForError ());
 							} else {
 								break;
 							}
 						} else if (me is MethodGroupExpr) {
 							// Leave it to overload resolution to report correct error
 						} else {
 							// TODO
 							ErrorIsInaccesible (rc, me.GetSignatureForError (), loc);
 						}
 					} else {
 						// LAMESPEC
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						//
 						// MemberLookup does not check accessors availability, this is actually needed for properties only
 						//
 						var pe = me as PropertyExpr;
 						if (pe != null) {
 
 							// Break as there is no other overload available anyway
 							if ((restrictions & MemberLookupRestrictions.ReadAccess) != 0) {
 								if (!pe.PropertyInfo.HasGet || !pe.PropertyInfo.Get.IsAccessible (current_type))
 									break;
 
 								pe.Getter = pe.PropertyInfo.Get;
 							} else {
 								if (!pe.PropertyInfo.HasSet || !pe.PropertyInfo.Set.IsAccessible (current_type))
 									break;
 
 								pe.Setter = pe.PropertyInfo.Set;
 							}
 						}
 					}
 
 					// TODO
 					// TODO
 					me = me.ResolveMemberAccess (rc, null, null);
 
 					if (Arity > 0) {
 						targs.Resolve (rc);
 						me.SetTypeArguments (rc, targs);
 					}
 
 					return me;
 				}
 
 				//
 				// Stage 3
 				//
 				if ((restrictions & MemberLookupRestrictions.InvocableOnly) == 0 && !variable_found) {
 					e = ResolveAsTypeStep (rc, lookup_arity == 0 || !errorMode);
 					if (e != null) {
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						return e;
 					}
 				}
 
 				if (errorMode) {
 					if (variable_found) {
 						rc.Report.Error (841, loc, "A local variable `{0}' cannot be used before it is declared", Name);
 					} else {
 						rc.Report.Error (103, loc, "The name `{0}' does not exist in the current context", Name);
 					}
 
 					return null;
 				}
 
 				if (RootContext.EvalMode) {
 					var fi = Evaluator.LookupField (Name);
 					if (fi != null)
 						return new FieldExpr (fi.Item1, loc);
 				}
 
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 			while (true) {
 				//
 				// Stage 1
 				//
 				// LAMESPEC
 				//
 				if (current_block != null && lookup_arity == 0) {
 					if (current_block.ParametersBlock.TopBlock.GetLocalName (Name, current_block.Original, ref variable)) {
 						if (!variable.IsDeclared) {
 							// We found local name in accessible block but it's not
 							// initialized yet, maybe the user wanted to bind to something else
 							errorMode = true;
 							variable_found = true;
 						} else {
 							e = variable.CreateReferenceExpression (rc, loc);
 							if (e != null) {
 								if (Arity > 0)
 									Error_TypeArgumentsCannotBeUsed (rc.Report, "variable", Name, loc);
 
 								return e;
 							}
 						}
 					}
 				}
 
 				//
 				// Stage 2
 				//
 				TypeSpec member_type = rc.CurrentType;
 				TypeSpec current_type = member_type;
 				for (; member_type != null; member_type = member_type.DeclaringType) {
 					e = MemberLookup (errorMode ? null 
 					if (e == null)
 						continue;
 
 					var me = e as MemberExpr;
 					if (me == null) {
 						// The name matches a type, defer to ResolveAsTypeStep
 						if (e is TypeExpr)
 							break;
 
 						continue;
 					}
 
 					if (errorMode) {
 						if (variable != null) {
 							if (me is FieldExpr || me is ConstantExpr || me is EventExpr || me is PropertyExpr) {
 								rc.Report.Error (844, loc,
 									"A local variable `{0}' cannot be used before it is declared. Consider renaming the local variable when it hides the member `{1}'",
 									Name, me.GetSignatureForError ());
 							} else {
 								break;
 							}
 						} else if (me is MethodGroupExpr) {
 							// Leave it to overload resolution to report correct error
 						} else {
 							// TODO
 							ErrorIsInaccesible (rc, me.GetSignatureForError (), loc);
 						}
 					} else {
 						// LAMESPEC
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						//
 						// MemberLookup does not check accessors availability, this is actually needed for properties only
 						//
 						var pe = me as PropertyExpr;
 						if (pe != null) {
 
 							// Break as there is no other overload available anyway
 							if ((restrictions & MemberLookupRestrictions.ReadAccess) != 0) {
 								if (!pe.PropertyInfo.HasGet || !pe.PropertyInfo.Get.IsAccessible (current_type))
 									break;
 
 								pe.Getter = pe.PropertyInfo.Get;
 							} else {
 								if (!pe.PropertyInfo.HasSet || !pe.PropertyInfo.Set.IsAccessible (current_type))
 									break;
 
 								pe.Setter = pe.PropertyInfo.Set;
 							}
 						}
 					}
 
 					// TODO
 					// TODO
 					me = me.ResolveMemberAccess (rc, null, null);
 
 					if (Arity > 0) {
 						targs.Resolve (rc);
 						me.SetTypeArguments (rc, targs);
 					}
 
 					return me;
 				}
 
 				//
 				// Stage 3
 				//
 				if ((restrictions & MemberLookupRestrictions.InvocableOnly) == 0 && !variable_found) {
 					e = ResolveAsTypeStep (rc, lookup_arity == 0 || !errorMode);
 					if (e != null) {
 						if (variable != null) {
 							rc.Report.SymbolRelatedToPreviousError (variable.Location, Name);
 							rc.Report.Error (135, loc, "`{0}' conflicts with a declaration in a child block", Name);
 						}
 
 						return e;
 					}
 				}
 
 				if (errorMode) {
 					if (variable_found) {
 						rc.Report.Error (841, loc, "A local variable `{0}' cannot be used before it is declared", Name);
 					} else {
 						rc.Report.Error (103, loc, "The name `{0}' does not exist in the current context", Name);
 					}
 
 					return null;
 				}
 
 				if (RootContext.EvalMode) {
 					var fi = Evaluator.LookupField (Name);
 					if (fi != null)
 						return new FieldExpr (fi.Item1, loc);
 				}
 
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="631" endline="811">
<![CDATA[
 
 		TypeSpec CreateType (MetaType type, TypeSpec declaringType, DynamicTypeReader dtype, bool canImportBaseType)
 		{
 			TypeSpec spec;
 			if (import_cache.TryGetValue (type, out spec)) {
 				if (spec == TypeManager.object_type) {
 					if (dtype.IsDynamicObject (this))
 						return InternalType.Dynamic;
 
 					return spec;
 				}
 
 				if (!spec.IsGeneric || type.IsGenericTypeDefinition)
 					return spec;
 
 				if (!dtype.HasDynamicAttribute (this))
 					return spec;
 
 				// We've found same object in the cache but this one has a dynamic custom attribute
 				// and it's most likely dynamic version of same type IFoo<object> agains IFoo<dynamic>
 				// Do type resolve process again in that case
 
 				// TODO
 			}
 
 			if (type.IsGenericType && !type.IsGenericTypeDefinition) {
 				var type_def = type.GetGenericTypeDefinition ();
 				var targs = CreateGenericArguments (0, type.GetGenericArguments (), dtype);
 				if (declaringType == null) {
 					// Simple case, no nesting
 					spec = CreateType (type_def, null, new DynamicTypeReader (), canImportBaseType);
 					spec = spec.MakeGenericType (targs);
 				} else {
 					//
 					// Nested type case, converting .NET types like
 					// A`1.B`1.C`1<int, long, string> to typespec like
 					// A<int>.B<long>.C<string>
 					//
 					var nested_hierarchy = new List<TypeSpec> ();
 					while (declaringType.IsNested) {
 						nested_hierarchy.Add (declaringType);
 						declaringType = declaringType.DeclaringType;
 					}
 					while (declaringType.IsNested) {
 						nested_hierarchy.Add (declaringType);
 						declaringType = declaringType.DeclaringType;
 					}
 
 					int targs_pos = 0;
 					if (declaringType.Arity > 0) {
 						spec = declaringType.MakeGenericType (targs.Skip (targs_pos).Take (declaringType.Arity).ToArray ());
 						targs_pos = spec.Arity;
 					} else {
 						spec = declaringType;
 					}
 
 					for (int i = nested_hierarchy.Count; i != 0; --i) {
 						var t = nested_hierarchy [i - 1];
 						spec = MemberCache.FindNestedType (spec, t.Name, t.Arity);
 						if (t.Arity > 0) {
 							spec = spec.MakeGenericType (targs.Skip (targs_pos).Take (spec.Arity).ToArray ());
 							targs_pos += t.Arity;
 						}
 					}
 					for (int i = nested_hierarchy.Count; i != 0; --i) {
 						var t = nested_hierarchy [i - 1];
 						spec = MemberCache.FindNestedType (spec, t.Name, t.Arity);
 						if (t.Arity > 0) {
 							spec = spec.MakeGenericType (targs.Skip (targs_pos).Take (spec.Arity).ToArray ());
 							targs_pos += t.Arity;
 						}
 					}
 
 					string name = type.Name;
 					int index = name.IndexOf ('`');
 					if (index > 0)
 						name = name.Substring (0, index);
 
 					spec = MemberCache.FindNestedType (spec, name, targs.Length - targs_pos);
 					if (spec.Arity > 0) {
 						spec = spec.MakeGenericType (targs.Skip (targs_pos).ToArray ());
 					}
 				}
 
 				// Don't add generic type with dynamic arguments, they can interfere with same type
 				// using object type arguments
 				if (!spec.HasDynamicElement) {
 
 					// Add to reading cache to speed up reading
 					if (!import_cache.ContainsKey (type))
 						import_cache.Add (type, spec);
 				}
 
 				return spec;
 			}
 
 			Modifiers mod;
 			MemberKind kind;
 
 			var ma = type.Attributes;
 			switch (ma & TypeAttributes.VisibilityMask) {
 			case TypeAttributes.Public
 			case TypeAttributes.NestedPublic
 				mod = Modifiers.PUBLIC;
 				break;
 			case TypeAttributes.NestedPrivate
 				mod = Modifiers.PRIVATE;
 				break;
 			case TypeAttributes.NestedFamily
 				mod = Modifiers.PROTECTED;
 				break;
 			case TypeAttributes.NestedFamORAssem
 				mod = Modifiers.PROTECTED | Modifiers.INTERNAL;
 				break;
 			default
 				mod = Modifiers.INTERNAL;
 				break;
 			}
 
 			if ((ma & TypeAttributes.Interface) != 0) {
 				kind = MemberKind.Interface;
 			} else if (type.IsGenericParameter) {
 				kind = MemberKind.TypeParameter;
 			} else {
 				var base_type = type.BaseType;
 				if (base_type == null || (ma & TypeAttributes.Abstract) != 0) {
 					kind = MemberKind.Class;
 				} else {
 					kind = DetermineKindFromBaseType (base_type);
 					if (kind == MemberKind.Struct || kind == MemberKind.Delegate) {
 						mod |= Modifiers.SEALED;
 					}
 				}
 
 				if (kind == MemberKind.Class) {
 					if ((ma & TypeAttributes.Sealed) != 0) {
 						mod |= Modifiers.SEALED;
 						if ((ma & TypeAttributes.Abstract) != 0)
 							mod |= Modifiers.STATIC;
 					} else if ((ma & TypeAttributes.Abstract) != 0) {
 						mod |= Modifiers.ABSTRACT;
 					}
 				}
 			}
 
 			var definition = new ImportedTypeDefinition (type, this);
 			BuildinTypeSpec pt;
 
 			if (kind == MemberKind.Enum) {
 				const BindingFlags underlying_member = BindingFlags.DeclaredOnly |
 					BindingFlags.Instance |
 					BindingFlags.Public | BindingFlags.NonPublic;
 
 				var type_members = type.GetFields (underlying_member);
 				foreach (var type_member in type_members) {
 					spec = new EnumSpec (declaringType, definition, CreateType (type_member.FieldType), type, mod);
 					break;
 				foreach (var type_member in type_members) {
 					spec = new EnumSpec (declaringType, definition, CreateType (type_member.FieldType), type, mod);
 					break;
 				}
 
 				if (spec == null)
 					kind = MemberKind.Class;
 
 			} else if (kind == MemberKind.TypeParameter) {
 				// Return as type_cache was updated
 				return CreateTypeParameter (type, declaringType);
 			} else if (type.IsGenericTypeDefinition) {
 				definition.TypeParameters = CreateGenericParameters (type, declaringType);
 
 				// Constraints are not loaded on demand and can reference this type
 				if (import_cache.TryGetValue (type, out spec))
 					return spec;
 
 			} else if (buildin_types.TryGetValue (type, out pt)) {
 				spec = pt;
 				pt.SetDefinition (definition, type, mod);
 			}
 
 			if (spec == null)
 				spec = new TypeSpec (kind, declaringType, definition, type, mod);
 
 			import_cache.Add (type, spec);
 
 			//
 			// Two stage setup as the base type can be inflated declaring type or
 			// another nested type inside same declaring type which has not been
 			// loaded, therefore we can import a base type of nested types once
 			// the types have been imported
 			//
 			if (canImportBaseType)
 				ImportTypeBase (spec, type);
 
 			return spec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4531" endline="4686">
<![CDATA[
 
 		bool VerifyArguments (ResolveContext ec, ref Arguments args, MemberSpec member, IParametersMember pm, bool chose_params_expanded)
 		{
 			var pd = pm.Parameters;
 			TypeSpec[] ptypes = ((IParametersMember) member).Parameters.Types;
 
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 			int a_idx = 0, a_pos = 0;
 			Argument a = null;
 			ArrayInitializer params_initializers = null;
 			bool has_unsafe_arg = pm.MemberType.IsPointer;
 			int arg_count = args == null ? 0 
 
 			for (; a_idx < arg_count; a_idx++, ++a_pos) {
 				a = args[a_idx];
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = pd.FixedParameters[a_idx].ModFlags;
 					pt = ptypes[a_idx];
 					has_unsafe_arg |= pt.IsPointer;
 
 					if (p_mod == Parameter.Modifier.PARAMS) {
 						if (chose_params_expanded) {
 							params_initializers = new ArrayInitializer (arg_count - a_idx, a.Expr.Location);
 							pt = TypeManager.GetElementType (pt);
 						}
 					}
 				}
 
 				//
 				// Types have to be identical when ref or out modifer is used 
 				//
 				if (a.Modifier != 0 || (p_mod & ~Parameter.Modifier.PARAMS) != 0) {
 					if ((p_mod & ~Parameter.Modifier.PARAMS) != a.Modifier)
 						break;
 
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt))
 						continue;
 
 					break;
 				}
 
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int name_index = pd.GetParameterIndexByName (na.Name);
 					if (name_index < 0 || name_index >= pd.Count) {
 						if (IsDelegateInvoke) {
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 							ec.Report.Error (1746, na.Location,
 								"The delegate `{0}' does not contain a parameter named `{1}'",
 								DelegateType.GetSignatureForError (), na.Name);
 						} else {
 							ec.Report.SymbolRelatedToPreviousError (member);
 							ec.Report.Error (1739, na.Location,
 								"The best overloaded method match for `{0}' does not contain a parameter named `{1}'",
 								TypeManager.CSharpSignature (member), na.Name);
 						}
 					} else if (args[name_index] != a) {
 						if (IsDelegateInvoke)
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 						else
 							ec.Report.SymbolRelatedToPreviousError (member);
 
 						ec.Report.Error (1744, na.Location,
 							"Named argument `{0}' cannot be used for a parameter which has positional argument specified",
 							na.Name);
 					}
 				}
 				
 				if (a.Expr.Type == InternalType.Dynamic)
 					continue;
 
 				if ((restrictions & Restrictions.CovariantDelegate) != 0 && !Delegate.IsTypeCovariant (a.Expr, pt)) {
 					custom_errors.NoArgumentMatch (ec, member);
 					return false;
 				}
 
 				Expression conv = null;
 				if (a.ArgType == Argument.AType.ExtensionType) {
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt)) {
 						conv = a.Expr;
 					} else {
 						conv = Convert.ImplicitReferenceConversion (a.Expr, pt, false);
 						if (conv == null)
 							conv = Convert.ImplicitBoxingConversion (a.Expr, a.Expr.Type, pt);
 					}
 				} else {
 					conv = Convert.ImplicitConversion (ec, a.Expr, pt, loc);
 				}
 
 				if (conv == null)
 					break;
 
 				//
 				// Convert params arguments to an array initializer
 				//
 				if (params_initializers != null) {
 					// we choose to use 'a.Expr' rather than 'conv' so that
 					// we don't hide the kind of expression we have (esp. CompoundAssign.Helper)
 					params_initializers.Add (a.Expr);
 					args.RemoveAt (a_idx--);
 					--arg_count;
 					continue;
 				}
 
 				// Update the argument with the implicit conversion
 				a.Expr = conv;
 			}
 			for (; a_idx < arg_count; a_idx++, ++a_pos) {
 				a = args[a_idx];
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = pd.FixedParameters[a_idx].ModFlags;
 					pt = ptypes[a_idx];
 					has_unsafe_arg |= pt.IsPointer;
 
 					if (p_mod == Parameter.Modifier.PARAMS) {
 						if (chose_params_expanded) {
 							params_initializers = new ArrayInitializer (arg_count - a_idx, a.Expr.Location);
 							pt = TypeManager.GetElementType (pt);
 						}
 					}
 				}
 
 				//
 				// Types have to be identical when ref or out modifer is used 
 				//
 				if (a.Modifier != 0 || (p_mod & ~Parameter.Modifier.PARAMS) != 0) {
 					if ((p_mod & ~Parameter.Modifier.PARAMS) != a.Modifier)
 						break;
 
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt))
 						continue;
 
 					break;
 				}
 
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int name_index = pd.GetParameterIndexByName (na.Name);
 					if (name_index < 0 || name_index >= pd.Count) {
 						if (IsDelegateInvoke) {
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 							ec.Report.Error (1746, na.Location,
 								"The delegate `{0}' does not contain a parameter named `{1}'",
 								DelegateType.GetSignatureForError (), na.Name);
 						} else {
 							ec.Report.SymbolRelatedToPreviousError (member);
 							ec.Report.Error (1739, na.Location,
 								"The best overloaded method match for `{0}' does not contain a parameter named `{1}'",
 								TypeManager.CSharpSignature (member), na.Name);
 						}
 					} else if (args[name_index] != a) {
 						if (IsDelegateInvoke)
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 						else
 							ec.Report.SymbolRelatedToPreviousError (member);
 
 						ec.Report.Error (1744, na.Location,
 							"Named argument `{0}' cannot be used for a parameter which has positional argument specified",
 							na.Name);
 					}
 				}
 				
 				if (a.Expr.Type == InternalType.Dynamic)
 					continue;
 
 				if ((restrictions & Restrictions.CovariantDelegate) != 0 && !Delegate.IsTypeCovariant (a.Expr, pt)) {
 					custom_errors.NoArgumentMatch (ec, member);
 					return false;
 				}
 
 				Expression conv = null;
 				if (a.ArgType == Argument.AType.ExtensionType) {
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt)) {
 						conv = a.Expr;
 					} else {
 						conv = Convert.ImplicitReferenceConversion (a.Expr, pt, false);
 						if (conv == null)
 							conv = Convert.ImplicitBoxingConversion (a.Expr, a.Expr.Type, pt);
 					}
 				} else {
 					conv = Convert.ImplicitConversion (ec, a.Expr, pt, loc);
 				}
 
 				if (conv == null)
 					break;
 
 				//
 				// Convert params arguments to an array initializer
 				//
 				if (params_initializers != null) {
 					// we choose to use 'a.Expr' rather than 'conv' so that
 					// we don't hide the kind of expression we have (esp. CompoundAssign.Helper)
 					params_initializers.Add (a.Expr);
 					args.RemoveAt (a_idx--);
 					--arg_count;
 					continue;
 				}
 
 				// Update the argument with the implicit conversion
 				a.Expr = conv;
 			}
 
 			if (a_idx != arg_count) {
 				ReportArgumentMismatch (ec, a_pos, member, a, pd, pt);
 				return false;
 			}
 
 			//
 			// Fill not provided arguments required by params modifier
 			//
 			if (params_initializers == null && pd.HasParams && arg_count + 1 == pd.Count) {
 				if (args == null)
 					args = new Arguments (1);
 
 				pt = ptypes[pd.Count - 1];
 				pt = TypeManager.GetElementType (pt);
 				has_unsafe_arg |= pt.IsPointer;
 				params_initializers = new ArrayInitializer (0, loc);
 			}
 
 			//
 			// Append an array argument with all params arguments
 			//
 			if (params_initializers != null) {
 				args.Add (new Argument (
 					new ArrayCreation (new TypeExpression (pt, loc), params_initializers, loc).Resolve (ec)));
 				arg_count++;
 			}
 
 			if (has_unsafe_arg && !ec.IsUnsafe) {
 				Expression.UnsafeError (ec, loc);
 			}
 
 			//
 			// We could infer inaccesible type arguments
 			//
 			if (type_arguments == null && member.IsGeneric) {
 				var ms = (MethodSpec) member;
 				foreach (var ta in ms.TypeArguments) {
 					if (!ta.IsAccessible (ec.CurrentType)) {
 						ec.Report.SymbolRelatedToPreviousError (ta);
 						Expression.ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						break;
 					}
 				}
 				foreach (var ta in ms.TypeArguments) {
 					if (!ta.IsAccessible (ec.CurrentType)) {
 						ec.Report.SymbolRelatedToPreviousError (ta);
 						Expression.ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						break;
 					}
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="174" endline="270">
<![CDATA[
 
 		private static int WriteMarshallingDescriptor(ModuleBuilder module, CustomAttributeBuilder attribute)
 		{
 			UnmanagedType unmanagedType;
 			object val = attribute.GetConstructorArgument(0);
 			if (val is short)
 			{
 				unmanagedType = (UnmanagedType)(short)val;
 			}
 			else if (val is int)
 			{
 				unmanagedType = (UnmanagedType)(int)val;
 			}
 			else
 			{
 				unmanagedType = (UnmanagedType)val;
 			}
 
 			ByteBuffer bb = new ByteBuffer(5);
 			bb.WriteCompressedInt((int)unmanagedType);
 
 			if (unmanagedType == UnmanagedType.LPArray)
 			{
 				UnmanagedType arraySubType = attribute.GetFieldValue<UnmanagedType>("ArraySubType") ?? NATIVE_TYPE_MAX;
 				bb.WriteCompressedInt((int)arraySubType);
 				int? sizeParamIndex = attribute.GetFieldValue<short>("SizeParamIndex");
 				int? sizeConst = attribute.GetFieldValue<int>("SizeConst");
 				if (sizeParamIndex != null)
 				{
 					bb.WriteCompressedInt(sizeParamIndex.Value);
 					if (sizeConst != null)
 					{
 						bb.WriteCompressedInt(sizeConst.Value);
 						bb.WriteCompressedInt(1); // flag that says that SizeParamIndex was specified
 					}
 				}
 				else if (sizeConst != null)
 				{
 					bb.WriteCompressedInt(0); // SizeParamIndex
 					bb.WriteCompressedInt(sizeConst.Value);
 					bb.WriteCompressedInt(0); // flag that says that SizeParamIndex was not specified
 				}
 			}
 			else if (unmanagedType == UnmanagedType.SafeArray)
 			{
 				VarEnum? safeArraySubType = attribute.GetFieldValue<VarEnum>("SafeArraySubType");
 				if (safeArraySubType != null)
 				{
 					bb.WriteCompressedInt((int)safeArraySubType);
 					Type safeArrayUserDefinedSubType = (Type)attribute.GetFieldValue("SafeArrayUserDefinedSubType");
 					if (safeArrayUserDefinedSubType != null)
 					{
 						WriteType(module, bb, safeArrayUserDefinedSubType);
 					}
 				}
 			}
 			else if (unmanagedType == UnmanagedType.ByValArray)
 			{
 				bb.WriteCompressedInt(attribute.GetFieldValue<int>("SizeConst") ?? 1);
 				UnmanagedType? arraySubType = attribute.GetFieldValue<UnmanagedType>("ArraySubType");
 				if (arraySubType != null)
 				{
 					bb.WriteCompressedInt((int)arraySubType);
 				}
 			}
 			else if (unmanagedType == UnmanagedType.ByValTStr)
 			{
 				bb.WriteCompressedInt(attribute.GetFieldValue<int>("SizeConst").Value);
 			}
 			else if (unmanagedType == UnmanagedType.Interface
 				|| unmanagedType == UnmanagedType.IDispatch
 				|| unmanagedType == UnmanagedType.IUnknown)
 			{
 				int? iidParameterIndex = attribute.GetFieldValue<int>("IidParameterIndex");
 				if (iidParameterIndex != null)
 				{
 					bb.WriteCompressedInt(iidParameterIndex.Value);
 				}
 			}
 			else if (unmanagedType == UnmanagedType.CustomMarshaler)
 			{
 				bb.WriteCompressedInt(0);
 				bb.WriteCompressedInt(0);
 				string marshalType = (string)attribute.GetFieldValue("MarshalType");
 				if (marshalType != null)
 				{
 					WriteString(bb, marshalType);
 				}
 				else
 				{
 					WriteType(module, bb, (Type)attribute.GetFieldValue("MarshalTypeRef"));
 				}
 				WriteString(bb, (string)attribute.GetFieldValue("MarshalCookie") ?? "");
 			}
 
 			return module.Blobs.Add(bb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2984" endline="3117">
<![CDATA[
 
 		//
 		// Lower-bound (false) or Upper-bound (true) inference based on inversed argument
 		//
 		int LowerBoundInference (TypeSpec u, TypeSpec v, bool inversed)
 		{
 			// If V is one of the unfixed type arguments
 			int pos = IsUnfixed (v);
 			if (pos != -1) {
 				AddToBounds (new BoundInfo (u, inversed ? BoundKind.Upper 
 				return 1;
 			}			
 
 			// If U is an array type
 			var u_ac = u as ArrayContainer;
 			if (u_ac != null) {
 				var v_ac = v as ArrayContainer;
 				if (v_ac != null) {
 					if (u_ac.Rank != v_ac.Rank)
 						return 0;
 
 					if (TypeManager.IsValueType (u_ac.Element))
 						return ExactInference (u_ac.Element, v_ac.Element);
 
 					return LowerBoundInference (u_ac.Element, v_ac.Element, inversed);
 				}
 
 				if (u_ac.Rank != 1)
 					return 0;
 
 				if (TypeManager.IsGenericType (v)) {
 					TypeSpec g_v = v.GetDefinition ();
 					if (g_v != TypeManager.generic_ilist_type &&
 						g_v != TypeManager.generic_icollection_type &&
 						g_v != TypeManager.generic_ienumerable_type)
 						return 0;
 
 					var v_i = TypeManager.GetTypeArguments (v) [0];
 					if (TypeManager.IsValueType (u_ac.Element))
 						return ExactInference (u_ac.Element, v_i);
 
 					return LowerBoundInference (u_ac.Element, v_i);
 				}
 			} else if (TypeManager.IsGenericType (v)) {
 				//
 				// if V is a constructed type C<V1..Vk> and there is a unique type C<U1..Uk>
 				// such that U is identical to, inherits from (directly or indirectly),
 				// or implements (directly or indirectly) C<U1..Uk>
 				//
 				var u_candidates = new List<TypeSpec> ();
 				var open_v = v.MemberDefinition;
 
 				for (TypeSpec t = u; t != null; t = t.BaseType) {
 					if (open_v == t.MemberDefinition)
 						u_candidates.Add (t);
 
 					//
 					// Using this trick for dynamic type inference, the spec says the type arguments are "unknown" but
 					// that would complicate the process a lot, instead I treat them as dynamic
 					//
 					if (t == InternalType.Dynamic)
 						u_candidates.Add (t);
 
 					if (t.Interfaces != null) {
 						foreach (var iface in t.Interfaces) {
 							if (open_v == iface.MemberDefinition)
 								u_candidates.Add (iface);
 						}
 						foreach (var iface in t.Interfaces) {
 							if (open_v == iface.MemberDefinition)
 								u_candidates.Add (iface);
 						}
 					}
 				}
 				for (TypeSpec t = u; t != null; t = t.BaseType) {
 					if (open_v == t.MemberDefinition)
 						u_candidates.Add (t);
 
 					//
 					// Using this trick for dynamic type inference, the spec says the type arguments are "unknown" but
 					// that would complicate the process a lot, instead I treat them as dynamic
 					//
 					if (t == InternalType.Dynamic)
 						u_candidates.Add (t);
 
 					if (t.Interfaces != null) {
 						foreach (var iface in t.Interfaces) {
 							if (open_v == iface.MemberDefinition)
 								u_candidates.Add (iface);
 						}
 					}
 				}
 
 				TypeSpec [] unique_candidate_targs = null;
 				TypeSpec[] ga_v = TypeManager.GetTypeArguments (v);
 				foreach (TypeSpec u_candidate in u_candidates) {
 					//
 					// The unique set of types U1..Uk means that if we have an interface I<T>,
 					// class U 
 					// type I<T> by applying type U because T could be int or long
 					//
 					if (unique_candidate_targs != null) {
 						TypeSpec[] second_unique_candidate_targs = TypeManager.GetTypeArguments (u_candidate);
 						if (TypeSpecComparer.Equals (unique_candidate_targs, second_unique_candidate_targs)) {
 							unique_candidate_targs = second_unique_candidate_targs;
 							continue;
 						}
 
 						//
 						// This should always cause type inference failure
 						//
 						failed = true;
 						return 1;
 					}
 
 					//
 					// A candidate is dynamic type expression, to simplify things use dynamic
 					// for all type parameter of this type. For methods like this one
 					// 
 					// void M<T, U> (IList<T>, IList<U[]>)
 					//
 					// dynamic becomes both T and U when the arguments are of dynamic type
 					//
 					if (u_candidate == InternalType.Dynamic) {
 						unique_candidate_targs = new TypeSpec[ga_v.Length];
 						for (int i = 0; i < unique_candidate_targs.Length; ++i)
 							unique_candidate_targs[i] = u_candidate;
 						for (int i = 0; i < unique_candidate_targs.Length; ++i)
 							unique_candidate_targs[i] = u_candidate;
 					} else {
 						unique_candidate_targs = TypeManager.GetTypeArguments (u_candidate);
 					}
 				}
 				foreach (TypeSpec u_candidate in u_candidates) {
 					//
 					// The unique set of types U1..Uk means that if we have an interface I<T>,
 					// class U 
 					// type I<T> by applying type U because T could be int or long
 					//
 					if (unique_candidate_targs != null) {
 						TypeSpec[] second_unique_candidate_targs = TypeManager.GetTypeArguments (u_candidate);
 						if (TypeSpecComparer.Equals (unique_candidate_targs, second_unique_candidate_targs)) {
 							unique_candidate_targs = second_unique_candidate_targs;
 							continue;
 						}
 
 						//
 						// This should always cause type inference failure
 						//
 						failed = true;
 						return 1;
 					}
 
 					//
 					// A candidate is dynamic type expression, to simplify things use dynamic
 					// for all type parameter of this type. For methods like this one
 					// 
 					// void M<T, U> (IList<T>, IList<U[]>)
 					//
 					// dynamic becomes both T and U when the arguments are of dynamic type
 					//
 					if (u_candidate == InternalType.Dynamic) {
 						unique_candidate_targs = new TypeSpec[ga_v.Length];
 						for (int i = 0; i < unique_candidate_targs.Length; ++i)
 							unique_candidate_targs[i] = u_candidate;
 					} else {
 						unique_candidate_targs = TypeManager.GetTypeArguments (u_candidate);
 					}
 				}
 
 				if (unique_candidate_targs != null) {
 					var ga_open_v = open_v.TypeParameters;
 					int score = 0;
 					for (int i = 0; i < unique_candidate_targs.Length; ++i) {
 						Variance variance = ga_open_v [i].Variance;
 
 						TypeSpec u_i = unique_candidate_targs [i];
 						if (variance == Variance.None || TypeManager.IsValueType (u_i)) {
 							if (ExactInference (u_i, ga_v [i]) == 0)
 								++score;
 						} else {
 							bool upper_bound = (variance == Variance.Contravariant && !inversed) ||
 								(variance == Variance.Covariant && inversed);
 
 							if (LowerBoundInference (u_i, ga_v [i], upper_bound) == 0)
 								++score;
 						}
 					}
 					for (int i = 0; i < unique_candidate_targs.Length; ++i) {
 						Variance variance = ga_open_v [i].Variance;
 
 						TypeSpec u_i = unique_candidate_targs [i];
 						if (variance == Variance.None || TypeManager.IsValueType (u_i)) {
 							if (ExactInference (u_i, ga_v [i]) == 0)
 								++score;
 						} else {
 							bool upper_bound = (variance == Variance.Contravariant && !inversed) ||
 								(variance == Variance.Covariant && inversed);
 
 							if (LowerBoundInference (u_i, ga_v [i], upper_bound) == 0)
 								++score;
 						}
 					}
 					return score;
 				}
 			}
 
 			return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5024" endline="5036">
<![CDATA[
 		
 		public bool IsFixed {
 			get {
 				//
 				// A variable of the form V.I is fixed when V is a fixed variable of a struct type
 				//
 				IVariableReference variable = InstanceExpression as IVariableReference;
 				if (variable != null)
 					return InstanceExpression.Type.IsStruct && variable.IsFixed;
 
 				IFixedExpression fe = InstanceExpression as IFixedExpression;
 				return fe != null && fe.IsFixed;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="992" endline="1121">
<![CDATA[
 
 		/// <summary>
 		/// Emit attribute for Attributable symbol
 		/// </summary>
 		public void Emit (Dictionary<Attribute, List<Attribute>> allEmitted)
 		{
 			var ctor = Resolve ();
 			if (ctor == null)
 				return;
 
 			var predefined = context.Module.PredefinedAttributes;
 
 			AttributeUsageAttribute usage_attr = Type.GetAttributeUsage (predefined.AttributeUsage);
 			if ((usage_attr.ValidOn & Target) == 0) {
 				Report.Error (592, Location, "The attribute `{0}' is not valid on this declaration type. " +
 					      "It is valid on `{1}' declarations only",
 					GetSignatureForError (), GetValidTargets ());
 				return;
 			}
 
 			byte[] cdata;
 			if (PosArguments == null && named_values == null) {
 				cdata = AttributeEncoder.Empty;
 			} else {
 				AttributeEncoder encoder = new AttributeEncoder ();
 
 				if (PosArguments != null) {
 					var param_types = ctor.Parameters.Types;
 					for (int j = 0; j < PosArguments.Count; ++j) {
 						var pt = param_types[j];
 						var arg_expr = PosArguments[j].Expr;
 						if (j == 0) {
 							if (Type == predefined.IndexerName || Type == predefined.Conditional) {
 								string v = ((StringConstant) arg_expr).Value;
 								if (!Tokenizer.IsValidIdentifier (v) || Tokenizer.IsKeyword (v)) {
 									context.Compiler.Report.Error (633, arg_expr.Location,
 										"The argument to the `{0}' attribute must be a valid identifier", GetSignatureForError ());
 								}
 							} else if (Type == predefined.Guid) {
 								try {
 									string v = ((StringConstant) arg_expr).Value;
 									new Guid (v);
 								} catch (Exception e) {
 									Error_AttributeEmitError (e.Message);
 									return;
 								}
 							} else if (Type == predefined.AttributeUsage) {
 								int v = ((IntConstant) ((EnumConstant) arg_expr).Child).Value;
 								if (v == 0) {
 									context.Compiler.Report.Error (591, Location, "Invalid value for argument to `{0}' attribute",
 										"System.AttributeUsage");
 								}
 							} else if (Type == predefined.MarshalAs) {
 								if (PosArguments.Count == 1) {
 									var u_type = (UnmanagedType) System.Enum.Parse (typeof (UnmanagedType), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 									if (u_type == UnmanagedType.ByValArray && !(Owner is FieldBase)) {
 										Error_AttributeEmitError ("Specified unmanaged type is only valid on fields");
 									}
 								}
 							} else if (Type == predefined.DllImport) {
 								if (PosArguments.Count == 1) {
 									var value = ((Constant) PosArguments[0].Expr).GetValue () as string;
 									if (string.IsNullOrEmpty (value))
 										Error_AttributeEmitError ("DllName cannot be empty");
 								}
 							} else if (Type == predefined.MethodImpl && pt == TypeManager.short_type &&
 								!System.Enum.IsDefined (typeof (MethodImplOptions), ((Constant) arg_expr).GetValue ().ToString ())) {
 								Error_AttributeEmitError ("Incorrect argument value.");
 								return;
 							}
 						}
 
 						arg_expr.EncodeAttributeValue (context, encoder, pt);
 					}
 					for (int j = 0; j < PosArguments.Count; ++j) {
 						var pt = param_types[j];
 						var arg_expr = PosArguments[j].Expr;
 						if (j == 0) {
 							if (Type == predefined.IndexerName || Type == predefined.Conditional) {
 								string v = ((StringConstant) arg_expr).Value;
 								if (!Tokenizer.IsValidIdentifier (v) || Tokenizer.IsKeyword (v)) {
 									context.Compiler.Report.Error (633, arg_expr.Location,
 										"The argument to the `{0}' attribute must be a valid identifier", GetSignatureForError ());
 								}
 							} else if (Type == predefined.Guid) {
 								try {
 									string v = ((StringConstant) arg_expr).Value;
 									new Guid (v);
 								} catch (Exception e) {
 									Error_AttributeEmitError (e.Message);
 									return;
 								}
 							} else if (Type == predefined.AttributeUsage) {
 								int v = ((IntConstant) ((EnumConstant) arg_expr).Child).Value;
 								if (v == 0) {
 									context.Compiler.Report.Error (591, Location, "Invalid value for argument to `{0}' attribute",
 										"System.AttributeUsage");
 								}
 							} else if (Type == predefined.MarshalAs) {
 								if (PosArguments.Count == 1) {
 									var u_type = (UnmanagedType) System.Enum.Parse (typeof (UnmanagedType), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 									if (u_type == UnmanagedType.ByValArray && !(Owner is FieldBase)) {
 										Error_AttributeEmitError ("Specified unmanaged type is only valid on fields");
 									}
 								}
 							} else if (Type == predefined.DllImport) {
 								if (PosArguments.Count == 1) {
 									var value = ((Constant) PosArguments[0].Expr).GetValue () as string;
 									if (string.IsNullOrEmpty (value))
 										Error_AttributeEmitError ("DllName cannot be empty");
 								}
 							} else if (Type == predefined.MethodImpl && pt == TypeManager.short_type &&
 								!System.Enum.IsDefined (typeof (MethodImplOptions), ((Constant) arg_expr).GetValue ().ToString ())) {
 								Error_AttributeEmitError ("Incorrect argument value.");
 								return;
 							}
 						}
 
 						arg_expr.EncodeAttributeValue (context, encoder, pt);
 					}
 				}
 
 				if (named_values != null) {
 					encoder.Encode ((ushort) named_values.Count);
 					foreach (var na in named_values) {
 						if (na.Key is FieldExpr)
 							encoder.Encode ((byte) 0x53);
 						else
 							encoder.Encode ((byte) 0x54);
 
 						encoder.Encode (na.Key.Type);
 						encoder.Encode (na.Value.Name);
 						na.Value.Expr.EncodeAttributeValue (context, encoder, na.Key.Type);
 					}
 					foreach (var na in named_values) {
 						if (na.Key is FieldExpr)
 							encoder.Encode ((byte) 0x53);
 						else
 							encoder.Encode ((byte) 0x54);
 
 						encoder.Encode (na.Key.Type);
 						encoder.Encode (na.Value.Name);
 						na.Value.Expr.EncodeAttributeValue (context, encoder, na.Key.Type);
 					}
 				} else {
 					encoder.EncodeEmptyNamedArguments ();
 				}
 
 				cdata = encoder.ToArray ();
 			}
 
 			try {
 				foreach (Attributable target in targets)
 					target.ApplyAttributeBuilder (this, ctor, cdata, predefined);
 				foreach (Attributable target in targets)
 					target.ApplyAttributeBuilder (this, ctor, cdata, predefined);
 			} catch (Exception e) {
 				Error_AttributeEmitError (e.Message);
 				return;
 			}
 
 			if (!usage_attr.AllowMultiple && allEmitted != null) {
 				if (allEmitted.ContainsKey (this)) {
 					var a = allEmitted [this];
 					if (a == null) {
 						a = new List<Attribute> (2);
 						allEmitted [this] = a;
 					}
 					a.Add (this);
 				} else {
 					allEmitted.Add (this, null);
 				}
 			}
 
 			if (!RootContext.VerifyClsCompliance)
 				return;
 
 			// Here we are testing attribute arguments for array usage (error 3016)
 			if (Owner.IsClsComplianceRequired ()) {
 				if (PosArguments != null)
 					PosArguments.CheckArrayAsAttribute (context.Compiler);
 			
 				if (NamedArguments == null)
 					return;
 
 				NamedArguments.CheckArrayAsAttribute (context.Compiler);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8187" endline="8217">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			// dynamic is used per argument in ConvertExpressionToArrayIndex case
 			bool dynamic;
 			ea.Arguments.Resolve (ec, out dynamic);
 
 			var ac = ea.Expr.Type as ArrayContainer;
 			int rank = ea.Arguments.Count;
 			if (ac.Rank != rank) {
 				ec.Report.Error (22, ea.Location, "Wrong number of indexes `{0}' inside [], expected `{1}'",
 					  rank.ToString (), ac.Rank.ToString ());
 				return null;
 			}
 
 			type = ac.Element;
 			if (type.IsPointer && !ec.IsUnsafe) {
 				UnsafeError (ec, ea.Location);
 			}
 
 			foreach (Argument a in ea.Arguments) {
 				if (a is NamedArgument)
 					ElementAccess.Error_NamedArgument ((NamedArgument) a, ec.Report);
 
 				a.Expr = ConvertExpressionToArrayIndex (ec, a.Expr);
 			}
 			foreach (Argument a in ea.Arguments) {
 				if (a is NamedArgument)
 					ElementAccess.Error_NamedArgument ((NamedArgument) a, ec.Report);
 
 				a.Expr = ConvertExpressionToArrayIndex (ec, a.Expr);
 			}
 			
 			eclass = ExprClass.Variable;
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="474" endline="632">
<![CDATA[
 
 		//
 		// Processes "see" or "seealso" elements.
 		// Checks cref attribute.
 		//
 		private static void HandleXrefCommon (MemberCore mc,
 			DeclSpace ds, XmlElement xref, Report Report)
 		{
 			string cref = xref.GetAttribute ("cref").Trim (wsChars);
 			// when, XmlReader, "if (cref == null)"
 			if (!xref.HasAttribute ("cref"))
 				return;
 			if (cref.Length == 0)
 				Report.Warning (1001, 1, mc.Location, "Identifier expected");
 				// ... and continue until CS1584.
 
 			string signature; // "x
 			string name; // method invokation "(...)" are removed
 			string parameters; // method parameter list
 
 			// When it found '?
 			// MS ignores not only its member kind, but also
 			// the entire syntax correctness. Nor it also does
 			// type fullname resolution i.e. "T
 			// as T
 			// T
 			if (cref.Length > 2 && cref [1] == '
 				return;
 			else
 				signature = cref;
 
 			// Also note that without "T
 			// indication fails.
 
 			int parens_pos = signature.IndexOf ('(');
 			int brace_pos = parens_pos >= 0 ? -1 
 				signature.IndexOf ('[');
 			if (parens_pos > 0 && signature [signature.Length - 1] == ')') {
 				name = signature.Substring (0, parens_pos).Trim (wsChars);
 				parameters = signature.Substring (parens_pos + 1, signature.Length - parens_pos - 2).Trim (wsChars);
 			}
 			else if (brace_pos > 0 && signature [signature.Length - 1] == ']') {
 				name = signature.Substring (0, brace_pos).Trim (wsChars);
 				parameters = signature.Substring (brace_pos + 1, signature.Length - brace_pos - 2).Trim (wsChars);
 			}
 			else {
 				name = signature;
 				parameters = null;
 			}
 			Normalize (mc, ref name, Report);
 
 			string identifier = GetBodyIdentifierFromName (name);
 
 			// Check if identifier is valid.
 			// This check is not necessary to mark as error, but
 			// csc specially reports CS1584 for wrong identifiers.
 			string [] name_elems = identifier.Split ('.');
 			for (int i = 0; i < name_elems.Length; i++) {
 				string nameElem = GetBodyIdentifierFromName (name_elems [i]);
 				if (i > 0)
 					Normalize (mc, ref nameElem, Report);
 				if (!Tokenizer.IsValidIdentifier (nameElem)
 					&& nameElem.IndexOf ("operator") < 0) {
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					xref.SetAttribute ("cref", "!
 					return;
 				}
 			}
 			for (int i = 0; i < name_elems.Length; i++) {
 				string nameElem = GetBodyIdentifierFromName (name_elems [i]);
 				if (i > 0)
 					Normalize (mc, ref nameElem, Report);
 				if (!Tokenizer.IsValidIdentifier (nameElem)
 					&& nameElem.IndexOf ("operator") < 0) {
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					xref.SetAttribute ("cref", "!
 					return;
 				}
 			}
 
 			// check if parameters are valid
 			AParametersCollection parameter_types;
 			if (parameters == null)
 				parameter_types = null;
 			else if (parameters.Length == 0)
 				parameter_types = ParametersCompiled.EmptyReadOnlyParameters;
 			else {
 				string [] param_list = parameters.Split (',');
 				var plist = new List<TypeSpec> ();
 				for (int i = 0; i < param_list.Length; i++) {
 					string param_type_name = param_list [i].Trim (wsChars);
 					Normalize (mc, ref param_type_name, Report);
 					TypeSpec param_type = FindDocumentedType (mc, param_type_name, ds, cref, Report);
 					if (param_type == null) {
 						Report.Warning (1580, 1, mc.Location, "Invalid type for parameter `{0}' in XML comment cref attribute `{1}'",
 							(i + 1).ToString (), cref);
 						return;
 					}
 					plist.Add (param_type);
 				}
 				for (int i = 0; i < param_list.Length; i++) {
 					string param_type_name = param_list [i].Trim (wsChars);
 					Normalize (mc, ref param_type_name, Report);
 					TypeSpec param_type = FindDocumentedType (mc, param_type_name, ds, cref, Report);
 					if (param_type == null) {
 						Report.Warning (1580, 1, mc.Location, "Invalid type for parameter `{0}' in XML comment cref attribute `{1}'",
 							(i + 1).ToString (), cref);
 						return;
 					}
 					plist.Add (param_type);
 				}
 
 				parameter_types = ParametersCompiled.CreateFullyResolved (plist.ToArray ());
 			}
 
 			TypeSpec type = FindDocumentedType (mc, name, ds, cref, Report);
 			if (type != null
 				// delegate must not be referenced with args
 				&& (!type.IsDelegate
 				|| parameter_types == null)) {
 				string result = GetSignatureForDoc (type)
 					+ (brace_pos < 0 ? String.Empty 
 				xref.SetAttribute ("cref", "T
 				return; // a type
 			}
 
 			int period = name.LastIndexOf ('.');
 			if (period > 0) {
 				string typeName = name.Substring (0, period);
 				string member_name = name.Substring (period + 1);
 				string lookup_name = member_name == "this" ? MemberCache.IndexerNameAlias 
 				Normalize (mc, ref lookup_name, Report);
 				Normalize (mc, ref member_name, Report);
 				type = FindDocumentedType (mc, typeName, ds, cref, Report);
 				int warn_result;
 				if (type != null) {
 					var mi = FindDocumentedMember (mc, type, lookup_name, parameter_types, ds, out warn_result, cref, true, name, Report);
 					if (warn_result > 0)
 						return;
 					if (mi != null) {
 						// we cannot use 'type' directly
 						// to get its name, since mi
 						// could be from DeclaringType
 						// for nested types.
 						xref.SetAttribute ("cref", GetMemberDocHead (mi) + GetSignatureForDoc (mi.DeclaringType) + "." + member_name + GetParametersFormatted (mi));
 						return; // a member of a type
 					}
 				}
 			} else {
 				int warn_result;
 				var mi = FindDocumentedMember (mc, ds.PartialContainer.Definition, name, parameter_types, ds, out warn_result, cref, true, name, Report);
 
 				if (warn_result > 0)
 					return;
 				if (mi != null) {
 					// we cannot use 'type' directly
 					// to get its name, since mi
 					// could be from DeclaringType
 					// for nested types.
 					xref.SetAttribute ("cref", GetMemberDocHead (mi) + GetSignatureForDoc (mi.DeclaringType) + "." + name + GetParametersFormatted (mi));
 					return; // local member name
 				}
 			}
 
 			// It still might be part of namespace name.
 			Namespace ns = ds.NamespaceEntry.NS.GetNamespace (name, false);
 			if (ns != null) {
 				xref.SetAttribute ("cref", "N
 				return; // a namespace
 			}
 			if (mc.Module.GlobalRootNamespace.IsNamespace (name)) {
 				xref.SetAttribute ("cref", "N
 				return; // a namespace
 			}
 
 			Report.Warning (1574, 1, mc.Location, "XML comment on `{0}' has cref attribute `{1}' that could not be resolved",
 				mc.GetSignatureForError (), cref);
 
 			xref.SetAttribute ("cref", "!
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="540" endline="588">
<![CDATA[
 
 		public virtual void ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			if (builder != null)
 				throw new InternalErrorException ("builder already exists");
 
 			var pattrs = ParametersCompiled.GetParameterAttribute (modFlags);
 			if (HasOptionalExpression)
 				pattrs |= ParameterAttributes.Optional;
 
 			if (mb == null)
 				builder = cb.DefineParameter (index, pattrs, Name);
 			else
 				builder = mb.DefineParameter (index, pattrs, Name);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (HasDefaultValue) {
 				//
 				// Emit constant values for true constants only, the other
 				// constant-like expressions will rely on default value expression
 				//
 				var def_value = DefaultValue;
 				Constant c = def_value != null ? def_value.Child as Constant 
 				if (c != null) {
 					if (default_expr.Type == TypeManager.decimal_type) {
 						pa.DecimalConstant.EmitAttribute (builder, (decimal) c.GetValue (), c.Location);
 					} else {
 						builder.SetConstant (c.GetValue ());
 					}
 				} else if (default_expr.Type.IsStruct) {
 					//
 					// Handles special case where default expression is used with value-type
 					//
 					// void Foo (S s = default (S)) {}
 					//
 					builder.SetConstant (null);
 				}
 			}
 
 			if (parameter_type != null) {
 				if (parameter_type == InternalType.Dynamic) {
 					pa.Dynamic.EmitAttribute (builder);
 				} else if (parameter_type.HasDynamicElement) {
 					pa.Dynamic.EmitAttribute (builder, parameter_type, Location);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4131" endline="4397">
<![CDATA[
 
 		//
 		// Find the best method from candidate list
 		//
 		public T ResolveMember<T> (ResolveContext rc, ref Arguments args) where T 
 		{
 			List<AmbiguousCandidate> ambiguous_candidates = null;
 
 			MemberSpec best_candidate;
 			Arguments best_candidate_args = null;
 			bool best_candidate_params = false;
 			bool best_candidate_dynamic = false;
 			int best_candidate_rate;
 			IParametersMember best_parameter_member = null;
 
 			int args_count = args != null ? args.Count 
 
 			Arguments candidate_args = args;
 			bool error_mode = false;
 			var current_type = rc.CurrentType;
 			MemberSpec invocable_member = null;
 
 			// Be careful, cannot return until error reporter is restored
 			while (true) {
 				best_candidate = null;
 				best_candidate_rate = int.MaxValue;
 
 				var type_members = members;
 				try {
 
 					do {
 						for (int i = 0; i < type_members.Count; ++i) {
 							var member = type_members[i];
 
 							//
 							// Methods in a base class are not candidates if any method in a derived
 							// class is applicable
 							//
 							if ((member.Modifiers & Modifiers.OVERRIDE) != 0)
 								continue;
 
 							if (!error_mode) {
 								if (!member.IsAccessible (current_type))
 									continue;
 
 								if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (current_type))
 									continue;
 							}
 
 							IParametersMember pm = member as IParametersMember;
 							if (pm == null) {
 								//
 								// Will use it later to report ambiguity between best method and invocable member
 								//
 								if (Invocation.IsMemberInvocable (member))
 									invocable_member = member;
 
 								continue;
 							}
 
 							//
 							// Overload resolution is looking for base member but using parameter names
 							// and default values from the closest member. That means to do expensive lookup
 							// for the closest override for virtual or abstract members
 							//
 							if ((member.Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 								var override_params = base_provider.GetOverrideMemberParameters (member);
 								if (override_params != null)
 									pm = override_params;
 							}
 
 							//
 							// Check if the member candidate is applicable
 							//
 							bool params_expanded_form = false;
 							bool dynamic_argument = false;
 							TypeSpec rt = pm.MemberType;
 							int candidate_rate = IsApplicable (rc, ref candidate_args, args_count, ref member, pm, ref params_expanded_form, ref dynamic_argument, ref rt);
 
 							//
 							// How does it score compare to others
 							//
 							if (candidate_rate < best_candidate_rate) {
 								best_candidate_rate = candidate_rate;
 								best_candidate = member;
 								best_candidate_args = candidate_args;
 								best_candidate_params = params_expanded_form;
 								best_candidate_dynamic = dynamic_argument;
 								best_parameter_member = pm;
 								best_candidate_return_type = rt;
 							} else if (candidate_rate == 0) {
 								//
 								// The member look is done per type for most operations but sometimes
 								// it's not possible like for binary operators overload because they
 								// are unioned between 2 sides
 								//
 								if ((restrictions & Restrictions.BaseMembersIncluded) != 0) {
 									if (TypeSpec.IsBaseClass (best_candidate.DeclaringType, member.DeclaringType, true))
 										continue;
 								}
 
 								bool is_better;
 								if (best_candidate.DeclaringType.IsInterface && member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 									//
 									// We pack all interface members into top level type which makes the overload resolution
 									// more complicated for interfaces. We accomodate for this by removing methods with same
 									// signature when building the cache hence this path should not really be hit often
 									//
 									// Example
 									// interface IA { void Foo (int arg); }
 									// interface IB 
 									//
 									// IB
 									//
 									is_better = true;
 									if (ambiguous_candidates != null) {
 										foreach (var amb_cand in ambiguous_candidates) {
 											if (member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 												continue;
 											}
 
 											is_better = false;
 											break;
 										foreach (var amb_cand in ambiguous_candidates) {
 											if (member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 												continue;
 											}
 
 											is_better = false;
 											break;
 										}
 
 										if (is_better)
 											ambiguous_candidates = null;
 									}
 								} else {
 									// Is the new candidate better
 									is_better = BetterFunction (rc, candidate_args, member, pm.Parameters, params_expanded_form, best_candidate, best_parameter_member.Parameters, best_candidate_params);
 								}
 
 								if (is_better) {
 									best_candidate = member;
 									best_candidate_args = candidate_args;
 									best_candidate_params = params_expanded_form;
 									best_candidate_dynamic = dynamic_argument;
 									best_parameter_member = pm;
 									best_candidate_return_type = rt;
 								} else {
 									// It's not better but any other found later could be but we are not sure yet
 									if (ambiguous_candidates == null)
 										ambiguous_candidates = new List<AmbiguousCandidate> ();
 
 									ambiguous_candidates.Add (new AmbiguousCandidate (member, pm.Parameters, params_expanded_form));
 								}
 							}
 
 							// Restore expanded arguments
 							if (candidate_args != args)
 								candidate_args = args;
 						}
 						for (int i = 0; i < type_members.Count; ++i) {
 							var member = type_members[i];
 
 							//
 							// Methods in a base class are not candidates if any method in a derived
 							// class is applicable
 							//
 							if ((member.Modifiers & Modifiers.OVERRIDE) != 0)
 								continue;
 
 							if (!error_mode) {
 								if (!member.IsAccessible (current_type))
 									continue;
 
 								if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (current_type))
 									continue;
 							}
 
 							IParametersMember pm = member as IParametersMember;
 							if (pm == null) {
 								//
 								// Will use it later to report ambiguity between best method and invocable member
 								//
 								if (Invocation.IsMemberInvocable (member))
 									invocable_member = member;
 
 								continue;
 							}
 
 							//
 							// Overload resolution is looking for base member but using parameter names
 							// and default values from the closest member. That means to do expensive lookup
 							// for the closest override for virtual or abstract members
 							//
 							if ((member.Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 								var override_params = base_provider.GetOverrideMemberParameters (member);
 								if (override_params != null)
 									pm = override_params;
 							}
 
 							//
 							// Check if the member candidate is applicable
 							//
 							bool params_expanded_form = false;
 							bool dynamic_argument = false;
 							TypeSpec rt = pm.MemberType;
 							int candidate_rate = IsApplicable (rc, ref candidate_args, args_count, ref member, pm, ref params_expanded_form, ref dynamic_argument, ref rt);
 
 							//
 							// How does it score compare to others
 							//
 							if (candidate_rate < best_candidate_rate) {
 								best_candidate_rate = candidate_rate;
 								best_candidate = member;
 								best_candidate_args = candidate_args;
 								best_candidate_params = params_expanded_form;
 								best_candidate_dynamic = dynamic_argument;
 								best_parameter_member = pm;
 								best_candidate_return_type = rt;
 							} else if (candidate_rate == 0) {
 								//
 								// The member look is done per type for most operations but sometimes
 								// it's not possible like for binary operators overload because they
 								// are unioned between 2 sides
 								//
 								if ((restrictions & Restrictions.BaseMembersIncluded) != 0) {
 									if (TypeSpec.IsBaseClass (best_candidate.DeclaringType, member.DeclaringType, true))
 										continue;
 								}
 
 								bool is_better;
 								if (best_candidate.DeclaringType.IsInterface && member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 									//
 									// We pack all interface members into top level type which makes the overload resolution
 									// more complicated for interfaces. We accomodate for this by removing methods with same
 									// signature when building the cache hence this path should not really be hit often
 									//
 									// Example
 									// interface IA { void Foo (int arg); }
 									// interface IB 
 									//
 									// IB
 									//
 									is_better = true;
 									if (ambiguous_candidates != null) {
 										foreach (var amb_cand in ambiguous_candidates) {
 											if (member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 												continue;
 											}
 
 											is_better = false;
 											break;
 										}
 
 										if (is_better)
 											ambiguous_candidates = null;
 									}
 								} else {
 									// Is the new candidate better
 									is_better = BetterFunction (rc, candidate_args, member, pm.Parameters, params_expanded_form, best_candidate, best_parameter_member.Parameters, best_candidate_params);
 								}
 
 								if (is_better) {
 									best_candidate = member;
 									best_candidate_args = candidate_args;
 									best_candidate_params = params_expanded_form;
 									best_candidate_dynamic = dynamic_argument;
 									best_parameter_member = pm;
 									best_candidate_return_type = rt;
 								} else {
 									// It's not better but any other found later could be but we are not sure yet
 									if (ambiguous_candidates == null)
 										ambiguous_candidates = new List<AmbiguousCandidate> ();
 
 									ambiguous_candidates.Add (new AmbiguousCandidate (member, pm.Parameters, params_expanded_form));
 								}
 							}
 
 							// Restore expanded arguments
 							if (candidate_args != args)
 								candidate_args = args;
 						}
 					} while (best_candidate_rate != 0 && (type_members = base_provider.GetBaseMembers (type_members[0].DeclaringType.BaseType)) != null);
 				} finally {
 					if (prev_recorder != null)
 						rc.Report.SetPrinter (prev_recorder);
 				}
 
 				//
 				// We've found exact match
 				//
 				if (best_candidate_rate == 0)
 					break;
 
 				//
 				// Try extension methods lookup when no ordinary method match was found and provider enables it
 				//
 				if (!error_mode) {
 					var emg = base_provider.LookupExtensionMethod (rc);
 					if (emg != null) {
 						emg = emg.OverloadResolve (rc, ref args, null, restrictions);
 						if (emg != null) {
 							best_candidate_extension_group = emg;
 							return (T) (MemberSpec) emg.BestCandidate;
 						}
 					}
 				}
 
 				// Don't run expensive error reporting mode for probing
 				if (IsProbingOnly)
 					return null;
 
 				if (error_mode)
 					break;
 
 				lambda_conv_msgs = null;
 				error_mode = true;
 			}
 			while (true) {
 				best_candidate = null;
 				best_candidate_rate = int.MaxValue;
 
 				var type_members = members;
 				try {
 
 					do {
 						for (int i = 0; i < type_members.Count; ++i) {
 							var member = type_members[i];
 
 							//
 							// Methods in a base class are not candidates if any method in a derived
 							// class is applicable
 							//
 							if ((member.Modifiers & Modifiers.OVERRIDE) != 0)
 								continue;
 
 							if (!error_mode) {
 								if (!member.IsAccessible (current_type))
 									continue;
 
 								if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (current_type))
 									continue;
 							}
 
 							IParametersMember pm = member as IParametersMember;
 							if (pm == null) {
 								//
 								// Will use it later to report ambiguity between best method and invocable member
 								//
 								if (Invocation.IsMemberInvocable (member))
 									invocable_member = member;
 
 								continue;
 							}
 
 							//
 							// Overload resolution is looking for base member but using parameter names
 							// and default values from the closest member. That means to do expensive lookup
 							// for the closest override for virtual or abstract members
 							//
 							if ((member.Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 								var override_params = base_provider.GetOverrideMemberParameters (member);
 								if (override_params != null)
 									pm = override_params;
 							}
 
 							//
 							// Check if the member candidate is applicable
 							//
 							bool params_expanded_form = false;
 							bool dynamic_argument = false;
 							TypeSpec rt = pm.MemberType;
 							int candidate_rate = IsApplicable (rc, ref candidate_args, args_count, ref member, pm, ref params_expanded_form, ref dynamic_argument, ref rt);
 
 							//
 							// How does it score compare to others
 							//
 							if (candidate_rate < best_candidate_rate) {
 								best_candidate_rate = candidate_rate;
 								best_candidate = member;
 								best_candidate_args = candidate_args;
 								best_candidate_params = params_expanded_form;
 								best_candidate_dynamic = dynamic_argument;
 								best_parameter_member = pm;
 								best_candidate_return_type = rt;
 							} else if (candidate_rate == 0) {
 								//
 								// The member look is done per type for most operations but sometimes
 								// it's not possible like for binary operators overload because they
 								// are unioned between 2 sides
 								//
 								if ((restrictions & Restrictions.BaseMembersIncluded) != 0) {
 									if (TypeSpec.IsBaseClass (best_candidate.DeclaringType, member.DeclaringType, true))
 										continue;
 								}
 
 								bool is_better;
 								if (best_candidate.DeclaringType.IsInterface && member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 									//
 									// We pack all interface members into top level type which makes the overload resolution
 									// more complicated for interfaces. We accomodate for this by removing methods with same
 									// signature when building the cache hence this path should not really be hit often
 									//
 									// Example
 									// interface IA { void Foo (int arg); }
 									// interface IB 
 									//
 									// IB
 									//
 									is_better = true;
 									if (ambiguous_candidates != null) {
 										foreach (var amb_cand in ambiguous_candidates) {
 											if (member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 												continue;
 											}
 
 											is_better = false;
 											break;
 										}
 
 										if (is_better)
 											ambiguous_candidates = null;
 									}
 								} else {
 									// Is the new candidate better
 									is_better = BetterFunction (rc, candidate_args, member, pm.Parameters, params_expanded_form, best_candidate, best_parameter_member.Parameters, best_candidate_params);
 								}
 
 								if (is_better) {
 									best_candidate = member;
 									best_candidate_args = candidate_args;
 									best_candidate_params = params_expanded_form;
 									best_candidate_dynamic = dynamic_argument;
 									best_parameter_member = pm;
 									best_candidate_return_type = rt;
 								} else {
 									// It's not better but any other found later could be but we are not sure yet
 									if (ambiguous_candidates == null)
 										ambiguous_candidates = new List<AmbiguousCandidate> ();
 
 									ambiguous_candidates.Add (new AmbiguousCandidate (member, pm.Parameters, params_expanded_form));
 								}
 							}
 
 							// Restore expanded arguments
 							if (candidate_args != args)
 								candidate_args = args;
 						}
 					} while (best_candidate_rate != 0 && (type_members = base_provider.GetBaseMembers (type_members[0].DeclaringType.BaseType)) != null);
 				} finally {
 					if (prev_recorder != null)
 						rc.Report.SetPrinter (prev_recorder);
 				}
 
 				//
 				// We've found exact match
 				//
 				if (best_candidate_rate == 0)
 					break;
 
 				//
 				// Try extension methods lookup when no ordinary method match was found and provider enables it
 				//
 				if (!error_mode) {
 					var emg = base_provider.LookupExtensionMethod (rc);
 					if (emg != null) {
 						emg = emg.OverloadResolve (rc, ref args, null, restrictions);
 						if (emg != null) {
 							best_candidate_extension_group = emg;
 							return (T) (MemberSpec) emg.BestCandidate;
 						}
 					}
 				}
 
 				// Don't run expensive error reporting mode for probing
 				if (IsProbingOnly)
 					return null;
 
 				if (error_mode)
 					break;
 
 				lambda_conv_msgs = null;
 				error_mode = true;
 			}
 
 			//
 			// No best member match found, report an error
 			//
 			if (best_candidate_rate != 0 || error_mode) {
 				ReportOverloadError (rc, best_candidate, best_parameter_member, best_candidate_args, best_candidate_params);
 				return null;
 			}
 
 			if (best_candidate_dynamic) {
 				if (args[0].ArgType == Argument.AType.ExtensionType) {
 					rc.Report.Error (1973, loc,
 						"Type `{0}' does not contain a member `{1}' and the best extension method overload `{2}' cannot be dynamically dispatched. Consider calling the method without the extension method syntax",
 						args [0].Type.GetSignatureForError (), best_candidate.Name, best_candidate.GetSignatureForError ());
 				}
 
 				BestCandidateIsDynamic = true;
 				return null;
 			}
 
 			if (ambiguous_candidates != null) {
 				//
 				// Now check that there are no ambiguities i.e the selected method
 				// should be better than all the others
 				//
 				for (int ix = 0; ix < ambiguous_candidates.Count; ix++) {
 					var candidate = ambiguous_candidates [ix];
 
 					if (!BetterFunction (rc, best_candidate_args, best_candidate, best_parameter_member.Parameters, best_candidate_params, candidate.Member, candidate.Parameters, candidate.Expanded)) {
 						var ambiguous = candidate.Member;
 						if (custom_errors == null || !custom_errors.AmbiguousCandidates (rc, best_candidate, ambiguous)) {
 							rc.Report.SymbolRelatedToPreviousError (best_candidate);
 							rc.Report.SymbolRelatedToPreviousError (ambiguous);
 							rc.Report.Error (121, loc, "The call is ambiguous between the following methods or properties
 								best_candidate.GetSignatureForError (), ambiguous.GetSignatureForError ());
 						}
 
 						return (T) best_candidate;
 					}
 				}
 				for (int ix = 0; ix < ambiguous_candidates.Count; ix++) {
 					var candidate = ambiguous_candidates [ix];
 
 					if (!BetterFunction (rc, best_candidate_args, best_candidate, best_parameter_member.Parameters, best_candidate_params, candidate.Member, candidate.Parameters, candidate.Expanded)) {
 						var ambiguous = candidate.Member;
 						if (custom_errors == null || !custom_errors.AmbiguousCandidates (rc, best_candidate, ambiguous)) {
 							rc.Report.SymbolRelatedToPreviousError (best_candidate);
 							rc.Report.SymbolRelatedToPreviousError (ambiguous);
 							rc.Report.Error (121, loc, "The call is ambiguous between the following methods or properties
 								best_candidate.GetSignatureForError (), ambiguous.GetSignatureForError ());
 						}
 
 						return (T) best_candidate;
 					}
 				}
 			}
 
 			if (invocable_member != null) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.SymbolRelatedToPreviousError (invocable_member);
 				rc.Report.Warning (467, 2, loc, "Ambiguity between method `{0}' and invocable non-method `{1}'. Using method group",
 					best_candidate.GetSignatureForError (), invocable_member.GetSignatureForError ());
 			}
 
 			//
 			// And now check if the arguments are all
 			// compatible, perform conversions if
 			// necessary etc. and return if everything is
 			// all right
 			//
 			if (!VerifyArguments (rc, ref best_candidate_args, best_candidate, best_parameter_member, best_candidate_params))
 				return null;
 
 			if (best_candidate == null)
 				return null;
 
 			//
 			// Check ObsoleteAttribute on the best method
 			//
 			ObsoleteAttribute oa = best_candidate.GetAttributeObsolete ();
 			if (oa != null && !rc.IsObsolete)
 				AttributeTester.Report_ObsoleteMessage (oa, best_candidate.GetSignatureForError (), loc, rc.Report);
 
 			var dep = best_candidate.GetMissingDependencies ();
 			if (dep != null) {
 				ImportedTypeDefinition.Error_MissingDependency (rc, dep, loc);
 			}
 
 			best_candidate.MemberDefinition.SetIsUsed ();
 
 			args = best_candidate_args;
 			return (T) best_candidate;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1520" endline="1624">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			//
 			// Use same anonymous method implementation for scenarios where same
 			// code is used from multiple blocks, e.g. field initializers
 			//
 			if (method == null) {
 				//
 				// Delay an anonymous method definition to avoid emitting unused code
 				// for unreachable blocks or expression trees
 				//
 				method = DoCreateMethodHost (ec);
 				method.Define ();
 			}
 
 			bool is_static = (method.ModFlags & Modifiers.STATIC) != 0;
 			if (is_static && am_cache == null) {
 				//
 				// Creates a field cache to store delegate instance if it's not generic
 				//
 				if (!method.MemberName.IsGeneric) {
 					TypeContainer parent = method.Parent.PartialContainer;
 					int id = parent.Fields == null ? 0 
 					var cache_type = storey != null && storey.Mutator != null ? storey.Mutator.Mutate (type) 
 
 					am_cache = new Field (parent, new TypeExpression (cache_type, loc),
 						Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.COMPILER_GENERATED,
 						new MemberName (CompilerGeneratedClass.MakeName (null, "f", "am$cache", id), loc), null);
 					am_cache.Define ();
 					parent.AddField (am_cache);
 				} else {
 					// TODO
 					//
 					// Idea
 					//
 					// Some extra class is needed to capture variable generic type
 					// arguments. Maybe we could re-use anonymous types, with a unique
 					// anonymous method id, but they are quite heavy.
 					//
 					// Consider 
 					//
 					// We need something like
 					// static class Wrap<Tn, Tm, DelegateType> {
 					//		public static DelegateType cache;
 					// }
 					//
 					// We then specialize local variable to capture all generic parameters
 					// and delegate type, e.g. "Wrap<Ta, Tb, DelegateTypeInst> cache;"
 					//
 				}
 			}
 
 			Label l_initialized = ec.DefineLabel ();
 
 			if (am_cache != null) {
 				ec.Emit (OpCodes.Ldsfld, am_cache.Spec);
 				ec.Emit (OpCodes.Brtrue_S, l_initialized);
 			}
 
 			//
 			// Load method delegate implementation
 			//
 
 			if (is_static) {
 				ec.Emit (OpCodes.Ldnull);
 			} else if (storey != null) {
 				Expression e = storey.GetStoreyInstanceExpression (ec).Resolve (new ResolveContext (ec.MemberContext));
 				if (e != null)
 					e.Emit (ec);
 			} else {
 				ec.Emit (OpCodes.Ldarg_0);
 			}
 
 			var delegate_method = method.Spec;
 			if (storey != null && storey.MemberName.IsGeneric) {
 				TypeSpec t = storey.Instance.Type;
 
 				//
 				// Mutate anonymous method instance type if we are in nested
 				// hoisted generic anonymous method storey
 				//
 				if (ec.CurrentAnonymousMethod != null &&
 					ec.CurrentAnonymousMethod.Storey != null &&
 					ec.CurrentAnonymousMethod.Storey.Mutator != null) {
 					t = storey.Mutator.Mutate (t);
 				}
 
 				ec.Emit (OpCodes.Ldftn, TypeBuilder.GetMethod (t.GetMetaInfo (), (MethodInfo) delegate_method.GetMetaInfo ()));
 			} else {
 				if (delegate_method.IsGeneric)
 					delegate_method = delegate_method.MakeGenericMethod (method.TypeParameters);
 
 				ec.Emit (OpCodes.Ldftn, delegate_method);
 			}
 
 			var constructor_method = Delegate.GetConstructor (ec.MemberContext.Compiler, ec.CurrentType, type);
 			ec.Emit (OpCodes.Newobj, constructor_method);
 
 			if (am_cache != null) {
 				ec.Emit (OpCodes.Stsfld, am_cache.Spec);
 				ec.MarkLabel (l_initialized);
 				ec.Emit (OpCodes.Ldsfld, am_cache.Spec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1991" endline="2108">
<![CDATA[
 
 		bool CheckConstraint (MemberSpec context, TypeSpec atype, TypeParameterSpec tparam, Location loc)
 		{
 			//
 			// First, check the `class' and `struct' constraints.
 			//
 			if (tparam.HasSpecialClass && !TypeManager.IsReferenceType (atype)) {
 				if (mc != null) {
 					mc.Compiler.Report.Error (452, loc,
 						"The type `{0}' must be a reference type in order to use it as type parameter `{1}' in the generic type or method `{2}'",
 						TypeManager.CSharpName (atype), tparam.GetSignatureForError (), context.GetSignatureForError ());
 				}
 
 				return false;
 			}
 
 			if (tparam.HasSpecialStruct && (!TypeManager.IsValueType (atype) || TypeManager.IsNullableType (atype))) {
 				if (mc != null) {
 					mc.Compiler.Report.Error (453, loc,
 						"The type `{0}' must be a non-nullable value type in order to use it as type parameter `{1}' in the generic type or method `{2}'",
 						TypeManager.CSharpName (atype), tparam.GetSignatureForError (), context.GetSignatureForError ());
 				}
 
 				return false;
 			}
 
 			bool ok = true;
 
 			//
 			// Check the class constraint
 			//
 			if (tparam.HasTypeConstraint) {
 				var dep = tparam.BaseType.GetMissingDependencies ();
 				if (dep != null) {
 					if (mc == null)
 						return false;
 
 					ImportedTypeDefinition.Error_MissingDependency (mc, dep, loc);
 					ok = false;
 				}
 
 				if (!CheckConversion (mc, context, atype, tparam, tparam.BaseType, loc)) {
 					if (mc == null)
 						return false;
 
 					ok = false;
 				}
 			}
 
 			//
 			// Check the interfaces constraints
 			//
 			if (tparam.Interfaces != null) {
 				if (TypeManager.IsNullableType (atype)) {
 					if (mc == null)
 						return false;
 
 					mc.Compiler.Report.Error (313, loc,
 						"The type `{0}' cannot be used as type parameter `{1}' in the generic type or method `{2}'. The nullable type `{0}' never satisfies interface constraint",
 						atype.GetSignatureForError (), tparam.GetSignatureForError (), context.GetSignatureForError ());
 					ok = false;
 				} else {
 					foreach (TypeSpec iface in tparam.Interfaces) {
 						var dep = iface.GetMissingDependencies ();
 						if (dep != null) {
 							if (mc == null)
 								return false;
 
 							ImportedTypeDefinition.Error_MissingDependency (mc, dep, loc);
 							ok = false;
 
 							// return immediately to avoid duplicate errors because we are scanning
 							// expanded interface list
 							return false;
 						}
 
 						if (!CheckConversion (mc, context, atype, tparam, iface, loc)) {
 							if (mc == null)
 								return false;
 
 							ok = false;
 						}
 					}
 					foreach (TypeSpec iface in tparam.Interfaces) {
 						var dep = iface.GetMissingDependencies ();
 						if (dep != null) {
 							if (mc == null)
 								return false;
 
 							ImportedTypeDefinition.Error_MissingDependency (mc, dep, loc);
 							ok = false;
 
 							// return immediately to avoid duplicate errors because we are scanning
 							// expanded interface list
 							return false;
 						}
 
 						if (!CheckConversion (mc, context, atype, tparam, iface, loc)) {
 							if (mc == null)
 								return false;
 
 							ok = false;
 						}
 					}
 				}
 			}
 
 			//
 			// Check the type parameter constraint
 			//
 			if (tparam.TypeArguments != null) {
 				foreach (var ta in tparam.TypeArguments) {
 					if (!CheckConversion (mc, context, atype, tparam, ta, loc)) {
 						if (mc == null)
 							return false;
 
 						ok = false;
 					}
 				}
 				foreach (var ta in tparam.TypeArguments) {
 					if (!CheckConversion (mc, context, atype, tparam, ta, loc)) {
 						if (mc == null)
 							return false;
 
 						ok = false;
 					}
 				}
 			}
 
 			//
 			// Finally, check the constructor constraint.
 			//
 			if (!tparam.HasSpecialConstructor)
 				return ok;
 
 			if (!HasDefaultConstructor (atype)) {
 				if (mc != null) {
 					mc.Compiler.Report.SymbolRelatedToPreviousError (atype);
 					mc.Compiler.Report.Error (310, loc,
 						"The type `{0}' must have a public parameterless constructor in order to use it as parameter `{1}' in the generic type or method `{2}'",
 						TypeManager.CSharpName (atype), tparam.GetSignatureForError (), context.GetSignatureForError ());
 				}
 				return false;
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="458" endline="466">
<![CDATA[
 		}
 
 		public CompilationUnit CompilationUnit {
 			get {
 				int index = CompilationUnitIndex;
 				if (index == 0)
 					return null;
 				return (CompilationUnit) source_list [index - 1];
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1867" endline="1885">
<![CDATA[
 
 		//
 		// Checks the constraints of open generic type against type
 		// arguments. Has to be called after all members have been defined
 		//
 		public bool CheckConstraints (IMemberContext ec)
 		{
 			if (constraints_checked)
 				return true;
 
 			constraints_checked = true;
 
 			var gtype = (InflatedTypeSpec) type;
 			var constraints = gtype.Constraints;
 			if (constraints == null)
 				return true;
 
 			return new ConstraintChecker(ec).CheckAll (open_type, args.Arguments, constraints, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1746" endline="1943">
<![CDATA[
 
 		public void LoadMembers (TypeSpec declaringType, bool onlyTypes, ref MemberCache cache)
 		{
 			//
 			// Not interested in members of nested private types unless the importer needs them
 			//
 			if (declaringType.IsPrivate && importer.IgnorePrivateMembers) {
 				cache = MemberCache.Empty;
 				return;
 			}
 
 			var loading_type = (MetaType) provider;
 			const BindingFlags all_members = BindingFlags.DeclaredOnly |
 				BindingFlags.Static | BindingFlags.Instance |
 				BindingFlags.Public | BindingFlags.NonPublic;
 
 			const MethodAttributes explicit_impl = MethodAttributes.NewSlot |
 					MethodAttributes.Virtual | MethodAttributes.HideBySig |
 					MethodAttributes.Final;
 
 			Dictionary<MethodBase, MethodSpec> possible_accessors = null;
 			List<EventSpec> imported_events = null;
 			EventSpec event_spec;
 			MemberSpec imported;
 			MethodInfo m;
 			MemberInfo[] all;
 			try {
 				all = loading_type.GetMembers (all_members);
 			} catch (Exception e) {
 				throw new InternalErrorException (e, "Could not import type `{0}' from `{1}'",
 					declaringType.GetSignatureForError (), declaringType.MemberDefinition.DeclaringAssembly.FullName);
 			}
 
 			if (cache == null) {
 				cache = new MemberCache (all.Length);
 
 				//
 				// Do the types first as they can be referenced by the members before
 				// they are found or inflated
 				//
 				foreach (var member in all) {
 					if (member.MemberType != MemberTypes.NestedType)
 						continue;
 
 					var t = (MetaType) member;
 
 					// Ignore compiler generated types, mostly lambda containers
 					if ((t.Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate && importer.IgnorePrivateMembers)
 						continue;
 
 					imported = importer.CreateNestedType (t, declaringType);
 					cache.AddMember (imported);
 				}
 				foreach (var member in all) {
 					if (member.MemberType != MemberTypes.NestedType)
 						continue;
 
 					var t = (MetaType) member;
 
 					// Ignore compiler generated types, mostly lambda containers
 					if ((t.Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate && importer.IgnorePrivateMembers)
 						continue;
 
 					imported = importer.CreateNestedType (t, declaringType);
 					cache.AddMember (imported);
 				}
 
 				foreach (var member in all) {
 					if (member.MemberType != MemberTypes.NestedType)
 						continue;
 
 					var t = (MetaType) member;
 
 					if ((t.Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate && importer.IgnorePrivateMembers)
 						continue;
 
 					importer.ImportTypeBase (t);
 				}
 				foreach (var member in all) {
 					if (member.MemberType != MemberTypes.NestedType)
 						continue;
 
 					var t = (MetaType) member;
 
 					if ((t.Attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate && importer.IgnorePrivateMembers)
 						continue;
 
 					importer.ImportTypeBase (t);
 				}
 			}
 
 			if (!onlyTypes) {
 				//
 				// The logic here requires methods to be returned first which seems to work for both Mono and .NET
 				//
 				foreach (var member in all) {
 					switch (member.MemberType) {
 					case MemberTypes.Constructor
 					case MemberTypes.Method
 						MethodBase mb = (MethodBase) member;
 						var attrs = mb.Attributes;
 
 						if ((attrs & MethodAttributes.MemberAccessMask) == MethodAttributes.Private) {
 							if (importer.IgnorePrivateMembers)
 								continue;
 
 							// Ignore explicitly implemented members
 							if ((attrs & explicit_impl) == explicit_impl)
 								continue;
 
 							// Ignore compiler generated methods
 							if (importer.HasAttribute (CustomAttributeData.GetCustomAttributes (mb), "CompilerGeneratedAttribute", MetadataImporter.CompilerServicesNamespace))
 								continue;
 						}
 
 						imported = importer.CreateMethod (mb, declaringType);
 						if (imported.Kind == MemberKind.Method && !imported.IsGeneric) {
 							if (possible_accessors == null)
 								possible_accessors = new Dictionary<MethodBase, MethodSpec> (ReferenceEquality<MethodBase>.Default);
 
 							// There are no metadata rules for accessors, we have to consider any method as possible candidate
 							possible_accessors.Add (mb, (MethodSpec) imported);
 						}
 
 						break;
 					case MemberTypes.Property
 						if (possible_accessors == null)
 							continue;
 
 						var p = (PropertyInfo) member;
 						//
 						// Links possible accessors with property
 						//
 						MethodSpec get, set;
 						m = p.GetGetMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out get))
 							get = null;
 
 						m = p.GetSetMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out set))
 							set = null;
 
 						// No accessors registered (e.g. explicit implementation)
 						if (get == null && set == null)
 							continue;
 
 						imported = importer.CreateProperty (p, declaringType, get, set);
 						if (imported == null)
 							continue;
 
 						break;
 					case MemberTypes.Event
 						if (possible_accessors == null)
 							continue;
 
 						var e = (EventInfo) member;
 						//
 						// Links accessors with event
 						//
 						MethodSpec add, remove;
 						m = e.GetAddMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out add))
 							add = null;
 
 						m = e.GetRemoveMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out remove))
 							remove = null;
 
 						// Both accessors are required
 						if (add == null || remove == null)
 							continue;
 
 						event_spec = importer.CreateEvent (e, declaringType, add, remove);
 						if (!importer.IgnorePrivateMembers) {
 							if (imported_events == null)
 								imported_events = new List<EventSpec> ();
 
 							imported_events.Add (event_spec);
 						}
 
 						imported = event_spec;
 						break;
 					case MemberTypes.Field
 						var fi = (FieldInfo) member;
 
 						imported = importer.CreateField (fi, declaringType);
 						if (imported == null)
 							continue;
 
 						//
 						// For dynamic binder event has to be fully restored to allow operations
 						// within the type container to work correctly
 						//
 						if (imported_events != null) {
 							// The backing event field should be private but it may not
 							int index = imported_events.FindIndex (l => l.Name == fi.Name);
 							if (index >= 0) {
 								event_spec = imported_events[index];
 								event_spec.BackingField = (FieldSpec) imported;
 								imported_events.RemoveAt (index);
 								continue;
 							}
 						}
 
 						break;
 					case MemberTypes.NestedType
 						// Already in the cache from the first pass
 						continue;
 					default
 						throw new NotImplementedException (member.ToString ());
 					}
 
 					cache.AddMember (imported);
 				}
 				foreach (var member in all) {
 					switch (member.MemberType) {
 					case MemberTypes.Constructor
 					case MemberTypes.Method
 						MethodBase mb = (MethodBase) member;
 						var attrs = mb.Attributes;
 
 						if ((attrs & MethodAttributes.MemberAccessMask) == MethodAttributes.Private) {
 							if (importer.IgnorePrivateMembers)
 								continue;
 
 							// Ignore explicitly implemented members
 							if ((attrs & explicit_impl) == explicit_impl)
 								continue;
 
 							// Ignore compiler generated methods
 							if (importer.HasAttribute (CustomAttributeData.GetCustomAttributes (mb), "CompilerGeneratedAttribute", MetadataImporter.CompilerServicesNamespace))
 								continue;
 						}
 
 						imported = importer.CreateMethod (mb, declaringType);
 						if (imported.Kind == MemberKind.Method && !imported.IsGeneric) {
 							if (possible_accessors == null)
 								possible_accessors = new Dictionary<MethodBase, MethodSpec> (ReferenceEquality<MethodBase>.Default);
 
 							// There are no metadata rules for accessors, we have to consider any method as possible candidate
 							possible_accessors.Add (mb, (MethodSpec) imported);
 						}
 
 						break;
 					case MemberTypes.Property
 						if (possible_accessors == null)
 							continue;
 
 						var p = (PropertyInfo) member;
 						//
 						// Links possible accessors with property
 						//
 						MethodSpec get, set;
 						m = p.GetGetMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out get))
 							get = null;
 
 						m = p.GetSetMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out set))
 							set = null;
 
 						// No accessors registered (e.g. explicit implementation)
 						if (get == null && set == null)
 							continue;
 
 						imported = importer.CreateProperty (p, declaringType, get, set);
 						if (imported == null)
 							continue;
 
 						break;
 					case MemberTypes.Event
 						if (possible_accessors == null)
 							continue;
 
 						var e = (EventInfo) member;
 						//
 						// Links accessors with event
 						//
 						MethodSpec add, remove;
 						m = e.GetAddMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out add))
 							add = null;
 
 						m = e.GetRemoveMethod (true);
 						if (m == null || !possible_accessors.TryGetValue (m, out remove))
 							remove = null;
 
 						// Both accessors are required
 						if (add == null || remove == null)
 							continue;
 
 						event_spec = importer.CreateEvent (e, declaringType, add, remove);
 						if (!importer.IgnorePrivateMembers) {
 							if (imported_events == null)
 								imported_events = new List<EventSpec> ();
 
 							imported_events.Add (event_spec);
 						}
 
 						imported = event_spec;
 						break;
 					case MemberTypes.Field
 						var fi = (FieldInfo) member;
 
 						imported = importer.CreateField (fi, declaringType);
 						if (imported == null)
 							continue;
 
 						//
 						// For dynamic binder event has to be fully restored to allow operations
 						// within the type container to work correctly
 						//
 						if (imported_events != null) {
 							// The backing event field should be private but it may not
 							int index = imported_events.FindIndex (l => l.Name == fi.Name);
 							if (index >= 0) {
 								event_spec = imported_events[index];
 								event_spec.BackingField = (FieldSpec) imported;
 								imported_events.RemoveAt (index);
 								continue;
 							}
 						}
 
 						break;
 					case MemberTypes.NestedType
 						// Already in the cache from the first pass
 						continue;
 					default
 						throw new NotImplementedException (member.ToString ());
 					}
 
 					cache.AddMember (imported);
 				}
 			}
 
 			if (declaringType.IsInterface && declaringType.Interfaces != null) {
 				foreach (var iface in declaringType.Interfaces) {
 					cache.AddInterface (iface);
 				}
 				foreach (var iface in declaringType.Interfaces) {
 					cache.AddInterface (iface);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7619" endline="7794">
<![CDATA[
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			var sn = expr as SimpleName;
 			const ResolveFlags flags = ResolveFlags.VariableOrValue | ResolveFlags.Type;
 
 			//
 			// Resolve the expression with flow analysis turned off, we'll do the definite
 			// assignment checks later.  This is because we don't know yet what the expression
 			// will resolve to - it may resolve to a FieldExpr and in this case we must do the
 			// definite assignment check on the actual field and not on the whole struct.
 			//
 			using (rc.Set (ResolveContext.Options.OmitStructFlowAnalysis)) {
 				if (sn != null) {
 					expr = sn.LookupNameExpression (rc, MemberLookupRestrictions.ReadAccess | MemberLookupRestrictions.ExactArity);
 
 					// Call resolve on expression which does have type set as we need expression type
 					// TODO
 					if (expr is VariableReference || expr is ConstantExpr || expr is Linq.TransparentMemberAccess) {
 						using (rc.With (ResolveContext.Options.DoFlowAnalysis, false)) {
 							expr = expr.Resolve (rc);
 						}
 					} else if (expr is TypeParameterExpr) {
 						expr.Error_UnexpectedKind (rc, flags, sn.Location);
 						expr = null;
 					}
 				} else {
 					expr = expr.Resolve (rc, flags);
 				}
 			}
 
 			if (expr == null)
 				return null;
 
 			Namespace ns = expr as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 					return null;
 				}
 
 				if (HasTypeArguments)
 					return new GenericTypeExpr (retval.Type, targs, loc);
 
 				return retval;
 			}
 
 			MemberExpr me;
 			TypeSpec expr_type = expr.Type;
 			if (expr_type == InternalType.Dynamic) {
 				me = expr as MemberExpr;
 				if (me != null)
 					me.ResolveInstanceExpression (rc, null);
 
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return new DynamicMemberBinder (Name, args, loc);
 			}
 
 			const MemberKind dot_kinds = MemberKind.Class | MemberKind.Struct | MemberKind.Delegate | MemberKind.Enum |
 				MemberKind.Interface | MemberKind.TypeParameter | MemberKind.ArrayType;
 
 			if ((expr_type.Kind & dot_kinds) == 0 || expr_type == TypeManager.void_type) {
 				if (expr_type == InternalType.Null && rc.Compiler.IsRuntimeBinder)
 					rc.Report.Error (Report.RuntimeErrorId, loc, "Cannot perform member binding on `null' value");
 				else
 					Unary.Error_OperatorCannotBeApplied (rc, loc, ".", expr_type);
 				return null;
 			}
 
 			var current_type = rc.CurrentType;
 			var lookup_arity = Arity;
 			bool errorMode = false;
 			Expression member_lookup;
 			while (true) {
 				member_lookup = MemberLookup (errorMode ? null 
 				if (member_lookup == null) {
 					//
 					// Try to look for extension method when member lookup failed
 					//
 					if (MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 						NamespaceEntry scope = null;
 						var methods = rc.LookupExtensionMethod (expr_type, Name, lookup_arity, ref scope);
 						if (methods != null) {
 							var emg = new ExtensionMethodGroupExpr (methods, scope, expr, loc);
 							if (HasTypeArguments) {
 								if (!targs.Resolve (rc))
 									return null;
 
 								emg.SetTypeArguments (rc, targs);
 							}
 
 							// TODO
 							return emg.Resolve (rc);
 						}
 					}
 				}
 
 				if (errorMode) {
 					if (member_lookup == null) {
 						if (expr is TypeExpr)
 							base.Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 						else
 							Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 
 						return null;
 					}
 
 					if (member_lookup is MethodGroupExpr) {
 						// Leave it to overload resolution to report correct error
 					} else {
 						// TODO
 						ErrorIsInaccesible (rc, member_lookup.GetSignatureForError (), loc);
 					}
 					break;
 				}
 
 				if (member_lookup != null)
 					break;
 
 				current_type = null;
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 			while (true) {
 				member_lookup = MemberLookup (errorMode ? null 
 				if (member_lookup == null) {
 					//
 					// Try to look for extension method when member lookup failed
 					//
 					if (MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 						NamespaceEntry scope = null;
 						var methods = rc.LookupExtensionMethod (expr_type, Name, lookup_arity, ref scope);
 						if (methods != null) {
 							var emg = new ExtensionMethodGroupExpr (methods, scope, expr, loc);
 							if (HasTypeArguments) {
 								if (!targs.Resolve (rc))
 									return null;
 
 								emg.SetTypeArguments (rc, targs);
 							}
 
 							// TODO
 							return emg.Resolve (rc);
 						}
 					}
 				}
 
 				if (errorMode) {
 					if (member_lookup == null) {
 						if (expr is TypeExpr)
 							base.Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 						else
 							Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 
 						return null;
 					}
 
 					if (member_lookup is MethodGroupExpr) {
 						// Leave it to overload resolution to report correct error
 					} else {
 						// TODO
 						ErrorIsInaccesible (rc, member_lookup.GetSignatureForError (), loc);
 					}
 					break;
 				}
 
 				if (member_lookup != null)
 					break;
 
 				current_type = null;
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 
 			TypeExpr texpr = member_lookup as TypeExpr;
 			if (texpr != null) {
 				if (!(expr is TypeExpr)) {
 					me = expr as MemberExpr;
 					if (me == null || me.ProbeIdenticalTypeName (rc, expr, sn) == expr) {
 						rc.Report.Error (572, loc, "`{0}'
 							Name, member_lookup.GetSignatureForError ());
 						return null;
 					}
 				}
 
 				if (!texpr.Type.IsAccessible (rc.CurrentType)) {
 					rc.Report.SymbolRelatedToPreviousError (member_lookup.Type);
 					ErrorIsInaccesible (rc, member_lookup.Type.GetSignatureForError (), loc);
 					return null;
 				}
 
 				if (HasTypeArguments) {
 					return new GenericTypeExpr (member_lookup.Type, targs, loc);
 				}
 
 				return member_lookup;
 			}
 
 			me = member_lookup as MemberExpr;
 
 			if (sn != null && me.IsStatic)
 				expr = me.ProbeIdenticalTypeName (rc, expr, sn);
 
 			me = me.ResolveMemberAccess (rc, expr, sn);
 
 			if (Arity > 0) {
 				if (!targs.Resolve (rc))
 					return null;
 
 				me.SetTypeArguments (rc, targs);
 			}
 
 			if (sn != null && (!TypeManager.IsValueType (expr_type) || me is PropertyExpr)) {
 				if (me.IsInstance) {
 					LocalVariableReference var = expr as LocalVariableReference;
 					if (var != null && !var.VerifyAssigned (rc))
 						return null;
 				}
 			}
 
 			return me;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="676" endline="711">
<![CDATA[
 		}
 
 		/// <summary>
 		/// Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
 		/// </summary>
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.Excluded) != 0)
 				return new string [0];
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 			string[] conditions;
 
 			if (base_method == null) {
 				if (OptAttributes == null)
 					return null;
 
 				Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 				if (attrs == null)
 					return null;
 
 				conditions = new string[attrs.Length];
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			} else {
 				conditions = base_method.MemberDefinition.ConditionalConditions();
 			}
 
 			if (conditions != null)
 				caching_flags |= Flags.Excluded;
 
 			return conditions;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="540" endline="637">
<![CDATA[
 
 		//
 		// Checks whether the type P is as accessible as this member
 		//
 		public bool IsAccessibleAs (TypeSpec p)
 		{
 			//
 			// if M is private, its accessibility is the same as this declspace.
 			// we already know that P is accessible to T before this method, so we
 			// may return true.
 			//
 			if ((mod_flags & Modifiers.PRIVATE) != 0)
 				return true;
 
 			while (TypeManager.HasElementType (p))
 				p = TypeManager.GetElementType (p);
 			while (TypeManager.HasElementType (p))
 				p = TypeManager.GetElementType (p);
 
 			if (p.IsGenericParameter)
 				return true;
 
 			for (TypeSpec p_parent; p != null; p = p_parent) {
 				p_parent = p.DeclaringType;
 
 				if (p.IsGeneric) {
 					foreach (TypeSpec t in p.TypeArguments) {
 						if (!IsAccessibleAs (t))
 							return false;
 					}
 					foreach (TypeSpec t in p.TypeArguments) {
 						if (!IsAccessibleAs (t))
 							return false;
 					}
 				}
 
 				var pAccess = p.Modifiers & Modifiers.AccessibilityMask;
 				if (pAccess == Modifiers.PUBLIC)
 					continue;
 
 				bool same_access_restrictions = false;
 				for (MemberCore mc = this; !same_access_restrictions && mc != null && mc.Parent != null; mc = mc.Parent) {
 					var al = mc.ModFlags & Modifiers.AccessibilityMask;
 					switch (pAccess) {
 					case Modifiers.INTERNAL
 						if (al == Modifiers.PRIVATE || al == Modifiers.INTERNAL)
 							same_access_restrictions = p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						
 						break;
 
 					case Modifiers.PROTECTED
 						if (al == Modifiers.PROTECTED) {
 							same_access_restrictions = mc.Parent.IsBaseTypeDefinition (p_parent);
 							break;
 						}
 
 						if (al == Modifiers.PRIVATE) {
 							//
 							// When type is private and any of its parents derives from
 							// protected type then the type is accessible
 							//
 							while (mc.Parent != null) {
 								if (mc.Parent.IsBaseTypeDefinition (p_parent))
 									same_access_restrictions = true;
 								mc = mc.Parent; 
 							}
 							while (mc.Parent != null) {
 								if (mc.Parent.IsBaseTypeDefinition (p_parent))
 									same_access_restrictions = true;
 								mc = mc.Parent; 
 							}
 						}
 						
 						break;
 
 					case Modifiers.PROTECTED | Modifiers.INTERNAL
 						if (al == Modifiers.INTERNAL)
 							same_access_restrictions = p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						else if (al == (Modifiers.PROTECTED | Modifiers.INTERNAL))
 							same_access_restrictions = mc.Parent.IsBaseTypeDefinition (p_parent) && p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						else
 							goto case Modifiers.PROTECTED;
 
 						break;
 
 					case Modifiers.PRIVATE
 						//
 						// Both are private and share same parent
 						//
 						if (al == Modifiers.PRIVATE) {
 							var decl = mc.Parent;
 							do {
 								same_access_restrictions = decl.CurrentType == p_parent;
 							} while (!same_access_restrictions && !decl.IsTopLevel && (decl = decl.Parent) != null);
 						}
 						
 						break;
 						
 					default
 						throw new InternalErrorException (al.ToString ());
 					}
 				}
 				for (MemberCore mc = this; !same_access_restrictions && mc != null && mc.Parent != null; mc = mc.Parent) {
 					var al = mc.ModFlags & Modifiers.AccessibilityMask;
 					switch (pAccess) {
 					case Modifiers.INTERNAL
 						if (al == Modifiers.PRIVATE || al == Modifiers.INTERNAL)
 							same_access_restrictions = p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						
 						break;
 
 					case Modifiers.PROTECTED
 						if (al == Modifiers.PROTECTED) {
 							same_access_restrictions = mc.Parent.IsBaseTypeDefinition (p_parent);
 							break;
 						}
 
 						if (al == Modifiers.PRIVATE) {
 							//
 							// When type is private and any of its parents derives from
 							// protected type then the type is accessible
 							//
 							while (mc.Parent != null) {
 								if (mc.Parent.IsBaseTypeDefinition (p_parent))
 									same_access_restrictions = true;
 								mc = mc.Parent; 
 							}
 						}
 						
 						break;
 
 					case Modifiers.PROTECTED | Modifiers.INTERNAL
 						if (al == Modifiers.INTERNAL)
 							same_access_restrictions = p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						else if (al == (Modifiers.PROTECTED | Modifiers.INTERNAL))
 							same_access_restrictions = mc.Parent.IsBaseTypeDefinition (p_parent) && p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						else
 							goto case Modifiers.PROTECTED;
 
 						break;
 
 					case Modifiers.PRIVATE
 						//
 						// Both are private and share same parent
 						//
 						if (al == Modifiers.PRIVATE) {
 							var decl = mc.Parent;
 							do {
 								same_access_restrictions = decl.CurrentType == p_parent;
 							} while (!same_access_restrictions && !decl.IsTopLevel && (decl = decl.Parent) != null);
 						}
 						
 						break;
 						
 					default
 						throw new InternalErrorException (al.ToString ());
 					}
 				}
 				
 				if (!same_access_restrictions)
 					return false;
 			}
 			for (TypeSpec p_parent; p != null; p = p_parent) {
 				p_parent = p.DeclaringType;
 
 				if (p.IsGeneric) {
 					foreach (TypeSpec t in p.TypeArguments) {
 						if (!IsAccessibleAs (t))
 							return false;
 					}
 				}
 
 				var pAccess = p.Modifiers & Modifiers.AccessibilityMask;
 				if (pAccess == Modifiers.PUBLIC)
 					continue;
 
 				bool same_access_restrictions = false;
 				for (MemberCore mc = this; !same_access_restrictions && mc != null && mc.Parent != null; mc = mc.Parent) {
 					var al = mc.ModFlags & Modifiers.AccessibilityMask;
 					switch (pAccess) {
 					case Modifiers.INTERNAL
 						if (al == Modifiers.PRIVATE || al == Modifiers.INTERNAL)
 							same_access_restrictions = p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						
 						break;
 
 					case Modifiers.PROTECTED
 						if (al == Modifiers.PROTECTED) {
 							same_access_restrictions = mc.Parent.IsBaseTypeDefinition (p_parent);
 							break;
 						}
 
 						if (al == Modifiers.PRIVATE) {
 							//
 							// When type is private and any of its parents derives from
 							// protected type then the type is accessible
 							//
 							while (mc.Parent != null) {
 								if (mc.Parent.IsBaseTypeDefinition (p_parent))
 									same_access_restrictions = true;
 								mc = mc.Parent; 
 							}
 						}
 						
 						break;
 
 					case Modifiers.PROTECTED | Modifiers.INTERNAL
 						if (al == Modifiers.INTERNAL)
 							same_access_restrictions = p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						else if (al == (Modifiers.PROTECTED | Modifiers.INTERNAL))
 							same_access_restrictions = mc.Parent.IsBaseTypeDefinition (p_parent) && p.MemberDefinition.IsInternalAsPublic (mc.Module.DeclaringAssembly);
 						else
 							goto case Modifiers.PROTECTED;
 
 						break;
 
 					case Modifiers.PRIVATE
 						//
 						// Both are private and share same parent
 						//
 						if (al == Modifiers.PRIVATE) {
 							var decl = mc.Parent;
 							do {
 								same_access_restrictions = decl.CurrentType == p_parent;
 							} while (!same_access_restrictions && !decl.IsTopLevel && (decl = decl.Parent) != null);
 						}
 						
 						break;
 						
 					default
 						throw new InternalErrorException (al.ToString ());
 					}
 				}
 				
 				if (!same_access_restrictions)
 					return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2756" endline="2884">
<![CDATA[
 
 		//
 		// 26.3.3.10 Fixing
 		//
 		public bool FixType (ResolveContext ec, int i)
 		{
 			// It's already fixed
 			if (fixed_types[i] != null)
 				throw new InternalErrorException ("Type argument has been already fixed");
 
 			if (failed)
 				return false;
 
 			var candidates = bounds [i];
 			if (candidates == null)
 				return false;
 
 			if (candidates.Count == 1) {
 				TypeSpec t = candidates[0].Type;
 				if (t == InternalType.Null)
 					return false;
 
 				fixed_types [i] = t;
 				return true;
 			}
 
 			//
 			// Determines a unique type from which there is
 			// a standard implicit conversion to all the other
 			// candidate types.
 			//
 			TypeSpec best_candidate = null;
 			int cii;
 			int candidates_count = candidates.Count;
 			for (int ci = 0; ci < candidates_count; ++ci) {
 				BoundInfo bound = candidates [ci];
 				for (cii = 0; cii < candidates_count; ++cii) {
 					if (cii == ci)
 						continue;
 
 					BoundInfo cbound = candidates[cii];
 					
 					// Same type parameters with different bounds
 					if (cbound.Type == bound.Type) {
 						if (bound.Kind != BoundKind.Exact)
 							bound = cbound;
 
 						continue;
 					}
 
 					if (bound.Kind == BoundKind.Exact || cbound.Kind == BoundKind.Exact) {
 						if (cbound.Kind == BoundKind.Lower) {
 							if (!Convert.ImplicitConversionExists (ec, cbound.GetTypeExpression (), bound.Type)) {
 								break;
 							}
 
 							continue;
 						}
 						if (cbound.Kind == BoundKind.Upper) {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							continue;
 						}
 						
 						if (bound.Kind != BoundKind.Exact) {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							bound = cbound;
 							continue;
 						}
 						
 						break;
 					}
 
 					if (bound.Kind == BoundKind.Lower) {
 						if (cbound.Kind == BoundKind.Lower) {
 							if (!Convert.ImplicitConversionExists (ec, cbound.GetTypeExpression (), bound.Type)) {
 								break;
 							}
 						} else {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							bound = cbound;
 						}
 
 						continue;
 					}
 
 					if (bound.Kind == BoundKind.Upper) {
 						if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 							break;
 						}
 					} else {
 						throw new NotImplementedException ("variance conversion");
 					}
 				}
 				for (cii = 0; cii < candidates_count; ++cii) {
 					if (cii == ci)
 						continue;
 
 					BoundInfo cbound = candidates[cii];
 					
 					// Same type parameters with different bounds
 					if (cbound.Type == bound.Type) {
 						if (bound.Kind != BoundKind.Exact)
 							bound = cbound;
 
 						continue;
 					}
 
 					if (bound.Kind == BoundKind.Exact || cbound.Kind == BoundKind.Exact) {
 						if (cbound.Kind == BoundKind.Lower) {
 							if (!Convert.ImplicitConversionExists (ec, cbound.GetTypeExpression (), bound.Type)) {
 								break;
 							}
 
 							continue;
 						}
 						if (cbound.Kind == BoundKind.Upper) {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							continue;
 						}
 						
 						if (bound.Kind != BoundKind.Exact) {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							bound = cbound;
 							continue;
 						}
 						
 						break;
 					}
 
 					if (bound.Kind == BoundKind.Lower) {
 						if (cbound.Kind == BoundKind.Lower) {
 							if (!Convert.ImplicitConversionExists (ec, cbound.GetTypeExpression (), bound.Type)) {
 								break;
 							}
 						} else {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							bound = cbound;
 						}
 
 						continue;
 					}
 
 					if (bound.Kind == BoundKind.Upper) {
 						if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 							break;
 						}
 					} else {
 						throw new NotImplementedException ("variance conversion");
 					}
 				}
 
 				if (cii != candidates_count)
 					continue;
 
 				//
 				// We already have the best candidate, break if thet are different
 				//
 				// Dynamic is never ambiguous as we prefer dynamic over other best candidate types
 				//
 				if (best_candidate != null) {
 
 					if (best_candidate == InternalType.Dynamic)
 						continue;
 
 					if (bound.Type != InternalType.Dynamic && best_candidate != bound.Type)
 						return false;
 				}
 
 				best_candidate = bound.Type;
 			}
 			for (int ci = 0; ci < candidates_count; ++ci) {
 				BoundInfo bound = candidates [ci];
 				for (cii = 0; cii < candidates_count; ++cii) {
 					if (cii == ci)
 						continue;
 
 					BoundInfo cbound = candidates[cii];
 					
 					// Same type parameters with different bounds
 					if (cbound.Type == bound.Type) {
 						if (bound.Kind != BoundKind.Exact)
 							bound = cbound;
 
 						continue;
 					}
 
 					if (bound.Kind == BoundKind.Exact || cbound.Kind == BoundKind.Exact) {
 						if (cbound.Kind == BoundKind.Lower) {
 							if (!Convert.ImplicitConversionExists (ec, cbound.GetTypeExpression (), bound.Type)) {
 								break;
 							}
 
 							continue;
 						}
 						if (cbound.Kind == BoundKind.Upper) {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							continue;
 						}
 						
 						if (bound.Kind != BoundKind.Exact) {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							bound = cbound;
 							continue;
 						}
 						
 						break;
 					}
 
 					if (bound.Kind == BoundKind.Lower) {
 						if (cbound.Kind == BoundKind.Lower) {
 							if (!Convert.ImplicitConversionExists (ec, cbound.GetTypeExpression (), bound.Type)) {
 								break;
 							}
 						} else {
 							if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 								break;
 							}
 
 							bound = cbound;
 						}
 
 						continue;
 					}
 
 					if (bound.Kind == BoundKind.Upper) {
 						if (!Convert.ImplicitConversionExists (ec, bound.GetTypeExpression (), cbound.Type)) {
 							break;
 						}
 					} else {
 						throw new NotImplementedException ("variance conversion");
 					}
 				}
 
 				if (cii != candidates_count)
 					continue;
 
 				//
 				// We already have the best candidate, break if thet are different
 				//
 				// Dynamic is never ambiguous as we prefer dynamic over other best candidate types
 				//
 				if (best_candidate != null) {
 
 					if (best_candidate == InternalType.Dynamic)
 						continue;
 
 					if (bound.Type != InternalType.Dynamic && best_candidate != bound.Type)
 						return false;
 				}
 
 				best_candidate = bound.Type;
 			}
 
 			if (best_candidate == null)
 				return false;
 
 			fixed_types[i] = best_candidate;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3542" endline="3714">
<![CDATA[
 
 		/// <summary>
 		///   Determines "Better function" between candidate
 		///   and the current best match
 		/// </summary>
 		/// <remarks>
 		///    Returns a boolean indicating 
 		///     false if candidate ain't better
 		///     true  if candidate is better than the current best match
 		/// </remarks>
 		static bool BetterFunction (ResolveContext ec, Arguments args, MemberSpec candidate, AParametersCollection cparam, bool candidate_params,
 			MemberSpec best, AParametersCollection bparam, bool best_params)
 		{
 			AParametersCollection candidate_pd = ((IParametersMember) candidate).Parameters;
 			AParametersCollection best_pd = ((IParametersMember) best).Parameters;
 
 			bool better_at_least_one = false;
 			bool same = true;
 			int args_count = args == null ? 0 
 			int j = 0;
 			Argument a = null;
 			TypeSpec ct, bt;
 			for (int c_idx = 0, b_idx = 0; j < args_count; ++j, ++c_idx, ++b_idx) {
 				a = args[j];
 
 				// Default arguments are ignored for better decision
 				if (a.IsDefaultArgument)
 					break;
 
 				//
 				// When comparing named argument the parameter type index has to be looked up
 				// in original parameter set (override version for virtual members)
 				//
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int idx = cparam.GetParameterIndexByName (na.Name);
 					ct = candidate_pd.Types[idx];
 					if (candidate_params && candidate_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						ct = TypeManager.GetElementType (ct);
 
 					idx = bparam.GetParameterIndexByName (na.Name);
 					bt = best_pd.Types[idx];
 					if (best_params && best_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						bt = TypeManager.GetElementType (bt);
 				} else {
 					ct = candidate_pd.Types[c_idx];
 					bt = best_pd.Types[b_idx];
 
 					if (candidate_params && candidate_pd.FixedParameters[c_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						ct = TypeManager.GetElementType (ct);
 						--c_idx;
 					}
 
 					if (best_params && best_pd.FixedParameters[b_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						bt = TypeManager.GetElementType (bt);
 						--b_idx;
 					}
 				}
 
 				if (TypeSpecComparer.IsEqual (ct, bt))
 					continue;
 
 				same = false;
 				int result = BetterExpressionConversion (ec, a, ct, bt);
 
 				// for each argument, the conversion to 'ct' should be no worse than 
 				// the conversion to 'bt'.
 				if (result == 2)
 					return false;
 
 				// for at least one argument, the conversion to 'ct' should be better than 
 				// the conversion to 'bt'.
 				if (result != 0)
 					better_at_least_one = true;
 			}
 			for (int c_idx = 0, b_idx = 0; j < args_count; ++j, ++c_idx, ++b_idx) {
 				a = args[j];
 
 				// Default arguments are ignored for better decision
 				if (a.IsDefaultArgument)
 					break;
 
 				//
 				// When comparing named argument the parameter type index has to be looked up
 				// in original parameter set (override version for virtual members)
 				//
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int idx = cparam.GetParameterIndexByName (na.Name);
 					ct = candidate_pd.Types[idx];
 					if (candidate_params && candidate_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						ct = TypeManager.GetElementType (ct);
 
 					idx = bparam.GetParameterIndexByName (na.Name);
 					bt = best_pd.Types[idx];
 					if (best_params && best_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						bt = TypeManager.GetElementType (bt);
 				} else {
 					ct = candidate_pd.Types[c_idx];
 					bt = best_pd.Types[b_idx];
 
 					if (candidate_params && candidate_pd.FixedParameters[c_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						ct = TypeManager.GetElementType (ct);
 						--c_idx;
 					}
 
 					if (best_params && best_pd.FixedParameters[b_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						bt = TypeManager.GetElementType (bt);
 						--b_idx;
 					}
 				}
 
 				if (TypeSpecComparer.IsEqual (ct, bt))
 					continue;
 
 				same = false;
 				int result = BetterExpressionConversion (ec, a, ct, bt);
 
 				// for each argument, the conversion to 'ct' should be no worse than 
 				// the conversion to 'bt'.
 				if (result == 2)
 					return false;
 
 				// for at least one argument, the conversion to 'ct' should be better than 
 				// the conversion to 'bt'.
 				if (result != 0)
 					better_at_least_one = true;
 			}
 
 			if (better_at_least_one)
 				return true;
 
 			//
 			// This handles the case
 			//
 			//   Add (float f1, float f2, float f3);
 			//   Add (params decimal [] foo);
 			//
 			// The call Add (3, 4, 5) should be ambiguous.  Without this check, the
 			// first candidate would've chosen as better.
 			//
 			if (!same && !a.IsDefaultArgument)
 				return false;
 
 			//
 			// The two methods have equal non-optional parameter types, apply tie-breaking rules
 			//
 
 			//
 			// This handles the following cases
 			//
 			//  Foo (int i) is better than Foo (int i, long l = 0)
 			//  Foo (params int[] args) is better than Foo (int i = 0, params int[] args)
 			//
 			// Prefer non-optional version
 			//
 			// LAMESPEC
 			//
 			if (candidate_params == best_params && candidate_pd.Count != best_pd.Count) {
 				if (candidate_pd.Count >= best_pd.Count)
 					return false;
 
 				if (j < candidate_pd.Count && candidate_pd.FixedParameters[j].HasDefaultValue)
 					return false;
 
 				return true;
 			}
 
 			//
 			// One is a non-generic method and second is a generic method, then non-generic is better
 			//
 			if (best.IsGeneric != candidate.IsGeneric)
 				return best.IsGeneric;
 
 			//
 			// This handles the following cases
 			//
 			//   Trim () is better than Trim (params char[] chars)
 			//   Concat (string s1, string s2, string s3) is better than
 			//     Concat (string s1, params string [] srest)
 			//   Foo (int, params int [] rest) is better than Foo (params int [] rest)
 			//
 			// Prefer non-expanded version
 			//
 			if (candidate_params != best_params)
 				return best_params;
 
 			int candidate_param_count = candidate_pd.Count;
 			int best_param_count = best_pd.Count;
 
 			if (candidate_param_count != best_param_count)
 				// can only happen if (candidate_params && best_params)
 				return candidate_param_count > best_param_count && best_pd.HasParams;
 
 			//
 			// Both methods have the same number of parameters, and the parameters have equal types
 			// Pick the "more specific" signature using rules over original (non-inflated) types
 			//
 			var candidate_def_pd = ((IParametersMember) candidate.MemberDefinition).Parameters;
 			var best_def_pd = ((IParametersMember) best.MemberDefinition).Parameters;
 
 			bool specific_at_least_once = false;
 			for (j = 0; j < args_count; ++j) {
 				NamedArgument na = args_count == 0 ? null 
 				if (na != null) {
 					ct = candidate_def_pd.Types[cparam.GetParameterIndexByName (na.Name)];
 					bt = best_def_pd.Types[bparam.GetParameterIndexByName (na.Name)];
 				} else {
 					ct = candidate_def_pd.Types[j];
 					bt = best_def_pd.Types[j];
 				}
 
 				if (ct == bt)
 					continue;
 				TypeSpec specific = MoreSpecific (ct, bt);
 				if (specific == bt)
 					return false;
 				if (specific == ct)
 					specific_at_least_once = true;
 			}
 			for (j = 0; j < args_count; ++j) {
 				NamedArgument na = args_count == 0 ? null 
 				if (na != null) {
 					ct = candidate_def_pd.Types[cparam.GetParameterIndexByName (na.Name)];
 					bt = best_def_pd.Types[bparam.GetParameterIndexByName (na.Name)];
 				} else {
 					ct = candidate_def_pd.Types[j];
 					bt = best_def_pd.Types[j];
 				}
 
 				if (ct == bt)
 					continue;
 				TypeSpec specific = MoreSpecific (ct, bt);
 				if (specific == bt)
 					return false;
 				if (specific == ct)
 					specific_at_least_once = true;
 			}
 
 			if (specific_at_least_once)
 				return true;
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="84" endline="96">
<![CDATA[
 		}
 
 		public CallingConventions CallingConventions {
 			get {
 				CallingConventions cc = parameters.CallingConvention;
 				if (!IsInterface)
 					if ((ModFlags & Modifiers.STATIC) == 0)
 						cc |= CallingConventions.HasThis;
 
 				// FIXME
 			
 				return cc;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="81" endline="101">
<![CDATA[
 
 		internal int ReadCompressedInt()
 		{
 			byte b1 = ReadByte();
 			if (b1 <= 0x7F)
 			{
 				return b1;
 			}
 			else if ((b1 & 0xC0) == 0x80)
 			{
 				byte b2 = ReadByte();
 				return ((b1 & 0x3F) << 8) | b2;
 			}
 			else
 			{
 				byte b2 = ReadByte();
 				byte b3 = ReadByte();
 				byte b4 = ReadByte();
 				return ((b1 & 0x3F) << 24) + (b2 << 16) + (b3 << 8) + b4;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="40" endline="70">
<![CDATA[
 		
 		//
 		// From a one-dimensional array-type S[] to System.Collections.IList<T> and base
 		// interfaces of this interface, provided there is an implicit reference conversion
 		// from S to T.
 		//
 		static bool ArrayToIList (ArrayContainer array, TypeSpec list, bool isExplicit)
 		{
 			if (array.Rank != 1 || !list.IsGeneric)
 				return false;
 
 			var open_version = list.GetDefinition ();
 			if ((open_version != TypeManager.generic_ilist_type) &&
 				(open_version != TypeManager.generic_icollection_type) &&
 				(open_version != TypeManager.generic_ienumerable_type))
 				return false;
 
 			var arg_type = list.TypeArguments[0];
 			if (array.Element == arg_type)
 				return true;
 
 			if (isExplicit)
 				return ExplicitReferenceConversionExists (array.Element, arg_type);
 
 			if (MyEmptyExpr == null)
 				MyEmptyExpr = new EmptyExpression (array.Element);
 			else
 				MyEmptyExpr.SetType (array.Element);
 
 			return ImplicitReferenceConversionExists (MyEmptyExpr, arg_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1701" endline="1707">
<![CDATA[
 
 		int peek_char2 ()
 		{
 			if (putback_char != -1)
 				return putback_char;
 			return reader.Peek ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="474" endline="487">
<![CDATA[
 
 		public int Size
 		{
 			get
 			{
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return this.ModuleBuilder.ClassLayout.records[i].ClassSize;
 					}
 				}
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return this.ModuleBuilder.ClassLayout.records[i].ClassSize;
 					}
 				}
 				return 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="488" endline="502">
<![CDATA[
 		}
 
 		public PackingSize PackingSize
 		{
 			get
 			{
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return (PackingSize)this.ModuleBuilder.ClassLayout.records[i].PackingSize;
 					}
 				}
 				for (int i = 0; i < this.ModuleBuilder.ClassLayout.records.Length; i++)
 				{
 					if (this.ModuleBuilder.ClassLayout.records[i].Parent == token)
 					{
 						return (PackingSize)this.ModuleBuilder.ClassLayout.records[i].PackingSize;
 					}
 				}
 				return PackingSize.Unspecified;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="290" endline="314">
<![CDATA[
 		}
 
 #endregion
 
 		public FieldInfo GetMetaInfo ()
 		{
 			if ((state & StateFlags.PendingMetaInflate) != 0) {
 				var decl_meta = DeclaringType.GetMetaInfo ();
 				if (DeclaringType.IsTypeBuilder) {
 					metaInfo = TypeBuilder.GetField (decl_meta, metaInfo);
 				} else {
 					var orig_token = metaInfo.MetadataToken;
 					metaInfo = decl_meta.GetField (Name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
 					if (metaInfo.MetadataToken != orig_token)
 						throw new NotImplementedException ("Resolved to wrong meta token");
 
 					// What a stupid API, does not work because field handle is imported
 					// metaInfo = FieldInfo.GetFieldFromHandle (metaInfo.FieldHandle, DeclaringType.MetaInfo.TypeHandle);
 				}
 
 				state &= ~StateFlags.PendingMetaInflate;
 			}
 
 			return metaInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="305" endline="316">
<![CDATA[
 
 		internal long RvaToFileOffset(DWORD rva)
 		{
 			for (int i = 0; i < sections.Length; i++)
 			{
 				if (rva >= sections[i].VirtualAddress && rva < sections[i].VirtualAddress + sections[i].VirtualSize)
 				{
 					return sections[i].PointerToRawData + rva - sections[i].VirtualAddress;
 				}
 			}
 			for (int i = 0; i < sections.Length; i++)
 			{
 				if (rva >= sections[i].VirtualAddress && rva < sections[i].VirtualAddress + sections[i].VirtualSize)
 				{
 					return sections[i].PointerToRawData + rva - sections[i].VirtualAddress;
 				}
 			}
 			throw new BadImageFormatException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="562" endline="577">
<![CDATA[
 		}
 
 		internal override Type GetTypeImpl(string typeName)
 		{
 			PopulateTypeDef();
 			Type type;
 			if (!types.TryGetValue(typeName, out type))
 			{
 				LazyForwardedType fw;
 				if (forwardedTypes.TryGetValue(typeName, out fw))
 				{
 					return fw.GetType(this, typeName);
 				}
 			}
 			return type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="334" endline="343">
<![CDATA[
 
 		public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names)
 		{
 			gtpb = new GenericTypeParameterBuilder[names.Length];
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], null, this, i);
 			}
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], null, this, i);
 			}
 			return (GenericTypeParameterBuilder[])gtpb.Clone();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="572" endline="591">
<![CDATA[
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			CheckAbstractAndExtern (block != null);
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0) {
 				for (int i = 0; i < parameters.Count; ++i) {
 					IParameterData p = parameters.FixedParameters [i];
 					if (p.ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (752, Location, "`{0}'
 							GetSignatureForError ());
 					}
 
 					if (p.HasDefaultValue && IsPartialImplementation)
 						((Parameter) p).Warning_UselessOptionalParameter (Report);
 				}
 				for (int i = 0; i < parameters.Count; ++i) {
 					IParameterData p = parameters.FixedParameters [i];
 					if (p.ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (752, Location, "`{0}'
 							GetSignatureForError ());
 					}
 
 					if (p.HasDefaultValue && IsPartialImplementation)
 						((Parameter) p).Warning_UselessOptionalParameter (Report);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="484" endline="506">
<![CDATA[
 
 		void CheckMissingAccessor (MemberKind kind, ParametersCompiled parameters, bool get)
 		{
 			if (IsExplicitImpl) {
 				MemberFilter filter;
 				if (kind == MemberKind.Indexer)
 					filter = new MemberFilter (MemberCache.IndexerNameAlias, 0, kind, parameters, null);
 				else
 					filter = new MemberFilter (MemberName.Name, 0, kind, null, null);
 
 				var implementing = MemberCache.FindMember (InterfaceType, filter, BindingRestriction.DeclaredOnly) as PropertySpec;
 
 				if (implementing == null)
 					return;
 
 				var accessor = get ? implementing.Get 
 				if (accessor != null) {
 					Report.SymbolRelatedToPreviousError (accessor);
 					Report.Error (551, Location, "Explicit interface implementation `{0}' is missing accessor `{1}'",
 						GetSignatureForError (), accessor.GetSignatureForError ());
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cfold.cs" startline="35" endline="62">
<![CDATA[
 
 		//
 		// Performs the numeric promotions on the left and right expresions
 		// and deposits the results on `lc' and `rc'.
 		//
 		// On success, the types of `lc' and `rc' on output will always match,
 		// and the pair will be one of
 		//
 		// TODO
 		// error checking here is weak
 		//		
 		static bool DoBinaryNumericPromotions (ResolveContext rc, ref Constant left, ref Constant right)
 		{
 			TypeSpec ltype = left.Type;
 			TypeSpec rtype = right.Type;
 
 			foreach (TypeSpec t in BinaryPromotionsTypes) {
 				if (t == ltype)
 					return t == rtype || ConvertPromotion (rc, ref right, ref left, t);
 
 				if (t == rtype)
 					return t == ltype || ConvertPromotion (rc, ref left, ref right, t);
 			}
 			foreach (TypeSpec t in BinaryPromotionsTypes) {
 				if (t == ltype)
 					return t == rtype || ConvertPromotion (rc, ref right, ref left, t);
 
 				if (t == rtype)
 					return t == ltype || ConvertPromotion (rc, ref left, ref right, t);
 			}
 
 			left = left.ConvertImplicitly (rc, TypeManager.int32_type);
 			right = right.ConvertImplicitly (rc, TypeManager.int32_type);
 			return left != null && right != null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="437" endline="457">
<![CDATA[
 		}
 
 		// The ISymbolDocumentWriter interface is used by the symbol writer to
 		// describe a single source file - for each source file there's exactly
 		// one corresponding ISymbolDocumentWriter instance.
 		//
 		// This class has an internal hash table mapping source document names
 		// to such ISymbolDocumentWriter instances - so there's exactly one
 		// instance per document.
 		//
 		// This property returns the ISymbolDocumentWriter instance which belongs
 		// to the location's source file.
 		//
 		// If we don't have a symbol writer, this property is always null.
 		public SourceFile SourceFile {
 			get {
 				int index = File;
 				if (index == 0)
 					return null;
 				return (SourceFile) source_list [index - 1];
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="357" endline="369">
<![CDATA[
 
 		internal void WriteMethodRefSig(ModuleBuilder module, ByteBuffer bb, Type[] optionalParameterTypes)
 		{
 			WriteSigImpl(module, bb, parameterTypes.Length + optionalParameterTypes.Length);
 			if (optionalParameterTypes.Length > 0)
 			{
 				bb.Write(SENTINEL);
 				foreach (Type type in optionalParameterTypes)
 				{
 					WriteType(module, bb, type);
 				}
 				foreach (Type type in optionalParameterTypes)
 				{
 					WriteType(module, bb, type);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2714" endline="2757">
<![CDATA[
 
 		public override bool IsUnmanagedType ()
 		{
 			if (fields == null)
 				return true;
 
 			if (has_unmanaged_check_done)
 				return is_unmanaged;
 
 			if (requires_delayed_unmanagedtype_check)
 				return true;
 
 			requires_delayed_unmanagedtype_check = true;
 
 			foreach (FieldBase f in fields) {
 				if (f.IsStatic)
 					continue;
 
 				// It can happen when recursive unmanaged types are defined
 				// struct S { S* s; }
 				TypeSpec mt = f.MemberType;
 				if (mt == null) {
 					return true;
 				}
 
 				while (mt.IsPointer)
 					mt = TypeManager.GetElementType (mt);
 				while (mt.IsPointer)
 					mt = TypeManager.GetElementType (mt);
 
 				if (mt.IsGenericOrParentIsGeneric || mt.IsGenericParameter) {
 					has_unmanaged_check_done = true;
 					return false;
 				}
 
 				if (TypeManager.IsUnmanagedType (mt))
 					continue;
 
 				has_unmanaged_check_done = true;
 				return false;
 			foreach (FieldBase f in fields) {
 				if (f.IsStatic)
 					continue;
 
 				// It can happen when recursive unmanaged types are defined
 				// struct S { S* s; }
 				TypeSpec mt = f.MemberType;
 				if (mt == null) {
 					return true;
 				}
 
 				while (mt.IsPointer)
 					mt = TypeManager.GetElementType (mt);
 
 				if (mt.IsGenericOrParentIsGeneric || mt.IsGenericParameter) {
 					has_unmanaged_check_done = true;
 					return false;
 				}
 
 				if (TypeManager.IsUnmanagedType (mt))
 					continue;
 
 				has_unmanaged_check_done = true;
 				return false;
 			}
 
 			has_unmanaged_check_done = true;
 			is_unmanaged = true;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="312" endline="321">
<![CDATA[
 
 		public CodeBlockEntry[] Blocks {
 			get {
 				if (_blocks == null)
 					return new CodeBlockEntry [0];
 
 				CodeBlockEntry[] retval = new CodeBlockEntry [_blocks.Count];
 				_blocks.CopyTo (retval, 0);
 				return retval;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="480" endline="499">
<![CDATA[
 
 		//
 		// For named arguments when the order of execution is different
 		// to order of invocation
 		//
 		public Arguments MarkOrderedArgument (NamedArgument a)
 		{
 			//
 			// Constant expression have no effect on left-to-right execution
 			//
 			if (a.Expr is Constant)
 				return this;
 
 			ArgumentsOrdered ra = this as ArgumentsOrdered;
 			if (ra == null)
 				ra = new ArgumentsOrdered (this);
 
 			ra.AddOrdered (a);
 			return ra;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="837" endline="857">
<![CDATA[
 
 		//
 		// Constraints have to match by definition but not position, used by
 		// partial classes or methods
 		//
 		public bool HasSameConstraintsDefinition (TypeParameterSpec other)
 		{
 			if (spec != other.spec)
 				return false;
 
 			if (BaseType != other.BaseType)
 				return false;
 
 			if (!TypeSpecComparer.Override.IsSame (InterfacesDefined, other.InterfacesDefined))
 				return false;
 
 			if (!TypeSpecComparer.Override.IsSame (targs, other.targs))
 				return false;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="478" endline="516">
<![CDATA[
 	
 	static string GetMethodModifiers (MethodBase method)
 	{
 		if (method.IsStatic)
 			return "static ";
 
 		if (method.IsFinal) {
 			// This will happen if you have
 			// class X 
 			//   public void A () {}
 			//   static void Main () {}
 			// }
 			// interface IA {
 			//   void A ();
 			// }
 			//
 			// A needs to be virtual (the CLR requires
 			// methods implementing an iface be virtual),
 			// but can not be inherited. It also can not
 			// be inherited. In C# this is represented
 			// with no special modifiers
 
 			if (method.IsVirtual)
 				return null;
 			return "sealed ";
 		}
 		
 		// all interface methods are "virtual" but we don't say that in c#
 		if (method.IsVirtual && !method.DeclaringType.IsInterface) {
 			if (method.IsAbstract)
 				return "abstract ";
 
 			return ((method.Attributes & MethodAttributes.NewSlot) != 0) ?
 				"virtual " 
 				"override ";	
 		}
 				
 		return null;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="590" endline="618">
<![CDATA[
 
 		// unmanaged calling convention
 		internal static void WriteStandAloneMethodSig(ModuleBuilder module, ByteBuffer bb, CallingConvention callingConvention, Type returnType, Type[] parameterTypes)
 		{
 			switch (callingConvention)
 			{
 				case CallingConvention.Cdecl
 					bb.Write((byte)0x01);	// C
 					break;
 				case CallingConvention.StdCall
 				case CallingConvention.Winapi
 					bb.Write((byte)0x02);	// STDCALL
 					break;
 				case CallingConvention.ThisCall
 					bb.Write((byte)0x03);	// THISCALL
 					break;
 				case CallingConvention.FastCall
 					bb.Write((byte)0x04);	// FASTCALL
 					break;
 				default
 					throw new ArgumentOutOfRangeException("callingConvention");
 			}
 			bb.WriteCompressedInt(parameterTypes.Length);
 			WriteType(module, bb, returnType);
 			foreach (Type t in parameterTypes)
 			{
 				WriteType(module, bb, t);
 			}
 			foreach (Type t in parameterTypes)
 			{
 				WriteType(module, bb, t);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="511" endline="542">
<![CDATA[
 		}
 
 		internal int LineNumberCount = 0;
 		internal int LocalCount = 0;
 		internal int StringSize = 0;
 
 		internal int LineNumberSize = 0;
 		internal int ExtendedLineNumberSize = 0;
 
 		public SourceFileEntry GetSourceFile (int index)
 		{
 			if ((index < 1) || (index > ot.SourceCount))
 				throw new ArgumentException ();
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				SourceFileEntry source;
 				if (source_file_hash.TryGetValue (index, out source))
 					return source;
 
 				long old_pos = reader.BaseStream.Position;
 
 				reader.BaseStream.Position = ot.SourceTableOffset +
 					SourceFileEntry.Size * (index - 1);
 				source = new SourceFileEntry (this, reader);
 				source_file_hash.Add (index, source);
 
 				reader.BaseStream.Position = old_pos;
 				return source;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="554" endline="578">
<![CDATA[
 		}
 
 		public CompileUnitEntry GetCompileUnit (int index)
 		{
 			if ((index < 1) || (index > ot.CompileUnitCount))
 				throw new ArgumentException ();
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				CompileUnitEntry unit;
 				if (compile_unit_hash.TryGetValue (index, out unit))
 					return unit;
 
 				long old_pos = reader.BaseStream.Position;
 
 				reader.BaseStream.Position = ot.CompileUnitTableOffset +
 					CompileUnitEntry.Size * (index - 1);
 				unit = new CompileUnitEntry (this, reader);
 				compile_unit_hash.Add (index, unit);
 
 				reader.BaseStream.Position = old_pos;
 				return unit;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6324" endline="6355">
<![CDATA[
 
 void Error_SyntaxError (int error_code, int token, string msg)
 {
 	// An error message has been reported by tokenizer
 	if (token == Token.ERROR)
 		return;
 
 	string symbol = GetSymbolName (token);
 	string expecting = GetExpecting ();
 	var loc = lexer.Location - symbol.Length;
 	
 	if (error_code == 0) {
 		if (expecting == "`identifier'") {
 			if (token > Token.FIRST_KEYWORD && token < Token.LAST_KEYWORD) {
 				Report.Error (1041, loc, "Identifier expected, `{0}' is a keyword", symbol);
 				return;
 			}
 			
 			error_code = 1001;
 			expecting = "identifier";
 		} else if (expecting == "`)'") {
 			error_code = 1026;
 		} else {
 			error_code = 1525;
 		}
 	}
 	
 	if (string.IsNullOrEmpty (expecting))
 		Report.Error (error_code, loc, "{1} `{0}'", symbol, msg);
 	else
 		Report.Error (error_code, loc, "{2} `{0}', expecting {1}", symbol, expecting, msg);	  
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="610" endline="628">
<![CDATA[
 
 		//
 		// Returns inflated version of MemberSpec, it works similarly to
 		// SRE TypeBuilder.GetMethod
 		//
 		public static T GetMember<T> (TypeSpec container, T spec) where T 
 		{
 			IList<MemberSpec> applicable;
 			if (container.MemberCache.member_hash.TryGetValue (GetLookupName (spec), out applicable)) {
 				for (int i = applicable.Count - 1; i >= 0; i--) {
 					var entry = applicable[i];
 					if (entry.MemberDefinition == spec.MemberDefinition)
 						return (T) entry;
 				}
 				for (int i = applicable.Count - 1; i >= 0; i--) {
 					var entry = applicable[i];
 					if (entry.MemberDefinition == spec.MemberDefinition)
 						return (T) entry;
 				}
 			}
 
 			throw new InternalErrorException ("Missing member `{0}' on inflated type `{1}'",
 				spec.GetSignatureForError (), container.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="777" endline="808">
<![CDATA[
 
 		static PreprocessorDirective GetPreprocessorDirective (char[] id, int id_len)
 		{
 			//
 			// Keywords are stored in an array of arrays grouped by their
 			// length and then by the first character
 			//
 			if (id_len >= keywords_preprocessor.Length || keywords_preprocessor[id_len] == null)
 				return PreprocessorDirective.Invalid;
 
 			int first_index = id[0] - '_';
 			if (first_index > 'z' - '_')
 				return PreprocessorDirective.Invalid;
 
 			var kwe = keywords_preprocessor[id_len][first_index];
 			if (kwe == null)
 				return PreprocessorDirective.Invalid;
 
 			PreprocessorDirective res = PreprocessorDirective.Invalid;
 			do {
 				res = kwe.Token;
 				for (int i = 1; i < id_len; ++i) {
 					if (id[i] != kwe.Value[i]) {
 						res = 0;
 						kwe = kwe.Next;
 						break;
 					}
 				}
 				for (int i = 1; i < id_len; ++i) {
 					if (id[i] != kwe.Value[i]) {
 						res = 0;
 						kwe = kwe.Next;
 						break;
 					}
 				}
 			} while (res == PreprocessorDirective.Invalid && kwe != null);
 
 			return res;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="369" endline="384">
<![CDATA[
 
 		private static bool IsEqual(byte[] b1, byte[] b2)
 		{
 			if (b1.Length != b2.Length)
 			{
 				return false;
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			for (int i = 0; i < b1.Length; i++)
 			{
 				if (b1[i] != b2[i])
 				{
 					return false;
 				}
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="361" endline="378">
<![CDATA[
 
 		public void EndExceptionBlock()
 		{
 			ExceptionBlock block = exceptionStack.Pop();
 			if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
 			{
 				if (block.filterOffset != 0 || (block.exceptionType != null && block.exceptionType != FAULT))
 				{
 					Emit(OpCodes.Leave, block.labelEnd);
 				}
 				else
 				{
 					Emit(OpCodes.Endfinally);
 				}
 			}
 			MarkLabel(block.labelEnd);
 			block.handlerLength = code.Position - block.handlerOffset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1450" endline="1459">
<![CDATA[
 
 		public bool IsFieldAssigned (MyBitVector vector, string field_name)
 		{
 			int field_idx = TypeInfo.GetFieldIndex (field_name);
 
 			if (field_idx == 0)
 				return true;
 
 			return vector [Offset + field_idx];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="793" endline="805">
<![CDATA[
 		}
 
 		public TypeSpec GetAttributeCoClass ()
 		{
 			if (OptAttributes == null)
 				return null;
 
 			Attribute a = OptAttributes.Search (Module.PredefinedAttributes.CoClass);
 			if (a == null)
 				return null;
 
 			return a.GetCoClassAttributeValue ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="1099" endline="1122">
<![CDATA[
 		}
 
 #if !NET_2_1
 		/// <summary>
 		///   Describes an object or a type.
 		/// </summary>
 		/// <remarks>
 		///   This method will show a textual representation
 		///   of the object's type.  If the object is a
 		///   System.Type it renders the type directly,
 		///   otherwise it renders the type returned by
 		///   invoking GetType on the object.
 		/// </remarks>
 		static public string Describe (object x)
 		{
 			if (x == null)
 				return "<null>";
 
 			var type = x as Type ?? x.GetType ();
 
 			StringWriter sw = new StringWriter ();
 			new Outline (type, sw, true, false, false).OutlineType ();
 			return sw.ToString ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1142" endline="1173">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (ec.HasSet (ResolveContext.Options.ConstantScope)) {
 				ec.Report.Error (1706, loc, "Anonymous methods and lambda expressions cannot be used in the current context");
 				return null;
 			}
 
 			//
 			// Set class type, set type
 			//
 
 			eclass = ExprClass.Value;
 
 			//
 			// This hack means `The type is not accessible
 			// anywhere', we depend on special conversion
 			// rules.
 			// 
 			type = InternalType.AnonymousMethod;
 
 			if (!DoResolveParameters (ec))
 				return null;
 
 			// FIXME
 			// so, ensure we have a 'ret' at the end
 			BlockContext bc = ec as BlockContext;
 			if (bc != null && bc.CurrentBranching != null && bc.CurrentBranching.CurrentUsageVector.IsUnreachable)
 				bc.NeedReturnLabel ();
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="302" endline="326">
<![CDATA[
 
 		public Type GetType(string className, bool throwOnError, bool ignoreCase)
 		{
 			if (ignoreCase)
 			{
 				throw new NotImplementedException();
 			}
 			TypeNameParser parser = TypeNameParser.Parse(className, throwOnError);
 			if (parser.Error)
 			{
 				return null;
 			}
 			if (parser.AssemblyName != null)
 			{
 				if (throwOnError)
 				{
 					throw new ArgumentException("Type names passed to Module.GetType() must not specify an assembly.");
 				}
 				else
 				{
 					return null;
 				}
 			}
 			return parser.Expand(GetTypeImpl(parser.FirstNamePart), this.Assembly, throwOnError, className);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="120" endline="155">
<![CDATA[
 
 		#region IEquatable<MemberSpec> Members
 
 		public bool Equals (MemberSpec other)
 		{
 			// Is the member of the correct type ?
 			// TODO
 			if ((other.Kind & Kind & MemberKind.MaskType) == 0)
 				return false;
 
 			// Check arity when not disabled
 			if (arity >= 0 && arity != other.Arity)
 				return false;
 
 			if (Parameters != null) {
 				if (other is IParametersMember) {
 					var other_param = ((IParametersMember) other).Parameters;
 					if (!TypeSpecComparer.Override.IsEqual (Parameters, other_param))
 						return false;
 				} else {
 					return false;
 				}
 			}
 
 			if (MemberType != null) {
 				if (other is IInterfaceMemberSpec) {
 					var other_type = ((IInterfaceMemberSpec) other).MemberType;
 					if (!TypeSpecComparer.Override.IsEqual (other_type, MemberType))
 						return false;
 				} else {
 					return false;
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2639" endline="2681">
<![CDATA[
 
 		//
 		// 26.3.3.8 Exact Inference
 		//
 		public int ExactInference (TypeSpec u, TypeSpec v)
 		{
 			// If V is an array type
 			if (v.IsArray) {
 				if (!u.IsArray)
 					return 0;
 
 				// TODO MemberCache
 				if (u.GetMetaInfo ().GetArrayRank () != v.GetMetaInfo ().GetArrayRank ())
 					return 0;
 
 				return ExactInference (TypeManager.GetElementType (u), TypeManager.GetElementType (v));
 			}
 
 			// If V is constructed type and U is constructed type
 			if (TypeManager.IsGenericType (v)) {
 				if (!TypeManager.IsGenericType (u))
 					return 0;
 
 				TypeSpec [] ga_u = TypeManager.GetTypeArguments (u);
 				TypeSpec [] ga_v = TypeManager.GetTypeArguments (v);
 				if (ga_u.Length != ga_v.Length)
 					return 0;
 
 				int score = 0;
 				for (int i = 0; i < ga_u.Length; ++i)
 					score += ExactInference (ga_u [i], ga_v [i]);
 				for (int i = 0; i < ga_u.Length; ++i)
 					score += ExactInference (ga_u [i], ga_v [i]);
 
 				return score > 0 ? 1 
 			}
 
 			// If V is one of the unfixed type arguments
 			int pos = IsUnfixed (v);
 			if (pos == -1)
 				return 0;
 
 			AddToBounds (new BoundInfo (u, BoundKind.Exact), pos);
 			return 1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2359" endline="2369">
<![CDATA[
 
 		bool eval (string s)
 		{
 			bool v = pp_expr (ref s, true);
 			s = s.Trim ();
 			if (s.Length != 0){
 				return false;
 			}
 
 			return v;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4975" endline="4983">
<![CDATA[
 
 		public override bool Equals (object obj)
 		{
 			ParameterReference pr = obj as ParameterReference;
 			if (pr == null)
 				return false;
 
 			return Name == pr.Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8567" endline="8575">
<![CDATA[
 
 		IParametersMember OverloadResolver.IBaseMembersProvider.GetOverrideMemberParameters (MemberSpec member)
 		{
 			if (queried_type == member.DeclaringType)
 				return null;
 
 			var filter = new MemberFilter (MemberCache.IndexerNameAlias, 0, MemberKind.Indexer, ((IndexerSpec) member).Parameters, null);
 			return MemberCache.FindMember (queried_type, filter, BindingRestriction.InstanceOnly | BindingRestriction.OverrideOnly) as IParametersMember;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="896" endline="906">
<![CDATA[
 		}
 
 		public override bool CheckRethrow (Location loc)
 		{
 			if (!Parent.CheckRethrow (loc))
 				return false;
 			if (finally_vector == null)
 				return true;
 			Report.Error (724, loc, "A throw statement with no arguments is not allowed inside of a finally clause nested inside of the innermost catch clause");
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5270" endline="5287">
<![CDATA[
 
 		//
 		// If a member is a method or event, or if it is a constant, field or property of either a delegate type
 		// or the type dynamic, then the member is invocable
 		//
 		public static bool IsMemberInvocable (MemberSpec member)
 		{
 			switch (member.Kind) {
 			case MemberKind.Event
 				return true;
 			case MemberKind.Field
 			case MemberKind.Property
 				var m = member as IInterfaceMemberSpec;
 				return m.MemberType.IsDelegate || m.MemberType == InternalType.Dynamic;
 			default
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="341" endline="357">
<![CDATA[
 		}
 
 		//TODO
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ()) {
 				return false;
 			}
 
 			parameters.VerifyClsCompliance (this);
 
 			if (!ReturnType.Type.IsCLSCompliant ()) {
 				Report.Warning (3002, 1, Location, "Return type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3214" endline="3230">
<![CDATA[
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			//
 			// Two members can differ in their explicit interface
 			// type parameter only
 			//
 			InterfaceMemberBase imb = overload as InterfaceMemberBase;
 			if (imb != null && imb.IsExplicitImpl) {
 				if (IsExplicitImpl) {
 					caching_flags |= Flags.MethodOverloadsExist;
 				}
 				return true;
 			}
 
 			return IsExplicitImpl;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1670" endline="1685">
<![CDATA[
 
 		int get_char ()
 		{
 			int x;
 			if (putback_char != -1) {
 				x = putback_char;
 				putback_char = -1;
 			} else
 				x = reader.Read ();
 			if (x == '\n') {
 				advance_line ();
 			} else {
 				col++;
 			}
 			return x;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2601" endline="2622">
<![CDATA[
 
 		protected void AddToBounds (BoundInfo bound, int index)
 		{
 			//
 			// Some types cannot be used as type arguments
 			//
 			if (bound.Type == TypeManager.void_type || bound.Type.IsPointer)
 				return;
 
 			var a = bounds [index];
 			if (a == null) {
 				a = new List<BoundInfo> (2);
 				a.Add (bound);
 				bounds [index] = a;
 				return;
 			}
 
 			if (a.Contains (bound))
 				return;
 
 			a.Add (bound);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1026" endline="1040">
<![CDATA[
 
 		public static bool IsValidIdentifier (string s)
 		{
 			if (s == null || s.Length == 0)
 				return false;
 
 			if (!is_identifier_start_character (s [0]))
 				return false;
 			
 			for (int i = 1; i < s.Length; i ++)
 				if (! is_identifier_part_character (s [i]))
 					return false;
 			for (int i = 1; i < s.Length; i ++)
 				if (! is_identifier_part_character (s [i]))
 					return false;
 			
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6225" endline="6249">
<![CDATA[
 
 		protected bool ResolveInitializers (ResolveContext ec)
 		{
 			only_constant_initializers = true;
 
 			if (arguments != null) {
 				bool res = true;
 				for (int i = 0; i < arguments.Count; ++i) {
 					res &= CheckIndices (ec, initializers, i, true, dimensions);
 					if (initializers != null)
 						break;
 				}
 				for (int i = 0; i < arguments.Count; ++i) {
 					res &= CheckIndices (ec, initializers, i, true, dimensions);
 					if (initializers != null)
 						break;
 				}
 
 				return res;
 			}
 
 			arguments = new List<Expression> ();
 
 			if (!CheckIndices (ec, initializers, 0, false, dimensions))
 				return false;
 				
 			UpdateIndices ();
 				
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1583" endline="1592">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			parameters.VerifyClsCompliance (this);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="264" endline="273">
<![CDATA[
 	
 	BindingFlags DefaultFlags {
 		get {
 			BindingFlags f = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
 			
 			if (declared_only)
 				f |= BindingFlags.DeclaredOnly;
 			
 			return f;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="39" endline="50">
<![CDATA[
 
 		public static bool CheckContext (ResolveContext ec, Location loc)
 		{
 			if (!ec.CurrentAnonymousMethod.IsIterator) {
 				ec.Report.Error (1621, loc,
 					      "The yield statement cannot be used inside " +
 					      "anonymous method blocks");
 				return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="978" endline="986">
<![CDATA[
 
 		public override bool Equals (object obj)
 		{
 			Attribute a = obj as Attribute;
 			if (a == null)
 				return false;
 
 			return Type == a.Type && Target == a.Target;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="861" endline="869">
<![CDATA[
 		}
 
 		public bool IsObsolete {
 			get {
 				if (GetAttributeObsolete () != null)
 					return true;
 
 				return Parent == null ? false 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="617" endline="632">
<![CDATA[
 
 		/// <summary>
 		/// Returns custom name of indexer
 		/// </summary>
 		public string GetIndexerAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return null;
 
 			return ((Constant) PosArguments [0].Expr).GetValue () as string;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="633" endline="648">
<![CDATA[
 
 		/// <summary>
 		/// Returns condition of ConditionalAttribute
 		/// </summary>
 		public string GetConditionalAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return null;
 
 			return ((Constant) PosArguments[0].Expr).GetValue () as string;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5808" endline="5819">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			LocalTemporary v = null;
 			if (method == null && TypeManager.IsValueType (type)) {
 				// TODO
 				v = new LocalTemporary (type);
 			}
 
 			if (!Emit (ec, v))
 				v.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="220" endline="238">
<![CDATA[
 		}
 
 		internal uint StartupStubLength
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64)
 				{
 					return 12;
 				}
 				else if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_IA64)
 				{
 					return 48;
 				}
 				else
 				{
 					return 6;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9725" endline="9745">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression e = expr.Resolve (ec);
 			if (e == null)
 				return null;
 
 			if (e.eclass == ExprClass.MethodGroup) {
 				Error_InvalidInitializer (ec, e.ExprClassName);
 				return null;
 			}
 
 			type = e.Type;
 			if (type == TypeManager.void_type || type == InternalType.Null ||
 				type == InternalType.AnonymousMethod || type.IsPointer) {
 				Error_InvalidInitializer (ec, e.GetSignatureForError ());
 				return null;
 			}
 
 			return e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="64" endline="85">
<![CDATA[
 		}
 
 		public override EventInfo[] __GetDeclaredEvents()
 		{
 			int token = this.MetadataToken;
 			// TODO use binary search?
 			for (int i = 0; i < module.EventMap.records.Length; i++)
 			{
 				if (module.EventMap.records[i].Parent == token)
 				{
 					int evt = module.EventMap.records[i].EventList - 1;
 					int end = module.EventMap.records.Length > i + 1 ? module.EventMap.records[i + 1].EventList - 1 
 					EventInfo[] events = new EventInfo[end - evt];
 					for (int j = 0; evt < end; evt++, j++)
 					{
 						events[j] = new EventInfoImpl(module, this, evt);
 					}
 					for (int j = 0; evt < end; evt++, j++)
 					{
 						events[j] = new EventInfoImpl(module, this, evt);
 					}
 					return events;
 				}
 			}
 			for (int i = 0; i < module.EventMap.records.Length; i++)
 			{
 				if (module.EventMap.records[i].Parent == token)
 				{
 					int evt = module.EventMap.records[i].EventList - 1;
 					int end = module.EventMap.records.Length > i + 1 ? module.EventMap.records[i + 1].EventList - 1 
 					EventInfo[] events = new EventInfo[end - evt];
 					for (int j = 0; evt < end; evt++, j++)
 					{
 						events[j] = new EventInfoImpl(module, this, evt);
 					}
 					return events;
 				}
 			}
 			return Empty<EventInfo>.Array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="173" endline="193">
<![CDATA[
 
 		public override PropertyInfo[] __GetDeclaredProperties()
 		{
 			int token = this.MetadataToken;
 			// TODO use binary search?
 			for (int i = 0; i < module.PropertyMap.records.Length; i++)
 			{
 				if (module.PropertyMap.records[i].Parent == token)
 				{
 					int property = module.PropertyMap.records[i].PropertyList - 1;
 					int end = module.PropertyMap.records.Length > i + 1 ? module.PropertyMap.records[i + 1].PropertyList - 1 
 					PropertyInfo[] properties = new PropertyInfo[end - property];
 					for (int j = 0; property < end; property++, j++)
 					{
 						properties[j] = new PropertyInfoImpl(module, this, property);
 					}
 					for (int j = 0; property < end; property++, j++)
 					{
 						properties[j] = new PropertyInfoImpl(module, this, property);
 					}
 					return properties;
 				}
 			}
 			for (int i = 0; i < module.PropertyMap.records.Length; i++)
 			{
 				if (module.PropertyMap.records[i].Parent == token)
 				{
 					int property = module.PropertyMap.records[i].PropertyList - 1;
 					int end = module.PropertyMap.records.Length > i + 1 ? module.PropertyMap.records[i + 1].PropertyList - 1 
 					PropertyInfo[] properties = new PropertyInfo[end - property];
 					for (int j = 0; property < end; property++, j++)
 					{
 						properties[j] = new PropertyInfoImpl(module, this, property);
 					}
 					return properties;
 				}
 			}
 			return Empty<PropertyInfo>.Array;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="980" endline="1015">
<![CDATA[
 		}
 
 		public override IList<CustomAttributeData> __GetPlaceholderAssemblyCustomAttributes(bool multiple, bool security)
 		{
 			string typeName;
 			switch ((multiple ? 1 
 			{
 				case 0
 					typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHere";
 					break;
 				case 1
 					typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHereM";
 					break;
 				case 2
 					typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHereS";
 					break;
 				case 3
 				default
 					typeName = "System.Runtime.CompilerServices.AssemblyAttributesGoHereSM";
 					break;
 			}
 			List<CustomAttributeData> list = new List<CustomAttributeData>();
 			for (int i = 0; i < CustomAttribute.records.Length; i++)
 			{
 				if ((CustomAttribute.records[i].Parent >> 24) == TypeRefTable.Index)
 				{
 					int index = (CustomAttribute.records[i].Parent & 0xFFFFFF) - 1;
 					if (typeName == GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName))
 					{
 						ConstructorInfo constructor = (ConstructorInfo)ResolveMethod(CustomAttribute.records[i].Type);
 						list.Add(new CustomAttributeData(this.Assembly, constructor, GetBlob(CustomAttribute.records[i].Value)));
 					}
 				}
 			}
 			for (int i = 0; i < CustomAttribute.records.Length; i++)
 			{
 				if ((CustomAttribute.records[i].Parent >> 24) == TypeRefTable.Index)
 				{
 					int index = (CustomAttribute.records[i].Parent & 0xFFFFFF) - 1;
 					if (typeName == GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName))
 					{
 						ConstructorInfo constructor = (ConstructorInfo)ResolveMethod(CustomAttribute.records[i].Type);
 						list.Add(new CustomAttributeData(this.Assembly, constructor, GetBlob(CustomAttribute.records[i].Value)));
 					}
 				}
 			}
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5053" endline="5096">
<![CDATA[
 		
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			bool is_volatile = false;
 
 			if ((spec.Modifiers & Modifiers.VOLATILE) != 0)
 				is_volatile = true;
 
 			spec.MemberDefinition.SetIsUsed ();
 			
 			if (IsStatic){
 				if (is_volatile)
 					ec.Emit (OpCodes.Volatile);
 
 				ec.Emit (OpCodes.Ldsfld, spec);
 			} else {
 				if (!prepared)
 					EmitInstance (ec, false);
 
 				// Optimization for build-in types
 				if (TypeManager.IsStruct (type) && type == ec.MemberContext.CurrentType && InstanceExpression.Type == type) {
 					ec.EmitLoadFromPtr (type);
 				} else {
 					var ff = spec as FixedFieldSpec;
 					if (ff != null) {
 						ec.Emit (OpCodes.Ldflda, spec);
 						ec.Emit (OpCodes.Ldflda, ff.Element);
 					} else {
 						if (is_volatile)
 							ec.Emit (OpCodes.Volatile);
 
 						ec.Emit (OpCodes.Ldfld, spec);
 					}
 				}
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (!IsStatic) {
 					temp = new LocalTemporary (this.Type);
 					temp.Store (ec);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4830" endline="4838">
<![CDATA[
 
 		public override bool Equals (object obj)
 		{
 			LocalVariableReference lvr = obj as LocalVariableReference;
 			if (lvr == null)
 				return false;
 
 			return local_info == lvr.local_info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1465" endline="1472">
<![CDATA[
 
 		internal static void InplaceBindTypeParameters(IGenericBinder binder, Type[] types)
 		{
 			for (int i = 0; i < types.Length; i++)
 			{
 				types[i] = types[i].BindTypeParameters(binder);
 			}
 			for (int i = 0; i < types.Length; i++)
 			{
 				types[i] = types[i].BindTypeParameters(binder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1312" endline="1323">
<![CDATA[
 
 		public int CompareTo (object obj)
 		{
 			MethodEntry method = (MethodEntry) obj;
 
 			if (method.Token < Token)
 				return 1;
 			else if (method.Token > Token)
 				return -1;
 			else
 				return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5820" endline="5831">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			LocalTemporary v = null;
 			if (method == null && TypeManager.IsValueType (type)) {
 				// TODO
 				v = new LocalTemporary (type);
 			}
 
 			if (Emit (ec, v))
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="422" endline="439">
<![CDATA[
 
 		//
 		// A special method to work with member lookup only. It returns a list of all members named @name
 		// starting from @container. It's very performance sensitive
 		//
 		public static IList<MemberSpec> FindMembers (TypeSpec container, string name, bool declaredOnly)
 		{
 			IList<MemberSpec> applicable;
 
 			do {
 				if (container.MemberCache.member_hash.TryGetValue (name, out applicable) || declaredOnly)
 					return applicable;
 
 				container = container.BaseType;
 			} while (container != null);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1298" endline="1311">
<![CDATA[
 
 		public string GetRealName ()
 		{
 			lock (SymbolFile) {
 				if (real_name != null)
 					return real_name;
 
 				if (RealNameOffset == 0)
 					return null;
 
 				real_name = SymbolFile.BinaryReader.ReadString (RealNameOffset);
 				return real_name;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="151" endline="166">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			BlockContext bc = new BlockContext (ec.MemberContext, Block, ReturnType);
 			Expression args = parameters.CreateExpressionTree (bc, loc);
 			Expression expr = Block.CreateExpressionTree (ec);
 			if (expr == null)
 				return null;
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (expr));
 			arguments.Add (new Argument (args));
 			return CreateExpressionFactoryCall (ec, "Lambda",
 				new TypeArguments (new TypeExpression (type, loc)),
 				arguments);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="784" endline="826">
<![CDATA[
 
 		private MemberInfo ResolveTypeMemberRef(Type type, string name, ByteReader sig, Type[] genericTypeArguments, Type[] genericMethodArguments)
 		{
 			IGenericContext context;
 			if ((genericTypeArguments == null && genericMethodArguments == null) || type.IsGenericType)
 			{
 				context = type;
 			}
 			else
 			{
 				context = new GenericContext(genericTypeArguments, genericMethodArguments);
 			}
 			if (sig.PeekByte() == Signature.FIELD)
 			{
 				Type org = type;
 				FieldSignature fieldSig = FieldSignature.ReadSig(this, sig, context);
 				do
 				{
 					FieldInfo field = type.FindField(name, fieldSig);
 					if (field != null)
 					{
 						return field;
 					}
 					type = type.BaseType;
 				} while (type != null);
 				throw new MissingFieldException(org.ToString(), name);
 			}
 			else
 			{
 				Type org = type;
 				MethodSignature methodSig = MethodSignature.ReadSig(this, sig, context);
 				do
 				{
 					MethodBase method = type.FindMethod(name, methodSig);
 					if (method != null)
 					{
 						return method;
 					}
 					type = type.BaseType;
 				} while (type != null);
 				throw new MissingMethodException(org.ToString(), name);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4025" endline="4057">
<![CDATA[
 
 		//
 		// Creates nested calls tree from an array of arguments used for IL emit
 		//
 		Expression CreateExpressionAddCall (ResolveContext ec, Argument left, Expression left_etree, int pos)
 		{
 			Arguments concat_args = new Arguments (2);
 			Arguments add_args = new Arguments (3);
 
 			concat_args.Add (left);
 			add_args.Add (new Argument (left_etree));
 
 			concat_args.Add (arguments [pos]);
 			add_args.Add (new Argument (arguments [pos].CreateExpressionTree (ec)));
 
 			var methods = CreateConcatMethodCandidates ();
 			if (methods == null)
 				return null;
 
 			var res = new OverloadResolver (methods, OverloadResolver.Restrictions.NoBaseMembers, loc);
 			var method = res.ResolveMember<MethodSpec> (ec, ref concat_args);
 			if (method == null)
 				return null;
 
 			add_args.Add (new Argument (new TypeOfMethod (method, loc)));
 
 			Expression expr = CreateExpressionFactoryCall (ec, "Add", add_args);
 			if (++pos == arguments.Count)
 				return expr;
 
 			left = new Argument (new EmptyExpression (method.ReturnType));
 			return CreateExpressionAddCall (ec, left, expr, pos);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="114" endline="124">
<![CDATA[
 		}
 
 		public bool IsGeneric {
 			get {
 				if (TypeArguments != null)
 					return true;
 				else if (Left != null)
 					return Left.IsGeneric;
 				else
 					return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="950" endline="966">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			if (ec.Switch == null) {
 				ec.Report.Error (153, loc, "A goto case is only valid inside a switch statement");
 				return false;
 			}
 
 			if (!ec.Switch.GotDefault) {
 				FlowBranchingBlock.Error_UnknownLabel (loc, "default", ec.Report);
 				return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2111" endline="2122">
<![CDATA[
 
 		bool ResolveTransformationCtor (Location loc)
 		{
 			if (tctor != null)
 				return true;
 
 			if (Resolve (loc) == null)
 				return false;
 
 			tctor = TypeManager.GetPredefinedConstructor (type, Location.Null, ArrayContainer.MakeType (TypeManager.bool_type));
 			return tctor != null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5962" endline="5981">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			var current_field = rc.CurrentMemberDefinition as FieldBase;
 			TypeExpression type;
 			if (current_field != null) {
 				type = new TypeExpression (current_field.MemberType, current_field.Location);
 			} else if (variable != null) {
 				if (variable.TypeExpression is VarExpr) {
 					rc.Report.Error (820, loc, "An implicitly typed local variable declarator cannot use an array initializer");
 					return EmptyExpression.Null;
 				}
 
 				type = new TypeExpression (variable.Variable.Type, variable.Variable.Location);
 			} else {
 				throw new NotImplementedException ("Unexpected array initializer context");
 			}
 
 			return new ArrayCreation (type, this).Resolve (rc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6470" endline="6497">
<![CDATA[
 #endif
 		//
 		// Emits the initializers for the array
 		//
 		void EmitStaticInitializers (EmitContext ec)
 		{
 			if (TypeManager.void_initializearray_array_fieldhandle == null) {
 				var helper = ec.CurrentTypeDefinition.Module.PredefinedTypes.RuntimeHelpers.Resolve (loc);
 				if (helper == null)
 					return;
 
 				TypeManager.void_initializearray_array_fieldhandle = TypeManager.GetPredefinedMethod (
 					helper, "InitializeArray", loc,
 					TypeManager.array_type, TypeManager.runtime_field_handle_type);
 				if (TypeManager.void_initializearray_array_fieldhandle == null)
 					return;
 			}
 
 			//
 			// First, the static data
 			//
 			byte [] data = MakeByteBlob ();
 			var fb = ec.CurrentTypeDefinition.Module.MakeStaticData (data, loc);
 
 			ec.Emit (OpCodes.Dup);
 			ec.Emit (OpCodes.Ldtoken, fb);
 			ec.Emit (OpCodes.Call, TypeManager.void_initializearray_array_fieldhandle);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="220" endline="228">
<![CDATA[
 		}
 
 		public MemberCache MemberCacheTypes {
 			get {
 				if (cache == null)
 					InitializeMemberCache (true);
 
 				return cache;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1290" endline="1302">
<![CDATA[
 
 		internal void GetLayout(int token, ref int pack, ref int size)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Parent == token)
 				{
 					pack = records[i].PackingSize;
 					size = records[i].ClassSize;
 					break;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Parent == token)
 				{
 					pack = records[i].PackingSize;
 					size = records[i].ClassSize;
 					break;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1658" endline="1672">
<![CDATA[
 		}
 
 		public override string Name {
 			get {
 				if (name == null) {
 					name = base.Name;
 					if (tparams != null) {
 						int arity_start = name.IndexOf ('`');
 						if (arity_start > 0)
 							name = name.Substring (0, arity_start);
 					}
 				}
 
 				return name;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="259" endline="272">
<![CDATA[
 
 		public void AddParentStoreyReference (EmitContext ec, AnonymousMethodStorey storey)
 		{
 			CheckMembersDefined ();
 
 			if (used_parent_storeys == null)
 				used_parent_storeys = new List<StoreyFieldPair> ();
 			else if (used_parent_storeys.Exists (i => i.Storey == storey))
 				return;
 
 			TypeExpr type_expr = storey.CreateStoreyTypeExpression (ec);
 			Field f = AddCompilerGeneratedField ("<>f__ref$" + storey.ID, type_expr);
 			used_parent_storeys.Add (new StoreyFieldPair (storey, f));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="808" endline="821">
<![CDATA[
 
 		internal int FindOrAddRecord(Record record)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Class == record.Class
 					&& records[i].Name == record.Name
 					&& records[i].Signature == record.Signature)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Class == record.Class
 					&& records[i].Name == record.Name
 					&& records[i].Signature == record.Signature)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(record);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2160" endline="2173">
<![CDATA[
 
 		internal int FindOrAddRecord(Record rec)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Implementation == rec.Implementation
 					&& records[i].TypeName == rec.TypeName
 					&& records[i].TypeNamespace == rec.TypeNamespace)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Implementation == rec.Implementation
 					&& records[i].TypeName == rec.TypeName
 					&& records[i].TypeNamespace == rec.TypeNamespace)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="592" endline="613">
<![CDATA[
 
 		public void FreeTemporaryLocal (LocalBuilder b, TypeSpec t)
 		{
 			if (temporary_storage == null) {
 				temporary_storage = new Dictionary<TypeSpec, object> (ReferenceEquality<TypeSpec>.Default);
 				temporary_storage.Add (t, b);
 				return;
 			}
 			object o;
 			
 			if (!temporary_storage.TryGetValue (t, out o)) {
 				temporary_storage.Add (t, b);
 				return;
 			}
 			var s = o as Stack<LocalBuilder>;
 			if (s == null) {
 				s = new Stack<LocalBuilder> ();
 				s.Push ((LocalBuilder)o);
 				temporary_storage [t] = s;
 			}
 			s.Push (b);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6623" endline="6639">
<![CDATA[
 		
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			ArrayCreation target = (ArrayCreation) t;
 
 			if (requested_base_type != null)
 				target.requested_base_type = (FullNamedExpression)requested_base_type.Clone (clonectx);
 
 			if (arguments != null){
 				target.arguments = new List<Expression> (arguments.Count);
 				foreach (Expression e in arguments)
 					target.arguments.Add (e.Clone (clonectx));
 				foreach (Expression e in arguments)
 					target.arguments.Add (e.Clone (clonectx));
 			}
 
 			if (initializers != null)
 				target.initializers = (ArrayInitializer) initializers.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="875" endline="892">
<![CDATA[
 
 		void AddUsingAlias (UsingAliasEntry uae)
 		{
 			if (using_aliases == null) {
 				using_aliases = new List<UsingAliasEntry> ();
 			} else {
 				foreach (UsingAliasEntry entry in using_aliases) {
 					if (uae.Alias == entry.Alias) {
 						Compiler.Report.SymbolRelatedToPreviousError (uae.Location, uae.Alias);
 						Compiler.Report.Error (1537, entry.Location, "The using alias `{0}' appeared previously in this namespace",
 							entry.Alias);
 						return;
 					}
 				}
 				foreach (UsingAliasEntry entry in using_aliases) {
 					if (uae.Alias == entry.Alias) {
 						Compiler.Report.SymbolRelatedToPreviousError (uae.Location, uae.Alias);
 						Compiler.Report.Error (1537, entry.Location, "The using alias `{0}' appeared previously in this namespace",
 							entry.Alias);
 						return;
 					}
 				}
 			}
 
 			using_aliases.Add (uae);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="283" endline="306">
<![CDATA[
 
 		private static void WriteNameOrOrdinal(ByteBuffer bb, OrdinalOrName id, Dictionary<string, int> strings, ref int stringTableOffset, ByteBuffer stringTable)
 		{
 			if (id.Name == null)
 			{
 				bb.Write((int)id.Ordinal);
 			}
 			else
 			{
 				int stringOffset;
 				if (!strings.TryGetValue(id.Name, out stringOffset))
 				{
 					stringOffset = stringTableOffset;
 					strings.Add(id.Name, stringOffset);
 					stringTableOffset += id.Name.Length * 2 + 2;
 					stringTable.Write((ushort)id.Name.Length);
 					foreach (char c in id.Name)
 					{
 						stringTable.Write((short)c);
 					}
 					foreach (char c in id.Name)
 					{
 						stringTable.Write((short)c);
 					}
 				}
 				bb.Write(0x80000000U | (uint)stringOffset);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1018" endline="1033">
<![CDATA[
 
 		public void InflateConstraints (TypeParameterInflator inflator, TypeParameterSpec tps)
 		{
 			tps.BaseType = inflator.Inflate (BaseType);
 			if (ifaces != null) {
 				tps.ifaces = new List<TypeSpec> (ifaces.Count);
 				for (int i = 0; i < ifaces.Count; ++i)
 					tps.ifaces.Add (inflator.Inflate (ifaces[i]));
 				for (int i = 0; i < ifaces.Count; ++i)
 					tps.ifaces.Add (inflator.Inflate (ifaces[i]));
 			}
 
 			if (targs != null) {
 				tps.targs = new TypeSpec[targs.Length];
 				for (int i = 0; i < targs.Length; ++i)
 					tps.targs[i] = inflator.Inflate (targs[i]);
 				for (int i = 0; i < targs.Length; ++i)
 					tps.targs[i] = inflator.Inflate (targs[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1700" endline="1716">
<![CDATA[
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			Type[] int32 = new Type[] { this.Module.universe.System_Int32 };
 			List<MethodBase> list = new List<MethodBase>();
 			list.Add(new BuiltinArrayMethod(this.Module, this, "Set", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, new Type[] { this.Module.universe.System_Int32, elementType }));
 			list.Add(new BuiltinArrayMethod(this.Module, this, "Address", CallingConventions.Standard | CallingConventions.HasThis, elementType.MakeByRefType(), int32));
 			list.Add(new BuiltinArrayMethod(this.Module, this, "Get", CallingConventions.Standard | CallingConventions.HasThis, elementType, int32));
 			list.Add(new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, int32)));
 			for (Type type = elementType; type.__IsVector; type = type.GetElementType())
 			{
 				Array.Resize(ref int32, int32.Length + 1);
 				int32[int32.Length - 1] = int32[0];
 				list.Add(new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, int32)));
 			}
 			for (Type type = elementType; type.__IsVector; type = type.GetElementType())
 			{
 				Array.Resize(ref int32, int32.Length + 1);
 				int32[int32.Length - 1] = int32[0];
 				list.Add(new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, int32)));
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="191" endline="220">
<![CDATA[
 
 		internal void Bake()
 		{
 			PropertyTable.Record rec = new PropertyTable.Record();
 			rec.Flags = (short)attributes;
 			rec.Name = typeBuilder.ModuleBuilder.Strings.Add(name);
 			rec.Type = typeBuilder.ModuleBuilder.GetSignatureBlobIndex(sig);
 			int token = 0x17000000 | typeBuilder.ModuleBuilder.Property.AddRecord(rec);
 
 			if (lazyPseudoToken != 0)
 			{
 				typeBuilder.ModuleBuilder.RegisterTokenFixup(lazyPseudoToken, token);
 			}
 
 			if (getter != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Getter, getter.MetadataToken, token);
 			}
 			if (setter != null)
 			{
 				AddMethodSemantics(MethodSemanticsTable.Setter, setter.MetadataToken, token);
 			}
 			if (otherMethods != null)
 			{
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 				foreach (MethodBuilder method in otherMethods)
 				{
 					AddMethodSemantics(MethodSemanticsTable.Other, method.MetadataToken, token);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="134" endline="140">
<![CDATA[
 
 		public SourceFileEntry DefineDocument (string url)
 		{
 			SourceFileEntry entry = new SourceFileEntry (file, url);
 			sources.Add (entry);
 			return entry;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="148" endline="154">
<![CDATA[
 
 		public CompileUnitEntry DefineCompilationUnit (SourceFileEntry source)
 		{
 			CompileUnitEntry entry = new CompileUnitEntry (file, source);
 			comp_units.Add (entry);
 			return entry;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1096" endline="1103">
<![CDATA[
 
 		public int GetFieldIndex (string name)
 		{
 			if (struct_info == null)
 				return 0;
 
 			return struct_info [name];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="334" endline="341">
<![CDATA[
 		
 		public virtual bool CheckAccessibility (InterfaceMemberBase member)
 		{
 			if (parameter_type == null)
 				return true;
 
 			return member.IsAccessibleAs (parameter_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="205" endline="213">
<![CDATA[
 
 		public void SymbolRelatedToPreviousError (string loc)
 		{
 			string msg = String.Format ("{0} (Location of the symbol related to previous ", loc);
 			if (extra_information.Contains (msg))
 				return;
 
 			extra_information.Add (msg);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="546" endline="556">
<![CDATA[
 		}
 
 		public bool IsDefaultInitializer {
 			get {
 				Constant c = source as Constant;
 				if (c == null)
 					return false;
 				
 				FieldExpr fe = (FieldExpr)target;
 				return c.IsDefaultInitializer (fe.Type);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="728" endline="737">
<![CDATA[
 
 		internal void RegisterTokenFixup(int pseudoToken, int realToken)
 		{
 			int index = -(pseudoToken + 1);
 			while (resolvedTokens.Count <= index)
 			{
 				resolvedTokens.Add(0);
 			}
 			while (resolvedTokens.Count <= index)
 			{
 				resolvedTokens.Add(0);
 			}
 			resolvedTokens[index] = realToken;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1340" endline="1348">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2481" endline="2493">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (statements.Count == 1) {
 				Expression expr = ((Statement) statements[0]).CreateExpressionTree (ec);
 				if (scope_initializers != null)
 					expr = new BlockScopeExpression (expr, this);
 
 				return expr;
 			}
 
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="434" endline="445">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression e = base.DoResolve (ec);
 			if (e == null || e != this)
 				return e;
 
 			if (CheckEqualAssign (target))
 				ec.Report.Warning (1717, 3, loc, "Assignment made to same variable; did you mean to assign something else?");
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="740" endline="755">
<![CDATA[
 		}
 
 		public int Token {
 			get {
 				MethodToken token;
 				var mb = method as MethodBuilder;
 				if (mb != null)
 					token = mb.GetToken ();
 				else
 					token = ((ConstructorBuilder) method).GetToken ();
 #if STATIC
 				if (token.IsPseudoToken)
 					return ((ModuleBuilder) method.Module).ResolvePseudoToken (token.Token);
 #endif
 				return token.Token;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ManifestResourceInfo.cs" startline="69" endline="88">
<![CDATA[
 		}
 
 		public string FileName
 		{
 			get
 			{
 				int implementation = module.ManifestResource.records[index].Implementation;
 				if ((implementation >> 24) == FileTable.Index)
 				{
 					if ((implementation & 0xFFFFFF) == 0)
 					{
 						return null;
 					}
 					else
 					{
 						return module.GetString(module.File.records[(implementation & 0xFFFFFF) - 1].Name);
 					}
 				}
 				throw new NotImplementedException();
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="98" endline="112">
<![CDATA[
 
 		public override Type[] __GetDeclaredInterfaces()
 		{
 			int token = this.MetadataToken;
 			List<Type> list = new List<Type>();
 			// TODO use binary search?
 			for (int i = 0; i < module.InterfaceImpl.records.Length; i++)
 			{
 				if (module.InterfaceImpl.records[i].Class == token)
 				{
 					list.Add(module.ResolveType(module.InterfaceImpl.records[i].Interface, this));
 				}
 			}
 			for (int i = 0; i < module.InterfaceImpl.records.Length; i++)
 			{
 				if (module.InterfaceImpl.records[i].Class == token)
 				{
 					list.Add(module.ResolveType(module.InterfaceImpl.records[i].Interface, this));
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="158" endline="172">
<![CDATA[
 
 		public override Type[] __GetDeclaredTypes()
 		{
 			int token = this.MetadataToken;
 			List<Type> list = new List<Type>();
 			// TODO use binary search?
 			for (int i = 0; i < module.NestedClass.records.Length; i++)
 			{
 				if (module.NestedClass.records[i].EnclosingClass == token)
 				{
 					list.Add(module.ResolveType(module.NestedClass.records[i].NestedClass));
 				}
 			}
 			for (int i = 0; i < module.NestedClass.records.Length; i++)
 			{
 				if (module.NestedClass.records[i].EnclosingClass == token)
 				{
 					list.Add(module.ResolveType(module.NestedClass.records[i].NestedClass));
 				}
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3229" endline="3251">
<![CDATA[
 
 		//
 		// Extension methods lookup after ordinary methods candidates failed to apply
 		//
 		public virtual MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 		{
 			if (InstanceExpression == null)
 				return null;
 
 			InstanceExpression = InstanceExpression.Resolve (rc);
 			if (!IsExtensionMethodArgument (InstanceExpression))
 				return null;
 
 			int arity = type_arguments == null ? 0 
 			NamespaceEntry methods_scope = null;
 			var methods = rc.LookupExtensionMethod (InstanceExpression.Type, Methods[0].Name, arity, ref methods_scope);
 			if (methods == null)
 				return null;
 
 			var emg = new ExtensionMethodGroupExpr (methods, methods_scope, InstanceExpression, loc);
 			emg.SetTypeArguments (rc, type_arguments);
 			return emg;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1441" endline="1471">
<![CDATA[
 
 		protected override bool CheckBase ()
 		{
 			if ((ModFlags & Modifiers.STATIC) != 0) {
 				if (!parameters.IsEmpty) {
 					Report.Error (132, Location, "`{0}'
 						GetSignatureForError ());
 					return false;
 				}
 
 				// the rest can be ignored
 				return true;
 			}
 
 			// Check whether arguments were correct.
 			if (!DefineParameters (parameters))
 				return false;
 
 			if ((caching_flags & Flags.MethodOverloadsExist) != 0)
 				Parent.MemberCache.CheckExistingMembersOverloads (this, parameters);
 
 			if (Parent.PartialContainer.Kind == MemberKind.Struct && parameters.IsEmpty) {
 				Report.Error (568, Location, 
 					"Structs cannot contain explicit parameterless constructors");
 				return false;
 			}
 
 			CheckProtectedModifier ();
 			
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3323" endline="3359">
<![CDATA[
 
 
 		Expression ResolveOperatorPointer (ResolveContext ec, TypeSpec l, TypeSpec r)
 		{
 			//
 			// bool operator == (void* x, void* y);
 			// bool operator != (void* x, void* y);
 			// bool operator < (void* x, void* y);
 			// bool operator > (void* x, void* y);
 			// bool operator <= (void* x, void* y);
 			// bool operator >= (void* x, void* y);
 			//
 			if ((oper & Operator.ComparisonMask) != 0) {
 				Expression temp;
 				if (!l.IsPointer) {
 					temp = Convert.ImplicitConversion (ec, left, r, left.Location);
 					if (temp == null)
 						return null;
 					left = temp;
 				}
 
 				if (!r.IsPointer) {
 					temp = Convert.ImplicitConversion (ec, right, l, right.Location);
 					if (temp == null)
 						return null;
 					right = temp;
 				}
 
 				type = TypeManager.bool_type;
 				return this;
 			}
 
 			if (pointer_operators == null)
 				CreatePointerOperatorsTable ();
 
 			return ResolveOperatorPredefined (ec, pointer_operators, false, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5124" endline="5161">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			VariableReference vr;
 			bool vr_locked = false;
 
 			using (ec.Set (ResolveContext.Options.UsingInitializerScope)) {
 				if (decl.Variable == null) {
 					vr = decl.ResolveExpression (ec) as VariableReference;
 					if (vr != null) {
 						vr_locked = vr.IsLockedByStatement;
 						vr.IsLockedByStatement = true;
 					}
 				} else {
 					if (!decl.Resolve (ec))
 						return false;
 
 					if (decl.Declarators != null) {
 						stmt = decl.RewriteForDeclarators (ec, stmt);
 					}
 
 					vr = null;
 				}
 			}
 
 			ec.StartFlowBranching (this);
 
 			stmt.Resolve (ec);
 
 			ec.EndFlowBranching ();
 
 			if (vr != null)
 				vr.IsLockedByStatement = vr_locked;
 
 			base.Resolve (ec);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1695" endline="1718">
<![CDATA[
 
 		public void SetRange (int offset, int length)
 		{
 			if (offset > Count || offset + length > Count)
 				throw new ArgumentOutOfRangeException ("flow-analysis");
 
 			if (shared == null && vector == null)
 				return;
 
 			int i = 0;
 			if (shared != null) {
 				if (offset + length <= shared.Count) {
 					for (; i < length; ++i)
 						if (!shared [i+offset])
 						    break;
 					for (; i < length; ++i)
 						if (!shared [i+offset])
 						    break;
 					if (i == length)
 						return;
 				}
 				initialize_vector ();
 			}
 			for (; i < length; ++i)
 				vector [i+offset] = true;
 			for (; i < length; ++i)
 				vector [i+offset] = true;
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2083" endline="2126">
<![CDATA[
 		}
 
 		//
 		// Public function used to locate types.
 		//
 		// Set 'ignore_cs0104' to true if you want to ignore cs0104 errors.
 		//
 		// Returns
 		//
 		public override FullNamedExpression LookupNamespaceOrType (string name, int arity, Location loc, bool ignore_cs0104)
 		{
 			FullNamedExpression e;
 			if (arity == 0 && Cache.TryGetValue (name, out e))
 				return e;
 
 			e = null;
 			int errors = Report.Errors;
 
 			if (arity == 0) {
 				TypeParameter[] tp = CurrentTypeParameters;
 				if (tp != null) {
 					TypeParameter tparam = TypeParameter.FindTypeParameter (tp, name);
 					if (tparam != null)
 						e = new TypeParameterExpr (tparam, Location.Null);
 				}
 			}
 
 			if (e == null) {
 				TypeSpec t = LookupNestedTypeInHierarchy (name, arity);
 
 				if (t != null)
 					e = new TypeExpression (t, Location.Null);
 				else if (Parent != null) {
 					e = Parent.LookupNamespaceOrType (name, arity, loc, ignore_cs0104);
 				} else
 					e = NamespaceEntry.LookupNamespaceOrType (name, arity, loc, ignore_cs0104);
 			}
 
 			// TODO MemberCache
 			if (errors == Report.Errors && arity == 0)
 				Cache[name] = e;
 
 			return e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9078" endline="9114">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			count = count.Resolve (ec);
 			if (count == null)
 				return null;
 			
 			if (count.Type != TypeManager.uint32_type){
 				count = Convert.ImplicitConversionRequired (ec, count, TypeManager.int32_type, loc);
 				if (count == null)
 					return null;
 			}
 
 			Constant c = count as Constant;
 			if (c != null && c.IsNegative) {
 				ec.Report.Error (247, loc, "Cannot use a negative size with stackalloc");
 			}
 
 			if (ec.HasAny (ResolveContext.Options.CatchScope | ResolveContext.Options.FinallyScope)) {
 				ec.Report.Error (255, loc, "Cannot use stackalloc in finally or catch");
 			}
 
 			TypeExpr texpr = t.ResolveAsTypeTerminal (ec, false);
 			if (texpr == null)
 				return null;
 
 			otype = texpr.Type;
 
 			if (!TypeManager.VerifyUnmanaged (ec.Compiler, otype, loc))
 				return null;
 
 			type = PointerContainer.MakeType (otype);
 			eclass = ExprClass.Value;
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="255" endline="291">
<![CDATA[
 		}
 
 		public void BeginCatchBlock(Type exceptionType)
 		{
 			ExceptionBlock block = exceptionStack.Peek();
 			if (exceptionBlockAssistanceMode == EBAM_COMPAT || (exceptionBlockAssistanceMode == EBAM_CLEVER && stackHeight != -1))
 			{
 				if (exceptionType == null)
 				{
 					Emit(OpCodes.Endfilter);
 				}
 				else
 				{
 					Emit(OpCodes.Leave, block.labelEnd);
 				}
 			}
 			stackHeight = 0;
 			UpdateStack(1);
 			if (block.tryLength == 0)
 			{
 				block.tryLength = code.Position - block.tryOffset;
 			}
 			else if (exceptionType != null)
 			{
 				block.handlerLength = code.Position - block.handlerOffset;
 				exceptionStack.Pop();
 				ExceptionBlock newBlock = new ExceptionBlock(exceptions.Count);
 				newBlock.labelEnd = block.labelEnd;
 				newBlock.tryOffset = block.tryOffset;
 				newBlock.tryLength = block.tryLength;
 				block = newBlock;
 				exceptions.Add(block);
 				exceptionStack.Push(block);
 			}
 			block.handlerOffset = code.Position;
 			block.exceptionType = exceptionType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9657" endline="9694">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (ec.HasSet (ResolveContext.Options.ConstantScope)) {
 				ec.Report.Error (836, loc, "Anonymous types cannot be used in this expression");
 				return null;
 			}
 
 			if (parameters == null) {
 				anonymous_type = CreateAnonymousType (ec, EmptyParameters);
 				RequestedType = new TypeExpression (anonymous_type.Definition, loc);
 				return base.DoResolve (ec);
 			}
 
 			bool error = false;
 			arguments = new Arguments (parameters.Count);
 			TypeExpression [] t_args = new TypeExpression [parameters.Count];
 			for (int i = 0; i < parameters.Count; ++i) {
 				Expression e = ((AnonymousTypeParameter) parameters [i]).Resolve (ec);
 				if (e == null) {
 					error = true;
 					continue;
 				}
 
 				arguments.Add (new Argument (e));
 				t_args [i] = new TypeExpression (e.Type, e.Location);
 			}
 			for (int i = 0; i < parameters.Count; ++i) {
 				Expression e = ((AnonymousTypeParameter) parameters [i]).Resolve (ec);
 				if (e == null) {
 					error = true;
 					continue;
 				}
 
 				arguments.Add (new Argument (e));
 				t_args [i] = new TypeExpression (e.Type, e.Location);
 			}
 
 			if (error)
 				return null;
 
 			anonymous_type = CreateAnonymousType (ec, parameters);
 			if (anonymous_type == null)
 				return null;
 
 			RequestedType = new GenericTypeExpr (anonymous_type.Definition, new TypeArguments (t_args), loc);
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="120" endline="156">
<![CDATA[
 
 		internal override void WriteSig(ModuleBuilder module, ByteBuffer bb)
 		{
 			byte flags = PROPERTY;
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				flags |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				flags |= EXPLICITTHIS;
 			}
 			if ((callingConvention & CallingConventions.VarArgs) != 0)
 			{
 				flags |= VARARG;
 			}
 			bb.Write(flags);
 			bb.WriteCompressedInt(parameterTypes == null ? 0 
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers);
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers);
 			WriteType(module, bb, propertyType);
 			if (parameterTypes != null)
 			{
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterRequiredCustomModifiers[i]);
 					}
 					if (parameterOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterRequiredCustomModifiers[i]);
 					}
 					if (parameterOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4340" endline="4381">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			// A boolean-expression is required to be of a type
 			// that can be implicitly converted to bool or of
 			// a type that implements operator true
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			Assign ass = expr as Assign;
 			if (ass != null && ass.Source is Constant) {
 				ec.Report.Warning (665, 3, loc,
 					"Assignment in conditional expression is always constant. Did you mean to use `==' instead ?");
 			}
 
 			if (expr.Type == TypeManager.bool_type)
 				return expr;
 
 			if (expr.Type == InternalType.Dynamic) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return DynamicUnaryConversion.CreateIsTrue (args, loc).Resolve (ec);
 			}
 
 			type = TypeManager.bool_type;
 			Expression converted = Convert.ImplicitConversion (ec, expr, type, loc);
 			if (converted != null)
 				return converted;
 
 			//
 			// If no implicit conversion to bool exists, try using `operator true'
 			//
 			converted = GetOperatorTrue (ec, expr, loc);
 			if (converted == null) {
 				expr.Error_ValueCannotBeConverted (ec, loc, type, false);
 				return null;
 			}
 
 			return converted;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="368" endline="408">
<![CDATA[
 
 		protected bool CheckAbstractAndExtern (bool has_block)
 		{
 			if (Parent.PartialContainer.Kind == MemberKind.Interface)
 				return true;
 
 			if (has_block) {
 				if ((ModFlags & Modifiers.EXTERN) != 0) {
 					Report.Error (179, Location, "`{0}' cannot declare a body because it is marked extern",
 						GetSignatureForError ());
 					return false;
 				}
 
 				if ((ModFlags & Modifiers.ABSTRACT) != 0) {
 					Report.Error (500, Location, "`{0}' cannot declare a body because it is marked abstract",
 						GetSignatureForError ());
 					return false;
 				}
 			} else {
 				if ((ModFlags & (Modifiers.ABSTRACT | Modifiers.EXTERN | Modifiers.PARTIAL)) == 0 && !(Parent is Delegate)) {
 					if (RootContext.Version >= LanguageVersion.V_3) {
 						Property.PropertyMethod pm = this as Property.PropertyMethod;
 						if (pm is Indexer.GetIndexerMethod || pm is Indexer.SetIndexerMethod)
 							pm = null;
 
 						if (pm != null && pm.Property.AccessorSecond == null) {
 							Report.Error (840, Location,
 								"`{0}' must have a body because it is not marked abstract or extern. The property can be automatically implemented when you define both accessors",
 								GetSignatureForError ());
 							return false;
 						}
 					}
 
 					Report.Error (501, Location, "`{0}' must have a body because it is not marked abstract, extern, or partial",
 					              GetSignatureForError ());
 					return false;
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7179" endline="7206">
<![CDATA[
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			// Target type is not System.Type therefore must be object
 			// and we need to use different encoding sequence
 			if (targetType != type)
 				enc.Encode (type);
 
 			if (!(QueriedType is GenericOpenTypeExpr)) {
 				var gt = typearg;
 				while (gt != null) {
 					if (InflatedTypeSpec.ContainsTypeParameter (gt)) {
 						rc.Compiler.Report.Error (416, loc, "`{0}'
 							typearg.GetSignatureForError ());
 						return;
 					}
 
 					gt = gt.DeclaringType;
 				}
 				while (gt != null) {
 					if (InflatedTypeSpec.ContainsTypeParameter (gt)) {
 						rc.Compiler.Report.Error (416, loc, "`{0}'
 							typearg.GetSignatureForError ());
 						return;
 					}
 
 					gt = gt.DeclaringType;
 				}
 
 				if (ContainsDynamicType (typearg)) {
 					Attribute.Error_AttributeArgumentIsDynamic (rc, loc);
 					return;
 				}
 			}
 
 			enc.EncodeTypeName (typearg);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\VersionInfo.cs" startline="254" endline="278">
<![CDATA[
 
 		private static ushort ParseVersionPart(string str, ref int pos)
 		{
 			ushort value = 0;
 			while (pos < str.Length)
 			{
 				char c = str[pos];
 				if (c == '.')
 				{
 					pos++;
 					break;
 				}
 				else if (c >= '0' && c <= '9')
 				{
 					value *= 10;
 					value += (ushort)(c - '0');
 					pos++;
 				}
 				else
 				{
 					break;
 				}
 			}
 			while (pos < str.Length)
 			{
 				char c = str[pos];
 				if (c == '.')
 				{
 					pos++;
 					break;
 				}
 				else if (c >= '0' && c <= '9')
 				{
 					value *= 10;
 					value += (ushort)(c - '0');
 					pos++;
 				}
 				else
 				{
 					break;
 				}
 			}
 			return value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2604" endline="2642">
<![CDATA[
 
 		private int consume_string (bool quoted)
 		{
 			int c;
 			string_builder.Length = 0;
 
 			while (true){
 				c = get_char ();
 				if (c == '"') {
 					if (quoted && peek_char () == '"') {
 						string_builder.Append ((char) c);
 						get_char ();
 						continue;
 					}
 
 					val = new StringLiteral (string_builder.ToString (), Location);
 					return Token.LITERAL;
 				}
 
 				if (c == '\n') {
 					if (!quoted)
 						Report.Error (1010, Location, "Newline in constant");
 				} else if (c == '\\' && !quoted) {
 					int surrogate;
 					c = escape (c, out surrogate);
 					if (c == -1)
 						return Token.ERROR;
 					if (surrogate != 0) {
 						string_builder.Append ((char) c);
 						c = surrogate;
 					}
 				} else if (c == -1) {
 					Report.Error (1039, Location, "Unterminated string literal");
 					return Token.EOF;
 				}
 
 				string_builder.Append ((char) c);
 			}
 			while (true){
 				c = get_char ();
 				if (c == '"') {
 					if (quoted && peek_char () == '"') {
 						string_builder.Append ((char) c);
 						get_char ();
 						continue;
 					}
 
 					val = new StringLiteral (string_builder.ToString (), Location);
 					return Token.LITERAL;
 				}
 
 				if (c == '\n') {
 					if (!quoted)
 						Report.Error (1010, Location, "Newline in constant");
 				} else if (c == '\\' && !quoted) {
 					int surrogate;
 					c = escape (c, out surrogate);
 					if (c == -1)
 						return Token.ERROR;
 					if (surrogate != 0) {
 						string_builder.Append ((char) c);
 						c = surrogate;
 					}
 				} else if (c == -1) {
 					Report.Error (1039, Location, "Unterminated string literal");
 					return Token.EOF;
 				}
 
 				string_builder.Append ((char) c);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="102" endline="114">
<![CDATA[
 
 		internal string ReadString()
 		{
 			if (PeekByte() == 0xFF)
 			{
 				pos++;
 				return null;
 			}
 			int length = ReadCompressedInt();
 			string str = Encoding.UTF8.GetString(buffer, pos, length);
 			pos += length;
 			return str;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="381" endline="401">
<![CDATA[
 
 		protected AssemblyName CreateAssemblyName ()
 		{
 			var an = new AssemblyName (name);
 
 			if (public_key != null && RootContext.Target != Target.Module) {
 				if (delay_sign) {
 					an.SetPublicKey (public_key);
 				} else {
 					if (public_key.Length == 16) {
 						Report.Error (1606, "Could not sign the assembly. ECMA key can only be used to delay-sign assemblies");
 					} else if (private_key == null) {
 						Error_AssemblySigning ("The specified key file does not have a private key");
 					} else {
 						an.KeyPair = private_key;
 					}
 				}
 			}
 
 			return an;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1836" endline="1879">
<![CDATA[
 
 		//
 		// Handles the #line directive
 		//
 		bool PreProcessLine (string arg)
 		{
 			if (arg.Length == 0)
 				return false;
 
 			if (arg == "default"){
 				ref_line = line;
 				ref_name = file_name;
 				hidden = false;
 				Location.Push (file_name, ref_name);
 				return true;
 			} else if (arg == "hidden"){
 				hidden = true;
 				return true;
 			}
 			
 			try {
 				int pos;
 
 				if ((pos = arg.IndexOf (' ')) != -1 && pos != 0){
 					ref_line = System.Int32.Parse (arg.Substring (0, pos));
 					pos++;
 					
 					char [] quotes = { '\"' };
 					
 					string name = arg.Substring (pos). Trim (quotes);
 					ref_name = Location.LookupFile (file_name, name);
 					file_name.AddFile (ref_name);
 					hidden = false;
 					Location.Push (file_name, ref_name);
 				} else {
 					ref_line = System.Int32.Parse (arg);
 					hidden = false;
 				}
 			} catch {
 				return false;
 			}
 			
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="652" endline="699">
<![CDATA[
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (member != null ? 5 
 			bool is_member_access = member is MemberAccess;
 
 			CSharpBinderFlags call_flags;
 			if (!is_member_access && member is SimpleName) {
 				call_flags = CSharpBinderFlags.InvokeSimpleName;
 				is_member_access = true;
 			} else {
 				call_flags = 0;
 			}
 
 			binder_args.Add (new Argument (new BinderFlags (call_flags, this)));
 
 			if (is_member_access)
 				binder_args.Add (new Argument (new StringLiteral (member.Name, member.Location)));
 
 			if (member != null && member.HasTypeArguments) {
 				TypeArguments ta = member.TypeArguments;
 				if (ta.Resolve (ec)) {
 					var targs = new ArrayInitializer (ta.Count, loc);
 					foreach (TypeSpec t in ta.Arguments)
 						targs.Add (new TypeOf (new TypeExpression (t, loc), loc));
 					foreach (TypeSpec t in ta.Arguments)
 						targs.Add (new TypeOf (new TypeExpression (t, loc), loc));
 
 					binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (targs, loc)));
 				}
 			} else if (is_member_access) {
 				binder_args.Add (new Argument (new NullLiteral (loc)));
 			}
 
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 
 			Expression real_args;
 			if (args == null) {
 				// Cannot be null because .NET trips over
 				real_args = new ArrayCreation (
 					new MemberAccess (GetBinderNamespace (loc), "CSharpArgumentInfo", loc),
 					new ArrayInitializer (0, loc), loc);
 			} else {
 				real_args = new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc);
 			}
 
 			binder_args.Add (new Argument (real_args));
 
 			return new Invocation (GetBinder (is_member_access ? "InvokeMember" 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="2022" endline="2082">
<![CDATA[
 
 		/// <summary>
 		///   Performs an explicit conversion of the expression `expr' whose
 		///   type is expr.Type to `target_type'.
 		/// </summary>
 		static public Expression ExplicitConversion (ResolveContext ec, Expression expr,
 			TypeSpec target_type, Location loc)
 		{
 			Expression e = ExplicitConversionCore (ec, expr, target_type, loc);
 			if (e != null) {
 				//
 				// Don't eliminate explicit precission casts
 				//
 				if (e == expr) {
 					if (target_type == TypeManager.float_type)
 						return new OpcodeCast (expr, target_type, OpCodes.Conv_R4);
 					
 					if (target_type == TypeManager.double_type)
 						return new OpcodeCast (expr, target_type, OpCodes.Conv_R8);
 				}
 					
 				return e;
 			}
 
 			TypeSpec expr_type = expr.Type;
 			if (TypeManager.IsNullableType (target_type)) {
 				if (TypeManager.IsNullableType (expr_type)) {
 					TypeSpec target = Nullable.NullableInfo.GetUnderlyingType (target_type);
 					Expression unwrap = Nullable.Unwrap.Create (expr);
 					e = ExplicitConversion (ec, unwrap, target, expr.Location);
 					if (e == null)
 						return null;
 
 					return new Nullable.Lifted (e, unwrap, target_type).Resolve (ec);
 				} else if (expr_type == TypeManager.object_type) {
 					return new UnboxCast (expr, target_type);
 				} else {
 					TypeSpec target = TypeManager.GetTypeArguments (target_type) [0];
 
 					e = ExplicitConversionCore (ec, expr, target, loc);
 					if (e != null)
 						return Nullable.Wrap.Create (e, target_type);
 				}
 			} else if (TypeManager.IsNullableType (expr_type)) {
 				e = ImplicitBoxingConversion (expr, Nullable.NullableInfo.GetUnderlyingType (expr_type), target_type);
 				if (e != null)
 					return e;
 
 				e = Nullable.Unwrap.Create (expr, false);			
 				e = ExplicitConversionCore (ec, e, target_type, loc);
 				if (e != null)
 					return EmptyCast.Create (e, target_type);
 			}
 			
 			e = ExplicitUserConversion (ec, expr, target_type, loc);
 			if (e != null)
 				return e;			
 
 			expr.Error_ValueCannotBeConverted (ec, loc, target_type, true);
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2698" endline="2706">
<![CDATA[
 
 		bool CheckFieldTypeCycle (TypeSpec ts)
 		{
 			var fts = ts.MemberDefinition as Struct;
 			if (fts == null)
 				return true;
 
 			return CheckStructCycles (fts);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="296" endline="310">
<![CDATA[
 
 		private static Type ReadType(Assembly asm, ByteReader br)
 		{
 			string typeName = br.ReadString();
 			if (typeName == null)
 			{
 				return null;
 			}
 			if (typeName.Length > 0 && typeName[typeName.Length - 1] == 0)
 			{
 				// there are broken compilers that emit an extra NUL character after the type name
 				typeName = typeName.Substring(0, typeName.Length - 1);
 			}
 			return asm.universe.GetType(asm, typeName, true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2550" endline="2577">
<![CDATA[
 
 			#endregion
 		}
 
 		readonly TypeSpec[] tp_args;
 		readonly TypeSpec[] fixed_types;
 		readonly List<BoundInfo>[] bounds;
 		bool failed;
 
 		// TODO MemberCache
 		public TypeInferenceContext (TypeSpec[] typeArguments)
 		{
 			if (typeArguments.Length == 0)
 				throw new ArgumentException ("Empty generic arguments");
 
 			fixed_types = new TypeSpec [typeArguments.Length];
 			for (int i = 0; i < typeArguments.Length; ++i) {
 				if (typeArguments [i].IsGenericParameter) {
 					if (bounds == null) {
 						bounds = new List<BoundInfo> [typeArguments.Length];
 						tp_args = new TypeSpec [typeArguments.Length];
 					}
 					tp_args [i] = typeArguments [i];
 				} else {
 					fixed_types [i] = typeArguments [i];
 				}
 			}
 			for (int i = 0; i < typeArguments.Length; ++i) {
 				if (typeArguments [i].IsGenericParameter) {
 					if (bounds == null) {
 						bounds = new List<BoundInfo> [typeArguments.Length];
 						tp_args = new TypeSpec [typeArguments.Length];
 					}
 					tp_args [i] = typeArguments [i];
 				} else {
 					fixed_types [i] = typeArguments [i];
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2944" endline="2996">
<![CDATA[
 
 		//
 		// D operator + (D x, D y)
 		// D operator - (D x, D y)
 		//
 		Expression ResolveOperatorDelegate (ResolveContext ec, TypeSpec l, TypeSpec r)
 		{
 			if (l != r && !TypeSpecComparer.Variant.IsEqual (r, l)) {
 				Expression tmp;
 				if (right.eclass == ExprClass.MethodGroup || r == InternalType.AnonymousMethod || r == InternalType.Null) {
 					tmp = Convert.ImplicitConversionRequired (ec, right, l, loc);
 					if (tmp == null)
 						return null;
 					right = tmp;
 					r = right.Type;
 				} else if (left.eclass == ExprClass.MethodGroup || (l == InternalType.AnonymousMethod || l == InternalType.Null)) {
 					tmp = Convert.ImplicitConversionRequired (ec, left, r, loc);
 					if (tmp == null)
 						return null;
 					left = tmp;
 					l = left.Type;
 				} else {
 					return null;
 				}
 			}
 
 			MethodSpec method;
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (left));
 			args.Add (new Argument (right));
 
 			if (oper == Operator.Addition) {
 				if (TypeManager.delegate_combine_delegate_delegate == null) {
 					TypeManager.delegate_combine_delegate_delegate = TypeManager.GetPredefinedMethod (
 						TypeManager.delegate_type, "Combine", loc, TypeManager.delegate_type, TypeManager.delegate_type);
 				}
 
 				method = TypeManager.delegate_combine_delegate_delegate;
 			} else if (oper == Operator.Subtraction) {
 				if (TypeManager.delegate_remove_delegate_delegate == null) {
 					TypeManager.delegate_remove_delegate_delegate = TypeManager.GetPredefinedMethod (
 						TypeManager.delegate_type, "Remove", loc, TypeManager.delegate_type, TypeManager.delegate_type);
 				}
 
 				method = TypeManager.delegate_remove_delegate_delegate;
 			} else {
 				return new EmptyExpression (TypeManager.decimal_type);
 			}
 
 			MethodGroupExpr mg = MethodGroupExpr.CreatePredefined (method, TypeManager.delegate_type, loc);
 			Expression expr = new UserOperatorCall (mg.BestCandidate, args, CreateExpressionTree, loc);
 			return new ClassCast (expr, l);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="63" endline="77">
<![CDATA[
 		}
 
 		internal uint ImportAddressTableLength
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 				{
 					return 8;
 				}
 				else
 				{
 					return 16;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="861" endline="876">
<![CDATA[
 
 		private static bool MatchParameterTypes(ParameterInfo[] parameters, Type[] types)
 		{
 			if (parameters.Length == types.Length)
 			{
 				for (int i = 0; i < parameters.Length; i++)
 				{
 					if (!parameters[i].ParameterType.Equals(types[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < parameters.Length; i++)
 				{
 					if (!parameters[i].ParameterType.Equals(types[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1001" endline="1042">
<![CDATA[
 
 		//
 		// Returns non-zero value for equal CLS parameter signatures
 		//
 		public static int IsSameClsSignature (AParametersCollection a, AParametersCollection b)
 		{
 			int res = 0;
 
 			for (int i = 0; i < a.Count; ++i) {
 				var a_type = a.Types[i];
 				var b_type = b.Types[i];
 				if (TypeSpecComparer.Override.IsEqual (a_type, b_type)) {
 					const Parameter.Modifier ref_out = Parameter.Modifier.REF | Parameter.Modifier.OUT;
 					if ((a.FixedParameters[i].ModFlags & ref_out) != (b.FixedParameters[i].ModFlags & ref_out))
 						res |= 1;
 
 					continue;
 				}
 
 				var ac_a = a_type as ArrayContainer;
 				if (ac_a == null)
 					return 0;
 
 				var ac_b = b_type as ArrayContainer;
 				if (ac_b == null)
 					return 0;
 
 				if (ac_a.Element is ArrayContainer || ac_b.Element is ArrayContainer) {
 					res |= 2;
 					continue;
 				}
 
 				if (ac_a.Rank != ac_b.Rank && TypeSpecComparer.Override.IsEqual (ac_a.Element, ac_b.Element)) {
 					res |= 1;
 					continue;
 				}
 
 				return 0;
 			for (int i = 0; i < a.Count; ++i) {
 				var a_type = a.Types[i];
 				var b_type = b.Types[i];
 				if (TypeSpecComparer.Override.IsEqual (a_type, b_type)) {
 					const Parameter.Modifier ref_out = Parameter.Modifier.REF | Parameter.Modifier.OUT;
 					if ((a.FixedParameters[i].ModFlags & ref_out) != (b.FixedParameters[i].ModFlags & ref_out))
 						res |= 1;
 
 					continue;
 				}
 
 				var ac_a = a_type as ArrayContainer;
 				if (ac_a == null)
 					return 0;
 
 				var ac_b = b_type as ArrayContainer;
 				if (ac_b == null)
 					return 0;
 
 				if (ac_a.Element is ArrayContainer || ac_b.Element is ArrayContainer) {
 					res |= 2;
 					continue;
 				}
 
 				if (ac_a.Rank != ac_b.Rank && TypeSpecComparer.Override.IsEqual (ac_a.Element, ac_b.Element)) {
 					res |= 1;
 					continue;
 				}
 
 				return 0;
 			}
 
 			return res;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5142" endline="5184">
<![CDATA[
 
 		public void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			if ((mode & AddressOp.Store) != 0)
 				spec.MemberDefinition.SetIsAssigned ();
 			if ((mode & AddressOp.Load) != 0)
 				spec.MemberDefinition.SetIsUsed ();
 
 			//
 			// Handle initonly fields specially
 			// get the address of the copy.
 			//
 			bool need_copy;
 			if (spec.IsReadOnly){
 				need_copy = true;
 				if (ec.HasSet (EmitContext.Options.ConstructorScope) && spec.DeclaringType == ec.CurrentType) {
 					if (IsStatic){
 						if (ec.IsStatic)
 							need_copy = false;
 					} else
 						need_copy = false;
 				}
 			} else
 				need_copy = false;
 			
 			if (need_copy){
 				LocalBuilder local;
 				Emit (ec);
 				local = ec.DeclareLocal (type, false);
 				ec.Emit (OpCodes.Stloc, local);
 				ec.Emit (OpCodes.Ldloca, local);
 				return;
 			}
 
 
 			if (IsStatic){
 				ec.Emit (OpCodes.Ldsflda, spec);
 			} else {
 				if (!prepared)
 					EmitInstance (ec, false);
 				ec.Emit (OpCodes.Ldflda, spec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="246" endline="269">
<![CDATA[
 
 		static readonly char [] wsChars =
 			new char [] {' ', '\t', '\n', '\r'};
 
 		//
 		// returns a full runtime type name from a name which might
 		// be C# specific type name.
 		//
 		private static TypeSpec FindDocumentedType (MemberCore mc, string name, DeclSpace ds, string cref, Report r)
 		{
 			bool is_array = false;
 			string identifier = name;
 			if (name [name.Length - 1] == ']') {
 				string tmp = name.Substring (0, name.Length - 1).Trim (wsChars);
 				if (tmp [tmp.Length - 1] == '[') {
 					identifier = tmp.Substring (0, tmp.Length - 1).Trim (wsChars);
 					is_array = true;
 				}
 			}
 			TypeSpec t = FindDocumentedTypeNonArray (mc, identifier, ds, cref, r);
 			if (t != null && is_array)
 				t = ArrayContainer.MakeType (t);
 			return t;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="770" endline="802">
<![CDATA[
 
 		public void Error_UnexpectedKind (ResolveContext ec, ResolveFlags flags, Location loc)
 		{
 			string [] valid = new string [4];
 			int count = 0;
 
 			if ((flags & ResolveFlags.VariableOrValue) != 0) {
 				valid [count++] = "variable";
 				valid [count++] = "value";
 			}
 
 			if ((flags & ResolveFlags.Type) != 0)
 				valid [count++] = "type";
 
 			if ((flags & ResolveFlags.MethodGroup) != 0)
 				valid [count++] = "method group";
 
 			if (count == 0)
 				valid [count++] = "unknown";
 
 			StringBuilder sb = new StringBuilder (valid [0]);
 			for (int i = 1; i < count - 1; i++) {
 				sb.Append ("', `");
 				sb.Append (valid [i]);
 			}
 			for (int i = 1; i < count - 1; i++) {
 				sb.Append ("', `");
 				sb.Append (valid [i]);
 			}
 			if (count > 1) {
 				sb.Append ("' or `");
 				sb.Append (valid [count - 1]);
 			}
 
 			ec.Report.Error (119, loc, 
 				"Expression denotes a `{0}', where a `{1}' was expected", ExprClassName, sb.ToString ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="515" endline="609">
<![CDATA[
 
 		//
 		// Returns base members of @member member if no exact match is found @bestCandidate returns
 		// the best match
 		//
 		public static MemberSpec FindBaseMember (MemberCore member, out MemberSpec bestCandidate)
 		{
 			bestCandidate = null;
 			var container = member.Parent.PartialContainer.Definition;
 			if (!container.IsInterface) {
 				container = container.BaseType;
 
 				// It can happen for a user definition of System.Object
 				if (container == null)
 					return null;
 			}
 
 			string name = GetLookupName (member);
 			IList<MemberSpec> applicable;
 			var member_param = member is IParametersMember ? ((IParametersMember) member).Parameters 
 
 			var mkind = GetMemberCoreKind (member);
 			bool member_with_accessors = mkind == MemberKind.Indexer || mkind == MemberKind.Property;
 
 			do {
 				if (container.MemberCache.member_hash.TryGetValue (name, out applicable)) {
 					for (int i = 0; i < applicable.Count; ++i) {
 						var entry = applicable [i];
 
 						if ((entry.Modifiers & Modifiers.PRIVATE) != 0)
 							continue;
 
 						if ((entry.Modifiers & Modifiers.AccessibilityMask) == Modifiers.INTERNAL &&
 							!entry.DeclaringType.MemberDefinition.IsInternalAsPublic (member.Module.DeclaringAssembly))
 							continue;
 
 						//
 						// Is the member of same kind ?
 						//
 						if ((entry.Kind & ~MemberKind.Destructor & mkind & MemberKind.MaskType) == 0) {
 							// Destructors are ignored as they cannot be overridden by user
 							if ((entry.Kind & MemberKind.Destructor) != 0)
 								continue;
 
 							// A method with different arity does not hide base member
 							if (mkind != MemberKind.Method && member.MemberName.Arity != entry.Arity)
 								continue;
 
 							bestCandidate = entry;
 							return null;
 						}
 
 						//
 						// Same kind of different arity is valid
 						//
 						if (member.MemberName.Arity != entry.Arity) {
 							continue;
 						}
 
 						if ((entry.Kind & mkind & (MemberKind.Method | MemberKind.Indexer)) != 0) {
 							if (entry.IsAccessor != member is AbstractPropertyEventMethod)
 								continue;
 
 							var pm = entry as IParametersMember;
 							if (!TypeSpecComparer.Override.IsEqual (pm.Parameters, member_param))
 								continue;
 						}
 
 						//
 						// Skip override members with accessors they may not fully implement the base member
 						//
 						if (member_with_accessors) {
 							if ((entry.Modifiers & (Modifiers.OVERRIDE | Modifiers.SEALED)) == Modifiers.OVERRIDE) {
 								//
 								// Set candidate to member override to flag we found an implementation
 								//
 								bestCandidate = entry;
 								continue;
 							}
 						} else {
 							bestCandidate = null;
 						}
 
 						return entry;
 					for (int i = 0; i < applicable.Count; ++i) {
 						var entry = applicable [i];
 
 						if ((entry.Modifiers & Modifiers.PRIVATE) != 0)
 							continue;
 
 						if ((entry.Modifiers & Modifiers.AccessibilityMask) == Modifiers.INTERNAL &&
 							!entry.DeclaringType.MemberDefinition.IsInternalAsPublic (member.Module.DeclaringAssembly))
 							continue;
 
 						//
 						// Is the member of same kind ?
 						//
 						if ((entry.Kind & ~MemberKind.Destructor & mkind & MemberKind.MaskType) == 0) {
 							// Destructors are ignored as they cannot be overridden by user
 							if ((entry.Kind & MemberKind.Destructor) != 0)
 								continue;
 
 							// A method with different arity does not hide base member
 							if (mkind != MemberKind.Method && member.MemberName.Arity != entry.Arity)
 								continue;
 
 							bestCandidate = entry;
 							return null;
 						}
 
 						//
 						// Same kind of different arity is valid
 						//
 						if (member.MemberName.Arity != entry.Arity) {
 							continue;
 						}
 
 						if ((entry.Kind & mkind & (MemberKind.Method | MemberKind.Indexer)) != 0) {
 							if (entry.IsAccessor != member is AbstractPropertyEventMethod)
 								continue;
 
 							var pm = entry as IParametersMember;
 							if (!TypeSpecComparer.Override.IsEqual (pm.Parameters, member_param))
 								continue;
 						}
 
 						//
 						// Skip override members with accessors they may not fully implement the base member
 						//
 						if (member_with_accessors) {
 							if ((entry.Modifiers & (Modifiers.OVERRIDE | Modifiers.SEALED)) == Modifiers.OVERRIDE) {
 								//
 								// Set candidate to member override to flag we found an implementation
 								//
 								bestCandidate = entry;
 								continue;
 							}
 						} else {
 							bestCandidate = null;
 						}
 
 						return entry;
 					}
 				}
 
 				if (container.IsInterface)
 					break;
 
 				container = container.BaseType;
 			} while (container != null);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="678" endline="695">
<![CDATA[
 
 		/// <summary>
 		/// Returns value of CLSCompliantAttribute contructor parameter but because the method can be called
 		/// before ApplyAttribute. We need to resolve the arguments.
 		/// This situation occurs when class deps is differs from Emit order.  
 		/// </summary>
 		public bool GetClsCompliantAttributeValue ()
 		{
 			if (!arg_resolved)
 				// TODO
 				// But because a lot of attribute class code must be rewritten will be better to wait...
 				Resolve ();
 
 			if (resolve_error)
 				return false;
 
 			return ((BoolConstant) PosArguments[0].Expr).Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4204" endline="4216">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 
 			var pc = left.Type as PointerContainer;
 			if (pc != null && pc.Element.BuildinType == BuildinTypeSpec.Type.Void) {
 				Error_VoidPointerOperation (ec);
 				return null;
 			}
 			
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="228" endline="239">
<![CDATA[
 		}
 
 		internal override IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
 		{
 			List<CustomAttributeData> list = module.GetCustomAttributes(this.MetadataToken, attributeType);
 			if ((this.Attributes & MethodAttributes.PinvokeImpl) != 0
 				&& (attributeType == null || attributeType.IsAssignableFrom(module.universe.System_Runtime_InteropServices_DllImportAttribute)))
 			{
 				CreateDllImportPseudoCustomAttribute(list);
 			}
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2480" endline="2489">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			int[] fixups = moduleBuilder.GenericParam.GetIndexFixup();
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].Owner = fixups[records[i].Owner - 1] + 1;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].Owner = fixups[records[i].Owner - 1] + 1;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1441" endline="1453">
<![CDATA[
 
 		bool Define (ResolveContext ec)
 		{
 			if (!Block.Resolved && Compatible (ec) == null)
 				return false;
 
 			if (block_name == null) {
 				MemberCore mc = (MemberCore) ec.MemberContext;
 				block_name = mc.MemberName.Basename;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="166" endline="186">
<![CDATA[
 		}
 
 		public override MethodInfo GetGenericMethodDefinition()
 		{
 			if (this.IsGenericMethod)
 			{
 				if (this.IsGenericMethodDefinition)
 				{
 					return this;
 				}
 				else if (declaringType.IsGenericType && !declaringType.IsGenericTypeDefinition)
 				{
 					return new GenericMethodInstance(declaringType, method, null);
 				}
 				else
 				{
 					return method;
 				}
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="228" endline="249">
<![CDATA[
 
 		internal int ReadCustomAttributeType()
 		{
 			int codedIndex;
 			if (bigCustomAttributeType)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 7)
 			{
 				case 2
 					return (MethodDefTable.Index << 24) + (codedIndex >> 3);
 				case 3
 					return (MemberRefTable.Index << 24) + (codedIndex >> 3);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="167" endline="192">
<![CDATA[
 
 		//
 		// When the same attribute is attached to multiple fiels
 		// we use @target field as a list of targets. The attribute
 		// has to be resolved only once but emitted for each target.
 		//
 		public void AttachTo (Attributable target, IMemberContext context)
 		{
 			if (this.targets == null) {
 				this.targets = new Attributable[] { target };
 				this.context = context;
 				return;
 			}
 
 			// Resize target array
 			Attributable[] new_array = new Attributable [this.targets.Length + 1];
 			targets.CopyTo (new_array, 0);
 			new_array [targets.Length] = target;
 			this.targets = new_array;
 
 			// No need to update context, different targets cannot have
 			// different contexts, it's enough to remove same attributes
 			// from secondary members.
 
 			target.OptAttributes = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2157" endline="2189">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		// Creates anonymous method storey in current block
 		//
 		public AnonymousMethodStorey CreateAnonymousMethodStorey (ResolveContext ec)
 		{
 			//
 			// An iterator has only 1 storey block
 			//
 			if (ec.CurrentIterator != null)
 			    return ec.CurrentIterator.Storey;
 
 			//
 			// When referencing a variable in iterator storey from children anonymous method
 			//
 			if (ParametersBlock.am_storey is IteratorStorey) {
 				return ParametersBlock.am_storey;
 			}
 
 			if (am_storey == null) {
 				MemberBase mc = ec.MemberContext as MemberBase;
 
 				//
 				// Creates anonymous method storey for this block
 				//
 				am_storey = new AnonymousMethodStorey (this, ec.CurrentMemberDefinition.Parent.PartialContainer, mc, ec.CurrentTypeParameters, "AnonStorey");
 			}
 
 			return am_storey;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1018" endline="1037">
<![CDATA[
 
 		TypeSpec ImportType (MetaType type, DynamicTypeReader dtype)
 		{
 			if (type.HasElementType) {
 				var element = type.GetElementType ();
 				++dtype.Position;
 				var spec = ImportType (element, dtype);
 
 				if (type.IsArray)
 					return ArrayContainer.MakeType (spec, type.GetArrayRank ());
 				if (type.IsByRef)
 					return ReferenceContainer.MakeType (spec);
 				if (type.IsPointer)
 					return PointerContainer.MakeType (spec);
 
 				throw new NotImplementedException ("Unknown element type " + type.ToString ());
 			}
 
 			return CreateType (type, dtype, true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="218" endline="237">
<![CDATA[
 		}
 
 		internal int Add(string str)
 		{
 			Debug.Assert(!frozen);
 			int offset;
 			if (!strings.TryGetValue(str, out offset))
 			{
 				int length = str.Length * 2 + 1 + MetadataWriter.GetCompressedIntLength(str.Length * 2 + 1);
 				if (nextOffset + length > 0xFFFFFF)
 				{
 					throw new FileFormatLimitationExceededException("No logical space left to create more user strings.", FileFormatLimitationExceededException.META_E_STRINGSPACE_FULL);
 				}
 				offset = nextOffset;
 				nextOffset += length;
 				list.Add(str);
 				strings.Add(str, offset);
 			}
 			return offset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4140" endline="4164">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			AParametersCollection pd = oper.Parameters;
 			if (!TypeSpecComparer.IsEqual (type, pd.Types[0]) || !TypeSpecComparer.IsEqual (type, pd.Types[1])) {
 				ec.Report.Error (217, loc,
 					"A user-defined operator `{0}' must have parameters and return values of the same type in order to be applicable as a short circuit operator",
 					oper.GetSignatureForError ());
 				return null;
 			}
 
 			Expression left_dup = new EmptyExpression (type);
 			Expression op_true = GetOperatorTrue (ec, left_dup, loc);
 			Expression op_false = GetOperatorFalse (ec, left_dup, loc);
 			if (op_true == null || op_false == null) {
 				ec.Report.Error (218, loc,
 					"The type `{0}' must have operator `true' and operator `false' defined when `{1}' is used as a short circuit operator",
 					TypeManager.CSharpName (type), oper.GetSignatureForError ());
 				return null;
 			}
 
 			oper_expr = is_and ? op_false 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2924" endline="2976">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			if (Report.Errors > 0)
 				return;
 
 #if PRODUCTION
 			try {
 #endif
 			if (ec.HasReturnLabel)
 				ec.ReturnLabel = ec.DefineLabel ();
 
 			base.Emit (ec);
 
 			ec.Mark (EndLocation);
 
 			if (ec.HasReturnLabel)
 				ec.MarkLabel (ec.ReturnLabel);
 
 			if (ec.return_value != null) {
 				ec.Emit (OpCodes.Ldloc, ec.return_value);
 				ec.Emit (OpCodes.Ret);
 			} else {
 				//
 				// If `HasReturnLabel' is set, then we already emitted a
 				// jump to the end of the method, so we must emit a `ret'
 				// there.
 				//
 				// Unfortunately, System.Reflection.Emit automatically emits
 				// a leave to the end of a finally block.  This is a problem
 				// if no code is following the try/finally block since we may
 				// jump to a point after the end of the method.
 				// As a workaround, we're always creating a return label in
 				// this case.
 				//
 
 				if (ec.HasReturnLabel || !unreachable) {
 					if (ec.ReturnType != TypeManager.void_type)
 						ec.Emit (OpCodes.Ldloc, ec.TemporaryReturn ());
 					ec.Emit (OpCodes.Ret);
 				}
 			}
 
 #if PRODUCTION
 			} catch (Exception e){
 				Console.WriteLine ("Exception caught by the compiler while emitting
 				Console.WriteLine ("   Block that caused the problem begin at
 					
 				Console.WriteLine (e.GetType ().FullName + "
 				throw;
 			}
 #endif
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="654" endline="701">
<![CDATA[
 
 		private sealed class GenericContext 
 		{
 			private readonly Type[] genericTypeArguments;
 			private readonly Type[] genericMethodArguments;
 
 			internal GenericContext(Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				this.genericTypeArguments = genericTypeArguments;
 				this.genericMethodArguments = genericMethodArguments;
 			}
 
 			public Type GetGenericTypeArgument(int index)
 			{
 				return genericTypeArguments[index];
 			}
 
 			public Type GetGenericMethodArgument(int index)
 			{
 				return genericMethodArguments[index];
 			}
 		}
 
 		public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 		{
 			if ((metadataToken >> 24) == MethodDefTable.Index)
 			{
 				int index = (metadataToken & 0xFFFFFF) - 1;
 				return GetMethodAt(null, index);
 			}
 			else if ((metadataToken >> 24) == MemberRefTable.Index)
 			{
 				int index = (metadataToken & 0xFFFFFF) - 1;
 				MethodBase method = GetMemberRef(index, genericTypeArguments, genericMethodArguments) as MethodBase;
 				if (method != null)
 				{
 					return method;
 				}
 			}
 			else if ((metadataToken >> 24) == MethodSpecTable.Index)
 			{
 				int index = (metadataToken & 0xFFFFFF) - 1;
 				MethodInfo method = (MethodInfo)ResolveMethod(MethodSpec.records[index].Method, genericTypeArguments, genericMethodArguments);
 				ByteReader instantiation = ByteReader.FromBlob(blobHeap, MethodSpec.records[index].Instantiation);
 				return method.MakeGenericMethod(Signature.ReadMethodSpec(this, instantiation, new GenericContext(genericTypeArguments, genericMethodArguments)));
 			}
 			throw new ArgumentOutOfRangeException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="666" endline="704">
<![CDATA[
 
 		internal static void WritePropertySig(ModuleBuilder module, ByteBuffer bb, CallingConventions callingConvention,
 			Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			byte flags = PROPERTY;
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				flags |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				flags |= EXPLICITTHIS;
 			}
 			if ((callingConvention & CallingConventions.VarArgs) != 0)
 			{
 				flags |= VARARG;
 			}
 			bb.Write(flags);
 			bb.WriteCompressedInt(parameterTypes == null ? 0 
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, returnTypeRequiredCustomModifiers);
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, returnTypeOptionalCustomModifiers);
 			WriteType(module, bb, returnType);
 			if (parameterTypes != null)
 			{
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterTypeRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterTypeRequiredCustomModifiers[i]);
 					}
 					if (parameterTypeOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterTypeOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 				for (int i = 0; i < parameterTypes.Length; i++)
 				{
 					if (parameterTypeRequiredCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, parameterTypeRequiredCustomModifiers[i]);
 					}
 					if (parameterTypeOptionalCustomModifiers != null)
 					{
 						WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, parameterTypeOptionalCustomModifiers[i]);
 					}
 					WriteType(module, bb, parameterTypes[i]);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1010" endline="1050">
<![CDATA[
 	
 		bool CreateTypeBuilder ()
 		{
 			//
 			// Sets .size to 1 for structs with no instance fields
 			//
 			int type_size = Kind == MemberKind.Struct && first_nonstatic_field == null ? 1 
 
 			if (IsTopLevel) {
 				// TODO
 				if (Module.GlobalRootNamespace.IsNamespace (Name)) {
 					Report.Error (519, Location, "`{0}' clashes with a predefined namespace", Name);
 				}
 
 				TypeBuilder = Module.CreateBuilder (Name, TypeAttr, type_size);
 			} else {
 				TypeBuilder = Parent.TypeBuilder.DefineNestedType (Basename, TypeAttr, null, type_size);
 			}
 
 			spec.SetMetaInfo (TypeBuilder);
 			spec.MemberCache = new MemberCache (this);
 			spec.DeclaringType = Parent.CurrentType;
 
 			if (!IsTopLevel)
 				Parent.MemberCache.AddMember (spec);
 
 			if (IsGeneric) {
 				string[] param_names = new string[TypeParameters.Length];
 				for (int i = 0; i < TypeParameters.Length; i++)
 					param_names [i] = TypeParameters[i].Name;
 				for (int i = 0; i < TypeParameters.Length; i++)
 					param_names [i] = TypeParameters[i].Name;
 
 				all_tp_builders = TypeBuilder.DefineGenericParameters (param_names);
 
 				int offset = CurrentTypeParametersStartIndex;
 				for (int i = offset; i < all_tp_builders.Length; i++) {
 					CurrentTypeParameters [i - offset].Define (all_tp_builders [i], spec);
 				}
 				for (int i = offset; i < all_tp_builders.Length; i++) {
 					CurrentTypeParameters [i - offset].Define (all_tp_builders [i], spec);
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="353" endline="406">
<![CDATA[
 
 		static public byte[] ToCapiPrivateKeyBlob (DSA dsa)
 		{
 			DSAParameters p = dsa.ExportParameters (true);
 			int keyLength = p.P.Length; // in bytes
 
 			// header + P + Q + G + X + count + seed
 			byte[] blob = new byte [16 + keyLength + 20 + keyLength + 20 + 4 + 20];
 
 			blob [0] = 0x07;	// Type - PRIVATEKEYBLOB (0x07)
 			blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
 			// [2], [3]		// RESERVED - Always 0
 			blob [5] = 0x22;	// ALGID
 			blob [8] = 0x44;	// Magic
 			blob [9] = 0x53;
 			blob [10] = 0x53;
 			blob [11] = 0x32;
 
 			byte[] bitlen = GetBytesLE (keyLength << 3);
 			blob [12] = bitlen [0];
 			blob [13] = bitlen [1];
 			blob [14] = bitlen [2];
 			blob [15] = bitlen [3];
 
 			int pos = 16;
 			byte[] part = p.P;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.Q;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 			pos += 20;
 
 			part = p.G;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, keyLength);
 			pos += keyLength;
 
 			part = p.X;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 			pos += 20;
 
 			Buffer.BlockCopy (GetBytesLE (p.Counter), 0, blob, pos, 4);
 			pos += 4;
 
 			part = p.Seed;
 			Array.Reverse (part);
 			Buffer.BlockCopy (part, 0, blob, pos, 20);
 
 			return blob;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1070" endline="1124">
<![CDATA[
 
 		internal MethodEntry (MonoSymbolFile file, CompileUnitEntry comp_unit,
 				      int token, ScopeVariable[] scope_vars,
 				      LocalVariableEntry[] locals, LineNumberEntry[] lines,
 				      CodeBlockEntry[] code_blocks, string real_name,
 				      Flags flags, int namespace_id)
 		{
 			this.SymbolFile = file;
 			this.real_name = real_name;
 			this.locals = locals;
 			this.code_blocks = code_blocks;
 			this.scope_vars = scope_vars;
 			this.flags = flags;
 
 			index = -1;
 
 			Token = token;
 			CompileUnitIndex = comp_unit.Index;
 			CompileUnit = comp_unit;
 			NamespaceID = namespace_id;
 
 			CheckLineNumberTable (lines);
 			lnt = new LineNumberTable (file, lines);
 			file.NumLineNumbers += lines.Length;
 
 			int num_locals = locals != null ? locals.Length 
 
 			if (num_locals <= 32) {
 				// Most of the time, the O(n^2) factor is actually
 				// less than the cost of allocating the hash table,
 				// 32 is a rough number obtained through some testing.
 				
 				for (int i = 0; i < num_locals; i ++) {
 					string nm = locals [i].Name;
 					
 					for (int j = i + 1; j < num_locals; j ++) {
 						if (locals [j].Name == nm) {
 							flags |= Flags.LocalNamesAmbiguous;
 							goto locals_check_done;
 						}
 					}
 					for (int j = i + 1; j < num_locals; j ++) {
 						if (locals [j].Name == nm) {
 							flags |= Flags.LocalNamesAmbiguous;
 							goto locals_check_done;
 						}
 					}
 				}
 				for (int i = 0; i < num_locals; i ++) {
 					string nm = locals [i].Name;
 					
 					for (int j = i + 1; j < num_locals; j ++) {
 						if (locals [j].Name == nm) {
 							flags |= Flags.LocalNamesAmbiguous;
 							goto locals_check_done;
 						}
 					}
 				}
 			locals_check_done 
 				;
 			} else {
 				var local_names = new Dictionary<string, LocalVariableEntry> ();
 				foreach (LocalVariableEntry local in locals) {
 					if (local_names.ContainsKey (local.Name)) {
 						flags |= Flags.LocalNamesAmbiguous;
 						break;
 					}
 					local_names.Add (local.Name, local);
 				}
 				foreach (LocalVariableEntry local in locals) {
 					if (local_names.ContainsKey (local.Name)) {
 						flags |= Flags.LocalNamesAmbiguous;
 						break;
 					}
 					local_names.Add (local.Name, local);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="391" endline="464">
<![CDATA[
 
 		public void ResolveDefaultValue (ResolveContext rc)
 		{
 			//
 			// Default value was specified using an expression
 			//
 			if (default_expr != null) {
 				((DefaultParameterValueExpression)default_expr).Resolve (rc, this);
 				return;
 			}
 
 			if (attributes == null)
 				return;
 			
 			var opt_attr = attributes.Search (rc.Module.PredefinedAttributes.OptionalParameter);
 			var def_attr = attributes.Search (rc.Module.PredefinedAttributes.DefaultParameterValue);
 			if (def_attr != null) {
 				if (def_attr.Resolve () == null)
 					return;
 
 				var default_expr_attr = def_attr.GetParameterDefaultValue ();
 				if (default_expr_attr == null)
 					return;
 
 				var dpa_rc = def_attr.CreateResolveContext ();
 				default_expr = default_expr_attr.Resolve (dpa_rc);
 
 				if (default_expr is BoxedCast)
 					default_expr = ((BoxedCast) default_expr).Child;
 
 				Constant c = default_expr as Constant;
 				if (c == null) {
 					if (parameter_type == TypeManager.object_type) {
 						rc.Compiler.Report.Error (1910, default_expr.Location,
 							"Argument of type `{0}' is not applicable for the DefaultParameterValue attribute",
 							default_expr.Type.GetSignatureForError ());
 					} else {
 						rc.Compiler.Report.Error (1909, default_expr.Location,
 							"The DefaultParameterValue attribute is not applicable on parameters of type `{0}'",
 							default_expr.Type.GetSignatureForError ()); ;
 					}
 
 					default_expr = null;
 					return;
 				}
 
 				if (TypeSpecComparer.IsEqual (default_expr.Type, parameter_type) ||
 					(default_expr is NullConstant && TypeManager.IsReferenceType (parameter_type) && !parameter_type.IsGenericParameter) ||
 					TypeSpecComparer.IsEqual (parameter_type, TypeManager.object_type)) {
 					return;
 				}
 
 				//
 				// LAMESPEC
 				// User operators returning same type as parameter type are considered
 				// valid for this attribute only
 				//
 				// struct S { public static implicit operator S (int i) {} }
 				//
 				// void M ([DefaultParameterValue (3)]S s)
 				//
 				var expr = Convert.ImplicitUserConversion (dpa_rc, default_expr, parameter_type, loc);
 				if (expr != null && TypeSpecComparer.IsEqual (expr.Type, parameter_type)) {
 					return;
 				}
 				
 				rc.Compiler.Report.Error (1908, default_expr.Location, "The type of the default value should match the type of the parameter");
 				return;
 			}
 
 			if (opt_attr != null) {
 				default_expr = EmptyExpression.MissingValue;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9172" endline="9234">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (source == null)
 				return EmptyExpressionStatement.Instance;
 
 			var t = ec.CurrentInitializerVariable.Type;
 			if (t == InternalType.Dynamic) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (ec.CurrentInitializerVariable));
 				target = new DynamicMemberBinder (Name, args, loc);
 			} else {
 
 				var member = MemberLookup (ec, ec.CurrentType, t, Name, 0, MemberLookupRestrictions.ExactArity, loc);
 				if (member == null) {
 					member = Expression.MemberLookup (null, ec.CurrentType, t, Name, 0, MemberLookupRestrictions.ExactArity, loc);
 
 					if (member != null) {
 						// TODO
 						ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						return null;
 					}
 				}
 
 				if (member == null) {
 					Error_TypeDoesNotContainDefinition (ec, loc, t, Name);
 					return null;
 				}
 
 				if (!(member is PropertyExpr || member is FieldExpr)) {
 					ec.Report.Error (1913, loc,
 						"Member `{0}' cannot be initialized. An object initializer may only be used for fields, or properties",
 						member.GetSignatureForError ());
 
 					return null;
 				}
 
 				var me = member as MemberExpr;
 				if (me.IsStatic) {
 					ec.Report.Error (1914, loc,
 						"Static field or property `{0}' cannot be assigned in an object initializer",
 						me.GetSignatureForError ());
 				}
 
 				target = me;
 				me.InstanceExpression = ec.CurrentInitializerVariable;
 			}
 
 			if (source is CollectionOrObjectInitializers) {
 				Expression previous = ec.CurrentInitializerVariable;
 				ec.CurrentInitializerVariable = target;
 				source = source.Resolve (ec);
 				ec.CurrentInitializerVariable = previous;
 				if (source == null)
 					return null;
 					
 				eclass = source.eclass;
 				type = source.Type;
 				return this;
 			}
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="902" endline="957">
<![CDATA[
 
 		protected bool VerifyParameterCompatibility (ResolveContext ec, TypeSpec delegate_type, AParametersCollection invoke_pd, bool ignore_errors)
 		{
 			if (Parameters.Count != invoke_pd.Count) {
 				if (ignore_errors)
 					return false;
 				
 				ec.Report.Error (1593, loc, "Delegate `{0}' does not take `{1}' arguments",
 					      TypeManager.CSharpName (delegate_type), Parameters.Count.ToString ());
 				return false;
 			}
 
 			bool has_implicit_parameters = !HasExplicitParameters;
 			bool error = false;
 
 			for (int i = 0; i < Parameters.Count; ++i) {
 				Parameter.Modifier p_mod = invoke_pd.FixedParameters [i].ModFlags;
 				if (Parameters.FixedParameters [i].ModFlags != p_mod && p_mod != Parameter.Modifier.PARAMS) {
 					if (ignore_errors)
 						return false;
 					
 					if (p_mod == Parameter.Modifier.NONE)
 						ec.Report.Error (1677, loc, "Parameter `{0}' should not be declared with the `{1}' keyword",
 							      (i + 1).ToString (), Parameter.GetModifierSignature (Parameters.FixedParameters [i].ModFlags));
 					else
 						ec.Report.Error (1676, loc, "Parameter `{0}' must be declared with the `{1}' keyword",
 							      (i+1).ToString (), Parameter.GetModifierSignature (p_mod));
 					error = true;
 				}
 
 				if (has_implicit_parameters)
 					continue;
 
 				TypeSpec type = invoke_pd.Types [i];
 				
 				// We assume that generic parameters are always inflated
 				if (TypeManager.IsGenericParameter (type))
 					continue;
 				
 				if (TypeManager.HasElementType (type) && TypeManager.IsGenericParameter (TypeManager.GetElementType (type)))
 					continue;
 				
 				if (!TypeSpecComparer.IsEqual (invoke_pd.Types [i], Parameters.Types [i])) {
 					if (ignore_errors)
 						return false;
 					
 					ec.Report.Error (1678, loc, "Parameter `{0}' is declared as type `{1}' but should be `{2}'",
 						      (i+1).ToString (),
 						      TypeManager.CSharpName (Parameters.Types [i]),
 						      TypeManager.CSharpName (invoke_pd.Types [i]));
 					error = true;
 				}
 			}
 			for (int i = 0; i < Parameters.Count; ++i) {
 				Parameter.Modifier p_mod = invoke_pd.FixedParameters [i].ModFlags;
 				if (Parameters.FixedParameters [i].ModFlags != p_mod && p_mod != Parameter.Modifier.PARAMS) {
 					if (ignore_errors)
 						return false;
 					
 					if (p_mod == Parameter.Modifier.NONE)
 						ec.Report.Error (1677, loc, "Parameter `{0}' should not be declared with the `{1}' keyword",
 							      (i + 1).ToString (), Parameter.GetModifierSignature (Parameters.FixedParameters [i].ModFlags));
 					else
 						ec.Report.Error (1676, loc, "Parameter `{0}' must be declared with the `{1}' keyword",
 							      (i+1).ToString (), Parameter.GetModifierSignature (p_mod));
 					error = true;
 				}
 
 				if (has_implicit_parameters)
 					continue;
 
 				TypeSpec type = invoke_pd.Types [i];
 				
 				// We assume that generic parameters are always inflated
 				if (TypeManager.IsGenericParameter (type))
 					continue;
 				
 				if (TypeManager.HasElementType (type) && TypeManager.IsGenericParameter (TypeManager.GetElementType (type)))
 					continue;
 				
 				if (!TypeSpecComparer.IsEqual (invoke_pd.Types [i], Parameters.Types [i])) {
 					if (ignore_errors)
 						return false;
 					
 					ec.Report.Error (1678, loc, "Parameter `{0}' is declared as type `{1}' but should be `{2}'",
 						      (i+1).ToString (),
 						      TypeManager.CSharpName (Parameters.Types [i]),
 						      TypeManager.CSharpName (invoke_pd.Types [i]));
 					error = true;
 				}
 			}
 
 			return !error;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1947" endline="2040">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			Block prev_block = ec.CurrentBlock;
 			bool ok = true;
 
 			ec.CurrentBlock = this;
 			ec.StartFlowBranching (this);
 
 			Report.Debug (4, "RESOLVE BLOCK", StartLocation, ec.CurrentBranching);
 
 			//
 			// Compiler generated scope statements
 			//
 			if (scope_initializers != null) {
 				for (resolving_init_idx = 0; resolving_init_idx < scope_initializers.Count; ++resolving_init_idx) {
 					scope_initializers[resolving_init_idx.Value].Resolve (ec);
 				}
 				for (resolving_init_idx = 0; resolving_init_idx < scope_initializers.Count; ++resolving_init_idx) {
 					scope_initializers[resolving_init_idx.Value].Resolve (ec);
 				}
 
 				resolving_init_idx = null;
 			}
 
 			//
 			// This flag is used to notate nested statements as unreachable from the beginning of this block.
 			// For the purposes of this resolution, it doesn't matter that the whole block is unreachable 
 			// from the beginning of the function.  The outer Resolve() that detected the unreachability is
 			// responsible for handling the situation.
 			//
 			int statement_count = statements.Count;
 			for (int ix = 0; ix < statement_count; ix++){
 				Statement s = statements [ix];
 
 				//
 				// Warn if we detect unreachable code.
 				//
 				if (unreachable) {
 					if (s is EmptyStatement)
 						continue;
 
 					if (!unreachable_shown && !(s is LabeledStatement)) {
 						ec.Report.Warning (162, 2, s.loc, "Unreachable code detected");
 						unreachable_shown = true;
 					}
 
 					Block c_block = s as Block;
 					if (c_block != null)
 						c_block.unreachable = c_block.unreachable_shown = true;
 				}
 
 				//
 				// Note that we're not using ResolveUnreachable() for unreachable
 				// statements here.  ResolveUnreachable() creates a temporary
 				// flow branching and kills it afterwards.  This leads to problems
 				// if you have two unreachable statements where the first one
 				// assigns a variable and the second one tries to access it.
 				//
 
 				if (!s.Resolve (ec)) {
 					ok = false;
 					if (ec.IsInProbingMode)
 						break;
 
 					statements [ix] = new EmptyStatement (s.loc);
 					continue;
 				}
 
 				if (unreachable && !(s is LabeledStatement) && !(s is Block))
 					statements [ix] = new EmptyStatement (s.loc);
 
 				unreachable = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 				if (unreachable && s is LabeledStatement)
 					throw new InternalErrorException ("should not happen");
 			}
 			for (int ix = 0; ix < statement_count; ix++){
 				Statement s = statements [ix];
 
 				//
 				// Warn if we detect unreachable code.
 				//
 				if (unreachable) {
 					if (s is EmptyStatement)
 						continue;
 
 					if (!unreachable_shown && !(s is LabeledStatement)) {
 						ec.Report.Warning (162, 2, s.loc, "Unreachable code detected");
 						unreachable_shown = true;
 					}
 
 					Block c_block = s as Block;
 					if (c_block != null)
 						c_block.unreachable = c_block.unreachable_shown = true;
 				}
 
 				//
 				// Note that we're not using ResolveUnreachable() for unreachable
 				// statements here.  ResolveUnreachable() creates a temporary
 				// flow branching and kills it afterwards.  This leads to problems
 				// if you have two unreachable statements where the first one
 				// assigns a variable and the second one tries to access it.
 				//
 
 				if (!s.Resolve (ec)) {
 					ok = false;
 					if (ec.IsInProbingMode)
 						break;
 
 					statements [ix] = new EmptyStatement (s.loc);
 					continue;
 				}
 
 				if (unreachable && !(s is LabeledStatement) && !(s is Block))
 					statements [ix] = new EmptyStatement (s.loc);
 
 				unreachable = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 				if (unreachable && s is LabeledStatement)
 					throw new InternalErrorException ("should not happen");
 			}
 
 			Report.Debug (4, "RESOLVE BLOCK DONE", StartLocation,
 				      ec.CurrentBranching, statement_count);
 
 			while (ec.CurrentBranching is FlowBranchingLabeled)
 				ec.EndFlowBranching ();
 			while (ec.CurrentBranching is FlowBranchingLabeled)
 				ec.EndFlowBranching ();
 
 			bool flow_unreachable = ec.EndFlowBranching ();
 
 			ec.CurrentBlock = prev_block;
 
 			if (flow_unreachable)
 				flags |= Flags.HasRet;
 
 			// If we're a non-static `struct' constructor which doesn't have an
 			// initializer, then we must initialize all of the struct's fields.
 			if (this == ParametersBlock.TopBlock && !ParametersBlock.TopBlock.IsThisAssigned (ec) && !flow_unreachable)
 				ok = false;
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2507" endline="2517">
<![CDATA[
 
 		protected abstract TypeExpr DoResolveAsTypeStep (IMemberContext ec);
 
 		public override bool Equals (object obj)
 		{
 			TypeExpr tobj = obj as TypeExpr;
 			if (tobj == null)
 				return false;
 
 			return Type == tobj.Type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="527" endline="536">
<![CDATA[
 		}
 
 		public override bool Equals (object obj)
 		{
 			AbstractMessage msg = obj as AbstractMessage;
 			if (msg == null)
 				return false;
 
 			return code == msg.code && location.Equals (msg.location) && message == msg.message;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="758" endline="769">
<![CDATA[
 
 		public void Error_UnexpectedKind (Report r, MemberCore mc, string expected, string was, Location loc)
 		{
 			string name;
 			if (mc != null)
 				name = mc.GetSignatureForError ();
 			else
 				name = GetSignatureForError ();
 
 			r.Error (118, loc, "`{0}' is a `{1}' but a `{2}' was expected",
 			      name, was, expected);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1915" endline="1926">
<![CDATA[
 
 		public override bool Equals (object obj)
 		{
 			GenericTypeExpr cobj = obj as GenericTypeExpr;
 			if (cobj == null)
 				return false;
 
 			if ((type == null) || (cobj.type == null))
 				return false;
 
 			return type == cobj.type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="880" endline="893">
<![CDATA[
 
 		public override FullNamedExpression LookupNamespaceOrType (string name, int arity, Location loc, bool ignore_cs0104)
 		{
 			if (arity == 0) {
 				TypeParameter[] tp = CurrentTypeParameters;
 				if (tp != null) {
 					TypeParameter t = TypeParameter.FindTypeParameter (tp, name);
 					if (t != null)
 						return new TypeParameterExpr (t, loc);
 				}
 			}
 
 			return base.LookupNamespaceOrType (name, arity, loc, ignore_cs0104);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2899" endline="2916">
<![CDATA[
 		}
 
 		public override IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			if (namespace_entry == null)
 				return null;
 
 			//
 			// For extension methodgroup we are not looking for base members but parent
 			// namespace extension methods
 			//
 			int arity = type_arguments == null ? 0 
 			var found = namespace_entry.LookupExtensionMethod (DeclaringType, Name, arity, ref namespace_entry);
 			if (found == null)
 				return null;
 
 			return found.Cast<MemberSpec> ().ToList ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="889" endline="927">
<![CDATA[
 
 		static Version IsValidAssemblyVersion (string version, bool allowGenerated)
 		{
 			string[] parts = version.Split ('.');
 			if (parts.Length < 1 || parts.Length > 4)
 				return null;
 
 			var values = new int[4];
 			for (int i = 0; i < parts.Length; ++i) {
 				if (!int.TryParse (parts[i], out values[i])) {
 					if (parts[i].Length == 1 && parts[i][0] == '*' && allowGenerated) {
 						if (i == 2) {
 							// Nothing can follow *
 							if (parts.Length > 3)
 								return null;
 
 							// Generate Build value based on days since 1/1/2000
 							TimeSpan days = DateTime.Today - new DateTime (2000, 1, 1);
 							values[i] = System.Math.Max (days.Days, 0);
 							i = 3;
 						}
 
 						if (i == 3) {
 							// Generate Revision value based on every other second today
 							var seconds = DateTime.Now - DateTime.Today;
 							values[i] = (int) seconds.TotalSeconds / 2;
 							continue;
 						}
 					}
 
 					return null;
 				}
 
 				if (values[i] > ushort.MaxValue)
 					return null;
 			}
 			for (int i = 0; i < parts.Length; ++i) {
 				if (!int.TryParse (parts[i], out values[i])) {
 					if (parts[i].Length == 1 && parts[i][0] == '*' && allowGenerated) {
 						if (i == 2) {
 							// Nothing can follow *
 							if (parts.Length > 3)
 								return null;
 
 							// Generate Build value based on days since 1/1/2000
 							TimeSpan days = DateTime.Today - new DateTime (2000, 1, 1);
 							values[i] = System.Math.Max (days.Days, 0);
 							i = 3;
 						}
 
 						if (i == 3) {
 							// Generate Revision value based on every other second today
 							var seconds = DateTime.Now - DateTime.Today;
 							values[i] = (int) seconds.TotalSeconds / 2;
 							continue;
 						}
 					}
 
 					return null;
 				}
 
 				if (values[i] > ushort.MaxValue)
 					return null;
 			}
 
 			return new Version (values[0], values[1], values[2], values[3]);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1207" endline="1287">
<![CDATA[
 
 		public static TypeCode GetTypeCode(Type type)
 		{
 			if (type == null)
 			{
 				return TypeCode.Empty;
 			}
 			if (type.IsEnum)
 			{
 				type = type.GetEnumUnderlyingType();
 			}
 			Universe u = type.Module.universe;
 			if (type == u.System_Boolean)
 			{
 				return TypeCode.Boolean;
 			}
 			else if (type == u.System_Char)
 			{
 				return TypeCode.Char;
 			}
 			else if (type == u.System_SByte)
 			{
 				return TypeCode.SByte;
 			}
 			else if (type == u.System_Byte)
 			{
 				return TypeCode.Byte;
 			}
 			else if (type == u.System_Int16)
 			{
 				return TypeCode.Int16;
 			}
 			else if (type == u.System_UInt16)
 			{
 				return TypeCode.UInt16;
 			}
 			else if (type == u.System_Int32)
 			{
 				return TypeCode.Int32;
 			}
 			else if (type == u.System_UInt32)
 			{
 				return TypeCode.UInt32;
 			}
 			else if (type == u.System_Int64)
 			{
 				return TypeCode.Int64;
 			}
 			else if (type == u.System_UInt64)
 			{
 				return TypeCode.UInt64;
 			}
 			else if (type == u.System_Single)
 			{
 				return TypeCode.Single;
 			}
 			else if (type == u.System_Double)
 			{
 				return TypeCode.Double;
 			}
 			else if (type == u.System_DateTime)
 			{
 				return TypeCode.DateTime;
 			}
 			else if (type == u.System_DBNull)
 			{
 				return TypeCode.DBNull;
 			}
 			else if (type == u.System_Decimal)
 			{
 				return TypeCode.Decimal;
 			}
 			else if (type == u.System_String)
 			{
 				return TypeCode.String;
 			}
 			else
 			{
 				return TypeCode.Object;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="333" endline="414">
<![CDATA[
 
 		public MethodSpec CreateMethod (MethodBase mb, TypeSpec declaringType)
 		{
 			Modifiers mod = ReadMethodModifiers (mb, declaringType);
 			TypeParameterSpec[] tparams;
 
 			var parameters = CreateParameters (declaringType, mb.GetParameters (), mb);
 
 			if (mb.IsGenericMethod) {
 				if (!mb.IsGenericMethodDefinition)
 					throw new NotSupportedException ("assert");
 
 				tparams = CreateGenericParameters (0, mb.GetGenericArguments ());
 			} else {
 				tparams = null;
 			}
 
 			MemberKind kind;
 			TypeSpec returnType;
 			if (mb.MemberType == MemberTypes.Constructor) {
 				kind = MemberKind.Constructor;
 				returnType = TypeManager.void_type;
 			} else {
 				//
 				// Detect operators and destructors
 				//
 				string name = mb.Name;
 				kind = MemberKind.Method;
 				if (tparams == null && !mb.DeclaringType.IsInterface && name.Length > 6) {
 					if ((mod & (Modifiers.STATIC | Modifiers.PUBLIC)) == (Modifiers.STATIC | Modifiers.PUBLIC)) {
 						if (name[2] == '_' && name[1] == 'p' && name[0] == 'o') {
 							var op_type = Operator.GetType (name);
 							if (op_type.HasValue && parameters.Count > 0 && parameters.Count < 3) {
 								kind = MemberKind.Operator;
 							}
 						}
 					} else if (parameters.IsEmpty && name == Destructor.MetadataName) {
 						kind = MemberKind.Destructor;
 						if (declaringType == TypeManager.object_type) {
 							mod &= ~Modifiers.OVERRIDE;
 							mod |= Modifiers.VIRTUAL;
 						}
 					}
 				}
 
 				var mi = (MethodInfo) mb;
 				returnType = ImportType (mi.ReturnType, new DynamicTypeReader (mi.ReturnParameter));
 
 				// Cannot set to OVERRIDE without full hierarchy checks
 				// this flag indicates that the method could be override
 				// but further validation is needed
 				if ((mod & Modifiers.OVERRIDE) != 0 && kind == MemberKind.Method && declaringType.BaseType != null) {
 					var filter = MemberFilter.Method (name, tparams != null ? tparams.Length 
 					var candidate = MemberCache.FindMember (declaringType.BaseType, filter, BindingRestriction.None);
 
 					//
 					// For imported class method do additional validation to be sure that metadata
 					// override flag was correct
 					// 
 					// Difference between protected internal and protected is ok
 					//
 					const Modifiers conflict_mask = Modifiers.AccessibilityMask & ~Modifiers.INTERNAL;
 					if (candidate == null || (candidate.Modifiers & conflict_mask) != (mod & conflict_mask) || candidate.IsStatic) {
 						mod &= ~Modifiers.OVERRIDE;
 						mod |= Modifiers.VIRTUAL;
 					}
 				}
 			}
 
 			IMemberDefinition definition;
 			if (tparams != null) {
 				definition = new ImportedGenericMethodDefinition ((MethodInfo) mb, returnType, parameters, tparams, this);
 			} else {
 				definition = new ImportedParameterMemberDefinition (mb, returnType, parameters, this);
 			}
 
 			MethodSpec ms = new MethodSpec (kind, declaringType, definition, returnType, mb, parameters, mod);
 			if (tparams != null)
 				ms.IsGeneric = true;
 
 			return ms;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3220" endline="3228">
<![CDATA[
 
 		public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 		{
 			if (queried_type == member.DeclaringType)
 				return null;
 
 			return MemberCache.FindMember (queried_type, new MemberFilter ((MethodSpec) member),
 				BindingRestriction.InstanceOnly | BindingRestriction.OverrideOnly) as IParametersMember;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="381" endline="391">
<![CDATA[
 		}
 
 		public string Name {
 			get {
 				int index = File;
 				if (token == 0 || index == 0)
 					return "Internal";
 
 				SourceFile file = (SourceFile) source_list [index - 1];
 				return file.Name;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="590" endline="608">
<![CDATA[
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			var expr = Expr.MakeExpression (ctx);
 			bool is_checked = ctx.HasSet (BuilderContext.Options.CheckedScope);
 
 			switch (Oper) {
 			case Operator.UnaryNegation
 				return is_checked ? SLE.Expression.NegateChecked (expr) 
 			case Operator.LogicalNot
 				return SLE.Expression.Not (expr);
 #if NET_4_0
 			case Operator.OnesComplement
 				return SLE.Expression.OnesComplement (expr);
 #endif
 			default
 				throw new NotImplementedException (Oper.ToString ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5037" endline="5052">
<![CDATA[
 		}
 
 		public override bool Equals (object obj)
 		{
 			FieldExpr fe = obj as FieldExpr;
 			if (fe == null)
 				return false;
 
 			if (spec != fe.spec)
 				return false;
 
 			if (InstanceExpression == null || fe.InstanceExpression == null)
 				return true;
 
 			return InstanceExpression.Equals (fe.InstanceExpression);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="286" endline="317">
<![CDATA[
 		
 		protected virtual Expression ResolveOperator (ResolveContext ec, Expression expr)
 		{
 			eclass = ExprClass.Value;
 
 			if (predefined_operators == null)
 				CreatePredefinedOperatorsTable ();
 
 			TypeSpec expr_type = expr.Type;
 			Expression best_expr;
 
 			//
 			// Primitive types first
 			//
 			if (TypeManager.IsPrimitiveType (expr_type)) {
 				best_expr = ResolvePrimitivePredefinedType (expr);
 				if (best_expr == null)
 					return null;
 
 				type = best_expr.Type;
 				Expr = best_expr;
 				return this;
 			}
 
 			//
 			// E operator ~(E x);
 			//
 			if (Oper == Operator.OnesComplement && TypeManager.IsEnumType (expr_type))
 				return ResolveEnumOperator (ec, expr);
 
 			return ResolveUserType (ec, expr);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="569" endline="580">
<![CDATA[
 		}
 
 		public int DefineNamespace (string name, string[] using_clauses, int parent)
 		{
 			if (!creating)
 				throw new InvalidOperationException ();
 
 			int index = file.GetNextNamespaceIndex ();
 			NamespaceEntry ns = new NamespaceEntry (name, index, using_clauses, parent);
 			namespaces.Add (ns);
 			return index;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1857" endline="1868">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].MemberForwarded))
 				{
 					records[i].MemberForwarded = moduleBuilder.ResolvePseudoToken(records[i].MemberForwarded);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].MemberForwarded))
 				{
 					records[i].MemberForwarded = moduleBuilder.ResolvePseudoToken(records[i].MemberForwarded);
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.cs" startline="161" endline="178">
<![CDATA[
 
   /* An EOF token */
   public int eof_token;
 
   /** (syntax) error message.
       Can be overwritten to control message format.
       @param message text to be displayed.
       @param expected vector of acceptable tokens, if available.
     */
   public void yyerror (string message, string[] expected) {
     if ((yacc_verbose_flag > 0) && (expected != null) && (expected.Length  > 0)) {
       ErrorOutput.Write (message+", expecting");
       for (int n = 0; n < expected.Length; ++ n)
         ErrorOutput.Write (" "+expected[n]);
       for (int n = 0; n < expected.Length; ++ n)
         ErrorOutput.Write (" "+expected[n]);
         ErrorOutput.WriteLine ();
     } else
       ErrorOutput.WriteLine (message);
   }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="717" endline="737">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{		
 			TypeSpec del_type = InstanceExpr.Type;
 			if (del_type == null)
 				return null;
 
 			//
 			// Do only core overload resolution the rest of the checks has been
 			// done on primary expression
 			//
 			method = Delegate.GetInvokeMethod (ec.Compiler, del_type);
 			var res = new OverloadResolver (new MemberSpec[] { method }, OverloadResolver.Restrictions.DelegateInvoke, loc);
 			var valid = res.ResolveMember<MethodSpec> (ec, ref arguments);
 			if (valid == null && !res.BestCandidateIsDynamic)
 				return null;
 
 			type = method.ReturnType;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7423" endline="7452">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			TypeExpr texpr = QueriedType.ResolveAsTypeTerminal (ec, false);
 			if (texpr == null)
 				return null;
 
 			type_queried = texpr.Type;
 			if (TypeManager.IsEnumType (type_queried))
 				type_queried = EnumSpec.GetUnderlyingType (type_queried);
 
 			int size_of = GetTypeSize (type_queried);
 			if (size_of > 0) {
 				return new IntConstant (size_of, loc).Resolve (ec);
 			}
 
 			if (!TypeManager.VerifyUnmanaged (ec.Compiler, type_queried, loc)){
 				return null;
 			}
 
 			if (!ec.IsUnsafe) {
 				ec.Report.Error (233, loc,
 					"`{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context (consider using System.Runtime.InteropServices.Marshal.SizeOf)",
 					TypeManager.CSharpName (type_queried));
 			}
 			
 			type = TypeManager.int32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="395" endline="429">
<![CDATA[
 
 		public InflatedTypeSpec MakeGenericType (TypeSpec[] targs)
 		{
 			if (targs.Length == 0 && !IsNested)
 				throw new ArgumentException ("Empty type arguments for type " + GetSignatureForError ());
 
 			InflatedTypeSpec instance;
 
 			if (inflated_instances == null) {
 				inflated_instances = new Dictionary<TypeSpec[], InflatedTypeSpec> (TypeSpecComparer.Default);
 
 				if (IsNested) {
 					instance = this as InflatedTypeSpec;
 					if (instance != null) {
 						//
 						// Nested types could be inflated on already inflated instances
 						// Caching this type ensured we are using same instance for
 						// inside/outside inflation using local type parameters
 						//
 						inflated_instances.Add (TypeArguments, instance);
 					}
 				}
 			}
 
 			if (!inflated_instances.TryGetValue (targs, out instance)) {
 				if (GetDefinition () != this && !IsNested)
 					throw new InternalErrorException ("`{0}' must be type definition or nested non-inflated type to MakeGenericType",
 						GetSignatureForError ());
 
 				instance = new InflatedTypeSpec (this, declaringType, targs);
 				inflated_instances.Add (targs, instance);
 			}
 
 			return instance;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="561" endline="590">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = this.ModuleBuilder.universe;
 			Type type = customBuilder.Constructor.DeclaringType;
 			if (type == u.System_Runtime_InteropServices_StructLayoutAttribute)
 			{
 				SetStructLayoutPseudoCustomAttribute(customBuilder.DecodeBlob(this.Assembly));
 			}
 			else if (type == u.System_SerializableAttribute)
 			{
 				attribs |= TypeAttributes.Serializable;
 			}
 			else if (type == u.System_Runtime_InteropServices_ComImportAttribute)
 			{
 				attribs |= TypeAttributes.Import;
 			}
 			else if (type == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attribs |= TypeAttributes.SpecialName;
 			}
 			else
 			{
 				if (type == u.System_Security_SuppressUnmanagedCodeSecurityAttribute)
 				{
 					attribs |= TypeAttributes.HasSecurity;
 				}
 				this.ModuleBuilder.SetCustomAttribute(token, customBuilder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="597" endline="635">
<![CDATA[
 
 		protected override void CreateArguments (ResolveContext ec, Parameter parameter, ref Arguments args)
 		{
 			if (args == null) {
 				if (IdentifierType != null)
 					expr = CreateCastExpression (expr);
 
 				base.CreateArguments (ec, parameter.Clone (), ref args);
 			}
 
 			Expression result_selector_expr;
 			QueryBlock result_block;
 
 			var target = GetIntoVariable ();
 			var target_param = new ImplicitLambdaParameter (target.Name, target.Location);
 
 			//
 			// When select follows use it as a result selector
 			//
 			if (next is Select) {
 				result_selector_expr = next.Expr;
 
 				result_block = next.block;
 				result_block.SetParameters (parameter, target_param);
 
 				next = next.next;
 			} else {
 				result_selector_expr = CreateRangeVariableType (ec, parameter, target, new SimpleName (target.Name, target.Location));
 
 				result_block = new QueryBlock (ec.Compiler, block.Parent, block.StartLocation);
 				result_block.SetParameters (parameter, target_param);
 			}
 
 			LambdaExpression result_selector = new LambdaExpression (Location);
 			result_selector.Block = result_block;
 			result_selector.Block.AddStatement (new ContextualReturn (result_selector_expr));
 
 			args.Add (new Argument (result_selector));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="428" endline="458">
<![CDATA[
 
 		public override void Emit()
 		{
 			ResolveContext rc = new ResolveContext (this);
 			IntConstant buffer_size_const = initializer.Resolve (rc) as IntConstant;
 			if (buffer_size_const == null)
 				return;
 
 			int buffer_size = buffer_size_const.Value;
 
 			if (buffer_size <= 0) {
 				Report.Error (1665, Location, "`{0}'
 				return;
 			}
 
 			int type_size = Expression.GetTypeSize (MemberType);
 
 			if (buffer_size > int.MaxValue / type_size) {
 				Report.Error (1664, Location, "Fixed size buffer `{0}' of length `{1}' and type `{2}' exceeded 2^31 limit",
 					GetSignatureForError (), buffer_size.ToString (), TypeManager.CSharpName (MemberType));
 				return;
 			}
 
 			EmitFieldSize (buffer_size);
 
 			Module.PredefinedAttributes.UnsafeValueType.EmitAttribute (fixed_buffer_type);
 			Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (fixed_buffer_type);
 			fixed_buffer_type.CreateType ();
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4437" endline="4491">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			true_expr = true_expr.Resolve (ec);
 			false_expr = false_expr.Resolve (ec);
 
 			if (true_expr == null || false_expr == null || expr == null)
 				return null;
 
 			eclass = ExprClass.Value;
 			TypeSpec true_type = true_expr.Type;
 			TypeSpec false_type = false_expr.Type;
 			type = true_type;
 
 			//
 			// First, if an implicit conversion exists from true_expr
 			// to false_expr, then the result type is of type false_expr.Type
 			//
 			if (!TypeSpecComparer.IsEqual (true_type, false_type)) {
 				Expression conv = Convert.ImplicitConversion (ec, true_expr, false_type, loc);
 				if (conv != null && true_type != InternalType.Dynamic) {
 					//
 					// Check if both can convert implicitly to each other's type
 					//
 					type = false_type;
 
 					if (false_type != InternalType.Dynamic && Convert.ImplicitConversion (ec, false_expr, true_type, loc) != null) {
 						ec.Report.Error (172, true_expr.Location,
 							"Type of conditional expression cannot be determined as `{0}' and `{1}' convert implicitly to each other",
 								true_type.GetSignatureForError (), false_type.GetSignatureForError ());
 						return null;
 					}
 
 					true_expr = conv;
 				} else if ((conv = Convert.ImplicitConversion (ec, false_expr, true_type, loc)) != null) {
 					false_expr = conv;
 				} else {
 					ec.Report.Error (173, true_expr.Location,
 						"Type of conditional expression cannot be determined because there is no implicit conversion between `{0}' and `{1}'",
 						TypeManager.CSharpName (true_type), TypeManager.CSharpName (false_type));
 					return null;
 				}
 			}			
 
 			// Dead code optimalization
 			Constant c = expr as Constant;
 			if (c != null){
 				bool is_false = c.IsDefaultValue;
 				ec.Report.Warning (429, 4, is_false ? true_expr.Location 
 				return ReducedExpression.Create (is_false ? false_expr 
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="416" endline="475">
<![CDATA[
 
 		public void Emit ()
 		{
 			if (RootContext.Target == Target.Module) {
 				module_target_attrs = new AssemblyAttributesPlaceholder (module, name);
 				module_target_attrs.CreateType ();
 				module_target_attrs.DefineType ();
 				module_target_attrs.Define ();
 				module.AddCompilerGeneratedClass (module_target_attrs);
 			} else if (added_modules != null) {
 				ReadModulesAssemblyAttributes ();
 			}
 
 			if (RootContext.GenerateDebugInfo) {
 				symbol_writer = new MonoSymbolWriter (file_name);
 
 				// TODO
 				Location.DefineSymbolDocuments (symbol_writer);
 				SymbolWriter.symwriter = symbol_writer;
 			}
 
 			module.Emit ();
 
 			if (module.HasExtensionMethod) {
 				var pa = module.PredefinedAttributes.Extension;
 				if (pa.IsDefined) {
 					SetCustomAttribute (pa.Constructor, AttributeEncoder.Empty);
 				}
 			}
 
 			if (!wrap_non_exception_throws_custom) {
 				PredefinedAttribute pa = module.PredefinedAttributes.RuntimeCompatibility;
 				if (pa.IsDefined && pa.ResolveBuilder ()) {
 					var prop = pa.GetProperty ("WrapNonExceptionThrows", TypeManager.bool_type, Location.Null);
 					if (prop != null) {
 						AttributeEncoder encoder = new AttributeEncoder ();
 						encoder.EncodeNamedPropertyArgument (prop, new BoolLiteral (true, Location.Null));
 						SetCustomAttribute (pa.Constructor, encoder.ToArray ());
 					}
 				}
 			}
 
 			if (declarative_security != null) {
 #if STATIC
 				foreach (var entry in declarative_security) {
 					Builder.__AddDeclarativeSecurity (entry);
 				}
 				foreach (var entry in declarative_security) {
 					Builder.__AddDeclarativeSecurity (entry);
 				}
 #else
 				var args = new PermissionSet[3];
 				declarative_security.TryGetValue (SecurityAction.RequestMinimum, out args[0]);
 				declarative_security.TryGetValue (SecurityAction.RequestOptional, out args[1]);
 				declarative_security.TryGetValue (SecurityAction.RequestRefuse, out args[2]);
 				builder_extra.AddPermissionRequests (args);
 #endif
 			}
 
 			CheckReferencesPublicToken ();
 
 			SetEntryPoint ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="672" endline="730">
<![CDATA[
 
 		void EmitBitwiseBoolean (EmitContext ec)
 		{
 			Label load_left = ec.DefineLabel ();
 			Label load_right = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			// null & value, null | value
 			if (left_unwrap == null) {
 				left_unwrap = right_unwrap;
 				right_unwrap = null;
 				right = left;
 			}
 
 			left_unwrap.Emit (ec);
 			ec.Emit (OpCodes.Brtrue_S, load_right);
 
 			// value & null, value | null
 			if (right_unwrap != null) {
 				right_unwrap.Emit (ec);
 				ec.Emit (OpCodes.Brtrue_S, load_left);
 			}
 
 			left_unwrap.EmitCheck (ec);
 			ec.Emit (OpCodes.Brfalse_S, load_right);
 
 			// load left
 			ec.MarkLabel (load_left);
 
 			if (Oper == Operator.BitwiseAnd) {
 				left_unwrap.Load (ec);
 			} else {
 				if (right_unwrap == null) {
 					right.Emit (ec);
 					if (right is EmptyConstantCast || right is EmptyCast)
 						ec.Emit (OpCodes.Newobj, NullableInfo.GetConstructor (type));
 				} else {
 					right_unwrap.Load (ec);
 					right_unwrap = left_unwrap;
 				}
 			}
 			ec.Emit (OpCodes.Br_S, end_label);
 
 			// load right
 			ec.MarkLabel (load_right);
 			if (right_unwrap == null) {
 				if (Oper == Operator.BitwiseAnd) {
 					right.Emit (ec);
 					if (right is EmptyConstantCast || right is EmptyCast)
 						ec.Emit (OpCodes.Newobj, NullableInfo.GetConstructor (type));
 				} else {
 					left_unwrap.Load (ec);
 				}
 			} else {
 				right_unwrap.Load (ec);
 			}
 
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="490" endline="573">
<![CDATA[
 
 		//
 		// Either keyFile or keyContainer has to be non-null
 		//
 		void LoadPublicKey (string keyFile, string keyContainer)
 		{
 			if (keyContainer != null) {
 				try {
 					private_key = new StrongNameKeyPair (keyContainer);
 					public_key = private_key.PublicKey;
 				} catch {
 					Error_AssemblySigning ("The specified key container `" + keyContainer + "' does not exist");
 				}
 
 				return;
 			}
 
 			bool key_file_exists = File.Exists (keyFile);
 
 			//
 			// For attribute based KeyFile do additional lookup
 			// in output assembly path
 			//
 			if (!key_file_exists && RootContext.StrongNameKeyFile == null) {
 				//
 				// The key file can be relative to output assembly
 				//
 				string test_path = Path.Combine (Path.GetDirectoryName (file_name), keyFile);
 				key_file_exists = File.Exists (test_path);
 				if (key_file_exists)
 					keyFile = test_path;
 			}
 
 			if (!key_file_exists) {
 				Error_AssemblySigning ("The specified key file `" + keyFile + "' does not exist");
 				return;
 			}
 
 			using (FileStream fs = new FileStream (keyFile, FileMode.Open, FileAccess.Read)) {
 				byte[] snkeypair = new byte[fs.Length];
 				fs.Read (snkeypair, 0, snkeypair.Length);
 
 				// check for ECMA key
 				if (snkeypair.Length == 16) {
 					public_key = snkeypair;
 					return;
 				}
 
 				try {
 					// take it, with or without, a private key
 					RSA rsa = CryptoConvert.FromCapiKeyBlob (snkeypair);
 					// and make sure we only feed the public part to Sys.Ref
 					byte[] publickey = CryptoConvert.ToCapiPublicKeyBlob (rsa);
 
 					// AssemblyName.SetPublicKey requires an additional header
 					byte[] publicKeyHeader = new byte[8] { 0x00, 0x24, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00 };
 
 					// Encode public key
 					public_key = new byte[12 + publickey.Length];
 					Buffer.BlockCopy (publicKeyHeader, 0, public_key, 0, publicKeyHeader.Length);
 
 					// Length of Public Key (in bytes)
 					int lastPart = public_key.Length - 12;
 					public_key[8] = (byte) (lastPart & 0xFF);
 					public_key[9] = (byte) ((lastPart >> 8) & 0xFF);
 					public_key[10] = (byte) ((lastPart >> 16) & 0xFF);
 					public_key[11] = (byte) ((lastPart >> 24) & 0xFF);
 
 					Buffer.BlockCopy (publickey, 0, public_key, 12, publickey.Length);
 				} catch {
 					Error_AssemblySigning ("The specified key file `" + keyFile + "' has incorrect format");
 					return;
 				}
 
 				if (delay_sign)
 					return;
 
 				try {
 					// TODO
 					CryptoConvert.FromCapiPrivateKeyBlob (snkeypair);
 					private_key = new StrongNameKeyPair (snkeypair);
 				} catch { }
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4867" endline="4934">
<![CDATA[
 
 		Expression DoResolve (ResolveContext ec, Expression rhs)
 		{
 			bool lvalue_instance = rhs != null && IsInstance && spec.DeclaringType.IsStruct;
 
 			if (ResolveInstanceExpression (ec, rhs)) {
 				// Resolve the field's instance expression while flow analysis is turned
 				// off
 				// "a.b" is initialized, not whether the whole struct "a" is initialized.
 
 				if (lvalue_instance) {
 					using (ec.With (ResolveContext.Options.DoFlowAnalysis, false)) {
 						bool out_access = rhs == EmptyExpression.OutAccess.Instance || rhs == EmptyExpression.LValueMemberOutAccess;
 
 						Expression right_side =
 							out_access ? EmptyExpression.LValueMemberOutAccess 
 
 						InstanceExpression = InstanceExpression.ResolveLValue (ec, right_side);
 					}
 				} else {
 					using (ec.With (ResolveContext.Options.DoFlowAnalysis, false)) {
 						InstanceExpression = InstanceExpression.Resolve (ec, ResolveFlags.VariableOrValue);
 					}
 				}
 
 				if (InstanceExpression == null)
 					return null;
 			}
 
 			DoBestMemberChecks (ec, spec);
 
 			var fb = spec as FixedFieldSpec;
 			IVariableReference var = InstanceExpression as IVariableReference;
 
 			if (lvalue_instance && var != null && var.VariableInfo != null) {
 				var.VariableInfo.SetFieldAssigned (ec, Name);
 			}
 			
 			if (fb != null) {
 				IFixedExpression fe = InstanceExpression as IFixedExpression;
 				if (!ec.HasSet (ResolveContext.Options.FixedInitializerScope) && (fe == null || !fe.IsFixed)) {
 					ec.Report.Error (1666, loc, "You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement");
 				}
 
 				if (InstanceExpression.eclass != ExprClass.Variable) {
 					ec.Report.SymbolRelatedToPreviousError (spec);
 					ec.Report.Error (1708, loc, "`{0}'
 						TypeManager.GetFullNameSignature (spec));
 				} else if (var != null && var.IsHoisted) {
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, var, loc);
 				}
 				
 				return new FixedBufferPtr (this, fb.ElementType, loc).Resolve (ec);
 			}
 
 			eclass = ExprClass.Variable;
 
 			// If the instance expression is a local variable or parameter.
 			if (var == null || var.VariableInfo == null)
 				return this;
 
 			VariableInfo vi = var.VariableInfo;
 			if (!vi.IsFieldAssigned (ec, Name, loc))
 				return null;
 
 			variable_info = vi.GetSubStruct (Name);
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="707" endline="738">
<![CDATA[
 
 		public bool CheckTarget ()
 		{
 			string[] valid_targets = Owner.ValidAttributeTargets;
 			if (ExplicitTarget == null || ExplicitTarget == valid_targets [0]) {
 				Target = Owner.AttributeTargets;
 				return true;
 			}
 
 			// TODO
 			if (Array.Exists (valid_targets, i => i == ExplicitTarget)) {
 				switch (ExplicitTarget) {
 				case "return"
 				case "param"
 				case "field"
 				case "method"
 				case "property"
 				case "module"
 				}
 				throw new InternalErrorException ("Unknown explicit target
 			}
 				
 			StringBuilder sb = new StringBuilder ();
 			foreach (string s in valid_targets) {
 				sb.Append (s);
 				sb.Append (", ");
 			}
 			foreach (string s in valid_targets) {
 				sb.Append (s);
 				sb.Append (", ");
 			}
 			sb.Remove (sb.Length - 2, 2);
 			Report.Error (657, Location, "`{0}' is not a valid attribute location for this declaration. " +
 				"Valid attribute locations for this declaration are `{1}'", ExplicitTarget, sb.ToString ());
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1858" endline="1946">
<![CDATA[
 
 		/// <summary>
 		///   Performs an explicit conversion of the expression `expr' whose
 		///   type is expr.Type to `target_type'.
 		/// </summary>
 		static public Expression ExplicitConversionCore (ResolveContext ec, Expression expr,
 								 TypeSpec target_type, Location loc)
 		{
 			TypeSpec expr_type = expr.Type;
 
 			// Explicit conversion includes implicit conversion and it used for enum underlying types too
 			Expression ne = ImplicitConversionStandard (ec, expr, target_type, loc, true);
 			if (ne != null)
 				return ne;
 
 			if (TypeManager.IsEnumType (expr_type)) {
 				TypeSpec real_target = TypeManager.IsEnumType (target_type) ? EnumSpec.GetUnderlyingType (target_type) 
 				Expression underlying = EmptyCast.Create (expr, EnumSpec.GetUnderlyingType (expr_type));
 				if (underlying.Type == real_target)
 					ne = underlying;
 
 				if (ne == null)
 					ne = ImplicitNumericConversion (underlying, real_target);
 
 				if (ne == null)
 					ne = ExplicitNumericConversion (underlying, real_target);
 
 				//
 				// LAMESPEC
 				//
 				if (ne == null && (real_target == TypeManager.intptr_type || real_target == TypeManager.uintptr_type))
 					ne = ExplicitUserConversion (ec, underlying, real_target, loc);
 
 				return ne != null ? EmptyCast.Create (ne, target_type) 
 			}
 
 			if (TypeManager.IsEnumType (target_type)) {
 				//
 				// System.Enum can be unboxed to any enum-type
 				//
 				if (expr_type == TypeManager.enum_type)
 					return new UnboxCast (expr, target_type);
 
 				TypeSpec real_target = TypeManager.IsEnumType (target_type) ? EnumSpec.GetUnderlyingType (target_type) 
 
 				if (expr_type == real_target)
 					return EmptyCast.Create (expr, target_type);
 
 				ne = ImplicitNumericConversion (expr, real_target);
 				if (ne != null)
 					return EmptyCast.Create (ne, target_type);
 
 				ne = ExplicitNumericConversion (expr, real_target);
 				if (ne != null)
 					return EmptyCast.Create (ne, target_type);
 
 				//
 				// LAMESPEC
 				//
 				if (expr_type == TypeManager.intptr_type || expr_type == TypeManager.uintptr_type) {
 					ne = ExplicitUserConversion (ec, expr, real_target, loc);
 					if (ne != null)
 						return ExplicitConversionCore (ec, ne, target_type, loc);
 				}
 			} else {
 				ne = ExplicitNumericConversion (expr, target_type);
 				if (ne != null)
 					return ne;
 			}
 
 			//
 			// Skip the ExplicitReferenceConversion because we can not convert
 			// from Null to a ValueType, and ExplicitReference wont check against
 			// null literal explicitly
 			//
 			if (expr_type != InternalType.Null) {
 				ne = ExplicitReferenceConversion (expr, expr_type, target_type);
 				if (ne != null)
 					return ne;
 			}
 
 			if (ec.IsUnsafe){
 				ne = ExplicitUnsafe (expr, target_type);
 				if (ne != null)
 					return ne;
 			}
 			
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="624" endline="634">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			UsageVector vector = base.Merge ();
 
 			if (actual.IsUnreachable)
 				Report.Warning (162, 2, stmt.loc, "Unreachable code detected");
 
 			actual.MergeChild (vector, false);
 			return actual;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="162" endline="193">
<![CDATA[
 
  		protected override bool CheckBase ()
 		{
  			if (!base.CheckBase ())
  				return false;
 
 			MemberSpec candidate;
 			var conflict_symbol = MemberCache.FindBaseMember (this, out candidate);
 			if (conflict_symbol == null)
 				conflict_symbol = candidate;
 
  			if (conflict_symbol == null) {
  				if ((ModFlags & Modifiers.NEW) != 0) {
  					Report.Warning (109, 4, Location, "The member `{0}' does not hide an inherited member. The new keyword is not required",
 						GetSignatureForError ());
  				}
  			} else {
 				if ((ModFlags & (Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.BACKING_FIELD)) == 0) {
 					Report.SymbolRelatedToPreviousError (conflict_symbol);
 					Report.Warning (108, 2, Location, "`{0}' hides inherited member `{1}'. Use the new keyword if hiding was intended",
 						GetSignatureForError (), conflict_symbol.GetSignatureForError ());
 				}
 
 				if (conflict_symbol.IsAbstract) {
 					Report.SymbolRelatedToPreviousError (conflict_symbol);
 					Report.Error (533, Location, "`{0}' hides inherited abstract member `{1}'",
 						GetSignatureForError (), conflict_symbol.GetSignatureForError ());
 				}
 			}
  
  			return true;
  		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9636" endline="9656">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (parameters == null)
 				return base.CreateExpressionTree (ec);
 
 			var init = new ArrayInitializer (parameters.Count, loc);
 			foreach (Property p in anonymous_type.Properties)
 				init.Add (new TypeOfMethod (MemberCache.GetMember (type, p.Get.Spec), loc));
 			foreach (Property p in anonymous_type.Properties)
 				init.Add (new TypeOfMethod (MemberCache.GetMember (type, p.Get.Spec), loc));
 
 			var ctor_args = new ArrayInitializer (arguments.Count, loc);
 			foreach (Argument a in arguments)
 				ctor_args.Add (a.CreateExpressionTree (ec));
 			foreach (Argument a in arguments)
 				ctor_args.Add (a.CreateExpressionTree (ec));
 
 			Arguments args = new Arguments (3);
 			args.Add (new Argument (new TypeOfMethod (method, loc)));
 			args.Add (new Argument (new ArrayCreation (CreateExpressionTypeExpression (ec, loc), ctor_args, loc)));
 			args.Add (new Argument (new ImplicitlyTypedArrayCreation (init, loc)));
 
 			return CreateExpressionFactoryCall (ec, "New", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="619" endline="695">
<![CDATA[
 		
 		//
 		// Parses the string @input and returns a CSharpParser if succeeful.
 		//
 		// if @silent is set to true then no errors are
 		// reported to the user.  This is used to do various calls to the
 		// parser and check if the expression is parsable.
 		//
 		// @partial_input
 		// parsed expression was partial, and more data is needed
 		//
 		static CSharpParser ParseString (ParseMode mode, string input, out bool partial_input)
 		{
 			partial_input = false;
 			Reset ();
 			queued_fields.Clear ();
 			Tokenizer.LocatedToken.Initialize ();
 
 			Stream s = new MemoryStream (Encoding.Default.GetBytes (input));
 			SeekableStreamReader seekable = new SeekableStreamReader (s, Encoding.Default);
 
 			InputKind kind = ToplevelOrStatement (seekable);
 			if (kind == InputKind.Error){
 				if (mode == ParseMode.ReportErrors)
 					ctx.Report.Error (-25, "Detection Parsing Error");
 				partial_input = false;
 				return null;
 			}
 
 			if (kind == InputKind.EOF){
 				if (mode == ParseMode.ReportErrors)
 					Console.Error.WriteLine ("Internal error
 				partial_input = true;
 				return null;
 				
 			}
 			seekable.Position = 0;
 
 			CSharpParser parser = new CSharpParser (seekable, Location.SourceFiles [0], RootContext.ToplevelTypes);
 
 			if (kind == InputKind.StatementOrExpression){
 				parser.Lexer.putback_char = Tokenizer.EvalStatementParserCharacter;
 				RootContext.StatementMode = true;
 			} else {
 				//
 				// Do not activate EvalCompilationUnitParserCharacter until
 				// I have figured out all the limitations to invoke methods
 				// in the generated classes.  See repl.txt
 				//
 				parser.Lexer.putback_char = Tokenizer.EvalUsingDeclarationsParserCharacter;
 				//parser.Lexer.putback_char = Tokenizer.EvalCompilationUnitParserCharacter;
 				RootContext.StatementMode = false;
 			}
 
 			if (mode == ParseMode.GetCompletions)
 				parser.Lexer.CompleteOnEOF = true;
 
 			ReportPrinter old_printer = null;
 			if ((mode == ParseMode.Silent || mode == ParseMode.GetCompletions) && CSharpParser.yacc_verbose_flag == 0)
 				old_printer = SetPrinter (new StreamReportPrinter (TextWriter.Null));
 
 			try {
 				parser.parse ();
 			} finally {
 				if (ctx.Report.Errors != 0){
 					if (mode != ParseMode.ReportErrors  && parser.UnexpectedEOF)
 						partial_input = true;
 
 					parser.undo.ExecuteUndo ();
 					parser = null;
 				}
 
 				if (old_printer != null)
 					SetPrinter (old_printer);
 			}
 			return parser;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3710" endline="3771">
<![CDATA[
 
 		void ResolveStringSwitchMap (ResolveContext ec)
 		{
 			FullNamedExpression string_dictionary_type;
 			if (TypeManager.generic_ienumerable_type != null) {
 				MemberAccess system_collections_generic = new MemberAccess (new MemberAccess (
 					new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Collections", loc), "Generic", loc);
 
 				string_dictionary_type = new MemberAccess (system_collections_generic, "Dictionary",
 					new TypeArguments (
 						new TypeExpression (TypeManager.string_type, loc),
 						new TypeExpression (TypeManager.int32_type, loc)), loc);
 			} else {
 				MemberAccess system_collections_generic = new MemberAccess (
 					new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Collections", loc);
 
 				string_dictionary_type = new MemberAccess (system_collections_generic, "Hashtable", loc);
 			}
 
 			var ctype = ec.CurrentMemberDefinition.Parent.PartialContainer;
 			Field field = new Field (ctype, string_dictionary_type,
 				Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.COMPILER_GENERATED,
 				new MemberName (CompilerGeneratedClass.MakeName (null, "f", "switch$map", unique_counter++), loc), null);
 			if (!field.Define ())
 				return;
 			ctype.AddField (field);
 
 			var init = new List<Expression> ();
 			int counter = 0;
 			Elements.Clear ();
 			string value = null;
 			foreach (SwitchSection section in Sections) {
 				int last_count = init.Count;
 				foreach (SwitchLabel sl in section.Labels) {
 					if (sl.Label == null || sl.Converted == SwitchLabel.NullStringCase)
 						continue;
 
 					value = (string) sl.Converted;
 					var init_args = new List<Expression> (2);
 					init_args.Add (new StringLiteral (value, sl.Location));
 					init_args.Add (new IntConstant (counter, loc));
 					init.Add (new CollectionElementInitializer (init_args, loc));
 				}
 				foreach (SwitchLabel sl in section.Labels) {
 					if (sl.Label == null || sl.Converted == SwitchLabel.NullStringCase)
 						continue;
 
 					value = (string) sl.Converted;
 					var init_args = new List<Expression> (2);
 					init_args.Add (new StringLiteral (value, sl.Location));
 					init_args.Add (new IntConstant (counter, loc));
 					init.Add (new CollectionElementInitializer (init_args, loc));
 				}
 
 				//
 				// Don't add empty sections
 				//
 				if (last_count == init.Count)
 					continue;
 
 				Elements.Add (counter, section.Labels [0]);
 				++counter;
 			}
 			foreach (SwitchSection section in Sections) {
 				int last_count = init.Count;
 				foreach (SwitchLabel sl in section.Labels) {
 					if (sl.Label == null || sl.Converted == SwitchLabel.NullStringCase)
 						continue;
 
 					value = (string) sl.Converted;
 					var init_args = new List<Expression> (2);
 					init_args.Add (new StringLiteral (value, sl.Location));
 					init_args.Add (new IntConstant (counter, loc));
 					init.Add (new CollectionElementInitializer (init_args, loc));
 				}
 
 				//
 				// Don't add empty sections
 				//
 				if (last_count == init.Count)
 					continue;
 
 				Elements.Add (counter, section.Labels [0]);
 				++counter;
 			}
 
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (new IntConstant (init.Count, loc)));
 			Expression initializer = new NewInitialize (string_dictionary_type, args,
 				new CollectionOrObjectInitializers (init, loc), loc);
 
 			switch_cache_field = new FieldExpr (field, loc);
 			string_dictionary = new SimpleAssign (switch_cache_field, initializer.Resolve (ec));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2123" endline="2167">
<![CDATA[
 
 		bool CheckConversion (IMemberContext mc, MemberSpec context, TypeSpec atype, TypeParameterSpec tparam, TypeSpec ttype, Location loc)
 		{
 			if (TypeManager.IsValueType (atype)) {
 				if (atype == ttype || Convert.ImplicitBoxingConversion (null, atype, ttype) != null)
 					return true;
 			} else {
 				var expr = new EmptyExpression (atype);
 
 				if (atype.IsGenericParameter) {
 					if (Convert.ImplicitTypeParameterConversion (expr, ttype) != null)
 						return true;
 				}
 
 				if (Convert.ImplicitStandardConversionExists (expr, ttype))
 					return true;
 			}
 
 			//
 			// When partial/full type inference finds a dynamic type argument delay
 			// the constraint check to runtime, it can succeed for real underlying
 			// dynamic type
 			//
 			if (ignore_inferred_dynamic && HasDynamicTypeArgument (ttype.TypeArguments))
 				return true;
 
 			if (mc != null) {
 				mc.Compiler.Report.SymbolRelatedToPreviousError (tparam);
 				if (TypeManager.IsValueType (atype)) {
 					mc.Compiler.Report.Error (315, loc,
 						"The type `{0}' cannot be used as type parameter `{1}' in the generic type or method `{2}'. There is no boxing conversion from `{0}' to `{3}'",
 						atype.GetSignatureForError (), tparam.GetSignatureForError (), context.GetSignatureForError (), ttype.GetSignatureForError ());
 				} else if (atype.IsGenericParameter) {
 					mc.Compiler.Report.Error (314, loc,
 						"The type `{0}' cannot be used as type parameter `{1}' in the generic type or method `{2}'. There is no boxing or type parameter conversion from `{0}' to `{3}'",
 						atype.GetSignatureForError (), tparam.GetSignatureForError (), context.GetSignatureForError (), ttype.GetSignatureForError ());
 				} else {
 					mc.Compiler.Report.Error (311, loc,
 						"The type `{0}' cannot be used as type parameter `{1}' in the generic type or method `{2}'. There is no implicit reference conversion from `{0}' to `{3}'",
 						atype.GetSignatureForError (), tparam.GetSignatureForError (), context.GetSignatureForError (), ttype.GetSignatureForError ());
 				}
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ModuleWriter.cs" startline="320" endline="370">
<![CDATA[
 
 		private static void StrongName(FileStream fs, StrongNameKeyPair keyPair, uint headerLength, uint textSectionFileOffset, uint strongNameSignatureFileOffset, uint strongNameSignatureLength)
 		{
 			SHA1Managed hash = new SHA1Managed();
 			using (CryptoStream cs = new CryptoStream(Stream.Null, hash, CryptoStreamMode.Write))
 			{
 				fs.Seek(0, SeekOrigin.Begin);
 				byte[] buf = new byte[8192];
 				HashChunk(fs, cs, buf, (int)headerLength);
 				fs.Seek(textSectionFileOffset, SeekOrigin.Begin);
 				HashChunk(fs, cs, buf, (int)(strongNameSignatureFileOffset - textSectionFileOffset));
 				fs.Seek(strongNameSignatureLength, SeekOrigin.Current);
 				HashChunk(fs, cs, buf, (int)(fs.Length - (strongNameSignatureFileOffset + strongNameSignatureLength)));
 			}
 			using (RSA rsa = CryptoHack.CreateRSA(keyPair))
 			{
 				RSAPKCS1SignatureFormatter sign = new RSAPKCS1SignatureFormatter(rsa);
 				byte[] signature = sign.CreateSignature(hash);
 				Array.Reverse(signature);
 				if (signature.Length != strongNameSignatureLength)
 				{
 					throw new InvalidOperationException("Signature length mismatch");
 				}
 				fs.Seek(strongNameSignatureFileOffset, SeekOrigin.Begin);
 				fs.Write(signature, 0, signature.Length);
 			}
 
 			// compute the PE checksum
 			fs.Seek(0, SeekOrigin.Begin);
 			int count = (int)fs.Length / 4;
 			BinaryReader br = new BinaryReader(fs);
 			long sum = 0;
 			for (int i = 0; i < count; i++)
 			{
 				sum += br.ReadUInt32();
 				int carry = (int)(sum >> 32);
 				sum &= 0xFFFFFFFFU;
 				sum += carry;
 			}
 			for (int i = 0; i < count; i++)
 			{
 				sum += br.ReadUInt32();
 				int carry = (int)(sum >> 32);
 				sum &= 0xFFFFFFFFU;
 				sum += carry;
 			}
 			while ((sum >> 16) != 0)
 			{
 				sum = (sum & 0xFFFF) + (sum >> 16);
 			}
 			while ((sum >> 16) != 0)
 			{
 				sum = (sum & 0xFFFF) + (sum >> 16);
 			}
 			sum += fs.Length;
 
 			// write the PE checksum, note that it is always at offset 0xD8 in the file
 			ByteBuffer bb = new ByteBuffer(4);
 			bb.Write((int)sum);
 			fs.Seek(0xD8, SeekOrigin.Begin);
 			bb.WriteTo(fs);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4740" endline="4748">
<![CDATA[
 		}
 
 		#endregion
 
 		public bool VerifyAssigned (ResolveContext ec)
 		{
 			VariableInfo variable_info = local_info.VariableInfo;
 			return variable_info == null || variable_info.IsAssigned (ec, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="711" endline="725">
<![CDATA[
 		}
 
 		public override string FullName
 		{
 			get
 			{
 				if (this.IsNested)
 				{
 					return this.DeclaringType.FullName + "+" + nameOrFullName;
 				}
 				else
 				{
 					return nameOrFullName;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="387" endline="399">
<![CDATA[
 
 		public abstract AssemblyName[] __GetReferencedAssemblies();
 
 		internal Type CanonicalizeType(Type type)
 		{
 			Type canon;
 			if (!universe.canonicalizedTypes.TryGetValue(type, out canon))
 			{
 				canon = type;
 				universe.canonicalizedTypes.Add(canon, canon);
 			}
 			return canon;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="218" endline="227">
<![CDATA[
 
 		public int CountTypeArguments {
 			get {
 				if (TypeArguments != null)
 					return TypeArguments.Count;
 				else if (Left != null)
 					return Left.CountTypeArguments; 
 				else
 					return 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="365" endline="378">
<![CDATA[
 		}
 
 		internal override Type BindTypeParameters(IGenericBinder binder)
 		{
 			int owner = module.GenericParam.records[index].Owner;
 			if ((owner >> 24) == MethodDefTable.Index)
 			{
 				return binder.BindMethodParameter(this);
 			}
 			else
 			{
 				return binder.BindTypeParameter(this);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="842" endline="850">
<![CDATA[
 
 		internal MethodInfo GetEntryPoint()
 		{
 			if (cliHeader.EntryPointToken != 0 && (cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT) == 0)
 			{
 				return (MethodInfo)ResolveMethod((int)cliHeader.EntryPointToken);
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="84" endline="95">
<![CDATA[
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (!MemberType.IsCLSCompliant ()) {
 				Report.Warning (3003, 1, Location, "Type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="146" endline="160">
<![CDATA[
 
 		bool IsWarningAsError (int code)
 		{
 			bool is_error = WarningsAreErrors;
 
 			// Check specific list
 			if (warnings_as_error != null)
 				is_error |= warnings_as_error.Contains (code);
 
 			// Ignore excluded warnings
 			if (warnings_only != null && warnings_only.Contains (code))
 				is_error = false;
 
 			return is_error;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="712" endline="722">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			for (UsageVector origin = return_origins; origin != null; origin = origin.Next)
 				Block.ParametersBlock.CheckOutParameters (origin, origin.Location);
 			for (UsageVector origin = return_origins; origin != null; origin = origin.Next)
 				Block.ParametersBlock.CheckOutParameters (origin, origin.Location);
 
 			UsageVector vector = base.Merge ();
 			Block.ParametersBlock.CheckOutParameters (vector, Block.loc);
 			// Note
 			return vector;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="243" endline="258">
<![CDATA[
 
 		internal void Write(System.IO.Stream stream)
 		{
 			const int chunkSize = 8192;
 			for (; ; )
 			{
 				if (pos + chunkSize > buffer.Length)
 					Grow(chunkSize);
 				int read = stream.Read(buffer, pos, chunkSize);
 				if (read <= 0)
 				{
 					break;
 				}
 				pos += read;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="360" endline="379">
<![CDATA[
 		}
 
 		#endregion
 
 		public bool Define ()
 		{
 			if (type != null)
 				return true;
 
 			Namespace type_ns = module.GlobalRootNamespace.GetNamespace (ns, true);
 			var te = type_ns.LookupType (module.Compiler, name, arity, true, Location.Null);
 			if (te == null)
 				return false;
 
 			if (te.Type.Kind != kind)
 				return false;
 
 			type = te.Type;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4901" endline="4917">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (!inside_try_finally)
 				ec.BeginExceptionBlock ();
 
 			Block.Emit (ec);
 
 			foreach (Catch c in Specific)
 				c.Emit (ec);
 			foreach (Catch c in Specific)
 				c.Emit (ec);
 
 			if (General != null)
 				General.Emit (ec);
 
 			if (!inside_try_finally)
 				ec.EndExceptionBlock ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1130" endline="1150">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = moduleBuilder.ResolvePseudoToken(records[i].Parent);
 				// do the HasFieldMarshal encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case FieldTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 1 | 0;
 						break;
 					case ParamTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 1 | 1;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = moduleBuilder.ResolvePseudoToken(records[i].Parent);
 				// do the HasFieldMarshal encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case FieldTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 1 | 0;
 						break;
 					case ParamTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 1 | 1;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8088" endline="8101">
<![CDATA[
 
 		Expression MakePointerAccess (ResolveContext ec, TypeSpec type)
 		{
 			if (Arguments.Count != 1){
 				ec.Report.Error (196, loc, "A pointer must be indexed by only one value");
 				return null;
 			}
 
 			if (Arguments [0] is NamedArgument)
 				Error_NamedArgument ((NamedArgument) Arguments[0], ec.Report);
 
 			Expression p = new PointerArithmetic (Binary.Operator.Addition, Expr, Arguments [0].Expr.Resolve (ec), type, loc);
 			return new Indirection (p, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1130" endline="1154">
<![CDATA[
 
 		//
 		// Returns member CLS compliance based on full member hierarchy
 		//
 		public bool IsCLSCompliant ()
 		{
 			if ((state & StateFlags.CLSCompliant_Undetected) != 0) {
 				state &= ~StateFlags.CLSCompliant_Undetected;
 
 				if (IsNotCLSCompliant ())
 					return false;
 
 				bool compliant;
 				if (DeclaringType != null) {
 					compliant = DeclaringType.IsCLSCompliant ();
 				} else {
 					compliant = ((ITypeDefinition) MemberDefinition).DeclaringAssembly.IsCLSCompliant;
 				}
 
 				if (compliant)
 					state |= StateFlags.CLSCompliant;
 			}
 
 			return (state & StateFlags.CLSCompliant) != 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="175" endline="202">
<![CDATA[
 		}
 
 		bool ReadBuffer ()
 		{
 			int slack = buffer.Length - char_count;
 
 			//
 			// read_ahead_length is only half of the buffer to deal with
 			// reads ahead and moves back without re-reading whole buffer
 			//
 			if (slack <= read_ahead_length) {
 				//
 				// shift the buffer to make room for read_ahead_length number of characters
 				//
 				int shift = read_ahead_length - slack;
 				Array.Copy (buffer, shift, buffer, 0, char_count - shift);
 
 				// Update all counters
 				pos -= shift;
 				char_count -= shift;
 				buffer_start += shift;
 				slack += shift;
 			}
 
 			char_count += reader.Read (buffer, char_count, slack);
 
 			return pos < char_count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1232" endline="1252">
<![CDATA[
 
 		public void SetPartialDefinition (Method methodDefinition)
 		{
 			caching_flags |= Flags.PartialDefinitionExists;
 			methodDefinition.partialMethodImplementation = this;
 
 			// Ensure we are always using method declaration parameters
 			for (int i = 0; i < methodDefinition.parameters.Count; ++i ) {
 				parameters [i].Name = methodDefinition.parameters [i].Name;
 				parameters [i].DefaultValue = methodDefinition.parameters [i].DefaultValue;
 			}
 			for (int i = 0; i < methodDefinition.parameters.Count; ++i ) {
 				parameters [i].Name = methodDefinition.parameters [i].Name;
 				parameters [i].DefaultValue = methodDefinition.parameters [i].DefaultValue;
 			}
 
 			if (methodDefinition.attributes == null)
 				return;
 
 			if (attributes == null) {
 				attributes = methodDefinition.attributes;
 			} else {
 				attributes.Attrs.AddRange (methodDefinition.attributes.Attrs);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5837" endline="5872">
<![CDATA[
 
 		protected virtual IMemoryLocation EmitAddressOf (EmitContext ec, AddressOp mode)
 		{
 			LocalTemporary value_target = new LocalTemporary (type);
 
 			if (type is TypeParameterSpec) {
 				DoEmitTypeParameter (ec);
 				value_target.Store (ec);
 				value_target.AddressOf (ec, mode);
 				return value_target;
 			}
 
 			if (!TypeManager.IsStruct (type)){
 				//
 				// We throw an exception.  So far, I believe we only need to support
 				// value types
 				// foreach (int j in new StructType ())
 				// see bug 42390
 				//
 				throw new Exception ("AddressOf should not be used for classes");
 			}
 
 			value_target.AddressOf (ec, AddressOp.Store);
 
 			if (method == null) {
 				ec.Emit (OpCodes.Initobj, type);
 			} else {
 				if (arguments != null)
 					arguments.Emit (ec);
 
 				ec.Emit (OpCodes.Call, method);
 			}
 			
 			value_target.AddressOf (ec, mode);
 			return value_target;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="243" endline="272">
<![CDATA[
 
 		internal static void ReadLocalVarSig(ModuleReader module, ByteReader br, IGenericContext context, List<LocalVariableInfo> list)
 		{
 			if (br.Length < 2 || br.ReadByte() != LOCAL_SIG)
 			{
 				throw new BadImageFormatException("Invalid local variable signature");
 			}
 			int count = br.ReadCompressedInt();
 			for (int i = 0; i < count; i++)
 			{
 				if (br.PeekByte() == ELEMENT_TYPE_TYPEDBYREF)
 				{
 					br.ReadByte();
 					list.Add(new LocalVariableInfo(i, module.universe.System_TypedReference, false));
 				}
 				else
 				{
 					SkipCustomModifiers(br);
 					bool pinned = false;
 					if (br.PeekByte() == ELEMENT_TYPE_PINNED)
 					{
 						br.ReadByte();
 						pinned = true;
 					}
 					SkipCustomModifiers(br);
 					Type type = ReadTypeOrByRef(module, br, context);
 					list.Add(new LocalVariableInfo(i, type, pinned));
 				}
 			}
 			for (int i = 0; i < count; i++)
 			{
 				if (br.PeekByte() == ELEMENT_TYPE_TYPEDBYREF)
 				{
 					br.ReadByte();
 					list.Add(new LocalVariableInfo(i, module.universe.System_TypedReference, false));
 				}
 				else
 				{
 					SkipCustomModifiers(br);
 					bool pinned = false;
 					if (br.PeekByte() == ELEMENT_TYPE_PINNED)
 					{
 						br.ReadByte();
 						pinned = true;
 					}
 					SkipCustomModifiers(br);
 					Type type = ReadTypeOrByRef(module, br, context);
 					list.Add(new LocalVariableInfo(i, type, pinned));
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1317" endline="1341">
<![CDATA[
 
 		public override void SetParameterInfo (List<Constraints> constraints_list)
 		{
 			base.SetParameterInfo (constraints_list);
 
 			if (PartialContainer.CurrentTypeParameters == null || PartialContainer == this)
 				return;
 
 			TypeParameter[] tc_names = PartialContainer.CurrentTypeParameters;
 			for (int i = 0; i < tc_names.Length; ++i) {
 				if (tc_names [i].Name != type_params [i].Name) {
 					Report.SymbolRelatedToPreviousError (PartialContainer.Location, "");
 					Report.Error (264, Location, "Partial declarations of `{0}' must have the same type parameter names in the same order",
 						GetSignatureForError ());
 					break;
 				}
 
 				if (tc_names [i].Variance != type_params [i].Variance) {
 					Report.SymbolRelatedToPreviousError (PartialContainer.Location, "");
 					Report.Error (1067, Location, "Partial declarations of `{0}' must have the same type parameter variance modifiers",
 						GetSignatureForError ());
 					break;
 				}
 			}
 			for (int i = 0; i < tc_names.Length; ++i) {
 				if (tc_names [i].Name != type_params [i].Name) {
 					Report.SymbolRelatedToPreviousError (PartialContainer.Location, "");
 					Report.Error (264, Location, "Partial declarations of `{0}' must have the same type parameter names in the same order",
 						GetSignatureForError ());
 					break;
 				}
 
 				if (tc_names [i].Variance != type_params [i].Variance) {
 					Report.SymbolRelatedToPreviousError (PartialContainer.Location, "");
 					Report.Error (1067, Location, "Partial declarations of `{0}' must have the same type parameter variance modifiers",
 						GetSignatureForError ());
 					break;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="472" endline="530">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			if (InitStatement != null){
 				if (!InitStatement.Resolve (ec))
 					ok = false;
 			}
 
 			if (Test != null){
 				Test = Test.Resolve (ec);
 				if (Test == null)
 					ok = false;
 				else if (Test is Constant){
 					bool value = !((Constant) Test).IsDefaultValue;
 
 					if (value == false){
 						if (!Statement.ResolveUnreachable (ec, true))
 							return false;
 						if ((Increment != null) &&
 						    !Increment.ResolveUnreachable (ec, false))
 							return false;
 						empty = true;
 						return true;
 					} else
 						infinite = true;
 				}
 			} else
 				infinite = true;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Loop, loc);
 			if (!infinite)
 				ec.CurrentBranching.CreateSibling ();
 
 			bool was_unreachable = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Embedded, loc);
 			if (!Statement.Resolve (ec))
 				ok = false;
 			ec.EndFlowBranching ();
 
 			if (Increment != null){
 				if (ec.CurrentBranching.CurrentUsageVector.IsUnreachable) {
 					if (!Increment.ResolveUnreachable (ec, !was_unreachable))
 						ok = false;
 				} else {
 					if (!Increment.Resolve (ec))
 						ok = false;
 				}
 			}
 
 			// There's no direct control flow from the end of the embedded statement to the end of the loop
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			ec.EndFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2532" endline="2585">
<![CDATA[
 
 		public bool Resolve (FlowBranching parent, BlockContext rc, IMethodData md)
 		{
 			if (resolved)
 				return true;
 
 			resolved = true;
 
 			if (rc.HasSet (ResolveContext.Options.ExpressionTreeConversion))
 				flags |= Flags.IsExpressionTree;
 
 			try {
 				ResolveMeta (rc);
 
 				using (rc.With (ResolveContext.Options.DoFlowAnalysis, true)) {
 					FlowBranchingToplevel top_level = rc.StartFlowBranching (this, parent);
 
 					if (!Resolve (rc))
 						return false;
 
 					unreachable = top_level.End ();
 				}
 			} catch (Exception e) {
 				if (e is CompletionResult || rc.Report.IsDisabled)
 					throw;
 
 				if (rc.CurrentBlock != null) {
 					rc.Report.Error (584, rc.CurrentBlock.StartLocation, "Internal compiler error
 				} else {
 					rc.Report.Error (587, "Internal compiler error
 				}
 
 				if (Report.DebugFlags > 0)
 					throw;
 			}
 
 			if (rc.ReturnType != TypeManager.void_type && !unreachable) {
 				if (rc.CurrentAnonymousMethod == null) {
 					// FIXME
 					if (md is IteratorMethod) {
 						unreachable = true;
 					} else {
 						rc.Report.Error (161, md.Location, "`{0}'
 						return false;
 					}
 				} else {
 					rc.Report.Error (1643, rc.CurrentAnonymousMethod.Location, "Not all code paths return a value in anonymous method of type `{0}'",
 							  rc.CurrentAnonymousMethod.GetSignatureForError ());
 					return false;
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="79" endline="88">
<![CDATA[
 
 		internal Assembly ToAssembly()
 		{
 			if (imported)
 			{
 				throw new InvalidOperationException();
 			}
 			imported = true;
 			return module.Assembly;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="726" endline="740">
<![CDATA[
 		}
 
 		public override string Name
 		{
 			get
 			{
 				if (this.IsNested)
 				{
 					return nameOrFullName;
 				}
 				else
 				{
 					return base.Name;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1466" endline="1476">
<![CDATA[
 
 		public void SetFieldAssigned (MyBitVector vector, string field_name)
 		{
 			int field_idx = TypeInfo.GetFieldIndex (field_name);
 
 			if (field_idx == 0)
 				return;
 
 			vector [Offset + field_idx] = true;
 			is_ever_assigned = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1978" endline="1989">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (type == InternalType.Null || type == TypeManager.object_type) {
 				// Optimized version, also avoids referencing literal internal type
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (this));
 				return CreateExpressionFactoryCall (ec, "Constant", args);
 			}
 
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="607" endline="617">
<![CDATA[
 
 		public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names)
 		{
 			typeFlags |= TypeFlags.IsGenericTypeDefinition;
 			gtpb = new GenericTypeParameterBuilder[names.Length];
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], this, null, i);
 			}
 			for (int i = 0; i < names.Length; i++)
 			{
 				gtpb[i] = new GenericTypeParameterBuilder(names[i], this, null, i);
 			}
 			return (GenericTypeParameterBuilder[])gtpb.Clone();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7119" endline="7147">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			TypeExpr texpr;
 
 			//
 			// Pointer types are allowed without explicit unsafe, they are just tokens
 			//
 			using (ec.Set (ResolveContext.Options.UnsafeScope)) {
 				texpr = QueriedType.ResolveAsTypeTerminal (ec, false);
 			}
 
 			if (texpr == null)
 				return null;
 
 			typearg = texpr.Type;
 
 			if (typearg == TypeManager.void_type && !(QueriedType is TypeExpression)) {
 				ec.Report.Error (673, loc, "System.Void cannot be used from C#. Use typeof (void) to get the void type object");
 			} else if (texpr is DynamicTypeExpr) {
 				ec.Report.Error (1962, QueriedType.Location,
 					"The typeof operator cannot be used on the dynamic type");
 			}
 
 			type = TypeManager.type_type;
 			QueriedType = texpr;
 
 			return DoResolveBase ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="486" endline="512">
<![CDATA[
 
 		public bool AddField (FieldBase field)
 		{
 			if (!AddMember (field))
 				return false;
 
 			if (fields == null)
 				fields = new List<FieldBase> ();
 
 			fields.Add (field);
 
 			if ((field.ModFlags & Modifiers.STATIC) != 0)
 				return true;
 
 			if (first_nonstatic_field == null) {
 				first_nonstatic_field = field;
 				return true;
 			}
 
 			if (Kind == MemberKind.Struct && first_nonstatic_field.Parent != field.Parent) {
 				Report.SymbolRelatedToPreviousError (first_nonstatic_field.Parent);
 				Report.Warning (282, 3, field.Location,
 					"struct instance field `{0}' found in different declaration from instance field `{1}'",
 					field.GetSignatureForError (), first_nonstatic_field.GetSignatureForError ());
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1568" endline="1605">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			TypeExpr target = target_type.ResolveAsTypeTerminal (ec, false);
 			if (target == null)
 				return null;
 
 			type = target.Type;
 
 			if (type.IsStatic) {
 				ec.Report.Error (716, loc, "Cannot convert to static type `{0}'", TypeManager.CSharpName (type));
 				return null;
 			}
 
 			eclass = ExprClass.Value;
 
 			Constant c = expr as Constant;
 			if (c != null) {
 				c = c.TryReduce (ec, type, loc);
 				if (c != null)
 					return c;
 			}
 
 			if (type.IsPointer && !ec.IsUnsafe) {
 				UnsafeError (ec, loc);
 			}
 
 			var res = Convert.ExplicitConversion (ec, expr, type, loc);
 			if (res == expr)
 				return EmptyCast.Create (res, type);
 
 			return res;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5344" endline="5380">
<![CDATA[
 
 		public override void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			Arguments args;
 
 			if (prepare_for_load && !(source is DynamicExpressionStatement)) {
 				args = new Arguments (0);
 				prepared = true;
 				source.Emit (ec);
 				
 				if (leave_copy) {
 					ec.Emit (OpCodes.Dup);
 					if (!IsStatic) {
 						temp = new LocalTemporary (this.Type);
 						temp.Store (ec);
 					}
 				}
 			} else {
 				args = new Arguments (1);
 
 				if (leave_copy) {
 					source.Emit (ec);
 					temp = new LocalTemporary (this.Type);
 					temp.Store (ec);
 					args.Add (new Argument (temp));
 				} else {
 					args.Add (new Argument (source));
 				}
 			}
 
 			Invocation.EmitCall (ec, InstanceExpression, Setter, args, loc, false, prepared);
 			
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="710" endline="760">
<![CDATA[
 
 		protected override Expression ResolveConversions (ResolveContext ec)
 		{
 			//
 			// LAMESPEC
 			// This allows more natual dynamic behaviour but breaks compatibility
 			// with static binding
 			//
 			if (target is RuntimeValueExpression)
 				return this;
 
 			TypeSpec target_type = target.Type;
 
 			//
 			// 1. the return type is implicitly convertible to the type of target
 			//
 			if (Convert.ImplicitConversionExists (ec, source, target_type)) {
 				source = Convert.ImplicitConversion (ec, source, target_type, loc);
 				return this;
 			}
 
 			//
 			// Otherwise, if the selected operator is a predefined operator
 			//
 			Binary b = source as Binary;
 			if (b == null && source is ReducedExpression)
 				b = ((ReducedExpression) source).OriginalExpression as Binary;
 
 			if (b != null) {
 				//
 				// 2a. the operator is a shift operator
 				//
 				// 2b. the return type is explicitly convertible to the type of x, and
 				// y is implicitly convertible to the type of x
 				//
 				if ((b.Oper & Binary.Operator.ShiftMask) != 0 ||
 					Convert.ImplicitConversionExists (ec, right, target_type)) {
 					source = Convert.ExplicitConversion (ec, source, target_type, loc);
 					return this;
 				}
 			}
 
 			if (source.Type == InternalType.Dynamic) {
 				Arguments arg = new Arguments (1);
 				arg.Add (new Argument (source));
 				return new SimpleAssign (target, new DynamicConversion (target_type, CSharpBinderFlags.ConvertExplicit, arg, loc), loc).Resolve (ec);
 			}
 
 			right.Error_ValueCannotBeConverted (ec, loc, target_type, false);
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4106" endline="4159">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return false;
 
 			if (!TypeManager.IsReferenceType (expr.Type)){
 				ec.Report.Error (185, loc,
 					"`{0}' is not a reference type as required by the lock statement",
 					expr.Type.GetSignatureForError ());
 			}
 
 			if (expr.Type.IsGenericParameter) {
 				expr = Convert.ImplicitTypeParameterConversion (expr, TypeManager.object_type);
 			}
 
 			VariableReference lv = expr as VariableReference;
 			bool locked;
 			if (lv != null) {
 				locked = lv.IsLockedByStatement;
 				lv.IsLockedByStatement = true;
 			} else {
 				lv = null;
 				locked = false;
 			}
 
 			ec.StartFlowBranching (this);
 			Statement.Resolve (ec);
 			ec.EndFlowBranching ();
 
 			if (lv != null) {
 				lv.IsLockedByStatement = locked;
 			}
 
 			base.Resolve (ec);
 
 			//
 			// Have to keep original lock value around to unlock same location
 			// in the case the original has changed or is null
 			//
 			expr_copy = TemporaryVariableReference.Create (TypeManager.object_type, ec.CurrentBlock.Parent, loc);
 			expr_copy.Resolve (ec);
 
 			//
 			// Ensure Monitor methods are available
 			//
 			if (ResolvePredefinedMethods (ec) > 1) {
 				lock_taken = TemporaryVariableReference.Create (TypeManager.bool_type, ec.CurrentBlock.Parent, loc);
 				lock_taken.Resolve (ec);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3772" endline="3826">
<![CDATA[
 
 		void DoEmitStringSwitch (LocalTemporary value, EmitContext ec)
 		{
 			Label l_initialized = ec.DefineLabel ();
 
 			//
 			// Skip initialization when value is null
 			//
 			value.EmitBranchable (ec, null_target, false);
 
 			//
 			// Check if string dictionary is initialized and initialize
 			//
 			switch_cache_field.EmitBranchable (ec, l_initialized, true);
 			string_dictionary.EmitStatement (ec);
 			ec.MarkLabel (l_initialized);
 
 			LocalTemporary string_switch_variable = new LocalTemporary (TypeManager.int32_type);
 
 			ResolveContext rc = new ResolveContext (ec.MemberContext);
 
 			if (TypeManager.generic_ienumerable_type != null) {
 				Arguments get_value_args = new Arguments (2);
 				get_value_args.Add (new Argument (value));
 				get_value_args.Add (new Argument (string_switch_variable, Argument.AType.Out));
 				Expression get_item = new Invocation (new MemberAccess (switch_cache_field, "TryGetValue", loc), get_value_args).Resolve (rc);
 				if (get_item == null)
 					return;
 
 				//
 				// A value was not found, go to default case
 				//
 				get_item.EmitBranchable (ec, default_target, false);
 			} else {
 				Arguments get_value_args = new Arguments (1);
 				get_value_args.Add (new Argument (value));
 
 				Expression get_item = new ElementAccess (switch_cache_field, get_value_args, loc).Resolve (rc);
 				if (get_item == null)
 					return;
 
 				LocalTemporary get_item_object = new LocalTemporary (TypeManager.object_type);
 				get_item_object.EmitAssign (ec, get_item, true, false);
 				ec.Emit (OpCodes.Brfalse, default_target);
 
 				ExpressionStatement get_item_int = (ExpressionStatement) new SimpleAssign (string_switch_variable,
 					new Cast (new TypeExpression (TypeManager.int32_type, loc), get_item_object, loc)).Resolve (rc);
 
 				get_item_int.EmitStatement (ec);
 				get_item_object.Release (ec);
 			}
 
 			TableSwitchEmit (ec, string_switch_variable);
 			string_switch_variable.Release (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1512" endline="1600">
<![CDATA[
 
 		//
 		// Emits the code
 		//
 		public override void Emit ()
 		{
 			if (Parent.PartialContainer.IsComImport) {
 				if (!IsDefault ()) {
 					Report.Error (669, Location, "`{0}'
 						Parent.GetSignatureForError ());
 				}
 
 				// Set as internal implementation and reset block data
 				// to ensure no IL is generated
 				ConstructorBuilder.SetImplementationFlags (MethodImplAttributes.InternalCall);
 				block = null;
 			}
 
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (ConstructorBuilder);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			base.Emit ();
 
 			//
 			// If we use a "this (...)" constructor initializer, then
 			// do not emit field initializers, they are initialized in the other constructor
 			//
 			bool emit_field_initializers = ((ModFlags & Modifiers.STATIC) != 0) ||
 				!(Initializer is ConstructorThisInitializer);
 
 			BlockContext bc = new BlockContext (this, block, TypeManager.void_type);
 			bc.Set (ResolveContext.Options.ConstructorScope);
 
 			if (emit_field_initializers)
 				Parent.PartialContainer.ResolveFieldInitializers (bc);
 
 			if (block != null) {
 				// If this is a non-static `struct' constructor and doesn't have any
 				// initializer, it must initialize all of the struct's fields.
 				if ((Parent.PartialContainer.Kind == MemberKind.Struct) &&
 					((ModFlags & Modifiers.STATIC) == 0) && (Initializer == null))
 					block.AddThisVariable (bc, Parent, Location);
 
 				if (block != null && (ModFlags & Modifiers.STATIC) == 0){
 					if (Parent.PartialContainer.Kind == MemberKind.Class && Initializer == null)
 						Initializer = new GeneratedBaseInitializer (Location);
 
 					if (Initializer != null) {
 						block.AddScopeStatement (new StatementExpression (Initializer));
 					}
 				}
 			}
 
 			parameters.ApplyAttributes (this, ConstructorBuilder);
 
 			SourceMethod source = SourceMethod.Create (Parent, ConstructorBuilder, block);
 
 			if (block != null) {
 				if (block.Resolve (null, bc, this)) {
 					EmitContext ec = new EmitContext (this, ConstructorBuilder.GetILGenerator (), bc.ReturnType);
 					ec.With (EmitContext.Options.ConstructorScope, true);
 
 					if (!ec.HasReturnLabel && bc.HasReturnLabel) {
 						ec.ReturnLabel = bc.ReturnLabel;
 						ec.HasReturnLabel = true;
 					}
 
 					block.Emit (ec);
 				}
 			}
 
 			if (source != null)
 				source.CloseMethod ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					ConstructorBuilder.__AddDeclarativeSecurity (de);
 #else
 					ConstructorBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 				foreach (var de in declarative_security) {
 #if STATIC
 					ConstructorBuilder.__AddDeclarativeSecurity (de);
 #else
 					ConstructorBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			block = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1299" endline="1310">
<![CDATA[
 
 		public TypeSpec[] Mutate (TypeSpec[] targs)
 		{
 			TypeSpec[] mutated = new TypeSpec[targs.Length];
 			bool changed = false;
 			for (int i = 0; i < targs.Length; ++i) {
 				mutated[i] = Mutate (targs[i]);
 				changed |= targs[i] != mutated[i];
 			}
 			for (int i = 0; i < targs.Length; ++i) {
 				mutated[i] = Mutate (targs[i]);
 				changed |= targs[i] != mutated[i];
 			}
 
 			return changed ? mutated 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="768" endline="785">
<![CDATA[
 
 		public static SourceMethod Create (DeclSpace parent, MethodBase method, Block block)
 		{
 			if (!SymbolWriter.HasSymbolWriter)
 				return null;
 			if (block == null)
 				return null;
 
 			Location start_loc = block.StartLocation;
 			if (start_loc.IsNull)
 				return null;
 
 			ICompileUnit compile_unit = start_loc.CompilationUnit;
 			if (compile_unit == null)
 				return null;
 
 			return new SourceMethod (parent, method, compile_unit);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="614" endline="638">
<![CDATA[
 
 		/// <summary>
 		///   ReturnValue creates on demand the LocalBuilder for the
 		///   return value from the function.  By default this is not
 		///   used.  This is only required when returns are found inside
 		///   Try or Catch statements.
 		///
 		///   This method is typically invoked from the Emit phase, so
 		///   we allow the creation of a return label if it was not
 		///   requested during the resolution phase.   Could be cleaned
 		///   up, but it would replicate a lot of logic in the Emit phase
 		///   of the code that uses it.
 		/// </summary>
 		public LocalBuilder TemporaryReturn ()
 		{
 			if (return_value == null){
 				return_value = DeclareLocal (return_type, false);
 				if (!HasReturnLabel){
 					ReturnLabel = DefineLabel ();
 					HasReturnLabel = true;
 				}
 			}
 
 			return return_value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1762" endline="1780">
<![CDATA[
 
 		protected override bool AddToContainer (MemberCore symbol, string name)
 		{
 			MemberCore mc = GetDefinition (name);
 
 			if (mc == null) {
 				defined_names.Add (name, symbol);
 				return true;
 			}
 
 			// A conflict between anonymous type members will be reported
 			if (symbol is TypeParameter) {
 				Report.SymbolRelatedToPreviousError (symbol);
 				return false;
 			}
 
 			// Ignore other conflicts
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="702" endline="719">
<![CDATA[
 
 		public override Type[] __ResolveOptionalParameterTypes(int metadataToken)
 		{
 			if ((metadataToken >> 24) == MemberRefTable.Index)
 			{
 				int index = (metadataToken & 0xFFFFFF) - 1;
 				int sig = MemberRef.records[index].Signature;
 				return Signature.ReadOptionalParameterTypes(this, GetBlob(sig));
 			}
 			else if ((metadataToken >> 24) == MethodDefTable.Index)
 			{
 				// for convenience, we support passing a MethodDef token as well, because in some places
 				// it makes sense to have a vararg method that is referred to by its methoddef (e.g. ldftn).
 				// Note that MethodSpec doesn't make sense, because generic methods cannot be vararg.
 				return Type.EmptyTypes;
 			}
 			throw new ArgumentOutOfRangeException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="626" endline="638">
<![CDATA[
 
 		public MethodEntry GetMethod (int index)
 		{
 			if ((index < 1) || (index > ot.MethodCount))
 				throw new ArgumentException ();
 			if (reader == null)
 				throw new InvalidOperationException ();
 
 			lock (this) {
 				read_methods ();
 				return (MethodEntry) method_list [index - 1];
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="450" endline="469">
<![CDATA[
 		List<CapturedVariable> captured_vars = new List<CapturedVariable> ();
 		List<CapturedScope> captured_scopes = new List<CapturedScope> ();
 
 		public AnonymousScopeEntry (int id)
 		{
 			this.ID = id;
 		}
 
 		internal AnonymousScopeEntry (MyBinaryReader reader)
 		{
 			ID = reader.ReadLeb128 ();
 
 			int num_captured_vars = reader.ReadLeb128 ();
 			for (int i = 0; i < num_captured_vars; i++)
 				captured_vars.Add (new CapturedVariable (reader));
 			for (int i = 0; i < num_captured_vars; i++)
 				captured_vars.Add (new CapturedVariable (reader));
 
 			int num_captured_scopes = reader.ReadLeb128 ();
 			for (int i = 0; i < num_captured_scopes; i++)
 				captured_scopes.Add (new CapturedScope (reader));
 			for (int i = 0; i < num_captured_scopes; i++)
 				captured_scopes.Add (new CapturedScope (reader));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1594" endline="1629">
<![CDATA[
 		}
 
 		#endregion
 
 		public void CreateBuilder (EmitContext ec)
 		{
 			if ((flags & Flags.Used) == 0) {
 				if (VariableInfo == null) {
 					// Missing flow analysis or wrong variable flags
 					throw new InternalErrorException ("VariableInfo is null and the variable `{0}' is not used", name);
 				}
 
 				if (VariableInfo.IsEverAssigned)
 					ec.Report.Warning (219, 3, Location, "The variable `{0}' is assigned but its value is never used", Name);
 				else
 					ec.Report.Warning (168, 3, Location, "The variable `{0}' is declared but never used", Name);
 			}
 
 			if (HoistedVariant != null)
 				return;
 
 			if (builder != null) {
 				if ((flags & Flags.CompilerGenerated) != 0)
 					return;
 
 				// To avoid Used warning duplicates
 				throw new InternalErrorException ("Already created variable `{0}'", name);
 			}
 
 			//
 			// All fixed variabled are pinned, a slot has to be alocated
 			//
 			builder = ec.DeclareLocal (Type, IsFixed);
 			if (SymbolWriter.HasSymbolWriter)
 				ec.DefineLocalVariable (name, builder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="146" endline="201">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			Report.Debug (1, "START IF BLOCK", loc);
 
 			expr = expr.Resolve (ec);
 			if (expr == null) {
 				ok = false;
 			} else {
 				//
 				// Dead code elimination
 				//
 				if (expr is Constant) {
 					bool take = !((Constant) expr).IsDefaultValue;
 
 					if (take) {
 						if (!TrueStatement.Resolve (ec))
 							return false;
 
 						if ((FalseStatement != null) &&
 							!FalseStatement.ResolveUnreachable (ec, true))
 							return false;
 						FalseStatement = null;
 					} else {
 						if (!TrueStatement.ResolveUnreachable (ec, true))
 							return false;
 						TrueStatement = null;
 
 						if ((FalseStatement != null) &&
 							!FalseStatement.Resolve (ec))
 							return false;
 					}
 
 					return true;
 				}
 			}
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Conditional, loc);
 			
 			ok &= TrueStatement.Resolve (ec);
 
 			is_true_ret = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 
 			ec.CurrentBranching.CreateSibling ();
 
 			if (FalseStatement != null)
 				ok &= FalseStatement.Resolve (ec);
 					
 			ec.EndFlowBranching ();
 
 			Report.Debug (1, "END IF BLOCK", loc);
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1265" endline="1307">
<![CDATA[
 
 		/// <summary>
 		/// Adds the member to defined_names table. It tests for duplications and enclosing name conflicts
 		/// </summary>
 		protected virtual bool AddToContainer (MemberCore symbol, string name)
 		{
 			MemberCore mc;
 			if (!defined_names.TryGetValue (name, out mc)) {
 				defined_names.Add (name, symbol);
 				return true;
 			}
 
 			if (((mc.ModFlags | symbol.ModFlags) & Modifiers.COMPILER_GENERATED) != 0)
 				return true;
 
 			if (symbol.EnableOverloadChecks (mc))
 				return true;
 
 			InterfaceMemberBase im = mc as InterfaceMemberBase;
 			if (im != null && im.IsExplicitImpl)
 				return true;
 
 			Report.SymbolRelatedToPreviousError (mc);
 			if ((mc.ModFlags & Modifiers.PARTIAL) != 0 && (symbol is ClassOrStruct || symbol is Interface)) {
 				Error_MissingPartialModifier (symbol);
 				return false;
 			}
 
 			if (this is ModuleContainer) {
 				Report.Error (101, symbol.Location, 
 					"The namespace `{0}' already contains a definition for `{1}'",
 					((DeclSpace)symbol).NamespaceEntry.GetSignatureForError (), symbol.MemberName.Name);
 			} else if (symbol is TypeParameter) {
 				Report.Error (692, symbol.Location,
 					"Duplicate type parameter `{0}'", symbol.GetSignatureForError ());
 			} else {
 				Report.Error (102, symbol.Location,
 					      "The type `{0}' already contains a definition for `{1}'",
 					      GetSignatureForError (), symbol.MemberName.Name);
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\VersionInfo.cs" startline="53" endline="94">
<![CDATA[
 
 		internal void SetAttribute(CustomAttributeBuilder cab)
 		{
 			Universe u = cab.Constructor.Module.universe;
 			Type type = cab.Constructor.DeclaringType;
 			if (copyright == null && type == u.System_Reflection_AssemblyCopyrightAttribute)
 			{
 				copyright = (string)cab.GetConstructorArgument(0);
 			}
 			else if (trademark == null && type == u.System_Reflection_AssemblyTrademarkAttribute)
 			{
 				trademark = (string)cab.GetConstructorArgument(0);
 			}
 			else if (product == null && type == u.System_Reflection_AssemblyProductAttribute)
 			{
 				product = (string)cab.GetConstructorArgument(0);
 			}
 			else if (company == null && type == u.System_Reflection_AssemblyCompanyAttribute)
 			{
 				company = (string)cab.GetConstructorArgument(0);
 			}
 			else if (description == null && type == u.System_Reflection_AssemblyDescriptionAttribute)
 			{
 				description = (string)cab.GetConstructorArgument(0);
 			}
 			else if (title == null && type == u.System_Reflection_AssemblyTitleAttribute)
 			{
 				title = (string)cab.GetConstructorArgument(0);
 			}
 			else if (informationalVersion == null && type == u.System_Reflection_AssemblyInformationalVersionAttribute)
 			{
 				informationalVersion = (string)cab.GetConstructorArgument(0);
 			}
 			else if (culture == null && type == u.System_Reflection_AssemblyCultureAttribute)
 			{
 				culture  = (string)cab.GetConstructorArgument(0);
 			}
 			else if (fileVersion == null && type == u.System_Reflection_AssemblyFileVersionAttribute)
 			{
 				fileVersion = (string)cab.GetConstructorArgument(0);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="355" endline="408">
<![CDATA[
 
 		protected TypeContainer AddPartial (TypeContainer next_part, string name)
 		{
 			next_part.ModFlags |= Modifiers.PARTIAL;
 			TypeContainer tc = GetDefinition (name) as TypeContainer;
 			if (tc == null)
 				return AddTypeContainer (next_part);
 
 			if ((tc.ModFlags & Modifiers.PARTIAL) == 0) {
 				Report.SymbolRelatedToPreviousError (next_part);
 				Error_MissingPartialModifier (tc);
 			}
 
 			if (tc.Kind != next_part.Kind) {
 				Report.SymbolRelatedToPreviousError (tc);
 				Report.Error (261, next_part.Location,
 					"Partial declarations of `{0}' must be all classes, all structs or all interfaces",
 					next_part.GetSignatureForError ());
 			}
 
 			if ((tc.ModFlags & Modifiers.AccessibilityMask) != (next_part.ModFlags & Modifiers.AccessibilityMask) &&
 				((tc.ModFlags & Modifiers.DEFAULT_ACCESS_MODIFER) == 0 &&
 				 (next_part.ModFlags & Modifiers.DEFAULT_ACCESS_MODIFER) == 0)) {
 				Report.SymbolRelatedToPreviousError (tc);
 				Report.Error (262, next_part.Location,
 					"Partial declarations of `{0}' have conflicting accessibility modifiers",
 					next_part.GetSignatureForError ());
 			}
 
 			if (tc.partial_parts == null)
 				tc.partial_parts = new List<TypeContainer> (1);
 
 			if ((next_part.ModFlags & Modifiers.DEFAULT_ACCESS_MODIFER) != 0) {
 				tc.ModFlags |= next_part.ModFlags & ~(Modifiers.DEFAULT_ACCESS_MODIFER | Modifiers.AccessibilityMask);
 			} else if ((tc.ModFlags & Modifiers.DEFAULT_ACCESS_MODIFER) != 0) {
 				tc.ModFlags &= ~(Modifiers.DEFAULT_ACCESS_MODIFER | Modifiers.AccessibilityMask);
 				tc.ModFlags |= next_part.ModFlags;
 			} else {
 				tc.ModFlags |= next_part.ModFlags;
 			}
 
 			tc.spec.Modifiers = tc.ModFlags;
 
 			if (next_part.attributes != null) {
 				if (tc.attributes == null)
 					tc.attributes = next_part.attributes;
 				else
 					tc.attributes.AddAttributes (next_part.attributes.Attrs);
 			}
 
 			next_part.PartialContainer = tc;
 			tc.partial_parts.Add (next_part);
 			return tc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3611" endline="3709">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			Expr = Expr.Resolve (ec);
 			if (Expr == null)
 				return false;
 
 			new_expr = SwitchGoverningType (ec, Expr);
 
 			if ((new_expr == null) && TypeManager.IsNullableType (Expr.Type)) {
 				unwrap = Nullable.Unwrap.Create (Expr, false);
 				if (unwrap == null)
 					return false;
 
 				new_expr = SwitchGoverningType (ec, unwrap);
 			}
 
 			if (new_expr == null){
 				ec.Report.Error (151, loc,
 					"A switch expression of type `{0}' cannot be converted to an integral type, bool, char, string, enum or nullable type",
 					TypeManager.CSharpName (Expr.Type));
 				return false;
 			}
 
 			// Validate switch.
 			SwitchType = new_expr.Type;
 
 			if (RootContext.Version == LanguageVersion.ISO_1 && SwitchType == TypeManager.bool_type) {
 				ec.Report.FeatureIsNotAvailable (loc, "switch expression of boolean type");
 				return false;
 			}
 
 			if (!CheckSwitch (ec))
 				return false;
 
 			if (HaveUnwrap)
 				Elements.Remove (SwitchLabel.NullStringCase);
 
 			Switch old_switch = ec.Switch;
 			ec.Switch = this;
 			ec.Switch.SwitchType = SwitchType;
 
 			Report.Debug (1, "START OF SWITCH BLOCK", loc, ec.CurrentBranching);
 			ec.StartFlowBranching (FlowBranching.BranchingType.Switch, loc);
 
 			var constant = new_expr as Constant;
 			if (constant != null) {
 				is_constant = true;
 				object key = constant.GetValue ();
 				SwitchLabel label;
 				if (Elements.TryGetValue (key, out label))
 					constant_section = FindSection (label);
 
 				if (constant_section == null)
 					constant_section = default_section;
 			}
 
 			bool first = true;
 			bool ok = true;
 			foreach (SwitchSection ss in Sections){
 				if (!first)
 					ec.CurrentBranching.CreateSibling (
 						null, FlowBranching.SiblingType.SwitchSection);
 				else
 					first = false;
 
 				if (is_constant && (ss != constant_section)) {
 					// If we're a constant switch, we're only emitting
 					// one single section - mark all the others as
 					// unreachable.
 					ec.CurrentBranching.CurrentUsageVector.Goto ();
 					if (!ss.Block.ResolveUnreachable (ec, true)) {
 						ok = false;
 					}
 				} else {
 					if (!ss.Block.Resolve (ec))
 						ok = false;
 				}
 			}
 			foreach (SwitchSection ss in Sections){
 				if (!first)
 					ec.CurrentBranching.CreateSibling (
 						null, FlowBranching.SiblingType.SwitchSection);
 				else
 					first = false;
 
 				if (is_constant && (ss != constant_section)) {
 					// If we're a constant switch, we're only emitting
 					// one single section - mark all the others as
 					// unreachable.
 					ec.CurrentBranching.CurrentUsageVector.Goto ();
 					if (!ss.Block.ResolveUnreachable (ec, true)) {
 						ok = false;
 					}
 				} else {
 					if (!ss.Block.Resolve (ec))
 						ok = false;
 				}
 			}
 
 			if (default_section == null)
 				ec.CurrentBranching.CreateSibling (
 					null, FlowBranching.SiblingType.SwitchSection);
 
 			ec.EndFlowBranching ();
 			ec.Switch = old_switch;
 
 			Report.Debug (1, "END OF SWITCH BLOCK", loc, ec.CurrentBranching);
 
 			if (!ok)
 				return false;
 
 			if (SwitchType == TypeManager.string_type && !is_constant) {
 				// TODO
 				ResolveStringSwitchMap (ec);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5352" endline="5464">
<![CDATA[
 		
 		// `dup_args' leaves an extra copy of the arguments on the stack
 		// `omit_args' does not leave any arguments at all.
 		// So, basically, you could make one call with `dup_args' set to true,
 		// and then another with `omit_args' set to true, and the two calls
 		// would have the same set of arguments. However, each argument would
 		// only have been evaluated once.
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc,
 		                             bool dup_args, bool omit_args)
 		{
 			LocalTemporary this_arg = null;
 
 			// Speed up the check by not doing it on not allowed targets
 			if (method.ReturnType == TypeManager.void_type && method.IsConditionallyExcluded (loc))
 				return;
 
 			OpCode call_op;
 			TypeSpec iexpr_type;
 
 			if (method.IsStatic) {
 				iexpr_type = null;
 				call_op = OpCodes.Call;
 			} else {
 				iexpr_type = instance_expr.Type;
 
 				if (IsVirtualCallRequired (instance_expr, method)) {
 					call_op = OpCodes.Callvirt;
 				} else {
 					call_op = OpCodes.Call;
 				}
 
 				//
 				// If this is ourselves, push "this"
 				//
 				if (!omit_args) {
 					TypeSpec t = iexpr_type;
 
 					//
 					// Push the instance expression
 					//
 					if ((iexpr_type.IsStruct && (call_op == OpCodes.Callvirt || (call_op == OpCodes.Call && method.DeclaringType == iexpr_type))) ||
 						iexpr_type.IsGenericParameter || TypeManager.IsNullableType (method.DeclaringType)) {
 						//
 						// If the expression implements IMemoryLocation, then
 						// we can optimize and use AddressOf on the
 						// return.
 						//
 						// If not we have to use some temporary storage for
 						// it.
 						var iml = instance_expr as IMemoryLocation;
 						if (iml != null) {
 							iml.AddressOf (ec, AddressOp.LoadStore);
 						} else {
 							LocalTemporary temp = new LocalTemporary (iexpr_type);
 							instance_expr.Emit (ec);
 							temp.Store (ec);
 							temp.AddressOf (ec, AddressOp.Load);
 						}
 
 						// avoid the overhead of doing this all the time.
 						if (dup_args)
 							t = ReferenceContainer.MakeType (iexpr_type);
 					} else if (iexpr_type.IsEnum || iexpr_type.IsStruct) {
 						instance_expr.Emit (ec);
 						ec.Emit (OpCodes.Box, iexpr_type);
 						t = iexpr_type = TypeManager.object_type;
 					} else {
 						instance_expr.Emit (ec);
 					}
 
 					if (dup_args) {
 						ec.Emit (OpCodes.Dup);
 						if (Arguments != null && Arguments.Count != 0) {
 							this_arg = new LocalTemporary (t);
 							this_arg.Store (ec);
 						}
 					}
 				}
 			}
 
 			if (!omit_args && Arguments != null) {
 				var dup_arg_exprs = Arguments.Emit (ec, dup_args);
 				if (dup_args) {
 					this_arg.Emit (ec);
 					LocalTemporary lt;
 					foreach (var dup in dup_arg_exprs) {
 						dup.Emit (ec);
 						lt = dup as LocalTemporary;
 						if (lt != null)
 							lt.Release (ec);
 					}
 					foreach (var dup in dup_arg_exprs) {
 						dup.Emit (ec);
 						lt = dup as LocalTemporary;
 						if (lt != null)
 							lt.Release (ec);
 					}
 				}
 			}
 
 			if (call_op == OpCodes.Callvirt && (iexpr_type.IsGenericParameter || iexpr_type.IsStruct)) {
 				ec.Emit (OpCodes.Constrained, iexpr_type);
 			}
 
 			if (method.Parameters.HasArglist) {
 				var varargs_types = GetVarargsTypes (method, Arguments);
 				ec.Emit (call_op, method, varargs_types);
 				return;
 			}
 
 			//
 			// If you have
 			// this.DoFoo ();
 			// and DoFoo is not virtual, you can omit the callvirt,
 			// because you don't need the null checking behavior.
 			//
 			ec.Emit (call_op, method);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="490" endline="540">
<![CDATA[
 
 		public void Emit(OpCode opc, Label label)
 		{
 			// We need special stackHeight handling for unconditional branches,
 			// because the branch and next flows have differing stack heights.
 			// Note that this assumes that unconditional branches do not push/pop.
 			int flowStackHeight = this.stackHeight;
 			Emit(opc);
 			if (opc == OpCodes.Leave || opc == OpCodes.Leave_S)
 			{
 				flowStackHeight = 0;
 			}
 			else if (opc.FlowControl != FlowControl.Branch)
 			{
 				flowStackHeight = this.stackHeight;
 			}
 			// if the label has already been marked, we can emit the branch offset directly
 			if (labels[label.Index] != -1)
 			{
 				if (labelStackHeight[label.Index] != flowStackHeight && (labelStackHeight[label.Index] != 0 || flowStackHeight != -1))
 				{
 					// the "backward branch constraint" prohibits this, so we don't need to support it
 					throw new NotSupportedException("'Backward branch constraints' violated");
 				}
 				if (opc.OperandType == OperandType.ShortInlineBrTarget)
 				{
 					WriteByteBranchOffset(labels[label.Index] - (code.Position + 1));
 				}
 				else
 				{
 					code.Write(labels[label.Index] - (code.Position + 4));
 				}
 			}
 			else
 			{
 				Debug.Assert(labelStackHeight[label.Index] == -1 || labelStackHeight[label.Index] == flowStackHeight || (flowStackHeight == -1 && labelStackHeight[label.Index] == 0));
 				labelStackHeight[label.Index] = flowStackHeight;
 				LabelFixup fix = new LabelFixup();
 				fix.label = label.Index;
 				fix.offset = code.Position;
 				labelFixups.Add(fix);
 				if (opc.OperandType == OperandType.ShortInlineBrTarget)
 				{
 					code.Write((byte)1);
 				}
 				else
 				{
 					code.Write(4);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="210" endline="304">
<![CDATA[
 
 		public TypeExpr LookupType (CompilerContext ctx, string name, int arity, bool silent, Location loc)
 		{
 			if (types == null)
 				return null;
 
 			TypeExpr te;
 			if (arity == 0 && cached_types.TryGetValue (name, out te))
 				return te;
 
 			IList<TypeSpec> found;
 			if (!types.TryGetValue (name, out found))
 				return null;
 
 			TypeSpec best = null;
 			foreach (var ts in found) {
 				if (ts.Arity == arity) {
 					if (best == null) {
 						best = ts;
 						continue;
 					}
 
 					var pts = best as BuildinTypeSpec;
 					if (pts == null)
 						pts = ts as BuildinTypeSpec;
 
 					if (pts != null) {
 						ctx.Report.SymbolRelatedToPreviousError (best);
 						ctx.Report.SymbolRelatedToPreviousError (ts);
 
 						// TODO
 						ctx.Report.Warning (1685, 1, loc,
 							"The predefined type `{0}.{1}' is redefined in the source code. Ignoring the local type definition",
 							pts.Namespace, pts.Name);
 						best = pts;
 						continue;
 					}
 
 					if (best.MemberDefinition.IsImported && ts.MemberDefinition.IsImported) {
 						ctx.Report.SymbolRelatedToPreviousError (best);
 						ctx.Report.SymbolRelatedToPreviousError (ts);
 						if (silent) {
 							ctx.Report.Warning (1685, 1, loc,
 								"The predefined type `{0}' is defined in multiple assemblies. Using definition from `{1}'",
 								ts.GetSignatureForError (), best.MemberDefinition.DeclaringAssembly.Name);
 						} else {
 							ctx.Report.Error (433, loc, "The imported type `{0}' is defined multiple times", ts.GetSignatureForError ());
 						}
 
 						break;
 					}
 
 					if (best.MemberDefinition.IsImported)
 						best = ts;
 
 					if ((best.Modifiers & Modifiers.INTERNAL) != 0 && !best.MemberDefinition.IsInternalAsPublic (RootContext.ToplevelTypes.DeclaringAssembly))
 						continue;
 
 					if (silent)
 						continue;
 
 					if (ts.MemberDefinition.IsImported)
 						ctx.Report.SymbolRelatedToPreviousError (ts);
 
 					ctx.Report.Warning (436, 2, loc,
 						"The type `{0}' conflicts with the imported type of same name'. Ignoring the imported type definition",
 						best.GetSignatureForError ());
 				}
 
 				//
 				// Lookup for the best candidate with closest arity match
 				//
 				if (arity < 0) {
 					if (best == null) {
 						best = ts;
 					} else if (System.Math.Abs (ts.Arity + arity) < System.Math.Abs (best.Arity + arity)) {
 						best = ts;
 					}
 				}
 			}
 			foreach (var ts in found) {
 				if (ts.Arity == arity) {
 					if (best == null) {
 						best = ts;
 						continue;
 					}
 
 					var pts = best as BuildinTypeSpec;
 					if (pts == null)
 						pts = ts as BuildinTypeSpec;
 
 					if (pts != null) {
 						ctx.Report.SymbolRelatedToPreviousError (best);
 						ctx.Report.SymbolRelatedToPreviousError (ts);
 
 						// TODO
 						ctx.Report.Warning (1685, 1, loc,
 							"The predefined type `{0}.{1}' is redefined in the source code. Ignoring the local type definition",
 							pts.Namespace, pts.Name);
 						best = pts;
 						continue;
 					}
 
 					if (best.MemberDefinition.IsImported && ts.MemberDefinition.IsImported) {
 						ctx.Report.SymbolRelatedToPreviousError (best);
 						ctx.Report.SymbolRelatedToPreviousError (ts);
 						if (silent) {
 							ctx.Report.Warning (1685, 1, loc,
 								"The predefined type `{0}' is defined in multiple assemblies. Using definition from `{1}'",
 								ts.GetSignatureForError (), best.MemberDefinition.DeclaringAssembly.Name);
 						} else {
 							ctx.Report.Error (433, loc, "The imported type `{0}' is defined multiple times", ts.GetSignatureForError ());
 						}
 
 						break;
 					}
 
 					if (best.MemberDefinition.IsImported)
 						best = ts;
 
 					if ((best.Modifiers & Modifiers.INTERNAL) != 0 && !best.MemberDefinition.IsInternalAsPublic (RootContext.ToplevelTypes.DeclaringAssembly))
 						continue;
 
 					if (silent)
 						continue;
 
 					if (ts.MemberDefinition.IsImported)
 						ctx.Report.SymbolRelatedToPreviousError (ts);
 
 					ctx.Report.Warning (436, 2, loc,
 						"The type `{0}' conflicts with the imported type of same name'. Ignoring the imported type definition",
 						best.GetSignatureForError ());
 				}
 
 				//
 				// Lookup for the best candidate with closest arity match
 				//
 				if (arity < 0) {
 					if (best == null) {
 						best = ts;
 					} else if (System.Math.Abs (ts.Arity + arity) < System.Math.Abs (best.Arity + arity)) {
 						best = ts;
 					}
 				}
 			}
 
 			if (best == null)
 				return null;
 
 			if ((best.Modifiers & Modifiers.INTERNAL) != 0 && !best.MemberDefinition.IsInternalAsPublic (RootContext.ToplevelTypes.DeclaringAssembly))
 				return null;
 
 			te = new TypeExpression (best, Location.Null);
 
 			// TODO MemberCache
 			if (arity == 0 && !silent)
 				cached_types.Add (name, te);
 
 			return te;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="264" endline="335">
<![CDATA[
 
 		public ArrayInitializer CreateDynamicBinderArguments (ResolveContext rc)
 		{
 			Location loc = Location.Null;
 			var all = new ArrayInitializer (args.Count, loc);
 
 			MemberAccess binder = DynamicExpressionStatement.GetBinderNamespace (loc);
 
 			foreach (Argument a in args) {
 				Arguments dargs = new Arguments (2);
 
 				// CSharpArgumentInfoFlags.None = 0
 				const string info_flags_enum = "CSharpArgumentInfoFlags";
 				Expression info_flags = new IntLiteral (0, loc);
 
 				if (a.Expr is Constant) {
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "Constant", loc), loc);
 				} else if (a.ArgType == Argument.AType.Ref) {
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "IsRef", loc), loc);
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "UseCompileTimeType", loc), loc);
 				} else if (a.ArgType == Argument.AType.Out) {
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "IsOut", loc), loc);
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "UseCompileTimeType", loc), loc);
 				} else if (a.ArgType == Argument.AType.DynamicTypeName) {
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "IsStaticType", loc), loc);
 				}
 
 				var arg_type = a.Expr.Type;
 
 				if (arg_type != InternalType.Dynamic && arg_type != InternalType.Null) {
 					MethodGroupExpr mg = a.Expr as MethodGroupExpr;
 					if (mg != null) {
 						rc.Report.Error (1976, a.Expr.Location,
 							"The method group `{0}' cannot be used as an argument of dynamic operation. Consider using parentheses to invoke the method",
 							mg.Name);
 					} else if (arg_type == InternalType.AnonymousMethod) {
 						rc.Report.Error (1977, a.Expr.Location,
 							"An anonymous method or lambda expression cannot be used as an argument of dynamic operation. Consider using a cast");
 					} else if (arg_type == TypeManager.void_type || arg_type == InternalType.Arglist || arg_type.IsPointer) {
 						rc.Report.Error (1978, a.Expr.Location,
 							"An expression of type `{0}' cannot be used as an argument of dynamic operation",
 							TypeManager.CSharpName (arg_type));
 					}
 
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "UseCompileTimeType", loc), loc);
 				}
 
 				string named_value;
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "NamedArgument", loc), loc);
 
 					named_value = na.Name;
 				} else {
 					named_value = null;
 				}
 
 				dargs.Add (new Argument (info_flags));
 				dargs.Add (new Argument (new StringLiteral (named_value, loc)));
 				all.Add (new Invocation (new MemberAccess (new MemberAccess (binder, "CSharpArgumentInfo", loc), "Create", loc), dargs));
 			}
 			foreach (Argument a in args) {
 				Arguments dargs = new Arguments (2);
 
 				// CSharpArgumentInfoFlags.None = 0
 				const string info_flags_enum = "CSharpArgumentInfoFlags";
 				Expression info_flags = new IntLiteral (0, loc);
 
 				if (a.Expr is Constant) {
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "Constant", loc), loc);
 				} else if (a.ArgType == Argument.AType.Ref) {
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "IsRef", loc), loc);
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "UseCompileTimeType", loc), loc);
 				} else if (a.ArgType == Argument.AType.Out) {
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "IsOut", loc), loc);
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "UseCompileTimeType", loc), loc);
 				} else if (a.ArgType == Argument.AType.DynamicTypeName) {
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "IsStaticType", loc), loc);
 				}
 
 				var arg_type = a.Expr.Type;
 
 				if (arg_type != InternalType.Dynamic && arg_type != InternalType.Null) {
 					MethodGroupExpr mg = a.Expr as MethodGroupExpr;
 					if (mg != null) {
 						rc.Report.Error (1976, a.Expr.Location,
 							"The method group `{0}' cannot be used as an argument of dynamic operation. Consider using parentheses to invoke the method",
 							mg.Name);
 					} else if (arg_type == InternalType.AnonymousMethod) {
 						rc.Report.Error (1977, a.Expr.Location,
 							"An anonymous method or lambda expression cannot be used as an argument of dynamic operation. Consider using a cast");
 					} else if (arg_type == TypeManager.void_type || arg_type == InternalType.Arglist || arg_type.IsPointer) {
 						rc.Report.Error (1978, a.Expr.Location,
 							"An expression of type `{0}' cannot be used as an argument of dynamic operation",
 							TypeManager.CSharpName (arg_type));
 					}
 
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "UseCompileTimeType", loc), loc);
 				}
 
 				string named_value;
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					info_flags = new Binary (Binary.Operator.BitwiseOr, info_flags,
 						new MemberAccess (new MemberAccess (binder, info_flags_enum, loc), "NamedArgument", loc), loc);
 
 					named_value = na.Name;
 				} else {
 					named_value = null;
 				}
 
 				dargs.Add (new Argument (info_flags));
 				dargs.Add (new Argument (new StringLiteral (named_value, loc)));
 				all.Add (new Invocation (new MemberAccess (new MemberAccess (binder, "CSharpArgumentInfo", loc), "Create", loc), dargs));
 			}
 
 			return all;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="1178" endline="1188">
<![CDATA[
 
 		public ParametersCompiled Clone ()
 		{
 			ParametersCompiled p = (ParametersCompiled) MemberwiseClone ();
 
 			p.parameters = new IParameterData [parameters.Length];
 			for (int i = 0; i < Count; ++i)
 				p.parameters [i] = this [i].Clone ();
 			for (int i = 0; i < Count; ++i)
 				p.parameters [i] = this [i].Clone ();
 
 			return p;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="274" endline="286">
<![CDATA[
 
 		TypeParameterSpec[] CreateGenericParameters (int first, MetaType[] tparams)
 		{
 			var tspec = new TypeParameterSpec[tparams.Length - first];
 			for (int pos = first; pos < tparams.Length; ++pos) {
 				var type = tparams[pos];
 				int index = pos - first;
 
 				tspec [index] = (TypeParameterSpec) CreateType (type, new DynamicTypeReader (), false);
 			}
 			for (int pos = first; pos < tparams.Length; ++pos) {
 				var type = tparams[pos];
 				int index = pos - first;
 
 				tspec [index] = (TypeParameterSpec) CreateType (type, new DynamicTypeReader (), false);
 			}
 
 			return tspec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="480" endline="501">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			unwrap = Unwrap.Create (Expr, false);
 			if (unwrap == null)
 				return null;
 
 			Expression res = base.ResolveOperator (ec, unwrap);
 			if (res != this) {
 				if (user_operator == null)
 					return res;
 			} else {
 				res = Expr = LiftExpression (ec, Expr);
 			}
 
 			if (res == null)
 				return null;
 
 			eclass = ExprClass.Value;
 			type = res.Type;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1667" endline="1682">
<![CDATA[
 		}
 
 		void CheckMemberUsage (List<MemberCore> al, string member_type)
 		{
 			if (al == null)
 				return;
 
 			foreach (MemberCore mc in al) {
 				if ((mc.ModFlags & Modifiers.AccessibilityMask) != Modifiers.PRIVATE)
 					continue;
 
 				if (!mc.IsUsed && (mc.caching_flags & Flags.Excluded) == 0) {
 					Report.Warning (169, 3, mc.Location, "The private {0} `{1}' is never used", member_type, mc.GetSignatureForError ());
 				}
 			}
 			foreach (MemberCore mc in al) {
 				if ((mc.ModFlags & Modifiers.AccessibilityMask) != Modifiers.PRIVATE)
 					continue;
 
 				if (!mc.IsUsed && (mc.caching_flags & Flags.Excluded) == 0) {
 					Report.Warning (169, 3, mc.Location, "The private {0} `{1}' is never used", member_type, mc.GetSignatureForError ());
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="385" endline="421">
<![CDATA[
 
 		public static MemberSpec FindMember (TypeSpec container, MemberFilter filter, BindingRestriction restrictions)
 		{
 			do {
 				IList<MemberSpec> applicable;
 				if (container.MemberCache.member_hash.TryGetValue (filter.Name, out applicable)) {
 					// Start from the end because interface members are in reverse order
 					for (int i = applicable.Count - 1; i >= 0; i--) {
 						var entry = applicable [i];
 
 						if ((restrictions & BindingRestriction.InstanceOnly) != 0 && entry.IsStatic)
 							continue;
 
 						if ((restrictions & BindingRestriction.NoAccessors) != 0 && entry.IsAccessor)
 							continue;
 
 						if ((restrictions & BindingRestriction.OverrideOnly) != 0 && (entry.Modifiers & Modifiers.OVERRIDE) == 0)
 							continue;
 
 						if (!filter.Equals (entry))
 							continue;
 
 						if ((restrictions & BindingRestriction.DeclaredOnly) != 0 && container.IsInterface && entry.DeclaringType != container)
 							continue;
 
 						return entry;
 					for (int i = applicable.Count - 1; i >= 0; i--) {
 						var entry = applicable [i];
 
 						if ((restrictions & BindingRestriction.InstanceOnly) != 0 && entry.IsStatic)
 							continue;
 
 						if ((restrictions & BindingRestriction.NoAccessors) != 0 && entry.IsAccessor)
 							continue;
 
 						if ((restrictions & BindingRestriction.OverrideOnly) != 0 && (entry.Modifiers & Modifiers.OVERRIDE) == 0)
 							continue;
 
 						if (!filter.Equals (entry))
 							continue;
 
 						if ((restrictions & BindingRestriction.DeclaredOnly) != 0 && container.IsInterface && entry.DeclaringType != container)
 							continue;
 
 						return entry;
 					}
 				}
 
 				if ((restrictions & BindingRestriction.DeclaredOnly) != 0)
 					break;
 
 				container = container.BaseType;
 			} while (container != null);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="343" endline="445">
<![CDATA[
 
 		bool ParseArguments (string[] args, bool require_files, Func<string [], int, int> unknown_option_parser)
 		{
 			List<string> response_file_list = null;
 			bool parsing_options = true;
 
 			for (int i = 0; i < args.Length; i++) {
 				string arg = args [i];
 				if (arg.Length == 0)
 					continue;
 
 				if (arg [0] == '@') {
 					string [] extra_args;
 					string response_file = arg.Substring (1);
 
 					if (response_file_list == null)
 						response_file_list = new List<string> ();
 
 					if (response_file_list.Contains (response_file)) {
 						Report.Error (
 							1515, "Response file `" + response_file +
 							"' specified multiple times");
 						return false;
 					}
 
 					response_file_list.Add (response_file);
 
 					extra_args = LoadArgs (response_file);
 					if (extra_args == null) {
 						Report.Error (2011, "Unable to open response file
 								  response_file);
 						return false;
 					}
 
 					args = AddArgs (args, extra_args);
 					continue;
 				}
 
 				if (parsing_options) {
 					if (arg == "--") {
 						parsing_options = false;
 						continue;
 					}
 
 					if (arg [0] == '-') {
 						if (UnixParseOption (arg, ref args, ref i))
 							continue;
 
 						// Try a -CSCOPTION
 						string csc_opt = "/" + arg.Substring (1);
 						if (CSCParseOption (csc_opt, ref args))
 							continue;
 
 						if (unknown_option_parser != null){
 							var ret = unknown_option_parser (args, i);
 							if (ret != -1){
 								i = ret;
 								return true;
 							}
 						}
 						
 						Error_WrongOption (arg);
 						return false;
 					}
 					if (arg [0] == '/') {
 						if (CSCParseOption (arg, ref args))
 							continue;
 
 						// Need to skip `/home/test.cs' however /test.cs is considered as error
 						if (arg.Length < 2 || arg.IndexOf ('/', 2) == -1) {
 							Error_WrongOption (arg);
 							return false;
 						}
 					}
 				}
 
 				ProcessSourceFiles (arg, false);
 			}
 			for (int i = 0; i < args.Length; i++) {
 				string arg = args [i];
 				if (arg.Length == 0)
 					continue;
 
 				if (arg [0] == '@') {
 					string [] extra_args;
 					string response_file = arg.Substring (1);
 
 					if (response_file_list == null)
 						response_file_list = new List<string> ();
 
 					if (response_file_list.Contains (response_file)) {
 						Report.Error (
 							1515, "Response file `" + response_file +
 							"' specified multiple times");
 						return false;
 					}
 
 					response_file_list.Add (response_file);
 
 					extra_args = LoadArgs (response_file);
 					if (extra_args == null) {
 						Report.Error (2011, "Unable to open response file
 								  response_file);
 						return false;
 					}
 
 					args = AddArgs (args, extra_args);
 					continue;
 				}
 
 				if (parsing_options) {
 					if (arg == "--") {
 						parsing_options = false;
 						continue;
 					}
 
 					if (arg [0] == '-') {
 						if (UnixParseOption (arg, ref args, ref i))
 							continue;
 
 						// Try a -CSCOPTION
 						string csc_opt = "/" + arg.Substring (1);
 						if (CSCParseOption (csc_opt, ref args))
 							continue;
 
 						if (unknown_option_parser != null){
 							var ret = unknown_option_parser (args, i);
 							if (ret != -1){
 								i = ret;
 								return true;
 							}
 						}
 						
 						Error_WrongOption (arg);
 						return false;
 					}
 					if (arg [0] == '/') {
 						if (CSCParseOption (arg, ref args))
 							continue;
 
 						// Need to skip `/home/test.cs' however /test.cs is considered as error
 						if (arg.Length < 2 || arg.IndexOf ('/', 2) == -1) {
 							Error_WrongOption (arg);
 							return false;
 						}
 					}
 				}
 
 				ProcessSourceFiles (arg, false);
 			}
 
 			if (require_files == false)
 				return true;
 					
 			//
 			// If we are an exe, require a source file for the entry point
 			//
 			if (RootContext.Target == Target.Exe || RootContext.Target == Target.WinExe || RootContext.Target == Target.Module) {
 				if (first_source == null) {
 					Report.Error (2008, "No files to compile were specified");
 					return false;
 				}
 
 			}
 
 			//
 			// If there is nothing to put in the assembly, and we are not a library
 			//
 			if (first_source == null && RootContext.Resources == null) {
 				Report.Error (2008, "No files to compile were specified");
 				return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1247" endline="1381">
<![CDATA[
 
 		static Expression ImplicitConversionStandard (ResolveContext ec, Expression expr, TypeSpec target_type, Location loc, bool explicit_cast)
 		{
 			if (expr.eclass == ExprClass.MethodGroup){
 				if (!TypeManager.IsDelegateType (target_type)){
 					return null;
 				}
 
 				//
 				// Only allow anonymous method conversions on post ISO_1
 				//
 				if (RootContext.Version != LanguageVersion.ISO_1){
 					MethodGroupExpr mg = expr as MethodGroupExpr;
 					if (mg != null)
 						return ImplicitDelegateCreation.Create (
 							ec, mg, target_type, loc);
 				}
 			}
 
 			TypeSpec expr_type = expr.Type;
 			Expression e;
 
 			if (expr_type == target_type) {
 				if (expr_type != InternalType.Null && expr_type != InternalType.AnonymousMethod)
 					return expr;
 				return null;
 			}
 
 			if (expr_type == InternalType.Dynamic) {
 				switch (target_type.Kind) {
 				case MemberKind.ArrayType
 				case MemberKind.Class
 					if (target_type == TypeManager.object_type)
 						return EmptyCast.Create (expr, target_type);
 
 					goto case MemberKind.Struct;
 				case MemberKind.Struct
 					// TODO
 					if (target_type == TypeManager.void_type)
 						return null;
 
 					goto case MemberKind.Enum;
 				case MemberKind.Delegate
 				case MemberKind.Enum
 				case MemberKind.Interface
 				case MemberKind.TypeParameter
 					Arguments args = new Arguments (1);
 					args.Add (new Argument (expr));
 					return new DynamicConversion (target_type, explicit_cast ? CSharpBinderFlags.ConvertExplicit 
 				}
 
 				return null;
 			}
 
 			if (TypeManager.IsNullableType (target_type))
 				return ImplicitNulableConversion (ec, expr, target_type);
 
 			//
 			// Attempt to do the implicit constant expression conversions
 			//
 			Constant c = expr as Constant;
 			if (c != null) {
 				try {
 					c = c.ConvertImplicitly (ec, target_type);
 				} catch {
 					Console.WriteLine ("Conversion error happened in line {0}", loc);
 					throw;
 				}
 				if (c != null)
 					return c;
 			}
 
 			e = ImplicitNumericConversion (expr, expr_type, target_type);
 			if (e != null)
 				return e;
 
 			e = ImplicitReferenceConversion (expr, target_type, explicit_cast);
 			if (e != null)
 				return e;
 
 			if (expr is IntegralConstant && TypeManager.IsEnumType (target_type)){
 				var i = (IntegralConstant) expr;
 				//
 				// LAMESPEC
 				//
 				// An implicit enumeration conversion permits the decimal-integer-literal 0
 				// to be converted to any enum-type and to any nullable-type whose underlying
 				// type is an enum-type
 				//
 				if (i.IsZeroInteger) {
 					// Recreate 0 literal to remove any collected conversions
 					return new EnumConstant (new IntLiteral (0, i.Location), target_type).Resolve (ec);
 				}
 			}
 
 			if (ec.IsUnsafe) {
 				var target_pc = target_type as PointerContainer;
 				if (target_pc != null) {
 					if (expr_type.IsPointer) {
 						//
 						// Pointer types are same when they have same element types
 						//
 						if (expr_type == target_pc)
 							return expr;
 
 						if (target_pc.Element.BuildinType == BuildinTypeSpec.Type.Void)
 							return EmptyCast.Create (expr, target_type);
 
 						//return null;
 					}
 
 					if (expr_type == InternalType.Null)
 						return EmptyCast.Create (new NullPointer (loc), target_type);
 				}
 			}
 
 			if (expr_type == InternalType.AnonymousMethod){
 				AnonymousMethodExpression ame = (AnonymousMethodExpression) expr;
 				Expression am = ame.Compatible (ec, target_type);
 				if (am != null)
 					return am.Resolve (ec);
 			}
 
 			if (expr_type == InternalType.Arglist && target_type == TypeManager.arg_iterator_type)
 				return expr;
 
 			if (TypeSpecComparer.IsEqual (expr_type, target_type)) {
 				if (expr_type == target_type)
 					return expr;
 
 				return EmptyCast.Create (expr, target_type);
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="205" endline="213">
<![CDATA[
 		}
 
 		public MemberCache MemberCache {
 			get {
 				if (cache == null || (state & StateFlags.PendingMemberCacheMembers) != 0)
 					InitializeMemberCache (false);
 
 				return cache;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1359" endline="1368">
<![CDATA[
 
 		#region Properties
 
 		public override TypeSpec BaseType {
 			get {
 				if (cache == null || (state & StateFlags.PendingBaseTypeInflate) != 0)
 					InitializeMemberCache (true);
 
 				return base.BaseType;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="113" endline="127">
<![CDATA[
 
 		public bool ResolveMethodGroup (ResolveContext ec)
 		{
 			SimpleName sn = Expr as SimpleName;
 			if (sn != null)
 				Expr = sn.GetMethodGroup ();
 
 			// FIXME
 			//        `out' in a delegate creation expression.
 			Expr = Expr.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.MethodGroup);
 			if (Expr == null)
 				return false;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1197" endline="1225">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Parent;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the HasDeclSecurity encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case MethodDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case AssemblyTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Parent = token;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Parent;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the HasDeclSecurity encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case MethodDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case AssemblyTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Parent = token;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3162" endline="3195">
<![CDATA[
 
 		protected bool DefineParameters (ParametersCompiled parameters)
 		{
 			if (!parameters.Resolve (this))
 				return false;
 
 			bool error = false;
 			for (int i = 0; i < parameters.Count; ++i) {
 				Parameter p = parameters [i];
 
 				if (p.HasDefaultValue && (IsExplicitImpl || this is Operator || (this is Indexer && parameters.Count == 1)))
 					p.Warning_UselessOptionalParameter (Report);
 
 				if (p.CheckAccessibility (this))
 					continue;
 
 				TypeSpec t = parameters.Types [i];
 				Report.SymbolRelatedToPreviousError (t);
 				if (this is Indexer)
 					Report.Error (55, Location,
 						      "Inconsistent accessibility
 						      TypeManager.CSharpName (t), GetSignatureForError ());
 				else if (this is Operator)
 					Report.Error (57, Location,
 						      "Inconsistent accessibility
 						      TypeManager.CSharpName (t), GetSignatureForError ());
 				else
 					Report.Error (51, Location,
 						"Inconsistent accessibility
 						TypeManager.CSharpName (t), GetSignatureForError ());
 				error = true;
 			}
 			for (int i = 0; i < parameters.Count; ++i) {
 				Parameter p = parameters [i];
 
 				if (p.HasDefaultValue && (IsExplicitImpl || this is Operator || (this is Indexer && parameters.Count == 1)))
 					p.Warning_UselessOptionalParameter (Report);
 
 				if (p.CheckAccessibility (this))
 					continue;
 
 				TypeSpec t = parameters.Types [i];
 				Report.SymbolRelatedToPreviousError (t);
 				if (this is Indexer)
 					Report.Error (55, Location,
 						      "Inconsistent accessibility
 						      TypeManager.CSharpName (t), GetSignatureForError ());
 				else if (this is Operator)
 					Report.Error (57, Location,
 						      "Inconsistent accessibility
 						      TypeManager.CSharpName (t), GetSignatureForError ());
 				else
 					Report.Error (51, Location,
 						"Inconsistent accessibility
 						TypeManager.CSharpName (t), GetSignatureForError ());
 				error = true;
 			}
 			return !error;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1477" endline="1486">
<![CDATA[
 
 		public VariableInfo GetSubStruct (string name)
 		{
 			TypeInfo type = TypeInfo.GetSubStruct (name);
 
 			if (type == null)
 				return null;
 
 			return new VariableInfo (this, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2494" endline="2501">
<![CDATA[
 		{
 			TypeExpr t = DoResolveAsTypeStep (ec);
 			if (t == null)
 				return null;
 
 			eclass = ExprClass.Type;
 			return t;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2020" endline="2027">
<![CDATA[
 
 		public void EmitAttribute (FieldBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2028" endline="2035">
<![CDATA[
 
 		public void EmitAttribute (ParameterBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2036" endline="2043">
<![CDATA[
 
 		public void EmitAttribute (PropertyBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="2044" endline="2051">
<![CDATA[
 
 		public void EmitAttribute (TypeBuilder builder, TypeSpec type, Location loc)
 		{
 			if (ResolveTransformationCtor (loc)) {
 				var cab = new CustomAttributeBuilder ((ConstructorInfo) tctor.GetMetaInfo (), new object[] { GetTransformationFlags (type) });
 				builder.SetCustomAttribute (cab);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="171" endline="179">
<![CDATA[
 
 		public override string ToString ()
 		{
 			return String.Format (
 				"OffsetTable [{0} - {1}
 				TotalFileSize, DataSectionOffset, DataSectionSize, SourceCount,
 				SourceTableOffset, SourceTableSize, MethodCount, MethodTableOffset,
 				MethodTableSize, TypeCount);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="732" endline="757">
<![CDATA[
 
 		internal void Fixup()
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Interface;
 				switch (token >> 24)
 				{
 					case 0
 						break;
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case TypeRefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case TypeSpecTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Interface = token;
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Interface;
 				switch (token >> 24)
 				{
 					case 0
 						break;
 					case TypeDefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case TypeRefTable.Index
 						token = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case TypeSpecTable.Index
 						token = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 				records[i].Interface = token;
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="671" endline="699">
<![CDATA[
 
 	//
 	// Whether a type is unmanaged.  This is used by the unsafe code (25.2)
 	//
 	public static bool IsUnmanagedType (TypeSpec t)
 	{
 		var ds = t.MemberDefinition as DeclSpace;
 		if (ds != null)
 			return ds.IsUnmanagedType ();
 
 		// some builtins that are not unmanaged types
 		if (t == TypeManager.object_type || t == TypeManager.string_type)
 			return false;
 
 		if (IsBuiltinOrEnum (t))
 			return true;
 
 		// Someone did the work of checking if the ElementType of t is unmanaged.  Let's not repeat it.
 		if (t.IsPointer)
 			return IsUnmanagedType (GetElementType (t));
 
 		if (!IsValueType (t))
 			return false;
 
 		if (t.IsNested && t.DeclaringType.IsGenericOrParentIsGeneric)
 			return false;
 
 		return true;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="1425" endline="1446">
<![CDATA[
 		
 		static bool IsExternAliasValid (string identifier)
 		{
 			if (identifier.Length == 0)
 				return false;
 			if (identifier [0] != '_' && !Char.IsLetter (identifier [0]))
 				return false;
 
 			for (int i = 1; i < identifier.Length; i++) {
 				char c = identifier [i];
 				if (Char.IsLetter (c) || Char.IsDigit (c))
 					continue;
 
 				UnicodeCategory category = Char.GetUnicodeCategory (c);
 				if (category != UnicodeCategory.Format || category != UnicodeCategory.NonSpacingMark ||
 						category != UnicodeCategory.SpacingCombiningMark ||
 						category != UnicodeCategory.ConnectorPunctuation)
 					return false;
 			}
 			for (int i = 1; i < identifier.Length; i++) {
 				char c = identifier [i];
 				if (Char.IsLetter (c) || Char.IsDigit (c))
 					continue;
 
 				UnicodeCategory category = Char.GetUnicodeCategory (c);
 				if (category != UnicodeCategory.Format || category != UnicodeCategory.NonSpacingMark ||
 						category != UnicodeCategory.SpacingCombiningMark ||
 						category != UnicodeCategory.ConnectorPunctuation)
 					return false;
 			}
 			
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="797" endline="847">
<![CDATA[
 	}
 
 	class ConsoleReportPrinter 
 	{
 		static readonly string prefix, postfix;
 
 		static ConsoleReportPrinter ()
 		{
 			string term = Environment.GetEnvironmentVariable ("TERM");
 			bool xterm_colors = false;
 			
 			switch (term){
 			case "xterm"
 			case "rxvt"
 			case "rxvt-unicode"
 				if (Environment.GetEnvironmentVariable ("COLORTERM") != null){
 					xterm_colors = true;
 				}
 				break;
 
 			case "xterm-color"
 				xterm_colors = true;
 				break;
 			}
 			if (!xterm_colors)
 				return;
 
 			if (!(UnixUtils.isatty (1) && UnixUtils.isatty (2)))
 				return;
 			
 			string config = Environment.GetEnvironmentVariable ("MCS_COLORS");
 			if (config == null){
 				config = "errors=red";
 				//config = "brightwhite,red";
 			}
 
 			if (config == "disable")
 				return;
 
 			if (!config.StartsWith ("errors="))
 				return;
 
 			config = config.Substring (7);
 			
 			int p = config.IndexOf (",");
 			if (p == -1)
 				prefix = GetForeground (config);
 			else
 				prefix = GetBackground (config.Substring (p+1)) + GetForeground (config.Substring (0, p));
 			postfix = "\x001b[0m";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="477" endline="533">
<![CDATA[
 
 		static public DSA FromCapiPublicKeyBlobDSA (byte[] blob, int offset)
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			try {
 				if ((blob [offset] != 0x06) ||				// PUBLICKEYBLOB (0x06)
 				    (blob [offset + 1] != 0x02) ||			// Version (0x02)
 				    (blob [offset + 2] != 0x00) ||			// Reserved (word)
 				    (blob [offset + 3] != 0x00) ||
 				    (ToUInt32LE (blob, offset + 8) != 0x31535344))	// DWORD magic
 					throw new CryptographicException ("Invalid blob header");
 
 				int bitlen = ToInt32LE (blob, offset + 12);
 				DSAParameters dsap = new DSAParameters ();
 				int bytelen = bitlen >> 3;
 				int pos = offset + 16;
 
 				dsap.P = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.P, 0, bytelen);
 				Array.Reverse (dsap.P);
 				pos += bytelen;
 
 				dsap.Q = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Q, 0, 20);
 				Array.Reverse (dsap.Q);
 				pos += 20;
 
 				dsap.G = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.G, 0, bytelen);
 				Array.Reverse (dsap.G);
 				pos += bytelen;
 
 				dsap.Y = new byte [bytelen];
 				Buffer.BlockCopy (blob, pos, dsap.Y, 0, bytelen);
 				Array.Reverse (dsap.Y);
 				pos += bytelen;
 
 				dsap.Counter = ToInt32LE (blob, pos);
 				pos += 4;
 
 				dsap.Seed = new byte [20];
 				Buffer.BlockCopy (blob, pos, dsap.Seed, 0, 20);
 				Array.Reverse (dsap.Seed);
 				pos += 20;
 
 				DSA dsa = (DSA)DSA.Create ();
 				dsa.ImportParameters (dsap);
 				return dsa;
 			}
 			catch (Exception e) {
 				throw new CryptographicException ("Invalid blob.", e);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="373" endline="432">
<![CDATA[
 		}
 
 		public MethodSpec Resolve ()
 		{
 			if (resolve_error)
 				return null;
 
 			resolve_error = true;
 			arg_resolved = true;
 
 			if (Type == null) {
 				ResolveAttributeType ();
 				if (Type == null)
 					return null;
 			}
 
 			if (Type.IsAbstract) {
 				Report.Error (653, Location, "Cannot apply attribute class `{0}' because it is abstract", GetSignatureForError ());
 				return null;
 			}
 
 			ObsoleteAttribute obsolete_attr = Type.GetAttributeObsolete ();
 			if (obsolete_attr != null) {
 				AttributeTester.Report_ObsoleteMessage (obsolete_attr, TypeManager.CSharpName (Type), Location, Report);
 			}
 
 			MethodSpec ctor;
 			// Try if the attribute is simple has been resolved before
 			if (PosArguments == null && NamedArguments == null) {
 				if (att_cache.TryGetValue (Type, out ctor)) {
 					resolve_error = false;
 					return ctor;
 				}
 			}
 
 			ResolveContext rc = CreateResolveContext ();
 			ctor = ResolveConstructor (rc);
 			if (ctor == null) {
 				return null;
 			}
 
 			//
 			// Add [module
 			//
 			var module = context.Module;
 			// HACK
 			if (module.PredefinedAttributes == null)
 				return ctor;
 
 			if (Type == module.PredefinedAttributes.DllImport && module.HasDefaultCharSet) {
 				AddModuleCharSet (rc);
 			}
 
 			if (NamedArguments != null && !ResolveNamedArguments (rc)) {
 				return null;
 			}
 
 			resolve_error = false;
 			return ctor;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2997" endline="3191">
<![CDATA[
 
 		//
 		// Enumeration operators
 		//
 		Expression ResolveOperatorEnum (ResolveContext ec, bool lenum, bool renum, TypeSpec ltype, TypeSpec rtype)
 		{
 			//
 			// bool operator == (E x, E y);
 			// bool operator != (E x, E y);
 			// bool operator < (E x, E y);
 			// bool operator > (E x, E y);
 			// bool operator <= (E x, E y);
 			// bool operator >= (E x, E y);
 			//
 			// E operator & (E x, E y);
 			// E operator | (E x, E y);
 			// E operator ^ (E x, E y);
 			//
 			// U operator - (E e, E f)
 			// E operator - (E e, U x)
 			// E operator - (U x, E e)	// LAMESPEC
 			//
 			// E operator + (E e, U x)
 			// E operator + (U x, E e)
 			//
 			Expression ltemp = left;
 			Expression rtemp = right;
 			TypeSpec underlying_type;
 			TypeSpec underlying_type_result;
 			TypeSpec res_type;
 			Expression expr;
 			
 			//
 			// LAMESPEC
 			// the one which contains more enum parameters always wins even if there
 			// is an implicit conversion involved
 			//
 			if ((oper & (Operator.ComparisonMask | Operator.BitwiseMask)) != 0) {
 				if (renum) {
 					underlying_type = EnumSpec.GetUnderlyingType (rtype);
 					expr = Convert.ImplicitConversion (ec, left, rtype, loc);
 					if (expr == null)
 						return null;
 
 					left = expr;
 					ltype = expr.Type;
 				} else if (lenum) {
 					underlying_type = EnumSpec.GetUnderlyingType (ltype);
 					expr = Convert.ImplicitConversion (ec, right, ltype, loc);
 					if (expr == null)
 						return null;
 
 					right = expr;
 					rtype = expr.Type;
 				} else {
 					return null;
 				}
 
 				if ((oper & Operator.BitwiseMask) != 0) {
 					res_type = ltype;
 					underlying_type_result = underlying_type;
 				} else {
 					res_type = null;
 					underlying_type_result = null;
 				}
 			} else if (oper == Operator.Subtraction) {
 				if (renum) {
 					underlying_type = EnumSpec.GetUnderlyingType (rtype);
 					if (ltype != rtype) {
 						expr = Convert.ImplicitConversion (ec, left, rtype, left.Location);
 						if (expr == null) {
 							expr = Convert.ImplicitConversion (ec, left, underlying_type, left.Location);
 							if (expr == null)
 								return null;
 
 							res_type = rtype;
 						} else {
 							res_type = underlying_type;
 						}
 
 						left = expr;
 					} else {
 						res_type = underlying_type;
 					}
 
 					underlying_type_result = underlying_type;
 				} else if (lenum) {
 					underlying_type = EnumSpec.GetUnderlyingType (ltype);
 					expr = Convert.ImplicitConversion (ec, right, ltype, right.Location);
 					if (expr == null || expr is EnumConstant) {
 						expr = Convert.ImplicitConversion (ec, right, underlying_type, right.Location);
 						if (expr == null)
 							return null;
 
 						res_type = ltype;
 					} else {
 						res_type = underlying_type;
 					}
 
 					right = expr;
 					underlying_type_result = underlying_type;
 				} else {
 					return null;
 				}
 			} else if (oper == Operator.Addition) {
 				if (lenum) {
 					underlying_type = EnumSpec.GetUnderlyingType (ltype);
 					res_type = ltype;
 
 					if (rtype != underlying_type && (state & (State.RightNullLifted | State.LeftNullLifted)) == 0) {
 						expr = Convert.ImplicitConversion (ec, right, underlying_type, right.Location);
 						if (expr == null)
 							return null;
 
 						right = expr;
 					}
 				} else {
 					underlying_type = EnumSpec.GetUnderlyingType (rtype);
 					res_type = rtype;
 					if (ltype != underlying_type) {
 						expr = Convert.ImplicitConversion (ec, left, underlying_type, left.Location);
 						if (expr == null)
 							return null;
 
 						left = expr;
 					}
 				}
 
 				underlying_type_result = underlying_type;
 			} else {
 				return null;
 			}
 
 			// Unwrap the constant correctly, so DoBinaryOperatorPromotion can do the magic
 			// with constants and expressions
 			if (left.Type != underlying_type) {
 				if (left is Constant)
 					left = ((Constant) left).ConvertExplicitly (false, underlying_type).Resolve (ec);
 				else
 					left = EmptyCast.Create (left, underlying_type);
 			}
 
 			if (right.Type != underlying_type) {
 				if (right is Constant)
 					right = ((Constant) right).ConvertExplicitly (false, underlying_type).Resolve (ec);
 				else
 					right = EmptyCast.Create (right, underlying_type);
 			}
 
 			//
 			// C# specification uses explicit cast syntax which means binary promotion
 			// should happen, however it seems that csc does not do that
 			//
 			if (!DoBinaryOperatorPromotion (ec)) {
 				left = ltemp;
 				right = rtemp;
 				return null;
 			}
 
 			if (underlying_type_result != null && left.Type != underlying_type_result) {
 				enum_conversion = Convert.ExplicitNumericConversion (new EmptyExpression (left.Type), underlying_type_result);
 			}
 
 			expr = ResolveOperatorPredefined (ec, standard_operators, true, res_type);
 			if (expr == null)
 				return null;
 
 			if (!IsCompound)
 				return expr;
 
 			//
 			// Section
 			//
 
 			//
 			// If the return type of the selected operator is implicitly convertible to the type of x
 			//
 			if (Convert.ImplicitConversionExists (ec, expr, ltype))
 				return expr;
 
 			//
 			// Otherwise, if the selected operator is a predefined operator, if the return type of the
 			// selected operator is explicitly convertible to the type of x, and if y is implicitly
 			// convertible to the type of x or the operator is a shift operator, then the operation
 			// is evaluated as x = (T)(x op y), where T is the type of x
 			//
 			expr = Convert.ExplicitConversion (ec, expr, ltype, loc);
 			if (expr == null)
 				return null;
 
 			if (Convert.ImplicitConversionExists (ec, ltemp, ltype))
 				return expr;
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1262" endline="1277">
<![CDATA[
 		}
 
 		#endregion
 
 		public static TypeSpec GetMemberDeclaringType (TypeSpec type)
 		{
 			if (type is InflatedTypeSpec) {
 				if (type.DeclaringType == null)
 					return type.GetDefinition ();
 
 				var parent = GetMemberDeclaringType (type.DeclaringType);
 				type = MemberCache.GetMember<TypeSpec> (parent, type);
 			}
 
 			return type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3438" endline="3455">
<![CDATA[
 
 		protected virtual bool ResolveMemberType ()
 		{
 			if (member_type != null)
 				throw new InternalErrorException ("Multi-resolve");
 
 			TypeExpr te = type_expr.ResolveAsTypeTerminal (this, false);
 			if (te == null)
 				return false;
 			
 			//
 			// Replace original type name, error reporting can use fully resolved name
 			//
 			type_expr = te;
 
 			member_type = te.Type;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="518" endline="531">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			// Field initializer can be resolved (fail) many times
 			if (source == null)
 				return null;
 
 			if (resolved == null) {
 				var ctx = new FieldInitializerContext (mc, ec);
 				resolved = base.DoResolve (ctx) as ExpressionStatement;
 			}
 
 			return resolved;
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6223" endline="6239">
<![CDATA[
 
 Location GetLocation (object obj)
 {
 	var lt = obj as Tokenizer.LocatedToken;
 	if (lt != null)
 		return lt.Location;
 		
 	var mn = obj as MemberName;
 	if (mn != null)
 		return mn.Location;
 		
 	var expr = obj as Expression;
 	if (expr != null)
 		return expr.Location;
 
 	return lexer.Location;
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6584" endline="6622">
<![CDATA[
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			// no multi dimensional or jagged arrays
 			if (arguments.Count != 1 || array_element_type.IsArray) {
 				base.EncodeAttributeValue (rc, enc, targetType);
 				return;
 			}
 
 			// No array covariance, except for array -> object
 			if (type != targetType) {
 				if (targetType != TypeManager.object_type) {
 					base.EncodeAttributeValue (rc, enc, targetType);
 					return;
 				}
 
 				if (enc.Encode (type) == AttributeEncoder.EncodedTypeProperties.DynamicType) {
 					Attribute.Error_AttributeArgumentIsDynamic (rc, loc);
 					return;
 				}
 			}
 
 			// Single dimensional array of 0 size
 			if (array_data == null) {
 				IntConstant ic = arguments[0] as IntConstant;
 				if (ic == null || !ic.IsDefaultValue) {
 					base.EncodeAttributeValue (rc, enc, targetType);
 				} else {
 					enc.Encode (0);
 				}
 
 				return;
 			}
 
 			enc.Encode (array_data.Count);
 			foreach (var element in array_data) {
 				element.EncodeAttributeValue (rc, enc, array_element_type);
 			}
 			foreach (var element in array_data) {
 				element.EncodeAttributeValue (rc, enc, array_element_type);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2743" endline="2842">
<![CDATA[
 
 		public bool ResolveInstanceExpression (ResolveContext rc, Expression rhs)
 		{
 			if (IsStatic) {
 				if (InstanceExpression != null) {
 					if (InstanceExpression is TypeExpr) {
 						var t = InstanceExpression.Type;
 						do {
 							ObsoleteAttribute oa = t.GetAttributeObsolete ();
 							if (oa != null && !rc.IsObsolete) {
 								AttributeTester.Report_ObsoleteMessage (oa, t.GetSignatureForError (), loc, rc.Report);
 							}
 
 							t = t.DeclaringType;
 						} while (t != null);
 					} else {
 						var runtime_expr = InstanceExpression as RuntimeValueExpression;
 						if (runtime_expr == null || !runtime_expr.IsSuggestionOnly) {
 							rc.Report.Error (176, loc,
 								"Static member `{0}' cannot be accessed with an instance reference, qualify it with a type name instead",
 								GetSignatureForError ());
 						}
 					}
 
 					InstanceExpression = null;
 				}
 
 				return false;
 			}
 
 			if (InstanceExpression == null || InstanceExpression is TypeExpr) {
 				if (InstanceExpression != null || !This.IsThisAvailable (rc, true)) {
 					if (rc.HasSet (ResolveContext.Options.FieldInitializerScope))
 						rc.Report.Error (236, loc,
 							"A field initializer cannot reference the nonstatic field, method, or property `{0}'",
 							GetSignatureForError ());
 					else
 						rc.Report.Error (120, loc,
 							"An object reference is required to access non-static member `{0}'",
 							GetSignatureForError ());
 
 					return false;
 				}
 
 				if (!TypeManager.IsFamilyAccessible (rc.CurrentType, DeclaringType)) {
 					rc.Report.Error (38, loc,
 						"Cannot access a nonstatic member of outer type `{0}' via nested type `{1}'",
 						DeclaringType.GetSignatureForError (), rc.CurrentType.GetSignatureForError ());
 				}
 
 				InstanceExpression = new This (loc);
 				if (this is FieldExpr && rc.CurrentType.IsStruct) {
 					using (rc.Set (ResolveContext.Options.OmitStructFlowAnalysis)) {
 						InstanceExpression = InstanceExpression.Resolve (rc);
 					}
 				} else {
 					InstanceExpression = InstanceExpression.Resolve (rc);
 				}
 
 				return false;
 			}
 
 			var me = InstanceExpression as MemberExpr;
 			if (me != null) {
 				me.ResolveInstanceExpression (rc, rhs);
 
 				var fe = me as FieldExpr;
 				if (fe != null && fe.IsMarshalByRefAccess ()) {
 					rc.Report.SymbolRelatedToPreviousError (me.DeclaringType);
 					rc.Report.Warning (1690, 1, loc,
 						"Cannot call methods, properties, or indexers on `{0}' because it is a value type member of a marshal-by-reference class",
 						me.GetSignatureForError ());
 				}
 
 				return true;
 			}
 
 			//
 			// Run member-access postponed check once we know that
 			// the expression is not field expression which is the only
 			// expression which can use uninitialized this
 			//
 			if (InstanceExpression is This && !(this is FieldExpr) && rc.CurrentType.IsStruct) {
 				((This)InstanceExpression).CheckStructThisDefiniteAssignment (rc);
 			}
 
 			//
 			// Additional checks for l-value member access
 			//
 			if (rhs != null) {
 				//
 				// TODO
 				//
 				if (InstanceExpression is UnboxCast) {
 					rc.Report.Error (445, InstanceExpression.Location, "Cannot modify the result of an unboxing conversion");
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="342" endline="427">
<![CDATA[
 
 		internal Type ResolveType(int metadataToken, IGenericContext context)
 		{
 			switch (metadataToken >> 24)
 			{
 				case TypeDefTable.Index
 					PopulateTypeDef();
 					return typeDefs[(metadataToken & 0xFFFFFF) - 1];
 				case TypeRefTable.Index
 					{
 						if (typeRefs == null)
 						{
 							typeRefs = new Type[TypeRef.records.Length];
 						}
 						int index = (metadataToken & 0xFFFFFF) - 1;
 						if (typeRefs[index] == null)
 						{
 							int scope = TypeRef.records[index].ResolutionScope;
 							switch (scope >> 24)
 							{
 								case AssemblyRefTable.Index
 									{
 										Assembly assembly = ResolveAssemblyRef((scope & 0xFFFFFF) - 1);
 										string typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
 										Type type = assembly.GetType(typeName);
 										if (type == null)
 										{
 											throw new TypeLoadException(String.Format("Type '{0}' not found in assembly '{1}'", typeName, assembly.FullName));
 										}
 										typeRefs[index] = type;
 										break;
 									}
 								case TypeRefTable.Index
 									{
 										Type outer = ResolveType(scope, null);
 										typeRefs[index] = outer.GetNestedType(GetString(TypeRef.records[index].TypeName), BindingFlags.Public | BindingFlags.NonPublic);
 										break;
 									}
 								case ModuleTable.Index
 									if (scope != 0 && scope != 1)
 									{
 										throw new NotImplementedException("self reference scope?");
 									}
 									typeRefs[index] = GetType(GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName));
 									break;
 								case ModuleRefTable.Index
 									{
 										Module module = ResolveModuleRef(ModuleRef.records[(scope & 0xFFFFFF) - 1]);
 										string typeName = GetTypeName(TypeRef.records[index].TypeNameSpace, TypeRef.records[index].TypeName);
 										Type type = assembly.GetType(typeName);
 										if (type == null)
 										{
 											throw new TypeLoadException(String.Format("Type '{0}' not found in module '{1}'", typeName, module.Name));
 										}
 										typeRefs[index] = type;
 										break;
 									}
 								default
 									throw new NotImplementedException("ResolutionScope = " + scope.ToString("X"));
 							}
 						}
 						return typeRefs[index];
 					}
 				case TypeSpecTable.Index
 					{
 						if (typeSpecs == null)
 						{
 							typeSpecs = new Type[TypeSpec.records.Length];
 						}
 						int index = (metadataToken & 0xFFFFFF) - 1;
 						Type type = typeSpecs[index];
 						if (type == null)
 						{
 							TrackingGenericContext tc = context == null ? null 
 							type = Signature.ReadTypeSpec(this, ByteReader.FromBlob(blobHeap, TypeSpec.records[index]), tc);
 							if (tc == null || !tc.IsUsed)
 							{
 								typeSpecs[index] = type;
 							}
 						}
 						return type;
 					}
 				default
 					throw new NotImplementedException(String.Format("0x{0
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1275" endline="1368">
<![CDATA[
 
 		public override bool Resolve (BlockContext bc)
 		{
 			if (li.Type == null) {
 				TypeSpec type = null;
 				if (type_expr is VarExpr) {
 					//
 					// C# 3.0 introduced contextual keywords (var) which behaves like a type if type with
 					// same name exists or as a keyword when no type was found
 					// 
 					var texpr = type_expr.ResolveAsTypeTerminal (bc, true);
 					if (texpr == null) {
 						if (RootContext.Version < LanguageVersion.V_3)
 							bc.Report.FeatureIsNotAvailable (loc, "implicitly typed local variable");
 
 						if (li.IsFixed) {
 							bc.Report.Error (821, loc, "A fixed statement cannot use an implicitly typed local variable");
 							return false;
 						}
 
 						if (li.IsConstant) {
 							bc.Report.Error (822, loc, "An implicitly typed local variable cannot be a constant");
 							return false;
 						}
 
 						if (Initializer == null) {
 							bc.Report.Error (818, loc, "An implicitly typed local variable declarator must include an initializer");
 							return false;
 						}
 
 						if (declarators != null) {
 							bc.Report.Error (819, loc, "An implicitly typed local variable declaration cannot include multiple declarators");
 							declarators = null;
 						}
 
 						Initializer = Initializer.Resolve (bc);
 						if (Initializer != null) {
 							((VarExpr) type_expr).InferType (bc, Initializer);
 							type = type_expr.Type;
 						}
 					}
 				}
 
 				if (type == null) {
 					var texpr = type_expr.ResolveAsTypeTerminal (bc, false);
 					if (texpr == null)
 						return false;
 
 					type = texpr.Type;
 
 					if (li.IsConstant && !type.IsConstantCompatible) {
 						Const.Error_InvalidConstantType (type, loc, bc.Report);
 					}
 				}
 
 				if (type.IsStatic)
 					FieldBase.Error_VariableOfStaticClass (loc, li.Name, type, bc.Report);
 
 				if (type.IsPointer && !bc.IsUnsafe)
 					Expression.UnsafeError (bc, loc);
 
 				li.Type = type;
 			}
 
 			bool eval_global = RootContext.StatementMode && bc.CurrentBlock is ToplevelBlock;
 			if (eval_global) {
 				CreateEvaluatorVariable (bc, li);
 			} else {
 				li.PrepareForFlowAnalysis (bc);
 			}
 
 			if (initializer != null) {
 				initializer = ResolveInitializer (bc, li, initializer);
 				// li.Variable.DefinitelyAssigned 
 			}
 
 			if (declarators != null) {
 				foreach (var d in declarators) {
 					d.Variable.Type = li.Type;
 					if (eval_global) {
 						CreateEvaluatorVariable (bc, d.Variable);
 					} else {
 						d.Variable.PrepareForFlowAnalysis (bc);
 					}
 
 					if (d.Initializer != null) {
 						d.Initializer = ResolveInitializer (bc, d.Variable, d.Initializer);
 						// d.Variable.DefinitelyAssigned 
 					}
 				}
 				foreach (var d in declarators) {
 					d.Variable.Type = li.Type;
 					if (eval_global) {
 						CreateEvaluatorVariable (bc, d.Variable);
 					} else {
 						d.Variable.PrepareForFlowAnalysis (bc);
 					}
 
 					if (d.Initializer != null) {
 						d.Initializer = ResolveInitializer (bc, d.Variable, d.Initializer);
 						// d.Variable.DefinitelyAssigned 
 					}
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="560" endline="568">
<![CDATA[
 
 		public SourceFileEntry SourceFile {
 			get {
 				if (creating)
 					return source;
 
 				ReadData ();
 				return source;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="105" endline="112">
<![CDATA[
 
 		public string GetSignatureForError ()
 		{
 			if (Expr.eclass == ExprClass.MethodGroup)
 				return Expr.ExprClassName;
 
 			return TypeManager.CSharpName (Expr.Type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="636" endline="650">
<![CDATA[
 
 		private int ImportAssemblyRef(Assembly asm)
 		{
 			int token;
 			if (!referencedAssemblies.TryGetValue(asm, out token))
 			{
 				// We can't write the AssemblyRef record here yet, because the identity of the assembly can still change
 				// (if it's an AssemblyBuilder).
 				// We set the high bit of rid in the token to make sure we emit obviously broken metadata,
 				// if we forget to patch up the token somewhere.
 				token = 0x23800001 + referencedAssemblies.Count;
 				referencedAssemblies.Add(asm, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="284" endline="305">
<![CDATA[
 
 		public void StartBlock (CodeBlockEntry.Type type, int start_offset)
 		{
 			if (_block_stack == null) {
 #if NET_2_1
 				_block_stack = new System.Collections.Stack ();
 #else				
 				_block_stack = new Stack<CodeBlockEntry> ();
 #endif
 			}
 			
 			if (_blocks == null)
 				_blocks = new List<CodeBlockEntry> ();
 
 			int parent = CurrentBlock != null ? CurrentBlock.Index 
 
 			CodeBlockEntry block = new CodeBlockEntry (
 				_blocks.Count + 1, parent, type, start_offset);
 
 			_block_stack.Push (block);
 			_blocks.Add (block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1806" endline="1824">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			base.Emit (ec);
 
 			bool gen = TypeManager.IsGenericParameter (child.Type);
 			if (gen)
 				ec.Emit (OpCodes.Box, child.Type);
 			
 			if (type.IsGenericParameter) {
 				ec.Emit (OpCodes.Unbox_Any, type);
 				return;
 			}
 			
 			if (gen && !forced)
 				return;
 			
 			ec.Emit (OpCodes.Castclass, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="444" endline="458">
<![CDATA[
 
 		public override void LoadReferences (ModuleContainer module)
 		{
 			List<Tuple<RootNamespace, Assembly>> loaded;
 			base.LoadReferencesCore (module, out corlib, out loaded);
 
 			if (corlib != null) {
 				importer.InitializeBuildinTypes (compiler.BuildinTypes, corlib);
 				importer.ImportAssembly (corlib, module.GlobalRootNamespace);
 			}
 
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 			foreach (var entry in loaded) {
 				importer.ImportAssembly (entry.Item2, entry.Item1);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3722" endline="4022">
<![CDATA[
 
 		//
 		// Determines if the candidate method is applicable to the given set of arguments
 		// There could be two different set of parameters for same candidate where one
 		// is the closest override for default values and named arguments checks and second
 		// one being the virtual base for the parameter types and modifiers.
 		//
 		// A return value rates candidate method compatibility,
 		// 0 = the best, int.MaxValue = the worst
 		//
 		int IsApplicable (ResolveContext ec, ref Arguments arguments, int arg_count, ref MemberSpec candidate, IParametersMember pm, ref bool params_expanded_form, ref bool dynamicArgument, ref TypeSpec returnType)
 		{
 			// Parameters of most-derived type used mainly for named and optional parameters
 			var pd = pm.Parameters;
 
 			// Used for params modifier only, that's legacy of C# 1.0 which uses base type for
 			// params modifier instead of most-derived type
 			var cpd = ((IParametersMember) candidate).Parameters;
 			int param_count = pd.Count;
 			int optional_count = 0;
 			int score;
 			Arguments orig_args = arguments;
 
 			if (arg_count != param_count) {
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 
 				if (optional_count != 0) {
 					// Readjust expected number when params used
 					if (cpd.HasParams) {
 						optional_count--;
 						if (arg_count < param_count)
 							param_count--;
 					} else if (arg_count > param_count) {
 						int args_gap = System.Math.Abs (arg_count - param_count);
 						return int.MaxValue - 10000 + args_gap;
 					}
 				} else if (arg_count != param_count) {
 					int args_gap = System.Math.Abs (arg_count - param_count);
 					if (!cpd.HasParams)
 						return int.MaxValue - 10000 + args_gap;
 					if (arg_count < param_count - 1)
 						return int.MaxValue - 10000 + args_gap;
 				}
 
 				// Resize to fit optional arguments
 				if (optional_count != 0) {
 					if (arguments == null) {
 						arguments = new Arguments (optional_count);
 					} else {
 						// Have to create a new container, so the next run can do same
 						var resized = new Arguments (param_count);
 						resized.AddRange (arguments);
 						arguments = resized;
 					}
 
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 				}
 			}
 
 			if (arg_count > 0) {
 				//
 				// Shuffle named arguments to the right positions if there are any
 				//
 				if (arguments[arg_count - 1] is NamedArgument) {
 					arg_count = arguments.Count;
 
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 				} else {
 					arg_count = arguments.Count;
 				}
 			} else if (arguments != null) {
 				arg_count = arguments.Count;
 			}
 
 			//
 			// 1. Handle generic method using type arguments when specified or type inference
 			//
 			TypeSpec[] ptypes;
 			var ms = candidate as MethodSpec;
 			if (ms != null && ms.IsGeneric) {
 				// Setup constraint checker for probing only
 				ConstraintChecker cc = new ConstraintChecker (null);
 
 				if (type_arguments != null) {
 					var g_args_count = ms.Arity;
 					if (g_args_count != type_arguments.Count)
 						return int.MaxValue - 20000 + System.Math.Abs (type_arguments.Count - g_args_count);
 
 					ms = ms.MakeGenericMethod (type_arguments.Arguments);
 				} else {
 					// TODO
 					// for now it simplifies things. I should probably add a callback to ResolveContext
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 
 					var ti = new TypeInference (arguments);
 					TypeSpec[] i_args = ti.InferMethodArguments (ec, ms);
 					lambda_conv_msgs.EndSession ();
 
 					if (i_args == null)
 						return ti.InferenceScore - 20000;
 
 					if (i_args.Length != 0) {
 						ms = ms.MakeGenericMethod (i_args);
 					}
 
 					cc.IgnoreInferredDynamic = true;
 				}
 
 				//
 				// Type arguments constraints have to match for the method to be applicable
 				//
 				if (!cc.CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc)) {
 					candidate = ms;
 					return int.MaxValue - 25000;
 				}
 
 				//
 				// We have a generic return type and at same time the method is override which
 				// means we have to also inflate override return type in case the candidate is
 				// best candidate and override return type is different to base return type.
 				// 
 				// virtual Foo<T, object> with override Foo<T, dynamic>
 				//
 				if (candidate != pm) {
 					MethodSpec override_ms = (MethodSpec) pm;
 					var inflator = new TypeParameterInflator (ms.DeclaringType, override_ms.GenericDefinition.TypeParameters, ms.TypeArguments);
 					returnType = inflator.Inflate (returnType);
 				} else {
 					returnType = ms.ReturnType;
 				}
 
 				candidate = ms;
 				ptypes = ms.Parameters.Types;
 			} else {
 				if (type_arguments != null)
 					return int.MaxValue - 15000;
 
 				ptypes = cpd.Types;
 			}
 
 			//
 			// 2. Each argument has to be implicitly convertible to method parameter
 			//
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 
 			//
 			// When params parameter has no argument it will be provided later if the method is the best candidate
 			//
 			if (arg_count + 1 == pd.Count && (cpd.FixedParameters [arg_count].ModFlags & Parameter.Modifier.PARAMS) != 0)
 				params_expanded_form = true;
 
 			//
 			// Restore original arguments for dynamic binder to keep the intention of original source code
 			//
 			if (dynamicArgument)
 				arguments = orig_args;
 
 			return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1032" endline="1056">
<![CDATA[
 		
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (left is NullLiteral)
 				ec.Report.Error (845, loc, "An expression tree cannot contain a coalescing operator with null left side");
 
 			UserCast uc = left as UserCast;
 			Expression conversion = null;
 			if (uc != null) {
 				left = uc.Source;
 
 				Arguments c_args = new Arguments (2);
 				c_args.Add (new Argument (uc.CreateExpressionTree (ec)));
 				c_args.Add (new Argument (left.CreateExpressionTree (ec)));
 				conversion = CreateExpressionFactoryCall (ec, "Lambda", c_args);
 			}
 
 			Arguments args = new Arguments (3);
 			args.Add (new Argument (left.CreateExpressionTree (ec)));
 			args.Add (new Argument (right.CreateExpressionTree (ec)));
 			if (conversion != null)
 				args.Add (new Argument (conversion));
 			
 			return CreateExpressionFactoryCall (ec, "Coalesce", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="260" endline="402">
<![CDATA[
 
 		public void Save(string assemblyFileName, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine)
 		{
 			ModuleBuilder manifestModule = null;
 
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.PopulatePropertyAndEventTables();
 
 				if (manifestModule == null
 					&& string.Compare(moduleBuilder.fileName, assemblyFileName, StringComparison.OrdinalIgnoreCase) == 0)
 				{
 					manifestModule = moduleBuilder;
 				}
 			}
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.PopulatePropertyAndEventTables();
 
 				if (manifestModule == null
 					&& string.Compare(moduleBuilder.fileName, assemblyFileName, StringComparison.OrdinalIgnoreCase) == 0)
 				{
 					manifestModule = moduleBuilder;
 				}
 			}
 
 			if (manifestModule == null)
 			{
 				manifestModule = DefineDynamicModule("RefEmit_OnDiskManifestModule", assemblyFileName, false);
 			}
 
 			AssemblyTable.Record assemblyRecord = new AssemblyTable.Record();
 			assemblyRecord.HashAlgId = (int)hashAlgorithm;
 			assemblyRecord.Name = manifestModule.Strings.Add(name);
 			assemblyRecord.MajorVersion = majorVersion;
 			assemblyRecord.MinorVersion = minorVersion;
 			assemblyRecord.BuildNumber = buildVersion;
 			assemblyRecord.RevisionNumber = revisionVersion;
 			if (publicKey != null)
 			{
 				assemblyRecord.PublicKey = manifestModule.Blobs.Add(ByteBuffer.Wrap(publicKey));
 				assemblyRecord.Flags = (int)(flags | AssemblyNameFlags.PublicKey);
 			}
 			else
 			{
 				assemblyRecord.Flags = (int)(flags & ~AssemblyNameFlags.PublicKey);
 			}
 			if (culture != null)
 			{
 				assemblyRecord.Culture = manifestModule.Strings.Add(culture);
 			}
 			int token = 0x20000000 + manifestModule.AssemblyTable.AddRecord(assemblyRecord);
 
 #pragma warning disable 618
 			// this values are obsolete, but we already know that so we disable the warning
 			System.Security.Permissions.SecurityAction requestMinimum = System.Security.Permissions.SecurityAction.RequestMinimum;
 			System.Security.Permissions.SecurityAction requestOptional = System.Security.Permissions.SecurityAction.RequestOptional;
 			System.Security.Permissions.SecurityAction requestRefuse = System.Security.Permissions.SecurityAction.RequestRefuse;
 #pragma warning restore 618
 			if (requiredPermissions != null)
 			{
 				manifestModule.AddDeclarativeSecurity(token, requestMinimum, requiredPermissions);
 			}
 			if (optionalPermissions != null)
 			{
 				manifestModule.AddDeclarativeSecurity(token, requestOptional, optionalPermissions);
 			}
 			if (refusedPermissions != null)
 			{
 				manifestModule.AddDeclarativeSecurity(token, requestRefuse, refusedPermissions);
 			}
 
 			if (versionInfo != null)
 			{
 				versionInfo.SetName(GetName());
 				versionInfo.SetFileName(assemblyFileName);
 				foreach (CustomAttributeBuilder cab in customAttributes)
 				{
 					// .NET doesn't support copying blob custom attributes into the version info
 					if (!cab.HasBlob)
 					{
 						versionInfo.SetAttribute(cab);
 					}
 				}
 				foreach (CustomAttributeBuilder cab in customAttributes)
 				{
 					// .NET doesn't support copying blob custom attributes into the version info
 					if (!cab.HasBlob)
 					{
 						versionInfo.SetAttribute(cab);
 					}
 				}
 				ByteBuffer versionInfoData = new ByteBuffer(512);
 				versionInfo.Write(versionInfoData);
 				if (unmanagedResources == null)
 				{
 					unmanagedResources = new ResourceSection();
 				}
 				unmanagedResources.AddVersionInfo(versionInfoData);
 			}
 
 			foreach (CustomAttributeBuilder cab in customAttributes)
 			{
 				// we intentionally don't filter out the version info (pseudo) custom attributes (to be compatible with .NET)
 				manifestModule.SetCustomAttribute(0x20000001, cab);
 			}
 			foreach (CustomAttributeBuilder cab in customAttributes)
 			{
 				// we intentionally don't filter out the version info (pseudo) custom attributes (to be compatible with .NET)
 				manifestModule.SetCustomAttribute(0x20000001, cab);
 			}
 
 			manifestModule.AddDeclarativeSecurity(0x20000001, declarativeSecurity);
 
 			foreach (Type type in typeForwarders)
 			{
 				manifestModule.AddTypeForwarder(type);
 			}
 			foreach (Type type in typeForwarders)
 			{
 				manifestModule.AddTypeForwarder(type);
 			}
 
 			foreach (ResourceFile resfile in resourceFiles)
 			{
 				int fileToken = AddFile(manifestModule, resfile.FileName, 1 /*ContainsNoMetaData*/);
 				ManifestResourceTable.Record rec = new ManifestResourceTable.Record();
 				rec.Offset = 0;
 				rec.Flags = (int)resfile.Attributes;
 				rec.Name = manifestModule.Strings.Add(resfile.Name);
 				rec.Implementation = fileToken;
 				manifestModule.ManifestResource.AddRecord(rec);
 			}
 			foreach (ResourceFile resfile in resourceFiles)
 			{
 				int fileToken = AddFile(manifestModule, resfile.FileName, 1 /*ContainsNoMetaData*/);
 				ManifestResourceTable.Record rec = new ManifestResourceTable.Record();
 				rec.Offset = 0;
 				rec.Flags = (int)resfile.Attributes;
 				rec.Name = manifestModule.Strings.Add(resfile.Name);
 				rec.Implementation = fileToken;
 				manifestModule.ManifestResource.AddRecord(rec);
 			}
 
 			int entryPointToken = 0;
 
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.FillAssemblyRefTable();
 				if (moduleBuilder != manifestModule)
 				{
 					int fileToken;
 					if (entryPoint != null && entryPoint.Module == moduleBuilder)
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, entryPoint.MetadataToken);
 						entryPointToken = fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					else
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, 0);
 						fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					moduleBuilder.ExportTypes(fileToken, manifestModule);
 				}
 			}
 			foreach (ModuleBuilder moduleBuilder in modules)
 			{
 				moduleBuilder.FillAssemblyRefTable();
 				if (moduleBuilder != manifestModule)
 				{
 					int fileToken;
 					if (entryPoint != null && entryPoint.Module == moduleBuilder)
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, entryPoint.MetadataToken);
 						entryPointToken = fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					else
 					{
 						ModuleWriter.WriteModule(null, null, moduleBuilder, fileKind, portableExecutableKind, imageFileMachine, moduleBuilder.unmanagedResources, 0);
 						fileToken = AddFile(manifestModule, moduleBuilder.fileName, 0 /*ContainsMetaData*/);
 					}
 					moduleBuilder.ExportTypes(fileToken, manifestModule);
 				}
 			}
 
 			foreach (Module module in addedModules)
 			{
 				int fileToken = AddFile(manifestModule, module.FullyQualifiedName, 0 /*ContainsMetaData*/);
 				module.ExportTypes(fileToken, manifestModule);
 			}
 			foreach (Module module in addedModules)
 			{
 				int fileToken = AddFile(manifestModule, module.FullyQualifiedName, 0 /*ContainsMetaData*/);
 				module.ExportTypes(fileToken, manifestModule);
 			}
 
 			if (entryPointToken == 0 && entryPoint != null)
 			{
 				entryPointToken = entryPoint.MetadataToken;
 			}
 
 			// finally, write the manifest module
 			ModuleWriter.WriteModule(keyPair, publicKey, manifestModule, fileKind, portableExecutableKind, imageFileMachine, unmanagedResources ?? manifestModule.unmanagedResources, entryPointToken);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="549" endline="575">
<![CDATA[
 
 		void Error_ConversionFailed (ResolveContext ec, MethodSpec method, Expression return_type)
 		{
 			var invoke_method = Delegate.GetInvokeMethod (ec.Compiler, type);
 			string member_name = method_group.InstanceExpression != null ?
 				Delegate.FullDelegateDesc (method) 
 				TypeManager.GetFullNameSignature (method);
 
 			ec.Report.SymbolRelatedToPreviousError (type);
 			ec.Report.SymbolRelatedToPreviousError (method);
 			if (RootContext.Version == LanguageVersion.ISO_1) {
 				ec.Report.Error (410, loc, "A method or delegate `{0} {1}' parameters and return type must be same as delegate `{2} {3}' parameters and return type",
 					TypeManager.CSharpName (method.ReturnType), member_name,
 					TypeManager.CSharpName (invoke_method.ReturnType), Delegate.FullDelegateDesc (invoke_method));
 				return;
 			}
 
 			if (return_type == null) {
 				ec.Report.Error (123, loc, "A method or delegate `{0}' parameters do not match delegate `{1}' parameters",
 					member_name, Delegate.FullDelegateDesc (invoke_method));
 				return;
 			}
 
 			ec.Report.Error (407, loc, "A method or delegate `{0} {1}' return type does not match delegate `{2} {3}' return type",
 				return_type.GetSignatureForError (), member_name,
 				TypeManager.CSharpName (invoke_method.ReturnType), Delegate.FullDelegateDesc (invoke_method));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5462" endline="5495">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (right_side == EmptyExpression.OutAccess.Instance) {
 				// TODO
 				INamedBlockVariable variable = null;
 				if (best_candidate != null && ec.CurrentBlock.ParametersBlock.TopBlock.GetLocalName (best_candidate.Name, ec.CurrentBlock, ref variable) && variable is Linq.RangeVariable) {
 					ec.Report.Error (1939, loc, "A range variable `{0}' may not be passes as `ref' or `out' parameter",
 						best_candidate.Name);
 				} else {
 					right_side.DoResolveLValue (ec, this);
 				}
 				return null;
 			}
 
 			// if the property/indexer returns a value type, and we try to set a field in it
 			if (right_side == EmptyExpression.LValueMemberAccess || right_side == EmptyExpression.LValueMemberOutAccess) {
 				Error_CannotModifyIntermediateExpressionValue (ec);
 			}
 
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, right_side);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.ResolveLValue (ec, right_side);
 			}
 
 			if (!ResolveSetter (ec))
 				return null;
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1472" endline="1511">
<![CDATA[
 		
 		//
 		// Creates the ConstructorBuilder
 		//
 		public override bool Define ()
 		{
 			if (ConstructorBuilder != null)
 				return true;
 
 			var ca = MethodAttributes.RTSpecialName | MethodAttributes.SpecialName;
 			
 			if ((ModFlags & Modifiers.STATIC) != 0) {
 				ca |= MethodAttributes.Static | MethodAttributes.Private;
 			} else {
 				ca |= ModifiersExtensions.MethodAttr (ModFlags);
 			}
 
 			if (!CheckAbstractAndExtern (block != null))
 				return false;
 			
 			// Check if arguments were correct.
 			if (!CheckBase ())
 				return false;
 
 			ConstructorBuilder = Parent.TypeBuilder.DefineConstructor (
 				ca, CallingConventions,
 				parameters.GetMetaInfo ());
 
 			spec = new MethodSpec (MemberKind.Constructor, Parent.Definition, this, TypeManager.void_type, ConstructorBuilder, parameters, ModFlags);
 			
 			Parent.MemberCache.AddMember (spec);
 			
 			// It's here only to report an error
 			if (block != null && block.IsIterator) {
 				member_type = TypeManager.void_type;
 				Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4716" endline="4744">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			using (ec.With (ResolveContext.Options.CatchScope, true)) {
 				if (type_expr != null) {
 					TypeExpr te = type_expr.ResolveAsTypeTerminal (ec, false);
 					if (te == null)
 						return false;
 
 					type = te.Type;
 					if (type != TypeManager.exception_type && !TypeSpec.IsBaseClass (type, TypeManager.exception_type, false)) {
 						ec.Report.Error (155, loc, "The type caught or thrown must be derived from System.Exception");
 					} else if (li != null) {
 						li.Type = type;
 						li.PrepareForFlowAnalysis (ec);
 
 						// source variable is at the top of the stack
 						Expression source = new EmptyExpression (li.Type);
 						if (li.Type.IsGenericParameter)
 							source = new UnboxCast (source, li.Type);
 
 						assign = new CompilerAssign (new LocalVariableReference (li, loc), source, loc);
 						Block.AddScopeStatement (new StatementExpression (assign));
 					}
 				}
 
 				return Block.Resolve (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="638" endline="685">
<![CDATA[
 
 		//
 		// Creates field access expression for hoisted variable
 		//
 		protected virtual FieldExpr GetFieldExpression (EmitContext ec)
 		{
 			if (ec.CurrentAnonymousMethod == null || ec.CurrentAnonymousMethod.Storey == null) {
 				if (cached_outer_access != null)
 					return cached_outer_access;
 
 				//
 				// When setting top-level hoisted variable in generic storey
 				// change storey generic types to method generic types (VAR -> MVAR)
 				//
 				if (storey.Instance.Type.IsGenericOrParentIsGeneric) {
 					var fs = MemberCache.GetMember (storey.Instance.Type, field.Spec);
 					cached_outer_access = new FieldExpr (fs, field.Location);
 				} else {
 					cached_outer_access = new FieldExpr (field, field.Location);
 				}
 
 				cached_outer_access.InstanceExpression = storey.GetStoreyInstanceExpression (ec);
 				return cached_outer_access;
 			}
 
 			FieldExpr inner_access;
 			if (cached_inner_access != null) {
 				if (!cached_inner_access.TryGetValue (ec.CurrentAnonymousMethod, out inner_access))
 					inner_access = null;
 			} else {
 				inner_access = null;
 				cached_inner_access = new Dictionary<AnonymousExpression, FieldExpr> (4);
 			}
 
 			if (inner_access == null) {
 				if (field.Parent.IsGeneric) {
 					var fs = MemberCache.GetMember (field.Parent.CurrentType, field.Spec);
 					inner_access = new FieldExpr (fs, field.Location);
 				} else {
 					inner_access = new FieldExpr (field, field.Location);
 				}
 
 				inner_access.InstanceExpression = storey.GetStoreyInstanceExpression (ec);
 				cached_inner_access.Add (ec.CurrentAnonymousMethod, inner_access);
 			}
 
 			return inner_access;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8267" endline="8320">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			var ac = (ArrayContainer) ea.Expr.Type;
 			TypeSpec t = source.Type;
 
 			//
 			// When we are dealing with a struct, get the address of it to avoid value copy
 			// Same cannot be done for reference type because array covariance and the
 			// check in ldelema requires to specify the type of array element stored at the index
 			//
 			if (t.IsStruct && ((prepare_for_load && !(source is DynamicExpressionStatement)) || !TypeManager.IsPrimitiveType (t))) {
 				LoadArrayAndArguments (ec);
 				ec.EmitArrayAddress (ac);
 
 				if (prepare_for_load) {
 					ec.Emit (OpCodes.Dup);
 				}
 
 				prepared = true;
 			} else if (prepare_for_load) {
 				ea.Expr.Emit (ec);
 				ec.Emit (OpCodes.Dup);
 
 				expr_copy = new LocalTemporary (ea.Expr.Type);
 				expr_copy.Store (ec);
 				prepared_arguments = ea.Arguments.Emit (ec, true);
 			} else {
 				LoadArrayAndArguments (ec);
 			}
 
 			source.Emit (ec);
 
 			if (expr_copy != null) {
 				expr_copy.Release (ec);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				temp = new LocalTemporary (this.type);
 				temp.Store (ec);
 			}
 
 			if (prepared) {
 				ec.EmitStoreFromPtr (t);
 			} else {
 				ec.EmitArrayStore (ac);
 			}
 			
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="34" endline="76">
<![CDATA[
 
 		/// <summary>
 		///   Defines the constant in the @parent
 		/// </summary>
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!member_type.IsConstantCompatible) {
 				Error_InvalidConstantType (member_type, Location, Report);
 			}
 
 			FieldAttributes field_attr = FieldAttributes.Static | ModifiersExtensions.FieldAttr (ModFlags);
 			// Decimals cannot be emitted into the constant blob.  So, convert to 'readonly'.
 			if (member_type == TypeManager.decimal_type) {
 				field_attr |= FieldAttributes.InitOnly;
 			} else {
 				field_attr |= FieldAttributes.Literal;
 			}
 
 			FieldBuilder = Parent.TypeBuilder.DefineField (Name, MemberType.GetMetaInfo (), field_attr);
 			spec = new ConstSpec (Parent.Definition, this, MemberType, FieldBuilder, ModFlags, initializer);
 
 			Parent.MemberCache.AddMember (spec);
 
 			if ((field_attr & FieldAttributes.InitOnly) != 0)
 				Parent.PartialContainer.RegisterFieldForInitialization (this,
 					new FieldInitializer (spec, initializer, this));
 
 			if (declarators != null) {
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Constants.IndexOf (this);
 				foreach (var d in declarators) {
 					var c = new Const (Parent, t, ModFlags & ~Modifiers.STATIC, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					c.initializer = d.Initializer;
 					((ConstInitializer) c.initializer).Name = d.Name.Value;
 					Parent.PartialContainer.Constants.Insert (++index, c);
 				}
 				foreach (var d in declarators) {
 					var c = new Const (Parent, t, ModFlags & ~Modifiers.STATIC, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					c.initializer = d.Initializer;
 					((ConstInitializer) c.initializer).Name = d.Name.Value;
 					Parent.PartialContainer.Constants.Insert (++index, c);
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1027" endline="1155">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			
 			if (expr == null)
 				return null;
 
 			if (expr.Type == InternalType.Dynamic) {
 				//
 				// Handle postfix unary operators using local
 				// temporary variable
 				//
 				if ((mode & Mode.IsPost) != 0)
 					expr = new DynamicPostMutator (expr);
 
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return new SimpleAssign (expr, new DynamicUnaryConversion (GetOperatorExpressionTypeName (), args, loc)).Resolve (ec);
 			}
 
 			if (TypeManager.IsNullableType (expr.Type))
 				return new Nullable.LiftedUnaryMutator (mode, expr, loc).Resolve (ec);
 
 			eclass = ExprClass.Value;
 			type = expr.Type;
 
 			if (expr is RuntimeValueExpression) {
 				operation = expr;
 			} else {
 				// Use itself at the top of the stack
 				operation = new EmptyExpression (type);
 			}
 
 			//
 			// The operand of the prefix/postfix increment decrement operators
 			// should be an expression that is classified as a variable,
 			// a property access or an indexer access
 			//
 			// TODO
 			if (expr.eclass == ExprClass.Variable || expr.eclass == ExprClass.IndexerAccess || expr.eclass == ExprClass.PropertyAccess) {
 				expr = expr.ResolveLValue (ec, expr);
 			} else {
 				ec.Report.Error (1059, loc, "The operand of an increment or decrement operator must be a variable, property or indexer");
 			}
 
 			//
 			// Step 1
 			//
 			var user_op = IsDecrement ? Operator.OpType.Decrement 
 			var methods = MemberCache.GetUserOperator (type, user_op, false);
 
 			if (methods != null) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 
 				var res = new OverloadResolver (methods, OverloadResolver.Restrictions.BaseMembersIncluded | OverloadResolver.Restrictions.NoBaseMembers, loc);
 				var method = res.ResolveOperator (ec, ref args);
 				if (method == null)
 					return null;
 
 				args[0].Expr = operation;
 				operation = new UserOperatorCall (method, args, null, loc);
 				operation = Convert.ImplicitConversionRequired (ec, operation, type, loc);
 				return this;
 			}
 
 			//
 			// Step 2
 			//
 			if (predefined == null)
 				CreatePredefinedOperators ();
 
 			// Predefined without user conversion first for speed-up
 			Expression source = null;
 			bool primitive_type = false;
 			foreach (var t in predefined) {
 				if (t == type) {
 					source = operation;
 					primitive_type = true;
 					break;
 				}
 			}
 			foreach (var t in predefined) {
 				if (t == type) {
 					source = operation;
 					primitive_type = true;
 					break;
 				}
 			}
 
 			// ++/-- on pointer variables of all types except void*
 			if (source == null && type.IsPointer) {
 				if (((PointerContainer) type).Element.BuildinType == BuildinTypeSpec.Type.Void) {
 					Error_VoidPointerOperation (ec);
 					return null;
 				}
 
 				source = operation;
 			}
 
 			if (source == null) {
 				// LAMESPEC
 				foreach (var t in predefined) {
 					source = Convert.ImplicitUserConversion (ec, operation, t, loc);
 					if (source != null) {
 						break;
 					}
 				}
 				foreach (var t in predefined) {
 					source = Convert.ImplicitUserConversion (ec, operation, t, loc);
 					if (source != null) {
 						break;
 					}
 				}
 			}
 
 			// ++/-- on enum types
 			if (source == null && type.IsEnum)
 				source = operation;
 
 			if (source == null) {
 				Unary.Error_OperatorCannotBeApplied (ec, loc, Operator.GetName (user_op), type);
 				return null;
 			}
 
 			var one = new IntConstant (1, loc);
 			var op = IsDecrement ? Binary.Operator.Subtraction 
 			operation = new Binary (op, source, one, loc);
 			operation = operation.Resolve (ec);
 			if (operation == null)
 				throw new NotImplementedException ("should not be reached");
 
 			if (operation.Type != type) {
 				if (primitive_type)
 					operation = Convert.ExplicitNumericConversion (operation, type);
 				else
 					operation = Convert.ImplicitConversionRequired (ec, operation, type, loc);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="970" endline="1108">
<![CDATA[
 
 		private int WriteFatHeaderAndCode(ByteBuffer bb, ref int localVarSigTok, bool initLocals)
 		{
 			// fat headers require 4-byte alignment
 			bb.Align(4);
 			int rva = bb.Position;
 
 			if (locals.Count != 0)
 			{
 				ByteBuffer localVarSig = new ByteBuffer(locals.Count + 2);
 				Signature.WriteLocalVarSig(moduleBuilder, localVarSig, locals);
 				localVarSigTok = 0x11000000 | moduleBuilder.StandAloneSig.FindOrAddRecord(moduleBuilder.Blobs.Add(localVarSig));
 			}
 
 			const byte CorILMethod_FatFormat = 0x03;
 			const byte CorILMethod_MoreSects = 0x08;
 			const byte CorILMethod_InitLocals = 0x10;
 
 			short flagsAndSize = (short)(CorILMethod_FatFormat | (3 << 12));
 			if (initLocals)
 			{
 				flagsAndSize |= CorILMethod_InitLocals;
 			}
 
 			if (exceptions.Count > 0)
 			{
 				flagsAndSize |= CorILMethod_MoreSects;
 			}
 
 			bb.Write(flagsAndSize);
 			bb.Write(maxStack);
 			bb.Write(code.Length);
 			bb.Write(localVarSigTok);
 
 			WriteCode(bb);
 
 			if (exceptions.Count > 0)
 			{
 				bb.Align(4);
 
 				bool fat = false;
 				foreach (ExceptionBlock block in exceptions)
 				{
 					if (block.tryOffset > 65535 || block.tryLength > 255 || block.handlerOffset > 65535 || block.handlerLength > 255)
 					{
 						fat = true;
 						break;
 					}
 				}
 				foreach (ExceptionBlock block in exceptions)
 				{
 					if (block.tryOffset > 65535 || block.tryLength > 255 || block.handlerOffset > 65535 || block.handlerLength > 255)
 					{
 						fat = true;
 						break;
 					}
 				}
 				exceptions.Sort(exceptions[0]);
 				if (exceptions.Count * 12 + 4 > 255)
 				{
 					fat = true;
 				}
 				const byte CorILMethod_Sect_EHTable = 0x1;
 				const byte CorILMethod_Sect_FatFormat = 0x40;
 				const short COR_ILEXCEPTION_CLAUSE_EXCEPTION = 0x0000;
 				const short COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001;
 				const short COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002;
 				const short COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004;
 
 				if (fat)
 				{
 					bb.Write((byte)(CorILMethod_Sect_EHTable | CorILMethod_Sect_FatFormat));
 					int dataSize = exceptions.Count * 24 + 4;
 					bb.Write((byte)dataSize);
 					bb.Write((short)(dataSize >> 8));
 					foreach (ExceptionBlock block in exceptions)
 					{
 						if (block.exceptionType == FAULT)
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_FAULT);
 						}
 						else if (block.filterOffset != 0)
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_FILTER);
 						}
 						else if (block.exceptionType != null)
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_EXCEPTION);
 						}
 						else
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_FINALLY);
 						}
 						bb.Write(block.tryOffset);
 						bb.Write(block.tryLength);
 						bb.Write(block.handlerOffset);
 						bb.Write(block.handlerLength);
 						if (block.exceptionType != null && block.exceptionType != FAULT)
 						{
 							bb.Write(moduleBuilder.GetTypeTokenForMemberRef(block.exceptionType));
 						}
 						else
 						{
 							bb.Write(block.filterOffset);
 						}
 					}
 					foreach (ExceptionBlock block in exceptions)
 					{
 						if (block.exceptionType == FAULT)
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_FAULT);
 						}
 						else if (block.filterOffset != 0)
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_FILTER);
 						}
 						else if (block.exceptionType != null)
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_EXCEPTION);
 						}
 						else
 						{
 							bb.Write((int)COR_ILEXCEPTION_CLAUSE_FINALLY);
 						}
 						bb.Write(block.tryOffset);
 						bb.Write(block.tryLength);
 						bb.Write(block.handlerOffset);
 						bb.Write(block.handlerLength);
 						if (block.exceptionType != null && block.exceptionType != FAULT)
 						{
 							bb.Write(moduleBuilder.GetTypeTokenForMemberRef(block.exceptionType));
 						}
 						else
 						{
 							bb.Write(block.filterOffset);
 						}
 					}
 				}
 				else
 				{
 					bb.Write(CorILMethod_Sect_EHTable);
 					bb.Write((byte)(exceptions.Count * 12 + 4));
 					bb.Write((short)0);
 					foreach (ExceptionBlock block in exceptions)
 					{
 						if (block.exceptionType == FAULT)
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_FAULT);
 						}
 						else if (block.filterOffset != 0)
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_FILTER);
 						}
 						else if (block.exceptionType != null)
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_EXCEPTION);
 						}
 						else
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_FINALLY);
 						}
 						bb.Write((short)block.tryOffset);
 						bb.Write((byte)block.tryLength);
 						bb.Write((short)block.handlerOffset);
 						bb.Write((byte)block.handlerLength);
 						if (block.exceptionType != null && block.exceptionType != FAULT)
 						{
 							bb.Write(moduleBuilder.GetTypeTokenForMemberRef(block.exceptionType));
 						}
 						else
 						{
 							bb.Write(block.filterOffset);
 						}
 					}
 					foreach (ExceptionBlock block in exceptions)
 					{
 						if (block.exceptionType == FAULT)
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_FAULT);
 						}
 						else if (block.filterOffset != 0)
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_FILTER);
 						}
 						else if (block.exceptionType != null)
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_EXCEPTION);
 						}
 						else
 						{
 							bb.Write(COR_ILEXCEPTION_CLAUSE_FINALLY);
 						}
 						bb.Write((short)block.tryOffset);
 						bb.Write((byte)block.tryLength);
 						bb.Write((short)block.handlerOffset);
 						bb.Write((byte)block.handlerLength);
 						if (block.exceptionType != null && block.exceptionType != FAULT)
 						{
 							bb.Write(moduleBuilder.GetTypeTokenForMemberRef(block.exceptionType));
 						}
 						else
 						{
 							bb.Write(block.filterOffset);
 						}
 					}
 				}
 			}
 			return rva;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="118" endline="141">
<![CDATA[
 
 		internal int ReadTypeDefOrRef()
 		{
 			int codedIndex;
 			if (bigTypeDefOrRef)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (TypeRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (TypeSpecTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="272" endline="295">
<![CDATA[
 
 		internal int ReadHasConstant()
 		{
 			int codedIndex;
 			if (bigHasConstant)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (FieldTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (ParamTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (PropertyTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="340" endline="363">
<![CDATA[
 
 		internal int ReadHasDeclSecurity()
 		{
 			int codedIndex;
 			if (bigHasDeclSecurity)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (TypeDefTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (MethodDefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (AssemblyTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="408" endline="431">
<![CDATA[
 
 		internal int ReadImplementation()
 		{
 			int codedIndex;
 			if (bigImplementation)
 			{
 				codedIndex = br.ReadInt32();
 			}
 			else
 			{
 				codedIndex = br.ReadUInt16();
 			}
 			switch (codedIndex & 3)
 			{
 				case 0
 					return (FileTable.Index << 24) + (codedIndex >> 2);
 				case 1
 					return (AssemblyRefTable.Index << 24) + (codedIndex >> 2);
 				case 2
 					return (ExportedTypeTable.Index << 24) + (codedIndex >> 2);
 				default
 					throw new BadImageFormatException();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\modifiers.cs" startline="116" endline="135">
<![CDATA[
 
 		//
 		// Used by custom property accessors to check whether @modA is more restrictive than @modB
 		//
 		public static bool IsRestrictedModifier (Modifiers modA, Modifiers modB)
 		{
 			Modifiers flags = 0;
 
 			if ((modB & Modifiers.PUBLIC) != 0) {
 				flags = Modifiers.PROTECTED | Modifiers.INTERNAL | Modifiers.PRIVATE;
 			} else if ((modB & Modifiers.PROTECTED) != 0) {
 				if ((modB & Modifiers.INTERNAL) != 0)
 					flags = Modifiers.PROTECTED | Modifiers.INTERNAL;
 
 				flags |= Modifiers.PRIVATE;
 			} else if ((modB & Modifiers.INTERNAL) != 0)
 				flags = Modifiers.PRIVATE;
 
 			return modB != modA && (modA & (~flags)) == 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2720" endline="2742">
<![CDATA[
 
 		//
 		// Implements identicial simple name and type-name
 		//
 		public Expression ProbeIdenticalTypeName (ResolveContext rc, Expression left, SimpleName name)
 		{
 			var t = left.Type;
 			if (t.Kind == MemberKind.InternalCompilerType || t is ElementTypeSpec || t.Arity > 0)
 				return left;
 
 			// In a member access of the form E.I, if E is a single identifier, and if the meaning of E as a simple-name is
 			// a constant, field, property, local variable, or parameter with the same type as the meaning of E as a type-name
 
 			if (left is MemberExpr || left is VariableReference) {
 				rc.Report.DisableReporting ();
 				Expression identical_type = rc.LookupNamespaceOrType (name.Name, 0, loc, true) as TypeExpr;
 				rc.Report.EnableReporting ();
 				if (identical_type != null && identical_type.Type == left.Type)
 					return identical_type;
 			}
 
 			return left;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2728" endline="2880">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (left == null)
 				return null;
 
 			if ((oper == Operator.Subtraction) && (left is ParenthesizedExpression)) {
 				left = ((ParenthesizedExpression) left).Expr;
 				left = left.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.Type);
 				if (left == null)
 					return null;
 
 				if (left.eclass == ExprClass.Type) {
 					ec.Report.Error (75, loc, "To cast a negative value, you must enclose the value in parentheses");
 					return null;
 				}
 			} else
 				left = left.Resolve (ec);
 
 			if (left == null)
 				return null;
 
 			Constant lc = left as Constant;
 
 			if (lc != null && lc.Type == TypeManager.bool_type &&
 				((oper == Operator.LogicalAnd && lc.IsDefaultValue) ||
 				 (oper == Operator.LogicalOr && !lc.IsDefaultValue))) {
 
 				// FIXME
 				// right.Resolve (ec);
 
 				ec.Report.Warning (429, 4, loc, "Unreachable expression code detected");
 				return left;
 			}
 
 			right = right.Resolve (ec);
 			if (right == null)
 				return null;
 
 			eclass = ExprClass.Value;
 			Constant rc = right as Constant;
 
 			// The conversion rules are ignored in enum context but why
 			if (!ec.HasSet (ResolveContext.Options.EnumScope) && lc != null && rc != null && (TypeManager.IsEnumType (left.Type) || TypeManager.IsEnumType (right.Type))) {
 				lc = EnumLiftUp (ec, lc, rc, loc);
 				if (lc != null)
 					rc = EnumLiftUp (ec, rc, lc, loc);
 			}
 
 			if (rc != null && lc != null) {
 				int prev_e = ec.Report.Errors;
 				Expression e = ConstantFold.BinaryFold (ec, oper, lc, rc, loc);
 				if (e != null)
 					e = e.Resolve (ec);
 
 				if (e != null || ec.Report.Errors != prev_e)
 					return e;
 			}
 
 			// Comparison warnings
 			if ((oper & Operator.ComparisonMask) != 0) {
 				if (left.Equals (right)) {
 					ec.Report.Warning (1718, 3, loc, "A comparison made to same variable. Did you mean to compare something else?");
 				}
 				CheckUselessComparison (ec, lc, right.Type);
 				CheckUselessComparison (ec, rc, left.Type);
 			}
 
 			if (left.Type == InternalType.Dynamic || right.Type == InternalType.Dynamic) {
 				var lt = left.Type;
 				var rt = right.Type;
 				if (lt == TypeManager.void_type || lt == InternalType.MethodGroup || lt == InternalType.AnonymousMethod ||
 					rt == TypeManager.void_type || rt == InternalType.MethodGroup || rt == InternalType.AnonymousMethod) {
 					Error_OperatorCannotBeApplied (ec, left, right);
 					return null;
 				}
 
 				Arguments args;
 
 				//
 				// Special handling for logical boolean operators which require rhs not to be
 				// evaluated based on lhs value
 				//
 				if ((oper & Operator.LogicalMask) != 0) {
 					Expression cond_left, cond_right, expr;
 
 					args = new Arguments (2);
 
 					if (lt == InternalType.Dynamic) {
 						LocalVariable temp = LocalVariable.CreateCompilerGenerated (lt, ec.CurrentBlock, loc);
 
 						var cond_args = new Arguments (1);
 						cond_args.Add (new Argument (new SimpleAssign (temp.CreateReferenceExpression (ec, loc), left).Resolve (ec)));
 
 						//
 						// dynamic && bool => IsFalse (temp = left) ? temp 
 						// dynamic || bool => IsTrue (temp = left) ? temp 
 						//
 						left = temp.CreateReferenceExpression (ec, loc);
 						if (oper == Operator.LogicalAnd) {
 							expr = DynamicUnaryConversion.CreateIsFalse (cond_args, loc);
 							cond_left = left;
 						} else {
 							expr = DynamicUnaryConversion.CreateIsTrue (cond_args, loc);
 							cond_left = left;
 						}
 
 						args.Add (new Argument (left));
 						args.Add (new Argument (right));
 						cond_right = new DynamicExpressionStatement (this, args, loc);
 					} else {
 						LocalVariable temp = LocalVariable.CreateCompilerGenerated (TypeManager.bool_type, ec.CurrentBlock, loc);
 
 						args.Add (new Argument (temp.CreateReferenceExpression (ec, loc).Resolve (ec)));
 						args.Add (new Argument (right));
 						right = new DynamicExpressionStatement (this, args, loc);
 
 						//
 						// bool && dynamic => (temp = left) ? temp && right 
 						// bool || dynamic => (temp = left) ? temp 
 						//
 						if (oper == Operator.LogicalAnd) {
 							cond_left = right;
 							cond_right = temp.CreateReferenceExpression (ec, loc);
 						} else {
 							cond_left = temp.CreateReferenceExpression (ec, loc);
 							cond_right = right;
 						}
 
 						expr = new BooleanExpression (new SimpleAssign (temp.CreateReferenceExpression (ec, loc), left));
 					}
 
 					return new Conditional (expr, cond_left, cond_right, loc).Resolve (ec);
 				}
 
 				args = new Arguments (2);
 				args.Add (new Argument (left));
 				args.Add (new Argument (right));
 				return new DynamicExpressionStatement (this, args, loc).Resolve (ec);
 			}
 
 			if (RootContext.Version >= LanguageVersion.ISO_2 &&
 				((TypeManager.IsNullableType (left.Type) && (right is NullLiteral || TypeManager.IsNullableType (right.Type) || TypeManager.IsValueType (right.Type))) ||
 				(TypeManager.IsValueType (left.Type) && right is NullLiteral) ||
 				(TypeManager.IsNullableType (right.Type) && (left is NullLiteral || TypeManager.IsNullableType (left.Type) || TypeManager.IsValueType (left.Type))) ||
 				(TypeManager.IsValueType (right.Type) && left is NullLiteral))) {
 				var lifted = new Nullable.LiftedBinaryOperator (oper, left, right, loc);
 				lifted.state = state;
 				return lifted.Resolve (ec);
 			}
 
 			return DoResolveCore (ec, left, right);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4023" endline="4091">
<![CDATA[
 
 		//
 		// Tests argument compatibility with the parameter
 		// The possible return values are
 		// 0 - success
 		// 1 - modifier mismatch
 		// 2 - type mismatch
 		// -1 - dynamic binding required
 		//
 		int IsArgumentCompatible (ResolveContext ec, Argument argument, Parameter.Modifier param_mod, TypeSpec parameter)
 		{
 			//
 			// Types have to be identical when ref or out modifer
 			// is used and argument is not of dynamic type
 			//
 			if ((argument.Modifier | param_mod) != 0) {
 				if (argument.Type != parameter) {
 					//
 					// Do full equality check after quick path
 					//
 					if (!TypeSpecComparer.IsEqual (argument.Type, parameter)) {
 						//
 						// Using dynamic for ref/out parameter can still succeed at runtime
 						//
 						if (argument.Type == InternalType.Dynamic && argument.Modifier == 0 && (restrictions & Restrictions.CovariantDelegate) == 0)
 							return -1;
 
 						return 2;
 					}
 				}
 
 				if (argument.Modifier != param_mod) {
 					//
 					// Using dynamic for ref/out parameter can still succeed at runtime
 					//
 					if (argument.Type == InternalType.Dynamic && argument.Modifier == 0 && (restrictions & Restrictions.CovariantDelegate) == 0)
 						return -1;
 
 					return 1;
 				}
 
 			} else {
 				if (argument.Type == InternalType.Dynamic && (restrictions & Restrictions.CovariantDelegate) == 0)
 					return -1;
 
 				//
 				// Deploy custom error reporting for lambda methods. When probing lambda methods
 				// keep all errors reported in separate set and once we are done and no best
 				// candidate found, this set is used to report more details about what was wrong
 				// with lambda body
 				//
 				if (argument.Expr.Type == InternalType.AnonymousMethod) {
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 				}
 
 				if (!Convert.ImplicitConversionExists (ec, argument.Expr, parameter)) {
 					if (lambda_conv_msgs != null) {
 						lambda_conv_msgs.EndSession ();
 					}
 
 					return 2;
 				}
 			}
 
 			return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="236" endline="266">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = this.ModuleBuilder.universe;
 			Type type = customBuilder.Constructor.DeclaringType;
 			if (type == u.System_Runtime_InteropServices_DllImportAttribute)
 			{
 				attributes |= MethodAttributes.PinvokeImpl;
 				SetDllImportPseudoCustomAttribute(customBuilder.DecodeBlob(this.Module.Assembly));
 			}
 			else if (type == u.System_Runtime_CompilerServices_MethodImplAttribute)
 			{
 				SetMethodImplAttribute(customBuilder.DecodeBlob(this.Module.Assembly));
 			}
 			else if (type == u.System_Runtime_InteropServices_PreserveSigAttribute)
 			{
 				implFlags |= MethodImplAttributes.PreserveSig;
 			}
 			else if (type == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= MethodAttributes.SpecialName;
 			}
 			else
 			{
 				if (type == u.System_Security_SuppressUnmanagedCodeSecurityAttribute)
 				{
 					attributes |= MethodAttributes.HasSecurity;
 				}
 				this.ModuleBuilder.SetCustomAttribute(pseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="300" endline="318">
<![CDATA[
 
 		//
 		// Creates alias global namespace
 		//
 		public RootNamespace CreateRootNamespace (string alias)
 		{
 			if (alias == global_ns.Alias) {
 				NamespaceEntry.Error_GlobalNamespaceRedefined (Location.Null, Report);
 				return global_ns;
 			}
 
 			RootNamespace rn;
 			if (!alias_ns.TryGetValue (alias, out rn)) {
 				rn = new RootNamespace (alias);
 				alias_ns.Add (alias, rn);
 			}
 
 			return rn;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3039" endline="3047">
<![CDATA[
 		}
 
 		public override bool IsStatic {
 			get {
 				if (best_candidate != null)
 					return best_candidate.IsStatic;
 
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="187" endline="198">
<![CDATA[
 
 		public override Type[] GetGenericArguments()
 		{
 			if (methodArgs == null)
 			{
 				return method.GetGenericArguments();
 			}
 			else
 			{
 				return (Type[])methodArgs.Clone();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="154" endline="175">
<![CDATA[
 
 		public string Name { get; set; }
 
 		protected override Expression DoResolve (ResolveContext unused)
 		{
 			if (type != null)
 				return expr;
 
 			var opt = ResolveContext.Options.ConstantScope;
 			if (field is EnumMember)
 				opt |= ResolveContext.Options.EnumScope;
 
 			//
 			// Use a context in which the constant was declared and
 			// not the one in which is referenced
 			//
 			var rc = new ResolveContext (field, opt);
 			expr = DoResolveInitializer (rc);
 			type = expr.Type;
 
 			return expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="56" endline="67">
<![CDATA[
 
 		internal int ReadStringIndex()
 		{
 			if (bigStrings)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="68" endline="79">
<![CDATA[
 
 		internal int ReadGuidIndex()
 		{
 			if (bigGuids)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="80" endline="91">
<![CDATA[
 
 		internal int ReadBlobIndex()
 		{
 			if (bigBlobs)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="446" endline="457">
<![CDATA[
 
 		internal int ReadField()
 		{
 			if (bigField)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="458" endline="469">
<![CDATA[
 
 		internal int ReadMethodDef()
 		{
 			if (bigMethodDef)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="470" endline="481">
<![CDATA[
 
 		internal int ReadParam()
 		{
 			if (bigParam)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="482" endline="493">
<![CDATA[
 
 		internal int ReadProperty()
 		{
 			if (bigProperty)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\MetadataReader.cs" startline="494" endline="505">
<![CDATA[
 
 		internal int ReadEvent()
 		{
 			if (bigEvent)
 			{
 				return br.ReadInt32();
 			}
 			else
 			{
 				return br.ReadUInt16();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="812" endline="825">
<![CDATA[
 
 		public ImportedAssemblyDefinition GetAssemblyDefinition (Assembly assembly)
 		{
 			ImportedAssemblyDefinition def;
 			if (!assembly_2_definition.TryGetValue (assembly, out def)) {
 
 				// This can happen in dynamic context only
 				def = new ImportedAssemblyDefinition (assembly, this);
 				assembly_2_definition.Add (assembly, def);
 				def.ReadAttributes ();
 			}
 
 			return def;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="245" endline="263">
<![CDATA[
 
 		#region Properties
 
 		public override TypeSpec CurrentType {
 			get {
 				if (current_type == null) {
 					if (IsGeneric) {
 						//
 						// Switch to inflated version as it's used by all expressions
 						//
 						var targs = CurrentTypeParameters == null ? TypeSpec.EmptyTypes 
 						current_type = spec.MakeGenericType (targs);
 					} else {
 						current_type = spec;
 					}
 				}
 
 				return current_type;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="115" endline="140">
<![CDATA[
 
 		void Parse (CompilationUnit file, ModuleContainer module)
 		{
 			Stream input;
 
 			try {
 				input = File.OpenRead (file.Name);
 			} catch {
 				Report.Error (2001, "Source file `{0}' could not be found", file.Name);
 				return;
 			}
 
 			// Check 'MZ' header
 			if (input.ReadByte () == 77 && input.ReadByte () == 90) {
 				Report.Error (2015, "Source file `{0}' is a binary file and not a text file", file.Name);
 				input.Close ();
 				return;
 			}
 
 			input.Position = 0;
 			SeekableStreamReader reader = new SeekableStreamReader (input, RootContext.Encoding);
 
 			Parse (reader, file, module);
 			reader.Dispose ();
 			input.Close ();
 		}	
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4781" endline="4787">
<![CDATA[
 		}
 
 		public bool IsHoisted {
 			get {
 				IVariableReference hv = InstanceExpression as IVariableReference;
 				return hv != null && hv.IsHoisted;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="499" endline="534">
<![CDATA[
 
 		/// <summary>
 		/// It is called very early therefore can resolve only predefined attributes
 		/// </summary>
 		void ResolveGlobalAttributes ()
 		{
 			if (OptAttributes == null)
 				return;
 
 			if (!OptAttributes.CheckTargets ())
 				return;
 
 			// FIXME
 			var DefaultCharSet_attr = new PredefinedAttribute (this, "System.Runtime.InteropServices", "DefaultCharSetAttribute");
 			DefaultCharSet_attr.Define ();
 			Attribute a = ResolveModuleAttribute (DefaultCharSet_attr);
 			if (a != null) {
 				has_default_charset = true;
 				DefaultCharSet = a.GetCharSetValue ();
 				switch (DefaultCharSet) {
 				case CharSet.Ansi
 				case CharSet.None
 					break;
 				case CharSet.Auto
 					DefaultCharSetType = TypeAttributes.AutoClass;
 					break;
 				case CharSet.Unicode
 					DefaultCharSetType = TypeAttributes.UnicodeClass;
 					break;
 				default
 					Report.Error (1724, a.Location, "Value specified for the argument to `{0}' is not valid", 
 						DefaultCharSet_attr.GetSignatureForError ());
 					break;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9157" endline="9171">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			FieldExpr fe = target as FieldExpr;
 			if (fe != null)
 				args.Add (new Argument (fe.CreateTypeOfExpression ()));
 			else
 				args.Add (new Argument (((PropertyExpr)target).CreateSetterTypeOfExpression ()));
 
 			args.Add (new Argument (source.CreateExpressionTree (ec)));
 			return CreateExpressionFactoryCall (ec,
 				source is CollectionOrObjectInitializers ? "ListBind" 
 				args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="887" endline="902">
<![CDATA[
 
 		public string ParameterDesc (int pos)
 		{
 			if (types == null || types [pos] == null)
 				return ((Parameter)FixedParameters [pos]).GetSignatureForError ();
 
 			string type = TypeManager.CSharpName (types [pos]);
 			if (FixedParameters [pos].HasExtensionMethodModifier)
 				return "this " + type;
 
 			Parameter.Modifier mod = FixedParameters [pos].ModFlags;
 			if (mod == 0)
 				return type;
 
 			return Parameter.GetModifierSignature (mod) + " " + type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1725" endline="1740">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].MethodBody))
 				{
 					records[i].MethodBody = moduleBuilder.ResolvePseudoToken(records[i].MethodBody);
 				}
 				if (moduleBuilder.IsPseudoToken(records[i].MethodDeclaration))
 				{
 					records[i].MethodDeclaration = moduleBuilder.ResolvePseudoToken(records[i].MethodDeclaration);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (moduleBuilder.IsPseudoToken(records[i].MethodBody))
 				{
 					records[i].MethodBody = moduleBuilder.ResolvePseudoToken(records[i].MethodBody);
 				}
 				if (moduleBuilder.IsPseudoToken(records[i].MethodDeclaration))
 				{
 					records[i].MethodDeclaration = moduleBuilder.ResolvePseudoToken(records[i].MethodDeclaration);
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="82" endline="91">
<![CDATA[
 		}
 
 		#endregion
 
 		public Argument Clone (Expression expr)
 		{
 			Argument a = (Argument) MemberwiseClone ();
 			a.Expr = expr;
 			return a;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="210" endline="222">
<![CDATA[
 
 		internal static bool TypeEquals(Type t1, Type t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return false;
 			}
 			return t1.Equals(t2);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3349" endline="3368">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		// Main member define entry
 		//
 		public override bool Define ()
 		{
 			DoMemberTypeIndependentChecks ();
 
 			//
 			// Returns false only when type resolution failed
 			//
 			if (!ResolveMemberType ())
 				return false;
 
 			DoMemberTypeDependentChecks ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="1150" endline="1168">
<![CDATA[
 
 		//
 		// Local report helper to issue correctly ordered members stored in hashtable
 		//
 		static MemberCore GetLaterDefinedMember (MemberSpec a, MemberSpec b)
 		{
 			var mc_a = a.MemberDefinition as MemberCore;
 			var mc_b = b.MemberDefinition as MemberCore;
 			if (mc_a == null)
 				return mc_b;
 
 			if (mc_b == null)
 				return mc_a;
 
 			if (mc_a.Location.File != mc_a.Location.File)
 				return mc_b;
 
 			return mc_b.Location.Row > mc_a.Location.Row ? mc_b 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="71" endline="93">
<![CDATA[
 		
 		static bool IList_To_Array(TypeSpec list, ArrayContainer array)
 		{
 			if (array.Rank != 1 || !list.IsGeneric)
 				return false;
 
 			var open_version = list.GetDefinition ();
 			if ((open_version != TypeManager.generic_ilist_type) &&
 				(open_version != TypeManager.generic_icollection_type) &&
 				(open_version != TypeManager.generic_ienumerable_type))
 				return false;
 
 			var arg_type = list.TypeArguments[0];
 			if (array.Element == arg_type)
 				return true;
 			
 			if (MyEmptyExpr == null)
 				MyEmptyExpr = new EmptyExpression (array.Element);
 			else
 				MyEmptyExpr.SetType (array.Element);
 
 			return ImplicitReferenceConversionExists (MyEmptyExpr, arg_type) || ExplicitReferenceConversionExists (array.Element, arg_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="150" endline="163">
<![CDATA[
 		}
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			if (overload is MethodCore) {
 				caching_flags |= Flags.MethodOverloadsExist;
 				return true;
 			}
 
 			if (overload is AbstractPropertyEventMethod)
 				return true;
 
 			return base.EnableOverloadChecks (overload);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1086" endline="1098">
<![CDATA[
 
 		public static Expression Create (Expression child, TypeSpec type)
 		{
 			Constant c = child as Constant;
 			if (c != null)
 				return new EmptyConstantCast (c, type);
 
 			EmptyCast e = child as EmptyCast;
 			if (e != null)
 				return new EmptyCast (e.child, type);
 
 			return new EmptyCast (child, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="739" endline="774">
<![CDATA[
 
 		/// <summary>
 		/// Tests permitted SecurityAction for assembly or other types
 		/// </summary>
 		protected virtual bool IsSecurityActionValid (bool for_assembly)
 		{
 			SecurityAction action = GetSecurityActionValue ();
 
 			switch (action) {
 #pragma warning disable 618
 			case SecurityAction.Demand
 			case SecurityAction.Assert
 			case SecurityAction.Deny
 			case SecurityAction.PermitOnly
 			case SecurityAction.LinkDemand
 			case SecurityAction.InheritanceDemand
 				if (!for_assembly)
 					return true;
 				break;
 
 			case SecurityAction.RequestMinimum
 			case SecurityAction.RequestOptional
 			case SecurityAction.RequestRefuse
 				if (for_assembly)
 					return true;
 				break;
 #pragma warning restore 618
 
 			default
 				Error_AttributeEmitError ("SecurityAction is out of range");
 				return false;
 			}
 
 			Error_AttributeEmitError (String.Concat ("SecurityAction `", action, "' is not valid for this declaration"));
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="1365" endline="1388">
<![CDATA[
 
 		static string [] AddArgs (string [] args, string [] extra_args)
 		{
 			string [] new_args;
 			new_args = new string [extra_args.Length + args.Length];
 
 			// if args contains '--' we have to take that into account
 			// split args into first half and second half based on '--'
 			// and add the extra_args before --
 			int split_position = Array.IndexOf (args, "--");
 			if (split_position != -1)
 			{
 				Array.Copy (args, new_args, split_position);
 				extra_args.CopyTo (new_args, split_position);
 				Array.Copy (args, split_position, new_args, split_position + extra_args.Length, args.Length - split_position);
 			}
 			else
 			{
 				args.CopyTo (new_args, 0);
 				extra_args.CopyTo (new_args, args.Length);
 			}
 
 			return new_args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="83" endline="104">
<![CDATA[
 
 		public virtual Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			if (this.type == type)
 				return this;
 
 			if (Convert.ImplicitNumericConversion (this, type) == null) 
 				return null;
 
 			bool fail;			
 			object constant_value = TypeManager.ChangeType (GetValue (), type, out fail);
 			if (fail){
 				//
 				// We should always catch the error before this is ever
 				// reached, by calling Convert.ImplicitStandardConversionExists
 				//
 				throw new InternalErrorException ("Missing constant conversion between `{0}' and `{1}'",
 				  TypeManager.CSharpName (Type), TypeManager.CSharpName (type));
 			}
 
 			return CreateConstant (rc, type, constant_value, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1836" endline="1846">
<![CDATA[
 		}
 
 		#endregion
 
 		public Block CreateSwitchBlock (Location start)
 		{
 			// FIXME
 			var new_block = new Block (this, start, start);
 			new_block.IsCompilerGenerated = true;
 			return new_block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2588" endline="2599">
<![CDATA[
 
 		//
 		// FIXME
 		// layout?
 		//
 		protected override TypeAttributes TypeAttr {
 			get {
 				TypeAttributes ta = base.TypeAttr | TypeAttributes.AutoLayout | TypeAttributes.Class;
 				if (IsStatic)
 					ta |= StaticClassAttribute;
 				return ta;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="322" endline="339">
<![CDATA[
 
 		public FieldSpec Mutate (TypeParameterMutator mutator)
 		{
 			var decl = DeclaringType;
 			if (DeclaringType.IsGenericOrParentIsGeneric)
 				decl = mutator.Mutate (decl);
 
 			if (decl == DeclaringType)
 				return this;
 
 			var fs = (FieldSpec) MemberwiseClone ();
 			fs.declaringType = decl;
 			fs.state |= StateFlags.PendingMetaInflate;
 
 			// Gets back FieldInfo in case of metaInfo was inflated
 			fs.metaInfo = MemberCache.GetMember (TypeParameterMutator.GetMemberDeclaringType (DeclaringType), this).metaInfo;
 			return fs;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2758" endline="2764">
<![CDATA[
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			TypeExpr[] ifaces = base.ResolveBaseTypes (out base_class);
 			base_type = TypeManager.value_type;
 			return ifaces;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2355" endline="2362">
<![CDATA[
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				if (default_static_constructor == null)
 					return base.TypeAttr | TypeAttributes.BeforeFieldInit;
 
 				return base.TypeAttr;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="164" endline="172">
<![CDATA[
 
 		public int OpenScope (int start_offset)
 		{
 			if (current_method == null)
 				return 0;
 
 			current_method.StartBlock (CodeBlockEntry.Type.Lexical, start_offset);
 			return 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9042" endline="9057">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			child.Emit (ec);
 
 			var expr_type = child.Type;
 
 			if (expr_type == TypeManager.uint32_type)
 				ec.Emit (OpCodes.Conv_U);
 			else if (expr_type == TypeManager.int64_type)
 				ec.Emit (OpCodes.Conv_Ovf_I);
 			else if (expr_type == TypeManager.uint64_type)
 				ec.Emit (OpCodes.Conv_Ovf_I_Un);
 			else
 				throw new InternalErrorException ("Cannot emit cast to unknown array element type", type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="196" endline="216">
<![CDATA[
 
 		Constant TryReduce (ResolveContext ec, TypeSpec target_type)
 		{
 			if (Type == target_type)
 				return this;
 
 			Constant c;
 			if (TypeManager.IsEnumType (target_type)) {
 				c = TryReduce (ec, EnumSpec.GetUnderlyingType (target_type));
 				if (c == null)
 					return null;
 
 				return new EnumConstant (c, target_type).Resolve (ec);
 			}
 
 			c = ConvertExplicitly (ec.ConstantCheckState, target_type);
 			if (c != null)
 				c = c.Resolve (ec);
 
 			return c;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1995" endline="2011">
<![CDATA[
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			// Type it as string cast
 			if (targetType == TypeManager.object_type || targetType == InternalType.Null)
 				enc.Encode (TypeManager.string_type);
 
 			var ac = targetType as ArrayContainer;
 			if (ac != null) {
 				if (ac.Rank != 1 || ac.Element.IsArray)
 					base.EncodeAttributeValue (rc, enc, targetType);
 				else
 					enc.Encode (uint.MaxValue);
 			} else {
 				enc.Encode (byte.MaxValue);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1464" endline="1480">
<![CDATA[
 
 		public void Encode (string value)
 		{
 			if (value == null) {
 				Encode ((byte) 0xFF);
 				return;
 			}
 
 			var buf = Encoding.UTF8.GetBytes(value);
 			WriteCompressedValue (buf.Length);
 
 			if (pos + buf.Length > buffer.Length)
 				Grow (buf.Length);
 
 			Buffer.BlockCopy (buf, 0, buffer, pos, buf.Length);
 			pos += buf.Length;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="300" endline="318">
<![CDATA[
 
 		private static bool ParseVersion(string str, out Version version)
 		{
 			string[] parts = str.Split('.');
 			if (parts.Length == 4)
 			{
 				ushort major, minor, build, revision;
 				if (ushort.TryParse(parts[0], System.Globalization.NumberStyles.Integer, null, out major)
 					&& ushort.TryParse(parts[1], System.Globalization.NumberStyles.Integer, null, out minor)
 					&& ushort.TryParse(parts[2], System.Globalization.NumberStyles.Integer, null, out build)
 					&& ushort.TryParse(parts[3], System.Globalization.NumberStyles.Integer, null, out revision))
 				{
 					version = new Version(major, minor, build, revision);
 					return true;
 				}
 			}
 			version = null;
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1151" endline="1162">
<![CDATA[
 
 		public override TypeSpec Mutate (TypeParameterMutator mutator)
 		{
 			var me = Element.Mutate (mutator);
 			if (me == Element)
 				return this;
 
 			var mutated = (ElementTypeSpec) MemberwiseClone ();
 			mutated.Element = me;
 			mutated.info = null;
 			return mutated;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="531" endline="540">
<![CDATA[
 
 		public Block LookupBlock (Block from)
 		{
 			Block result;
 			if (!block_map.TryGetValue (from, out result)) {
 				result = (Block) from.Clone (this);
 			}
 
 			return result;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="28" endline="45">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			int counter = QueryBlock.TransparentParameter.Counter;
 
 			Expression e = BuildQueryClause (ec, null, null);
 			if (e != null)
 				e = e.Resolve (ec);
 
 			//
 			// Reset counter in probing mode to ensure that all transparent
 			// identifier anonymous types are created only once
 			//
 			if (ec.IsInProbingMode)
 				QueryBlock.TransparentParameter.Counter = counter;
 
 			return e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="464" endline="477">
<![CDATA[
 
 	static string GetMethodVisibility (MethodBase m)
 	{
 		// itnerfaces have no modifiers here
 		if (m.DeclaringType.IsInterface)
 			return "";
 		
 		if (m.IsPublic)   return "public ";
 		if (m.IsFamily)   return "protected ";
 		if (m.IsPrivate)  return "private ";
 		if (m.IsAssembly) return "internal ";
 			
 		return null;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1034" endline="1040">
<![CDATA[
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var tps = (TypeParameterSpec) MemberwiseClone ();
 			InflateConstraints (inflator, tps);
 			return tps;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1544" endline="1553">
<![CDATA[
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			if (overload is Indexer) {
 				caching_flags |= Flags.MethodOverloadsExist;
 				return true;
 			}
 
 			return base.EnableOverloadChecks (overload);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1204" endline="1215">
<![CDATA[
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			// TODO
 			if (overload is Operator)
 				return overload.EnableOverloadChecks (this);
 
 			if (overload is Indexer)
 				return false;
 
 			return base.EnableOverloadChecks (overload);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="677" endline="690">
<![CDATA[
 
 		static public byte[] ToCapiKeyBlob (AsymmetricAlgorithm keypair, bool includePrivateKey) 
 		{
 			if (keypair == null)
 				throw new ArgumentNullException ("keypair");
 
 			// check between RSA and DSA (and potentially others like DH)
 			if (keypair is RSA)
 				return ToCapiKeyBlob ((RSA)keypair, includePrivateKey);
 			else if (keypair is DSA)
 				return ToCapiKeyBlob ((DSA)keypair, includePrivateKey);
 			else
 				return null;	// TODO
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="123" endline="140">
<![CDATA[
 		
 		bool IsWarningEnabled (int code, int level, Location loc)
 		{
 			if (WarningLevel < level)
 				return false;
 
 			if (IsWarningDisabledGlobally (code))
 				return false;
 
 			if (warning_regions_table == null || loc.IsNull)
 				return true;
 
 			WarningRegions regions;
 			if (!warning_regions_table.TryGetValue (loc.File, out regions))
 				return true;
 
 			return regions.IsWarningEnabled (code, loc.Row);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="812" endline="836">
<![CDATA[
 		}
 
 		/// <summary>
 		///   Records a new namespace for resolving name references
 		/// </summary>
 		public void AddUsing (MemberName name, Location loc)
 		{
 			if (DeclarationFound){
 				Compiler.Report.Error (1529, loc, "A using clause must precede all other namespace elements except extern alias declarations");
 			}
 
 			if (using_clauses == null) {
 				using_clauses = new List<UsingEntry> ();
 			} else {
 				foreach (UsingEntry old_entry in using_clauses) {
 					if (name.Equals (old_entry.MemberName)) {
 						Compiler.Report.SymbolRelatedToPreviousError (old_entry.Location, old_entry.GetSignatureForError ());
 						Compiler.Report.Warning (105, 3, loc, "The using directive for `{0}' appeared previously in this namespace", name.GetSignatureForError ());
 						return;
 					}
 				}
 				foreach (UsingEntry old_entry in using_clauses) {
 					if (name.Equals (old_entry.MemberName)) {
 						Compiler.Report.SymbolRelatedToPreviousError (old_entry.Location, old_entry.GetSignatureForError ());
 						Compiler.Report.Warning (105, 3, loc, "The using directive for `{0}' appeared previously in this namespace", name.GetSignatureForError ());
 						return;
 					}
 				}
 			}
 
 			using_clauses.Add (new UsingEntry (name));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6959" endline="6968">
<![CDATA[
 		}
 
 		public override bool Equals (object obj)
 		{
 			This t = obj as This;
 			if (t == null)
 				return false;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2210" endline="2219">
<![CDATA[
 
 		bool eval_val (string s)
 		{
 			if (s == "true")
 				return true;
 			if (s == "false")
 				return false;
 
 			return file_name.IsConditionalDefined (s);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="104" endline="115">
<![CDATA[
 
 		public static Expression Create (Expression expr)
 		{
 			//
 			// Avoid unwraping and wraping of same type
 			//
 			Wrap wrap = expr as Wrap;
 			if (wrap != null)
 				return wrap.Child;
 
 			return Create (expr, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1104" endline="1111">
<![CDATA[
 
 		public TypeInfo GetSubStruct (string name)
 		{
 			if (struct_info == null)
 				return null;
 
 			return struct_info.GetStructField (name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="696" endline="706">
<![CDATA[
 
 		public TypeSpec GetCoClassAttributeValue ()
 		{
 			if (!arg_resolved)
 				Resolve ();
 
 			if (resolve_error)
 				return null;
 
 			return GetArgumentType ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="164" endline="176">
<![CDATA[
 		}
 
 		private uint DebugDirectoryContentsLength
 		{
 			get
 			{
 				if (moduleBuilder.symbolWriter != null)
 				{
 					IMAGE_DEBUG_DIRECTORY idd = new IMAGE_DEBUG_DIRECTORY();
 					return (uint)SymbolSupport.GetDebugInfo(moduleBuilder.symbolWriter, ref idd).Length;
 				}
 				return 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="383" endline="401">
<![CDATA[
 
 		//
 		// 15.2 Delegate compatibility
 		//
 		public static bool IsTypeCovariant (Expression a, TypeSpec b)
 		{
 			//
 			// For each value parameter (a parameter with no ref or out modifier), an 
 			// identity conversion or implicit reference conversion exists from the
 			// parameter type in D to the corresponding parameter type in M
 			//
 			if (a.Type == b)
 				return true;
 
 			if (RootContext.Version == LanguageVersion.ISO_1)
 				return false;
 
 			return Convert.ImplicitReferenceConversionExists (a, b);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1937" endline="1956">
<![CDATA[
 
 		//
 		// Creates unresolved reduce expression. The original expression has to be
 		// already resolved
 		//
 		public static Expression Create (Expression expr, Expression original_expr)
 		{
 			Constant c = expr as Constant;
 			if (c != null)
 				return Create (c, original_expr);
 
 			ExpressionStatement s = expr as ExpressionStatement;
 			if (s != null)
 				return Create (s, original_expr);
 
 			if (expr.eclass == ExprClass.Unresolved)
 				throw new ArgumentException ("Unresolved expression");
 
 			return new ReducedExpression (expr, original_expr);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5577" endline="5599">
<![CDATA[
 
 		//
 		// Checks whether the type is an interface that has the
 		// [ComImport, CoClass] attributes and must be treated
 		// specially
 		//
 		public Expression CheckComImport (ResolveContext ec)
 		{
 			if (!type.IsInterface)
 				return null;
 
 			//
 			// Turn the call into
 			// (the-interface-stated) (new class-referenced-in-coclassattribute ())
 			//
 			var real_class = type.MemberDefinition.GetAttributeCoClass ();
 			if (real_class == null)
 				return null;
 
 			New proxy = new New (new TypeExpression (real_class, loc), arguments, loc);
 			Cast cast = new Cast (new TypeExpression (type, loc), proxy, loc);
 			return cast.Resolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2338" endline="2354">
<![CDATA[
 
 		public override IList<MethodSpec> LookupExtensionMethod (TypeSpec extensionType, string name, int arity, ref NamespaceEntry scope)
 		{
 			DeclSpace top_level = Parent;
 			if (top_level != null) {
 				while (top_level.Parent != null)
 					top_level = top_level.Parent;
 				while (top_level.Parent != null)
 					top_level = top_level.Parent;
 
 				var candidates = NamespaceEntry.NS.LookupExtensionMethod (extensionType, this, name, arity);
 				if (candidates != null) {
 					scope = NamespaceEntry;
 					return candidates;
 				}
 			}
 
 			return NamespaceEntry.LookupExtensionMethod (extensionType, name, arity, ref scope);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2487" endline="2525">
<![CDATA[
 
 		// at least one of 'left' or 'right' is an enumeration constant (EnumConstant or SideEffectConstant or ...)
 		// if 'left' is not an enumeration constant, create one from the type of 'right'
 		Constant EnumLiftUp (ResolveContext ec, Constant left, Constant right, Location loc)
 		{
 			switch (oper) {
 			case Operator.BitwiseOr
 			case Operator.BitwiseAnd
 			case Operator.ExclusiveOr
 			case Operator.Equality
 			case Operator.Inequality
 			case Operator.LessThan
 			case Operator.LessThanOrEqual
 			case Operator.GreaterThan
 			case Operator.GreaterThanOrEqual
 				if (TypeManager.IsEnumType (left.Type))
 					return left;
 				
 				if (left.IsZeroInteger)
 					return left.TryReduce (ec, right.Type, loc);
 				
 				break;
 				
 			case Operator.Addition
 			case Operator.Subtraction
 				return left;
 				
 			case Operator.Multiply
 			case Operator.Division
 			case Operator.Modulus
 			case Operator.LeftShift
 			case Operator.RightShift
 				if (TypeManager.IsEnumType (right.Type) || TypeManager.IsEnumType (left.Type))
 					break;
 				return left;
 			}
 			Error_OperatorCannotBeApplied (ec, this.left, this.right);
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="47" endline="58">
<![CDATA[
 
 		internal int PseudoToken
 		{
 			get
 			{
 				if (lazyPseudoToken == 0)
 				{
 					// we lazily create the token, because if we don't need it we don't want the token fixup cost
 					lazyPseudoToken = moduleBuilder.AllocPseudoToken();
 				}
 				return lazyPseudoToken;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="792" endline="798">
<![CDATA[
 
 		public void EmitWriteLine(string text)
 		{
 			Universe u = moduleBuilder.universe;
 			Emit(OpCodes.Ldstr, text);
 			Emit(OpCodes.Call, u.Import(typeof(Console)).GetMethod("WriteLine", new Type[] { u.System_String }));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="695" endline="714">
<![CDATA[
 	}
 
 	sealed class InterfaceImplTable 
 	{
 		internal const int Index = 0x09;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Interface;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].Interface = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1093" endline="1112">
<![CDATA[
 	}
 
 	sealed class FieldMarshalTable 
 	{
 		internal const int Index = 0x0D;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int NativeType;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasFieldMarshal();
 				records[i].NativeType = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasFieldMarshal();
 				records[i].NativeType = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1303" endline="1322">
<![CDATA[
 	}
 
 	sealed class FieldLayoutTable 
 	{
 		internal const int Index = 0x10;
 
 		internal struct Record
 		{
 			internal int Offset;
 			internal int Field;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1392" endline="1411">
<![CDATA[
 	}
 
 	sealed class EventMapTable 
 	{
 		internal const int Index = 0x12;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int EventList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].EventList = mr.ReadEvent();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].EventList = mr.ReadEvent();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1470" endline="1489">
<![CDATA[
 	}
 
 	sealed class PropertyMapTable 
 	{
 		internal const int Index = 0x15;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int PropertyList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].PropertyList = mr.ReadProperty();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadTypeDef();
 				records[i].PropertyList = mr.ReadProperty();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1874" endline="1893">
<![CDATA[
 	}
 
 	sealed class FieldRVATable 
 	{
 		internal const int Index = 0x1D;
 
 		internal struct Record
 		{
 			internal int RVA;
 			internal int Field;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].Field = mr.ReadField();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2218" endline="2237">
<![CDATA[
 	}
 
 	sealed class NestedClassTable 
 	{
 		internal const int Index = 0x29;
 
 		internal struct Record
 		{
 			internal int NestedClass;
 			internal int EnclosingClass;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].NestedClass = mr.ReadTypeDef();
 				records[i].EnclosingClass = mr.ReadTypeDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].NestedClass = mr.ReadTypeDef();
 				records[i].EnclosingClass = mr.ReadTypeDef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2382" endline="2401">
<![CDATA[
 	}
 
 	sealed class MethodSpecTable 
 	{
 		internal const int Index = 0x2B;
 
 		internal struct Record
 		{
 			internal int Method;
 			internal int Instantiation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Method = mr.ReadMethodDefOrRef();
 				records[i].Instantiation = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Method = mr.ReadMethodDefOrRef();
 				records[i].Instantiation = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2443" endline="2462">
<![CDATA[
 	}
 
 	sealed class GenericParamConstraintTable 
 	{
 		internal const int Index = 0x2C;
 
 		internal struct Record
 		{
 			internal int Owner;
 			internal int Constraint;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Owner = mr.ReadGenericParam();
 				records[i].Constraint = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Owner = mr.ReadGenericParam();
 				records[i].Constraint = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="119" endline="129">
<![CDATA[
 		}
 
 		internal void Write(MetadataWriter mw, uint rva)
 		{
 			foreach (int offset in linkOffsets)
 			{
 				bb.Position = offset;
 				bb.Write(bb.GetInt32AtCurrentPosition() + (int)rva);
 			}
 			foreach (int offset in linkOffsets)
 			{
 				bb.Position = offset;
 				bb.Write(bb.GetInt32AtCurrentPosition() + (int)rva);
 			}
 			mw.Write(bb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3886" endline="3896">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Switch target = (Switch) t;
 
 			target.Expr = Expr.Clone (clonectx);
 			target.Sections = new List<SwitchSection> ();
 			foreach (SwitchSection ss in Sections){
 				target.Sections.Add (ss.Clone (clonectx));
 			}
 			foreach (SwitchSection ss in Sections){
 				target.Sections.Add (ss.Clone (clonectx));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="400" endline="410">
<![CDATA[
 
 		public LocalBuilder DeclareLocal(Type localType, bool pinned)
 		{
 			LocalBuilder local = new LocalBuilder(localType, locals.Count, pinned);
 			locals.Add(local);
 			if (scope != null)
 			{
 				scope.locals.Add(local);
 			}
 			return local;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="589" endline="595">
<![CDATA[
 
 		public Module __AddModule(RawModule module)
 		{
 			Module mod = module.ToModule(this);
 			addedModules.Add(mod);
 			return mod;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="142" endline="157">
<![CDATA[
 		}
 
 		public override GenericParameterAttributes GenericParameterAttributes
 		{
 			get
 			{
 				if (type != null)
 				{
 					type.CheckBaked();
 				}
 				else
 				{
 					method.CheckBaked();
 				}
 				return attr;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="229" endline="244">
<![CDATA[
 
 		private void WriteData(ByteBuffer bb)
 		{
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					bb.Write(entry.Data);
 					bb.Align(4);
 				}
 				else
 				{
 					entry.WriteData(bb);
 				}
 			}
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					bb.Write(entry.Data);
 					bb.Align(4);
 				}
 				else
 				{
 					entry.WriteData(bb);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1278" endline="1288">
<![CDATA[
 
 		public TypeSpec Mutate (TypeSpec ts)
 		{
 			TypeSpec value;
 			if (mutated_typespec.TryGetValue (ts, out value))
 				return value;
 
 			value = ts.Mutate (this);
 			mutated_typespec.Add (ts, value);
 			return value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="109" endline="120">
<![CDATA[
 
 		protected override bool DoResolveParameters (ResolveContext rc)
 		{
 			//
 			// Only explicit parameters can be resolved at this point
 			//
 			if (HasExplicitParameters) {
 				return Parameters.Resolve (rc);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="242" endline="253">
<![CDATA[
 
 		public void AddAttributes (List<Attribute> attrs, IMemberContext context)
 		{
 			foreach (Attribute a in attrs)
 				a.AttachTo (this, context);
 			foreach (Attribute a in attrs)
 				a.AttachTo (this, context);
 
 			if (attributes == null) {
 				attributes = new Attributes (attrs);
 				return;
 			}
 			attributes.AddAttributes (attrs);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="61" endline="87">
<![CDATA[
 
 		private AssemblyName GetNameImpl(ref AssemblyTable.Record rec)
 		{
 			AssemblyName name = new AssemblyName();
 			name.Name = manifestModule.GetString(rec.Name);
 			name.Version = new Version(rec.MajorVersion, rec.MinorVersion, rec.BuildNumber, rec.RevisionNumber);
 			if (rec.PublicKey != 0)
 			{
 				name.SetPublicKey(manifestModule.GetBlobCopy(rec.PublicKey));
 			}
 			else
 			{
 				name.SetPublicKey(Empty<byte>.Array);
 			}
 			if (rec.Culture != 0)
 			{
 				name.CultureInfo = new System.Globalization.CultureInfo(manifestModule.GetString(rec.Culture));
 			}
 			else
 			{
 				name.CultureInfo = System.Globalization.CultureInfo.InvariantCulture;
 			}
 			name.HashAlgorithm = (AssemblyHashAlgorithm)rec.HashAlgId;
 			name.CodeBase = this.CodeBase;
 			name.Flags = (AssemblyNameFlags)rec.Flags;
 			return name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="639" endline="659">
<![CDATA[
 
 		protected void Print (AbstractMessage msg, TextWriter output)
 		{
 			StringBuilder txt = new StringBuilder ();
 			if (!msg.Location.IsNull) {
 				txt.Append (msg.Location.ToString ());
 				txt.Append (" ");
 			}
 
 			txt.AppendFormat ("{0} CS{1
 
 			if (!msg.IsWarning)
 				output.WriteLine (FormatText (txt.ToString ()));
 			else
 				output.WriteLine (txt.ToString ());
 
 			if (msg.RelatedSymbols != null) {
 				foreach (string s in msg.RelatedSymbols)
 					output.WriteLine (s + msg.MessageType + ")");
 				foreach (string s in msg.RelatedSymbols)
 					output.WriteLine (s + msg.MessageType + ")");
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1270" endline="1278">
<![CDATA[
 
 		public Attributes Clone ()
 		{
 			var al = new List<Attribute> (Attrs.Count);
 			foreach (Attribute a in Attrs)
 				al.Add (a.Clone ());
 			foreach (Attribute a in Attrs)
 				al.Add (a.Clone ());
 
 			return new Attributes (al);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7328" endline="7341">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			bool is_generic = member.DeclaringType.IsGenericOrParentIsGeneric;
 			MethodSpec mi;
 			if (is_generic) {
 				mi = TypeFromHandleGeneric;
 				ec.Emit (OpCodes.Ldtoken, member.DeclaringType);
 			} else {
 				mi = TypeFromHandle;
 			}
 
 			ec.Emit (OpCodes.Call, mi);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4680" endline="4715">
<![CDATA[
 		}
 
 		#endregion
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (IsGeneral)
 				ec.BeginCatchBlock (TypeManager.object_type);
 			else
 				ec.BeginCatchBlock (CatchType);
 
 			if (li != null) {
 				li.CreateBuilder (ec);
 
 				//
 				// Special case hoisted catch variable, we have to use a temporary variable
 				// to pass via anonymous storey initialization with the value still on top
 				// of the stack
 				//
 				if (li.HoistedVariant != null) {
 					LocalTemporary lt = new LocalTemporary (li.Type);
 					SymbolWriter.OpenCompilerGeneratedBlock (ec);
 					lt.Store (ec);
 					SymbolWriter.CloseCompilerGeneratedBlock (ec);
 
 					// switch to assigning from the temporary variable and not from top of the stack
 					assign.UpdateSource (lt);
 				}
 			} else {
 				SymbolWriter.OpenCompilerGeneratedBlock (ec);
 				ec.Emit (OpCodes.Pop);
 				SymbolWriter.CloseCompilerGeneratedBlock (ec);
 			}
 
 			Block.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.cs" startline="1214" endline="1220">
<![CDATA[
   protected string[] yyExpecting (int state) {
     int [] tokens = yyExpectingTokens (state);
     string [] result = new string[tokens.Length];
     for (int n = 0; n < tokens.Length;  n++)
       result[n++] = yyNames[tokens [n]];
     for (int n = 0; n < tokens.Length;  n++)
       result[n++] = yyNames[tokens [n]];
     return result;
   }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="446" endline="457">
<![CDATA[
 
 		void HackCorlibEnums ()
 		{
 			if (RootContext.StdLib)
 				return;
 
 			// Another Mono corlib HACK
 			// mono_class_layout_fields requires to have enums created
 			// before creating a class which used the enum for any of its fields
 			foreach (var e in hack_corlib_enums)
 				e.CloseType ();
 			foreach (var e in hack_corlib_enums)
 				e.CloseType ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="209" endline="228">
<![CDATA[
 
 		private void WriteResourceDataEntries(ByteBuffer bb, List<int> linkOffsets, ref int offset)
 		{
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					linkOffsets.Add(bb.Position);
 					bb.Write(offset);
 					bb.Write(entry.Data.Length);
 					bb.Write(0);	// code page
 					bb.Write(0);	// reserved
 					offset += (entry.Data.Length + 3) & ~3;
 				}
 				else
 				{
 					entry.WriteResourceDataEntries(bb, linkOffsets, ref offset);
 				}
 			}
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (entry.Data != null)
 				{
 					linkOffsets.Add(bb.Position);
 					bb.Write(offset);
 					bb.Write(entry.Data.Length);
 					bb.Write(0);	// code page
 					bb.Write(0);	// reserved
 					offset += (entry.Data.Length + 3) & ~3;
 				}
 				else
 				{
 					entry.WriteResourceDataEntries(bb, linkOffsets, ref offset);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="581" endline="597">
<![CDATA[
 
 		internal void WriteData (MyBinaryWriter bw)
 		{
 			DataOffset = (int) bw.BaseStream.Position;
 			bw.WriteLeb128 (source.Index);
 
 			int count_includes = include_files != null ? include_files.Count 
 			bw.WriteLeb128 (count_includes);
 			if (include_files != null) {
 				foreach (SourceFileEntry entry in include_files)
 					bw.WriteLeb128 (entry.Index);
 				foreach (SourceFileEntry entry in include_files)
 					bw.WriteLeb128 (entry.Index);
 			}
 
 			bw.WriteLeb128 (namespaces.Count);
 			foreach (NamespaceEntry ns in namespaces)
 				ns.Write (file, bw);
 			foreach (NamespaceEntry ns in namespaces)
 				ns.Write (file, bw);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="869" endline="920">
<![CDATA[
 
 		private string docfilename;
 
 		//
 		// Used to create element which helps well-formedness checking.
 		//
 		public XmlDocument XmlDocumentation;
 
 		//
 		// The output for XML documentation.
 		//
 		public XmlWriter XmlCommentOutput;
 
 		//
 		// Stores XmlDocuments that are included in XML documentation.
 		// Keys are included filenames, values are XmlDocuments.
 		//
 		public Dictionary<string, XmlDocument> StoredDocuments = new Dictionary<string, XmlDocument> ();
 
 		//
 		// Outputs XML documentation comment from tokenized comments.
 		//
 		public bool OutputDocComment (string asmfilename, Report Report)
 		{
 			XmlTextWriter w = null;
 			try {
 				w = new XmlTextWriter (docfilename, null);
 				w.Indentation = 4;
 				w.Formatting = Formatting.Indented;
 				w.WriteStartDocument ();
 				w.WriteStartElement ("doc");
 				w.WriteStartElement ("assembly");
 				w.WriteStartElement ("name");
 				w.WriteString (Path.ChangeExtension (asmfilename, null));
 				w.WriteEndElement (); // name
 				w.WriteEndElement (); // assembly
 				w.WriteStartElement ("members");
 				XmlCommentOutput = w;
 				GenerateDocComment (Report);
 				w.WriteFullEndElement (); // members
 				w.WriteEndElement ();
 				w.WriteWhitespace (Environment.NewLine);
 				w.WriteEndDocument ();
 				return true;
 			} catch (Exception ex) {
 				Report.Error (1569, "Error generating XML documentation file `{0}' (`{1}')", docfilename, ex.Message);
 				return false;
 			} finally {
 				if (w != null)
 					w.Close ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="702" endline="723">
<![CDATA[
 
 		internal void WriteData (MyBinaryWriter bw)
 		{
 			DataOffset = (int) bw.BaseStream.Position;
 			bw.Write (file_name);
 
 			if (guid == null) {
 				guid = Guid.NewGuid ().ToByteArray ();
 				try {
 					using (FileStream fs = new FileStream (file_name, FileMode.Open, FileAccess.Read)) {
 						MD5 md5 = MD5.Create ();
 						hash = md5.ComputeHash (fs);
 					}
 				} catch {
 					hash = new byte [16];
 				}
 			}
 
 			bw.Write (guid);
 			bw.Write (hash);
 			bw.Write ((byte) (auto_generated ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="484" endline="505">
<![CDATA[
 	}
 
 	sealed class TypeRefTable 
 	{
 		internal const int Index = 0x01;
 
 		internal struct Record
 		{
 			internal int ResolutionScope;
 			internal int TypeName;
 			internal int TypeNameSpace;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].ResolutionScope = mr.ReadResolutionScope();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNameSpace = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].ResolutionScope = mr.ReadResolutionScope();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNameSpace = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="575" endline="596">
<![CDATA[
 	}
 
 	sealed class FieldTable 
 	{
 		internal const int Index = 0x04;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal int Name;
 			internal int Signature;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="660" endline="681">
<![CDATA[
 	}
 
 	sealed class ParamTable 
 	{
 		internal const int Index = 0x08;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal short Sequence;
 			internal int Name;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Sequence = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Sequence = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="767" endline="788">
<![CDATA[
 	}
 
 	sealed class MemberRefTable 
 	{
 		internal const int Index = 0x0A;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int Name;
 			internal int Signature;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadMemberRefParent();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadMemberRefParent();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="833" endline="854">
<![CDATA[
 	}
 
 	sealed class ConstantTable 
 	{
 		internal const int Index = 0x0B;
 
 		internal struct Record
 		{
 			internal short Type;
 			internal int Parent;
 			internal int Value;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Type = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasConstant();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Type = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasConstant();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="965" endline="986">
<![CDATA[
 	}
 
 	sealed class CustomAttributeTable 
 	{
 		internal const int Index = 0x0C;
 
 		internal struct Record
 		{
 			internal int Parent;
 			internal int Type;
 			internal int Value;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasCustomAttribute();
 				records[i].Type = mr.ReadCustomAttributeType();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Parent = mr.ReadHasCustomAttribute();
 				records[i].Type = mr.ReadCustomAttributeType();
 				records[i].Value = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1156" endline="1177">
<![CDATA[
 	}
 
 	sealed class DeclSecurityTable 
 	{
 		internal const int Index = 0x0E;
 
 		internal struct Record
 		{
 			internal short Action;
 			internal int Parent;
 			internal int PermissionSet;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Action = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasDeclSecurity();
 				records[i].PermissionSet = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Action = mr.ReadInt16();
 				records[i].Parent = mr.ReadHasDeclSecurity();
 				records[i].PermissionSet = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1256" endline="1265">
<![CDATA[
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].PackingSize = mr.ReadInt16();
 				records[i].ClassSize = mr.ReadInt32();
 				records[i].Parent = mr.ReadTypeDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].PackingSize = mr.ReadInt16();
 				records[i].ClassSize = mr.ReadInt32();
 				records[i].Parent = mr.ReadTypeDef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1429" endline="1450">
<![CDATA[
 	}
 
 	sealed class EventTable 
 	{
 		internal const int Index = 0x14;
 
 		internal struct Record
 		{
 			internal short EventFlags;
 			internal int Name;
 			internal int EventType;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].EventFlags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].EventType = mr.ReadTypeDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].EventFlags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].EventType = mr.ReadTypeDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1507" endline="1528">
<![CDATA[
 	}
 
 	sealed class PropertyTable 
 	{
 		internal const int Index = 0x17;
 
 		internal struct Record
 		{
 			internal short Flags;
 			internal int Name;
 			internal int Type;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Type = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Type = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1548" endline="1577">
<![CDATA[
 	}
 
 	sealed class MethodSemanticsTable 
 	{
 		internal const int Index = 0x18;
 
 		// semantics
 		internal const short Setter = 0x0001;
 		internal const short Getter = 0x0002;
 		internal const short Other = 0x0004;
 		internal const short AddOn = 0x0008;
 		internal const short RemoveOn = 0x0010;
 		internal const short Fire = 0x0020;
 
 		internal struct Record
 		{
 			internal short Semantics;
 			internal int Method;
 			internal int Association;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Semantics = mr.ReadInt16();
 				records[i].Method = mr.ReadMethodDef();
 				records[i].Association = mr.ReadHasSemantics();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Semantics = mr.ReadInt16();
 				records[i].Method = mr.ReadMethodDef();
 				records[i].Association = mr.ReadHasSemantics();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1684" endline="1705">
<![CDATA[
 	}
 
 	sealed class MethodImplTable 
 	{
 		internal const int Index = 0x19;
 
 		internal struct Record
 		{
 			internal int Class;
 			internal int MethodBody;
 			internal int MethodDeclaration;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].MethodBody = mr.ReadMethodDefOrRef();
 				records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Class = mr.ReadTypeDef();
 				records[i].MethodBody = mr.ReadMethodDefOrRef();
 				records[i].MethodDeclaration = mr.ReadMethodDefOrRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2071" endline="2092">
<![CDATA[
 	}
 
 	sealed class FileTable 
 	{
 		internal const int Index = 0x26;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int Name;
 			internal int HashValue;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="94" endline="104">
<![CDATA[
 
 		public ImportedModuleDefinition ImportModule (Module module, RootNamespace targetNamespace)
 		{
 			var module_definition = new ImportedModuleDefinition (module, this);
 			module_definition.ReadAttributes ();
 
 			var all_types = module.GetTypes ();
 			ImportTypes (all_types, targetNamespace, false);
 
 			return module_definition;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="38" endline="47">
<![CDATA[
 		{
 			int pos = mw.Position;
 			WriteImpl(mw);
 			Debug.Assert(mw.Position == pos + unalignedlength);
 			int align = Length - unalignedlength;
 			for (int i = 0; i < align; i++)
 			{
 				mw.Write((byte)0);
 			}
 			for (int i = 0; i < align; i++)
 			{
 				mw.Write((byte)0);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="970" endline="977">
<![CDATA[
 
 		public Expression GetParameterDefaultValue ()
 		{
 			if (PosArguments == null)
 				return null;
 
 			return PosArguments[0].Expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1238" endline="1245">
<![CDATA[
 			get {
 				if (is_generic)
 					return true;
 				else if (Parent != null)
 					return Parent.IsGeneric;
 				else
 					return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="570" endline="584">
<![CDATA[
 		}
 
 		//
 		// Resolves all type parameter constraints
 		//
 		public bool ResolveConstraints (IMemberContext context)
 		{
 			if (constraints != null)
 				return constraints.Resolve (context, this);
 
 			if (spec.BaseType == null)
 				spec.BaseType = TypeManager.object_type;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="525" endline="535">
<![CDATA[
 
 		Expression LiftExpression (ResolveContext ec, Expression expr)
 		{
 			TypeExpr lifted_type = new NullableType (expr.Type, expr.Location);
 			lifted_type = lifted_type.ResolveAsTypeTerminal (ec, false);
 			if (lifted_type == null)
 				return null;
 
 			expr.Type = lifted_type.Type;
 			return expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="147" endline="156">
<![CDATA[
 		}
 
 		public EventToken GetEventToken()
 		{
 			if (lazyPseudoToken == 0)
 			{
 				lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 			}
 			return new EventToken(lazyPseudoToken);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1360" endline="1369">
<![CDATA[
 
 		internal void Write (MonoSymbolFile file, MyBinaryWriter bw)
 		{
 			bw.Write (Name);
 			bw.WriteLeb128 (Index);
 			bw.WriteLeb128 (Parent);
 			bw.WriteLeb128 (UsingClauses.Length);
 			foreach (string uc in UsingClauses)
 				bw.Write (uc);
 			foreach (string uc in UsingClauses)
 				bw.Write (uc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4595" endline="4624">
<![CDATA[
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Report.Debug (64, "VARIABLE EMIT", this, Variable, type, IsRef, loc);
 
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.Emit (ec, leave_copy);
 				return;
 			}
 
 			EmitLoad (ec);
 
 			if (IsRef) {
 				//
 				// If we are a reference, we loaded on the stack a pointer
 				// Now lets load the real value
 				//
 				ec.EmitLoadFromPtr (type);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1409" endline="1417">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakeByRefType ();
 			}
 
 			return info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1446" endline="1454">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				info = Element.GetMetaInfo ().MakePointerType ();
 			}
 
 			return info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="906" endline="927">
<![CDATA[
 				String.Format (
 					"CloneTo not implemented for expression {0}", this.GetType ()));
 		}
 
 		//
 		// Clones an expression created by the parser.
 		//
 		// We only support expressions created by the parser so far, not
 		// expressions that have been resolved (many more classes would need
 		// to implement CloneTo).
 		//
 		// This infrastructure is here merely for Lambda expressions which
 		// compile the same code using different type values for the same
 		// arguments to find the correct overload
 		//
 		public virtual Expression Clone (CloneContext clonectx)
 		{
 			Expression cloned = (Expression) MemberwiseClone ();
 			CloneTo (clonectx, cloned);
 
 			return cloned;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="71" endline="83">
<![CDATA[
 
 		//
 		// This routine must be overrided in derived classes and make copies
 		// of all the data that might be modified if resolved
 		// 
 		protected abstract void CloneTo (CloneContext clonectx, Statement target);
 
 		public Statement Clone (CloneContext clonectx)
 		{
 			Statement s = (Statement) this.MemberwiseClone ();
 			CloneTo (clonectx, s);
 			return s;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="257" endline="263">
<![CDATA[
 		}
 
 		Expression IParameterData.DefaultValue {
 			get {
 				var expr = default_expr as DefaultParameterValueExpression;
 				return expr == null ? default_expr 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="106" endline="117">
<![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="118" endline="129">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isStatic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="124" endline="135">
<![CDATA[
 		}
 
 		internal override bool IsPublic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isPublic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="136" endline="147">
<![CDATA[
 		}
 
 		internal override bool IsStatic
 		{
 			get
 			{
 				if (!flagsCached)
 				{
 					ComputeFlags();
 				}
 				return isStatic;
 			}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6266" endline="6274">
<![CDATA[
 
 Block
 end_block (Location loc)
 {
 	Block retval = current_block.Explicit;
 	retval.SetEndLocation (loc);
 	current_block = retval.Parent;
 	return retval;
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1911" endline="1923">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder, int sdataRVA)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].RVA += sdataRVA;
 				if (moduleBuilder.IsPseudoToken(records[i].Field))
 				{
 					records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				records[i].RVA += sdataRVA;
 				if (moduleBuilder.IsPseudoToken(records[i].Field))
 				{
 					records[i].Field = moduleBuilder.ResolvePseudoToken(records[i].Field);
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="873" endline="891">
<![CDATA[
 
 		internal Stream GetManifestResourceStream(string resourceName)
 		{
 			for (int i = 0; i < ManifestResource.records.Length; i++)
 			{
 				if (resourceName == GetString(ManifestResource.records[i].Name))
 				{
 					if (ManifestResource.records[i].Implementation != 0x26000000)
 					{
 						throw new NotImplementedException();
 					}
 					SeekRVA((int)cliHeader.ResourcesRVA + ManifestResource.records[i].Offset);
 					BinaryReader br = new BinaryReader(stream);
 					int length = br.ReadInt32();
 					return new MemoryStream(br.ReadBytes(length));
 				}
 			}
 			for (int i = 0; i < ManifestResource.records.Length; i++)
 			{
 				if (resourceName == GetString(ManifestResource.records[i].Name))
 				{
 					if (ManifestResource.records[i].Implementation != 0x26000000)
 					{
 						throw new NotImplementedException();
 					}
 					SeekRVA((int)cliHeader.ResourcesRVA + ManifestResource.records[i].Offset);
 					BinaryReader br = new BinaryReader(stream);
 					int length = br.ReadInt32();
 					return new MemoryStream(br.ReadBytes(length));
 				}
 			}
 			throw new FileNotFoundException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="86" endline="97">
<![CDATA[
 
 		public override FieldInfo[] __GetDeclaredFields()
 		{
 			int field = module.TypeDef.records[index].FieldList - 1;
 			int end = module.TypeDef.records.Length > index + 1 ? module.TypeDef.records[index + 1].FieldList - 1 
 			FieldInfo[] fields = new FieldInfo[end - field];
 			for (int i = 0; field < end; i++, field++)
 			{
 				fields[i] = module.GetFieldAt(this, field);
 			}
 			for (int i = 0; field < end; i++, field++)
 			{
 				fields[i] = module.GetFieldAt(this, field);
 			}
 			return fields;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="113" endline="124">
<![CDATA[
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			int method = module.TypeDef.records[index].MethodList - 1;
 			int end = module.TypeDef.records.Length > index + 1 ? module.TypeDef.records[index + 1].MethodList - 1 
 			MethodBase[] methods = new MethodBase[end - method];
 			for (int i = 0; method < end; method++, i++)
 			{
 				methods[i] = module.GetMethodAt(this, method);
 			}
 			for (int i = 0; method < end; method++, i++)
 			{
 				methods[i] = module.GetMethodAt(this, method);
 			}
 			return methods;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8102" endline="8117">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expr = Expr.Resolve (ec);
 			if (Expr == null)
 				return null;
 
 			type = Expr.Type;
 
 			// TODO
 			var res = CreateAccessExpression (ec);
 			if (res == null)
 				return null;
 
 			return res.Resolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2281" endline="2305">
<![CDATA[
 
 		/// <summary>
 		/// Defines the default constructors 
 		/// </summary>
 		protected void DefineDefaultConstructor (bool is_static)
 		{
 			// The default instance constructor is public
 			// If the class is abstract, the default constructor is protected
 			// The default static constructor is private
 
 			Modifiers mods;
 			if (is_static) {
 				mods = Modifiers.STATIC | Modifiers.PRIVATE;
 			} else {
 				mods = ((ModFlags & Modifiers.ABSTRACT) != 0) ? Modifiers.PROTECTED 
 			}
 
 			Constructor c = new Constructor (this, MemberName.Name, mods,
 				null, ParametersCompiled.EmptyReadOnlyParameters,
 				new GeneratedBaseInitializer (Location),
 				Location);
 			
 			AddConstructor (c);
 			c.Block = new ToplevelBlock (Compiler, ParametersCompiled.EmptyReadOnlyParameters, Location);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="504" endline="529">
<![CDATA[
 
 		/// <summary>
 		/// Returns instance of ObsoleteAttribute for this MemberCore
 		/// </summary>
 		public virtual ObsoleteAttribute GetAttributeObsolete ()
 		{
 			if ((caching_flags & (Flags.Obsolete_Undetected | Flags.Obsolete)) == 0)
 				return null;
 
 			caching_flags &= ~Flags.Obsolete_Undetected;
 
 			if (OptAttributes == null)
 				return null;
 
 			Attribute obsolete_attr = OptAttributes.Search (Module.PredefinedAttributes.Obsolete);
 			if (obsolete_attr == null)
 				return null;
 
 			caching_flags |= Flags.Obsolete;
 
 			ObsoleteAttribute obsolete = obsolete_attr.GetObsoleteAttribute ();
 			if (obsolete == null)
 				return null;
 
 			return obsolete;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="167" endline="185">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (parameters.HasArglist) {
 				Report.Warning (3000, 1, Location, "Methods with variable arguments are not CLS-compliant");
 			}
 
 			if (member_type != null && !member_type.IsCLSCompliant ()) {
 				Report.Warning (3002, 1, Location, "Return type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 
 			parameters.VerifyClsCompliance (this);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="474" endline="497">
<![CDATA[
 
 		internal int GetTypeTokenForMemberRef(Type type)
 		{
 			if (type.IsGenericTypeDefinition)
 			{
 				int token;
 				if (!memberRefTypeTokens.TryGetValue(type, out token))
 				{
 					ByteBuffer spec = new ByteBuffer(5);
 					Signature.WriteTypeSpec(this, spec, type);
 					token = 0x1B000000 | this.TypeSpec.AddRecord(this.Blobs.Add(spec));
 					memberRefTypeTokens.Add(type, token);
 				}
 				return token;
 			}
 			else if (type.IsModulePseudoType)
 			{
 				return 0x1A000000 | this.ModuleRef.FindOrAddRecord(this.Strings.Add(type.Module.ScopeName));
 			}
 			else
 			{
 				return GetTypeToken(type).Token;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="125" endline="153">
<![CDATA[
 
 		// note that an empty array matches a null reference
 		internal static bool ArrayEquals(Type[] t1, Type[] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!TypeEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!TypeEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="154" endline="181">
<![CDATA[
 
 		internal static bool ArrayEquals(Type[][] t1, Type[][] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="182" endline="209">
<![CDATA[
 
 		internal static bool ArrayEquals(Type[][][] t1, Type[][][] t2)
 		{
 			if (t1 == t2)
 			{
 				return true;
 			}
 			if (t1 == null)
 			{
 				return t2.Length == 0;
 			}
 			else if (t2 == null)
 			{
 				return t1.Length == 0;
 			}
 			if (t1.Length == t2.Length)
 			{
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < t1.Length; i++)
 				{
 					if (!ArrayEquals(t1[i], t2[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1880" endline="1923">
<![CDATA[
 
 		//
 		// Handles #define and #undef
 		//
 		void PreProcessDefinition (bool is_define, string ident, bool caller_is_taking)
 		{
 			if (ident.Length == 0 || ident == "true" || ident == "false"){
 				Report.Error (1001, Location, "Missing identifier to pre-processor directive");
 				return;
 			}
 
 			if (ident.IndexOfAny (simple_whitespaces) != -1){
 				Error_EndLineExpected ();
 				return;
 			}
 
 			if (!is_identifier_start_character (ident [0]))
 				Report.Error (1001, Location, "Identifier expected
 			
 			foreach (char c in ident.Substring (1)){
 				if (!is_identifier_part_character (c)){
 					Report.Error (1001, Location, "Identifier expected
 					return;
 				}
 			}
 			foreach (char c in ident.Substring (1)){
 				if (!is_identifier_part_character (c)){
 					Report.Error (1001, Location, "Identifier expected
 					return;
 				}
 			}
 
 			if (!caller_is_taking)
 				return;
 
 			if (is_define) {
 				//
 				// #define ident
 				//
 				if (RootContext.IsConditionalDefined (ident))
 					return;
 
 				file_name.AddDefine (ident);
 			} else {
 				//
 				// #undef ident
 				//
 				file_name.AddUndefine (ident);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1057" endline="1067">
<![CDATA[
 
 		public static TypeInfo GetTypeInfo (TypeSpec type)
 		{
 			TypeInfo info;
 			if (type_hash.TryGetValue (type, out info))
 				return info;
 
 			info = new TypeInfo (type);
 			type_hash.Add (type, info);
 			return info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1617" endline="1623">
<![CDATA[
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var spec = (IndexerSpec) base.InflateMember (inflator);
 			spec.parameters = parameters.Inflate (inflator);
 			return spec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="589" endline="597">
<![CDATA[
 
 		public Parameter Clone ()
 		{
 			Parameter p = (Parameter) MemberwiseClone ();
 			if (attributes != null)
 				p.attributes = attributes.Clone ();
 
 			return p;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="197" endline="209">
<![CDATA[
 		}
 
 		public static void SetInteractiveBaseClass (Type type)
 		{
 			if (type == null)
 				throw new ArgumentNullException ();
 
 			if (!inited)
 				throw new Exception ("Evaluator has to be initiated before seting custom InteractiveBase class");
 
 			lock (evaluator_lock)
 				interactive_base_class = loader.Importer.ImportType (type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1159" endline="1165">
<![CDATA[
 
 		internal int GetSignatureBlobIndex(Signature sig)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			sig.WriteSig(this, bb);
 			return this.Blobs.Add(bb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2190" endline="2206">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			if (am_storey != null) {
 				DefineAnonymousStorey (ec);
 				am_storey.EmitStoreyInstantiation (ec, this);
 			}
 
 			bool emit_debug_info = SymbolWriter.HasSymbolWriter && Parent != null && !(am_storey is IteratorStorey);
 			if (emit_debug_info)
 				ec.BeginScope ();
 
 			base.Emit (ec);
 
 			if (emit_debug_info)
 				ec.EndScope ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodBase.cs" startline="41" endline="48">
<![CDATA[
 			{
 				if ((this.Attributes & MethodAttributes.RTSpecialName) != 0)
 				{
 					string name = this.Name;
 					return name == ConstructorInfo.ConstructorName || name == ConstructorInfo.TypeConstructorName;
 				}
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\modifiers.cs" startline="237" endline="271">
<![CDATA[
 
 		// <summary>
 		//   Checks the object @mod modifiers to be in @allowed.
 		//   Returns the new mask.  Side effect
 		//   incorrect attributes. 
 		// </summary>
 		public static Modifiers Check (Modifiers allowed, Modifiers mod, Modifiers def_access, Location l, Report Report)
 		{
 			int invalid_flags = (~(int) allowed) & ((int) mod & ((int) Modifiers.TOP - 1));
 			int i;
 
 			if (invalid_flags == 0){
 				//
 				// If no accessibility bits provided
 				// then provide the defaults.
 				//
 				if ((mod & Modifiers.AccessibilityMask) == 0) {
 					mod |= def_access;
 					if (def_access != 0)
 						mod |= Modifiers.DEFAULT_ACCESS_MODIFER;
 					return mod;
 				}
 
 				return mod;
 			}
 
 			for (i = 1; i <= (int) Modifiers.TOP; i <<= 1) {
 				if ((i & invalid_flags) == 0)
 					continue;
 
 				Error_InvalidModifier ((Modifiers)i, l, Report);
 			}
 			for (i = 1; i <= (int) Modifiers.TOP; i <<= 1) {
 				if ((i & invalid_flags) == 0)
 					continue;
 
 				Error_InvalidModifier ((Modifiers)i, l, Report);
 			}
 
 			return allowed & mod;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="529" endline="548">
<![CDATA[
 		
 		public override void Emit (EmitContext ec)
 		{
 			if (method_group.InstanceExpression == null)
 				ec.Emit (OpCodes.Ldnull);
 			else
 				method_group.InstanceExpression.Emit (ec);
 
 			var delegate_method = method_group.BestCandidate;
 
 			// Any delegate must be sealed
 			if (!delegate_method.DeclaringType.IsDelegate && delegate_method.IsVirtual && !method_group.IsBase) {
 				ec.Emit (OpCodes.Dup);
 				ec.Emit (OpCodes.Ldvirtftn, delegate_method);
 			} else {
 				ec.Emit (OpCodes.Ldftn, delegate_method);
 			}
 
 			ec.Emit (OpCodes.Newobj, constructor_method);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="396" endline="412">
<![CDATA[
 
 		private int WriteDeclSecurityBlob(List<CustomAttributeBuilder> list)
 		{
 			ByteBuffer namedArgs = new ByteBuffer(100);
 			ByteBuffer bb = new ByteBuffer(list.Count * 100);
 			bb.Write((byte)'.');
 			bb.WriteCompressedInt(list.Count);
 			foreach (CustomAttributeBuilder cab in list)
 			{
 				bb.Write(cab.Constructor.DeclaringType.AssemblyQualifiedName);
 				namedArgs.Clear();
 				cab.WriteNamedArgumentsForDeclSecurity(this, namedArgs);
 				bb.WriteCompressedInt(namedArgs.Length);
 				bb.Write(namedArgs);
 			}
 			foreach (CustomAttributeBuilder cab in list)
 			{
 				bb.Write(cab.Constructor.DeclaringType.AssemblyQualifiedName);
 				namedArgs.Clear();
 				cab.WriteNamedArgumentsForDeclSecurity(this, namedArgs);
 				bb.WriteCompressedInt(namedArgs.Length);
 				bb.Write(namedArgs);
 			}
 			return this.Blobs.Add(bb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="910" endline="919">
<![CDATA[
 
 		/// <summary>
 		///    Exposes the API of the given assembly to the Evaluator
 		/// </summary>
 		static public void ReferenceAssembly (Assembly a)
 		{
 			lock (evaluator_lock){
 				loader.Importer.ImportAssembly (a, RootContext.ToplevelTypes.GlobalRootNamespace);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3097" endline="3109">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			this.eclass = ExprClass.MethodGroup;
 
 			if (InstanceExpression != null) {
 				InstanceExpression = InstanceExpression.Resolve (ec);
 				if (InstanceExpression == null)
 					return null;
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1458" endline="1469">
<![CDATA[
 
 		protected TypeParameter[] TypeParameters {
 			get {
 				if (!IsGeneric)
 					throw new InvalidOperationException ();
 				if ((PartialContainer != null) && (PartialContainer != this))
 					return PartialContainer.TypeParameters;
 				if (type_param_list == null)
 					initialize_type_params ();
 
 				return type_param_list;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8118" endline="8132">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			Expr = Expr.Resolve (ec);
 			if (Expr == null)
 				return null;
 
 			type = Expr.Type;
 
 			var res = CreateAccessExpression (ec);
 			if (res == null)
 				return null;
 
 			return res.ResolveLValue (ec, right_side);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3083" endline="3096">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (best_candidate == null) {
 				ec.Report.Error (1953, loc, "An expression tree cannot contain an expression with method group");
 				return null;
 			}
 
 			if (best_candidate.IsConditionallyExcluded (loc))
 				ec.Report.Error (765, loc,
 					"Partial methods with only a defining declaration or removed conditional methods cannot be used in an expression tree");
 			
 			return new TypeOfMethod (best_candidate, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="476" endline="489">
<![CDATA[
 
 		public byte[] GetPublicKeyToken ()
 		{
 			if (public_key == null || public_key_token != null)
 				return public_key_token;
 
 			HashAlgorithm ha = SHA1.Create ();
 			byte[] hash = ha.ComputeHash (public_key);
 			// we need the last 8 bytes in reverse order
 			public_key_token = new byte[8];
 			Buffer.BlockCopy (hash, hash.Length - 8, public_key_token, 0, 8);
 			Array.Reverse (public_key_token, 0, 8);
 			return public_key_token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4765" endline="4787">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			ec.StartFlowBranching (this);
 
 			if (!stmt.Resolve (ec))
 				ok = false;
 
 			if (ok)
 				ec.CurrentBranching.CreateSibling (fini, FlowBranching.SiblingType.Finally);
 			using (ec.With (ResolveContext.Options.FinallyScope, true)) {
 				if (!fini.Resolve (ec))
 					ok = false;
 			}
 
 			ec.EndFlowBranching ();
 
 			ok &= base.Resolve (ec);
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1645" endline="1665">
<![CDATA[
 
 		private MethodInfo GetNextMethod(Module module, int token, bool nonPublic, short semantics, ref int i)
 		{
 			// TODO use binary search?
 			for (; i < records.Length; i++)
 			{
 				if (records[i].Association == token)
 				{
 					if ((records[i].Semantics & semantics) != 0)
 					{
 						MethodInfo method = (MethodInfo)module.ResolveMethod((MethodDefTable.Index << 24) + records[i].Method);
 						if (nonPublic || method.IsPublic)
 						{
 							i++;
 							return method;
 						}
 					}
 				}
 			}
 			for (; i < records.Length; i++)
 			{
 				if (records[i].Association == token)
 				{
 					if ((records[i].Semantics & semantics) != 0)
 					{
 						MethodInfo method = (MethodInfo)module.ResolveMethod((MethodDefTable.Index << 24) + records[i].Method);
 						if (nonPublic || method.IsPublic)
 						{
 							i++;
 							return method;
 						}
 					}
 				}
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1935" endline="1949">
<![CDATA[
 
 		public bool ResolveBuilder ()
 		{
 			if (ctor != null)
 				return true;
 
 			//
 			// Handle all parameter-less attributes as optional
 			//
 			if (!IsDefined)
 				return false;
 
 			ctor = TypeManager.GetPredefinedConstructor (type, Location.Null, TypeSpec.EmptyTypes);
 			return ctor != null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="874" endline="901">
<![CDATA[
 
 		internal void Fixup(ModuleBuilder moduleBuilder)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Parent;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the HasConstant encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case FieldTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case ParamTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case PropertyTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				int token = records[i].Parent;
 				if (moduleBuilder.IsPseudoToken(token))
 				{
 					token = moduleBuilder.ResolvePseudoToken(token);
 				}
 				// do the HasConstant encoding, so that we can sort the table
 				switch (token >> 24)
 				{
 					case FieldTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 0;
 						break;
 					case ParamTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 1;
 						break;
 					case PropertyTable.Index
 						records[i].Parent = (token & 0xFFFFFF) << 2 | 2;
 						break;
 					default
 						throw new InvalidOperationException();
 				}
 			}
 			Array.Sort(records, 0, rowCount, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="888" endline="903">
<![CDATA[
 		}
 
 		public static bool Equals (TypeSpec[] x, TypeSpec[] y)
 		{
 			if (x == y)
 				return true;
 
 			if (x.Length != y.Length)
 				return false;
 
 			for (int i = 0; i < x.Length; ++i)
 				if (!IsEqual (x[i], y[i]))
 					return false;
 			for (int i = 0; i < x.Length; ++i)
 				if (!IsEqual (x[i], y[i]))
 					return false;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\modifiers.cs" startline="166" endline="191">
<![CDATA[
 
 		public static FieldAttributes FieldAttr (Modifiers mod_flags)
 		{
 			FieldAttributes fa = 0;
 
 			if ((mod_flags & Modifiers.PUBLIC) != 0)
 				fa |= FieldAttributes.Public;
 			if ((mod_flags & Modifiers.PRIVATE) != 0)
 				fa |= FieldAttributes.Private;
 			if ((mod_flags & Modifiers.PROTECTED) != 0) {
 				if ((mod_flags & Modifiers.INTERNAL) != 0)
 					fa |= FieldAttributes.FamORAssem;
 				else 
 					fa |= FieldAttributes.Family;
 			} else {
 				if ((mod_flags & Modifiers.INTERNAL) != 0)
 					fa |= FieldAttributes.Assembly;
 			}
 
 			if ((mod_flags & Modifiers.STATIC) != 0)
 				fa |= FieldAttributes.Static;
 			if ((mod_flags & Modifiers.READONLY) != 0)
 				fa |= FieldAttributes.InitOnly;
 
 			return fa;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1067" endline="1114">
<![CDATA[
 
 		static Modifiers ReadMethodModifiers (MethodBase mb, TypeSpec declaringType)
 		{
 			Modifiers mod;
 			var ma = mb.Attributes;
 			switch (ma & MethodAttributes.MemberAccessMask) {
 			case MethodAttributes.Public
 				mod = Modifiers.PUBLIC;
 				break;
 			case MethodAttributes.Assembly
 				mod = Modifiers.INTERNAL;
 				break;
 			case MethodAttributes.Family
 				mod = Modifiers.PROTECTED;
 				break;
 			case MethodAttributes.FamORAssem
 				mod = Modifiers.PROTECTED | Modifiers.INTERNAL;
 				break;
 			default
 				mod = Modifiers.PRIVATE;
 				break;
 			}
 
 			if ((ma & MethodAttributes.Static) != 0) {
 				mod |= Modifiers.STATIC;
 				return mod;
 			}
 			if ((ma & MethodAttributes.Abstract) != 0 && declaringType.IsClass) {
 				mod |= Modifiers.ABSTRACT;
 				return mod;
 			}
 
 			if ((ma & MethodAttributes.Final) != 0)
 				mod |= Modifiers.SEALED;
 
 			// It can be sealed and override
 			if ((ma & MethodAttributes.Virtual) != 0) {
 				if ((ma & MethodAttributes.NewSlot) != 0 || !declaringType.IsClass) {
 					// No private virtual or sealed virtual
 					if ((mod & (Modifiers.PRIVATE | Modifiers.SEALED)) == 0)
 						mod |= Modifiers.VIRTUAL;
 				} else {
 					mod |= Modifiers.OVERRIDE;
 				}
 			}
 
 			return mod;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\modifiers.cs" startline="136" endline="165">
<![CDATA[
 
 		public static TypeAttributes TypeAttr (Modifiers mod_flags, bool is_toplevel)
 		{
 			TypeAttributes t = 0;
 
 			if (is_toplevel){
 				if ((mod_flags & Modifiers.PUBLIC) != 0)
 					t = TypeAttributes.Public;
 				else if ((mod_flags & Modifiers.PRIVATE) != 0)
 					t = TypeAttributes.NotPublic;
 			} else {
 				if ((mod_flags & Modifiers.PUBLIC) != 0)
 					t = TypeAttributes.NestedPublic;
 				else if ((mod_flags & Modifiers.PRIVATE) != 0)
 					t = TypeAttributes.NestedPrivate;
 				else if ((mod_flags & (Modifiers.PROTECTED | Modifiers.INTERNAL)) == (Modifiers.PROTECTED | Modifiers.INTERNAL))
 					t = TypeAttributes.NestedFamORAssem;
 				else if ((mod_flags & Modifiers.PROTECTED) != 0)
 					t = TypeAttributes.NestedFamily;
 				else if ((mod_flags & Modifiers.INTERNAL) != 0)
 					t = TypeAttributes.NestedAssembly;
 			}
 
 			if ((mod_flags & Modifiers.SEALED) != 0)
 				t |= TypeAttributes.Sealed;
 			if ((mod_flags & Modifiers.ABSTRACT) != 0)
 				t |= TypeAttributes.Abstract;
 
 			return t;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="132" endline="139">
<![CDATA[
 
 		public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, 0);
 			sig.returnType = returnType;
 			sig.callingConvention = callingConvention;
 			return sig;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="648" endline="680">
<![CDATA[
 
 		public Type CreateType()
 		{
 			if ((typeFlags & TypeFlags.Baked) != 0)
 			{
 				// .NET allows multiple invocations (subsequent invocations return the same baked type)
 				throw new NotImplementedException();
 			}
 			typeFlags |= TypeFlags.Baked;
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.Bake();
 			}
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.Bake();
 			}
 			if (declarativeSecurity != null)
 			{
 				this.ModuleBuilder.AddDeclarativeSecurity(token, declarativeSecurity);
 			}
 			if (baseType != null)
 			{
 				extends = this.ModuleBuilder.GetTypeToken(baseType).Token;
 			}
 			if (interfaces != null)
 			{
 				foreach (Type interfaceType in interfaces)
 				{
 					InterfaceImplTable.Record rec = new InterfaceImplTable.Record();
 					rec.Class = token;
 					rec.Interface = this.ModuleBuilder.GetTypeToken(interfaceType).Token;
 					this.ModuleBuilder.InterfaceImpl.AddRecord(rec);
 				}
 				foreach (Type interfaceType in interfaces)
 				{
 					InterfaceImplTable.Record rec = new InterfaceImplTable.Record();
 					rec.Class = token;
 					rec.Interface = this.ModuleBuilder.GetTypeToken(interfaceType).Token;
 					this.ModuleBuilder.InterfaceImpl.AddRecord(rec);
 				}
 			}
 			return new BakedType(this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="211" endline="218">
<![CDATA[
 
 		public int Read ()
 		{
 			if ((pos >= char_count) && !ReadBuffer ())
 				return -1;
 
 			return buffer [pos++];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="816" endline="838">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			//
 			// Load Iterator storey instance
 			//
 			IteratorHost.Instance.Emit (ec);
 
 			//
 			// Initialize iterator PC when it's unitialized
 			//
 			if (IsEnumerable) {
 				ec.Emit (OpCodes.Dup);
 				ec.EmitInt ((int)State.Uninitialized);
 
 				var field = IteratorHost.PC.Spec;
 				if (Storey.MemberName.IsGeneric) {
 					field = MemberCache.GetMember (Storey.Instance.Type, field);
 				}
 
 				ec.Emit (OpCodes.Stfld, field);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8355" endline="8361">
<![CDATA[
 
 		SLE.Expression[] MakeExpressionArguments (BuilderContext ctx)
 		{
 			using (ctx.With (BuilderContext.Options.AllCheckStateFlags, true)) {
 				return Arguments.MakeExpression (ea.Arguments, ctx);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="226" endline="250">
<![CDATA[
 
 		internal override int ImportTo(Emit.ModuleBuilder module)
 		{
 			if (methodArgs == null)
 			{
 				return module.ImportMethodOrField(declaringType, method.Name, method.MethodSignature);
 			}
 			else
 			{
 				Writer.ByteBuffer spec = new Writer.ByteBuffer(10);
 				Signature.WriteMethodSpec(module, spec, methodArgs);
 				Metadata.MethodSpecTable.Record rec = new Metadata.MethodSpecTable.Record();
 				Emit.MethodBuilder mb = method as Emit.MethodBuilder;
 				if (mb != null && mb.ModuleBuilder == module && !declaringType.IsGenericType)
 				{
 					rec.Method = mb.MetadataToken;
 				}
 				else
 				{
 					rec.Method = module.ImportMember(GetGenericMethodDefinition());
 				}
 				rec.Instantiation = module.Blobs.Add(spec);
 				return 0x2B000000 | module.MethodSpec.FindOrAddRecord(rec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Assembly.cs" startline="92" endline="112">
<![CDATA[
 
 		public Type GetType(string typeName, bool throwOnError)
 		{
 			TypeNameParser parser = TypeNameParser.Parse(typeName, throwOnError);
 			if (parser.Error)
 			{
 				return null;
 			}
 			if (parser.AssemblyName != null)
 			{
 				if (throwOnError)
 				{
 					throw new ArgumentException("Type names passed to Assembly.GetType() must not specify an assembly.");
 				}
 				else
 				{
 					return null;
 				}
 			}
 			return parser.Expand(GetTypeImpl(parser.FirstNamePart), this, throwOnError, typeName);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="52" endline="62">
<![CDATA[
 
 		internal MethodBody GetMethodBody(IGenericContext context)
 		{
 			if ((GetMethodImplementationFlags() & MethodImplAttributes.CodeTypeMask) != MethodImplAttributes.IL)
 			{
 				// method is not IL
 				return null;
 			}
 			int rva = module.MethodDef.records[index].RVA;
 			return rva == 0 ? null 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1540" endline="1558">
<![CDATA[
 
 		// <summary>
 		//   Get/set bit `index' in the bit vector.
 		// </summary>
 		public bool this [int index] {
 			get {
 				if (index >= Count)
 					// FIXME
 					// throw new ArgumentOutOfRangeException ();
 					return true; 
 
 				if (vector != null)
 					return vector [index];
 				if (shared == null)
 					return true;
 				if (index < shared.Count)
 					return shared [index];
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1663" endline="1688">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			TypeExpr texpr = expr.ResolveAsTypeTerminal (ec, false);
 			if (texpr == null)
 				return null;
 
 			type = texpr.Type;
 
 			if (type.IsStatic) {
 				ec.Report.Error (-244, loc, "The `default value' operator cannot be applied to an operand of a static type");
 			}
 
 			if (type.IsPointer)
 				return new NullLiteral (Location).ConvertImplicitly (ec, type);
 
 			if (TypeManager.IsReferenceType (type))
 				return new NullConstant (type, loc);
 
 			Constant c = New.Constantify (type, expr.Location);
 			if (c != null)
 				return c.Resolve (ec);
 
 			eclass = ExprClass.Variable;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="478" endline="490">
<![CDATA[
 		}
 
 		internal CustomAttributeBuilder DecodeBlob(Assembly asm)
 		{
 			if (blob == null)
 			{
 				return this;
 			}
 			else
 			{
 				return ToData(asm).__ToBuilder();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="300" endline="310">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			TypeCast child_cast = child as TypeCast;
 			if (child_cast != null) {
 				child.Type = type;
 				return child_cast.CreateExpressionTree (ec);
 			}
 
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="628" endline="640">
<![CDATA[
 	}
 
 	//
 	// Simple version of statement list not requiring a block
 	//
 	public class StatementList 
 	{
 		List<Statement> statements;
 
 		public StatementList (Statement first, Statement second)
 		{
 			statements = new List<Statement> () { first, second };
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="968" endline="984">
<![CDATA[
 
 		public override bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			LabeledStatement s = current_vector.Block == null ? null 
 			if (s != null)
 				throw new InternalErrorException ("Shouldn't get here");
 
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddGotoOrigin (vector, goto_stmt);
 				if (errors == Report.Errors)
 					Report.Error (157, goto_stmt.loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new GotoOrigin (saved_origins, vector, goto_stmt);
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="256" endline="283">
<![CDATA[
 	}
 
 	sealed class PEReader
 	{
 		private MSDOS_HEADER msdos = new MSDOS_HEADER();
 		private IMAGE_NT_HEADERS headers = new IMAGE_NT_HEADERS();
 		private SectionHeader[] sections;
 
 		internal void Read(BinaryReader br)
 		{
 			msdos.signature = br.ReadUInt16();
 			br.BaseStream.Seek(58, SeekOrigin.Current);
 			msdos.peSignatureOffset = br.ReadUInt32();
 
 			if (msdos.signature != MSDOS_HEADER.MAGIC_MZ)
 			{
 				throw new BadImageFormatException();
 			}
 
 			br.BaseStream.Seek(msdos.peSignatureOffset, SeekOrigin.Begin);
 			headers.Read(br);
 			sections = new SectionHeader[headers.FileHeader.NumberOfSections];
 			for (int i = 0; i < sections.Length; i++)
 			{
 				sections[i] = new SectionHeader();
 				sections[i].Read(br);
 			}
 			for (int i = 0; i < sections.Length; i++)
 			{
 				sections[i] = new SectionHeader();
 				sections[i].Read(br);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\TypeNameParser.cs" startline="139" endline="394">
<![CDATA[
 		}
 
 		private struct Parser
 		{
 			private readonly string typeName;
 			internal int pos;
 
 			internal Parser(string typeName)
 			{
 				this.typeName = typeName;
 				this.pos = 0;
 			}
 
 			private void Check(bool condition)
 			{
 				if (!condition)
 				{
 					throw new ArgumentException("Invalid type name '" + typeName + "'");
 				}
 			}
 
 			private void Consume(char c)
 			{
 				Check(pos < typeName.Length && typeName[pos++] == c);
 			}
 
 			private bool TryConsume(char c)
 			{
 				if (pos < typeName.Length && typeName[pos] == c)
 				{
 					pos++;
 					return true;
 				}
 				else
 				{
 					return false;
 				}
 			}
 
 			internal string NextNamePart()
 			{
 				SkipWhiteSpace();
 				int start = pos;
 				for (; pos < typeName.Length; pos++)
 				{
 					char c = typeName[pos];
 					if (c == '\\')
 					{
 						pos++;
 						Check(pos < typeName.Length && SpecialChars.IndexOf(typeName[pos]) != -1);
 					}
 					else if (SpecialChars.IndexOf(c) != -1)
 					{
 						break;
 					}
 				}
 				Check(pos - start != 0);
 				if (start == 0 && pos == typeName.Length)
 				{
 					return typeName;
 				}
 				else
 				{
 					return typeName.Substring(start, pos - start);
 				}
 			}
 
 			internal void ParseNested(ref string[] nested)
 			{
 				while (TryConsume('+'))
 				{
 					Add(ref nested, NextNamePart());
 				}
 			}
 
 			internal void ParseGenericParameters(ref TypeNameParser[] genericParameters)
 			{
 				int saved = pos;
 				if (TryConsume('['))
 				{
 					SkipWhiteSpace();
 					if (TryConsume(']') || TryConsume('*') || TryConsume(','))
 					{
 						// it's not a generic parameter list, but an array instead
 						pos = saved;
 						return;
 					}
 					do
 					{
 						SkipWhiteSpace();
 						if (TryConsume('['))
 						{
 							Add(ref genericParameters, new TypeNameParser(ref this, true));
 							Consume(']');
 						}
 						else
 						{
 							Add(ref genericParameters, new TypeNameParser(ref this, false));
 						}
 					}
 					while (TryConsume(','));
 					Consume(']');
 					SkipWhiteSpace();
 				}
 			}
 
 			internal void ParseModifiers(ref short[] modifiers)
 			{
 				while (pos < typeName.Length)
 				{
 					switch (typeName[pos])
 					{
 						case '*'
 							pos++;
 							Add(ref modifiers, POINTER);
 							break;
 						case '&'
 							pos++;
 							Add(ref modifiers, BYREF);
 							break;
 						case '['
 							pos++;
 							Add(ref modifiers, ParseArray());
 							Consume(']');
 							break;
 						default
 							return;
 					}
 					SkipWhiteSpace();
 				}
 			}
 
 			internal void ParseAssemblyName(bool genericParameter, ref string assemblyName)
 			{
 				if (pos < typeName.Length)
 				{
 					if (typeName[pos] == ']' && genericParameter)
 					{
 						// ok
 					}
 					else
 					{
 						Consume(',');
 						SkipWhiteSpace();
 						if (genericParameter)
 						{
 							int start = pos;
 							while (pos < typeName.Length)
 							{
 								char c = typeName[pos];
 								if (c == '\\')
 								{
 									pos++;
 									// a backslash itself is not legal in an assembly name, so we don't need to check for an escaped backslash
 									Check(pos < typeName.Length && typeName[pos++] == ']');
 								}
 								else if (c == ']')
 								{
 									break;
 								}
 								else
 								{
 									pos++;
 								}
 							}
 							Check(pos < typeName.Length && typeName[pos] == ']');
 							assemblyName = typeName.Substring(start, pos - start).Replace("\\]", "]");
 						}
 						else
 						{
 							// only when an assembly name is used in a generic type parameter, will it be escaped
 							assemblyName = typeName.Substring(pos);
 						}
 						Check(assemblyName.Length != 0);
 					}
 				}
 				else
 				{
 					Check(!genericParameter);
 				}
 			}
 
 			private short ParseArray()
 			{
 				SkipWhiteSpace();
 				Check(pos < typeName.Length);
 				char c = typeName[pos];
 				if (c == ']')
 				{
 					return SZARRAY;
 				}
 				else if (c == '*')
 				{
 					pos++;
 					SkipWhiteSpace();
 					return 1;
 				}
 				else
 				{
 					short rank = 1;
 					while (TryConsume(','))
 					{
 						Check(rank < short.MaxValue);
 						rank++;
 						SkipWhiteSpace();
 					}
 					return rank;
 				}
 			}
 
 			private void SkipWhiteSpace()
 			{
 				while (pos < typeName.Length && Char.IsWhiteSpace(typeName[pos]))
 				{
 					pos++;
 				}
 			}
 
 			private static void Add<T>(ref T[] array, T elem)
 			{
 				if (array == null)
 				{
 					array = new T[] { elem };
 					return;
 				}
 				Array.Resize(ref array, array.Length + 1);
 				array[array.Length - 1] = elem;
 			}
 		}
 
 		internal Type GetType(Universe universe, Assembly context, bool throwOnError, string originalName)
 		{
 			Type type;
 			if (assemblyName != null)
 			{
 				Assembly asm = universe.Load(assemblyName, context, throwOnError);
 				if (asm == null)
 				{
 					return null;
 				}
 				type = asm.GetTypeImpl(name);
 			}
 			else if (context == null)
 			{
 				type = universe.Mscorlib.GetTypeImpl(name);
 			}
 			else
 			{
 				type = context.GetTypeImpl(name);
 				if (type == null && context != universe.Mscorlib)
 				{
 					type = universe.Mscorlib.GetTypeImpl(name);
 				}
 			}
 			return Expand(type, context, throwOnError, originalName);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="324" endline="351">
<![CDATA[
 
 		internal bool MatchParameterTypes(Type[] types)
 		{
 			if (types == parameterTypes)
 			{
 				return true;
 			}
 			if (types == null)
 			{
 				return parameterTypes.Length == 0;
 			}
 			if (parameterTypes == null)
 			{
 				return types.Length == 0;
 			}
 			if (types.Length == parameterTypes.Length)
 			{
 				for (int i = 0; i < types.Length; i++)
 				{
 					if (!Util.TypeEquals(types[i], parameterTypes[i]))
 					{
 						return false;
 					}
 				}
 				for (int i = 0; i < types.Length; i++)
 				{
 					if (!Util.TypeEquals(types[i], parameterTypes[i]))
 					{
 						return false;
 					}
 				}
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2633" endline="2682">
<![CDATA[
 
 		//
 		// Rules used during binary numeric promotion
 		//
 		static bool DoNumericPromotion (ResolveContext rc, ref Expression prim_expr, ref Expression second_expr, TypeSpec type)
 		{
 			Expression temp;
 			TypeSpec etype;
 
 			Constant c = prim_expr as Constant;
 			if (c != null) {
 				temp = c.ConvertImplicitly (rc, type);
 				if (temp != null) {
 					prim_expr = temp;
 					return true;
 				}
 			}
 
 			if (type == TypeManager.uint32_type) {
 				etype = prim_expr.Type;
 				if (etype == TypeManager.int32_type || etype == TypeManager.short_type || etype == TypeManager.sbyte_type) {
 					type = TypeManager.int64_type;
 
 					if (type != second_expr.Type) {
 						c = second_expr as Constant;
 						if (c != null)
 							temp = c.ConvertImplicitly (rc, type);
 						else
 							temp = Convert.ImplicitNumericConversion (second_expr, type);
 						if (temp == null)
 							return false;
 						second_expr = temp;
 					}
 				}
 			} else if (type == TypeManager.uint64_type) {
 				//
 				// A compile-time error occurs if the other operand is of type sbyte, short, int, or long
 				//
 				if (type == TypeManager.int32_type || type == TypeManager.int64_type ||
 					type == TypeManager.short_type || type == TypeManager.sbyte_type)
 					return false;
 			}
 
 			temp = Convert.ImplicitNumericConversion (prim_expr, type);
 			if (temp == null)
 				return false;
 
 			prim_expr = temp;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1668" endline="1683">
<![CDATA[
 
 		/// <summary>
 		///  Returns whether an explicit reference conversion can be performed
 		///  from source_type to target_type
 		/// </summary>
 		public static bool ExplicitReferenceConversionExists (TypeSpec source_type, TypeSpec target_type)
 		{
 			Expression e = ExplicitReferenceConversion (null, source_type, target_type);
 			if (e == null)
 				return false;
 
 			if (e == EmptyExpression.Null)
 				return true;
 
 			throw new InternalErrorException ("Invalid probing conversion result");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="152" endline="163">
<![CDATA[
 		}
 
 		internal uint DebugDirectoryLength
 		{
 			get
 			{
 				if (DebugDirectoryContentsLength != 0)
 				{
 					return 28;
 				}
 				return 0;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="747" endline="762">
<![CDATA[
 
 	//
 	// Checks whether `type' is a subclass or nested child of `base_type'.
 	//
 	public static bool IsNestedFamilyAccessible (TypeSpec type, TypeSpec base_type)
 	{
 		do {
 			if (IsFamilyAccessible (type, base_type))
 				return true;
 
 			// Handle nested types.
 			type = type.DeclaringType;
 		} while (type != null);
 
 		return false;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1382" endline="1390">
<![CDATA[
 		}
 
 		public override IList<TypeSpec> Interfaces {
 			get {
 				if (cache == null)
 					InitializeMemberCache (true);
 
 				return base.Interfaces;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="563" endline="573">
<![CDATA[
 
 		internal int ImportMember(MethodBase member)
 		{
 			int token;
 			if (!importedMembers.TryGetValue(member, out token))
 			{
 				token = member.ImportTo(this);
 				importedMembers.Add(member, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="574" endline="584">
<![CDATA[
 
 		internal int ImportMember(FieldInfo member)
 		{
 			int token;
 			if (!importedMembers.TryGetValue(member, out token))
 			{
 				token = member.ImportTo(this);
 				importedMembers.Add(member, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="521" endline="532">
<![CDATA[
 
 		public override bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			LabeledStatement stmt = Block == null ? null 
 			if (stmt == null)
 				return Parent.AddGotoOrigin (vector, goto_stmt);
 
 			// forward jump
 			goto_stmt.SetResolvedTarget (stmt);
 			stmt.AddUsageVector (vector);
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="952" endline="967">
<![CDATA[
 
 		public override bool AddReturnOrigin (UsageVector vector, ExitStatement exit_stmt)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddReturnOrigin (vector, exit_stmt);
 				if (errors == Report.Errors)
 					exit_stmt.Error_FinallyClause (Report);
 			} else {
 				saved_origins = new ReturnOrigin (saved_origins, vector, exit_stmt);
 			}
 
 			// sets ec.NeedReturnLabel()
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="80" endline="96">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = typeBuilder.ModuleBuilder.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= EventAttributes.SpecialName;
 			}
 			else
 			{
 				if (lazyPseudoToken == 0)
 				{
 					lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 				}
 				typeBuilder.ModuleBuilder.SetCustomAttribute(lazyPseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="92" endline="108">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = typeBuilder.ModuleBuilder.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attributes |= PropertyAttributes.SpecialName;
 			}
 			else
 			{
 				if (lazyPseudoToken == 0)
 				{
 					lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 				}
 				typeBuilder.ModuleBuilder.SetCustomAttribute(lazyPseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="222" endline="236">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddAnonymousType (AnonymousTypeClass type)
 		{
 			List<AnonymousTypeClass> existing;
 			if (!anonymous_types.TryGetValue (type.Parameters.Count, out existing))
 			if (existing == null) {
 				existing = new List<AnonymousTypeClass> ();
 				anonymous_types.Add (type.Parameters.Count, existing);
 			}
 
 			existing.Add (type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="152" endline="160">
<![CDATA[
 
 		public byte[] GetSignature()
 		{
 			if (module == null)
 			{
 				throw new NotSupportedException();
 			}
 			return GetSignature(module).ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="433" endline="446">
<![CDATA[
 
 		protected virtual MethodSpec ResolveConstructor (ResolveContext ec)
 		{
 			if (PosArguments != null) {
 				bool dynamic;
 				PosArguments.Resolve (ec, out dynamic);
 				if (dynamic) {
 					Error_AttributeArgumentIsDynamic (ec.MemberContext, loc);
 					return null;
 				}
 			}
 
 			return ConstructorLookup (ec, Type, ref PosArguments, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7228" endline="7241">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (member.IsConstructor) {
 				type = ec.Module.PredefinedTypes.ConstructorInfo.Resolve (loc);
 			} else {
 				type = ec.Module.PredefinedTypes.MethodInfo.Resolve (loc);
 			}
 
 			if (type == null)
 				return null;
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="896" endline="915">
<![CDATA[
 
 		public FieldSpec CreateCallSiteField (FullNamedExpression type, Location loc)
 		{
 			int index = fields == null ? 0 
 			Field f = new HoistedField (this, type, Modifiers.PUBLIC | Modifiers.STATIC, "Site" + index.ToString ("X"), null, loc);
 			f.Define ();
 
 			AddField (f);
 
 			var fs = f.Spec;
 			if (mutator != null) {
 				//
 				// Inflate the field, no need to keep it in MemberCache as it's accessed only once
 				//
 				var inflator = new TypeParameterInflator (instance_type, spec.MemberDefinition.TypeParameters, instance_type.TypeArguments);
 				fs = (FieldSpec) fs.InflateMember (inflator);
 			}
 
 			return fs;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="901" endline="908">
<![CDATA[
 
 		internal void WriteMethodDefRecords(int baseRVA, MetadataWriter mw, ref int paramList)
 		{
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.WriteMethodDefRecord(baseRVA, mw, ref paramList);
 			}
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.WriteMethodDefRecord(baseRVA, mw, ref paramList);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="780" endline="794">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (Expr != null) {
 				Expr.Emit (ec);
 
 				if (unwind_protect)
 					ec.Emit (OpCodes.Stloc, ec.TemporaryReturn ());
 			}
 
 			if (unwind_protect)
 				ec.Emit (OpCodes.Leave, ec.ReturnLabel);
 			else
 				ec.Emit (OpCodes.Ret);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="3423" endline="3433">
<![CDATA[
 
 		public void cleanup ()
 		{
 			if (ifstack != null && ifstack.Count >= 1) {
 				int state = ifstack.Pop ();
 				if ((state & REGION) != 0)
 					Report.Error (1038, Location, "#endregion directive expected");
 				else 
 					Report.Error (1027, Location, "Expected `#endif' directive");
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="160" endline="166">
<![CDATA[
 
 		public string Basename {
 			get {
 				if (TypeArguments != null)
 					return MakeName (Name, TypeArguments);
 				return Name;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3048" endline="3057">
<![CDATA[
 		}
 
 		public override string Name {
 			get {
 				if (best_candidate != null)
 					return best_candidate.Name;
 
 				// TODO
 				return Methods.First ().Name;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3075" endline="3082">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			if (best_candidate != null)
 				return best_candidate.GetSignatureForError ();
 
 			return Methods.First ().GetSignatureForError ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="197" endline="213">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec)
 		{
 			var type = Expr.Type;
 			if (IsByRef) {
 				var ml = (IMemoryLocation) Expr;
 				ml.AddressOf (ec, AddressOp.Load);
 				type = ReferenceContainer.MakeType (type);
 			} else {
 				Expr.Emit (ec);
 			}
 
 			variable = new LocalTemporary (type);
 			variable.Store (ec);
 
 			Expr = variable;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="127" endline="161">
<![CDATA[
 
 		//
 		// Initializes the code generator
 		//
 		public bool Create (StaticLoader loader)
 		{
 			ResolveAssemblySecurityAttributes ();
 			var an = CreateAssemblyName ();
 
 			Builder = loader.Domain.DefineDynamicAssembly (an, AssemblyBuilderAccess.Save, Path.GetDirectoryName (file_name));
 
 			if (loader.Corlib != null) {
 				Builder.__SetImageRuntimeVersion (loader.Corlib.ImageRuntimeVersion, 0x20000);
 			} else {
 				// Sets output file metadata version when there is no mscorlib
 				switch (RootContext.StdLibRuntimeVersion) {
 				case RuntimeVersion.v4
 					Builder.__SetImageRuntimeVersion ("v4.0.30319", 0x20000);
 					break;
 				case RuntimeVersion.v2
 					Builder.__SetImageRuntimeVersion ("v2.0.50727", 0x20000);
 					break;
 				case RuntimeVersion.v1
 					// Compiler does not do any checks whether the produced metadata
 					// are valid in the context of 1.0 stream version
 					Builder.__SetImageRuntimeVersion ("v1.1.4322", 0x10000);
 					break;
 				default
 					throw new NotImplementedException ();
 				}
 			}
 
 			builder_extra = new AssemblyBuilderIKVM (Builder, Compiler);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2188" endline="2238">
<![CDATA[
 
 		protected virtual void Error_TypeOrNamespaceNotFound (IMemberContext ec)
 		{
 			if (ec.CurrentType != null) {
 				if (ec.CurrentMemberDefinition != null) {
 					MemberCore mc = ec.CurrentMemberDefinition.Parent.GetDefinition (Name);
 					if (mc != null) {
 						Error_UnexpectedKind (ec.Compiler.Report, mc, "type", GetMemberType (mc), loc);
 						return;
 					}
 				}
 
 				/*
 								// TODO MemberCache
  
 								string ns = ec.CurrentType.Namespace;
 								string fullname = (ns.Length > 0) ? ns + "." + Name 
 								foreach (Assembly a in GlobalRootNamespace.Instance.Assemblies) {
 									var type = a.GetType (fullname);
 									if (type != null) {
 										ec.Compiler.Report.SymbolRelatedToPreviousError (type);
 										Expression.ErrorIsInaccesible (loc, TypeManager.CSharpName (type), ec.Compiler.Report);
 										return;
 									}
 								}
 
 								if (ec.CurrentTypeDefinition != null) {
 									TypeSpec t = ec.CurrentTypeDefinition.LookupAnyGeneric (Name);
 									if (t != null) {
 										Namespace.Error_InvalidNumberOfTypeArguments (ec.Compiler.Report, t, loc);
 										return;
 									}
 								}
 				*/
 			}
 
 			FullNamedExpression retval = ec.LookupNamespaceOrType (Name, -System.Math.Max (1, Arity), loc, true);
 			if (retval != null) {
 				Error_TypeArgumentsCannotBeUsed (ec.Compiler.Report, loc, retval.Type, Arity);
 /*
 				var te = retval as TypeExpr;
 				if (HasTypeArguments && te != null && !te.Type.IsGeneric)
 					retval.Error_TypeArgumentsCannotBeUsed (ec.Compiler.Report, loc);
 				else
 					Namespace.Error_InvalidNumberOfTypeArguments (ec.Compiler.Report, retval.Type, loc);
 */
 				return;
 			}
 
 			NamespaceEntry.Error_NamespaceNotFound (loc, Name, ec.Compiler.Report);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2689" endline="2714">
<![CDATA[
 
 		protected void DoBestMemberChecks<T> (ResolveContext rc, T member) where T 
 		{
 			if (InstanceExpression != null) {
 				InstanceExpression = InstanceExpression.Resolve (rc);
 				CheckProtectedMemberAccess (rc, member);
 			}
 
 			if (member.MemberType.IsPointer && !rc.IsUnsafe) {
 				UnsafeError (rc, loc);
 			}
 
 			var dep = member.GetMissingDependencies ();
 			if (dep != null) {
 				ImportedTypeDefinition.Error_MissingDependency (rc, dep, loc);
 			}
 
 			if (!rc.IsObsolete) {
 				ObsoleteAttribute oa = member.GetAttributeObsolete ();
 				if (oa != null)
 					AttributeTester.Report_ObsoleteMessage (oa, member.GetSignatureForError (), loc, rc.Report);
 			}
 
 			if (!(member is FieldSpec))
 				member.MemberDefinition.SetIsUsed ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4593" endline="4619">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			decl.Variable.CreateBuilder (ec);
 			decl.Initializer.Emit (ec);
 			if (decl.Declarators != null) {
 				foreach (var d in decl.Declarators) {
 					d.Variable.CreateBuilder (ec);
 					d.Initializer.Emit (ec);
 				}
 				foreach (var d in decl.Declarators) {
 					d.Variable.CreateBuilder (ec);
 					d.Initializer.Emit (ec);
 				}
 			}
 
 			statement.Emit (ec);
 
 			if (has_ret)
 				return;
 
 			//
 			// Clear the pinned variable
 			//
 			((Emitter) decl.Initializer).EmitExit (ec);
 			if (decl.Declarators != null) {
 				foreach (var d in decl.Declarators) {
 					((Emitter)d.Initializer).EmitExit (ec);
 				}
 				foreach (var d in decl.Declarators) {
 					((Emitter)d.Initializer).EmitExit (ec);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="550" endline="576">
<![CDATA[
 
 		public void Emit(OpCode opc, Label[] labels)
 		{
 			Emit(opc);
 			LabelFixup fix = new LabelFixup();
 			fix.label = -1;
 			fix.offset = code.Position;
 			labelFixups.Add(fix);
 			code.Write(labels.Length);
 			foreach (Label label in labels)
 			{
 				code.Write(label.Index);
 				if (this.labels[label.Index] != -1)
 				{
 					if (labelStackHeight[label.Index] != stackHeight)
 					{
 						// the "backward branch constraint" prohibits this, so we don't need to support it
 						throw new NotSupportedException();
 					}
 				}
 				else
 				{
 					Debug.Assert(labelStackHeight[label.Index] == -1 || labelStackHeight[label.Index] == stackHeight);
 					labelStackHeight[label.Index] = stackHeight;
 				}
 			}
 			foreach (Label label in labels)
 			{
 				code.Write(label.Index);
 				if (this.labels[label.Index] != -1)
 				{
 					if (labelStackHeight[label.Index] != stackHeight)
 					{
 						// the "backward branch constraint" prohibits this, so we don't need to support it
 						throw new NotSupportedException();
 					}
 				}
 				else
 				{
 					Debug.Assert(labelStackHeight[label.Index] == -1 || labelStackHeight[label.Index] == stackHeight);
 					labelStackHeight[label.Index] = stackHeight;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="199" endline="210">
<![CDATA[
 
 		internal override Type GetGenericMethodArgument(int index)
 		{
 			if (methodArgs == null)
 			{
 				return method.GetGenericMethodArgument(index);
 			}
 			else
 			{
 				return methodArgs[index];
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="291" endline="306">
<![CDATA[
 
 		public void CaptureParameter (ResolveContext ec, ParameterReference param_ref)
 		{
 			ec.CurrentBlock.Explicit.HasCapturedVariable = true;
 			AddReferenceFromChildrenBlock (ec.CurrentBlock.Explicit);
 
 			if (param_ref.GetHoistedVariable (ec) != null)
 				return;
 
 			if (hoisted_params == null)
 				hoisted_params = new List<HoistedParameter> (2);
 
 			var expr = new HoistedParameter (this, param_ref);
 			param_ref.Parameter.HoistedVariant = expr;
 			hoisted_params.Add (expr);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1266" endline="1276">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			Array.Sort(records, 0, rowCount, this);
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].PackingSize);
 				mw.Write(records[i].ClassSize);
 				mw.WriteTypeDef(records[i].Parent);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].PackingSize);
 				mw.Write(records[i].ClassSize);
 				mw.WriteTypeDef(records[i].Parent);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="694" endline="711">
<![CDATA[
 		}
 
 		public virtual void RegisterFieldForInitialization (MemberCore field, FieldInitializer expression)
 		{
 			if ((field.ModFlags & Modifiers.STATIC) != 0){
 				if (initialized_static_fields == null) {
 					PartialContainer.HasStaticFieldInitializer = true;
 					initialized_static_fields = new List<FieldInitializer> (4);
 				}
 
 				initialized_static_fields.Add (expression);
 			} else {
 				if (initialized_fields == null)
 					initialized_fields = new List<FieldInitializer> (4);
 
 				initialized_fields.Add (expression);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5381" endline="5402">
<![CDATA[
 
 		protected override Expression OverloadResolve (ResolveContext rc, Expression right_side)
 		{
 			eclass = ExprClass.PropertyAccess;
 
 			if (best_candidate.IsNotRealProperty) {
 				Error_PropertyNotValid (rc);
 			}
 
 			ResolveInstanceExpression (rc, right_side);
 
 			if ((best_candidate.Modifiers & (Modifiers.ABSTRACT | Modifiers.VIRTUAL)) != 0 && best_candidate.DeclaringType != InstanceExpression.Type) {
 				var filter = new MemberFilter (best_candidate.Name, 0, MemberKind.Property, null, null);
 				var p = MemberCache.FindMember (InstanceExpression.Type, filter, BindingRestriction.InstanceOnly | BindingRestriction.OverrideOnly) as PropertySpec;
 				if (p != null) {
 					type = p.MemberType;
 				}
 			}
 
 			DoBestMemberChecks (rc, best_candidate);
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1052" endline="1072">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			if (expr == null) {
 				ec.CurrentBranching.CurrentUsageVector.Goto ();
 				return ec.CurrentBranching.CheckRethrow (loc);
 			}
 
 			expr = expr.Resolve (ec, ResolveFlags.Type | ResolveFlags.VariableOrValue);
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			if (expr == null)
 				return false;
 
 			if (Convert.ImplicitConversionExists (ec, expr, TypeManager.exception_type))
 				expr = Convert.ImplicitConversion (ec, expr, TypeManager.exception_type, loc);
 			else
 				ec.Report.Error (155, expr.Location, "The type caught or thrown must be derived from System.Exception");
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="95" endline="120">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customAttributeBuilder)
 		{
 			Universe u = moduleBuilder.universe;
 			if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_InAttribute)
 			{
 				flags |= (short)ParameterAttributes.In;
 			}
 			else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_OutAttribute)
 			{
 				flags |= (short)ParameterAttributes.Out;
 			}
 			else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_OptionalAttribute)
 			{
 				flags |= (short)ParameterAttributes.Optional;
 			}
 			else if (customAttributeBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_MarshalAsAttribute)
 			{
 				MarshalSpec.SetMarshalAsAttribute(moduleBuilder, PseudoToken, customAttributeBuilder);
 				flags |= (short)ParameterAttributes.HasFieldMarshal;
 			}
 			else
 			{
 				moduleBuilder.SetCustomAttribute(PseudoToken, customAttributeBuilder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3806" endline="3850">
<![CDATA[
 
 		protected virtual void EmitOperator (EmitContext ec, TypeSpec l)
 		{
 			//
 			// Handle short-circuit operators differently
 			// than the rest
 			//
 			if ((oper & Operator.LogicalMask) != 0) {
 				Label load_result = ec.DefineLabel ();
 				Label end = ec.DefineLabel ();
 
 				bool is_or = oper == Operator.LogicalOr;
 				left.EmitBranchable (ec, load_result, is_or);
 				right.Emit (ec);
 				ec.Emit (OpCodes.Br_S, end);
 				
 				ec.MarkLabel (load_result);
 				ec.Emit (is_or ? OpCodes.Ldc_I4_1 
 				ec.MarkLabel (end);
 				return;
 			}
 
 			//
 			// Optimize zero-based operations which cannot be optimized at expression level
 			//
 			if (oper == Operator.Subtraction) {
 				var lc = left as IntegralConstant;
 				if (lc != null && lc.IsDefaultValue) {
 					right.Emit (ec);
 					ec.Emit (OpCodes.Neg);
 					return;
 				}
 			}
 
 			left.Emit (ec);
 			right.Emit (ec);
 			EmitOperatorOpcode (ec, oper, l);
 
 			//
 			// Nullable enum could require underlying type cast and we cannot simply wrap binary
 			// expression because that would wrap lifted binary operation
 			//
 			if (enum_conversion != null)
 				enum_conversion.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="219" endline="241">
<![CDATA[
 		}
 
 		public override void Emit ()
 		{
 			if (member_type == InternalType.Dynamic) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (FieldBuilder);
 			} else if (!(Parent is CompilerGeneratedClass) && member_type.HasDynamicElement) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (FieldBuilder, member_type, Location);
 			}
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (FieldBuilder);
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			if (((status & Status.HAS_OFFSET) == 0) && (ModFlags & (Modifiers.STATIC | Modifiers.BACKING_FIELD)) == 0 && Parent.PartialContainer.HasExplicitLayout) {
 				Report.Error (625, Location, "`{0}'
 			}
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="805" endline="855">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			//
 			// Optimize same expression operation
 			//
 			if (right_unwrap != null && right.Equals (left))
 				right_unwrap = left_unwrap;
 
 			if (user_operator == null && IsBitwiseBoolean) {
 				EmitBitwiseBoolean (ec);
 				return;
 			}
 
 			if ((Oper & Operator.EqualityMask) != 0) {
 				EmitEquality (ec);
 				return;
 			}
 
 			Label is_null_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			if (left_unwrap != null) {
 				left_unwrap.EmitCheck (ec);
 				ec.Emit (OpCodes.Brfalse, is_null_label);
 			}
 
 			//
 			// Don't emit HasValue check when left and right expressions are same
 			//
 			if (right_unwrap != null && !left.Equals (right)) {
 				right_unwrap.EmitCheck (ec);
 				ec.Emit (OpCodes.Brfalse, is_null_label);
 			}
 
 			EmitOperator (ec, left.Type);
 
 			if (wrap_ctor != null)
 				ec.Emit (OpCodes.Newobj, wrap_ctor);
 
 			ec.Emit (OpCodes.Br_S, end_label);
 			ec.MarkLabel (is_null_label);
 
 			if ((Oper & Operator.ComparisonMask) != 0) {
 				ec.Emit (OpCodes.Ldc_I4_0);
 			} else {
 				LiftedNull.Create (type, loc).Emit (ec);
 			}
 
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="921" endline="928">
<![CDATA[
 
 		internal void WriteParamRecords(MetadataWriter mw)
 		{
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.WriteParamRecords(mw);
 			}
 			foreach (MethodBuilder mb in methods)
 			{
 				mb.WriteParamRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="929" endline="936">
<![CDATA[
 
 		internal void WriteFieldRecords(MetadataWriter mw)
 		{
 			foreach (FieldBuilder fb in fields)
 			{
 				fb.WriteFieldRecords(mw);
 			}
 			foreach (FieldBuilder fb in fields)
 			{
 				fb.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="145" endline="152">
<![CDATA[
 
 		internal void WriteParamTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteParamRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteParamRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="153" endline="160">
<![CDATA[
 
 		internal void WriteFieldTable(MetadataWriter mw)
 		{
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteFieldRecords(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="115" endline="125">
<![CDATA[
 
 		internal void PopulatePropertyAndEventTables()
 		{
 			// LAMESPEC the PropertyMap and EventMap tables are not required to be sorted by the CLI spec,
 			// but .NET sorts them and Mono requires them to be sorted, so we have to populate the
 			// tables in the right order
 			foreach (TypeBuilder type in types)
 			{
 				type.PopulatePropertyAndEventTables();
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.PopulatePropertyAndEventTables();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="126" endline="135">
<![CDATA[
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (parameter_type == null)
 				throw new InternalErrorException ("A type of implicit lambda parameter `{0}' is not set",
 					Name);
 
 			base.idx = index;
 			return parameter_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="981" endline="993">
<![CDATA[
 
 		//
 		// TODO
 		// as the underlying type is not Parameter and some methods will fail to cast
 		//
 		public static AParametersCollection CreateFullyResolved (TypeSpec[] types)
 		{
 			var pd = new ParameterData [types.Length];
 			for (int i = 0; i < pd.Length; ++i)
 				pd[i] = new ParameterData (null, Parameter.Modifier.NONE, null);
 			for (int i = 0; i < pd.Length; ++i)
 				pd[i] = new ParameterData (null, Parameter.Modifier.NONE, null);
 
 			return new ParametersCompiled (pd, types);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1206" endline="1229">
<![CDATA[
 
 		/// <summary>
 		///   Converts implicitly the resolved expression `expr' into the
 		///   `target_type'.  It returns a new expression that can be used
 		///   in a context that expects a `target_type'.
 		/// </summary>
 		static public Expression ImplicitConversion (ResolveContext ec, Expression expr,
 							     TypeSpec target_type, Location loc)
 		{
 			Expression e;
 
 			if (target_type == null)
 				throw new Exception ("Target type is null");
 
 			e = ImplicitConversionStandard (ec, expr, target_type, loc);
 			if (e != null)
 				return e;
 
 			e = ImplicitUserConversion (ec, expr, target_type, loc);
 			if (e != null)
 				return e;
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1622" endline="1636">
<![CDATA[
 		}
 
 		internal sealed override Type BindTypeParameters(IGenericBinder binder)
 		{
 			Type type = elementType.BindTypeParameters(binder);
 			Type[] req = BindArray(requiredCustomModifiers, binder);
 			Type[] opt = BindArray(optionalCustomModifiers, binder);
 			if (ReferenceEquals(type, elementType)
 				&& ReferenceEquals(req, requiredCustomModifiers)
 				&& ReferenceEquals(opt, optionalCustomModifiers))
 			{
 				return this;
 			}
 			return Wrap(type, req, opt);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="614" endline="622">
<![CDATA[
 
 		public void Emit (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			ParameterReference.EmitLdArg (ec, arg_idx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="125" endline="134">
<![CDATA[
 		}
 
 		public string GetName (bool is_generic)
 		{
 			string name = is_generic ? Basename 
 			if (Left != null)
 				return Left.GetName (is_generic) + (is_double_colon ? "
 
 			return name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="827" endline="836">
<![CDATA[
 
 		internal new ByteReader ResolveSignature(int metadataToken)
 		{
 			if ((metadataToken >> 24) == StandAloneSigTable.Index)
 			{
 				int index = (metadataToken & 0xFFFFFF) - 1;
 				return ByteReader.FromBlob(blobHeap, StandAloneSig.records[index]);
 			}
 			throw new ArgumentOutOfRangeException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1221" endline="1231">
<![CDATA[
 
 		protected override bool ResolveMemberType ()
 		{
 			if (GenericMethod != null) {
 				MethodBuilder = Parent.TypeBuilder.DefineMethod (GetFullName (MemberName), flags);
 				if (!GenericMethod.Define (this))
 					return false;
 			}
 
 			return base.ResolveMemberType ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="582" endline="594">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			For target = (For) t;
 
 			if (InitStatement != null)
 				target.InitStatement = InitStatement.Clone (clonectx);
 			if (Test != null)
 				target.Test = Test.Clone (clonectx);
 			if (Increment != null)
 				target.Increment = Increment.Clone (clonectx);
 			target.Statement = Statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="640" endline="653">
<![CDATA[
 
 		internal MethodBase GetMethodAt(TypeDefImpl owner, int index)
 		{
 			if (methods == null)
 			{
 				methods = new MethodBase[MethodDef.records.Length];
 			}
 			if (methods[index] == null)
 			{
 				MethodDefImpl method = new MethodDefImpl(this, owner ?? FindMethodOwner(index), index);
 				methods[index] = method.IsConstructor ? new ConstructorInfoImpl(method) 
 			}
 			return methods[index];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1258" endline="1269">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				child.CreateExpressionTree (ec),
 				new TypeOf (new TypeExpression (type, loc), loc));
 
 			if (type.IsPointer)
 				Error_PointerInsideExpressionTree (ec);
 
 			return CreateExpressionFactoryCall (ec, "Convert", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="448" endline="471">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			MemberAccess ma = new MemberAccess (new MemberAccess (new QualifiedAliasMember ("global", "System", loc), "Delegate", loc), "CreateDelegate", loc);
 
 			Arguments args = new Arguments (3);
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 
 			if (method_group.InstanceExpression == null)
 				args.Add (new Argument (new NullLiteral (loc)));
 			else
 				args.Add (new Argument (method_group.InstanceExpression));
 
 			args.Add (new Argument (method_group.CreateExpressionTree (ec)));
 			Expression e = new Invocation (ma, args).Resolve (ec);
 			if (e == null)
 				return null;
 
 			e = Convert.ExplicitConversion (ec, e, type, loc);
 			if (e == null)
 				return null;
 
 			return e.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6551" endline="6583">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			if (first_emit != null) {
 				first_emit.Emit (ec);
 				first_emit_temp.Store (ec);
 			}
 
 			foreach (Expression e in arguments)
 				e.Emit (ec);
 			foreach (Expression e in arguments)
 				e.Emit (ec);
 
 			ec.EmitArrayNew ((ArrayContainer) type);
 			
 			if (initializers == null)
 				return;
 
 			// Emit static initializer for arrays which have contain more than 2 items and
 			// the static initializer will initialize at least 25% of array values or there
 			// is more than 10 items to be initialized
 			// NOTE
 			if (const_initializers_count > 2 && (array_data.Count > 10 || const_initializers_count * 4 > (array_data.Count)) &&
 				(TypeManager.IsPrimitiveType (array_element_type) || TypeManager.IsEnumType (array_element_type))) {
 				EmitStaticInitializers (ec);
 
 				if (!only_constant_initializers)
 					EmitDynamicInitializers (ec, false);
 			} else {
 				EmitDynamicInitializers (ec, true);
 			}
 
 			if (first_emit_temp != null)
 				first_emit_temp.Release (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="345" endline="385">
<![CDATA[
 		}
 
 		protected override TypeExpr [] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			var mtype = Iterator.OriginalIteratorType;
 			if (Mutator != null)
 				mtype = Mutator.Mutate (mtype);
 
 			iterator_type_expr = new TypeExpression (mtype, Location);
 			generic_args = new TypeArguments (iterator_type_expr);
 
 			var list = new List<FullNamedExpression> ();
 			if (Iterator.IsEnumerable) {
 				enumerable_type = new TypeExpression (
 					TypeManager.ienumerable_type, Location);
 				list.Add (enumerable_type);
 
 				if (TypeManager.generic_ienumerable_type != null) {
 					generic_enumerable_type = new GenericTypeExpr (
 						TypeManager.generic_ienumerable_type,
 						generic_args, Location);
 					list.Add (generic_enumerable_type);
 				}
 			}
 
 			enumerator_type = new TypeExpression (
 				TypeManager.ienumerator_type, Location);
 			list.Add (enumerator_type);
 
 			list.Add (new TypeExpression (TypeManager.idisposable_type, Location));
 
 			var ienumerator_generic = Module.PredefinedTypes.IEnumeratorGeneric;
 			if (ienumerator_generic.Define ()) {
 				generic_enumerator_type = new GenericTypeExpr (ienumerator_generic.TypeSpec, generic_args, Location);
 				list.Add (generic_enumerator_type);
 			}
 
 			type_bases = list;
 
 			return base.ResolveBaseTypes (out base_class);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="421" endline="432">
<![CDATA[
 		}
 
 		public IList<CustomAttributeTypedArgument> ConstructorArguments
 		{
 			get
 			{
 				if (lazyConstructorArguments == null)
 				{
 					LazyParseArguments();
 				}
 				return lazyConstructorArguments;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="433" endline="444">
<![CDATA[
 		}
 
 		public IList<CustomAttributeNamedArgument> NamedArguments
 		{
 			get
 			{
 				if (lazyNamedArguments == null)
 				{
 					LazyParseArguments();
 				}
 				return lazyNamedArguments;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="77" endline="85">
<![CDATA[
 
 		public ILGenerator GetILGenerator(int streamSize)
 		{
 			if (ilgen == null)
 			{
 				ilgen = new ILGenerator(typeBuilder.ModuleBuilder, streamSize);
 			}
 			return ilgen;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6925" endline="6935">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			ResolveBase (ec);
 
 			if (variable_info != null && type.IsStruct) {
 				CheckStructThisDefiniteAssignment (ec);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="311" endline="347">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			bool ok = true;
 			source = source.Resolve (ec);
 						
 			if (source == null) {
 				ok = false;
 				source = EmptyExpression.Null;
 			}
 
 			target = target.ResolveLValue (ec, source);
 
 			if (target == null || !ok)
 				return null;
 
 			TypeSpec target_type = target.Type;
 			TypeSpec source_type = source.Type;
 
 			eclass = ExprClass.Value;
 			type = target_type;
 
 			if (!(target is IAssignMethod)) {
 				Error_ValueAssignment (ec, loc);
 				return null;
 			}
 
 			if (target_type != source_type) {
 				Expression resolved = ResolveConversions (ec);
 
 				if (resolved != this)
 					return resolved;
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="467" endline="474">
<![CDATA[
 
 		public bool IsCompilerGenerated {
 			get	{
 				if ((mod_flags & Modifiers.COMPILER_GENERATED) != 0)
 					return true;
 
 				return Parent == null ? false 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2563" endline="2577">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			StringBuilder sb = new StringBuilder ();
 			if (OperatorType == OpType.Implicit || OperatorType == OpType.Explicit) {
 				sb.AppendFormat ("{0}.{1} operator {2}",
 					Parent.GetSignatureForError (), GetName (OperatorType), type_expr.GetSignatureForError ());
 			}
 			else {
 				sb.AppendFormat ("{0}.operator {1}", Parent.GetSignatureForError (), GetName (OperatorType));
 			}
 
 			sb.Append (parameters.GetSignatureForError ());
 			return sb.ToString ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5600" endline="5613">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args;
 			if (method == null) {
 				args = new Arguments (1);
 				args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			} else {
 				args = Arguments.CreateForExpressionTree (ec,
 					arguments, new TypeOfMethod (method, loc));
 			}
 
 			return CreateExpressionFactoryCall (ec, "New", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="113" endline="145">
<![CDATA[
 
 		private void Read()
 		{
 			BinaryReader br = new BinaryReader(stream);
 			peFile.Read(br);
 			stream.Seek(peFile.RvaToFileOffset(peFile.GetComDescriptorVirtualAddress()), SeekOrigin.Begin);
 			cliHeader.Read(br);
 			stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaDataRVA), SeekOrigin.Begin);
 			foreach (StreamHeader sh in ReadStreamHeaders(br, out imageRuntimeVersion))
 			{
 				switch (sh.Name)
 				{
 					case "#Strings"
 						stringHeap = ReadHeap(stream, sh);
 						break;
 					case "#Blob"
 						blobHeap = ReadHeap(stream, sh);
 						break;
 					case "#US"
 						userStringHeap = ReadHeap(stream, sh);
 						break;
 					case "#GUID"
 						guidHeap = ReadHeap(stream, sh);
 						break;
 					case "#~"
 						stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaDataRVA + sh.Offset), SeekOrigin.Begin);
 						ReadTables(br);
 						break;
 					default
 						throw new BadImageFormatException("Unsupported stream
 				}
 			}
 			foreach (StreamHeader sh in ReadStreamHeaders(br, out imageRuntimeVersion))
 			{
 				switch (sh.Name)
 				{
 					case "#Strings"
 						stringHeap = ReadHeap(stream, sh);
 						break;
 					case "#Blob"
 						blobHeap = ReadHeap(stream, sh);
 						break;
 					case "#US"
 						userStringHeap = ReadHeap(stream, sh);
 						break;
 					case "#GUID"
 						guidHeap = ReadHeap(stream, sh);
 						break;
 					case "#~"
 						stream.Seek(peFile.RvaToFileOffset(cliHeader.MetaDataRVA + sh.Offset), SeekOrigin.Begin);
 						ReadTables(br);
 						break;
 					default
 						throw new BadImageFormatException("Unsupported stream
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="42" endline="49">
<![CDATA[
 
 		internal static ByteReader FromBlob(byte[] blobHeap, int blob)
 		{
 			ByteReader br = new ByteReader(blobHeap, blob, 4);
 			int length = br.ReadCompressedInt();
 			br.end = br.pos + length;
 			return br;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="330" endline="340">
<![CDATA[
 
 		private static bool ParsePublicKeyToken(string str, out string publicKeyToken)
 		{
 			if (str == null)
 			{
 				publicKeyToken = null;
 				return false;
 			}
 			publicKeyToken = str.ToLowerInvariant();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2925" endline="2953">
<![CDATA[
 		
 		//
 		// Tests whether all delegate input arguments are fixed and generic output type
 		// requires output type inference 
 		//
 		public bool IsReturnTypeNonDependent (ResolveContext ec, MethodSpec invoke, TypeSpec returnType)
 		{
 			if (returnType.IsGenericParameter) {
 				if (IsFixed (returnType))
 				    return false;
 			} else if (TypeManager.IsGenericType (returnType)) {
 				if (TypeManager.IsDelegateType (returnType)) {
 					invoke = Delegate.GetInvokeMethod (ec.Compiler, returnType);
 					return IsReturnTypeNonDependent (ec, invoke, invoke.ReturnType);
 				}
 					
 				TypeSpec[] g_args = TypeManager.GetTypeArguments (returnType);
 				
 				// At least one unfixed return type has to exist 
 				if (AllTypesAreFixed (g_args))
 					return false;
 			} else {
 				return false;
 			}
 
 			// All generic input arguments have to be fixed
 			AParametersCollection d_parameters = invoke.Parameters;
 			return AllTypesAreFixed (d_parameters.Types);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1600" endline="1609">
<![CDATA[
 		}
 
 		internal sealed override int GetModuleBuilderToken()
 		{
 			if (token == 0)
 			{
 				token = ((ModuleBuilder)elementType.Module).ImportType(this);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2362" endline="2371">
<![CDATA[
 		}
 
 		internal override int GetModuleBuilderToken()
 		{
 			if (token == 0)
 			{
 				token = ((ModuleBuilder)type.Module).ImportType(this);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="1345" endline="1356">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null) {
 				if (rank == 1)
 					info = Element.GetMetaInfo ().MakeArrayType ();
 				else
 					info = Element.GetMetaInfo ().MakeArrayType (rank);
 			}
 
 			return info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="907" endline="919">
<![CDATA[
 
 		public override bool AddResumePoint (ResumableStatement stmt, Location loc, out int pc)
 		{
 			int errors = Report.Errors;
 			Parent.AddResumePoint (this.stmt, loc, out pc);
 			if (errors == Report.Errors) {
 				if (finally_vector == null)
 					this.stmt.AddResumePoint (stmt, pc);
 				else
 					Report.Error (1625, loc, "Cannot yield in the body of a finally clause");
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="920" endline="935">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddBreakOrigin (vector, loc);
 				if (errors == Report.Errors)
 					Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new BreakOrigin (saved_origins, vector, loc);
 			}
 
 			// either the loop test or a back jump will follow code
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="936" endline="951">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			if (finally_vector != null) {
 				int errors = Report.Errors;
 				Parent.AddContinueOrigin (vector, loc);
 				if (errors == Report.Errors)
 					Report.Error (157, loc, "Control cannot leave the body of a finally clause");
 			} else {
 				saved_origins = new ContinueOrigin (saved_origins, vector, loc);
 			}
 
 			// either the loop test or a back jump will follow code
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1145" endline="1163">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			left = left.Resolve (ec);
 			right = right.Resolve (ec);
 
 			if (left == null || right == null)
 				return null;
 
 			eclass = ExprClass.Value;
 
 			Expression e = ConvertExpression (ec);
 			if (e == null) {
 				Binary.Error_OperatorCannotBeApplied (ec, left, right, "??", loc);
 				return null;
 			}
 
 			return e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="1174" endline="1183">
<![CDATA[
 
 		/// <summary>
 		///   Used to validate that all the using clauses are correct
 		///   after we are finished parsing all the files.  
 		/// </summary>
 		static public void VerifyAllUsing ()
 		{
 			foreach (NamespaceEntry entry in entries)
 				entry.VerifyUsing ();
 			foreach (NamespaceEntry entry in entries)
 				entry.VerifyUsing ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="136" endline="144">
<![CDATA[
 
 		internal void WriteMethodDefTable(int baseRVA, MetadataWriter mw)
 		{
 			int paramList = 1;
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteMethodDefRecords(baseRVA, mw, ref paramList);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteMethodDefRecords(baseRVA, mw, ref paramList);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="249" endline="260">
<![CDATA[
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (!MemberType.IsCLSCompliant () || this is FixedField) {
 				Report.Warning (3003, 1, Location, "Type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="484" endline="511">
<![CDATA[
 
 		public void EmitConstraints (GenericTypeParameterBuilder builder)
 		{
 			var attr = GenericParameterAttributes.None;
 			if (spec.Variance == Variance.Contravariant)
 				attr |= GenericParameterAttributes.Contravariant;
 			else if (spec.Variance == Variance.Covariant)
 				attr |= GenericParameterAttributes.Covariant;
 
 			if (spec.HasSpecialClass)
 				attr |= GenericParameterAttributes.ReferenceTypeConstraint;
 			else if (spec.HasSpecialStruct)
 				attr |= GenericParameterAttributes.NotNullableValueTypeConstraint | GenericParameterAttributes.DefaultConstructorConstraint;
 
 			if (spec.HasSpecialConstructor)
 				attr |= GenericParameterAttributes.DefaultConstructorConstraint;
 
 			if (spec.BaseType != TypeManager.object_type)
 				builder.SetBaseTypeConstraint (spec.BaseType.GetMetaInfo ());
 
 			if (spec.InterfacesDefined != null)
 				builder.SetInterfaceConstraints (spec.InterfacesDefined.Select (l => l.GetMetaInfo ()).ToArray ());
 
 			if (spec.TypeArguments != null)
 				builder.SetInterfaceConstraints (spec.TypeArguments.Select (l => l.GetMetaInfo ()).ToArray ());
 
 			builder.SetGenericParameterAttributes (attr);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="743" endline="755">
<![CDATA[
 
 		public override bool AddResumePoint (ResumableStatement stmt, Location loc, out int pc)
 		{
 			int errors = Report.Errors;
 			Parent.AddResumePoint (stmt, loc, out pc);
 			if (errors == Report.Errors) {
 				if (CurrentUsageVector.Next == null)
 					Report.Error (1626, loc, "Cannot yield a value in the body of a try block with a catch clause");
 				else
 					Report.Error (1631, loc, "Cannot yield a value in the body of a catch clause");
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1742" endline="1753">
<![CDATA[
 
 		StringBuilder Dump (StringBuilder sb)
 		{
 			var dump = vector == null ? shared 
 			if (dump == null)
 				return sb.Append ("/");
 			if (dump == shared)
 				sb.Append ("=");
 			for (int i = 0; i < dump.Count; i++)
 				sb.Append (dump [i] ? "1" 
 			for (int i = 0; i < dump.Count; i++)
 				sb.Append (dump [i] ? "1" 
 			return sb;
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6172" endline="6206">
<![CDATA[
 
 public void parse ()
 {
 	eof_token = Token.EOF;
 	Tokenizer.LocatedToken.Initialize ();
 	
 	try {
 		if (yacc_verbose_flag > 1)
 			yyparse (lexer, new yydebug.yyDebugSimple ());
 		else
 			yyparse (lexer);
 			
 		Tokenizer tokenizer = lexer as Tokenizer;
 		tokenizer.cleanup ();		
 	} catch (Exception e){
 	  	if (e is yyParser.yyUnexpectedEof) {
 			Error_SyntaxError (yyToken);
 			UnexpectedEOF = true;
 			return;
 		}
 			
 		if (e is yyParser.yyException) {
 			Report.Error (-25, lexer.Location, "Parsing error");
 		} else {
 			// Used by compiler-tester to test internal errors
 			if (yacc_verbose_flag > 0)
 				throw;
 		
 			Report.Error (589, lexer.Location, "Internal compiler error during parsing");
 		}
 	}
 
 	if (RootContext.ToplevelTypes.NamespaceEntry != null)
 		throw new InternalErrorException ("who set it?");
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="517" endline="533">
<![CDATA[
 
 	static string GetTypeKind (Type t)
 	{
 		if (t.IsEnum)
 			return "enum";
 		if (t.IsClass) {
 			if (t.IsSubclassOf (typeof (System.MulticastDelegate)))
 				return "delegate";
 			else
 				return "class";
 		}
 		if (t.IsInterface)
 			return "interface";
 		if (t.IsValueType)
 			return "struct";
 		return "class";
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5260" endline="5269">
<![CDATA[
 
 		static MetaType[] GetVarargsTypes (MethodSpec mb, Arguments arguments)
 		{
 			AParametersCollection pd = mb.Parameters;
 
 			Argument a = arguments[pd.Count - 1];
 			Arglist list = (Arglist) a.Expr;
 
 			return list.ArgumentTypes;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="533" endline="550">
<![CDATA[
 
 		// when we refer to a method on a generic type definition in the IL stream,
 		// we need to use a MemberRef (even if the method is in the same module)
 		internal MethodToken GetMethodTokenForIL(MethodInfo method)
 		{
 			if (method.IsGenericMethodDefinition)
 			{
 				method = method.MakeGenericMethod(method.GetGenericArguments());
 			}
 			if (IsFromGenericTypeDefinition(method))
 			{
 				return new MethodToken(ImportMember(method));
 			}
 			else
 			{
 				return GetMethodToken(method);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7148" endline="7160">
<![CDATA[
 
 		protected Expression DoResolveBase ()
 		{
 			if (TypeManager.system_type_get_type_from_handle == null) {
 				TypeManager.system_type_get_type_from_handle = TypeManager.GetPredefinedMethod (
 					TypeManager.type_type, "GetTypeFromHandle", loc, TypeManager.runtime_handle_type);
 			}
 
 			// Even though what is returned is a type object, it's treated as a value by the compiler.
 			// In particular, 'typeof (Foo).X' is something totally different from 'Foo.X'.
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="2143" endline="2149">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			Constant new_value = value.ConvertExplicitly (in_checked_context, target_type);
 			return new_value == null ? null 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1301" endline="1309">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				expr.CreateExpressionTree (ec),
 				new TypeOf (probe_type_expr, loc));
 
 			return CreateExpressionFactoryCall (ec, "TypeIs", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1469" endline="1477">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, null,
 				expr.CreateExpressionTree (ec),
 				new TypeOf (probe_type_expr, loc));
 
 			return CreateExpressionFactoryCall (ec, "TypeAs", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="506" endline="515">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteResolutionScope(records[i].ResolutionScope);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNameSpace);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteResolutionScope(records[i].ResolutionScope);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNameSpace);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="789" endline="798">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMemberRefParent(records[i].Class);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Signature);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteMemberRefParent(records[i].Class);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Signature);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="855" endline="864">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Type);
 				mw.WriteHasConstant(records[i].Parent);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Type);
 				mw.WriteHasConstant(records[i].Parent);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="987" endline="996">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasCustomAttribute(records[i].Parent);
 				mw.WriteCustomAttributeType(records[i].Type);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteHasCustomAttribute(records[i].Parent);
 				mw.WriteCustomAttributeType(records[i].Type);
 				mw.WriteBlobIndex(records[i].Value);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1178" endline="1187">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Action);
 				mw.WriteHasDeclSecurity(records[i].Parent);
 				mw.WriteBlobIndex(records[i].PermissionSet);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Action);
 				mw.WriteHasDeclSecurity(records[i].Parent);
 				mw.WriteBlobIndex(records[i].PermissionSet);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1451" endline="1460">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].EventFlags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteTypeDefOrRef(records[i].EventType);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].EventFlags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteTypeDefOrRef(records[i].EventType);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1529" endline="1538">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Type);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].Type);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1578" endline="1587">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Semantics);
 				mw.WriteMethodDef(records[i].Method);
 				mw.WriteHasSemantics(records[i].Association);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Semantics);
 				mw.WriteMethodDef(records[i].Method);
 				mw.WriteHasSemantics(records[i].Association);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1706" endline="1715">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteMethodDefOrRef(records[i].MethodBody);
 				mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.WriteTypeDef(records[i].Class);
 				mw.WriteMethodDefOrRef(records[i].MethodBody);
 				mw.WriteMethodDefOrRef(records[i].MethodDeclaration);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2093" endline="2102">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1836" endline="1846">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MappingFlags);
 				mw.WriteMemberForwarded(records[i].MemberForwarded);
 				mw.WriteStringIndex(records[i].ImportName);
 				mw.WriteModuleRef(records[i].ImportScope);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MappingFlags);
 				mw.WriteMemberForwarded(records[i].MemberForwarded);
 				mw.WriteStringIndex(records[i].ImportName);
 				mw.WriteModuleRef(records[i].ImportScope);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2198" endline="2208">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Offset);
 				mw.Write(records[i].Flags);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2294" endline="2304">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Number);
 				mw.Write(records[i].Flags);
 				mw.WriteTypeOrMethodDef(records[i].Owner);
 				mw.WriteStringIndex(records[i].Name);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Number);
 				mw.Write(records[i].Flags);
 				mw.WriteTypeOrMethodDef(records[i].Owner);
 				mw.WriteStringIndex(records[i].Name);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="2032" endline="2056">
<![CDATA[
 
 		public override Constant ConvertExplicitly (bool inCheckedContext, TypeSpec targetType)
 		{
 			if (targetType.IsPointer) {
 				if (IsLiteral || this is NullPointer)
 					return new EmptyConstantCast (new NullPointer (loc), targetType);
 
 				return null;
 			}
 
 			// Exlude internal compiler types
 			if (targetType.Kind == MemberKind.InternalCompilerType && targetType != InternalType.Dynamic && targetType != InternalType.Null)
 				return null;
 
 			if (!IsLiteral && !Convert.ImplicitStandardConversionExists (this, targetType))
 				return null;
 
 			if (TypeManager.IsReferenceType (targetType))
 				return new NullConstant (targetType, loc);
 
 			if (TypeManager.IsNullableType (targetType))
 				return Nullable.LiftedNull.Create (targetType, loc);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="322" endline="330">
<![CDATA[
 		}
 
 		public CodeBlockEntry CurrentBlock {
 			get {
 				if ((_block_stack != null) && (_block_stack.Count > 0))
 					return (CodeBlockEntry) _block_stack.Peek ();
 				else
 					return null;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="958" endline="969">
<![CDATA[
 
 		//
 		// Returns true for StructLayoutAttribute with LayoutKind.Explicit value
 		// 
 		public bool IsExplicitLayoutKind ()
 		{
 			if (PosArguments == null || PosArguments.Count != 1)
 				return false;
 
 			var value = (LayoutKind) System.Enum.Parse (typeof (LayoutKind), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 			return value == LayoutKind.Explicit;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="128" endline="148">
<![CDATA[
 
 		void AddModuleCharSet (ResolveContext rc)
 		{
 			const string dll_import_char_set = "CharSet";
 
 			//
 			// Only when not customized by user
 			//
 			if (HasField (dll_import_char_set))
 				return;
 
 			if (!rc.Module.PredefinedTypes.CharSet.IsDefined) {
 				return;
 			}
 
 			if (NamedArguments == null)
 				NamedArguments = new Arguments (1);
 
 			var value = Constant.CreateConstant (rc, rc.Module.PredefinedTypes.CharSet.TypeSpec, rc.Module.DefaultCharSet, Location);
 			NamedArguments.Add (new NamedArgument (dll_import_char_set, loc, value));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="482" endline="490">
<![CDATA[
 
 		private static Type[] NormalizeAndCopy(Type[][] array, int index)
 		{
 			if (array == null || array.Length == 0)
 			{
 				return null;
 			}
 			return NormalizeAndCopy(array[index]);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1427" endline="1439">
<![CDATA[
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			if (this.type == type) {
 				return this;
 			}
 
 			if (!Convert.ImplicitStandardConversionExists (this, type)){
 				return null;
 			}
 
 			return Child.ConvertImplicitly (rc, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2881" endline="2895">
<![CDATA[
 
 		protected Expression DoResolveCore (ResolveContext ec, Expression left_orig, Expression right_orig)
 		{
 			Expression expr = ResolveOperator (ec);
 			if (expr == null)
 				Error_OperatorCannotBeApplied (ec, left_orig, right_orig);
 
 			if (left == null || right == null)
 				throw new InternalErrorException ("Invalid conversion");
 
 			if (oper == Operator.BitwiseOr)
 				CheckBitwiseOrOnSignExtended (ec);
 
 			return expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2116" endline="2125">
<![CDATA[
 		}
 
 		#endregion
 
 		public override bool Equals (object obj)
 		{
 			ATypeNameExpression atne = obj as ATypeNameExpression;
 			return atne != null && atne.Name == Name &&
 				(targs == null || targs.Equals (atne.targs));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="855" endline="881">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			if (!ec.IsUnsafe)
 				UnsafeError (ec, loc);
 
 			var pc = expr.Type as PointerContainer;
 
 			if (pc == null) {
 				ec.Report.Error (193, loc, "The * or -> operator must be applied to a pointer");
 				return null;
 			}
 
 			type = pc.Element;
 
 			if (type.BuildinType == BuildinTypeSpec.Type.Void) {
 				Error_VoidPointerOperation (ec);
 				return null;
 			}
 
 			eclass = ExprClass.Variable;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="433" endline="446">
<![CDATA[
 		}
 
 		public bool MustCaptureVariable (INamedBlockVariable local)
 		{
 			if (CurrentAnonymousMethod == null)
 				return false;
 
 			// FIXME
 			// block contains yield
 			if (CurrentAnonymousMethod.IsIterator)
 				return true;
 
 			return local.Block.ParametersBlock != CurrentBlock.ParametersBlock.Original;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="410" endline="446">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		// This is called for each part of a partial generic type definition.
 		//
 		// If partial type parameters constraints are not null and we don't
 		// already have constraints they become our constraints. If we already
 		// have constraints, we must check that they're the same.
 		//
 		public bool AddPartialConstraints (TypeContainer part, TypeParameter tp)
 		{
 			if (builder == null)
 				throw new InvalidOperationException ();
 
 			var new_constraints = tp.constraints;
 			if (new_constraints == null)
 				return true;
 
 			// TODO
 			//tp.Define (null, -1, part.Definition);
 			tp.spec.DeclaringType = part.Definition;
 			if (!tp.ResolveConstraints (part))
 				return false;
 
 			if (constraints != null)
 				return spec.HasSameConstraintsDefinition (tp.Type);
 
 			// Copy constraint from resolved part to partial container
 			spec.SpecialConstraint = tp.spec.SpecialConstraint;
 			spec.InterfacesDefined = tp.spec.InterfacesDefined;
 			spec.TypeArguments = tp.spec.TypeArguments;
 			spec.BaseType = tp.spec.BaseType;
 			
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2097" endline="2119">
<![CDATA[
 #endif
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Block target = (Block) t;
 #if DEBUG
 			target.clone_id = clone_id_counter++;
 #endif
 
 			clonectx.AddBlockMap (this, target);
 			if (original != this)
 				clonectx.AddBlockMap (original, target);
 
 			target.ParametersBlock = (ParametersBlock) (ParametersBlock == this ? target 
 			target.Explicit = (ExplicitBlock) (Explicit == this ? target 
 
 			if (Parent != null)
 				target.Parent = clonectx.RemapBlockCopy (Parent);
 
 			target.statements = new List<Statement> (statements.Count);
 			foreach (Statement s in statements)
 				target.statements.Add (s.Clone (clonectx));
 			foreach (Statement s in statements)
 				target.statements.Add (s.Clone (clonectx));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="631" endline="660">
<![CDATA[
 
 		/// <summary>
 		///  Same as ImplicitStandardConversionExists except that it also looks at
 		///  implicit user defined conversions - needed for overload resolution
 		/// </summary>
 		public static bool ImplicitConversionExists (ResolveContext ec, Expression expr, TypeSpec target_type)
 		{
 			if (ImplicitStandardConversionExists (expr, target_type))
 				return true;
 
 			if (expr.Type == InternalType.AnonymousMethod) {
 				if (!TypeManager.IsDelegateType (target_type) && target_type.GetDefinition () != TypeManager.expression_type)
 					return false;
 
 				AnonymousMethodExpression ame = (AnonymousMethodExpression) expr;
 				return ame.ImplicitStandardConversionExists (ec, target_type);
 			}
 			
 			if (expr.eclass == ExprClass.MethodGroup) {
 				if (target_type.IsDelegate && RootContext.Version != LanguageVersion.ISO_1) {
 					MethodGroupExpr mg = expr as MethodGroupExpr;
 					if (mg != null)
 						return DelegateCreation.ImplicitStandardConversionExists (ec, mg, target_type);
 				}
 
 				return false;
 			}
 
 			return ImplicitUserConversion (ec, expr, target_type, Location.Null) != null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9289" endline="9302">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (mg.CreateExpressionTree (ec)));
 
 			var expr_initializers = new ArrayInitializer (arguments.Count, loc);
 			foreach (Argument a in arguments)
 				expr_initializers.Add (a.CreateExpressionTree (ec));
 			foreach (Argument a in arguments)
 				expr_initializers.Add (a.CreateExpressionTree (ec));
 
 			args.Add (new Argument (new ArrayCreation (
 				CreateExpressionTypeExpression (ec, loc), expr_initializers, loc)));
 			return CreateExpressionFactoryCall (ec, "ElementInit", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EnumBuilder.cs" startline="59" endline="66">
<![CDATA[
 		}
 
 		public FieldBuilder DefineLiteral(string literalName, object literalValue)
 		{
 			FieldBuilder fb = typeBuilder.DefineField(literalName, typeBuilder, FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
 			fb.SetConstant(literalValue);
 			return fb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="326" endline="334">
<![CDATA[
 		}
 
 		public override Type DeclaringType
 		{
 			get
 			{
 				int owner = module.GenericParam.records[index].Owner;
 				return (owner >> 24) == TypeDefTable.Index ? module.ResolveType(owner) 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="335" endline="343">
<![CDATA[
 		}
 
 		public override MethodBase DeclaringMethod
 		{
 			get
 			{
 				int owner = module.GenericParam.records[index].Owner;
 				return (owner >> 24) == MethodDefTable.Index ? module.ResolveMethod(owner) 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="444" endline="455">
<![CDATA[
 		}
 
 		// 
 		// Returns full member name for error message
 		//
 		public virtual string GetSignatureForError ()
 		{
 			if (Parent == null || Parent.Parent == null)
 				return member_name.GetSignatureForError ();
 
 			return Parent.GetSignatureForError () + "." + member_name.GetSignatureForError ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="161" endline="190">
<![CDATA[
 
 		internal ByteBuffer GetSignature(ModuleBuilder module)
 		{
 			ByteBuffer bb = new ByteBuffer(16);
 			switch (type)
 			{
 				case 0
 					if (unmanaged)
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, unmanagedCallConv, returnType, args.ToArray());
 					}
 					else
 					{
 						Signature.WriteStandAloneMethodSig(module, bb, callingConvention, returnType, args.ToArray(), optionalArgs.ToArray());
 					}
 					break;
 				case Signature.FIELD
 					FieldSignature.Create(args[0], optionalCustomModifiers[0], requiredCustomModifiers[0]).WriteSig(module, bb);
 					break;
 				case Signature.PROPERTY
 					Signature.WritePropertySig(module, bb, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, args.ToArray(), requiredCustomModifiers.ToArray(), optionalCustomModifiers.ToArray());
 					break;
 				case Signature.LOCAL_SIG
 					Signature.WriteLocalVarSig(module, bb, locals);
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 			return bb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="496" endline="509">
<![CDATA[
 		}
 
 		internal void Write (MyBinaryWriter bw)
 		{
 			bw.WriteLeb128 (ID);
 
 			bw.WriteLeb128 (captured_vars.Count);
 			foreach (CapturedVariable cv in captured_vars)
 				cv.Write (bw);
 			foreach (CapturedVariable cv in captured_vars)
 				cv.Write (bw);
 
 			bw.WriteLeb128 (captured_scopes.Count);
 			foreach (CapturedScope cs in captured_scopes)
 				cs.Write (bw);
 			foreach (CapturedScope cs in captured_scopes)
 				cs.Write (bw);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="167" endline="179">
<![CDATA[
 
 		// <summary>
 		//   Ends a code branching.  Merges the state of locals and parameters
 		//   from all the children of the ending branching.
 		// </summary>
 		public bool EndFlowBranching ()
 		{
 			FlowBranching old = current_flow_branching;
 			current_flow_branching = current_flow_branching.Parent;
 
 			FlowBranching.UsageVector vector = current_flow_branching.MergeChild (old);
 			return vector.IsUnreachable;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="581" endline="609">
<![CDATA[
 		}
 
 		internal void Bake()
 		{
 			this.signature = this.ModuleBuilder.GetSignatureBlobIndex(this.MethodSignature);
 
 			if (ilgen != null)
 			{
 				if (this.ModuleBuilder.symbolWriter != null)
 				{
 					this.ModuleBuilder.symbolWriter.OpenMethod(new SymbolToken(-pseudoToken | 0x06000000));
 				}
 				rva = ilgen.WriteBody(initLocals);
 				if (this.ModuleBuilder.symbolWriter != null)
 				{
 					this.ModuleBuilder.symbolWriter.CloseMethod();
 				}
 				ilgen = null;
 			}
 			else
 			{
 				rva = -1;
 			}
 
 			if (declarativeSecurity != null)
 			{
 				this.ModuleBuilder.AddDeclarativeSecurity(pseudoToken, declarativeSecurity);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4754" endline="4764">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			Arguments arg = new Arguments (1);
 			arg.Add (new Argument (this));
 			return CreateExpressionFactoryCall (ec, "Constant", arg);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="638" endline="649">
<![CDATA[
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if ((ModFlags & Modifiers.VOLATILE) != 0) {
 				Report.Warning (3026, 1, Location, "CLS-compliant field `{0}' cannot be volatile", GetSignatureForError ());
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="153" endline="159">
<![CDATA[
 
 		public FlowBranchingIterator StartFlowBranching (Iterator iterator, FlowBranching parent)
 		{
 			FlowBranchingIterator branching = new FlowBranchingIterator (parent, iterator);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="160" endline="166">
<![CDATA[
 
 		public FlowBranchingToplevel StartFlowBranching (ParametersBlock stmt, FlowBranching parent)
 		{
 			FlowBranchingToplevel branching = new FlowBranchingToplevel (parent, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="645" endline="651">
<![CDATA[
 
 		public static DynamicInvocation CreateSpecialNameInvoke (ATypeNameExpression member, Arguments args, Location loc)
 		{
 			return new DynamicInvocation (member, args, loc) {
 				flags = CSharpBinderFlags.InvokeSpecialName
 			};
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1015" endline="1031">
<![CDATA[
 		}
 
 		#endregion
 
 		public virtual ObsoleteAttribute GetAttributeObsolete ()
 		{
 			if ((state & (StateFlags.Obsolete | StateFlags.Obsolete_Undetected)) == 0)
 				return null;
 
 			state &= ~StateFlags.Obsolete_Undetected;
 
 			var oa = definition.GetAttributeObsolete ();
 			if (oa != null)
 				state |= StateFlags.Obsolete;
 
 			return oa;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="198" endline="208">
<![CDATA[
 
 		internal override int GetModuleBuilderToken()
 		{
 			if (typeToken == 0)
 			{
 				ByteBuffer spec = new ByteBuffer(5);
 				Signature.WriteTypeSpec(this.ModuleBuilder, spec, this);
 				typeToken = 0x1B000000 | this.ModuleBuilder.TypeSpec.AddRecord(this.ModuleBuilder.Blobs.Add(spec));
 			}
 			return typeToken;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="445" endline="465">
<![CDATA[
 		}
 
 		private void LazyParseArguments()
 		{
 			ByteReader br = module.GetBlob(module.CustomAttribute.records[index].Value);
 			if (br.Length == 0)
 			{
 				// it's legal to have an empty blob
 				lazyConstructorArguments = Empty<CustomAttributeTypedArgument>.Array;
 				lazyNamedArguments = Empty<CustomAttributeNamedArgument>.Array;
 			}
 			else
 			{
 				if (br.ReadUInt16() != 1)
 				{
 					throw new BadImageFormatException();
 				}
 				lazyConstructorArguments = ReadConstructorArguments(module.Assembly, br, Constructor);
 				lazyNamedArguments = ReadNamedArguments(module.Assembly, br, br.ReadUInt16(), Constructor.DeclaringType);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5255" endline="5275">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args;
 			if (IsSingleDimensionalArrayLength ()) {
 				args = new Arguments (1);
 				args.Add (new Argument (InstanceExpression.CreateExpressionTree (ec)));
 				return CreateExpressionFactoryCall (ec, "ArrayLength", args);
 			}
 
 			args = new Arguments (2);
 			if (InstanceExpression == null)
 				args.Add (new Argument (new NullLiteral (loc)));
 			else
 				args.Add (new Argument (InstanceExpression.CreateExpressionTree (ec)));
 			args.Add (new Argument (new TypeOfMethod (Getter, loc)));
 			return CreateExpressionFactoryCall (ec, "Property", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3389" endline="3397">
<![CDATA[
 		}
 
 		TypeSpec DelegateType {
 			get {
 				if ((restrictions & Restrictions.DelegateInvoke) == 0)
 					throw new InternalErrorException ("Not running in delegate mode", loc);
 
 				return members [0].DeclaringType;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="701" endline="726">
<![CDATA[
 
 		/// <summary>
 		/// Goes through class hierarchy and gets value of first found CLSCompliantAttribute.
 		/// If no is attribute exists then assembly CLSCompliantAttribute is returned.
 		/// </summary>
 		public bool IsNotCLSCompliant ()
 		{
 			if ((caching_flags & Flags.HasCompliantAttribute_Undetected) == 0)
 				return (caching_flags & Flags.ClsCompliantAttributeFalse) != 0;
 
 			caching_flags &= ~Flags.HasCompliantAttribute_Undetected;
 
 			if (OptAttributes != null) {
 				Attribute cls_attribute = OptAttributes.Search (Module.PredefinedAttributes.CLSCompliant);
 				if (cls_attribute != null) {
 					caching_flags |= Flags.HasClsCompliantAttribute;
 					if (cls_attribute.GetClsCompliantAttributeValue ())
 						return false;
 
 					caching_flags |= Flags.ClsCompliantAttributeFalse;
 					return true;
 				}
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8501" endline="8546">
<![CDATA[
 
 		protected override Expression OverloadResolve (ResolveContext rc, Expression right_side)
 		{
 			if (best_candidate != null)
 				return this;
 
 			eclass = ExprClass.IndexerAccess;
 
 			bool dynamic;
 			arguments.Resolve (rc, out dynamic);
 
 			if (indexers == null && InstanceExpression.Type == InternalType.Dynamic) {
 				dynamic = true;
 			} else {
 				var res = new OverloadResolver (indexers, OverloadResolver.Restrictions.None, loc);
 				res.BaseMembersProvider = this;
 
 				// TODO
 				best_candidate = res.ResolveMember<IndexerSpec> (rc, ref arguments);
 				if (best_candidate != null)
 					type = res.BestCandidateReturnType;
 				else if (!res.BestCandidateIsDynamic)
 					return null;
 			}
 
 			//
 			// It has dynamic arguments
 			//
 			if (dynamic) {
 				Arguments args = new Arguments (arguments.Count + 1);
 				if (IsBase) {
 					rc.Report.Error (1972, loc,
 						"The indexer base access cannot be dynamically dispatched. Consider casting the dynamic arguments or eliminating the base access");
 				} else {
 					args.Add (new Argument (InstanceExpression));
 				}
 				args.AddRange (arguments);
 
 				best_candidate = null;
 				return new DynamicIndexBinder (args, loc);
 			}
 
 			ResolveInstanceExpression (rc, right_side);
 			CheckProtectedMemberAccess (rc, best_candidate);
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="532" endline="542">
<![CDATA[
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			if (resolved == null)
 				return;
 			
 			if (resolved != this)
 				resolved.EmitStatement (ec);
 			else
 				base.EmitStatement (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1369" endline="1381">
<![CDATA[
 		}
 
 		//
 		// Inflated type parameters with constraints array, mapping with type arguments is based on index
 		//
 		public TypeParameterSpec[] Constraints {
 			get {
 				if (constraints == null) {
 					constraints = TypeParameterSpec.InflateConstraints (MemberDefinition.TypeParameters, l => l.CreateLocalInflator (), this);
 				}
 
 				return constraints;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="89" endline="99">
<![CDATA[
 
 		internal Module ToModule(Assembly assembly)
 		{
 			if (module.Assembly != null)
 			{
 				throw new InvalidOperationException();
 			}
 			imported = true;
 			module.SetAssembly(assembly);
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="799" endline="811">
<![CDATA[
 		}
 
 		public NamespaceEntry ImplicitParent {
 			get {
 				if (parent == null)
 					return null;
 				if (implicit_parent == null) {
 					implicit_parent = (parent.NS == ns.Parent)
 						? parent
 						
 				}
 				return implicit_parent;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="916" endline="924">
<![CDATA[
 
 		protected override bool DoResolveTypeParameters ()
 		{
 			instance_type = spec;
 			if (mutator != null)
 				instance_type = instance_type.MakeGenericType (mutator.MethodTypeParameters.Select (l => l.Type).ToArray ());
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="46" endline="54">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			GenericMethodInstance other = obj as GenericMethodInstance;
 			return other != null
 				&& other.method.Equals(method)
 				&& other.declaringType.Equals(declaringType)
 				&& Util.ArrayEquals(other.methodArgs, methodArgs);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1682" endline="1692">
<![CDATA[
 
 		public bool IsThisAssigned (BlockContext ec, Block block)
 		{
 			if (VariableInfo == null)
 				throw new Exception ();
 
 			if (!ec.DoFlowAnalysis || ec.CurrentBranching.IsAssigned (VariableInfo))
 				return true;
 
 			return VariableInfo.TypeInfo.IsFullyInitialized (ec, VariableInfo, block.StartLocation);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="69" endline="80">
<![CDATA[
 
 		internal byte[] ReadBytes(int count)
 		{
 			if (count < 0)
 				throw new BadImageFormatException();
 			if (end - pos < count)
 				throw new BadImageFormatException();
 			byte[] buf = new byte[count];
 			Buffer.BlockCopy(buffer, pos, buf, 0, count);
 			pos += count;
 			return buf;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="39" endline="52">
<![CDATA[
 		{
 			Offset = br.ReadUInt32();
 			Size = br.ReadUInt32();
 			byte[] buf = new byte[32];
 			byte b;
 			int len = 0;
 			while ((b = br.ReadByte()) != 0)
 			{
 				buf[len++] = b;
 			}
 			while ((b = br.ReadByte()) != 0)
 			{
 				buf[len++] = b;
 			}
 			Name = Encoding.UTF8.GetString(buf, 0, len); ;
 			int padding = -1 + ((len + 4) & ~3) - len;
 			br.BaseStream.Seek(padding, SeekOrigin.Current);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="219" endline="236">
<![CDATA[
 
 		internal TypeBuilder DefineNestedTypeHelper(TypeBuilder enclosingType, string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize)
 		{
 			if (parent == null && (attr & TypeAttributes.Interface) == 0)
 			{
 				parent = universe.System_Object;
 			}
 			TypeBuilder typeBuilder = new TypeBuilder(enclosingType, name, parent, attr);
 			PostDefineType(typeBuilder, packingSize, typesize);
 			if (enclosingType != null)
 			{
 				NestedClassTable.Record rec = new NestedClassTable.Record();
 				rec.NestedClass = typeBuilder.MetadataToken;
 				rec.EnclosingClass = enclosingType.MetadataToken;
 				this.NestedClass.AddRecord(rec);
 			}
 			return typeBuilder;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7935" endline="7950">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			using (ec.With (ResolveContext.Options.AllCheckStateFlags, true))
 				Expr = Expr.Resolve (ec);
 			
 			if (Expr == null)
 				return null;
 
 			if (Expr is Constant || Expr is MethodGroupExpr || Expr is AnonymousMethodExpression || Expr is DefaultValueExpression)
 				return Expr;
 			
 			eclass = Expr.eclass;
 			type = Expr.Type;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7997" endline="8012">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			using (ec.With (ResolveContext.Options.AllCheckStateFlags, false))
 				Expr = Expr.Resolve (ec);
 
 			if (Expr == null)
 				return null;
 
 			if (Expr is Constant || Expr is MethodGroupExpr || Expr is AnonymousMethodExpression || Expr is DefaultValueExpression)
 				return Expr;
 			
 			eclass = Expr.eclass;
 			type = Expr.Type;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4942" endline="4969">
<![CDATA[
 
 		bool DoResolveBase (ResolveContext ec)
 		{
 			type = pi.ParameterType;
 			eclass = ExprClass.Variable;
 
 			//
 			// If we are referencing a parameter from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (pi)) {
 				if (Parameter.HasAddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (IsRef) {
 					ec.Report.Error (1628, loc,
 						"Parameter `{0}' cannot be used inside `{1}' when using `ref' or `out' modifier",
 						Name, ec.CurrentAnonymousMethod.ContainerType);
 				}
 
 				if (ec.IsVariableCapturingRequired && !pi.Block.ParametersBlock.IsExpressionTree) {
 					AnonymousMethodStorey storey = pi.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureParameter (ec, this);
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="350" endline="389">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				ok = false;
 
 			//
 			// Inform whether we are infinite or not
 			//
 			if (expr is Constant){
 				bool value = !((Constant) expr).IsDefaultValue;
 
 				if (value == false){
 					if (!Statement.ResolveUnreachable (ec, true))
 						return false;
 					empty = true;
 					return true;
 				} else
 					infinite = true;
 			}
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Loop, loc);
 			if (!infinite)
 				ec.CurrentBranching.CreateSibling ();
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Embedded, loc);
 			if (!Statement.Resolve (ec))
 				ok = false;
 			ec.EndFlowBranching ();
 
 			// There's no direct control flow from the end of the embedded statement to the end of the loop
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 
 			ec.EndFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="268" endline="297">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			bool ok = true;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Loop, loc);
 
 			bool was_unreachable = ec.CurrentBranching.CurrentUsageVector.IsUnreachable;
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Embedded, loc);
 			if (!EmbeddedStatement.Resolve (ec))
 				ok = false;
 			ec.EndFlowBranching ();
 
 			if (ec.CurrentBranching.CurrentUsageVector.IsUnreachable && !was_unreachable)
 				ec.Report.Warning (162, 2, expr.Location, "Unreachable code detected");
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				ok = false;
 			else if (expr is Constant){
 				bool infinite = !((Constant) expr).IsDefaultValue;
 				if (infinite)
 					ec.CurrentBranching.CurrentUsageVector.Goto ();
 			}
 
 			ec.EndFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3827" endline="3885">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			//
 			// Needed to emit anonymous storey initialization
 			// Otherwise it does not contain any statements for now
 			//
 			block.Emit (ec);
 
 			default_target = ec.DefineLabel ();
 			null_target = ec.DefineLabel ();
 
 			// Store variable for comparission purposes
 			// TODO
 			LocalTemporary value;
 			if (HaveUnwrap) {
 				value = new LocalTemporary (SwitchType);
 				unwrap.EmitCheck (ec);
 				ec.Emit (OpCodes.Brfalse, null_target);
 				new_expr.Emit (ec);
 				value.Store (ec);
 			} else if (!is_constant) {
 				value = new LocalTemporary (SwitchType);
 				new_expr.Emit (ec);
 				value.Store (ec);
 			} else
 				value = null;
 
 			//
 			// Setup the codegen context
 			//
 			Label old_end = ec.LoopEnd;
 			Switch old_switch = ec.Switch;
 			
 			ec.LoopEnd = ec.DefineLabel ();
 			ec.Switch = this;
 
 			// Emit Code.
 			if (is_constant) {
 				if (constant_section != null)
 					constant_section.Block.Emit (ec);
 			} else if (string_dictionary != null) {
 				DoEmitStringSwitch (value, ec);
 			} else {
 				TableSwitchEmit (ec, value);
 			}
 
 			if (value != null)
 				value.Release (ec);
 
 			// Restore context state. 
 			ec.MarkLabel (ec.LoopEnd);
 
 			//
 			// Restore the previous context
 			//
 			ec.LoopEnd = old_end;
 			ec.Switch = old_switch;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="892" endline="930">
<![CDATA[
 
 		public override AssemblyName[] __GetReferencedAssemblies()
 		{
 			List<AssemblyName> list = new List<AssemblyName>();
 			for (int i = 0; i < AssemblyRef.records.Length; i++)
 			{
 				AssemblyName name = new AssemblyName();
 				name.Name = GetString(AssemblyRef.records[i].Name);
 				name.Version = new Version(
 					AssemblyRef.records[i].MajorVersion,
 					AssemblyRef.records[i].MinorVersion,
 					AssemblyRef.records[i].BuildNumber,
 					AssemblyRef.records[i].RevisionNumber);
 				if (AssemblyRef.records[i].PublicKeyOrToken != 0)
 				{
 					byte[] keyOrToken = GetBlobCopy(AssemblyRef.records[i].PublicKeyOrToken);
 					const int PublicKey = 0x0001;
 					if ((AssemblyRef.records[i].Flags & PublicKey) != 0)
 					{
 						name.SetPublicKey(keyOrToken);
 					}
 					else
 					{
 						name.SetPublicKeyToken(keyOrToken);
 					}
 				}
 				if (AssemblyRef.records[i].Culture != 0)
 				{
 					name.CultureInfo = new System.Globalization.CultureInfo(GetString(AssemblyRef.records[i].Culture));
 				}
 				else
 				{
 					name.CultureInfo = System.Globalization.CultureInfo.InvariantCulture;
 				}
 				name.Flags = (AssemblyNameFlags)AssemblyRef.records[i].Flags;
 				list.Add(name);
 			}
 			for (int i = 0; i < AssemblyRef.records.Length; i++)
 			{
 				AssemblyName name = new AssemblyName();
 				name.Name = GetString(AssemblyRef.records[i].Name);
 				name.Version = new Version(
 					AssemblyRef.records[i].MajorVersion,
 					AssemblyRef.records[i].MinorVersion,
 					AssemblyRef.records[i].BuildNumber,
 					AssemblyRef.records[i].RevisionNumber);
 				if (AssemblyRef.records[i].PublicKeyOrToken != 0)
 				{
 					byte[] keyOrToken = GetBlobCopy(AssemblyRef.records[i].PublicKeyOrToken);
 					const int PublicKey = 0x0001;
 					if ((AssemblyRef.records[i].Flags & PublicKey) != 0)
 					{
 						name.SetPublicKey(keyOrToken);
 					}
 					else
 					{
 						name.SetPublicKeyToken(keyOrToken);
 					}
 				}
 				if (AssemblyRef.records[i].Culture != 0)
 				{
 					name.CultureInfo = new System.Globalization.CultureInfo(GetString(AssemblyRef.records[i].Culture));
 				}
 				else
 				{
 					name.CultureInfo = System.Globalization.CultureInfo.InvariantCulture;
 				}
 				name.Flags = (AssemblyNameFlags)AssemblyRef.records[i].Flags;
 				list.Add(name);
 			}
 			return list.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="426" endline="467">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (Oper == Operator.AddressOf) {
 				return ResolveAddressOf (ec);
 			}
 
 			Expr = Expr.Resolve (ec);
 			if (Expr == null)
 				return null;
 
 			if (Expr.Type == InternalType.Dynamic) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (Expr));
 				return new DynamicUnaryConversion (GetOperatorExpressionTypeName (), args, loc).Resolve (ec);
 			}
 
 			if (TypeManager.IsNullableType (Expr.Type))
 				return new Nullable.LiftedUnaryOperator (Oper, Expr, loc).Resolve (ec);
 
 			//
 			// Attempt to use a constant folding operation.
 			//
 			Constant cexpr = Expr as Constant;
 			if (cexpr != null) {
 				cexpr = TryReduceConstant (ec, cexpr);
 				if (cexpr != null)
 					return cexpr.Resolve (ec);
 			}
 
 			Expression expr = ResolveOperator (ec, Expr);
 			if (expr == null)
 				Error_OperatorCannotBeApplied (ec, loc, OperName (Oper), Expr.Type);
 			
 			//
 			// Reduce unary operator on predefined types
 			//
 			if (expr == this && Oper == Operator.UnaryPlus)
 				return Expr;
 
 			return expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1906" endline="1928">
<![CDATA[
 
 		//
 		// It should be used by expressions which require to
 		// register a statement during resolve process.
 		//
 		public void AddScopeStatement (Statement s)
 		{
 			if (scope_initializers == null)
 				scope_initializers = new List<Statement> ();
 
 			//
 			// Simple recursive helper, when resolve scope initializer another
 			// new scope initializer can be added, this ensures it's initialized
 			// before existing one. For now this can happen with expression trees
 			// in base ctor initializer only
 			//
 			if (resolving_init_idx.HasValue) {
 				scope_initializers.Insert (resolving_init_idx.Value, s);
 				++resolving_init_idx;
 			} else {
 				scope_initializers.Add (s);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4795" endline="4824">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			// is out param
 			if (right_side == EmptyExpression.OutAccess.Instance)
 				local_info.SetIsUsed ();
 
 			if (local_info.IsReadonly && !ec.HasAny (ResolveContext.Options.FieldInitializerScope | ResolveContext.Options.UsingInitializerScope)) {
 				int code;
 				string msg;
 				if (right_side == EmptyExpression.OutAccess.Instance) {
 					code = 1657; msg = "Cannot pass `{0}' as a ref or out argument because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberAccess) {
 					code = 1654; msg = "Cannot assign to members of `{0}' because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberOutAccess) {
 					code = 1655; msg = "Cannot pass members of `{0}' as ref or out arguments because it is a `{1}'";
 				} else if (right_side == EmptyExpression.UnaryAddress) {
 					code = 459; msg = "Cannot take the address of {1} `{0}'";
 				} else {
 					code = 1656; msg = "Cannot assign to `{0}' because it is a `{1}'";
 				}
 				ec.Report.Error (code, loc, msg, Name, local_info.GetReadOnlyContext ());
 			} else if (VariableInfo != null) {
 				VariableInfo.SetAssigned (ec);
 			}
 
 			DoResolveBase (ec);
 
 			return base.DoResolveLValue (ec, right_side);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="3269" endline="3315">
<![CDATA[
 
 		int TokenizeLessThan ()
 		{
 			int d;
 			if (handle_typeof) {
 				PushPosition ();
 				if (parse_generic_dimension (out d)) {
 					val = d;
 					DiscardPosition ();
 					return Token.GENERIC_DIMENSION;
 				}
 				PopPosition ();
 			}
 
 			// Save current position and parse next token.
 			PushPosition ();
 			if (parse_less_than ()) {
 				if (parsing_generic_declaration && token () != Token.DOT) {
 					d = Token.OP_GENERICS_LT_DECL;
 				} else {
 					d = Token.OP_GENERICS_LT;
 				}
 				PopPosition ();
 				return d;
 			}
 
 			PopPosition ();
 			parsing_generic_less_than = 0;
 
 			d = peek_char ();
 			if (d == '<') {
 				get_char ();
 				d = peek_char ();
 
 				if (d == '=') {
 					get_char ();
 					return Token.OP_SHIFT_LEFT_ASSIGN;
 				}
 				return Token.OP_SHIFT_LEFT;
 			}
 
 			if (d == '=') {
 				get_char ();
 				return Token.OP_LE;
 			}
 			return Token.OP_LT;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="300" endline="310">
<![CDATA[
 
 		// <remarks>
 		//   If we're compiling with debugging support, this is called between parsing
 		//   and code generation to register all the source files with the
 		//   symbol writer.
 		// </remarks>
 		static public void DefineSymbolDocuments (MonoSymbolWriter symwriter)
 		{
 			foreach (CompilationUnit unit in compile_units)
 				unit.DefineSymbolInfo (symwriter);
 			foreach (CompilationUnit unit in compile_units)
 				unit.DefineSymbolInfo (symwriter);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="799" endline="814">
<![CDATA[
 
 		public void EmitWriteLine(FieldInfo field)
 		{
 			Universe u = moduleBuilder.universe;
 			Emit(OpCodes.Call, u.Import(typeof(Console)).GetMethod("get_Out"));
 			if (field.IsStatic)
 			{
 				Emit(OpCodes.Ldsfld, field);
 			}
 			else
 			{
 				Emit(OpCodes.Ldarg_0);
 				Emit(OpCodes.Ldfld, field);
 			}
 			Emit(OpCodes.Callvirt, u.Import(typeof(System.IO.TextWriter)).GetMethod("WriteLine", new Type[] { field.FieldType }));
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6096" endline="6107">
<![CDATA[
 
 [System.Diagnostics.Conditional ("FULL_AST")]
 void StoreModifierLocation (object token, Location loc)
 {
 	if (lbag == null)
 		return;
 
 	if (mod_locations == null)
   		mod_locations = new List<Tuple<Modifiers, Location>> ();
 
 	mod_locations.Add (Tuple.Create ((Modifiers) token, loc));
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="265" endline="280">
<![CDATA[
 
 		public void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			if (builder == null)
 				builder = ec.GetTemporaryLocal (type);
 
 			if (builder.LocalType.IsByRef) {
 				//
 				// if is_address, than this is just the address anyways,
 				// so we just return this.
 				//
 				ec.Emit (OpCodes.Ldloc, builder);
 			} else {
 				ec.Emit (OpCodes.Ldloca, builder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="273" endline="290">
<![CDATA[
 
 		public void CaptureLocalVariable (ResolveContext ec, LocalVariable local_info)
 		{
 			ec.CurrentBlock.Explicit.HasCapturedVariable = true;
 			if (ec.CurrentBlock.Explicit != local_info.Block.Explicit)
 				AddReferenceFromChildrenBlock (ec.CurrentBlock.Explicit);
 
 			if (local_info.HoistedVariant != null)
 				return;
 
 			HoistedVariable var = new HoistedLocalVariable (this, local_info, GetVariableMangledName (local_info));
 			local_info.HoistedVariant = var;
 
 			if (hoisted_locals == null)
 				hoisted_locals = new List<HoistedVariable> ();
 
 			hoisted_locals.Add (var);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="673" endline="689">
<![CDATA[
 		}
 
 		internal override MetaType GetTypeImpl (string typeName)
 		{
 			//
 			// We are loading a type from missing reference
 			// this itself is fine. The error will be reported
 			// later when the type is actually used
 			//
 			MetaType t;
 			if (!types.TryGetValue (typeName, out t)) {
 				t = new MissingType (typeName, this);
 				types.Add (typeName, t);
 			}
 
 			return t;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1559" endline="1567">
<![CDATA[
 
 			set {
 				// Only copy the vector if we're actually modifying it.
 				if (this [index] != value) {
 					if (vector == null)
 						initialize_vector ();
 					vector [index] = value;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5793" endline="5809">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 
 			//
 			// Don't capture temporary variables except when using
 			// iterator redirection
 			//
 			if (ec.CurrentAnonymousMethod != null && ec.CurrentAnonymousMethod.IsIterator && ec.IsVariableCapturingRequired) {
 				AnonymousMethodStorey storey = li.Block.Explicit.CreateAnonymousMethodStorey (ec);
 				storey.CaptureLocalVariable (ec, li);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="174" endline="187">
<![CDATA[
 
 		internal int Add(string str)
 		{
 			Debug.Assert(!frozen);
 			int offset;
 			if (!strings.TryGetValue(str, out offset))
 			{
 				offset = nextOffset;
 				nextOffset += System.Text.Encoding.UTF8.GetByteCount(str) + 1;
 				list.Add(str);
 				strings.Add(str, offset);
 			}
 			return offset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="459" endline="485">
<![CDATA[
 
 		public void AddConstructor (Constructor c)
 		{
 			bool is_static = (c.ModFlags & Modifiers.STATIC) != 0;
 			if (!AddToContainer (c, is_static ? Constructor.ConstructorName 
 				return;
 			
 			if (is_static && c.ParameterInfo.IsEmpty){
 				if (default_static_constructor != null) {
 				    Report.SymbolRelatedToPreviousError (default_static_constructor);
 					Report.Error (111, c.Location,
 						"A member `{0}' is already defined. Rename this member or use different parameter types",
 						c.GetSignatureForError ());
 				    return;
 				}
 
 				default_static_constructor = c;
 			} else {
 				if (c.ParameterInfo.IsEmpty)
 					default_constructor = c;
 				
 				if (instance_constructors == null)
 					instance_constructors = new List<Constructor> ();
 				
 				instance_constructors.Add (c);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1247" endline="1277">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			probe_type_expr = ProbeType.ResolveAsTypeTerminal (ec, false);
 			if (probe_type_expr == null)
 				return null;
 
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			if (probe_type_expr.Type.IsStatic) {
 				ec.Report.Error (-244, loc, "The `{0}' operator cannot be applied to an operand of a static type",
 					OperatorName);
 			}
 			
 			if (expr.Type.IsPointer || probe_type_expr.Type.IsPointer) {
 				ec.Report.Error (244, loc, "The `{0}' operator cannot be applied to an operand of pointer type",
 					OperatorName);
 				return null;
 			}
 
 			if (expr.Type == InternalType.AnonymousMethod) {
 				ec.Report.Error (837, loc, "The `{0}' operator cannot be applied to a lambda expression or anonymous method",
 					OperatorName);
 				return null;
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2571" endline="2654">
<![CDATA[
 		}
 
 		/// <summary>
 		///   Whether this is an instance member.
 		/// </summary>
 		public abstract bool IsInstance {
 			get;
 		}
 
 		/// <summary>
 		///   Whether this is a static member.
 		/// </summary>
 		public abstract bool IsStatic {
 			get;
 		}
 
 		// TODO
 		protected abstract TypeSpec DeclaringType {
 			get;
 		}
 
 		//
 		// Converts best base candidate for virtual method starting from QueriedBaseType
 		//
 		protected MethodSpec CandidateToBaseOverride (ResolveContext rc, MethodSpec method)
 		{
 			//
 			// Only when base.member is used and method is virtual
 			//
 			if (!IsBase)
 				return method;
 
 			//
 			// Overload resulution works on virtual or non-virtual members only (no overrides). That
 			// means for base.member access we have to find the closest match after we found best candidate
 			//
 			if ((method.Modifiers & (Modifiers.ABSTRACT | Modifiers.VIRTUAL | Modifiers.STATIC)) != Modifiers.STATIC) {
 				//
 				// The method could already be what we are looking for
 				//
 				TypeSpec[] targs = null;
 				if (method.DeclaringType != InstanceExpression.Type) {
 					var base_override = MemberCache.FindMember (InstanceExpression.Type, new MemberFilter (method), BindingRestriction.InstanceOnly) as MethodSpec;
 					if (base_override != null && base_override.DeclaringType != method.DeclaringType) {
 						if (base_override.IsGeneric)
 							targs = method.TypeArguments;
 
 						method = base_override;
 					}
 				}
 
 				// TODO
 				// hoisted stories only but that requires a new expression wrapper
 				if (rc.CurrentAnonymousMethod != null) {
 					if (targs == null && method.IsGeneric) {
 						targs = method.TypeArguments;
 						method = method.GetGenericMethodDefinition ();
 					}
 
 					if (method.Parameters.HasArglist)
 						throw new NotImplementedException ("__arglist base call proxy");
 
 					method = rc.CurrentMemberDefinition.Parent.PartialContainer.CreateHoistedBaseCallProxy (rc, method);
 
 					// Ideally this should apply to any proxy rewrite but in the case of unary mutators on
 					// get/set member expressions second call would fail to proxy because left expression
 					// would be of 'this' and not 'base'
 					if (rc.CurrentType.IsStruct)
 						InstanceExpression = new This (loc).Resolve (rc);
 				}
 
 				if (targs != null)
 					method = method.MakeGenericMethod (targs);
 			}
 
 			//
 			// Only base will allow this invocation to happen.
 			//
 			if (method.IsAbstract) {
 				Error_CannotCallAbstractBase (rc, method.GetSignatureForError ());
 			}
 
 			return method;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="174" endline="186">
<![CDATA[
 		}
 
 		void Store (EmitContext ec)
 		{
 			if (expr is VariableReference)
 				return;
 
 			if (temp != null)
 				return;
 
 			expr.Emit (ec);
 			LocalVariable.Store (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="558" endline="577">
<![CDATA[
 
 		protected static MethodSpec ConstructorLookup (ResolveContext rc, TypeSpec type, ref Arguments args, Location loc)
 		{
 			var ctors = MemberCache.FindMembers (type, Constructor.ConstructorName, true);
 			if (ctors == null) {
 				rc.Report.SymbolRelatedToPreviousError (type);
 				if (type.IsStruct) {
 					// Report meaningful error for struct as they always have default ctor in C# context
 					OverloadResolver.Error_ConstructorMismatch (rc, type, args == null ? 0 
 				} else {
 					rc.Report.Error (143, loc, "The class `{0}' has no constructors defined",
 						type.GetSignatureForError ());
 				}
 
 				return null;
 			}
 
 			var r = new OverloadResolver (ctors, OverloadResolver.Restrictions.NoBaseMembers, loc);
 			return r.ResolveMember<MethodSpec> (rc, ref args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5611" endline="5644">
<![CDATA[
 		}
 
 		#endregion
 
 		public override MemberExpr ResolveMemberAccess (ResolveContext ec, Expression left, SimpleName original)
 		{
 			//
 			// If the event is local to this class and we are not lhs of +=/-= we transform ourselves into a FieldExpr
 			//
 			if (!ec.HasSet (ResolveContext.Options.CompoundAssignmentScope)) {
 				if (spec.BackingField != null &&
 					(spec.DeclaringType == ec.CurrentType || TypeManager.IsNestedChildOf (ec.CurrentType, spec.DeclaringType.MemberDefinition))) {
 
 					spec.MemberDefinition.SetIsUsed ();
 
 					if (!ec.IsObsolete) {
 						ObsoleteAttribute oa = spec.GetAttributeObsolete ();
 						if (oa != null)
 							AttributeTester.Report_ObsoleteMessage (oa, spec.GetSignatureForError (), loc, ec.Report);
 					}
 
 					if ((spec.Modifiers & (Modifiers.ABSTRACT | Modifiers.EXTERN)) != 0)
 						Error_AssignmentEventOnly (ec);
 
 					FieldExpr ml = new FieldExpr (spec.BackingField, loc);
 
 					InstanceExpression = null;
 
 					return ml.ResolveMemberAccess (ec, left, original);
 				}
 			}
 
 			return base.ResolveMemberAccess (ec, left, original);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1275" endline="1332">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Value;
 
 			// FIXME
 			var caller_builder = (Constructor) ec.MemberContext;
 
 			//
 			// Spec mandates that constructor initializer will not have `this' access
 			//
 			using (ec.Set (ResolveContext.Options.BaseInitializer)) {
 				if (argument_list != null) {
 					bool dynamic;
 					argument_list.Resolve (ec, out dynamic);
 
 					if (dynamic) {
 						ec.Report.Error (1975, loc,
 							"The constructor call cannot be dynamically dispatched within constructor initializer");
 
 						return null;
 					}
 				}
 
 				type = ec.CurrentType;
 				if (this is ConstructorBaseInitializer) {
 					if (ec.CurrentType.BaseType == null)
 						return this;
 
 					type = ec.CurrentType.BaseType;
 					if (ec.CurrentType.IsStruct) {
 						ec.Report.Error (522, loc,
 							"`{0}'
 						return this;
 					}
 				} else {
 					//
 					// It is legal to have "this" initializers that take no arguments
 					// in structs, they are just no-ops.
 					//
 					// struct D { public D (int a) 
 					//
 					if (TypeManager.IsStruct (ec.CurrentType) && argument_list == null)
 						return this;
 				}
 
 				base_ctor = ConstructorLookup (ec, type, ref argument_list, loc);
 			}
 	
 			// TODO MemberCache
 			if (base_ctor == caller_builder.Spec){
 				ec.Report.Error (516, loc, "Constructor `{0}' cannot call itself",
 					caller_builder.GetSignatureForError ());
 			}
 						
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1367" endline="1382">
<![CDATA[
 		}
 
 		public TypeSpec MemberType { get; private set; }
 
 		#endregion
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var es = (EventSpec) base.InflateMember (inflator);
 			es.MemberType = inflator.Inflate (MemberType);
 
 			if (backing_field != null)
 				es.backing_field = (FieldSpec) backing_field.InflateMember (inflator);
 
 			return es;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="469" endline="479">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (user_operator != null)
 				return user_operator.CreateExpressionTree (ec);
 
 			if (Oper == Operator.UnaryPlus)
 				return Expr.CreateExpressionTree (ec);
 
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="198" endline="217">
<![CDATA[
 
 		protected override bool DoResolve (BlockContext ec)
 		{
 			//
 			// When delegate returns void, only expression statements can be used
 			//
 			if (ec.ReturnType == TypeManager.void_type) {
 				Expr = Expr.Resolve (ec);
 				if (Expr == null)
 					return false;
 
 				statement = Expr as ExpressionStatement;
 				if (statement == null)
 					Expr.Error_InvalidExpressionStatement (ec);
 
 				return true;
 			}
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2923" endline="2945">
<![CDATA[
 
 		public override MethodGroupExpr OverloadResolve (ResolveContext ec, ref Arguments arguments, OverloadResolver.IErrorHandler ehandler, OverloadResolver.Restrictions restr)
 		{
 			if (arguments == null)
 				arguments = new Arguments (1);
 
 			arguments.Insert (0, new Argument (ExtensionExpression, Argument.AType.ExtensionType));
 			var res = base.OverloadResolve (ec, ref arguments, ehandler ?? this, restr);
 
 			// Store resolved argument and restore original arguments
 			if (res == null) {
 				// Clean-up modified arguments for error reporting
 				arguments.RemoveAt (0);
 				return null;
 			}
 
 			var me = ExtensionExpression as MemberExpr;
 			if (me != null)
 				me.ResolveInstanceExpression (ec, null);
 
 			InstanceExpression = null;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="401" endline="413">
<![CDATA[
 		}
 
 		internal int AddRecord(T newRecord)
 		{
 			if (rowCount == records.Length)
 			{
 				T[] newarr = new T[records.Length * 2];
 				Array.Copy(records, newarr, records.Length);
 				records = newarr;
 			}
 			records[rowCount++] = newRecord;
 			return rowCount;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="109" endline="117">
<![CDATA[
 
 		public override object GetRawConstantValue()
 		{
 			if (lazyPseudoToken != 0)
 			{
 				return typeBuilder.ModuleBuilder.Constant.GetRawConstantValue(typeBuilder.ModuleBuilder, lazyPseudoToken);
 			}
 			throw new InvalidOperationException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1319" endline="1330">
<![CDATA[
 		}
 
 		internal override MethodSignature MethodSignature
 		{
 			get
 			{
 				if (methodSignature == null)
 				{
 					methodSignature = MethodSignature.MakeFromBuilder(returnType, parameterTypes, null, callingConvention, 0);
 				}
 				return methodSignature;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="94" endline="100">
<![CDATA[
 
 		internal void Write(byte value)
 		{
 			if (pos == buffer.Length)
 				Grow(1);
 			buffer[pos++] = value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1391" endline="1398">
<![CDATA[
 
 		public void Encode (byte value)
 		{
 			if (pos == buffer.Length)
 				Grow (1);
 
 			buffer [pos++] = value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="166" endline="182">
<![CDATA[
 		}
 
 		internal override int ImportTo(ModuleBuilder other)
 		{
 			if (typeBuilder.IsGenericTypeDefinition)
 			{
 				return other.ImportMember(TypeBuilder.GetField(typeBuilder, this));
 			}
 			else if (other == typeBuilder.ModuleBuilder)
 			{
 				return pseudoToken;
 			}
 			else
 			{
 				return other.ImportMethodOrField(typeBuilder, name, fieldSig);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2171" endline="2180">
<![CDATA[
 
 		public static void Error_OperatorCannotBeApplied (ResolveContext ec, Expression left, Expression right, string oper, Location loc)
 		{
 			string l, r;
 			l = TypeManager.CSharpName (left.Type);
 			r = TypeManager.CSharpName (right.Type);
 
 			ec.Report.Error (19, loc, "Operator `{0}' cannot be applied to operands of type `{1}' and `{2}'",
 				oper, l, r);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="670" endline="686">
<![CDATA[
 		}
 
 		internal override int ImportTo(ModuleBuilder other)
 		{
 			if (typeBuilder.IsGenericTypeDefinition)
 			{
 				return other.ImportMember(TypeBuilder.GetMethod(typeBuilder, this));
 			}
 			else if (other == typeBuilder.ModuleBuilder)
 			{
 				return pseudoToken;
 			}
 			else
 			{
 				return other.ImportMethodOrField(typeBuilder, name, this.MethodSignature);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="212" endline="229">
<![CDATA[
 
 		private void AddArgument(Type argument, bool pinned, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			if (type == Signature.LOCAL_SIG)
 			{
 				locals.Add(new LocalBuilder(argument, 0, pinned));
 			}
 			else if (optional)
 			{
 				this.optionalArgs.Add(argument);
 			}
 			else
 			{
 				this.args.Add(argument);
 				this.requiredCustomModifiers.Add(requiredCustomModifiers);
 				this.optionalCustomModifiers.Add(optionalCustomModifiers);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="85" endline="111">
<![CDATA[
 
 		public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
 		{
 			Universe u = this.Module.universe;
 			if (customBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_FieldOffsetAttribute)
 			{
 				customBuilder = customBuilder.DecodeBlob(this.Module.Assembly);
 				SetOffset((int)customBuilder.GetConstructorArgument(0));
 			}
 			else if (customBuilder.Constructor.DeclaringType == u.System_Runtime_InteropServices_MarshalAsAttribute)
 			{
 				MarshalSpec.SetMarshalAsAttribute(typeBuilder.ModuleBuilder, pseudoToken, customBuilder);
 				attribs |= FieldAttributes.HasFieldMarshal;
 			}
 			else if (customBuilder.Constructor.DeclaringType == u.System_NonSerializedAttribute)
 			{
 				attribs |= FieldAttributes.NotSerialized;
 			}
 			else if (customBuilder.Constructor.DeclaringType == u.System_Runtime_CompilerServices_SpecialNameAttribute)
 			{
 				attribs |= FieldAttributes.SpecialName;
 			}
 			else
 			{
 				typeBuilder.ModuleBuilder.SetCustomAttribute(pseudoToken, customBuilder);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5097" endline="5128">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			prepared = prepare_for_load && !(source is DynamicExpressionStatement);
 			if (IsInstance)
 				EmitInstance (ec, prepared);
 
 			source.Emit (ec);
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (!IsStatic) {
 					temp = new LocalTemporary (this.Type);
 					temp.Store (ec);
 				}
 			}
 
 			if ((spec.Modifiers & Modifiers.VOLATILE) != 0)
 				ec.Emit (OpCodes.Volatile);
 					
 			spec.MemberDefinition.SetIsAssigned ();
 
 			if (IsStatic)
 				ec.Emit (OpCodes.Stsfld, spec);
 			else
 				ec.Emit (OpCodes.Stfld, spec);
 			
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 				temp = null;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="436" endline="463">
<![CDATA[
 
 	void OutlineField (FieldInfo fi)
 	{
 		if (fi.IsPublic)   o.Write ("public ");
 		if (fi.IsFamily)   o.Write ("protected ");
 		if (fi.IsPrivate)  o.Write ("private ");
 		if (fi.IsAssembly) o.Write ("internal ");
 		if (fi.IsLiteral)  o.Write ("const ");
 		else if (fi.IsStatic) o.Write ("static ");
 		if (fi.IsInitOnly) o.Write ("readonly ");
 
 		o.Write (FormatType (fi.FieldType));
 		o.Write (" ");
 		o.Write (fi.Name);
 		if (fi.IsLiteral) { 
 			object v = fi.GetValue (this);
 
 			// TODO
 			o.Write (" = ");
 			if (v is char)
 				o.Write ("'{0}'", v);
 			else if (v is string)
 				o.Write ("\"{0}\"", v);
 			else
 				o.Write (fi.GetValue (this));
 		}
 		o.Write (";");
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2675" endline="2688">
<![CDATA[
 
 		static bool IsSameOrBaseQualifier (TypeSpec type, TypeSpec qtype)
 		{
 			do {
 				type = type.GetDefinition ();
 
 				if (type == qtype || TypeManager.IsFamilyAccessible (qtype, type))
 					return true;
 
 				type = type.DeclaringType;
 			} while (type != null);
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.cs" startline="1186" endline="1213">
<![CDATA[
 
   int yyExpectingState;
   /** computes list of expected tokens on error by tracing the tables.
       @param state for which to compute the list.
       @return list of token names.
     */
   protected int [] yyExpectingTokens (int state){
     int token, n, len = 0;
     bool[] ok = new bool[yyNames.Length];
     if ((n = yySindex[state]) != 0)
       for (token = n < 0 ? -n 
            (token < yyNames.Length) && (n+token < yyTable.Length); ++ token)
         if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
           ++ len;
           ok[token] = true;
         }
            (token < yyNames.Length) && (n+token < yyTable.Length); ++ token)
         if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
           ++ len;
           ok[token] = true;
         }
     if ((n = yyRindex[state]) != 0)
       for (token = n < 0 ? -n 
            (token < yyNames.Length) && (n+token < yyTable.Length); ++ token)
         if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
           ++ len;
           ok[token] = true;
         }
            (token < yyNames.Length) && (n+token < yyTable.Length); ++ token)
         if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
           ++ len;
           ok[token] = true;
         }
     int [] result = new int [len];
     for (n = token = 0; n < len;  ++ token)
       if (ok[token]) result[n++] = token;
     for (n = token = 0; n < len;  ++ token)
       if (ok[token]) result[n++] = token;
     return result;
   }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2207" endline="2263">
<![CDATA[
 
 		void DefineAnonymousStorey (EmitContext ec)
 		{
 			//
 			// Creates anonymous method storey
 			//
 			if (ec.CurrentAnonymousMethod != null && ec.CurrentAnonymousMethod.Storey != null) {
 				//
 				// Creates parent storey reference when hoisted this is accessible
 				//
 				if (am_storey.OriginalSourceBlock.Explicit.HasCapturedThis) {
 					ExplicitBlock parent = am_storey.OriginalSourceBlock.Explicit.Parent.Explicit;
 
 					//
 					// Hoisted this exists in top-level parent storey only
 					//
 					while (parent.am_storey == null || parent.am_storey.Parent is AnonymousMethodStorey)
 						parent = parent.Parent.Explicit;
 					while (parent.am_storey == null || parent.am_storey.Parent is AnonymousMethodStorey)
 						parent = parent.Parent.Explicit;
 
 					am_storey.AddParentStoreyReference (ec, parent.am_storey);
 				}
 
 				am_storey.SetNestedStoryParent (ec.CurrentAnonymousMethod.Storey);
 
 				// TODO MemberCache
 				am_storey.Mutator = ec.CurrentAnonymousMethod.Storey.Mutator;
 			}
 
 			am_storey.CreateType ();
 			if (am_storey.Mutator == null && ec.CurrentTypeParameters != null)
 				am_storey.Mutator = new TypeParameterMutator (ec.CurrentTypeParameters, am_storey.CurrentTypeParameters);
 
 			am_storey.DefineType ();
 			am_storey.ResolveTypeParameters ();
 
 			var ref_blocks = am_storey.ReferencesFromChildrenBlock;
 			if (ref_blocks != null) {
 				foreach (ExplicitBlock ref_block in ref_blocks) {
 					for (ExplicitBlock b = ref_block.Explicit; b.am_storey != am_storey; b = b.Parent.Explicit) {
 						if (b.am_storey != null) {
 							b.am_storey.AddParentStoreyReference (ec, am_storey);
 
 							// Stop propagation inside same top block
 							if (b.ParametersBlock.am_storey == ParametersBlock.am_storey)
 								break;
 
 							b = b.ParametersBlock;
 						}
 
 						b.HasCapturedVariable = true;
 					}
 					for (ExplicitBlock b = ref_block.Explicit; b.am_storey != am_storey; b = b.Parent.Explicit) {
 						if (b.am_storey != null) {
 							b.am_storey.AddParentStoreyReference (ec, am_storey);
 
 							// Stop propagation inside same top block
 							if (b.ParametersBlock.am_storey == ParametersBlock.am_storey)
 								break;
 
 							b = b.ParametersBlock;
 						}
 
 						b.HasCapturedVariable = true;
 					}
 				}
 				foreach (ExplicitBlock ref_block in ref_blocks) {
 					for (ExplicitBlock b = ref_block.Explicit; b.am_storey != am_storey; b = b.Parent.Explicit) {
 						if (b.am_storey != null) {
 							b.am_storey.AddParentStoreyReference (ec, am_storey);
 
 							// Stop propagation inside same top block
 							if (b.ParametersBlock.am_storey == ParametersBlock.am_storey)
 								break;
 
 							b = b.ParametersBlock;
 						}
 
 						b.HasCapturedVariable = true;
 					}
 				}
 			}
 
 			am_storey.Define ();
 			am_storey.Parent.PartialContainer.AddCompilerGeneratedClass (am_storey);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="218" endline="225">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			if (Name == null)
 				return field.GetSignatureForError ();
 
 			return field.Parent.GetSignatureForError () + "." + Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="59" endline="67">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			PropertySignature other = obj as PropertySignature;
 			return other != null
 				&& other.propertyType.Equals(propertyType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="51" endline="59">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			FieldSignature other = obj as FieldSignature;
 			return other != null
 				&& other.fieldType.Equals(fieldType)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2382" endline="2396">
<![CDATA[
 		}
 
 		public TypeSpec[] InferMethodArguments (ResolveContext ec, MethodSpec method)
 		{
 			var method_generic_args = method.GenericDefinition.TypeParameters;
 			TypeInferenceContext context = new TypeInferenceContext (method_generic_args);
 			if (!context.UnfixedVariableExists)
 				return TypeSpec.EmptyTypes;
 
 			AParametersCollection pd = method.Parameters;
 			if (!InferInPhases (ec, context, pd))
 				return null;
 
 			return context.InferredTypeArguments;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1033" endline="1045">
<![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (child.CreateExpressionTree (ec)));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 
 			if (type.IsPointer || child.Type.IsPointer)
 				Error_PointerInsideExpressionTree (ec);
 
 			return CreateExpressionFactoryCall (ec, ec.HasSet (ResolveContext.Options.CheckedScope) ? "ConvertChecked" 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="135" endline="153">
<![CDATA[
 
 		public ATypeNameExpression GetTypeExpression ()
 		{
 			if (Left == null) {
 				if (TypeArguments != null)
 					return new SimpleName (Name, TypeArguments, Location);
 				
 				return new SimpleName (Name, Location);
 			}
 
 			if (is_double_colon) {
 				if (Left.Left != null)
 					throw new InternalErrorException ("The left side of a 
 				return new QualifiedAliasMember (Left.Name, Name, TypeArguments, Location);
 			}
 
 			Expression lexpr = Left.GetTypeExpression ();
 			return new MemberAccess (lexpr, Name, TypeArguments, Location);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="427" endline="456">
<![CDATA[
 
 		public MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria)
 		{
 			List<MemberInfo> members = new List<MemberInfo>();
 			if ((memberType & MemberTypes.Constructor) != 0)
 			{
 				AddMembers(members, filter, filterCriteria, GetConstructors(bindingAttr));
 			}
 			if ((memberType & MemberTypes.Method) != 0)
 			{
 				AddMembers(members, filter, filterCriteria, GetMethods(bindingAttr));
 			}
 			if ((memberType & MemberTypes.Field) != 0)
 			{
 				AddMembers(members, filter, filterCriteria, GetFields(bindingAttr));
 			}
 			if ((memberType & MemberTypes.Property) != 0)
 			{
 				AddMembers(members, filter, filterCriteria, GetProperties(bindingAttr));
 			}
 			if ((memberType & MemberTypes.Event) != 0)
 			{
 				AddMembers(members, filter, filterCriteria, GetEvents(bindingAttr));
 			}
 			if ((memberType & MemberTypes.NestedType) != 0)
 			{
 				AddMembers(members, filter, filterCriteria, GetNestedTypes(bindingAttr));
 			}
 			return members.ToArray();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2330" endline="2358">
<![CDATA[
 		
 		//
 		// Evaluates an expression for `#if' or `#elif'
 		//
 		bool pp_expr (ref string s, bool isTerm)
 		{
 			bool va = pp_and (ref s);
 			s = s.Trim ();
 			int len = s.Length;
 			if (len > 0){
 				char c = s [0];
 				
 				if (c == '|'){
 					if (len > 2 && s [1] == '|'){
 						s = s.Substring (2);
 						return va | pp_expr (ref s, isTerm);
 					} else {
 						Error_InvalidDirective ();
 						return false;
 					}
 				}
 				if (isTerm) {
 					Error_EndLineExpected ();
 					return false;
 				}
 			}
 			
 			return va;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="904" endline="953">
<![CDATA[
 
 		//
 		// Identity type conversion
 		//
 		// Default reference comparison, it has to be used when comparing
 		// two possible dynamic/internal types
 		//
 		public static bool IsEqual (TypeSpec a, TypeSpec b)
 		{
 			if (a == b) {
 				// This also rejects dynamic == dynamic
 				return a.Kind != MemberKind.InternalCompilerType || a == InternalType.Dynamic;
 			}
 
 			//
 			// object and dynamic are considered equivalent there is an identity conversion
 			// between object and dynamic, and between constructed types that are the same
 			// when replacing all occurences of dynamic with object.
 			//
 			if (a == InternalType.Dynamic || b == InternalType.Dynamic)
 				return b == TypeManager.object_type || a == TypeManager.object_type;
 
 			if (a == null)
 				return false;
 
 			if (a.IsArray) {
 				var a_a = (ArrayContainer) a;
 				var b_a = b as ArrayContainer;
 				if (b_a == null)
 					return false;
 
 				return IsEqual (a_a.Element, b_a.Element) && a_a.Rank == b_a.Rank;
 			}
 
 			if (!a.IsGeneric || b == null || !b.IsGeneric)
 				return false;
 
 			if (a.MemberDefinition != b.MemberDefinition)
 				return false;
 
 			do {
 				if (!Equals (a.TypeArguments, b.TypeArguments))
 					return false;
 
 				a = a.DeclaringType;
 				b = b.DeclaringType;
 			} while (a != null);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="412" endline="471">
<![CDATA[
 
 		static public RSA FromCapiPublicKeyBlob (byte[] blob, int offset) 
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			try {
 				if ((blob [offset]   != 0x06) ||				// PUBLICKEYBLOB (0x06)
 				    (blob [offset+1] != 0x02) ||				// Version (0x02)
 				    (blob [offset+2] != 0x00) ||				// Reserved (word)
 				    (blob [offset+3] != 0x00) || 
 				    (ToUInt32LE (blob, offset+8) != 0x31415352))	// DWORD magic = RSA1
 					throw new CryptographicException ("Invalid blob header");
 
 				// ALGID (CALG_RSA_SIGN, CALG_RSA_KEYX, ...)
 				// int algId = ToInt32LE (blob, offset+4);
 
 				// DWORD bitlen
 				int bitLen = ToInt32LE (blob, offset+12);
 
 				// DWORD public exponent
 				RSAParameters rsap = new RSAParameters ();
 				rsap.Exponent = new byte [3];
 				rsap.Exponent [0] = blob [offset+18];
 				rsap.Exponent [1] = blob [offset+17];
 				rsap.Exponent [2] = blob [offset+16];
 			
 				int pos = offset+20;
 				// BYTE modulus[rsapubkey.bitlen/8];
 				int byteLen = (bitLen >> 3);
 				rsap.Modulus = new byte [byteLen];
 				Buffer.BlockCopy (blob, pos, rsap.Modulus, 0, byteLen);
 				Array.Reverse (rsap.Modulus);
 #if NET_2_1
 				RSA rsa = RSA.Create ();
 				rsa.ImportParameters (rsap);
 #else
 				RSA rsa = null;
 				try {
 					rsa = RSA.Create ();
 					rsa.ImportParameters (rsap);
 				}
 				catch (CryptographicException) {
 					// this may cause problem when this code is run under
 					// the SYSTEM identity on Windows (e.g. ASP.NET). See
 					// http
 					CspParameters csp = new CspParameters ();
 					csp.Flags = CspProviderFlags.UseMachineKeyStore;
 					rsa = new RSACryptoServiceProvider (csp);
 					rsa.ImportParameters (rsap);
 				}
 #endif
 				return rsa;
 			}
 			catch (Exception e) {
 				throw new CryptographicException ("Invalid blob.", e);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="177" endline="189">
<![CDATA[
 
 		public override AssemblyName GetName()
 		{
 			AssemblyName n = new AssemblyName();
 			n.Name = name;
 			n.Version = new Version(majorVersion, minorVersion, buildVersion, revisionVersion);
 			n.Culture = culture;
 			n.HashAlgorithm = hashAlgorithm;
 			n.Flags = flags;
 			n.SetPublicKey(publicKey != null ? (byte[])publicKey.Clone() 
 			n.KeyPair = keyPair;
 			return n;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="398" endline="438">
<![CDATA[
 
 		private void WriteImportDirectory(MetadataWriter mw)
 		{
 			mw.Write(ImportDirectoryRVA + 40);		// ImportLookupTable
 			mw.Write(0);							// DateTimeStamp
 			mw.Write(0);							// ForwarderChain
 			mw.Write(ImportHintNameTableRVA + 14);	// Name
 			mw.Write(ImportAddressTableRVA);
 			mw.Write(new byte[20]);
 			// Import Lookup Table
 			mw.Write(ImportHintNameTableRVA);		// Hint/Name Table RVA
 			int size = 48;
 			if (peWriter.Headers.FileHeader.Machine != IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 			{
 				size += 4;
 				mw.Write(0);
 			}
 			mw.Write(0);
 
 			// alignment padding
 			for (int i = (int)(ImportHintNameTableRVA - (ImportDirectoryRVA + size)); i > 0; i--)
 			{
 				mw.Write((byte)0);
 			}
 			for (int i = (int)(ImportHintNameTableRVA - (ImportDirectoryRVA + size)); i > 0; i--)
 			{
 				mw.Write((byte)0);
 			}
 
 			// Hint/Name Table
 			AssertRVA(mw, ImportHintNameTableRVA);
 			mw.Write((ushort)0);		// Hint
 			if ((peWriter.Headers.FileHeader.Characteristics & IMAGE_FILE_HEADER.IMAGE_FILE_DLL) != 0)
 			{
 				mw.Write(System.Text.Encoding.ASCII.GetBytes("_CorDllMain"));
 			}
 			else
 			{
 				mw.Write(System.Text.Encoding.ASCII.GetBytes("_CorExeMain"));
 			}
 			mw.Write((byte)0);
 			// Name
 			mw.Write(System.Text.Encoding.ASCII.GetBytes("mscoree.dll"));
 			mw.Write((ushort)0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1413" endline="1426">
<![CDATA[
 		}
 
 		//
 		// Returns true if this is a default constructor
 		//
 		public bool IsDefault ()
 		{
 			if ((ModFlags & Modifiers.STATIC) != 0)
 				return parameters.IsEmpty;
 
 			return parameters.IsEmpty &&
 					(Initializer is ConstructorBaseInitializer) &&
 					(Initializer.Arguments == null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2009" endline="2038">
<![CDATA[
 
 		public override void Emit()
 		{
 			var base_type = Parent.PartialContainer.BaseType;
 			if (base_type != null && Block != null) {
 				var base_dtor = MemberCache.FindMember (base_type,
 					new MemberFilter (MetadataName, 0, MemberKind.Destructor, null, null), BindingRestriction.InstanceOnly) as MethodSpec;
 
 				if (base_dtor == null)
 					throw new NotImplementedException ();
 
 				MethodGroupExpr method_expr = MethodGroupExpr.CreatePredefined (base_dtor, base_type, Location);
 				method_expr.InstanceExpression = new BaseThis (base_type, Location);
 
 				var try_block = new ExplicitBlock (block, block.StartLocation, block.EndLocation);
 				var finaly_block = new ExplicitBlock (block, Location, Location);
 
 				//
 				// 0-size arguments to avoid CS0250 error
 				// TODO
 				// debugger scope
 				//
 				finaly_block.AddStatement (new StatementExpression (new Invocation (method_expr, new Arguments (0))));
 
 				var tf = new TryFinally (try_block, finaly_block, Location);
 				block.WrapIntoDestructor (tf, try_block);
 			}
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="182" endline="203">
<![CDATA[
 
 		public bool Equals (MemberName other)
 		{
 			if (this == other)
 				return true;
 			if (other == null || Name != other.Name)
 				return false;
 			if (is_double_colon != other.is_double_colon)
 				return false;
 
 			if ((TypeArguments != null) &&
 			    (other.TypeArguments == null || TypeArguments.Count != other.TypeArguments.Count))
 				return false;
 
 			if ((TypeArguments == null) && (other.TypeArguments != null))
 				return false;
 
 			if (Left == null)
 				return other.Left == null;
 
 			return Left.Equals (other.Left);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="541" endline="552">
<![CDATA[
 
 		///
 		/// Remaps block to cloned copy if one exists.
 		///
 		public Block RemapBlockCopy (Block from)
 		{
 			Block mapped_to;
 			if (!block_map.TryGetValue (from, out mapped_to))
 				return from;
 
 			return mapped_to;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="870" endline="878">
<![CDATA[
 		}
 
 		public bool IsUnsafe {
 			get {
 				if ((ModFlags & Modifiers.UNSAFE) != 0)
 					return true;
 
 				return Parent == null ? false 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="863" endline="879">
<![CDATA[
 
 		bool IsEntryPoint ()
 		{
 			if (ReturnType != TypeManager.void_type &&
 				ReturnType != TypeManager.int32_type)
 				return false;
 
 			if (parameters.IsEmpty)
 				return true;
 
 			if (parameters.Count > 1)
 				return false;
 
 			var ac = parameters.Types [0] as ArrayContainer;
 			return ac != null && ac.Rank == 1 && ac.Element == TypeManager.string_type &&
 					(parameters[0].ModFlags & ~Parameter.Modifier.PARAMS) == Parameter.Modifier.NONE;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1073" endline="1084">
<![CDATA[
 
 		public virtual MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var inflated = (MemberSpec) MemberwiseClone ();
 			inflated.declaringType = inflator.TypeInstance;
 			if (DeclaringType.IsGenericOrParentIsGeneric)
 				inflated.state |= StateFlags.PendingMetaInflate;
 #if DEBUG
 			inflated.ID += 1000000;
 #endif
 			return inflated;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\reflection.cs" startline="319" endline="330">
<![CDATA[
 
 		public override Module AddModule (string module)
 		{
 			try {
 				if (adder_method == null)
 					adder_method = typeof (AssemblyBuilder).GetMethod ("AddModule", BindingFlags.Instance | BindingFlags.NonPublic);
 
 				return (Module) adder_method.Invoke (builder, new object[] { module });
 			} catch {
 				return base.AddModule (module);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="642" endline="662">
<![CDATA[
 
 		public override void Emit ()
 		{
 			CheckReservedNameConflict (GetMethod.Prefix, get == null ? null 
 			CheckReservedNameConflict (SetMethod.Prefix, set == null ? null 
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (member_type == InternalType.Dynamic) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (PropertyBuilder);
 			} else if (member_type.HasDynamicElement) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (PropertyBuilder, member_type, Location);
 			}
 
 			first.Emit (Parent);
 			if (AccessorSecond != null)
 				AccessorSecond.Emit (Parent);
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="308" endline="319">
<![CDATA[
 
 		public void EmitArrayNew (ArrayContainer ac)
 		{
 			if (ac.Rank == 1) {
 				Emit (OpCodes.Newarr, ac.Element);
 			} else {
 				if (IsAnonymousStoreyMutateRequired)
 					ac = (ArrayContainer) ac.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 				ig.Emit (OpCodes.Newobj, ac.GetConstructor ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="679" endline="703">
<![CDATA[
 
 	void GetFullName_recursed (StringBuilder sb, Type t, bool recursed)
 	{
 #if NET_2_0
 		if (t.IsGenericParameter) {
 			sb.Append (t.Name);
 			return;
 		}
 #endif
 
 		if (t.DeclaringType != null) {
 			GetFullName_recursed (sb, t.DeclaringType, true);
 			sb.Append (".");
 		}
 
 		if (!recursed) {
 			string ns = t.Namespace;
 			if ((ns != null) && (ns != "")) {
 				sb.Append (ns);
 				sb.Append (".");
 			}
 		}
 
 		GetTypeName (sb, t);
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="411" endline="421">
<![CDATA[
 
 		public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype)
 		{
 			if (events == null)
 			{
 				events = new List<EventBuilder>();
 			}
 			EventBuilder eb = new EventBuilder(this, name, attributes, eventtype);
 			events.Add(eb);
 			return eb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="349" endline="379">
<![CDATA[
 
 		//
 		// Is @baseClass base implementation of @type. With enabled @dynamicIsEqual the slower
 		// comparison is used to hide differences between `object' and `dynamic' for generic
 		// types. Should not be used for comparisons where G<object> != G<dynamic>
 		//
 		public static bool IsBaseClass (TypeSpec type, TypeSpec baseClass, bool dynamicIsObject)
 		{
 			if (dynamicIsObject && baseClass.IsGeneric) {
 				//
 				// Returns true for a hierarchies like this when passing baseClass of A<dynamic>
 				//
 				// class B 
 				//
 				while (type != null) {
 					type = type.BaseType;
 					if (TypeSpecComparer.IsEqual (type, baseClass))
 						return true;
 				}
 				while (type != null) {
 					type = type.BaseType;
 					if (TypeSpecComparer.IsEqual (type, baseClass))
 						return true;
 				}
 
 				return false;
 			}
 
 			while (type != null) {
 				type = type.BaseType;
 				if (type == baseClass)
 					return true;
 			}
 			while (type != null) {
 				type = type.BaseType;
 				if (type == baseClass)
 					return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="669" endline="685">
<![CDATA[
 
 		/// <summary>
 		/// Returns true when MemberCore is exposed from assembly.
 		/// </summary>
 		public bool IsExposedFromAssembly ()
 		{
 			if ((ModFlags & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 				return false;
 			
 			DeclSpace parentContainer = Parent.PartialContainer;
 			while (parentContainer != null && parentContainer.ModFlags != 0) {
 				if ((parentContainer.ModFlags & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 					return false;
 				parentContainer = parentContainer.Parent;
 			}
 			while (parentContainer != null && parentContainer.ModFlags != 0) {
 				if ((parentContainer.ModFlags & (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
 					return false;
 				parentContainer = parentContainer.Parent;
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="220" endline="339">
<![CDATA[
 
 		//
 		// 6.1.6 Implicit reference conversions
 		//
 		public static bool ImplicitReferenceConversionExists (Expression expr, TypeSpec target_type)
 		{
 			if (TypeManager.IsStruct (target_type))
 				return false;
 
 			TypeSpec expr_type = expr.Type;
 
 			// from the null type to any reference-type.
 			if (expr_type == InternalType.Null)
 				return target_type != InternalType.AnonymousMethod;
 
 			if (TypeManager.IsGenericParameter (expr_type))
 				return ImplicitTypeParameterConversion (expr, target_type) != null;
 
 			// This code is kind of mirrored inside ImplicitStandardConversionExists
 			// with the small distinction that we only probe there
 			//
 			// Always ensure that the code here and there is in sync
 
 			// from any class-type S to any interface-type T.
 			if (target_type.IsInterface) {
 				if (expr_type.ImplementsInterface (target_type, true)){
 					return !TypeManager.IsValueType (expr_type);
 				}
 			}
 
 			//
 			// Implicit reference conversions (no-boxing) to object or dynamic
 			//
 			if (target_type == TypeManager.object_type || target_type == InternalType.Dynamic) {
 				switch (expr_type.Kind) {
 				case MemberKind.Class
 				case MemberKind.Interface
 				case MemberKind.Delegate
 				case MemberKind.ArrayType
 					return true;
 				}
 
 				return expr_type == InternalType.Dynamic;
 			}
 
 			if (target_type == TypeManager.value_type) {
 				return expr_type == TypeManager.enum_type;
 			} else if (expr_type == target_type || TypeSpec.IsBaseClass (expr_type, target_type, true)) {
 				//
 				// Special case
 				// System.Enum is not a value type, it is a class, so we need
 				// a boxing conversion
 				//
 				if (target_type == TypeManager.enum_type || TypeManager.IsGenericParameter (expr_type))
 					return false;
 
 				if (TypeManager.IsValueType (expr_type))
 					return false;
 
 				// Array type variance conversion
 				//if (target_type.IsArray != expr_type.IsArray)
 				//	return false;
 
 				return true;
 			}
 
 			var expr_type_array = expr_type as ArrayContainer;
 			if (expr_type_array != null) {
 				var target_type_array = target_type as ArrayContainer;
 				// from an array-type S to an array-type of type T
 				if (target_type_array != null && expr_type_array.Rank == target_type_array.Rank) {
 
 					//
 					// Both SE and TE are reference-types
 					//
 					TypeSpec expr_element_type = expr_type_array.Element;
 					if (!TypeManager.IsReferenceType (expr_element_type))
 						return false;
 
 					TypeSpec target_element_type = target_type_array.Element;
 					if (!TypeManager.IsReferenceType (target_element_type))
 						return false;
 
 					if (MyEmptyExpr == null)
 						MyEmptyExpr = new EmptyExpression (expr_element_type);
 					else
 						MyEmptyExpr.SetType (expr_element_type);
 
 					return ImplicitStandardConversionExists (MyEmptyExpr, target_element_type);
 				}
 
 				// from an array-type to System.Array
 				if (target_type == TypeManager.array_type)
 					return true;
 
 				// from an array-type of type T to IList<T>
 				if (ArrayToIList (expr_type_array, target_type, false))
 					return true;
 
 				return false;
 			}
 
 			if (TypeSpecComparer.IsEqual (expr_type, target_type))
 				return true;
 
 			if (TypeSpecComparer.Variant.IsEqual (expr_type, target_type))
 				return true;
 
 			// from any interface type S to interface-type T.
 			if (expr_type.IsInterface && target_type.IsInterface) {
 				return expr_type.ImplementsInterface (target_type, true);
 			}
 
 			// from any delegate type to System.Delegate
 			if (target_type == TypeManager.delegate_type &&
 				(expr_type == TypeManager.delegate_type || expr_type.IsDelegate))
 				return true;
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1694" endline="1700">
<![CDATA[
 
 		int peek_char ()
 		{
 			if (putback_char == -1)
 				putback_char = reader.Read ();
 			return putback_char;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="347" endline="390">
<![CDATA[
 
 		// <summary>
 		//   Resolve is used in method definitions
 		// </summary>
 		public virtual TypeSpec Resolve (IMemberContext rc, int index)
 		{
 			if (parameter_type != null)
 				return parameter_type;
 
 			if (attributes != null)
 				attributes.AttachTo (this, rc);
 
 			var expr = texpr.ResolveAsTypeTerminal (rc, false);
 			if (expr == null)
 				return null;
 
 			this.idx = index;
 			texpr = expr;
 			parameter_type = texpr.Type;
 	
 			if ((modFlags & Parameter.Modifier.ISBYREF) != 0 &&
 				TypeManager.IsSpecialType (parameter_type)) {
 				rc.Compiler.Report.Error (1601, Location, "Method or delegate parameter cannot be of type `{0}'",
 					GetSignatureForError ());
 				return null;
 			}
 
 			TypeManager.CheckTypeVariance (parameter_type,
 				(modFlags & Parameter.Modifier.ISBYREF) != 0 ? Variance.None 
 				rc);
 
 			if (parameter_type.IsStatic) {
 				rc.Compiler.Report.Error (721, Location, "`{0}'
 					texpr.GetSignatureForError ());
 				return parameter_type;
 			}
 
 			if ((modFlags & Modifier.This) != 0 && (parameter_type.IsPointer || parameter_type == InternalType.Dynamic)) {
 				rc.Compiler.Report.Error (1103, Location, "The extension method cannot be of type `{0}'",
 					TypeManager.CSharpName (parameter_type));
 			}
 
 			return parameter_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4625" endline="4669">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy,
 					bool prepare_for_load)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.EmitAssign (ec, source, leave_copy, prepare_for_load);
 				return;
 			}
 
 			New n_source = source as New;
 			if (n_source != null) {
 				if (!n_source.Emit (ec, this)) {
 					if (leave_copy) {
 						EmitLoad (ec);
 						if (IsRef)
 							ec.EmitLoadFromPtr (type);
 					}
 					return;
 				}
 			} else {
 				if (IsRef)
 					EmitLoad (ec);
 
 				source.Emit (ec);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 
 			if (IsRef)
 				ec.EmitStoreFromPtr (type);
 			else
 				Variable.EmitAssign (ec);
 
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="125" endline="137">
<![CDATA[
 
 		void InitializeStream (int read_length_inc)
 		{
 			read_ahead_length += read_length_inc;
 
 			int required_buffer_size = read_ahead_length * 2;
 
 			if (buffer == null || buffer.Length < required_buffer_size)
 				buffer = new char [required_buffer_size];
 
 			stream.Position = 0;
 			buffer_start = char_count = pos = 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="53" endline="68">
<![CDATA[
 
 		protected override MemberKind DetermineKindFromBaseType (MetaType baseType)
 		{
 			string name = baseType.Name;
 
 			if (name == "ValueType" && baseType.Namespace == "System")
 				return MemberKind.Struct;
 
 			if (name == "Enum" && baseType.Namespace == "System")
 				return MemberKind.Enum;
 
 			if (name == "MulticastDelegate" && baseType.Namespace == "System")
 				return MemberKind.Delegate;
 
 			return MemberKind.Class;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="318" endline="365">
<![CDATA[
 		}
 
 		public override StructLayoutAttribute StructLayoutAttribute
 		{
 			get
 			{
 				StructLayoutAttribute layout;
 				switch (this.Attributes & TypeAttributes.LayoutMask)
 				{
 					case TypeAttributes.AutoLayout
 						return null;
 					case TypeAttributes.SequentialLayout
 						layout = new StructLayoutAttribute(LayoutKind.Sequential);
 						break;
 					case TypeAttributes.ExplicitLayout
 						layout = new StructLayoutAttribute(LayoutKind.Explicit);
 						break;
 					default
 						throw new BadImageFormatException();
 				}
 				int token = this.MetadataToken;
 				// TODO use binary search?
 				for (int i = 0; i < module.ClassLayout.records.Length; i++)
 				{
 					if (module.ClassLayout.records[i].Parent == token)
 					{
 						layout.Pack = module.ClassLayout.records[i].PackingSize;
 						layout.Size = module.ClassLayout.records[i].ClassSize;
 						switch (this.Attributes & TypeAttributes.StringFormatMask)
 						{
 							case TypeAttributes.AnsiClass
 								layout.CharSet = CharSet.Ansi;
 								break;
 							case TypeAttributes.UnicodeClass
 								layout.CharSet = CharSet.Unicode;
 								break;
 							case TypeAttributes.AutoClass
 								layout.CharSet = CharSet.Auto;
 								break;
 							default
 								layout.CharSet = CharSet.None;
 								break;
 						}
 						return layout;
 					}
 				}
 				for (int i = 0; i < module.ClassLayout.records.Length; i++)
 				{
 					if (module.ClassLayout.records[i].Parent == token)
 					{
 						layout.Pack = module.ClassLayout.records[i].PackingSize;
 						layout.Size = module.ClassLayout.records[i].ClassSize;
 						switch (this.Attributes & TypeAttributes.StringFormatMask)
 						{
 							case TypeAttributes.AnsiClass
 								layout.CharSet = CharSet.Ansi;
 								break;
 							case TypeAttributes.UnicodeClass
 								layout.CharSet = CharSet.Unicode;
 								break;
 							case TypeAttributes.AutoClass
 								layout.CharSet = CharSet.Auto;
 								break;
 							default
 								layout.CharSet = CharSet.None;
 								break;
 						}
 						return layout;
 					}
 				}
 				return null;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1630" endline="1636">
<![CDATA[
 
 		public static LocalVariable CreateCompilerGenerated (TypeSpec type, Block block, Location loc)
 		{
 			LocalVariable li = new LocalVariable (block, "<$$>", Flags.CompilerGenerated | Flags.Used, loc);
 			li.Type = type;
 			return li;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="125" endline="133">
<![CDATA[
 
 		internal short ReadInt16()
 		{
 			if (end - pos < 2)
 				throw new BadImageFormatException();
 			byte b1 = buffer[pos++];
 			byte b2 = buffer[pos++];
 			return (short)(b1 | (b2 << 8));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1488" endline="1546">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (resolved_type == null) {
 				resolved_type = base.DoResolve (ec);
 
 				if (resolved_type == null)
 					return null;
 			}
 
 			type = probe_type_expr.Type;
 			eclass = ExprClass.Value;
 			TypeSpec etype = expr.Type;
 
 			if (!TypeManager.IsReferenceType (type) && !TypeManager.IsNullableType (type)) {
 				if (TypeManager.IsGenericParameter (type)) {
 					ec.Report.Error (413, loc,
 						"The `as' operator cannot be used with a non-reference type parameter `{0}'. Consider adding `class' or a reference type constraint",
 						probe_type_expr.GetSignatureForError ());
 				} else {
 					ec.Report.Error (77, loc,
 						"The `as' operator cannot be used with a non-nullable value type `{0}'",
 						TypeManager.CSharpName (type));
 				}
 				return null;
 			}
 
 			if (expr.IsNull && TypeManager.IsNullableType (type)) {
 				return Nullable.LiftedNull.CreateFromExpression (ec, this);
 			}
 
 			// If the compile-time type of E is dynamic, unlike the cast operator the as operator is not dynamically bound
 			if (etype == InternalType.Dynamic) {
 				return this;
 			}
 			
 			Expression e = Convert.ImplicitConversionStandard (ec, expr, type, loc);
 			if (e != null) {
 				e = EmptyCast.Create (e, type);
 				return ReducedExpression.Create (e, this).Resolve (ec);
 			}
 
 			if (Convert.ExplicitReferenceConversionExists (etype, type)){
 				if (TypeManager.IsGenericParameter (etype))
 					expr = new BoxedCast (expr, etype);
 
 				return this;
 			}
 
 			if (InflatedTypeSpec.ContainsTypeParameter (etype) || InflatedTypeSpec.ContainsTypeParameter (type)) {
 				expr = new BoxedCast (expr, etype);
 				return this;
 			}
 
 			ec.Report.Error (39, loc, "Cannot convert type `{0}' to `{1}' via a built-in conversion",
 				TypeManager.CSharpName (etype), TypeManager.CSharpName (type));
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="731" endline="798">
<![CDATA[
 
 		//
 		// Emits optimized equality or inequality operator when possible
 		//
 		void EmitEquality (EmitContext ec)
 		{
 			//
 			// Either left or right is null
 			//
 			if (left_unwrap != null && (IsRightNullLifted || right.IsNull)) {
 				left_unwrap.EmitCheck (ec);
 				if (Oper == Binary.Operator.Equality) {
 					ec.Emit (OpCodes.Ldc_I4_0);
 					ec.Emit (OpCodes.Ceq);
 				}
 				return;
 			}
 
 			if (right_unwrap != null && (IsLeftNullLifted || left.IsNull)) {
 				right_unwrap.EmitCheck (ec);
 				if (Oper == Binary.Operator.Equality) {
 					ec.Emit (OpCodes.Ldc_I4_0);
 					ec.Emit (OpCodes.Ceq);
 				}
 				return;
 			}
 
 			Label dissimilar_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			if (user_operator != null) {
 				user_operator.Emit (ec);
 				ec.Emit (Oper == Operator.Equality ? OpCodes.Brfalse_S 
 			} else {
 				left.Emit (ec);
 				right.Emit (ec);
 
 				ec.Emit (OpCodes.Bne_Un_S, dissimilar_label);
 			}
 
 			if (left_unwrap != null)
 				left_unwrap.EmitCheck (ec);
 
 			if (right_unwrap != null)
 				right_unwrap.EmitCheck (ec);
 
 			if (left_unwrap != null && right_unwrap != null) {
 				if (Oper == Operator.Inequality)
 					ec.Emit (OpCodes.Xor);
 				else
 					ec.Emit (OpCodes.Ceq);
 			} else {
 				if (Oper == Operator.Inequality) {
 					ec.Emit (OpCodes.Ldc_I4_0);
 					ec.Emit (OpCodes.Ceq);
 				}
 			}
 
 			ec.Emit (OpCodes.Br_S, end_label);
 
 			ec.MarkLabel (dissimilar_label);
 			if (Oper == Operator.Inequality)
 				ec.Emit (OpCodes.Ldc_I4_1);
 			else
 				ec.Emit (OpCodes.Ldc_I4_0);
 
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2175" endline="2208">
<![CDATA[
 		}
 
 		public virtual void Emit (DeclSpace parent)
 		{
 			method_data.Emit (parent);
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (method_data.MethodBuilder);
 			if (((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0))
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (method_data.MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					method_data.MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					method_data.MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 				foreach (var de in declarative_security) {
 #if STATIC
 					method_data.MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					method_data.MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			block = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="351" endline="362">
<![CDATA[
 		}
 
 		public void Error (int code, Location loc, string error)
 		{
 			if (reporting_disabled > 0)
 				return;
 
 			ErrorMessage msg = new ErrorMessage (code, loc, error, extra_information);
 			extra_information.Clear ();
 
 			printer.Print (msg);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1297" endline="1316">
<![CDATA[
 
 		public override void DefineType ()
 		{
 			if (error)
 				return;
 			if (type_defined)
 				return;
 
 			type_defined = true;
 
 			if (!DefineBaseTypes ()) {
 				error = true;
 				return;
 			}
 
 			if (!DefineNestedTypes ()) {
 				error = true;
 				return;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4575" endline="4592">
<![CDATA[
 		}
 
 		#endregion
 
 		public override bool Resolve (BlockContext ec)
 		{
 			using (ec.Set (ResolveContext.Options.FixedInitializerScope)) {
 				if (!decl.Resolve (ec))
 					return false;
 			}
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Conditional, loc);
 			bool ok = statement.Resolve (ec);
 			bool flow_unreachable = ec.EndFlowBranching ();
 			has_ret = flow_unreachable;
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4001" endline="4011">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			// System.Reflection.Emit automatically emits a 'leave' at the end of a try clause
 			// So, ensure there's some IL code after this statement.
 			if (!code_follows && resume_points == null && ec.CurrentBranching.CurrentUsageVector.IsUnreachable)
 				ec.NeedReturnLabel ();
 
 			iter = ec.CurrentIterator;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="292" endline="302">
<![CDATA[
 
 		public Label BeginExceptionBlock()
 		{
 			ExceptionBlock block = new ExceptionBlock(exceptions.Count);
 			block.labelEnd = DefineLabel();
 			block.tryOffset = code.Position;
 			exceptionStack.Push(block);
 			exceptions.Add(block);
 			stackHeight = 0;
 			return block.labelEnd;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3077" endline="3090">
<![CDATA[
 
 		public void Error_AlreadyOccurs (ResolveContext ec, TypeSpec switch_type, SwitchLabel collision_with)
 		{
 			string label;
 			if (converted == null)
 				label = "default";
 			else if (converted == NullStringCase)
 				label = "null";
 			else
 				label = converted.ToString ();
 			
 			ec.Report.SymbolRelatedToPreviousError (collision_with.loc, null);
 			ec.Report.Error (152, loc, "The label `case {0}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1122" endline="1129">
<![CDATA[
 
 		private Expression GetValue () 
 		{
 			if (PosArguments == null || PosArguments.Count < 1)
 				return null;
 
 			return PosArguments [0].Expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="283" endline="304">
<![CDATA[
 
 		protected bool DoResolveCore (ResolveContext rc)
 		{
 			int errors = rc.Report.Errors;
 			var pt = rc.Module.PredefinedTypes;
 
 			binder_type = pt.Binder.Resolve (loc);
 			pt.CallSite.Resolve (loc);
 			pt.CallSiteGeneric.Resolve (loc);
 
 			eclass = ExprClass.Value;
 
 			if (type == null)
 				type = InternalType.Dynamic;
 
 			if (rc.Report.Errors == errors)
 				return true;
 
 			rc.Report.Error (1969, loc,
 				"Dynamic operation cannot be compiled without `Microsoft.CSharp.dll' assembly reference");
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2402" endline="2430">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.AttributeUsage) {
 				if (!BaseType.IsAttribute && spec != TypeManager.attribute_type) {
 					Report.Error (641, a.Location, "Attribute `{0}' is only valid on classes derived from System.Attribute", a.GetSignatureForError ());
 				}
 			}
 
 			if (a.Type == pa.Conditional && !BaseType.IsAttribute) {
 				Report.Error (1689, a.Location, "Attribute `System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes");
 				return;
 			}
 
 			if (a.Type == pa.ComImport && !attributes.Contains (pa.Guid)) {
 				a.Error_MissingGuidAttribute ();
 				return;
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			if (a.Type.IsConditionallyExcluded (Location))
 				return;
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5714" endline="5742">
<![CDATA[
 		}
 
 		public override bool Resolve (BlockContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return false;
 
 			if (expr.IsNull) {
 				ec.Report.Error (186, loc, "Use of null is not valid in this context");
 				return false;
 			}
 
 			if (expr.Type == TypeManager.string_type) {
 				statement = new ArrayForeach (this, 1);
 			} else if (expr.Type is ArrayContainer) {
 				statement = new ArrayForeach (this, ((ArrayContainer) expr.Type).Rank);
 			} else {
 				if (expr.eclass == ExprClass.MethodGroup || expr is AnonymousMethodExpression) {
 					ec.Report.Error (446, expr.Location, "Foreach statement cannot operate on a `{0}'",
 						expr.ExprClassName);
 					return false;
 				}
 
 				statement = new CollectionForeach (type, variable, expr, statement, loc);
 			}
 
 			return statement.Resolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="601" endline="637">
<![CDATA[
 
 		public override void Emit ()
 		{
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (MethodBuilder);
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			if (MethodData != null)
 				MethodData.Emit (Parent);
 
 			base.Emit ();
 
 			Block = null;
 			MethodData = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="709" endline="716">
<![CDATA[
 		
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, this.arguments,
 				InstanceExpr.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "Invoke", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8080" endline="8087">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, Arguments,
 				Expr.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "ArrayIndex", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="819" endline="829">
<![CDATA[
 
 		static string GetLookupName (MemberCore mc)
 		{
 			if (mc is Indexer)
 				return IndexerNameAlias;
 
 			if (mc is Constructor)
 				return Constructor.ConstructorName;
 
 			return mc.MemberName.Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5649" endline="5666">
<![CDATA[
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (right_side == EmptyExpression.EventAddition) {
 				op = spec.AccessorAdd;
 			} else if (right_side == EmptyExpression.EventSubtraction) {
 				op = spec.AccessorRemove;
 			}
 
 			if (op == null) {
 				Error_AssignmentEventOnly (ec);
 				return null;
 			}
 
 			op = CandidateToBaseOverride (ec, op);
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8418" endline="8432">
<![CDATA[
 
 		public override void Emit (EmitContext ec, bool leave_copy)
 		{
 			if (prepared) {
 				prepared_value.Emit (ec);
 			} else {
 				Invocation.EmitCall (ec, InstanceExpression, Getter, arguments, loc);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				temp = new LocalTemporary (Type);
 				temp.Store (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5320" endline="5343">
<![CDATA[
 
 		public override void Emit (EmitContext ec, bool leave_copy)
 		{
 			//
 			// Special case
 			//
 			if (IsSingleDimensionalArrayLength ()) {
 				if (!prepared)
 					EmitInstance (ec, false);
 				ec.Emit (OpCodes.Ldlen);
 				ec.Emit (OpCodes.Conv_I4);
 				return;
 			}
 
 			Invocation.EmitCall (ec, InstanceExpression, Getter, null, loc, prepared, false);
 			
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (!IsStatic) {
 					temp = new LocalTemporary (this.Type);
 					temp.Store (ec);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6936" endline="6954">
<![CDATA[
 
 		override public Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			ResolveBase (ec);
 
 			if (variable_info != null)
 				variable_info.SetAssigned (ec);
 
 			if (type.IsClass){
 				if (right_side == EmptyExpression.UnaryAddress)
 					ec.Report.Error (459, loc, "Cannot take the address of `this' because it is read-only");
 				else if (right_side == EmptyExpression.OutAccess.Instance)
 					ec.Report.Error (1605, loc, "Cannot pass `this' as a ref or out argument because it is read-only");
 				else
 					ec.Report.Error (1604, loc, "Cannot assign to `this' because it is read-only");
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="259" endline="281">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.Assembly) {
 				assembly.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.CLSCompliant) {
 				Attribute cls = DeclaringAssembly.CLSCompliantAttribute;
 				if (cls == null) {
 					Report.Warning (3012, 1, a.Location,
 						"You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking");
 				} else if (DeclaringAssembly.IsCLSCompliant != a.GetBoolean ()) {
 					Report.SymbolRelatedToPreviousError (cls.Location, cls.GetSignatureForError ());
 					Report.Warning (3017, 1, a.Location,
 						"You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly");
 					return;
 				}
 			}
 
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="894" endline="939">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				if (IsExplicitImpl) {
 					Error_ConditionalAttributeIsNotValid ();
 					return;
 				}
 
 				if ((ModFlags & Modifiers.OVERRIDE) != 0) {
 					Report.Error (243, Location, "Conditional not valid on `{0}' because it is an override method", GetSignatureForError ());
 					return;
 				}
 
 				if (ReturnType != TypeManager.void_type) {
 					Report.Error (578, Location, "Conditional not valid on `{0}' because its return type is not void", GetSignatureForError ());
 					return;
 				}
 
 				if (IsInterface) {
 					Report.Error (582, Location, "Conditional not valid on interface members");
 					return;
 				}
 
 				if (MethodData.implementing != null) {
 					Report.SymbolRelatedToPreviousError (MethodData.implementing.DeclaringType);
 					Report.Error (629, Location, "Conditional member `{0}' cannot implement interface member `{1}'",
 						GetSignatureForError (), TypeManager.CSharpSignature (MethodData.implementing));
 					return;
 				}
 
 				for (int i = 0; i < parameters.Count; ++i) {
 					if (parameters.FixedParameters [i].ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (685, Location, "Conditional method `{0}' cannot have an out parameter", GetSignatureForError ());
 						return;
 					}
 				}
 				for (int i = 0; i < parameters.Count; ++i) {
 					if (parameters.FixedParameters [i].ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (685, Location, "Conditional method `{0}' cannot have an out parameter", GetSignatureForError ());
 						return;
 					}
 				}
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1057" endline="1144">
<![CDATA[
 
 		Expression ConvertExpression (ResolveContext ec)
 		{
 			// TODO
 			if (left.eclass == ExprClass.MethodGroup)
 				return null;
 
 			TypeSpec ltype = left.Type;
 
 			//
 			// If left is a nullable type and an implicit conversion exists from right to underlying type of left,
 			// the result is underlying type of left
 			//
 			if (TypeManager.IsNullableType (ltype)) {
 				unwrap = Unwrap.Create (left, false);
 				if (unwrap == null)
 					return null;
 
 				//
 				// Reduce (left ?? null) to left
 				//
 				if (right.IsNull)
 					return ReducedExpression.Create (left, this);
 
 				if (Convert.ImplicitConversionExists (ec, right, unwrap.Type)) {
 					left = unwrap;
 					ltype = left.Type;
 
 					//
 					// If right is a dynamic expression, the result type is dynamic
 					//
 					if (right.Type == InternalType.Dynamic) {
 						type = right.Type;
 
 						// Need to box underlying value type
 						left = Convert.ImplicitBoxingConversion (left, ltype, type);
 						return this;
 					}
 
 					right = Convert.ImplicitConversion (ec, right, ltype, loc);
 					type = ltype;
 					return this;
 				}
 			} else if (TypeManager.IsReferenceType (ltype)) {
 				if (Convert.ImplicitConversionExists (ec, right, ltype)) {
 					//
 					// If right is a dynamic expression, the result type is dynamic
 					//
 					if (right.Type == InternalType.Dynamic) {
 						type = right.Type;
 						return this;
 					}
 
 					//
 					// Reduce ("foo" ?? expr) to expression
 					//
 					Constant lc = left as Constant;
 					if (lc != null && !lc.IsDefaultValue)
 						return ReducedExpression.Create (lc, this).Resolve (ec);
 
 					//
 					// Reduce (left ?? null) to left OR (null-constant ?? right) to right
 					//
 					if (right.IsNull || lc != null)
 						return ReducedExpression.Create (lc != null ? right 
 
 					right = Convert.ImplicitConversion (ec, right, ltype, loc);
 					type = ltype;
 					return this;
 				}
 			} else {
 				return null;
 			}
 
 			TypeSpec rtype = right.Type;
 			if (!Convert.ImplicitConversionExists (ec, unwrap != null ? unwrap 
 				return null;
 
 			//
 			// Reduce (null ?? right) to right
 			//
 			if (left.IsNull)
 				return ReducedExpression.Create (right, this).Resolve (ec);
 
 			left = Convert.ImplicitConversion (ec, unwrap != null ? unwrap 
 			type = rtype;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="450" endline="461">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Generation);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteGuidIndex(records[i].Mvid);
 				mw.WriteGuidIndex(records[i].EncId);
 				mw.WriteGuidIndex(records[i].EncBaseId);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Generation);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteGuidIndex(records[i].Mvid);
 				mw.WriteGuidIndex(records[i].EncId);
 				mw.WriteGuidIndex(records[i].EncBaseId);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2138" endline="2149">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.Write(records[i].TypeDefId);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNamespace);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].Flags);
 				mw.Write(records[i].TypeDefId);
 				mw.WriteStringIndex(records[i].TypeName);
 				mw.WriteStringIndex(records[i].TypeNamespace);
 				mw.WriteImplementation(records[i].Implementation);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1903" endline="1939">
<![CDATA[
 
 
 		/// <summary>
 		/// Create the MethodBuilder for the method 
 		/// </summary>
 		void DefineMethodBuilder (TypeContainer container, string method_name, ParametersCompiled param)
 		{
 			var return_type = method.ReturnType.GetMetaInfo ();
 			var p_types = param.GetMetaInfo ();
 
 			if (builder == null) {
 				builder = container.TypeBuilder.DefineMethod (
 					method_name, flags, method.CallingConventions,
 					return_type, p_types);
 				return;
 			}
 
 			//
 			// Generic method has been already defined to resolve method parameters
 			// correctly when they use type parameters
 			//
 			builder.SetParameters (p_types);
 			builder.SetReturnType (return_type);
 			if (builder.Attributes != flags) {
 #if STATIC
 				builder.__SetAttributes (flags);
 #else
 				try {
 					if (methodbuilder_attrs_field == null)
 						methodbuilder_attrs_field = typeof (MethodBuilder).GetField ("attrs", BindingFlags.NonPublic | BindingFlags.Instance);
 					methodbuilder_attrs_field.SetValue (builder, flags);
 				} catch {
 					container.Compiler.Report.RuntimeMissingSupport (method.Location, "Generic method MethodAttributes");
 				}
 #endif
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="843" endline="892">
<![CDATA[
 		}
 
 		public static void CreateIterator (IMethodData method, TypeContainer parent, Modifiers modifiers, CompilerContext ctx)
 		{
 			bool is_enumerable;
 			TypeSpec iterator_type;
 
 			TypeSpec ret = method.ReturnType;
 			if (ret == null)
 				return;
 
 			if (!CheckType (ret, out iterator_type, out is_enumerable)) {
 				ctx.Report.Error (1624, method.Location,
 					      "The body of `{0}' cannot be an iterator block " +
 					      "because `{1}' is not an iterator interface type",
 					      method.GetSignatureForError (),
 					      TypeManager.CSharpName (ret));
 				return;
 			}
 
 			ParametersCompiled parameters = method.ParameterInfo;
 			for (int i = 0; i < parameters.Count; i++) {
 				Parameter p = parameters [i];
 				Parameter.Modifier mod = p.ModFlags;
 				if ((mod & Parameter.Modifier.ISBYREF) != 0) {
 					ctx.Report.Error (1623, p.Location,
 						"Iterators cannot have ref or out parameters");
 					return;
 				}
 
 				if (p is ArglistParameter) {
 					ctx.Report.Error (1636, method.Location,
 						"__arglist is not allowed in parameter list of iterators");
 					return;
 				}
 
 				if (parameters.Types [i].IsPointer) {
 					ctx.Report.Error (1637, p.Location,
 							  "Iterators cannot have unsafe parameters or " +
 							  "yield types");
 					return;
 				}
 			}
 			for (int i = 0; i < parameters.Count; i++) {
 				Parameter p = parameters [i];
 				Parameter.Modifier mod = p.ModFlags;
 				if ((mod & Parameter.Modifier.ISBYREF) != 0) {
 					ctx.Report.Error (1623, p.Location,
 						"Iterators cannot have ref or out parameters");
 					return;
 				}
 
 				if (p is ArglistParameter) {
 					ctx.Report.Error (1636, method.Location,
 						"__arglist is not allowed in parameter list of iterators");
 					return;
 				}
 
 				if (parameters.Types [i].IsPointer) {
 					ctx.Report.Error (1637, p.Location,
 							  "Iterators cannot have unsafe parameters or " +
 							  "yield types");
 					return;
 				}
 			}
 
 			if ((modifiers & Modifiers.UNSAFE) != 0) {
 				ctx.Report.Error (1629, method.Location, "Unsafe code may not appear in iterators");
 			}
 
 			method.Block.WrapIntoIterator (method, parent, iterator_type, is_enumerable);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="102" endline="185">
<![CDATA[
 		}
 
 		protected override bool DoDefineMembers ()
 		{
 			var ctor_parameters = ParametersCompiled.CreateFullyResolved (
 				new [] {
 					new Parameter (new TypeExpression (TypeManager.object_type, Location), "object", Parameter.Modifier.NONE, null, Location),
 					new Parameter (new TypeExpression (TypeManager.intptr_type, Location), "method", Parameter.Modifier.NONE, null, Location)
 				},
 				new [] {
 					TypeManager.object_type,
 					TypeManager.intptr_type
 				}
 			);
 
 			Constructor = new Constructor (this, Constructor.ConstructorName,
 				Modifiers.PUBLIC, null, ctor_parameters, null, Location);
 			Constructor.Define ();
 
 			//
 			// Here the various methods like Invoke, BeginInvoke etc are defined
 			//
 			// First, call the `out of band' special method for
 			// defining recursively any types we need
 			//
 			var p = parameters;
 
 			if (!p.Resolve (this))
 				return false;
 
 			//
 			// Invoke method
 			//
 
 			// Check accessibility
 			foreach (var partype in p.Types) {
 				if (!IsAccessibleAs (partype)) {
 					Report.SymbolRelatedToPreviousError (partype);
 					Report.Error (59, Location,
 						"Inconsistent accessibility
 						TypeManager.CSharpName (partype), GetSignatureForError ());
 				}
 			}
 			foreach (var partype in p.Types) {
 				if (!IsAccessibleAs (partype)) {
 					Report.SymbolRelatedToPreviousError (partype);
 					Report.Error (59, Location,
 						"Inconsistent accessibility
 						TypeManager.CSharpName (partype), GetSignatureForError ());
 				}
 			}
 
 			ReturnType = ReturnType.ResolveAsTypeTerminal (this, false);
 			if (ReturnType == null)
 				return false;
 
 			var ret_type = ReturnType.Type;
 
 			//
 			// We don't have to check any others because they are all
 			// guaranteed to be accessible - they are standard types.
 			//
 			if (!IsAccessibleAs (ret_type)) {
 				Report.SymbolRelatedToPreviousError (ret_type);
 				Report.Error (58, Location,
 						  "Inconsistent accessibility
 						  TypeManager.CSharpName (ret_type) + "' is less " +
 						  "accessible than delegate `" + GetSignatureForError () + "'");
 				return false;
 			}
 
 			CheckProtectedModifier ();
 
 			if (RootContext.StdLib && TypeManager.IsSpecialType (ret_type)) {
 				Method.Error1599 (Location, ret_type, Report);
 				return false;
 			}
 
 			TypeManager.CheckTypeVariance (ret_type, Variance.Covariant, this);
 
 			InvokeBuilder = new Method (this, null, ReturnType, MethodModifiers, new MemberName (InvokeMethodName), p, null);
 			InvokeBuilder.Define ();
 
 			//
 			// Don't emit async method for compiler generated delegates (e.g. dynamic site containers)
 			//
 			if (!IsCompilerGenerated) {
 				DefineAsyncMethods (Parameters.CallingConvention);
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="747" endline="806">
<![CDATA[
 
 		/// <summary>
 		/// The main virtual method for CLS-Compliant verifications.
 		/// The method returns true if member is CLS-Compliant and false if member is not
 		/// CLS-Compliant which means that CLS-Compliant tests are not necessary. A descendants override it
 		/// and add their extra verifications.
 		/// </summary>
 		protected virtual bool VerifyClsCompliance ()
 		{
 			if (HasClsCompliantAttribute) {
 				if (!Module.DeclaringAssembly.HasCLSCompliantAttribute) {
 					Attribute a = OptAttributes.Search (Module.PredefinedAttributes.CLSCompliant);
 					if ((caching_flags & Flags.ClsCompliantAttributeFalse) != 0) {
 						Report.Warning (3021, 2, a.Location,
 							"`{0}' does not need a CLSCompliant attribute because the assembly is not marked as CLS-compliant",
 							GetSignatureForError ());
 					} else {
 						Report.Warning (3014, 1, a.Location,
 							"`{0}' cannot be marked as CLS-compliant because the assembly is not marked as CLS-compliant",
 							GetSignatureForError ());
 					}
 					return false;
 				}
 
 				if (!IsExposedFromAssembly ()) {
 					Attribute a = OptAttributes.Search (Module.PredefinedAttributes.CLSCompliant);
 					Report.Warning (3019, 2, a.Location, "CLS compliance checking will not be performed on `{0}' because it is not visible from outside this assembly", GetSignatureForError ());
 					return false;
 				}
 
 				if ((caching_flags & Flags.ClsCompliantAttributeFalse) != 0) {
 					if (Parent.Kind == MemberKind.Interface && Parent.IsClsComplianceRequired ()) {
 						Report.Warning (3010, 1, Location, "`{0}'
 					} else if (Parent.Kind == MemberKind.Class && (ModFlags & Modifiers.ABSTRACT) != 0 && Parent.IsClsComplianceRequired ()) {
 						Report.Warning (3011, 1, Location, "`{0}'
 					}
 
 					return false;
 				}
 
 				if (Parent.Parent != null && !Parent.IsClsComplianceRequired ()) {
 					Attribute a = OptAttributes.Search (Module.PredefinedAttributes.CLSCompliant);
 					Report.Warning (3018, 1, a.Location, "`{0}' cannot be marked as CLS-compliant because it is a member of non CLS-compliant type `{1}'",
 						GetSignatureForError (), Parent.GetSignatureForError ());
 					return false;
 				}
 			} else {
 				if (!IsExposedFromAssembly ())
 					return false;
 
 				if (!Parent.PartialContainer.IsClsComplianceRequired ())
 					return false;
 			}
 
 			if (member_name.Name [0] == '_') {
 				Report.Warning (3008, 1, Location, "Identifier `{0}' is not CLS-compliant", GetSignatureForError () );
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3410" endline="3477">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		//  7.4.3.3  Better conversion from expression
 		//  Returns 
 		//              2    if a->q is better,
 		//              0 if neither is better
 		//
 		static int BetterExpressionConversion (ResolveContext ec, Argument a, TypeSpec p, TypeSpec q)
 		{
 			TypeSpec argument_type = a.Type;
 
 			//
 			// If argument is an anonymous function
 			//
 			if (argument_type == InternalType.AnonymousMethod && RootContext.Version > LanguageVersion.ISO_2) {
 				//
 				// p and q are delegate types or expression tree types
 				//
 				if (p.GetDefinition () == TypeManager.expression_type || q.GetDefinition () == TypeManager.expression_type) {
 					if (q.MemberDefinition != p.MemberDefinition) {
 						return 0;
 					}
 
 					//
 					// Uwrap delegate from Expression<T>
 					//
 					q = TypeManager.GetTypeArguments (q)[0];
 					p = TypeManager.GetTypeArguments (p)[0];
 				}
 
 				var p_m = Delegate.GetInvokeMethod (ec.Compiler, p);
 				var q_m = Delegate.GetInvokeMethod (ec.Compiler, q);
 
 				//
 				// With identical parameter lists
 				//
 				if (!TypeSpecComparer.Equals (p_m.Parameters.Types,q_m.Parameters.Types))
 					return 0;
 
 				p = p_m.ReturnType;
 				q = q_m.ReturnType;
 
 				//
 				// if p is void returning, and q has a return type Y, then C2 is the better conversion.
 				//
 				if (p == TypeManager.void_type) {
 					return q != TypeManager.void_type ? 2 
 				}
 
 				//
 				// if p has a return type Y, and q is void returning, then C1 is the better conversion.
 				//
 				if (q == TypeManager.void_type) {
 					return p != TypeManager.void_type ? 1
 				}
 			} else {
 				if (argument_type == p)
 					return 1;
 
 				if (argument_type == q)
 					return 2;
 			}
 
 			return BetterTypeConversion (ec, p, q);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1947" endline="1992">
<![CDATA[
 
 		public static Expression ExplicitUnsafe (Expression expr, TypeSpec target_type)
 		{
 			TypeSpec expr_type = expr.Type;
 
 			if (target_type.IsPointer){
 				if (expr_type.IsPointer)
 					return EmptyCast.Create (expr, target_type);
 
 				if (expr_type == TypeManager.sbyte_type ||
 					expr_type == TypeManager.short_type ||
 					expr_type == TypeManager.int32_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_I);
 
 				if (expr_type == TypeManager.ushort_type ||
 					expr_type == TypeManager.uint32_type ||
 					expr_type == TypeManager.byte_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U);
 
 				if (expr_type == TypeManager.int64_type)
 					return new ConvCast (expr, target_type, ConvCast.Mode.I8_I);
 
 				if (expr_type == TypeManager.uint64_type)
 					return new ConvCast (expr, target_type, ConvCast.Mode.U8_I);
 			}
 
 			if (expr_type.IsPointer){
 				if (target_type == TypeManager.sbyte_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_I1);
 				if (target_type == TypeManager.byte_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U1);
 				if (target_type == TypeManager.short_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_I2);
 				if (target_type == TypeManager.ushort_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U2);
 				if (target_type == TypeManager.int32_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_I4);
 				if (target_type == TypeManager.uint32_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U4);
 				if (target_type == TypeManager.int64_type)
 					return new ConvCast (expr, target_type, ConvCast.Mode.I_I8);
 				if (target_type == TypeManager.uint64_type)
 					return new OpcodeCast (expr, target_type, OpCodes.Conv_U8);
 			}
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1958" endline="2060">
<![CDATA[
 
 		//
 		// Parses #pragma checksum
 		//
 		bool ParsePragmaChecksum ()
 		{
 			//
 			// The syntax is ` "foo.txt" "{guid}" "hash"'
 			//
 			int c = get_char ();
 
 			if (c != '"')
 				return false;
 
 			string_builder.Length = 0;
 			while (c != -1 && c != '\n') {
 				c = get_char ();
 				if (c == '"') {
 					c = get_char ();
 					break;
 				}
 
 				string_builder.Append ((char) c);
 			}
 			while (c != -1 && c != '\n') {
 				c = get_char ();
 				if (c == '"') {
 					c = get_char ();
 					break;
 				}
 
 				string_builder.Append ((char) c);
 			}
 
 			if (string_builder.Length == 0) {
 				Report.Warning (1709, 1, Location, "Filename specified for preprocessor directive is empty");
 			}
 
 			// TODO
 			if (c != ' ')
 				return false;
 
 			SourceFile file = Location.LookupFile (file_name, string_builder.ToString ());
 
 			if (get_char () != '"' || get_char () != '{')
 				return false;
 
 			bool error;
 			byte[] guid_bytes = new byte [16];
 			int i = 0;
 
 			for (; i < 4; i++) {
 				guid_bytes [i] = read_hex (out error);
 				if (error)
 					return false;
 			}
 			for (; i < 4; i++) {
 				guid_bytes [i] = read_hex (out error);
 				if (error)
 					return false;
 			}
 
 			if (get_char () != '-')
 				return false;
 
 			for (; i < 10; i++) {
 				guid_bytes [i] = read_hex (out error);
 				if (error)
 					return false;
 
 				guid_bytes [i++] = read_hex (out error);
 				if (error)
 					return false;
 
 				if (get_char () != '-')
 					return false;
 			}
 			for (; i < 10; i++) {
 				guid_bytes [i] = read_hex (out error);
 				if (error)
 					return false;
 
 				guid_bytes [i++] = read_hex (out error);
 				if (error)
 					return false;
 
 				if (get_char () != '-')
 					return false;
 			}
 
 			for (; i < 16; i++) {
 				guid_bytes [i] = read_hex (out error);
 				if (error)
 					return false;
 			}
 			for (; i < 16; i++) {
 				guid_bytes [i] = read_hex (out error);
 				if (error)
 					return false;
 			}
 
 			if (get_char () != '}' || get_char () != '"')
 				return false;
 
 			// TODO
 			c = get_char ();
 			if (c != ' ')
 				return false;
 
 			if (get_char () != '"')
 				return false;
 
 			// Any length of checksum
 			List<byte> checksum_bytes = new List<byte> (16);
 
 			c = peek_char ();
 			while (c != '"' && c != -1) {
 				checksum_bytes.Add (read_hex (out error));
 				if (error)
 					return false;
 
 				c = peek_char ();
 			}
 			while (c != '"' && c != -1) {
 				checksum_bytes.Add (read_hex (out error));
 				if (error)
 					return false;
 
 				c = peek_char ();
 			}
 
 			if (c == '/') {
 				ReadSingleLineComment ();
 			} else if (get_char () != '"') {
 				return false;
 			}
 
 			file.SetChecksum (guid_bytes, checksum_bytes.ToArray ());
 			ref_name.AutoGenerated = true;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\literal.cs" startline="117" endline="132">
<![CDATA[
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			//
 			// The 0 literal can be converted to an enum value
 			//
 			if (Value == 0 && TypeManager.IsEnumType (type)) {
 				Constant c = ConvertImplicitly (rc, EnumSpec.GetUnderlyingType (type));
 				if (c == null)
 					return null;
 
 				return new EnumConstant (c, type).Resolve (rc);
 			}
 
 			return base.ConvertImplicitly (rc, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="267" endline="283">
<![CDATA[
 
 		private LineNumberEntry [] method_lines;
 		private int method_lines_pos = 0;
 
 		public void MarkSequencePoint (int offset, SourceFileEntry file, int line, int column,
 					       bool is_hidden)
 		{
 			if (method_lines_pos == method_lines.Length) {
 				LineNumberEntry [] tmp = method_lines;
 				method_lines = new LineNumberEntry [method_lines.Length * 2];
 				Array.Copy (tmp, method_lines, method_lines_pos);
 			}
 
 			int file_idx = file != null ? file.Index 
 			method_lines [method_lines_pos++] = new LineNumberEntry (
 				file_idx, line, offset, is_hidden);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8796" endline="8805">
<![CDATA[
 			
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			ObsoleteAttribute oa = method.GetAttributeObsolete ();
 			if (oa != null)
 				AttributeTester.Report_ObsoleteMessage (oa, GetSignatureForError (), loc, ec.Report);
 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1161" endline="1205">
<![CDATA[
 
 		internal void WriteData (MonoSymbolFile file, MyBinaryWriter bw)
 		{
 			if (index <= 0)
 				throw new InvalidOperationException ();
 
 			LocalVariableTableOffset = (int) bw.BaseStream.Position;
 			int num_locals = locals != null ? locals.Length 
 			bw.WriteLeb128 (num_locals);
 			for (int i = 0; i < num_locals; i++)
 				locals [i].Write (file, bw);
 			for (int i = 0; i < num_locals; i++)
 				locals [i].Write (file, bw);
 			file.LocalCount += num_locals;
 
 			CodeBlockTableOffset = (int) bw.BaseStream.Position;
 			int num_code_blocks = code_blocks != null ? code_blocks.Length 
 			bw.WriteLeb128 (num_code_blocks);
 			for (int i = 0; i < num_code_blocks; i++)
 				code_blocks [i].Write (bw);
 			for (int i = 0; i < num_code_blocks; i++)
 				code_blocks [i].Write (bw);
 
 			ScopeVariableTableOffset = (int) bw.BaseStream.Position;
 			int num_scope_vars = scope_vars != null ? scope_vars.Length 
 			bw.WriteLeb128 (num_scope_vars);
 			for (int i = 0; i < num_scope_vars; i++)
 				scope_vars [i].Write (bw);
 			for (int i = 0; i < num_scope_vars; i++)
 				scope_vars [i].Write (bw);
 
 			if (real_name != null) {
 				RealNameOffset = (int) bw.BaseStream.Position;
 				bw.Write (real_name);
 			}
 
 			LineNumberTableOffset = (int) bw.BaseStream.Position;
 			lnt.Write (file, bw);
 
 			DataOffset = (int) bw.BaseStream.Position;
 
 			bw.WriteLeb128 (CompileUnitIndex);
 			bw.WriteLeb128 (LocalVariableTableOffset);
 			bw.WriteLeb128 (NamespaceID);
 
 			bw.WriteLeb128 (CodeBlockTableOffset);
 			bw.WriteLeb128 (ScopeVariableTableOffset);
 
 			bw.WriteLeb128 (RealNameOffset);
 			bw.WriteLeb128 ((int) flags);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="49" endline="59">
<![CDATA[
 
 		public override bool Equals(object obj)
 		{
 			MethodSignature other = obj as MethodSignature;
 			return other != null
 				&& other.callingConvention == callingConvention
 				&& other.genericParamCount == genericParamCount
 				&& other.returnType.Equals(returnType)
 				&& Util.ArrayEquals(other.parameterTypes, parameterTypes)
 				&& Util.ArrayEquals(other.modifiers, modifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="856" endline="868">
<![CDATA[
 
 		protected override void EmitOperator (EmitContext ec, TypeSpec l)
 		{
 			if (user_operator != null) {
 				user_operator.Emit (ec);
 				return;
 			}
 
 			if (TypeManager.IsNullableType (l))
 				l = TypeManager.GetTypeArguments (l) [0];
 
 			base.EmitOperator (ec, l);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="274" endline="287">
<![CDATA[
 	}
 
 	// FIXME
 	void OutlineAttributes ()
 	{
 		if (t.IsSerializable)
 			o.WriteLine ("[Serializable]");
 
 		if (t.IsDefined (typeof (System.FlagsAttribute), true))
 			o.WriteLine ("[Flags]");
 
 		if (t.IsDefined (typeof (System.ObsoleteAttribute), true))
 			o.WriteLine ("[Obsolete]");
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1522" endline="1539">
<![CDATA[
 
 		System.Collections.BitArray MakeShared (int new_count)
 		{
 			// Post-condition
 
 			// ensure we don't leak out dirty bits from the BitVector we inherited from
 			if (new_count > Count &&
 			    ((shared != null && shared.Count > Count) ||
 			     (shared == null && vector == null)))
 				initialize_vector ();
 
 			if (vector != null) {
 				shared = vector;
 				vector = null;
 			}
 
 			return shared;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="422" endline="444">
<![CDATA[
 
 		private void AddMemberToList (MemberCore mc, List<MemberCore> alist, bool isexplicit)
 		{
 			if (ordered_explicit_member_list == null)  {
 				ordered_explicit_member_list = new List<MemberCore> ();
 				ordered_member_list = new List<MemberCore> ();
 			}
 
 			if (isexplicit) {
 				if (Kind == MemberKind.Interface) {
 					Report.Error (541, mc.Location,
 						"`{0}'
 						mc.GetSignatureForError ());
 				}
 
 				ordered_explicit_member_list.Add (mc);
 				alist.Insert (0, mc);
 			} else {
 				ordered_member_list.Add (mc);
 				alist.Add (mc);
 			}
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1436" endline="1452">
<![CDATA[
 
 		Expression ResolveGenericParameter (ResolveContext ec, TypeSpec d, TypeParameterSpec t)
 		{
 			if (t.IsReferenceType) {
 				if (TypeManager.IsStruct (d))
 					return CreateConstantResult (ec, false);
 			}
 
 			if (TypeManager.IsGenericParameter (expr.Type)) {
 				if (t.IsValueType && expr.Type == d)
 					return CreateConstantResult (ec, true);
 
 				expr = new BoxedCast (expr, d);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2219" endline="2240">
<![CDATA[
 
 		protected override bool AddToContainer (MemberCore symbol, string name)
 		{
 			if (!(symbol is Constructor) && symbol.MemberName.Name == MemberName.Name) {
 				if (symbol is TypeParameter) {
 					Report.Error (694, symbol.Location,
 						"Type parameter `{0}' has same name as containing type, or method",
 						symbol.GetSignatureForError ());
 					return false;
 				}
 			
 				InterfaceMemberBase imb = symbol as InterfaceMemberBase;
 				if (imb == null || !imb.IsExplicitImpl) {
 					Report.SymbolRelatedToPreviousError (this);
 					Report.Error (542, symbol.Location, "`{0}'
 						symbol.GetSignatureForError ());
 					return false;
 				}
 			}
 
 			return base.AddToContainer (symbol, name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="51" endline="76">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return false;
 
 			Report.Debug (64, "RESOLVE YIELD #1", this, ec, expr, expr.GetType (),
 				      ec.CurrentAnonymousMethod, ec.CurrentIterator);
 
 			if (!CheckContext (ec, loc))
 				return false;
 
 			iterator = ec.CurrentIterator;
 			if (expr.Type != iterator.OriginalIteratorType) {
 				expr = Convert.ImplicitConversionRequired (
 					ec, expr, iterator.OriginalIteratorType, loc);
 				if (expr == null)
 					return false;
 			}
 
 			if (!ec.CurrentBranching.CurrentUsageVector.IsUnreachable)
 				unwind_protect = ec.CurrentBranching.AddResumePoint (this, loc, out resume_pc);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7489" endline="7518">
<![CDATA[
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			if (alias == GlobalAlias) {
 				expr = ec.Module.GlobalRootNamespace;
 				return base.ResolveAsTypeStep (ec, silent);
 			}
 
 			int errors = ec.Compiler.Report.Errors;
 			expr = ec.LookupNamespaceAlias (alias);
 			if (expr == null) {
 				if (errors == ec.Compiler.Report.Errors)
 					ec.Compiler.Report.Error (432, loc, "Alias `{0}' not found", alias);
 				return null;
 			}
 
 			FullNamedExpression fne = base.ResolveAsTypeStep (ec, silent);
 			if (fne == null)
 				return null;
 
 			if (expr.eclass == ExprClass.Type) {
 				if (!silent) {
 					ec.Compiler.Report.Error (431, loc,
 						"Alias `{0}' cannot be used with '
 				}
 				return null;
 			}
 
 			return fne;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1267" endline="1302">
<![CDATA[
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!TypeManager.IsDelegateType (MemberType)) {
 				Report.Error (66, Location, "`{0}'
 			}
 
 			if (!CheckBase ())
 				return false;
 
 			//
 			// Now define the accessors
 			//
 			var AddBuilder = Add.Define (Parent);
 			if (AddBuilder == null)
 				return false;
 
 			var RemoveBuilder = remove.Define (Parent);
 			if (RemoveBuilder == null)
 				return false;
 
 			EventBuilder = Parent.TypeBuilder.DefineEvent (GetFullName (MemberName), EventAttributes.None, MemberType.GetMetaInfo ());
 			EventBuilder.SetAddOnMethod (AddBuilder);
 			EventBuilder.SetRemoveOnMethod (RemoveBuilder);
 
 			spec = new EventSpec (Parent.Definition, this, MemberType, ModFlags, Add.Spec, remove.Spec);
 
 			Parent.MemberCache.AddMember (this, Name, spec);
 			Parent.MemberCache.AddMember (this, AddBuilder.Name, Add.Spec);
 			Parent.MemberCache.AddMember (this, RemoveBuilder.Name, remove.Spec);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1262" endline="1274">
<![CDATA[
 		}
 
 		#endregion
 
 		public abstract List<MissingType> ResolveMissingDependencies ();
 
 		public string[] ConditionalConditions ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.Conditionals;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1275" endline="1282">
<![CDATA[
 
 		public ObsoleteAttribute GetAttributeObsolete ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.Obsolete;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1283" endline="1290">
<![CDATA[
 
 		public bool IsNotCLSCompliant ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.IsNotCLSCompliant;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1716" endline="1723">
<![CDATA[
 
 		public TypeSpec GetAttributeCoClass ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.CoClass;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1724" endline="1731">
<![CDATA[
 
 		public string GetAttributeDefaultMember ()
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.DefaultIndexerName;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1732" endline="1739">
<![CDATA[
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			if (cattrs == null)
 				ReadAttributes ();
 
 			return cattrs.AttributeUsage;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6994" endline="7007">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 			type = ec.Module.PredefinedTypes.RuntimeArgumentHandle.Resolve (loc);
 
 			if (ec.HasSet (ResolveContext.Options.FieldInitializerScope) || !ec.CurrentBlock.ParametersBlock.Parameters.HasArglist) {
 				ec.Report.Error (190, loc,
 					"The __arglist construct is valid only within a variable argument method");
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1476" endline="1491">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.IndexerName) {
 				if (IsExplicitImpl) {
 					Report.Error (415, a.Location,
 						"The `{0}' attribute is valid only on an indexer that is not an explicit interface member declaration",
 						TypeManager.CSharpName (a.Type));
 				}
 
 				// Attribute was copied to container
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="573" endline="589">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.DefaultMember) {
 				if (Indexers != null) {
 					Report.Error (646, a.Location, "Cannot specify the `DefaultMember' attribute on type containing an indexer");
 					return;
 				}
 			}
 
 			if (a.Type == pa.Required) {
 				Report.Error (1608, a.Location, "The RequiredAttribute attribute is not permitted on C# types");
 				return;
 			}
 
 			TypeBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		} 
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2260" endline="2280">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (a.Type == pa.StructLayout) {
 				PartialContainer.HasStructLayout = true;
 				if (a.IsExplicitLayoutKind ())
 					PartialContainer.HasExplicitLayout = true;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6215" endline="6222">
<![CDATA[
 
 string ConsumeStoredComment ()
 {
 	string s = tmpComment;
 	tmpComment = null;
 	Lexer.doc_state = XmlCommentState.Allowed;
 	return s;
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="97" endline="104">
<![CDATA[
 
 		public virtual Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (ArgType == AType.Default)
 				ec.Report.Error (854, Expr.Location, "An expression tree cannot contain an invocation which uses optional parameter");
 
 			return Expr.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2499" endline="2510">
<![CDATA[
 
 		public override void Emit ()
 		{
 			base.Emit ();
 
 			if ((ModFlags & Modifiers.METHOD_EXTENSION) != 0)
 				Module.PredefinedAttributes.Extension.EmitAttribute (TypeBuilder);
 
 			if (base_type != null && base_type.HasDynamicElement) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (TypeBuilder, base_type, Location);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7871" endline="7889">
<![CDATA[
 
 		protected virtual void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			var nested = MemberCache.FindNestedType (expr_type, Name, -System.Math.Max (1, Arity));
 
 			if (nested != null) {
 				Error_TypeArgumentsCannotBeUsed (rc.Compiler.Report, expr.Location, nested, Arity);
 				return;
 			}
 
 			var any_other_member = MemberLookup (null, rc.CurrentType, expr_type, Name, 0, MemberLookupRestrictions.None, loc);
 			if (any_other_member != null) {
 				any_other_member.Error_UnexpectedKind (rc.Compiler.Report, null, "type", loc);
 				return;
 			}
 
 			rc.Compiler.Report.Error (426, loc, "The nested type `{0}' does not exist in the type `{1}'",
 				Name, expr_type.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3119" endline="3161">
<![CDATA[
 
 		public override bool Define ()
 		{
 			if (IsInterface) {
 				ModFlags = Modifiers.PUBLIC | Modifiers.ABSTRACT |
 					Modifiers.VIRTUAL | (ModFlags & (Modifiers.UNSAFE | Modifiers.NEW));
 
 				flags = MethodAttributes.Public |
 					MethodAttributes.Abstract |
 					MethodAttributes.HideBySig |
 					MethodAttributes.NewSlot |
 					MethodAttributes.Virtual;
 			} else {
 				Parent.PartialContainer.MethodModifiersValid (this);
 
 				flags = ModifiersExtensions.MethodAttr (ModFlags);
 			}
 
 			if (IsExplicitImpl) {
 				TypeExpr iface_texpr = MemberName.Left.GetTypeExpression ().ResolveAsTypeTerminal (Parent, false);
 				if (iface_texpr == null)
 					return false;
 
 				if ((ModFlags & Modifiers.PARTIAL) != 0) {
 					Report.Error (754, Location, "A partial method `{0}' cannot explicitly implement an interface",
 						GetSignatureForError ());
 				}
 
 				InterfaceType = iface_texpr.Type;
 
 				if (!InterfaceType.IsInterface) {
 					Report.SymbolRelatedToPreviousError (InterfaceType);
 					Report.Error (538, Location, "The type `{0}' in explicit interface declaration is not an interface",
 						TypeManager.CSharpName (InterfaceType));
 				} else {
 					Parent.PartialContainer.VerifyImplements (this);
 				}
 
 				ModifiersExtensions.Check (Modifiers.AllowedExplicitImplFlags, explicit_mod_flags, 0, Location, Report);
 			}
 
 			return base.Define ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="599" endline="641">
<![CDATA[
 
 		protected void DefineBuilders (MemberKind kind, ParametersCompiled parameters)
 		{
 			PropertyBuilder = Parent.TypeBuilder.DefineProperty (
 				GetFullName (MemberName), PropertyAttributes.None,
 #if !BOOTSTRAP_BASIC	// Requires trunk version mscorlib
 				IsStatic ? 0 
 #endif
 				MemberType.GetMetaInfo (), null, null,
 				parameters.GetMetaInfo (), null, null);
 
 			PropertySpec spec;
 			if (kind == MemberKind.Indexer)
 				spec = new IndexerSpec (Parent.Definition, this, MemberType, parameters, PropertyBuilder, ModFlags);
 			else
 				spec = new PropertySpec (kind, Parent.Definition, this, MemberType, PropertyBuilder, ModFlags);
 
 			if (Get != null) {
 				spec.Get = Get.Spec;
 
 				var method = Get.Spec.GetMetaInfo () as MethodBuilder;
 				if (method != null) {
 					PropertyBuilder.SetGetMethod (method);
 					Parent.MemberCache.AddMember (this, method.Name, Get.Spec);
 				}
 			} else {
 				CheckMissingAccessor (kind, parameters, true);
 			}
 
 			if (Set != null) {
 				spec.Set = Set.Spec;
 
 				var method = Set.Spec.GetMetaInfo () as MethodBuilder;
 				if (method != null) {
 					PropertyBuilder.SetSetMethod (method);
 					Parent.MemberCache.AddMember (this, method.Name, Set.Spec);
 				}
 			} else {
 				CheckMissingAccessor (kind, parameters, false);
 			}
 
 			Parent.MemberCache.AddMember (this, PropertyBuilder.Name, spec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="176" endline="217">
<![CDATA[
 
 		protected virtual Expression DoResolveInitializer (ResolveContext rc)
 		{
 			if (in_transit) {
 				field.Compiler.Report.Error (110, expr.Location,
 					"The evaluation of the constant value for `{0}' involves a circular definition",
 					GetSignatureForError ());
 
 				expr = null;
 			} else {
 				in_transit = true;
 				expr = expr.Resolve (rc);
 			}
 
 			in_transit = false;
 
 			if (expr != null) {
 				Constant c = expr as Constant;
 				if (c != null)
 					c = field.ConvertInitializer (rc, c);
 
 				if (c == null) {
 					if (TypeManager.IsReferenceType (field.MemberType))
 						Error_ConstantCanBeInitializedWithNullOnly (rc, field.MemberType, expr.Location, GetSignatureForError ());
 					else if (!(expr is Constant))
 						Error_ExpressionMustBeConstant (rc, expr.Location, GetSignatureForError ());
 					else
 						expr.Error_ValueCannotBeConverted (rc, expr.Location, field.MemberType, false);
 				}
 
 				expr = c;
 			}
 
 			if (expr == null) {
 				expr = New.Constantify (field.MemberType, Location);
 				if (expr == null)
 					expr = Constant.CreateConstantFromValue (field.MemberType, null, Location);
 				expr = expr.Resolve (rc);
 			}
 
 			return expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="523" endline="533">
<![CDATA[
 
 		public override Module ManifestModule
 		{
 			get
 			{
 				if (pseudoManifestModule == null)
 				{
 					pseudoManifestModule = new ManifestModule(this);
 				}
 				return pseudoManifestModule;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1963" endline="1978">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].HashAlgId);
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKey);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].HashAlgId);
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKey);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2044" endline="2059">
<![CDATA[
 
 		internal override void Write(MetadataWriter mw)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKeyOrToken);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				mw.Write(records[i].MajorVersion);
 				mw.Write(records[i].MinorVersion);
 				mw.Write(records[i].BuildNumber);
 				mw.Write(records[i].RevisionNumber);
 				mw.Write(records[i].Flags);
 				mw.WriteBlobIndex(records[i].PublicKeyOrToken);
 				mw.WriteStringIndex(records[i].Name);
 				mw.WriteStringIndex(records[i].Culture);
 				mw.WriteBlobIndex(records[i].HashValue);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="380" endline="414">
<![CDATA[
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!TypeManager.IsPrimitiveType (MemberType)) {
 				Report.Error (1663, Location,
 					"`{0}'
 					GetSignatureForError ());
 			} else if (declarators != null) {
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Fields.IndexOf (this);
 				foreach (var d in declarators) {
 					var f = new FixedField (Parent, t, ModFlags, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					f.initializer = d.Initializer;
 					((ConstInitializer) f.initializer).Name = d.Name.Value;
 					Parent.PartialContainer.Fields.Insert (++index, f);
 				}
 				foreach (var d in declarators) {
 					var f = new FixedField (Parent, t, ModFlags, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					f.initializer = d.Initializer;
 					((ConstInitializer) f.initializer).Name = d.Name.Value;
 					Parent.PartialContainer.Fields.Insert (++index, f);
 				}
 			}
 			
 			// Create nested fixed buffer container
 			string name = String.Format ("<{0}>__FixedBuffer{1}", Name, GlobalCounter++);
 			fixed_buffer_type = Parent.TypeBuilder.DefineNestedType (name, Parent.Module.DefaultCharSetType |
 				TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit, TypeManager.value_type.GetMetaInfo ());
 
 			fixed_buffer_type.DefineField (FixedElementName, MemberType.GetMetaInfo (), FieldAttributes.Public);
 			
 			FieldBuilder = Parent.TypeBuilder.DefineField (Name, fixed_buffer_type, ModifiersExtensions.FieldAttr (ModFlags));
 			var element_spec = new FieldSpec (null, this, MemberType, FieldBuilder, ModFlags);
 			spec = new FixedFieldSpec (Parent.Definition, this, FieldBuilder, element_spec, ModFlags);
 
 			Parent.MemberCache.AddMember (spec);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="205" endline="211">
<![CDATA[
 
 		public ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo)
 		{
 			ModuleBuilder module = new ModuleBuilder(this, name, fileName, emitSymbolInfo);
 			modules.Add(module);
 			return module;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="732" endline="746">
<![CDATA[
 
 		public void EmitHoistingAssignment (EmitContext ec)
 		{
 			//
 			// Remove hoisted redirection to emit assignment from original parameter
 			//
 			HoistedVariable temp = parameter.Parameter.HoistedVariant;
 			parameter.Parameter.HoistedVariant = null;
 
 			Assign a = new HoistedFieldAssign (GetFieldExpression (ec), parameter);
 			if (a.Resolve (new ResolveContext (ec.MemberContext)) != null)
 				a.EmitStatement (ec);
 
 			parameter.Parameter.HoistedVariant = temp;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="427" endline="478">
<![CDATA[
 
 		public void EmitInt (int i)
 		{
 			switch (i) {
 			case -1
 				ig.Emit (OpCodes.Ldc_I4_M1);
 				break;
 
 			case 0
 				ig.Emit (OpCodes.Ldc_I4_0);
 				break;
 
 			case 1
 				ig.Emit (OpCodes.Ldc_I4_1);
 				break;
 
 			case 2
 				ig.Emit (OpCodes.Ldc_I4_2);
 				break;
 
 			case 3
 				ig.Emit (OpCodes.Ldc_I4_3);
 				break;
 
 			case 4
 				ig.Emit (OpCodes.Ldc_I4_4);
 				break;
 
 			case 5
 				ig.Emit (OpCodes.Ldc_I4_5);
 				break;
 
 			case 6
 				ig.Emit (OpCodes.Ldc_I4_6);
 				break;
 
 			case 7
 				ig.Emit (OpCodes.Ldc_I4_7);
 				break;
 
 			case 8
 				ig.Emit (OpCodes.Ldc_I4_8);
 				break;
 
 			default
 				if (i >= -128 && i <= 127) {
 					ig.Emit (OpCodes.Ldc_I4_S, (sbyte) i);
 				} else
 					ig.Emit (OpCodes.Ldc_I4, i);
 				break;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4102" endline="4110">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			var members = CreateConcatMethodCandidates ();
 			var res = new OverloadResolver (members, OverloadResolver.Restrictions.NoBaseMembers, loc);
 			var method = res.ResolveMember<MethodSpec> (new ResolveContext (ec.MemberContext), ref arguments);
 			if (method != null)
 				Invocation.EmitCall (ec, null, method, arguments, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4972" endline="5018">
<![CDATA[
 		
 		override public Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			Expression e = DoResolve (ec, right_side);
 
 			if (e == null)
 				return null;
 
 			spec.MemberDefinition.SetIsAssigned ();
 
 			if ((right_side == EmptyExpression.UnaryAddress || right_side == EmptyExpression.OutAccess.Instance) &&
 					(spec.Modifiers & Modifiers.VOLATILE) != 0) {
 				ec.Report.Warning (420, 1, loc,
 					"`{0}'
 					spec.GetSignatureForError ());
 			}
 
 			if (spec.IsReadOnly) {
 				// InitOnly fields can only be assigned in constructors or initializers
 				if (!ec.HasAny (ResolveContext.Options.FieldInitializerScope | ResolveContext.Options.ConstructorScope))
 					return Report_AssignToReadonly (ec, right_side);
 
 				if (ec.HasSet (ResolveContext.Options.ConstructorScope)) {
 
 					// InitOnly fields cannot be assigned-to in a different constructor from their declaring type
 					if (ec.CurrentMemberDefinition.Parent.Definition != spec.DeclaringType.GetDefinition ())
 						return Report_AssignToReadonly (ec, right_side);
 					// static InitOnly fields cannot be assigned-to in an instance constructor
 					if (IsStatic && !ec.IsStatic)
 						return Report_AssignToReadonly (ec, right_side);
 					// instance constructors can't modify InitOnly fields of other instances of the same type
 					if (!IsStatic && !(InstanceExpression is This))
 						return Report_AssignToReadonly (ec, right_side);
 				}
 			}
 
 			if (right_side == EmptyExpression.OutAccess.Instance &&
 				!IsStatic && !(InstanceExpression is This) && TypeManager.mbr_type != null && TypeSpec.IsBaseClass (spec.DeclaringType, TypeManager.mbr_type, false)) {
 				ec.Report.SymbolRelatedToPreviousError (spec.DeclaringType);
 				ec.Report.Warning (197, 1, loc,
 						"Passing `{0}' as ref or out or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class",
 						GetSignatureForError ());
 			}
 
 			eclass = ExprClass.Variable;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="370" endline="418">
<![CDATA[
 
 		private void WriteSigImpl(ModuleBuilder module, ByteBuffer bb, int parameterCount)
 		{
 			byte first;
 			if ((callingConvention & CallingConventions.Any) == CallingConventions.VarArgs)
 			{
 				Debug.Assert(genericParamCount == 0);
 				first = VARARG;
 			}
 			else if (genericParamCount > 0)
 			{
 				first = GENERIC;
 			}
 			else
 			{
 				first = DEFAULT;
 			}
 			if ((callingConvention & CallingConventions.HasThis) != 0)
 			{
 				first |= HASTHIS;
 			}
 			if ((callingConvention & CallingConventions.ExplicitThis) != 0)
 			{
 				first |= EXPLICITTHIS;
 			}
 			bb.Write(first);
 			if (genericParamCount > 0)
 			{
 				bb.WriteCompressedInt(genericParamCount);
 			}
 			bb.WriteCompressedInt(parameterCount);
 			// RetType
 			if (modifiers != null && modifiers[0] != null)
 			{
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[0][0]);
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[0][1]);
 			}
 			WriteType(module, bb, returnType);
 			// Param
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if (modifiers != null && modifiers[i + 1] != null)
 				{
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[i + 1][0]);
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[i + 1][1]);
 				}
 				WriteType(module, bb, parameterTypes[i]);
 			}
 			for (int i = 0; i < parameterTypes.Length; i++)
 			{
 				if (modifiers != null && modifiers[i + 1] != null)
 				{
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, modifiers[i + 1][0]);
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, modifiers[i + 1][1]);
 				}
 				WriteType(module, bb, parameterTypes[i]);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3134" endline="3201">
<![CDATA[
 
 		/// <summary>
 		///   Find the Applicable Function Members (7.4.2.1)
 		///
 		///   me
 		///       it might contain constructors or methods (or anything
 		///       that maps to a method).
 		///
 		///   Arguments
 		///
 		///   loc
 		///        location for "probing" purposes.
 		///
 		///   Returns
 		///            that is the best match of me on Arguments.
 		///
 		/// </summary>
 		public virtual MethodGroupExpr OverloadResolve (ResolveContext ec, ref Arguments args, OverloadResolver.IErrorHandler cerrors, OverloadResolver.Restrictions restr)
 		{
 			// TODO
 			if (best_candidate != null && best_candidate.Kind == MemberKind.Destructor)
 				return this;
 
 			var r = new OverloadResolver (Methods, type_arguments, restr, loc);
 			if ((restr & OverloadResolver.Restrictions.NoBaseMembers) == 0) {
 				r.BaseMembersProvider = this;
 			}
 
 			if (cerrors != null)
 				r.CustomErrors = cerrors;
 
 			// TODO
 			best_candidate = r.ResolveMember<MethodSpec> (ec, ref args);
 			if (best_candidate == null)
 				return r.BestCandidateIsDynamic ? this 
 
 			// Overload resolver had to create a new method group, all checks bellow have already been executed
 			if (r.BestCandidateNewMethodGroup != null)
 				return r.BestCandidateNewMethodGroup;
 
 			if (best_candidate.Kind == MemberKind.Method && (restr & OverloadResolver.Restrictions.ProbingOnly) == 0) {
 				if (InstanceExpression != null) {
 					if (best_candidate.IsExtensionMethod && args[0].Expr == InstanceExpression) {
 						InstanceExpression = null;
 					} else {
 						if (best_candidate.IsStatic && simple_name != null) {
 							InstanceExpression = ProbeIdenticalTypeName (ec, InstanceExpression, simple_name);
 						}
 
 						InstanceExpression.Resolve (ec);
 					}
 				}
 
 				ResolveInstanceExpression (ec, null);
 				if (InstanceExpression != null)
 					CheckProtectedMemberAccess (ec, best_candidate);
 			}
 
 			var base_override = CandidateToBaseOverride (ec, best_candidate);
 			if (base_override == best_candidate) {
 				best_candidate_return = r.BestCandidateReturnType;
 			} else {
 				best_candidate = base_override;
 				best_candidate_return = best_candidate.ReturnType;
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2511" endline="2563">
<![CDATA[
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			TypeExpr[] ifaces = base.ResolveBaseTypes (out base_class);
 
 			if (base_class == null) {
 				if (spec != TypeManager.object_type)
 					base_type = TypeManager.object_type;
 			} else {
 				if (base_type.IsGenericParameter){
 					Report.Error (689, base_class.Location, "`{0}'
 						GetSignatureForError (), base_type.GetSignatureForError ());
 				} else if (IsGeneric && base_type.IsAttribute) {
 					Report.Error (698, base_class.Location,
 						"A generic type cannot derive from `{0}' because it is an attribute class",
 						base_class.GetSignatureForError ());
 				} else if (base_type.IsStatic) {
 					Report.SymbolRelatedToPreviousError (base_class.Type);
 					Report.Error (709, Location, "`{0}'
 						GetSignatureForError (), base_type.GetSignatureForError ());
 				} else if (base_type.IsSealed) {
 					Report.SymbolRelatedToPreviousError (base_class.Type);
 					Report.Error (509, Location, "`{0}'
 						GetSignatureForError (), base_type.GetSignatureForError ());
 				} else if (PartialContainer.IsStatic && base_class.Type != TypeManager.object_type) {
 					Report.Error (713, Location, "Static class `{0}' cannot derive from type `{1}'. Static classes must derive from object",
 						GetSignatureForError (), base_class.GetSignatureForError ());
 				}
 
 				if (base_type is BuildinTypeSpec && !(spec is BuildinTypeSpec) &&
 					(base_type == TypeManager.enum_type || base_type == TypeManager.value_type || base_type == TypeManager.multicast_delegate_type ||
 					base_type == TypeManager.delegate_type || base_type == TypeManager.array_type)) {
 					Report.Error (644, Location, "`{0}' cannot derive from special class `{1}'",
 						GetSignatureForError (), base_type.GetSignatureForError ());
 
 					base_type = TypeManager.object_type;
 				}
 
 				if (!IsAccessibleAs (base_type)) {
 					Report.SymbolRelatedToPreviousError (base_type);
 					Report.Error (60, Location, "Inconsistent accessibility
 						base_type.GetSignatureForError (), GetSignatureForError ());
 				}
 			}
 
 			if (PartialContainer.IsStatic && ifaces != null) {
 				foreach (TypeExpr t in ifaces)
 					Report.SymbolRelatedToPreviousError (t.Type);
 				foreach (TypeExpr t in ifaces)
 					Report.SymbolRelatedToPreviousError (t.Type);
 				Report.Error (714, Location, "Static class `{0}' cannot implement interfaces", GetSignatureForError ());
 			}
 
 			return ifaces;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5614" endline="5700">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			TypeExpr texpr = RequestedType.ResolveAsTypeTerminal (ec, false);
 			if (texpr == null)
 				return null;
 
 			type = texpr.Type;
 			eclass = ExprClass.Value;
 
 			if (type.IsPointer) {
 				ec.Report.Error (1919, loc, "Unsafe type `{0}' cannot be used in an object creation expression",
 					TypeManager.CSharpName (type));
 				return null;
 			}
 
 			if (arguments == null) {
 				Constant c = Constantify (type, RequestedType.Location);
 				if (c != null)
 					return ReducedExpression.Create (c.Resolve (ec), this);
 			}
 
 			if (TypeManager.IsDelegateType (type)) {
 				return (new NewDelegate (type, arguments, loc)).Resolve (ec);
 			}
 
 			var tparam = type as TypeParameterSpec;
 			if (tparam != null) {
 				//
 				// Check whether the type of type parameter can be constructed. BaseType can be a struct for method overrides
 				// where type parameter constraint is inflated to struct
 				//
 				if ((tparam.SpecialConstraint & (SpecialConstraint.Struct | SpecialConstraint.Constructor)) == 0 && !tparam.BaseType.IsStruct) {
 					ec.Report.Error (304, loc,
 						"Cannot create an instance of the variable type `{0}' because it does not have the new() constraint",
 						TypeManager.CSharpName (type));
 				}
 
 				if ((arguments != null) && (arguments.Count != 0)) {
 					ec.Report.Error (417, loc,
 						"`{0}'
 						TypeManager.CSharpName (type));
 				}
 
 				return this;
 			}
 
 			if (type.IsStatic) {
 				ec.Report.SymbolRelatedToPreviousError (type);
 				ec.Report.Error (712, loc, "Cannot create an instance of the static class `{0}'", TypeManager.CSharpName (type));
 				return null;
 			}
 
 			if (type.IsInterface || type.IsAbstract){
 				if (!TypeManager.IsGenericType (type)) {
 					RequestedType = CheckComImport (ec);
 					if (RequestedType != null)
 						return RequestedType;
 				}
 				
 				ec.Report.SymbolRelatedToPreviousError (type);
 				ec.Report.Error (144, loc, "Cannot create an instance of the abstract class or interface `{0}'", TypeManager.CSharpName (type));
 				return null;
 			}
 
 			//
 			// Any struct always defines parameterless constructor
 			//
 			if (type.IsStruct && arguments == null)
 				return this;
 
 			bool dynamic;
 			if (arguments != null) {
 				arguments.Resolve (ec, out dynamic);
 			} else {
 				dynamic = false;
 			}
 
 			method = ConstructorLookup (ec, type, ref arguments, loc);
 
 			if (dynamic) {
 				arguments.Insert (0, new Argument (new TypeOf (texpr, loc).Resolve (ec), Argument.AType.DynamicTypeName));
 				return new DynamicConstructorBinder (type, arguments, loc).Resolve (ec);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="610" endline="709">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			right = right.Resolve (ec);
 			if (right == null)
 				return null;
 
 			MemberAccess ma = target as MemberAccess;
 			using (ec.Set (ResolveContext.Options.CompoundAssignmentScope)) {
 				target = target.Resolve (ec);
 			}
 			
 			if (target == null)
 				return null;
 
 			if (target is MethodGroupExpr){
 				ec.Report.Error (1656, loc,
 					"Cannot assign to `{0}' because it is a `{1}'",
 					((MethodGroupExpr)target).Name, target.ExprClassName);
 				return null;
 			}
 
 			var event_expr = target as EventExpr;
 			if (event_expr != null) {
 				source = Convert.ImplicitConversionRequired (ec, right, target.Type, loc);
 				if (source == null)
 					return null;
 
 				Expression rside;
 				if (op == Binary.Operator.Addition)
 					rside = EmptyExpression.EventAddition;
 				else if (op == Binary.Operator.Subtraction)
 					rside = EmptyExpression.EventSubtraction;
 				else
 					rside = null;
 
 				target = target.ResolveLValue (ec, rside);
 				if (target == null)
 					return null;
 
 				eclass = ExprClass.Value;
 				type = event_expr.Operator.ReturnType;
 				return this;
 			}
 
 			//
 			// Only now we can decouple the original source/target
 			// into a tree, to guarantee that we do not have side
 			// effects.
 			//
 			if (left == null)
 				left = new TargetExpression (target);
 
 			source = new Binary (op, left, right, true, loc);
 
 			if (target is DynamicMemberAssignable) {
 				Arguments targs = ((DynamicMemberAssignable) target).Arguments;
 				source = source.Resolve (ec);
 
 				Arguments args = new Arguments (targs.Count + 1);
 				args.AddRange (targs);
 				args.Add (new Argument (source));
 
 				var binder_flags = CSharpBinderFlags.ValueFromCompoundAssignment;
 
 				//
 				// Compound assignment does target conversion using additional method
 				// call, set checked context as the binary operation can overflow
 				//
 				if (ec.HasSet (ResolveContext.Options.CheckedScope))
 					binder_flags |= CSharpBinderFlags.CheckedContext;
 
 				if (target is DynamicMemberBinder) {
 					source = new DynamicMemberBinder (ma.Name, binder_flags, args, loc).Resolve (ec);
 
 					// Handles possible event addition/subtraction
 					if (op == Binary.Operator.Addition || op == Binary.Operator.Subtraction) {
 						args = new Arguments (targs.Count + 1);
 						args.AddRange (targs);
 						args.Add (new Argument (right));
 						string method_prefix = op == Binary.Operator.Addition ?
 							Event.AEventAccessor.AddPrefix 
 
 						var invoke = DynamicInvocation.CreateSpecialNameInvoke (
 							new MemberAccess (right, method_prefix + ma.Name, loc), args, loc).Resolve (ec);
 
 						args = new Arguments (targs.Count);
 						args.AddRange (targs);
 						source = new DynamicEventCompoundAssign (ma.Name, args,
 							(ExpressionStatement) source, (ExpressionStatement) invoke, loc).Resolve (ec);
 					}
 				} else {
 					source = new DynamicIndexBinder (binder_flags, args, loc).Resolve (ec);
 				}
 
 				return source;
 			}
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="869" endline="956">
<![CDATA[
 
 		Expression LiftResult (ResolveContext ec, Expression res_expr)
 		{
 			TypeExpr lifted_type;
 
 			//
 			// Avoid double conversion
 			//
 			if (left_unwrap == null || IsLeftNullLifted || left_unwrap.Type != left.Type || (left_unwrap != null && IsRightNullLifted)) {
 				lifted_type = new NullableType (left.Type, loc);
 				lifted_type = lifted_type.ResolveAsTypeTerminal (ec, false);
 				if (lifted_type == null)
 					return null;
 
 				if (left is UserCast || left is TypeCast)
 					left.Type = lifted_type.Type;
 				else
 					left = EmptyCast.Create (left, lifted_type.Type);
 			}
 
 			if (left != right && (right_unwrap == null || IsRightNullLifted || right_unwrap.Type != right.Type || (right_unwrap != null && IsLeftNullLifted))) {
 				lifted_type = new NullableType (right.Type, loc);
 				lifted_type = lifted_type.ResolveAsTypeTerminal (ec, false);
 				if (lifted_type == null)
 					return null;
 
 				var r = right;
 				if (r is ReducedExpression)
 					r = ((ReducedExpression) r).OriginalExpression;
 
 				if (r is UserCast || r is TypeCast)
 					r.Type = lifted_type.Type;
 				else
 					right = EmptyCast.Create (right, lifted_type.Type);
 			}
 
 			if ((Oper & Operator.ComparisonMask) == 0) {
 				lifted_type = new NullableType (res_expr.Type, loc);
 				lifted_type = lifted_type.ResolveAsTypeTerminal (ec, false);
 				if (lifted_type == null)
 					return null;
 
 				wrap_ctor = NullableInfo.GetConstructor (lifted_type.Type);
 				type = res_expr.Type = lifted_type.Type;
 			}
 
 			if (IsLeftNullLifted) {
 				left = LiftedNull.Create (right.Type, left.Location);
 
 				//
 				// Special case for bool?, the result depends on both null right side and left side value
 				//
 				if ((Oper == Operator.BitwiseAnd || Oper == Operator.BitwiseOr) && NullableInfo.GetUnderlyingType (type) == TypeManager.bool_type) {
 					return res_expr;
 				}
 
 				if ((Oper & (Operator.ArithmeticMask | Operator.ShiftMask | Operator.BitwiseMask)) != 0)
 					return LiftedNull.CreateFromExpression (ec, res_expr);
 
 				//
 				// Value types and null comparison
 				//
 				if (right_unwrap == null || (Oper & Operator.RelationalMask) != 0)
 					return CreateNullConstant (ec, right_orig).Resolve (ec);
 			}
 
 			if (IsRightNullLifted) {
 				right = LiftedNull.Create (left.Type, right.Location);
 
 				//
 				// Special case for bool?, the result depends on both null right side and left side value
 				//
 				if ((Oper == Operator.BitwiseAnd || Oper == Operator.BitwiseOr) && NullableInfo.GetUnderlyingType (type) == TypeManager.bool_type) {
 					return res_expr;
 				}
 
 				if ((Oper & (Operator.ArithmeticMask | Operator.ShiftMask | Operator.BitwiseMask)) != 0)
 					return LiftedNull.CreateFromExpression (ec, res_expr);
 
 				//
 				// Value types and null comparison
 				//
 				if (left_unwrap == null || (Oper & Operator.RelationalMask) != 0)
 					return CreateNullConstant (ec, left_orig);
 			}
 
 			return res_expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4403" endline="4452">
<![CDATA[
 
 		void ReportArgumentMismatch (ResolveContext ec, int idx, MemberSpec method,
 													Argument a, AParametersCollection expected_par, TypeSpec paramType)
 		{
 			if (custom_errors != null && custom_errors.ArgumentMismatch (ec, method, a, idx))
 				return;
 
 			if (a is CollectionElementInitializer.ElementInitializerArgument) {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				if ((expected_par.FixedParameters[idx].ModFlags & Parameter.Modifier.ISBYREF) != 0) {
 					ec.Report.Error (1954, loc, "The best overloaded collection initalizer method `{0}' cannot have 'ref', or `out' modifier",
 						TypeManager.CSharpSignature (method));
 					return;
 				}
 				ec.Report.Error (1950, loc, "The best overloaded collection initalizer method `{0}' has some invalid arguments",
 					  TypeManager.CSharpSignature (method));
 			} else if (IsDelegateInvoke) {
 				ec.Report.Error (1594, loc, "Delegate `{0}' has some invalid arguments",
 					DelegateType.GetSignatureForError ());
 			} else {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				ec.Report.Error (1502, loc, "The best overloaded method match for `{0}' has some invalid arguments",
 					method.GetSignatureForError ());
 			}
 
 			Parameter.Modifier mod = idx >= expected_par.Count ? 0 
 
 			string index = (idx + 1).ToString ();
 			if (((mod & (Parameter.Modifier.REF | Parameter.Modifier.OUT)) ^
 				(a.Modifier & (Parameter.Modifier.REF | Parameter.Modifier.OUT))) != 0) {
 				if ((mod & Parameter.Modifier.ISBYREF) == 0)
 					ec.Report.Error (1615, loc, "Argument `#{0}' does not require `{1}' modifier. Consider removing `{1}' modifier",
 						index, Parameter.GetModifierSignature (a.Modifier));
 				else
 					ec.Report.Error (1620, loc, "Argument `#{0}' is missing `{1}' modifier",
 						index, Parameter.GetModifierSignature (mod));
 			} else {
 				string p1 = a.GetSignatureForError ();
 				string p2 = TypeManager.CSharpName (paramType);
 
 				if (p1 == p2) {
 					ec.Report.ExtraInformation (loc, "(equally named types possibly from different assemblies in previous ");
 					ec.Report.SymbolRelatedToPreviousError (a.Expr.Type);
 					ec.Report.SymbolRelatedToPreviousError (paramType);
 				}
 
 				ec.Report.Error (1503, loc,
 					"Argument `#{0}' cannot convert `{1}' expression to type `{2}'", index, p1, p2);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4321" endline="4329">
<![CDATA[
 
 		public override bool Resolve (BlockContext ec)
 		{
 			if (ec.CurrentIterator != null)
 				ec.Report.Error (1629, loc, "Unsafe code may not appear in iterators");
 
 			using (ec.Set (ResolveContext.Options.UnsafeScope))
 				return Block.Resolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4453" endline="4530">
<![CDATA[
 
 		//
 		// We have failed to find exact match so we return error info about the closest match
 		//
 		void ReportOverloadError (ResolveContext rc, MemberSpec best_candidate, IParametersMember pm, Arguments args, bool params_expanded)
 		{
 			int ta_count = type_arguments == null ? 0 
 			int arg_count = args == null ? 0 
 
 			if (ta_count != best_candidate.Arity && (ta_count > 0 || ((IParametersMember) best_candidate).Parameters.IsEmpty)) {
 				var mg = new MethodGroupExpr (new [] { best_candidate }, best_candidate.DeclaringType, loc);
 				mg.Error_TypeArgumentsCannotBeUsed (rc.Report, loc, best_candidate, ta_count);
 				return;
 			}
 
 			if (lambda_conv_msgs != null) {
 				if (lambda_conv_msgs.Merge (rc.Report.Printer))
 					return;
 			}
 
 			//
 			// For candidates which match on parameters count report more details about incorrect arguments
 			//
 			if (pm != null) {
 				int unexpanded_count = ((IParametersMember) best_candidate).Parameters.HasParams ? pm.Parameters.Count - 1 
 				if (pm.Parameters.Count == arg_count || params_expanded || unexpanded_count == arg_count) {
 					// Reject any inaccessible member
 					if (!best_candidate.IsAccessible (rc.CurrentType) || !best_candidate.DeclaringType.IsAccessible (rc.CurrentType)) {
 						rc.Report.SymbolRelatedToPreviousError (best_candidate);
 						Expression.ErrorIsInaccesible (rc, best_candidate.GetSignatureForError (), loc);
 						return;
 					}
 
 					var ms = best_candidate as MethodSpec;
 					if (ms != null && ms.IsGeneric) {
 						bool constr_ok = true;
 						if (ms.TypeArguments != null)
 							constr_ok = new ConstraintChecker (rc.MemberContext).CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc);
 
 						if (ta_count == 0) {
 							if (custom_errors != null && custom_errors.TypeInferenceFailed (rc, best_candidate))
 								return;
 
 							if (constr_ok) {
 								rc.Report.Error (411, loc,
 									"The type arguments for method `{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly",
 									ms.GetGenericMethodDefinition ().GetSignatureForError ());
 							}
 
 							return;
 						}
 					}
 
 					VerifyArguments (rc, ref args, best_candidate, pm, params_expanded);
 					return;
 				}
 			}
 
 			//
 			// We failed to find any method with correct argument count, report best candidate
 			//
 			if (custom_errors != null && custom_errors.NoArgumentMatch (rc, best_candidate))
 				return;
 
 			if (best_candidate.Kind == MemberKind.Constructor) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				Error_ConstructorMismatch (rc, best_candidate.DeclaringType, arg_count, loc);
 			} else if (IsDelegateInvoke) {
 				rc.Report.SymbolRelatedToPreviousError (DelegateType);
 				rc.Report.Error (1593, loc, "Delegate `{0}' does not take `{1}' arguments",
 					DelegateType.GetSignatureForError (), arg_count.ToString ());
 			} else {
 				string name = best_candidate.Kind == MemberKind.Indexer ? "this" 
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.Error (1501, loc, "No overload for method `{0}' takes `{1}' arguments",
 					name, arg_count.ToString ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3640" endline="3800">
<![CDATA[
 
 		/// <remarks>
 		///   EmitBranchable is called from Statement.EmitBoolExpression in the
 		///   context of a conditional bool expression.  This function will return
 		///   false if it is was possible to use EmitBranchable, or true if it was.
 		///
 		///   The expression's code is generated, and we will generate a branch to `target'
 		///   if the resulting expression value is equal to isTrue
 		/// </remarks>
 		public override void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			//
 			// This is more complicated than it looks, but its just to avoid
 			// duplicated tests
 			// but on top of that we want for == and != to use a special path
 			// if we are comparing against null
 			//
 			if ((oper & Operator.EqualityMask) != 0 && (left is Constant || right is Constant)) {
 				bool my_on_true = oper == Operator.Inequality ? on_true 
 				
 				//
 				// put the constant on the rhs, for simplicity
 				//
 				if (left is Constant) {
 					Expression swap = right;
 					right = left;
 					left = swap;
 				}
 				
 				//
 				// brtrue/brfalse works with native int only
 				//
 				if (((Constant) right).IsZeroInteger && right.Type != TypeManager.int64_type && right.Type != TypeManager.uint64_type) {
 					left.EmitBranchable (ec, target, my_on_true);
 					return;
 				}
 				if (right.Type == TypeManager.bool_type) {
 					// right is a boolean, and it's not 'false' => it is 'true'
 					left.EmitBranchable (ec, target, !my_on_true);
 					return;
 				}
 
 			} else if (oper == Operator.LogicalAnd) {
 
 				if (on_true) {
 					Label tests_end = ec.DefineLabel ();
 					
 					left.EmitBranchable (ec, tests_end, false);
 					right.EmitBranchable (ec, target, true);
 					ec.MarkLabel (tests_end);					
 				} else {
 					//
 					// This optimizes code like this 
 					// if (true && i > 4)
 					//
 					if (!(left is Constant))
 						left.EmitBranchable (ec, target, false);
 
 					if (!(right is Constant)) 
 						right.EmitBranchable (ec, target, false);
 				}
 				
 				return;
 				
 			} else if (oper == Operator.LogicalOr){
 				if (on_true) {
 					left.EmitBranchable (ec, target, true);
 					right.EmitBranchable (ec, target, true);
 					
 				} else {
 					Label tests_end = ec.DefineLabel ();
 					left.EmitBranchable (ec, tests_end, true);
 					right.EmitBranchable (ec, target, false);
 					ec.MarkLabel (tests_end);
 				}
 				
 				return;
 
 			} else if ((oper & Operator.ComparisonMask) == 0) {
 				base.EmitBranchable (ec, target, on_true);
 				return;
 			}
 			
 			left.Emit (ec);
 			right.Emit (ec);
 
 			TypeSpec t = left.Type;
 			bool is_float = IsFloat (t);
 			bool is_unsigned = is_float || IsUnsigned (t);
 			
 			switch (oper){
 			case Operator.Equality
 				if (on_true)
 					ec.Emit (OpCodes.Beq, target);
 				else
 					ec.Emit (OpCodes.Bne_Un, target);
 				break;
 
 			case Operator.Inequality
 				if (on_true)
 					ec.Emit (OpCodes.Bne_Un, target);
 				else
 					ec.Emit (OpCodes.Beq, target);
 				break;
 
 			case Operator.LessThan
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Blt_Un, target);
 					else
 						ec.Emit (OpCodes.Blt, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Bge_Un, target);
 					else
 						ec.Emit (OpCodes.Bge, target);
 				break;
 
 			case Operator.GreaterThan
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Bgt_Un, target);
 					else
 						ec.Emit (OpCodes.Bgt, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Ble_Un, target);
 					else
 						ec.Emit (OpCodes.Ble, target);
 				break;
 
 			case Operator.LessThanOrEqual
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Ble_Un, target);
 					else
 						ec.Emit (OpCodes.Ble, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Bgt_Un, target);
 					else
 						ec.Emit (OpCodes.Bgt, target);
 				break;
 
 
 			case Operator.GreaterThanOrEqual
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Bge_Un, target);
 					else
 						ec.Emit (OpCodes.Bge, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Blt_Un, target);
 					else
 						ec.Emit (OpCodes.Blt, target);
 				break;
 			default
 				throw new InternalErrorException (oper.ToString ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="96" endline="105">
<![CDATA[
 
 		public BlockContext (ResolveContext rc, ExplicitBlock block, TypeSpec returnType)
 			
 		{
 			if (rc.IsUnsafe)
 				flags |= ResolveContext.Options.UnsafeScope;
 
 			if (rc.HasSet (ResolveContext.Options.CheckedScope))
 				flags |= ResolveContext.Options.CheckedScope;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="132" endline="138">
<![CDATA[
 
 		public FlowBranchingTryCatch StartFlowBranching (TryCatch stmt)
 		{
 			FlowBranchingTryCatch branching = new FlowBranchingTryCatch (CurrentBranching, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="139" endline="145">
<![CDATA[
 
 		public FlowBranchingException StartFlowBranching (ExceptionStatement stmt)
 		{
 			FlowBranchingException branching = new FlowBranchingException (CurrentBranching, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="146" endline="152">
<![CDATA[
 
 		public FlowBranchingLabeled StartFlowBranching (LabeledStatement stmt)
 		{
 			FlowBranchingLabeled branching = new FlowBranchingLabeled (CurrentBranching, stmt);
 			current_flow_branching = branching;
 			return branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3091" endline="3098">
<![CDATA[
 
 		public SwitchLabel Clone (CloneContext clonectx)
 		{
 			if (label == null)
 				return this;
 
 			return new SwitchLabel (label.Clone (clonectx), loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="187" endline="197">
<![CDATA[
 
 		private Module GetModule(int index)
 		{
 			if (externalModules[index] != null)
 			{
 				return externalModules[index];
 			}
 			// TODO add ModuleResolve event
 			string location = Path.Combine(Path.GetDirectoryName(this.location), manifestModule.GetString(manifestModule.File.records[index].Name));
 			return LoadModule(index, File.ReadAllBytes(location), location);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="52" endline="61">
<![CDATA[
 		}
 
 		internal int Length
 		{
 			get
 			{
 				if (!frozen)
 					throw new InvalidOperationException();
 				return (unalignedlength + 3) & ~3;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="203" endline="210">
<![CDATA[
 
 		public int Peek ()
 		{
 			if ((pos >= char_count) && !ReadBuffer ())
 				return -1;
 
 			return buffer [pos];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="212" endline="218">
<![CDATA[
 
 		public EnumBuilder DefineEnum(string name, TypeAttributes visibility, Type underlyingType)
 		{
 			TypeBuilder tb = DefineType(name, (visibility & TypeAttributes.VisibilityMask) | TypeAttributes.Sealed, universe.System_Enum);
 			FieldBuilder fb = tb.DefineField("value__", underlyingType, FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
 			return new EnumBuilder(tb, fb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="214" endline="232">
<![CDATA[
 
 		public void AddWarningAsError (string warningId)
 		{
 			int id;
 			try {
 				id = int.Parse (warningId);
 			} catch {
 				CheckWarningCode (warningId, Location.Null);
 				return;
 			}
 
 			if (!CheckWarningCode (id, Location.Null))
 				return;
 
 			if (warnings_as_error == null)
 				warnings_as_error = new List<int> ();
 			
 			warnings_as_error.Add (id);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="233" endline="251">
<![CDATA[
 
 		public void RemoveWarningAsError (string warningId)
 		{
 			int id;
 			try {
 				id = int.Parse (warningId);
 			} catch {
 				CheckWarningCode (warningId, Location.Null);
 				return;
 			}
 
 			if (!CheckWarningCode (id, Location.Null))
 				return;
 
 			if (warnings_only == null)
 				warnings_only = new List<int> ();
 
 			warnings_only.Add (id);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3547" endline="3599">
<![CDATA[
 
 		private void CheckUselessComparison (ResolveContext ec, Constant c, TypeSpec type)
 		{
 			if (c == null || !IsTypeIntegral (type)
 				|| c is StringConstant
 				|| c is BoolConstant
 				|| c is FloatConstant
 				|| c is DoubleConstant
 				|| c is DecimalConstant
 				)
 				return;
 
 			long value = 0;
 
 			if (c is ULongConstant) {
 				ulong uvalue = ((ULongConstant) c).Value;
 				if (uvalue > long.MaxValue) {
 					if (type == TypeManager.byte_type ||
 					    type == TypeManager.sbyte_type ||
 					    type == TypeManager.short_type ||
 					    type == TypeManager.ushort_type ||
 					    type == TypeManager.int32_type ||
 					    type == TypeManager.uint32_type ||
 					    type == TypeManager.int64_type ||
 						type == TypeManager.char_type)
 						WarnUselessComparison (ec, type);
 					return;
 				}
 				value = (long) uvalue;
 			}
 			else if (c is ByteConstant)
 				value = ((ByteConstant) c).Value;
 			else if (c is SByteConstant)
 				value = ((SByteConstant) c).Value;
 			else if (c is ShortConstant)
 				value = ((ShortConstant) c).Value;
 			else if (c is UShortConstant)
 				value = ((UShortConstant) c).Value;
 			else if (c is IntConstant)
 				value = ((IntConstant) c).Value;
 			else if (c is UIntConstant)
 				value = ((UIntConstant) c).Value;
 			else if (c is LongConstant)
 				value = ((LongConstant) c).Value;
 			else if (c is CharConstant)
 				value = ((CharConstant)c).Value;
 
 			if (value == 0)
 				return;
 
 			if (IsValueOutOfRange (value, type))
 				WarnUselessComparison (ec, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="566" endline="607">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}					
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1812" endline="1835">
<![CDATA[
 	}
 
 	sealed class ImplMapTable 
 	{
 		internal const int Index = 0x1C;
 
 		internal struct Record
 		{
 			internal short MappingFlags;
 			internal int MemberForwarded;
 			internal int ImportName;
 			internal int ImportScope;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MappingFlags = mr.ReadInt16();
 				records[i].MemberForwarded = mr.ReadMemberForwarded();
 				records[i].ImportName = mr.ReadStringIndex();
 				records[i].ImportScope = mr.ReadModuleRef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MappingFlags = mr.ReadInt16();
 				records[i].MemberForwarded = mr.ReadMemberForwarded();
 				records[i].ImportName = mr.ReadStringIndex();
 				records[i].ImportScope = mr.ReadModuleRef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2174" endline="2197">
<![CDATA[
 	}
 
 	sealed class ManifestResourceTable 
 	{
 		internal const int Index = 0x28;
 
 		internal struct Record
 		{
 			internal int Offset;
 			internal int Flags;
 			internal int Name;
 			internal int Implementation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Offset = mr.ReadInt32();
 				records[i].Flags = mr.ReadInt32();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2268" endline="2293">
<![CDATA[
 	}
 
 	sealed class GenericParamTable 
 	{
 		internal const int Index = 0x2A;
 
 		internal struct Record
 		{
 			internal short Number;
 			internal short Flags;
 			internal int Owner;
 			internal int Name;
 			// not part of the table, we use it to be able to fixup the GenericParamConstraint table
 			internal int unsortedIndex;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Number = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Owner = mr.ReadTypeOrMethodDef();
 				records[i].Name = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Number = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Owner = mr.ReadTypeOrMethodDef();
 				records[i].Name = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1777" endline="1800">
<![CDATA[
 		}
 
 		public override MethodBase[] __GetDeclaredMethods()
 		{
 			Type int32 = this.Module.universe.System_Int32;
 			Type[] setArgs = new Type[rank + 1];
 			Type[] getArgs = new Type[rank];
 			Type[] ctorArgs = new Type[rank * 2];
 			for (int i = 0; i < rank; i++)
 			{
 				setArgs[i] = int32;
 				getArgs[i] = int32;
 				ctorArgs[i * 2 + 0] = int32;
 				ctorArgs[i * 2 + 1] = int32;
 			}
 			for (int i = 0; i < rank; i++)
 			{
 				setArgs[i] = int32;
 				getArgs[i] = int32;
 				ctorArgs[i * 2 + 0] = int32;
 				ctorArgs[i * 2 + 1] = int32;
 			}
 			setArgs[rank] = elementType;
 			return new MethodBase[] {
 				new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, getArgs)),
 				new ConstructorInfoImpl(new BuiltinArrayMethod(this.Module, this, ".ctor", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, ctorArgs)),
 				new BuiltinArrayMethod(this.Module, this, "Set", CallingConventions.Standard | CallingConventions.HasThis, this.Module.universe.System_Void, setArgs),
 				new BuiltinArrayMethod(this.Module, this, "Address", CallingConventions.Standard | CallingConventions.HasThis, elementType.MakeByRefType(), getArgs),
 				new BuiltinArrayMethod(this.Module, this, "Get", CallingConventions.Standard | CallingConventions.HasThis, elementType, getArgs),
 			};
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="281" endline="352">
<![CDATA[
 
 		static public byte[] ToCapiPrivateKeyBlob (RSA rsa) 
 		{
 			RSAParameters p = rsa.ExportParameters (true);
 			int keyLength = p.Modulus.Length; // in bytes
 			byte[] blob = new byte [20 + (keyLength << 2) + (keyLength >> 1)];
 
 			blob [0] = 0x07;	// Type - PRIVATEKEYBLOB (0x07)
 			blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
 			// [2], [3]		// RESERVED - Always 0
 			blob [5] = 0x24;	// ALGID - Always 00 24 00 00 (for CALG_RSA_SIGN)
 			blob [8] = 0x52;	// Magic - RSA2 (ASCII in hex)
 			blob [9] = 0x53;
 			blob [10] = 0x41;
 			blob [11] = 0x32;
 
 			byte[] bitlen = GetBytesLE (keyLength << 3);
 			blob [12] = bitlen [0];	// bitlen
 			blob [13] = bitlen [1];	
 			blob [14] = bitlen [2];	
 			blob [15] = bitlen [3];
 
 			// public exponent (DWORD)
 			int pos = 16;
 			int n = p.Exponent.Length;
 			while (n > 0)
 				blob [pos++] = p.Exponent [--n];
 			while (n > 0)
 				blob [pos++] = p.Exponent [--n];
 			// modulus
 			pos = 20;
 			byte[] part = p.Modulus;
 			int len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 			// private key
 			part = p.P;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.Q;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.DP;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.DQ;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.InverseQ;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 
 			part = p.D;
 			len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 
 			return blob;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1549" endline="1600">
<![CDATA[
 
 		//
 		// Accepts exactly count (4 or 8) hex, no more no less
 		//
 		int getHex (int count, out int surrogate, out bool error)
 		{
 			int i;
 			int total = 0;
 			int c;
 			int top = count != -1 ? count 
 			
 			get_char ();
 			error = false;
 			surrogate = 0;
 			for (i = 0; i < top; i++){
 				c = get_char ();
 
 				if (c >= '0' && c <= '9')
 					c = (int) c - (int) '0';
 				else if (c >= 'A' && c <= 'F')
 					c = (int) c - (int) 'A' + 10;
 				else if (c >= 'a' && c <= 'f')
 					c = (int) c - (int) 'a' + 10;
 				else {
 					error = true;
 					return 0;
 				}
 				
 				total = (total * 16) + c;
 				if (count == -1){
 					int p = peek_char ();
 					if (p == -1)
 						break;
 					if (!is_hex ((char)p))
 						break;
 				}
 			}
 			for (i = 0; i < top; i++){
 				c = get_char ();
 
 				if (c >= '0' && c <= '9')
 					c = (int) c - (int) '0';
 				else if (c >= 'A' && c <= 'F')
 					c = (int) c - (int) 'A' + 10;
 				else if (c >= 'a' && c <= 'f')
 					c = (int) c - (int) 'a' + 10;
 				else {
 					error = true;
 					return 0;
 				}
 				
 				total = (total * 16) + c;
 				if (count == -1){
 					int p = peek_char ();
 					if (p == -1)
 						break;
 					if (!is_hex ((char)p))
 						break;
 				}
 			}
 
 			if (top == 8) {
 				if (total > 0x0010FFFF) {
 					error = true;
 					return 0;
 				}
 
 				if (total >= 0x00010000) {
 					surrogate = ((total - 0x00010000) % 0x0400 + 0xDC00);					
 					total = ((total - 0x00010000) / 0x0400 + 0xD800);
 				}
 			}
 
 			return total;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3030" endline="3038">
<![CDATA[
 		}
 
 		public override bool IsInstance {
 			get {
 				if (best_candidate != null)
 					return !best_candidate.IsStatic;
 
 				return false;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="200" endline="208">
<![CDATA[
 
 		public void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			IMemoryLocation ml = expr as VariableReference;
 			if (ml != null)
 				ml.AddressOf (ec, mode);
 			else
 				LocalVariable.AddressOf (ec, mode);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5873" endline="5882">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			New target = (New) t;
 
 			target.RequestedType = RequestedType.Clone (clonectx);
 			if (arguments != null){
 				target.arguments = arguments.Clone (clonectx);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2895" endline="2913">
<![CDATA[
 		}
 
 		// <summary>
 		//   This is used by non-static `struct' constructors which do not have an
 		//   initializer - in this case, the constructor must initialize all of the
 		//   struct's fields.  To do this, we add a "this" variable and use the flow
 		//   analysis code to ensure that it's been fully initialized before control
 		//   leaves the constructor.
 		// </summary>
 		public LocalVariable AddThisVariable (BlockContext bc, TypeContainer ds, Location l)
 		{
 			if (this_variable == null) {
 				this_variable = new LocalVariable (this, "this", LocalVariable.Flags.IsThis | LocalVariable.Flags.Used, l);
 				this_variable.Type = ds.CurrentType;
 				this_variable.PrepareForFlowAnalysis (bc);
 			}
 
 			return this_variable;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1227" endline="1246">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			unwrap = Unwrap.Create (expr, false);
 			if (unwrap == null)
 				return null;
 
 			underlying = (UnaryMutator) new UnaryMutator (Mode, unwrap, loc).Resolve (ec);
 			if (underlying == null)
 				return null;
 
 
 			eclass = ExprClass.Value;
 			type = expr.Type;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="625" endline="671">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if ((Oper & Operator.LogicalMask) != 0) {
 				Error_OperatorCannotBeApplied (ec, left, right);
 				return null;
 			}
 
 			bool use_default_call = (Oper & (Operator.BitwiseMask | Operator.EqualityMask)) != 0;
 			left_orig = left;
 			if (TypeManager.IsNullableType (left.Type)) {
 				left = left_unwrap = Unwrap.Create (left, use_default_call);
 				if (left == null)
 					return null;
 			}
 
 			right_orig = right;
 			if (TypeManager.IsNullableType (right.Type)) {
 				right = right_unwrap = Unwrap.Create (right, use_default_call);
 				if (right == null)
 					return null;
 			}
 
 			//
 			// Some details are in 6.4.2, 7.2.7
 			// Arguments can be lifted for equal operators when the return type is bool and both
 			// arguments are of same type
 			//	
 			if (left_orig is NullLiteral) {
 				left = right;
 				state |= State.LeftNullLifted;
 				type = TypeManager.bool_type;
 			}
 
 			if (right_orig.IsNull) {
 				if ((Oper & Operator.ShiftMask) != 0)
 					right = new EmptyExpression (TypeManager.int32_type);
 				else
 					right = left;
 
 				state |= State.RightNullLifted;
 				type = TypeManager.bool_type;
 			}
 
 			eclass = ExprClass.Value;
 			return DoResolveCore (ec, left_orig, right_orig);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5871" endline="5887">
<![CDATA[
 
 		public bool InferType (ResolveContext ec, Expression right_side)
 		{
 			if (type != null)
 				throw new InternalErrorException ("An implicitly typed local variable could not be redefined");
 			
 			type = right_side.Type;
 			if (type == InternalType.Null || type == TypeManager.void_type || type == InternalType.AnonymousMethod || type == InternalType.MethodGroup) {
 				ec.Report.Error (815, loc,
 					"An implicitly typed local variable declaration cannot be initialized with `{0}'",
 					type.GetSignatureForError ());
 				return false;
 			}
 
 			eclass = ExprClass.Variable;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1676" endline="1689">
<![CDATA[
 
 		public static MyBitVector operator | (MyBitVector a, MyBitVector b)
 		{
 			if (a == b)
 				return a;
 			if (a == null)
 				return new MyBitVector (null, b.Count);
 			if (b == null)
 				return new MyBitVector (null, a.Count);
 			if (a.Count > b.Count)
 				return a.Clone ().Or (b);
 			else
 				return b.Clone ().Or (a);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5694" endline="5704">
<![CDATA[
 		}
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			if (leave_copy || !prepare_for_load)
 				throw new NotImplementedException ("EventExpr
 
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (source));
 			Invocation.EmitCall (ec, InstanceExpression, op, args, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="217" endline="228">
<![CDATA[
 
 		/// <summary>
 		/// Need to pass type as the constant can require a boxing
 		/// and in such case no optimization is possible
 		/// </summary>
 		public bool IsDefaultInitializer (TypeSpec type)
 		{
 			if (type == Type)
 				return IsDefaultValue;
 
 			return this is NullLiteral;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="698" endline="709">
<![CDATA[
 		}
 
 		//
 		// Unexpanded interfaces list
 		//
 		public TypeSpec[] InterfacesDefined {
 			get {
 				if (ifaces_defined == null && ifaces != null)
 					ifaces_defined = ifaces.ToArray ();
 
 				return ifaces_defined;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="220" endline="228">
<![CDATA[
 		}
 
 		public TypeParameterSpec[] Constraints {
 			get {
 				if (constraints == null && IsGeneric)
 					constraints = GenericDefinition.TypeParameters;
 
 				return constraints;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4008" endline="4018">
<![CDATA[
 
 		public static StringConcat Create (ResolveContext rc, Expression left, Expression right, Location loc)
 		{
 			if (left.eclass == ExprClass.Unresolved || right.eclass == ExprClass.Unresolved)
 				throw new ArgumentException ();
 
 			var s = new StringConcat (left, right, loc);
 			s.Append (rc, left);
 			s.Append (rc, right);
 			return s;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="216" endline="224">
<![CDATA[
 
 		internal void Align(int alignment)
 		{
 			if (pos + alignment > buffer.Length)
 				Grow(alignment);
 			int newpos = (pos + alignment - 1) & ~(alignment - 1);
 			while (pos < newpos)
 				buffer[pos++] = 0;
 			while (pos < newpos)
 				buffer[pos++] = 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="400" endline="430">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			//
 			// It's null when lifting non-nullable type
 			//
 			if (unwrap == null) {
 				// S -> T? is wrap only
 				if (TypeManager.IsNullableType (type))
 					return Wrap.Create (expr, type);
 
 				// S -> T can be simplified
 				return expr;
 			}
 
 			// Wrap target for T?
 			if (TypeManager.IsNullableType (type)) {
 				expr = Wrap.Create (expr, type);
 				if (expr == null)
 					return null;
 
 				null_value = LiftedNull.Create (type, loc);
 			} else if (TypeManager.IsValueType (type)) {
 				null_value = LiftedNull.Create (type, loc);
 			} else {
 				null_value = new NullConstant (type, loc);
 			}
 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="141" endline="147">
<![CDATA[
 
 		public SourceFileEntry DefineDocument (string url, byte[] guid, byte[] checksum)
 		{
 			SourceFileEntry entry = new SourceFileEntry (file, url, guid, checksum);
 			sources.Add (entry);
 			return entry;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="439" endline="478">
<![CDATA[
 
 		private sealed class TrackingGenericContext 
 		{
 			private readonly IGenericContext context;
 			private bool used;
 
 			internal TrackingGenericContext(IGenericContext context)
 			{
 				this.context = context;
 			}
 
 			internal bool IsUsed
 			{
 				get { return used; }
 			}
 
 			public Type GetGenericTypeArgument(int index)
 			{
 				used = true;
 				return context.GetGenericTypeArgument(index);
 			}
 
 			public Type GetGenericMethodArgument(int index)
 			{
 				used = true;
 				return context.GetGenericMethodArgument(index);
 			}
 		}
 
 		public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 		{
 			if ((metadataToken >> 24) == TypeSpecTable.Index)
 			{
 				return ResolveType(metadataToken, new GenericContext(genericTypeArguments, genericMethodArguments));
 			}
 			else
 			{
 				return ResolveType(metadataToken, null);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="491" endline="503">
<![CDATA[
 
 		private Assembly ResolveAssemblyRef(int index)
 		{
 			if (assemblyRefs == null)
 			{
 				assemblyRefs = new Assembly[AssemblyRef.RowCount];
 			}
 			if (assemblyRefs[index] == null)
 			{
 				assemblyRefs[index] = ResolveAssemblyRefImpl(ref AssemblyRef.records[index]);
 			}
 			return assemblyRefs[index];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="784" endline="801">
<![CDATA[
 		}
 
 		#endregion
 
 		public void ChangeTypeArgumentToBaseType (int index)
 		{
 			BaseType = targs [index];
 			if (targs.Length == 1) {
 				targs = null;
 			} else {
 				var copy = new TypeSpec[targs.Length - 1];
 				if (index > 0)
 					Array.Copy (targs, copy, index);
 
 				Array.Copy (targs, index + 1, copy, index, targs.Length - index - 1);
 				targs = copy;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="255" endline="261">
<![CDATA[
 		}
 
 		internal override MethodBase BindTypeParameters(Type type)
 		{
 			System.Diagnostics.Debug.Assert(methodArgs == null);
 			return new GenericMethodInstance(declaringType.BindTypeParameters(type), method, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="843" endline="850">
<![CDATA[
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (label == null)
 				throw new InternalErrorException ("goto emitted before target resolved");
 			Label l = label.LabelTarget (ec);
 			ec.Emit (unwind_protect ? OpCodes.Leave 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5107" endline="5120">
<![CDATA[
 
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Expression instance = mg.IsInstance ?
 				mg.InstanceExpression.CreateExpressionTree (ec) 
 				new NullLiteral (loc);
 
 			var args = Arguments.CreateForExpressionTree (ec, arguments,
 				instance,
 				mg.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="288" endline="320">
<![CDATA[
 
 		public override void EmitType ()
 		{
 			if (ReturnType.Type != null) {
 				if (ReturnType.Type == InternalType.Dynamic) {
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 					Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 				} else if (ReturnType.Type.HasDynamicElement) {
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 					Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType.Type, Location);
 				}
 			}
 
 			Constructor.ParameterInfo.ApplyAttributes (this, Constructor.ConstructorBuilder);
 			Constructor.ConstructorBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 
 			parameters.ApplyAttributes (this, InvokeBuilder.MethodBuilder);
 			InvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 
 			if (BeginInvokeBuilder != null) {
 				BeginInvokeBuilder.ParameterInfo.ApplyAttributes (this, BeginInvokeBuilder.MethodBuilder);
 				EndInvokeBuilder.ParameterInfo.ApplyAttributes (this, EndInvokeBuilder.MethodBuilder);
 
 				BeginInvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 				EndInvokeBuilder.MethodBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
 			}
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="504" endline="518">
<![CDATA[
 
 		private Assembly ResolveAssemblyRefImpl(ref AssemblyRefTable.Record rec)
 		{
 			const int PublicKey = 0x0001;
 			string name = String.Format("{0}, Version={1}.{2}.{3}.{4}, Culture={5}, {6}={7}",
 				GetString(rec.Name),
 				rec.MajorVersion,
 				rec.MinorVersion,
 				rec.BuildNumber,
 				rec.RevisionNumber,
 				rec.Culture == 0 ? "neutral" 
 				(rec.Flags & PublicKey) == 0 ? "PublicKeyToken" 
 				PublicKeyOrTokenToString(rec.PublicKeyOrToken));
 			return universe.Load(name, this.Assembly, true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9115" endline="9129">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			int size = GetTypeSize (otype);
 
 			count.Emit (ec);
 
 			if (size == 0)
 				ec.Emit (OpCodes.Sizeof, otype);
 			else
 				ec.EmitInt (size);
 
 			ec.Emit (OpCodes.Mul_Ovf_Un);
 			ec.Emit (OpCodes.Localloc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="36" endline="57">
<![CDATA[
 		{
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					builder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if (a.HasSecurityAttribute) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="466" endline="483">
<![CDATA[
 		}
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.HasSecurityAttribute) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			PropertyBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="243" endline="258">
<![CDATA[
 
 		//
 		// Creates a link between hoisted variable block and the anonymous method storey
 		//
 		// An anonymous method can reference variables from any outer block, but they are
 		// hoisted in their own ExplicitBlock. When more than one block is referenced we
 		// need to create another link between those variable storeys
 		//
 		public void AddReferenceFromChildrenBlock (ExplicitBlock block)
 		{
 			if (children_references == null)
 				children_references = new List<ExplicitBlock> ();
 
 			if (!children_references.Contains (block))
 				children_references.Add (block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="344" endline="352">
<![CDATA[
 		}
 
 		public void AddLocal (int index, string name)
 		{
 			if (_locals == null)
 				_locals = new List<LocalVariableEntry> ();
 			int block_idx = CurrentBlock != null ? CurrentBlock.Index 
 			_locals.Add (new LocalVariableEntry (index, name, block_idx));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="612" endline="623">
<![CDATA[
 
 		public override bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			if (goto_stmt.Target != stmt.Name)
 				return Parent.AddGotoOrigin (vector, goto_stmt);
 
 			// backward jump
 			goto_stmt.SetResolvedTarget (stmt);
 			actual.MergeOrigins (vector.Clone ());
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="659" endline="669">
<![CDATA[
 
 		internal override MethodSignature MethodSignature
 		{
 			get
 			{
 				if (methodSignature == null)
 				{
 					methodSignature = MethodSignature.MakeFromBuilder(returnType, parameterTypes, modifiers, callingConvention, gtpb == null ? 0 
 				}
 				return methodSignature;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="89" endline="102">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant) {
 				method.Compiler.Report.Warning (3023, 1, a.Location,
 					"CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead");
 			}
 
 			// This occurs after Warning -28
 			if (builder == null)
 				return;
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="245" endline="268">
<![CDATA[
 
 		private void Write(ByteBuffer bb, int writeDepth, int currentDepth, ref int offset, Dictionary<string, int> strings, ref int stringTableOffset, ByteBuffer stringTable)
 		{
 			if (currentDepth == writeDepth)
 			{
 				// directory header
 				bb.Write(0);	// Characteristics
 				bb.Write(0);	// Time/Date Stamp
 				bb.Write(0);	// Version (Major / Minor)
 				bb.Write((ushort)namedEntries);
 				bb.Write((ushort)(entries.Count - namedEntries));
 			}
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (currentDepth == writeDepth)
 				{
 					entry.WriteEntry(bb, ref offset, strings, ref stringTableOffset, stringTable);
 				}
 				else
 				{
 					entry.Write(bb, writeDepth, currentDepth + 1, ref offset, strings, ref stringTableOffset, stringTable);
 				}
 			}
 			foreach (ResourceDirectoryEntry entry in entries)
 			{
 				if (currentDepth == writeDepth)
 				{
 					entry.WriteEntry(bb, ref offset, strings, ref stringTableOffset, stringTable);
 				}
 				else
 				{
 					entry.Write(bb, writeDepth, currentDepth + 1, ref offset, strings, ref stringTableOffset, stringTable);
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="114" endline="156">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.FieldOffset) {
 				status |= Status.HAS_OFFSET;
 
 				if (!Parent.PartialContainer.HasExplicitLayout) {
 					Report.Error (636, Location, "The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)");
 					return;
 				}
 
 				if ((ModFlags & Modifiers.STATIC) != 0 || this is Const) {
 					Report.Error (637, Location, "The FieldOffset attribute is not allowed on static or const fields");
 					return;
 				}
 			}
 
 			if (a.Type == pa.FixedBuffer) {
 				Report.Error (1716, Location, "Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead");
 				return;
 			}
 
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					FieldBuilder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			FieldBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="477" endline="507">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			if (a.Type == pa.DllImport) {
 				const Modifiers extern_static = Modifiers.EXTERN | Modifiers.STATIC;
 				if ((ModFlags & extern_static) != extern_static) {
 					Report.Error (601, a.Location, "The DllImport attribute must be specified on a method marked `static' and `extern'");
 				}
 				is_external_implementation = true;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (MethodBuilder != null)
 				MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3023" endline="3032">
<![CDATA[
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3033" endline="3041">
<![CDATA[
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3897" endline="3912">
<![CDATA[
 	}
 
 	// A place where execution can restart in an iterator
 	public abstract class ResumableStatement 
 	{
 		bool prepared;
 		protected Label resume_point;
 
 		public Label PrepareForEmit (EmitContext ec)
 		{
 			if (!prepared) {
 				prepared = true;
 				resume_point = ec.DefineLabel ();
 			}
 			return resume_point;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4025" endline="4033">
<![CDATA[
 
 		public override Label PrepareForDispose (EmitContext ec, Label end)
 		{
 			if (!prepared_for_dispose) {
 				prepared_for_dispose = true;
 				dispose_try_block = ec.DefineLabel ();
 			}
 			return dispose_try_block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1728" endline="1741">
<![CDATA[
 
 		void initialize_vector ()
 		{
 			// Post-condition
 			if (shared == null) {
 				vector = new System.Collections.BitArray (Count, true);
 				return;
 			}
 
 			vector = new System.Collections.BitArray (shared);
 			if (Count != vector.Count)
 				vector.Length = Count;
 			shared = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="472" endline="483">
<![CDATA[
 		}
 
 		internal override IList<CustomAttributeData> GetCustomAttributesData(Type attributeType)
 		{
 			IList<CustomAttributeData> list = base.GetCustomAttributesData(attributeType);
 			if ((this.Attributes & ParameterAttributes.HasFieldMarshal) != 0
 				&& (attributeType == null || attributeType.IsAssignableFrom(this.Module.universe.System_Runtime_InteropServices_MarshalAsAttribute)))
 			{
 				list.Add(MarshalSpec.GetMarshalAsAttribute(this.Module, this.MetadataToken));
 			}
 			return list;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="524" endline="571">
<![CDATA[
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!CheckBase ())
 				return false;
 
 			MemberKind kind;
 			if (this is Operator)
 				kind = MemberKind.Operator;
 			else if (this is Destructor)
 				kind = MemberKind.Destructor;
 			else
 				kind = MemberKind.Method;
 
 			if (IsPartialDefinition) {
 				caching_flags &= ~Flags.Excluded_Undetected;
 				caching_flags |= Flags.Excluded;
 
 				// Add to member cache only when a partial method implementation has not been found yet
 				if ((caching_flags & Flags.PartialDefinitionExists) == 0) {
 //					MethodBase mb = new PartialMethodDefinitionInfo (this);
 
 					spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, null, parameters, ModFlags);
 					Parent.MemberCache.AddMember (spec);
 				}
 
 				return true;
 			}
 
 			MethodData = new MethodData (
 				this, ModFlags, flags, this, MethodBuilder, GenericMethod, base_method);
 
 			if (!MethodData.Define (Parent.PartialContainer, GetFullName (MemberName), Report))
 				return false;
 					
 			MethodBuilder = MethodData.MethodBuilder;
 
 			spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, MethodBuilder, parameters, ModFlags);
 			if (MemberName.Arity > 0)
 				spec.IsGeneric = true;
 			
 			Parent.MemberCache.AddMember (this, MethodBuilder.Name, spec);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="961" endline="969">
<![CDATA[
 
 		private int WriteTinyHeaderAndCode(ByteBuffer bb)
 		{
 			int rva = bb.Position;
 			const byte CorILMethod_TinyFormat = 0x2;
 			bb.Write((byte)(CorILMethod_TinyFormat | (code.Length << 2)));
 			WriteCode(bb);
 			return rva;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="450" endline="463">
<![CDATA[
 
 		protected override void CreateArguments (ResolveContext ec, Parameter parameter, ref Arguments args)
 		{
 			base.CreateArguments (ec, parameter, ref args);
 
 			if (element_selector != null) {
 				LambdaExpression lambda = new LambdaExpression (element_selector.Location);
 
 				element_block.SetParameter (parameter.Clone ());
 				lambda.Block = element_block;
 				lambda.Block.AddStatement (new ContextualReturn (element_selector));
 				args.Add (new Argument (lambda));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="531" endline="581">
<![CDATA[
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (InitStatement != null)
 				InitStatement.Emit (ec);
 
 			if (empty) {
 				Test.EmitSideEffect (ec);
 				return;
 			}
 
 			Label old_begin = ec.LoopBegin;
 			Label old_end = ec.LoopEnd;
 			Label loop = ec.DefineLabel ();
 			Label test = ec.DefineLabel ();
 
 			ec.LoopBegin = ec.DefineLabel ();
 			ec.LoopEnd = ec.DefineLabel ();
 
 			ec.Emit (OpCodes.Br, test);
 			ec.MarkLabel (loop);
 			Statement.Emit (ec);
 
 			ec.MarkLabel (ec.LoopBegin);
 			Increment.Emit (ec);
 
 			ec.MarkLabel (test);
 			//
 			// If test is null, there is no test, and we are just
 			// an infinite loop
 			//
 			if (Test != null){
 				//
 				// The Resolve code already catches the case for
 				// Test == Constant (false) so we know that
 				// this is true
 				//
 				if (Test is Constant) {
 					Test.EmitSideEffect (ec);
 					ec.Emit (OpCodes.Br, loop);
 				} else {
 					Test.EmitBranchable (ec, loop, true);
 				}
 				
 			} else
 				ec.Emit (OpCodes.Br, loop);
 			ec.MarkLabel (ec.LoopEnd);
 
 			ec.LoopBegin = old_begin;
 			ec.LoopEnd = old_end;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3192" endline="3322">
<![CDATA[
 
 		//
 		// 7.9.6 Reference type equality operators
 		//
 		Expression ResolveOperatorEquality (ResolveContext ec, TypeSpec l, TypeSpec r)
 		{
 			Expression result;
 			type = TypeManager.bool_type;
 
 			//
 			// a, Both operands are reference-type values or the value null
 			// b, One operand is a value of type T where T is a type-parameter and
 			// the other operand is the value null. Furthermore T does not have the
 			// value type constraint
 			//
 			// LAMESPEC
 			// reference like type-parameter is allowed
 			//
 			var tparam_l = l as TypeParameterSpec;
 			var tparam_r = r as TypeParameterSpec;
 			if (tparam_l != null) {
 				if (right is NullLiteral && !tparam_l.HasSpecialStruct) {
 					left = new BoxedCast (left, TypeManager.object_type);
 					return this;
 				}
 
 				if (!tparam_l.IsReferenceType)
 					return null;
 
 				l = tparam_l.GetEffectiveBase ();
 				left = new BoxedCast (left, l);
 			} else if (left is NullLiteral && tparam_r == null) {
 				if (!TypeManager.IsReferenceType (r) || r.Kind == MemberKind.InternalCompilerType)
 					return null;
 
 				return this;
 			}
 
 			if (tparam_r != null) {
 				if (left is NullLiteral && !tparam_r.HasSpecialStruct) {
 					right = new BoxedCast (right, TypeManager.object_type);
 					return this;
 				}
 
 				if (!tparam_r.IsReferenceType)
 					return null;
 
 				r = tparam_r.GetEffectiveBase ();
 				right = new BoxedCast (right, r);
 			} else if (right is NullLiteral) {
 				if (!TypeManager.IsReferenceType (l) || l.Kind == MemberKind.InternalCompilerType)
 					return null;
 
 				return this;
 			}
 
 			//
 			// LAMESPEC
 			//
 			if (l.IsDelegate) {
 				if (right.eclass == ExprClass.MethodGroup) {
 					result = Convert.ImplicitConversion (ec, right, l, loc);
 					if (result == null)
 						return null;
 
 					right = result;
 					r = l;
 				} else if (r.IsDelegate && l != r) {
 					return null;
 				}
 			} else if (left.eclass == ExprClass.MethodGroup && r.IsDelegate) {
 				result = Convert.ImplicitConversionRequired (ec, left, r, loc);
 				if (result == null)
 					return null;
 
 				left = result;
 				l = r;
 			}
 
 			//
 			// bool operator != (string a, string b)
 			// bool operator == (string a, string b)
 			//
 			// bool operator != (Delegate a, Delegate b)
 			// bool operator == (Delegate a, Delegate b)
 			//
 			// bool operator != (bool a, bool b)
 			// bool operator == (bool a, bool b)
 			//
 			// LAMESPEC
 			// they implement an implicit conversion to any of types above.
 			//
 			if (r != TypeManager.object_type && l != TypeManager.object_type) {
 				result = ResolveOperatorPredefined (ec, equality_operators, false, null);
 				if (result != null)
 					return result;
 			}
 
 			//
 			// bool operator != (object a, object b)
 			// bool operator == (object a, object b)
 			//
 			// An explicit reference conversion exists from the
 			// type of either operand to the type of the other operand.
 			//
 
 			// Optimize common path
 			if (l == r) {
 				return l.Kind == MemberKind.InternalCompilerType || l.Kind == MemberKind.Struct ? null 
 			}
 
 			if (!Convert.ExplicitReferenceConversionExists (l, r) &&
 				!Convert.ExplicitReferenceConversionExists (r, l))
 				return null;
 
 			// Reject allowed explicit conversions like int->object
 			if (!TypeManager.IsReferenceType (l) || !TypeManager.IsReferenceType (r))
 				return null;
 
 			if (l == TypeManager.string_type || l == TypeManager.delegate_type || MemberCache.GetUserOperator (l, CSharp.Operator.OpType.Equality, false) != null)
 				ec.Report.Warning (253, 2, loc,
 					"Possible unintended reference comparison. Consider casting the right side expression to type `{0}' to get value comparison",
 					l.GetSignatureForError ());
 
 			if (r == TypeManager.string_type || r == TypeManager.delegate_type || MemberCache.GetUserOperator (r, CSharp.Operator.OpType.Equality, false) != null)
 				ec.Report.Warning (252, 2, loc,
 					"Possible unintended reference comparison. Consider casting the left side expression to type `{0}' to get value comparison",
 					r.GetSignatureForError ());
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="209" endline="218">
<![CDATA[
 
 		//
 		// Keeps result of non-variable expression
 		//
 		LocalTemporary LocalVariable {
 			get {
 				if (temp == null)
 					temp = new LocalTemporary (expr.Type);
 				return temp;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="48" endline="59">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (expr_tree != null)
 				return expr_tree (ec, new TypeOfMethod (oper, loc));
 
 			Arguments args = Arguments.CreateForExpressionTree (ec, arguments,
 				new NullLiteral (loc),
 				new TypeOfMethod (oper, loc));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="538" endline="551">
<![CDATA[
 
 		/// <summary>
 		/// Indexer has special handling in constrast to other AddXXX because the name can be driven by IndexerNameAttribute
 		/// </summary>
 		public void AddIndexer (Indexer i)
 		{
 			if (indexers == null)
 				indexers = new List<MemberCore> ();
 
 			if (i.IsExplicitImpl)
 				AddMemberToList (i, indexers, true);
 			else 
 				AddMemberToList (i, indexers, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="525" endline="536">
<![CDATA[
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			flags |= ec.HasSet (ResolveContext.Options.CheckedScope) ? CSharpBinderFlags.CheckedContext 
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			return new Invocation (GetBinder ("Convert", loc), binder_args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="741" endline="771">
<![CDATA[
 
 		private MemberInfo GetMemberRef(int index, Type[] genericTypeArguments, Type[] genericMethodArguments)
 		{
 			if (memberRefs == null)
 			{
 				memberRefs = new MemberInfo[MemberRef.records.Length];
 			}
 			if (memberRefs[index] == null)
 			{
 				int owner = MemberRef.records[index].Class;
 				int sig = MemberRef.records[index].Signature;
 				string name = GetString(MemberRef.records[index].Name);
 				switch (owner >> 24)
 				{
 					case MethodDefTable.Index
 						return GetMethodAt(null, (owner & 0xFFFFFF) - 1);
 					case ModuleRefTable.Index
 						memberRefs[index] = ResolveTypeMemberRef(ResolveModuleType(owner), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
 						break;
 					case TypeDefTable.Index
 					case TypeRefTable.Index
 						memberRefs[index] = ResolveTypeMemberRef(ResolveType(owner), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
 						break;
 					case TypeSpecTable.Index
 						return ResolveTypeMemberRef(ResolveType(owner, genericTypeArguments, genericMethodArguments), name, ByteReader.FromBlob(blobHeap, sig), genericTypeArguments, genericMethodArguments);
 					default
 						throw new BadImageFormatException();
 				}
 			}
 			return memberRefs[index];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\modifiers.cs" startline="192" endline="236">
<![CDATA[
 
 		public static MethodAttributes MethodAttr (Modifiers mod_flags)
 		{
 			MethodAttributes ma = MethodAttributes.HideBySig;
 
 			switch (mod_flags & Modifiers.AccessibilityMask) {
 			case Modifiers.PUBLIC
 				ma |= MethodAttributes.Public;
 				break;
 			case Modifiers.PRIVATE
 				ma |= MethodAttributes.Private;
 				break;
 			case Modifiers.PROTECTED | Modifiers.INTERNAL
 				ma |= MethodAttributes.FamORAssem;
 				break;
 			case Modifiers.PROTECTED
 				ma |= MethodAttributes.Family;
 				break;
 			case Modifiers.INTERNAL
 				ma |= MethodAttributes.Assembly;
 				break;
 			default
 				throw new NotImplementedException (mod_flags.ToString ());
 			}
 
 			if ((mod_flags & Modifiers.STATIC) != 0)
 				ma |= MethodAttributes.Static;
 			if ((mod_flags & Modifiers.ABSTRACT) != 0) {
 				ma |= MethodAttributes.Abstract | MethodAttributes.Virtual;
 			}
 			if ((mod_flags & Modifiers.SEALED) != 0)
 				ma |= MethodAttributes.Final;
 
 			if ((mod_flags & Modifiers.VIRTUAL) != 0)
 				ma |= MethodAttributes.Virtual;
 
 			if ((mod_flags & Modifiers.OVERRIDE) != 0) {
 				ma |= MethodAttributes.Virtual;
 			} else {
 				if ((ma & MethodAttributes.Virtual) != 0)
 					ma |= MethodAttributes.NewSlot;
 			}
 			
 			return ma;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1751" endline="1902">
<![CDATA[
 
 		public bool Define (DeclSpace parent, string method_full_name, Report Report)
 		{
 			TypeContainer container = parent.PartialContainer;
 
 			PendingImplementation pending = container.PendingImplementations;
 			if (pending != null){
 				implementing = pending.IsInterfaceMethod (method.MethodName, member.InterfaceType, this);
 
 				if (member.InterfaceType != null){
 					if (implementing == null){
 						if (member is PropertyBase) {
 							Report.Error (550, method.Location, "`{0}' is an accessor not found in interface member `{1}{2}'",
 								      method.GetSignatureForError (), TypeManager.CSharpName (member.InterfaceType),
 								      member.GetSignatureForError ().Substring (member.GetSignatureForError ().LastIndexOf ('.')));
 
 						} else {
 							Report.Error (539, method.Location,
 								      "`{0}.{1}' in explicit interface declaration is not a member of interface",
 								      TypeManager.CSharpName (member.InterfaceType), member.ShortName);
 						}
 						return false;
 					}
 					if (implementing.IsAccessor && !(method is AbstractPropertyEventMethod)) {
 						Report.SymbolRelatedToPreviousError (implementing);
 						Report.Error (683, method.Location, "`{0}' explicit method implementation cannot implement `{1}' because it is an accessor",
 							member.GetSignatureForError (), TypeManager.CSharpSignature (implementing));
 						return false;
 					}
 				} else {
 					if (implementing != null) {
 						AbstractPropertyEventMethod prop_method = method as AbstractPropertyEventMethod;
 						if (prop_method == null) {
 							if (implementing.IsAccessor) {
 								Report.SymbolRelatedToPreviousError (implementing);
 								Report.Error (470, method.Location, "Method `{0}' cannot implement interface accessor `{1}'",
 									method.GetSignatureForError (), TypeManager.CSharpSignature (implementing));
 							}
 						} else if (implementing.DeclaringType.IsInterface) {
 							if (!implementing.IsAccessor) {
 								Report.SymbolRelatedToPreviousError (implementing);
 								Report.Error (686, method.Location, "Accessor `{0}' cannot implement interface member `{1}' for type `{2}'. Use an explicit interface implementation",
 									method.GetSignatureForError (), TypeManager.CSharpSignature (implementing), container.GetSignatureForError ());
 							} else {
 								PropertyBase.PropertyMethod pm = prop_method as PropertyBase.PropertyMethod;
 								if (pm != null && pm.HasCustomAccessModifier && (pm.ModFlags & Modifiers.PUBLIC) == 0) {
 									Report.SymbolRelatedToPreviousError (implementing);
 									Report.Error (277, method.Location, "Accessor `{0}' must be declared public to implement interface member `{1}'",
 										method.GetSignatureForError (), implementing.GetSignatureForError ());
 								}
 							}
 						}
 					}
 				}
 			}
 
 			//
 			// For implicit implementations, make sure we are public, for
 			// explicit implementations, make sure we are private.
 			//
 			if (implementing != null){
 				//
 				// Setting null inside this block will trigger a more
 				// verbose error reporting for missing interface implementations
 				//
 				// The "candidate" function has been flagged already
 				// but it wont get cleared
 				//
 				if (member.IsExplicitImpl){
 					if (method.ParameterInfo.HasParams && !implementing.Parameters.HasParams) {
 						Report.SymbolRelatedToPreviousError (implementing);
 						Report.Error (466, method.Location, "`{0}'
 							method.GetSignatureForError ());
 					}
 				} else {
 					if (implementing.DeclaringType.IsInterface) {
 						//
 						// If this is an interface method implementation,
 						// check for public accessibility
 						//
 						if ((flags & MethodAttributes.MemberAccessMask) != MethodAttributes.Public)
 						{
 							implementing = null;
 						}
 					} else if ((flags & MethodAttributes.MemberAccessMask) == MethodAttributes.Private){
 						// We may never be private.
 						implementing = null;
 
 					} else if ((modifiers & Modifiers.OVERRIDE) == 0){
 						//
 						// We may be protected if we're overriding something.
 						//
 						implementing = null;
 					}
 				}
 					
 				//
 				// Static is not allowed
 				//
 				if ((modifiers & Modifiers.STATIC) != 0){
 					implementing = null;
 				}
 			}
 			
 			//
 			// If implementing is still valid, set flags
 			//
 			if (implementing != null){
 				//
 				// When implementing interface methods, set NewSlot
 				// unless, we are overwriting a method.
 				//
 				if (implementing.DeclaringType.IsInterface){
 					if ((modifiers & Modifiers.OVERRIDE) == 0)
 						flags |= MethodAttributes.NewSlot;
 				}
 
 				flags |= MethodAttributes.Virtual | MethodAttributes.HideBySig;
 
 				// Set Final unless we're virtual, abstract or already overriding a method.
 				if ((modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT | Modifiers.OVERRIDE)) == 0)
 					flags |= MethodAttributes.Final;
 
 				//
 				// clear the pending implementation flag (requires explicit methods to be defined first)
 				//
 				parent.PartialContainer.PendingImplementations.ImplementMethod (method.MethodName,
 					member.InterfaceType, this, member.IsExplicitImpl);
 
 				//
 				// Update indexer accessor name to match implementing abstract accessor
 				//
 				if (!implementing.DeclaringType.IsInterface && !member.IsExplicitImpl && implementing.IsAccessor)
 					method_full_name = implementing.MemberDefinition.Name;
 			}
 
 			DefineMethodBuilder (container, method_full_name, method.ParameterInfo);
 
 			if (builder == null)
 				return false;
 
 //			if (container.CurrentType != null)
 //				declaring_type = container.CurrentType;
 //			else
 				declaring_type = container.Definition;
 
 			if (implementing != null && member.IsExplicitImpl) {
 				container.TypeBuilder.DefineMethodOverride (builder, (MethodInfo) implementing.GetMetaInfo ());
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1286" endline="1364">
<![CDATA[
 
 		int integer_type_suffix (ulong ul, int c)
 		{
 			bool is_unsigned = false;
 			bool is_long = false;
 
 			if (c != -1){
 				bool scanning = true;
 				do {
 					switch (c){
 					case 'U'
 						if (is_unsigned)
 							scanning = false;
 						is_unsigned = true;
 						get_char ();
 						break;
 
 					case 'l'
 						if (!is_unsigned){
 							//
 							// if we have not seen anything in between
 							// report this error
 							//
 							Report.Warning (78, 4, Location, "The 'l' suffix is easily confused with the digit '1' (use 'L' for clarity)");
 						}
 
 						goto case 'L';
 
 					case 'L'
 						if (is_long)
 							scanning = false;
 						is_long = true;
 						get_char ();
 						break;
 						
 					default
 						scanning = false;
 						break;
 					}
 					c = peek_char ();
 				} while (scanning);
 			}
 
 			if (is_long && is_unsigned){
 				val = new ULongLiteral (ul, Location);
 				return Token.LITERAL;
 			}
 			
 			if (is_unsigned){
 				// uint if possible, or ulong else.
 
 				if ((ul & 0xffffffff00000000) == 0)
 					val = new UIntLiteral ((uint) ul, Location);
 				else
 					val = new ULongLiteral (ul, Location);
 			} else if (is_long){
 				// long if possible, ulong otherwise
 				if ((ul & 0x8000000000000000) != 0)
 					val = new ULongLiteral (ul, Location);
 				else
 					val = new LongLiteral ((long) ul, Location);
 			} else {
 				// int, uint, long or ulong in that order
 				if ((ul & 0xffffffff00000000) == 0){
 					uint ui = (uint) ul;
 					
 					if ((ui & 0x80000000) != 0)
 						val = new UIntLiteral (ui, Location);
 					else
 						val = new IntLiteral ((int) ui, Location);
 				} else {
 					if ((ul & 0x8000000000000000) != 0)
 						val = new ULongLiteral (ul, Location);
 					else
 						val = new LongLiteral ((long) ul, Location);
 				}
 			}
 			return Token.LITERAL;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="896" endline="944">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1693" endline="1700">
<![CDATA[
 
 		public bool IsAssigned (BlockContext ec)
 		{
 			if (VariableInfo == null)
 				throw new Exception ();
 
 			return !ec.DoFlowAnalysis || ec.CurrentBranching.IsAssigned (VariableInfo);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="294" endline="333">
<![CDATA[
 		}
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.In && ModFlags == Modifier.OUT) {
 				a.Report.Error (36, a.Location, "An out parameter cannot have the `In' attribute");
 				return;
 			}
 
 			if (a.Type == pa.ParamArray) {
 				a.Report.Error (674, a.Location, "Do not use `System.ParamArrayAttribute'. Use the `params' keyword instead");
 				return;
 			}
 
 			if (a.Type == pa.Out && (ModFlags & Modifier.REF) == Modifier.REF &&
 			    !OptAttributes.Contains (pa.In)) {
 				a.Report.Error (662, a.Location,
 					"Cannot specify only `Out' attribute on a ref parameter. Use both `In' and `Out' attributes or neither");
 				return;
 			}
 
 			if (a.Type == pa.CLSCompliant) {
 				a.Report.Warning (3022, 1, a.Location, "CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead");
 			}
 
 			if (a.Type == pa.DefaultParameterValue || a.Type == pa.OptionalParameter) {
 				if (HasOptionalExpression) {
 					a.Report.Error (1745, a.Location,
 						"Cannot specify `{0}' attribute on optional parameter `{1}'",
 						TypeManager.CSharpName (a.Type).Replace ("Attribute", ""), Name);
 				}
 
 				if (a.Type == pa.DefaultParameterValue)
 					return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="459" endline="517">
<![CDATA[
 
 		private Type ImportImpl(System.Type type)
 		{
 			if (type.Assembly == typeof(IKVM.Reflection.Type).Assembly)
 			{
 				throw new ArgumentException("Did you really want to import " + type.FullName + "?");
 			}
 			if (type.HasElementType)
 			{
 				if (type.IsArray)
 				{
 					if (type.Name.EndsWith("[]"))
 					{
 						return Import(type.GetElementType()).MakeArrayType();
 					}
 					else
 					{
 						return Import(type.GetElementType()).MakeArrayType(type.GetArrayRank());
 					}
 				}
 				else if (type.IsByRef)
 				{
 					return Import(type.GetElementType()).MakeByRefType();
 				}
 				else if (type.IsPointer)
 				{
 					return Import(type.GetElementType()).MakePointerType();
 				}
 				else
 				{
 					throw new InvalidOperationException();
 				}
 			}
 			else if (type.IsGenericParameter)
 			{
 				if (type.DeclaringMethod != null)
 				{
 					throw new NotImplementedException();
 				}
 				else
 				{
 					return Import(type.DeclaringType).GetGenericArguments()[type.GenericParameterPosition];
 				}
 			}
 			else if (type.IsGenericType && !type.IsGenericTypeDefinition)
 			{
 				System.Type[] args = type.GetGenericArguments();
 				Type[] importedArgs = new Type[args.Length];
 				for (int i = 0; i < args.Length; i++)
 				{
 					importedArgs[i] = Import(args[i]);
 				}
 				for (int i = 0; i < args.Length; i++)
 				{
 					importedArgs[i] = Import(args[i]);
 				}
 				return Import(type.GetGenericTypeDefinition()).MakeGenericType(importedArgs);
 			}
 			else
 			{
 				return Import(type.Assembly).GetType(type.FullName);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="409" endline="425">
<![CDATA[
 
 		public void PopPosition ()
 		{
 			Position p = position_stack.Pop ();
 
 			reader.Position = p.position;
 			ref_line = p.ref_line;
 			line = p.line;
 			col = p.col;
 			hidden = p.hidden;
 			putback_char = p.putback_char;
 			previous_col = p.previous_col;
 			ifstack = p.ifstack;
 			parsing_generic_less_than = p.parsing_generic_less_than;
 			current_token = p.current_token;
 			val = p.val;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="379" endline="386">
<![CDATA[
 
 		public void BeginScope()
 		{
 			Scope newScope = new Scope(scope);
 			scope.children.Add(newScope);
 			scope = newScope;
 			scope.startOffset = code.Position;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2104" endline="2111">
<![CDATA[
 
 		public override bool Equals(object o)
 		{
 			GenericTypeInstance gt = o as GenericTypeInstance;
 			return gt != null && gt.type.Equals(type) && Util.ArrayEquals(gt.args, args)
 				&& Util.ArrayEquals(gt.requiredCustomModifiers, requiredCustomModifiers)
 				&& Util.ArrayEquals(gt.optionalCustomModifiers, optionalCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="604" endline="624">
<![CDATA[
 
 		//
 		// CSC 2 has this behavior, it allows structs to be compared
 		// with the null literal *outside* of a generics context and
 		// inlines that as true or false.
 		//
 		Constant CreateNullConstant (ResolveContext ec, Expression expr)
 		{
 			// FIXME
 			Constant c = new BoolConstant (Oper == Operator.Inequality, loc).Resolve (ec);
 
 			if ((Oper & Operator.EqualityMask) != 0) {
 				ec.Report.Warning (472, 2, loc, "The result of comparing value type `{0}' with null is `{1}'",
 					TypeManager.CSharpName (expr.Type), c.AsString ());
 			} else {
 				ec.Report.Warning (464, 2, loc, "The result of comparing type `{0}' with null is always `{1}'",
 					TypeManager.CSharpName (expr.Type), c.AsString ());
 			}
 
 			return ReducedExpression.Create (c, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8406" endline="8417">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = Arguments.CreateForExpressionTree (ec, arguments,
 				InstanceExpression.CreateExpressionTree (ec),
 				new TypeOfMethod (Getter, loc));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2041" endline="2055">
<![CDATA[
 
 		public override bool ResolveUnreachable (BlockContext ec, bool warn)
 		{
 			unreachable_shown = true;
 			unreachable = true;
 
 			if (warn)
 				ec.Report.Warning (162, 2, loc, "Unreachable code detected");
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Block, loc);
 			bool ok = Resolve (ec);
 			ec.KillFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4111" endline="4119">
<![CDATA[
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			if (arguments.Count != 2)
 				throw new NotImplementedException ("arguments.Count != 2");
 
 			var concat = typeof (string).GetMethod ("Concat", new[] { typeof (object), typeof (object) });
 			return SLE.Expression.Add (arguments[0].Expr.MakeExpression (ctx), arguments[1].Expr.MakeExpression (ctx), concat);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1056" endline="1152">
<![CDATA[
 
 		//
 		// Creates the type
 		//
 		public override bool Define ()
 		{
 			if (type_expr.Type == TypeManager.void_type && parameters.IsEmpty && MemberName.Arity == 0 && MemberName.Name == Destructor.MetadataName) {
 				Report.Warning (465, 1, Location, "Introducing `Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?");
 			}
 
 			if (!base.Define ())
 				return false;
 
 			if (partialMethodImplementation != null && IsPartialDefinition)
 				MethodBuilder = partialMethodImplementation.MethodBuilder;
 
 			if (RootContext.StdLib && TypeManager.IsSpecialType (ReturnType)) {
 				Error1599 (Location, ReturnType, Report);
 				return false;
 			}
 
 			if (CurrentTypeParameters == null) {
 				if (base_method != null) {
 					if (parameters.Count == 1 && ParameterTypes[0] == TypeManager.object_type && Name == "Equals")
 						Parent.PartialContainer.Mark_HasEquals ();
 					else if (parameters.IsEmpty && Name == "GetHashCode")
 						Parent.PartialContainer.Mark_HasGetHashCode ();
 				}
 					
 			} else {
 				DefineTypeParameters ();
 			}
 
 			if (block != null && block.IsIterator) {
 				//
 				// Current method is turned into automatically generated
 				// wrapper which creates an instance of iterator
 				//
 				Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 				ModFlags |= Modifiers.DEBUGGER_HIDDEN;
 			}
 
 			if ((ModFlags & Modifiers.STATIC) == 0)
 				return true;
 
 			if (parameters.HasExtensionMethodType) {
 				if (Parent.PartialContainer.IsStatic && !Parent.IsGeneric) {
 					if (!Parent.IsTopLevel)
 						Report.Error (1109, Location, "`{0}'
 							GetSignatureForError ());
 
 					PredefinedAttribute pa = Module.PredefinedAttributes.Extension;
 					if (!pa.IsDefined) {
 						Report.Error (1110, Location,
 							"`{0}'
 							GetSignatureForError ());
 					}
 
 					ModFlags |= Modifiers.METHOD_EXTENSION;
 					Parent.PartialContainer.ModFlags |= Modifiers.METHOD_EXTENSION;
 					Spec.DeclaringType.SetExtensionMethodContainer ();
 					Parent.Module.HasExtensionMethod = true;
 				} else {
 					Report.Error (1106, Location, "`{0}'
 						GetSignatureForError ());
 				}
 			}
 
 			//
 			// This is used to track the Entry Point,
 			//
 			if (RootContext.NeedsEntryPoint &&
 				Name == "Main" &&
 				(RootContext.MainClass == null ||
 				RootContext.MainClass == Parent.TypeBuilder.FullName)){
 				if (IsEntryPoint ()) {
 
 					if (Parent.DeclaringAssembly.EntryPoint == null) {
 						if (Parent.IsGeneric || MemberName.IsGeneric) {
 							Report.Warning (402, 4, Location, "`{0}'
 								GetSignatureForError ());
 						} else {
 							SetIsUsed ();
 							Parent.DeclaringAssembly.EntryPoint = this;
 						}
 					} else {
 						Error_DuplicateEntryPoint (Parent.DeclaringAssembly.EntryPoint);
 						Error_DuplicateEntryPoint (this);
 					}
 				} else {
 					Report.Warning (28, 4, Location, "`{0}' has the wrong signature to be an entry point",
 						GetSignatureForError ());
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1690" endline="1699">
<![CDATA[
 		}
 
 		public override Type[] __GetDeclaredInterfaces()
 		{
 			return new Type[] {
 				this.Module.universe.Import(typeof(IList<>)).MakeGenericType(elementType),
 				this.Module.universe.Import(typeof(ICollection<>)).MakeGenericType(elementType),
 				this.Module.universe.Import(typeof(IEnumerable<>)).MakeGenericType(elementType)
 			};
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2404" endline="2603">
<![CDATA[
 		
 		//
 		// if true, then the code continues processing the code
 		// if false, the code stays in a loop until another directive is
 		// reached.
 		// When caller_is_taking is false we ignore all directives except the ones
 		// which can help us to identify where the #if block ends
 		bool ParsePreprocessingDirective (bool caller_is_taking)
 		{
 			string arg;
 			bool region_directive = false;
 
 			var directive = get_cmd_arg (out arg);
 
 			//
 			// The first group of pre-processing instructions is always processed
 			//
 			switch (directive) {
 			case PreprocessorDirective.Region
 				region_directive = true;
 				arg = "true";
 				goto case PreprocessorDirective.If;
 
 			case PreprocessorDirective.Endregion
 				if (ifstack == null || ifstack.Count == 0){
 					Error_UnexpectedDirective ("no #region for this #endregion");
 					return true;
 				}
 				int pop = ifstack.Pop ();
 					
 				if ((pop & REGION) == 0)
 					Report.Error (1027, Location, "Expected `#endif' directive");
 					
 				return caller_is_taking;
 				
 			case PreprocessorDirective.If
 				if (ifstack == null)
 					ifstack = new Stack<int> (2);
 
 				int flags = region_directive ? REGION 
 				if (ifstack.Count == 0){
 					flags |= PARENT_TAKING;
 				} else {
 					int state = ifstack.Peek ();
 					if ((state & TAKING) != 0) {
 						flags |= PARENT_TAKING;
 					}
 				}
 
 				if (caller_is_taking && eval (arg)) {
 					ifstack.Push (flags | TAKING);
 					return true;
 				}
 				ifstack.Push (flags);
 				return false;
 
 			case PreprocessorDirective.Endif
 				if (ifstack == null || ifstack.Count == 0){
 					Error_UnexpectedDirective ("no #if for this #endif");
 					return true;
 				} else {
 					pop = ifstack.Pop ();
 					
 					if ((pop & REGION) != 0)
 						Report.Error (1038, Location, "#endregion directive expected");
 					
 					if (arg.Length != 0) {
 						Error_EndLineExpected ();
 					}
 					
 					if (ifstack.Count == 0)
 						return true;
 
 					int state = ifstack.Peek ();
 					return (state & TAKING) != 0;
 				}
 
 			case PreprocessorDirective.Elif
 				if (ifstack == null || ifstack.Count == 0){
 					Error_UnexpectedDirective ("no #if for this #elif");
 					return true;
 				} else {
 					int state = ifstack.Pop ();
 
 					if ((state & REGION) != 0) {
 						Report.Error (1038, Location, "#endregion directive expected");
 						return true;
 					}
 
 					if ((state & ELSE_SEEN) != 0){
 						Error_UnexpectedDirective ("#elif not valid after #else");
 						return true;
 					}
 
 					if ((state & TAKING) != 0) {
 						ifstack.Push (0);
 						return false;
 					}
 
 					if (eval (arg) && ((state & PARENT_TAKING) != 0)){
 						ifstack.Push (state | TAKING);
 						return true;
 					}
 
 					ifstack.Push (state);
 					return false;
 				}
 
 			case PreprocessorDirective.Else
 				if (ifstack == null || ifstack.Count == 0){
 					Error_UnexpectedDirective ("no #if for this #else");
 					return true;
 				} else {
 					int state = ifstack.Peek ();
 
 					if ((state & REGION) != 0) {
 						Report.Error (1038, Location, "#endregion directive expected");
 						return true;
 					}
 
 					if ((state & ELSE_SEEN) != 0){
 						Error_UnexpectedDirective ("#else within #else");
 						return true;
 					}
 
 					ifstack.Pop ();
 
 					if (arg.Length != 0) {
 						Error_EndLineExpected ();
 						return true;
 					}
 
 					bool ret = false;
 					if ((state & PARENT_TAKING) != 0) {
 						ret = (state & TAKING) == 0;
 					
 						if (ret)
 							state |= TAKING;
 						else
 							state &= ~TAKING;
 					}
 	
 					ifstack.Push (state | ELSE_SEEN);
 					
 					return ret;
 				}
 			case PreprocessorDirective.Define
 				if (any_token_seen){
 					Error_TokensSeen ();
 					return caller_is_taking;
 				}
 				PreProcessDefinition (true, arg, caller_is_taking);
 				return caller_is_taking;
 
 			case PreprocessorDirective.Undef
 				if (any_token_seen){
 					Error_TokensSeen ();
 					return caller_is_taking;
 				}
 				PreProcessDefinition (false, arg, caller_is_taking);
 				return caller_is_taking;
 
 			case PreprocessorDirective.Invalid
 				Report.Error (1024, Location, "Wrong preprocessor directive");
 				return true;
 			}
 
 			//
 			// These are only processed if we are in a `taking' block
 			//
 			if (!caller_is_taking)
 				return false;
 					
 			switch (directive){
 			case PreprocessorDirective.Error
 				Report.Error (1029, Location, "#error
 				return true;
 
 			case PreprocessorDirective.Warning
 				Report.Warning (1030, 1, Location, "#warning
 				return true;
 
 			case PreprocessorDirective.Pragma
 				if (RootContext.Version == LanguageVersion.ISO_1) {
 					Report.FeatureIsNotAvailable (Location, "#pragma");
 				}
 
 				ParsePragmaDirective (arg);
 				return true;
 
 			case PreprocessorDirective.Line
 				if (!PreProcessLine (arg))
 					Report.Error (
 						1576, Location,
 						"The line number specified for #line directive is missing or invalid");
 				return caller_is_taking;
 			}
 
 			throw new NotImplementedException (directive.ToString ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="182" endline="350">
<![CDATA[
 
 		public void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (a.Type == pa.AssemblyCulture) {
 				string value = a.GetString ();
 				if (value == null || value.Length == 0)
 					return;
 
 				if (RootContext.Target == Target.Exe) {
 					a.Error_AttributeEmitError ("The executables cannot be satelite assemblies, remove the attribute or keep it empty");
 					return;
 				}
 
 				if (value == "neutral")
 					value = "";
 
 				if (RootContext.Target == Target.Module) {
 					SetCustomAttribute (ctor, cdata);
 				} else {
 					builder_extra.SetCulture (value, a.Location);
 				}
 
 				return;
 			}
 
 			if (a.Type == pa.AssemblyVersion) {
 				string value = a.GetString ();
 				if (value == null || value.Length == 0)
 					return;
 
 				var vinfo = IsValidAssemblyVersion (value, true);
 				if (vinfo == null) {
 					a.Error_AttributeEmitError (string.Format ("Specified version `{0}' is not valid", value));
 					return;
 				}
 
 				if (RootContext.Target == Target.Module) {
 					SetCustomAttribute (ctor, cdata);
 				} else {
 					builder_extra.SetVersion (vinfo, a.Location);
 				}
 
 				return;
 			}
 
 			if (a.Type == pa.AssemblyAlgorithmId) {
 				const int pos = 2; // skip CA header
 				uint alg = (uint) cdata [pos];
 				alg |= ((uint) cdata [pos + 1]) << 8;
 				alg |= ((uint) cdata [pos + 2]) << 16;
 				alg |= ((uint) cdata [pos + 3]) << 24;
 
 				if (RootContext.Target == Target.Module) {
 					SetCustomAttribute (ctor, cdata);
 				} else {
 					builder_extra.SetAlgorithmId (alg, a.Location);
 				}
 
 				return;
 			}
 
 			if (a.Type == pa.AssemblyFlags) {
 				const int pos = 2; // skip CA header
 				uint flags = (uint) cdata[pos];
 				flags |= ((uint) cdata [pos + 1]) << 8;
 				flags |= ((uint) cdata [pos + 2]) << 16;
 				flags |= ((uint) cdata [pos + 3]) << 24;
 
 				// Ignore set PublicKey flag if assembly is not strongnamed
 				if ((flags & (uint) AssemblyNameFlags.PublicKey) != 0 && public_key == null)
 					flags &= ~(uint) AssemblyNameFlags.PublicKey;
 
 				if (RootContext.Target == Target.Module) {
 					SetCustomAttribute (ctor, cdata);
 				} else {
 					builder_extra.SetFlags (flags, a.Location);
 				}
 
 				return;
 			}
 
 			if (a.Type == pa.TypeForwarder) {
 				TypeSpec t = a.GetArgumentType ();
 				if (t == null || TypeManager.HasElementType (t)) {
 					Report.Error (735, a.Location, "Invalid type specified as an argument for TypeForwardedTo attribute");
 					return;
 				}
 
 				if (emitted_forwarders == null) {
 					emitted_forwarders = new Dictionary<ITypeDefinition, Attribute> ();
 				} else if (emitted_forwarders.ContainsKey (t.MemberDefinition)) {
 					Report.SymbolRelatedToPreviousError (emitted_forwarders[t.MemberDefinition].Location, null);
 					Report.Error (739, a.Location, "A duplicate type forward of type `{0}'",
 						TypeManager.CSharpName (t));
 					return;
 				}
 
 				emitted_forwarders.Add (t.MemberDefinition, a);
 
 				if (t.MemberDefinition.DeclaringAssembly == this) {
 					Report.SymbolRelatedToPreviousError (t);
 					Report.Error (729, a.Location, "Cannot forward type `{0}' because it is defined in this assembly",
 						TypeManager.CSharpName (t));
 					return;
 				}
 
 				if (t.IsNested) {
 					Report.Error (730, a.Location, "Cannot forward type `{0}' because it is a nested type",
 						TypeManager.CSharpName (t));
 					return;
 				}
 
 				builder_extra.AddTypeForwarder (t.GetDefinition (), a.Location);
 				return;
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			if (a.Type == pa.InternalsVisibleTo) {
 				string assembly_name = a.GetString ();
 				if (assembly_name.Length == 0)
 					return;
 
 				AssemblyName aname = null;
 				try {
 					aname = new AssemblyName (assembly_name);
 				} catch (Exception) {
 					Report.Warning (1700, 3, a.Location, "Assembly reference `{0}' is invalid and cannot be resolved",
 						assembly_name);
 					return;
 				}
 
 				if (aname.Version != null || aname.CultureInfo != null || aname.ProcessorArchitecture != ProcessorArchitecture.None) {
 					Report.Error (1725, a.Location,
 						"Friend assembly reference `{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture or processor architecture specified",
 						assembly_name);
 
 					return;
 				}
 
 				// TODO
 				if (public_key != null && aname.GetPublicKey () == null) {
 					Report.Error (1726, a.Location,
 						"Friend assembly reference `{0}' is invalid. Strong named assemblies must specify a public key in their InternalsVisibleTo declarations",
 						assembly_name);
 					return;
 				}
 			} else if (a.Type == pa.RuntimeCompatibility) {
 				wrap_non_exception_throws_custom = true;
 			} else if (a.Type == pa.AssemblyFileVersion) {
 				string value = a.GetString ();
 				if (string.IsNullOrEmpty (value) || IsValidAssemblyVersion (value, false) == null) {
 					Report.Warning (1607, 1, a.Location, "The version number `{0}' specified for `{1}' is invalid",
 						value, a.Name);
 					return;
 				}
 			}
 
 
 			SetCustomAttribute (ctor, cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="134" endline="141">
<![CDATA[
 
 		internal void FixupToken(int parameterToken)
 		{
 			if (lazyPseudoToken != 0)
 			{
 				moduleBuilder.RegisterTokenFixup(lazyPseudoToken, parameterToken);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="206" endline="213">
<![CDATA[
 
 		public LocalBuilder DeclareLocal (TypeSpec type, bool pinned)
 		{
 			if (IsAnonymousStoreyMutateRequired)
 				type = CurrentAnonymousMethod.Storey.Mutator.Mutate (type);
 
 			return ig.DeclareLocal (type.GetMetaInfo (), pinned);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="62" endline="68">
<![CDATA[
 
 		internal byte ReadByte()
 		{
 			if (pos == end)
 				throw new BadImageFormatException();
 			return buffer[pos++];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="411" endline="418">
<![CDATA[
 
 		public Label DefineLabel()
 		{
 			Label label = new Label(labels.Count);
 			labels.Add(-1);
 			labelStackHeight.Add(-1);
 			return label;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4563" endline="4573">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			if (IsLockedByStatement) {
 				rc.Report.Warning (728, 2, loc,
 					"Possibly incorrect assignment to `{0}' which is the argument to a using or lock statement",
 					Name);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1520" endline="1527">
<![CDATA[
 
 		public override MetaType GetMetaInfo ()
 		{
 			if (info == null)
 				info = CreateMetaInfo (null);
 
 			return info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7356" endline="7364">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			type = ec.Module.PredefinedTypes.FieldInfo.Resolve (loc);
 			if (type == null)
 				return null;
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="546" endline="562">
<![CDATA[
 
 		protected override Expression ResolveUserOperator (ResolveContext ec, Expression expr)
 		{
 			expr = base.ResolveUserOperator (ec, expr);
 			if (expr == null)
 				return null;
 
 			//
 			// When a user operator is of non-nullable type
 			//
 			if (Expr is Unwrap) {
 				user_operator = LiftExpression (ec, expr);
 				return user_operator;
 			}
 
 			return expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6208" endline="6224">
<![CDATA[
 
 		protected virtual Expression ResolveArrayElement (ResolveContext ec, Expression element)
 		{
 			element = element.Resolve (ec);
 			if (element == null)
 				return null;
 
 			if (element is CompoundAssign.TargetExpression) {
 				if (first_emit != null)
 					throw new InternalErrorException ("Can only handle one mutator at a time");
 				first_emit = element;
 				element = first_emit_temp = new LocalTemporary (element.Type);
 			}
 
 			return Convert.ImplicitConversionRequired (
 				ec, element, array_element_type, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="87" endline="98">
<![CDATA[
 
 		public void AddFile (SourceFile file)
 		{
 			if (file == this)
 				return;
 			
 			if (include_files == null)
 				include_files = new Dictionary<string, SourceFile> ();
 
 			if (!include_files.ContainsKey (file.Path))
 				include_files.Add (file.Path, file);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="513" endline="526">
<![CDATA[
 
 		public void AddProperty (Property prop)
 		{
 			if (!AddMember (prop))
 				return;
 
 			if (properties == null)
 				properties = new List<MemberCore> ();
 
 			if (prop.MemberName.Left != null)
 				AddMemberToList (prop, properties, true);
 			else 
 				AddMemberToList (prop, properties, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="54" endline="73">
<![CDATA[
 
 		public override Constant ConvertInitializer (ResolveContext rc, Constant expr)
 		{
 			if (expr is EnumConstant)
 				expr = ((EnumConstant) expr).Child;
 
 			var underlying = ((Enum) Parent).UnderlyingType;
 			if (expr != null) {
 				expr = expr.ImplicitConversionRequired (rc, underlying, Location);
 				if (expr != null && !IsValidEnumType (expr.Type)) {
 					Enum.Error_1008 (Location, Report);
 					expr = null;
 				}
 			}
 
 			if (expr == null)
 				expr = New.Constantify (underlying, Location);
 
 			return new EnumConstant (expr, MemberType).Resolve (rc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="826" endline="832">
<![CDATA[
 
 		public void ImportTypeBase (MetaType type)
 		{
 			TypeSpec spec = import_cache[type];
 			if (spec != null)
 				ImportTypeBase (spec, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7056" endline="7067">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 			type = InternalType.Arglist;
 			if (Arguments != null) {
 				bool dynamic;	// Can be ignored as there is always only 1 overload
 				Arguments.Resolve (ec, out dynamic);
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4497" endline="4517">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label false_target = ec.DefineLabel ();
 			Label end_target = ec.DefineLabel ();
 
 			expr.EmitBranchable (ec, false_target, false);
 			true_expr.Emit (ec);
 
 			if (type.IsInterface) {
 				LocalBuilder temp = ec.GetTemporaryLocal (type);
 				ec.Emit (OpCodes.Stloc, temp);
 				ec.Emit (OpCodes.Ldloc, temp);
 				ec.FreeTemporaryLocal (temp, type);
 			}
 
 			ec.Emit (OpCodes.Br, end_target);
 			ec.MarkLabel (false_target);
 			false_expr.Emit (ec);
 			ec.MarkLabel (end_target);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="397" endline="450">
<![CDATA[
 
 		void DefineIteratorMembers ()
 		{
 			pc_field = AddCompilerGeneratedField ("$PC", new TypeExpression (TypeManager.int32_type, Location));
 			current_field = AddCompilerGeneratedField ("$current", iterator_type_expr);
 
 			if (hoisted_params != null) {
 				//
 				// Iterators are independent, each GetEnumerator call has to
 				// create same enumerator therefore we have to keep original values
 				// around for re-initialization
 				//
 				// TODO
 				//
 				hoisted_params_copy = new List<HoistedParameter> (hoisted_params.Count);
 				foreach (HoistedParameter hp in hoisted_params) {
 					hoisted_params_copy.Add (new HoistedParameter (hp, "<$>" + hp.Field.Name));
 				}
 				foreach (HoistedParameter hp in hoisted_params) {
 					hoisted_params_copy.Add (new HoistedParameter (hp, "<$>" + hp.Field.Name));
 				}
 			}
 
 			if (generic_enumerator_type != null)
 				Define_Current (true);
 
 			Define_Current (false);
 			new DisposeMethod (this);
 			Define_Reset ();
 
 			if (Iterator.IsEnumerable) {
 				MemberName name = new MemberName (QualifiedAliasMember.GlobalAlias, "System", null, Location);
 				name = new MemberName (name, "Collections", Location);
 				name = new MemberName (name, "IEnumerable", Location);
 				name = new MemberName (name, "GetEnumerator", Location);
 
 				if (generic_enumerator_type != null) {
 					Method get_enumerator = new IteratorMethod (this, enumerator_type, 0, name);
 
 					name = new MemberName (name.Left.Left, "Generic", Location);
 					name = new MemberName (name, "IEnumerable", generic_args, Location);
 					name = new MemberName (name, "GetEnumerator", Location);
 					Method gget_enumerator = new GetEnumeratorMethod (this, generic_enumerator_type, name);
 
 					//
 					// Just call generic GetEnumerator implementation
 					//
 					get_enumerator.Block.AddStatement (
 						new Return (new Invocation (new DynamicMethodGroupExpr (gget_enumerator, Location), null), Location));
 
 					AddMethod (get_enumerator);
 					AddMethod (gget_enumerator);
 				} else {
 					AddMethod (new GetEnumeratorMethod (this, enumerator_type, name));
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="128" endline="140">
<![CDATA[
 		}
 
 		//
 		// For compiled constants we have to resolve the value as there could be constant dependecies. This
 		// is needed for imported constants too to get the right context type
 		//
 		public Constant GetConstant (ResolveContext rc)
 		{
 			if (value.eclass != ExprClass.Value)
 				value = value.Resolve (rc);
 
 			return (Constant) value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1528" endline="1535">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			if (TypeManager.IsNullableType (open_type))
 				return targs[0].GetSignatureForError () + "?";
 
 			return base.GetSignatureForError ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1369" endline="1379">
<![CDATA[
 
 		public bool IsAssigned (ResolveContext ec, Location loc)
 		{
 			if (IsAssigned (ec))
 				return true;
 
 			ec.Report.Error (165, loc,
 				      "Use of unassigned local variable `" + Name + "'");
 			ec.CurrentBranching.SetAssigned (this);
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3280" endline="3295">
<![CDATA[
 
 		public string GetFullName (string name)
 		{
 			if (!IsExplicitImpl)
 				return name;
 
 			//
 			// When dealing with explicit members a full interface type
 			// name is added to member name to avoid possible name conflicts
 			//
 			// We use CSharpName which gets us full name with benefit of
 			// replacing predefined names which saves some space and name
 			// is still unique
 			//
 			return TypeManager.CSharpName (InterfaceType) + "." + name;
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6067" endline="6076">
<![CDATA[
 
 DeclSpace pop_current_class ()
 {
 	DeclSpace retval = current_class;
 
 	current_class = current_class.Parent;
 	current_container = current_class.PartialContainer;
 
 	return retval;
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1645" endline="1653">
<![CDATA[
 
 		public void Emit (EmitContext ec)
 		{
 			// TODO
 			if ((flags & Flags.CompilerGenerated) != 0)
 				CreateBuilder (ec);
 
 			ec.Emit (OpCodes.Ldloc, builder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1654" endline="1662">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec)
 		{
 			// TODO
 			if ((flags & Flags.CompilerGenerated) != 0)
 				CreateBuilder (ec);
 
 			ec.Emit (OpCodes.Stloc, builder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1334" endline="1345">
<![CDATA[
 		
 		Expression CreateConstantResult (ResolveContext ec, bool result)
 		{
 			if (result)
 				ec.Report.Warning (183, 1, loc, "The given expression is always of the provided (`{0}') type",
 					TypeManager.CSharpName (probe_type_expr.Type));
 			else
 				ec.Report.Warning (184, 1, loc, "The given expression is never of the provided (`{0}') type",
 					TypeManager.CSharpName (probe_type_expr.Type));
 
 			return ReducedExpression.Create (new BoolConstant (result, loc).Resolve (ec), this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="593" endline="605">
<![CDATA[
 
 		internal FieldInfo GetFieldAt(TypeDefImpl owner, int index)
 		{
 			if (fields == null)
 			{
 				fields = new FieldInfo[Field.records.Length];
 			}
 			if (fields[index] == null)
 			{
 				fields[index] = new FieldDefImpl(this, owner ?? FindFieldOwner(index), index);
 			}
 			return fields[index];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="281" endline="326">
<![CDATA[
 
 		protected void Error_ValueCannotBeConvertedCore (ResolveContext ec, Location loc, TypeSpec target, bool expl)
 		{
 			// The error was already reported as CS1660
 			if (type == InternalType.AnonymousMethod)
 				return;
 
 /*
 			if (TypeManager.IsGenericParameter (Type) && TypeManager.IsGenericParameter (target) && type.Name == target.Name) {
 				string sig1 = type.DeclaringMethod == null ?
 					TypeManager.CSharpName (type.DeclaringType) 
 					TypeManager.CSharpSignature (type.DeclaringMethod);
 				string sig2 = target.DeclaringMethod == null ?
 					TypeManager.CSharpName (target.DeclaringType) 
 					TypeManager.CSharpSignature (target.DeclaringMethod);
 				ec.Report.ExtraInformation (loc,
 					String.Format (
 						"The generic parameter `{0}' of `{1}' cannot be converted to the generic parameter `{0}' of `{2}' (in the previous ",
 						Type.Name, sig1, sig2));
 			} else if (Type.MetaInfo.FullName == target.MetaInfo.FullName) {
 				ec.Report.ExtraInformation (loc,
 					String.Format (
 					"The type `{0}' has two conflicting definitions, one comes from `{1}' and the other from `{2}' (in the previous ",
 					Type.MetaInfo.FullName, Type.Assembly.FullName, target.Assembly.FullName));
 			}
 */
 			if (expl) {
 				ec.Report.Error (30, loc, "Cannot convert type `{0}' to `{1}'",
 					TypeManager.CSharpName (type), TypeManager.CSharpName (target));
 				return;
 			}
 
 			ec.Report.DisableReporting ();
 			bool expl_exists = Convert.ExplicitConversion (ec, this, target, Location.Null) != null;
 			ec.Report.EnableReporting ();
 
 			if (expl_exists) {
 				ec.Report.Error (266, loc, "Cannot implicitly convert type `{0}' to `{1}'. " +
 					      "An explicit conversion exists (are you missing a cast?)",
 					TypeManager.CSharpName (Type), TypeManager.CSharpName (target));
 				return;
 			}
 
 			ec.Report.Error (29, loc, "Cannot implicitly convert type `{0}' to `{1}'",
 				type.GetSignatureForError (), target.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="327" endline="349">
<![CDATA[
 
 		public void Error_TypeArgumentsCannotBeUsed (Report report, Location loc, MemberSpec member, int arity)
 		{
 			// Better message for possible generic expressions
 			if (member != null && (member.Kind & MemberKind.GenericMask) != 0) {
 				report.SymbolRelatedToPreviousError (member);
 				if (member is TypeSpec)
 					member = ((TypeSpec) member).GetDefinition ();
 				else
 					member = ((MethodSpec) member).GetGenericMethodDefinition ();
 
 				string name = member.Kind == MemberKind.Method ? "method" 
 				if (member.IsGeneric) {
 					report.Error (305, loc, "Using the generic {0} `{1}' requires `{2}' type argument(s)",
 						name, member.GetSignatureForError (), member.Arity.ToString ());
 				} else {
 					report.Error (308, loc, "The non-generic {0} `{1}' cannot be used with the type arguments",
 						name, member.GetSignatureForError ());
 				}
 			} else {
 				Error_TypeArgumentsCannotBeUsed (report, ExprClassName, GetSignatureForError (), loc);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1151" endline="1160">
<![CDATA[
 
 		internal void Write (MyBinaryWriter bw)
 		{
 			if ((index <= 0) || (DataOffset == 0))
 				throw new InvalidOperationException ();
 
 			bw.Write (Token);
 			bw.Write (DataOffset);
 			bw.Write (LineNumberTableOffset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="56" endline="64">
<![CDATA[
 		}
 
 		private void PatchCallingConvention(MethodBuilder mdBuilder)
 		{
 			if (patchCallingConvention && !mdBuilder.IsStatic)
 			{
 				sig.HasThis = true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6838" endline="6848">
<![CDATA[
 		}
 
 		#endregion
 
 		public void CheckStructThisDefiniteAssignment (ResolveContext rc)
 		{
 			if (variable_info != null && !variable_info.IsAssigned (rc)) {
 				rc.Report.Error (188, loc,
 					"The `this' object cannot be used before all of its fields are assigned to");
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1428" endline="1436">
<![CDATA[
 
 		public void SetAssigned (MyBitVector vector)
 		{
 			if (Length == 1)
 				vector [Offset] = true;
 			else
 				vector.SetRange (Offset, Length);
 			is_ever_assigned = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="1204" endline="1216">
<![CDATA[
 
 		public void AddTypeContainer (TypeContainer current_container, TypeContainer tc)
 		{
 			if (current_container == tc){
 				Console.Error.WriteLine ("Internal error
 				return;
 			}
 
 			if (undo_types == null)
 				undo_types = new List<KeyValuePair<TypeContainer, TypeContainer>> ();
 
 			undo_types.Add (new KeyValuePair<TypeContainer, TypeContainer> (current_container, tc));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4765" endline="4786">
<![CDATA[
 
 		void DoResolveBase (ResolveContext ec)
 		{
 			VerifyAssigned (ec);
 
 			//
 			// If we are referencing a variable from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (local_info)) {
 				if (local_info.AddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (ec.IsVariableCapturingRequired) {
 					AnonymousMethodStorey storey = local_info.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureLocalVariable (ec, local_info);
 				}
 			}
 
 			eclass = ExprClass.Variable;
 			type = local_info.Type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="759" endline="768">
<![CDATA[
 
 		protected abstract Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet);
 
 		protected virtual Arguments CreateSetterArguments (ResolveContext rc, Expression rhs)
 		{
 			var setter_args = new Arguments (Arguments.Count + 1);
 			setter_args.AddRange (Arguments);
 			setter_args.Add (new Argument (rhs));
 			return setter_args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="169" endline="218">
<![CDATA[
 
 		//
 		// Processes "include" element. Check included file and
 		// embed the document content inside this documentation node.
 		//
 		private static bool HandleInclude (MemberCore mc, XmlElement el, Report Report)
 		{
 			bool keep_include_node = false;
 			string file = el.GetAttribute ("file");
 			string path = el.GetAttribute ("path");
 			if (file == "") {
 				Report.Warning (1590, 1, mc.Location, "Invalid XML `include' element. Missing `file' attribute");
 				el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (" Include tag is invalid "), el);
 				keep_include_node = true;
 			}
 			else if (path.Length == 0) {
 				Report.Warning (1590, 1, mc.Location, "Invalid XML `include' element. Missing `path' attribute");
 				el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (" Include tag is invalid "), el);
 				keep_include_node = true;
 			}
 			else {
 				XmlDocument doc;
 				if (!RootContext.Documentation.StoredDocuments.TryGetValue (file, out doc)) {
 					try {
 						doc = new XmlDocument ();
 						doc.Load (file);
 						RootContext.Documentation.StoredDocuments.Add (file, doc);
 					} catch (Exception) {
 						el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (String.Format (" Badly formed XML in at comment file `{0}'
 						Report.Warning (1592, 1, mc.Location, "Badly formed XML in included comments file -- `{0}'", file);
 					}
 				}
 				if (doc != null) {
 					try {
 						XmlNodeList nl = doc.SelectNodes (path);
 						if (nl.Count == 0) {
 							el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (" No matching elements were found for the include tag embedded here. "), el);
 					
 							keep_include_node = true;
 						}
 						foreach (XmlNode n in nl)
 							el.ParentNode.InsertBefore (el.OwnerDocument.ImportNode (n, true), el);
 						foreach (XmlNode n in nl)
 							el.ParentNode.InsertBefore (el.OwnerDocument.ImportNode (n, true), el);
 					} catch (Exception ex) {
 						el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (" Failed to insert some or all of included XML "), el);
 						Report.Warning (1589, 1, mc.Location, "Unable to include XML fragment `{0}' of file `{1}' ({2})", path, file, ex.Message);
 					}
 				}
 			}
 			return keep_include_node;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="424" endline="433">
<![CDATA[
 
 		void CheckGuidMatch (Guid other, string filename, string assembly)
 		{
 			if (other == guid)
 				return;
 
 			throw new MonoSymbolFileException (
 				"Symbol file `{0}' does not match assembly `{1}'",
 				filename, assembly);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="724" endline="746">
<![CDATA[
 
 	public static bool IsFamilyAccessible (TypeSpec type, TypeSpec parent)
 	{
 //		TypeParameter tparam = LookupTypeParameter (type);
 //		TypeParameter pparam = LookupTypeParameter (parent);
 
 		if (type.Kind == MemberKind.TypeParameter && parent.Kind == MemberKind.TypeParameter) { // (tparam != null) && (pparam != null)) {
 			if (type == parent)
 				return true;
 
 			throw new NotImplementedException ("net");
 //			return tparam.IsSubclassOf (parent);
 		}
 
 		do {
 			if (IsInstantiationOfSameGenericType (type, parent))
 				return true;
 
 			type = type.BaseType;
 		} while (type != null);
 
 		return false;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3305" endline="3352">
<![CDATA[
 
 		void EmitObjectInteger (EmitContext ec, object k)
 		{
 			if (k is int)
 				ec.EmitInt ((int) k);
 			else if (k is Constant) {
 				EmitObjectInteger (ec, ((Constant) k).GetValue ());
 			} 
 			else if (k is uint)
 				ec.EmitInt (unchecked ((int) (uint) k));
 			else if (k is long)
 			{
 				if ((long) k >= int.MinValue && (long) k <= int.MaxValue)
 				{
 					ec.EmitInt ((int) (long) k);
 					ec.Emit (OpCodes.Conv_I8);
 				}
 				else
 					ec.EmitLong ((long) k);
 			}
 			else if (k is ulong)
 			{
 				ulong ul = (ulong) k;
 				if (ul < (1L<<32))
 				{
 					ec.EmitInt (unchecked ((int) ul));
 					ec.Emit (OpCodes.Conv_U8);
 				}
 				else
 				{
 					ec.EmitLong (unchecked ((long) ul));
 				}
 			}
 			else if (k is char)
 				ec.EmitInt ((int) ((char) k));
 			else if (k is sbyte)
 				ec.EmitInt ((int) ((sbyte) k));
 			else if (k is byte)
 				ec.EmitInt ((int) ((byte) k));
 			else if (k is short)
 				ec.EmitInt ((int) ((short) k));
 			else if (k is ushort)
 				ec.EmitInt ((int) ((ushort) k));
 			else if (k is bool)
 				ec.EmitInt (((bool) k) ? 1 
 			else
 				throw new Exception ("Unhandled case");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="661" endline="788">
<![CDATA[
 
 		/// <summary>
 		///  Determines if a standard implicit conversion exists from
 		///  expr_type to target_type
 		///
 		/// </summary>
 		public static bool ImplicitStandardConversionExists (Expression expr, TypeSpec target_type)
 		{
 			TypeSpec expr_type = expr.Type;
 
 			NullLiteral nl = expr as NullLiteral;
 			if (nl != null)
 				return nl.ConvertImplicitly (null, target_type) != null;
 
 			if (expr_type == TypeManager.void_type)
 				return false;
 
 			if (expr_type == target_type)
 				return true;
 
 			// Implicit dynamic conversion
 			if (expr_type == InternalType.Dynamic) {
 				switch (target_type.Kind) {
 				case MemberKind.ArrayType
 				case MemberKind.Class
 				case MemberKind.Struct
 				case MemberKind.Delegate
 				case MemberKind.Enum
 				case MemberKind.Interface
 				case MemberKind.TypeParameter
 					return true;
 				}
 
 				// dynamic to __arglist
 				if (target_type == InternalType.Arglist)
 					return true;
 
 				return false;
 			}
 
 			if (TypeManager.IsNullableType (target_type)) {
 				return ImplicitNulableConversion (null, expr, target_type) != null;
 			}
 
 			// First numeric conversions
 			if (ImplicitNumericConversion (null, expr_type, target_type) != null)
 				return true;
 
 			if (ImplicitReferenceConversionExists (expr, target_type))
 				return true;
 
 			if (ImplicitBoxingConversion (null, expr_type, target_type) != null)
 				return true;
 			
 			//
 			// Implicit Constant Expression Conversions
 			//
 			if (expr is IntConstant){
 				int value = ((IntConstant) expr).Value;
 
 				if (target_type == TypeManager.sbyte_type){
 					if (value >= SByte.MinValue && value <= SByte.MaxValue)
 						return true;
 				} else if (target_type == TypeManager.byte_type){
 					if (value >= 0 && value <= Byte.MaxValue)
 						return true;
 				} else if (target_type == TypeManager.short_type){
 					if (value >= Int16.MinValue && value <= Int16.MaxValue)
 						return true;
 				} else if (target_type == TypeManager.ushort_type){
 					if (value >= UInt16.MinValue && value <= UInt16.MaxValue)
 						return true;
 				} else if (target_type == TypeManager.uint32_type){
 					if (value >= 0)
 						return true;
 				} else if (target_type == TypeManager.uint64_type){
 					 //
 					 // we can optimize this case
 					 // always fits on a uint64.  But we need an opcode
 					 // to do it.
 					 //
 					if (value >= 0)
 						return true;
 				}
 			}
 
 			if (expr is LongConstant && target_type == TypeManager.uint64_type){
 				//
 				// Try the implicit constant expression conversion
 				// from long to ulong, instead of a nice routine,
 				// we just inline it
 				//
 				long v = ((LongConstant) expr).Value;
 				if (v >= 0)
 					return true;
 			}
 
 			if (expr is IntegralConstant && TypeManager.IsEnumType (target_type)) {
 				var i = (IntegralConstant) expr;
 				//
 				// LAMESPEC
 				//
 				// An implicit enumeration conversion permits the decimal-integer-literal 0
 				// to be converted to any enum-type and to any nullable-type whose underlying
 				// type is an enum-type
 				//
 				return i.IsZeroInteger;
 			}
 
 			//
 			// If `expr_type' implements `target_type' (which is an iface)
 			// see TryImplicitIntConversion
 			//
 			if (target_type.IsInterface && expr_type.ImplementsInterface (target_type, true))
 				return true;
 
 			if (target_type.IsPointer && expr_type.IsPointer && ((PointerContainer) target_type).Element.BuildinType == BuildinTypeSpec.Type.Void)
 				return true;
 
 			// Conversion from __arglist to System.ArgIterator
 			if (expr_type == InternalType.Arglist)
 				return target_type == TypeManager.arg_iterator_type;
 
 			if (TypeSpecComparer.IsEqual (expr_type, target_type))
 				return true;
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="1180" endline="1333">
<![CDATA[
 
 		public bool CheckExistingMembersOverloads (MemberCore member, string name, AParametersCollection parameters)
 		{
 			IList<MemberSpec> entries;
 			if (!member_hash.TryGetValue (name, out entries))
 				return false;
 
 			var Report = member.Compiler.Report;
 
 			int method_param_count = parameters.Count;
 			for (int i = entries.Count - 1; i >= 0; --i) {
 				var ce = entries[i];
 				var pm = ce as IParametersMember;
 				var pd = pm == null ? ParametersCompiled.EmptyReadOnlyParameters 
 				if (pd.Count != method_param_count)
 					continue;
 
 				if (ce.Arity != member.MemberName.Arity)
 					continue;
 
 				// Ignore merged interface members
 				if (member.Parent.PartialContainer != ce.DeclaringType.MemberDefinition)
 					continue;
 
 				var p_types = pd.Types;
 				if (method_param_count > 0) {
 					int ii = method_param_count - 1;
 					TypeSpec type_a, type_b;
 					do {
 						type_a = parameters.Types [ii];
 						type_b = p_types [ii];
 
 						if ((pd.FixedParameters [ii].ModFlags & Parameter.Modifier.ISBYREF) !=
 							(parameters.FixedParameters [ii].ModFlags & Parameter.Modifier.ISBYREF))
 							break;
 
 					} while (TypeSpecComparer.Override.IsEqual (type_a, type_b) && ii-- != 0);
 
 					if (ii >= 0)
 						continue;
 
 					//
 					// Operators can differ in return type only
 					//
 					if (member is Operator && ce.Kind == MemberKind.Operator && ((MethodSpec) ce).ReturnType != ((Operator) member).ReturnType)
 						continue;
 
 					//
 					// Report difference in parameter modifiers only
 					//
 					if (pd != null && member is MethodCore) {
 						ii = method_param_count;
 						while (ii-- != 0 && parameters.FixedParameters[ii].ModFlags == pd.FixedParameters[ii].ModFlags &&
 							parameters.ExtensionMethodType == pd.ExtensionMethodType) ;
 
 						if (ii >= 0) {
 							var mc = ce as MethodSpec;
 							member.Compiler.Report.SymbolRelatedToPreviousError (ce);
 							if ((member.ModFlags & Modifiers.PARTIAL) != 0 && (mc.Modifiers & Modifiers.PARTIAL) != 0) {
 								if (parameters.HasParams || pd.HasParams) {
 									Report.Error (758, member.Location,
 										"A partial method declaration and partial method implementation cannot differ on use of `params' modifier");
 								} else {
 									Report.Error (755, member.Location,
 										"A partial method declaration and partial method implementation must be both an extension method or neither");
 								}
 							} else if (member is Constructor) {
 								Report.Error (851, member.Location,
 									"Overloaded contructor `{0}' cannot differ on use of parameter modifiers only",
 									member.GetSignatureForError ());
 							} else {
 								Report.Error (663, member.Location,
 									"Overloaded method `{0}' cannot differ on use of parameter modifiers only",
 									member.GetSignatureForError ());
 							}
 							return false;
 						}
 					}
 				}
 
 				if ((ce.Kind & MemberKind.Method) != 0) {
 					Method method_a = member as Method;
 					Method method_b = ce.MemberDefinition as Method;
 					if (method_a != null && method_b != null && (method_a.ModFlags & method_b.ModFlags & Modifiers.PARTIAL) != 0) {
 						const Modifiers partial_modifiers = Modifiers.STATIC | Modifiers.UNSAFE;
 						if (method_a.IsPartialDefinition == method_b.IsPartialImplementation) {
 							if ((method_a.ModFlags & partial_modifiers) == (method_b.ModFlags & partial_modifiers) ||
 								method_a.Parent.IsUnsafe && method_b.Parent.IsUnsafe) {
 								if (method_a.IsPartialImplementation) {
 									method_a.SetPartialDefinition (method_b);
 									if (entries.Count == 1)
 										member_hash.Remove (name);
 									else
 										entries.RemoveAt (i);
 								} else {
 									method_b.SetPartialDefinition (method_a);
 									method_a.caching_flags |= MemberCore.Flags.PartialDefinitionExists;
 								}
 								continue;
 							}
 
 							if (method_a.IsStatic != method_b.IsStatic) {
 								Report.SymbolRelatedToPreviousError (ce);
 								Report.Error (763, member.Location,
 									"A partial method declaration and partial method implementation must be both `static' or neither");
 							}
 
 							Report.SymbolRelatedToPreviousError (ce);
 							Report.Error (764, member.Location,
 								"A partial method declaration and partial method implementation must be both `unsafe' or neither");
 							return false;
 						}
 
 						Report.SymbolRelatedToPreviousError (ce);
 						if (method_a.IsPartialDefinition) {
 							Report.Error (756, member.Location, "A partial method `{0}' declaration is already defined",
 								member.GetSignatureForError ());
 						}
 
 						Report.Error (757, member.Location, "A partial method `{0}' implementation is already defined",
 							member.GetSignatureForError ());
 						return false;
 					}
 
 					Report.SymbolRelatedToPreviousError (ce);
 
 					bool is_reserved_a = member is AbstractPropertyEventMethod || member is Operator;
 					bool is_reserved_b = ((MethodSpec) ce).IsReservedMethod;
 
 					if (is_reserved_a || is_reserved_b) {
 						Report.Error (82, member.Location, "A member `{0}' is already reserved",
 							is_reserved_a ?
 							ce.GetSignatureForError () 
 							member.GetSignatureForError ());
 						return false;
 					}
 				} else {
 					Report.SymbolRelatedToPreviousError (ce);
 				}
 
 				if (member is Operator && ce.Kind == MemberKind.Operator) {
 					Report.Error (557, member.Location, "Duplicate user-defined conversion in type `{0}'",
 						member.Parent.GetSignatureForError ());
 					return false;
 				}
 
 				Report.Error (111, member.Location,
 					"A member `{0}' is already defined. Rename this member or use different parameter types",
 					member.GetSignatureForError ());
 				return false;
 			for (int i = entries.Count - 1; i >= 0; --i) {
 				var ce = entries[i];
 				var pm = ce as IParametersMember;
 				var pd = pm == null ? ParametersCompiled.EmptyReadOnlyParameters 
 				if (pd.Count != method_param_count)
 					continue;
 
 				if (ce.Arity != member.MemberName.Arity)
 					continue;
 
 				// Ignore merged interface members
 				if (member.Parent.PartialContainer != ce.DeclaringType.MemberDefinition)
 					continue;
 
 				var p_types = pd.Types;
 				if (method_param_count > 0) {
 					int ii = method_param_count - 1;
 					TypeSpec type_a, type_b;
 					do {
 						type_a = parameters.Types [ii];
 						type_b = p_types [ii];
 
 						if ((pd.FixedParameters [ii].ModFlags & Parameter.Modifier.ISBYREF) !=
 							(parameters.FixedParameters [ii].ModFlags & Parameter.Modifier.ISBYREF))
 							break;
 
 					} while (TypeSpecComparer.Override.IsEqual (type_a, type_b) && ii-- != 0);
 
 					if (ii >= 0)
 						continue;
 
 					//
 					// Operators can differ in return type only
 					//
 					if (member is Operator && ce.Kind == MemberKind.Operator && ((MethodSpec) ce).ReturnType != ((Operator) member).ReturnType)
 						continue;
 
 					//
 					// Report difference in parameter modifiers only
 					//
 					if (pd != null && member is MethodCore) {
 						ii = method_param_count;
 						while (ii-- != 0 && parameters.FixedParameters[ii].ModFlags == pd.FixedParameters[ii].ModFlags &&
 							parameters.ExtensionMethodType == pd.ExtensionMethodType) ;
 
 						if (ii >= 0) {
 							var mc = ce as MethodSpec;
 							member.Compiler.Report.SymbolRelatedToPreviousError (ce);
 							if ((member.ModFlags & Modifiers.PARTIAL) != 0 && (mc.Modifiers & Modifiers.PARTIAL) != 0) {
 								if (parameters.HasParams || pd.HasParams) {
 									Report.Error (758, member.Location,
 										"A partial method declaration and partial method implementation cannot differ on use of `params' modifier");
 								} else {
 									Report.Error (755, member.Location,
 										"A partial method declaration and partial method implementation must be both an extension method or neither");
 								}
 							} else if (member is Constructor) {
 								Report.Error (851, member.Location,
 									"Overloaded contructor `{0}' cannot differ on use of parameter modifiers only",
 									member.GetSignatureForError ());
 							} else {
 								Report.Error (663, member.Location,
 									"Overloaded method `{0}' cannot differ on use of parameter modifiers only",
 									member.GetSignatureForError ());
 							}
 							return false;
 						}
 					}
 				}
 
 				if ((ce.Kind & MemberKind.Method) != 0) {
 					Method method_a = member as Method;
 					Method method_b = ce.MemberDefinition as Method;
 					if (method_a != null && method_b != null && (method_a.ModFlags & method_b.ModFlags & Modifiers.PARTIAL) != 0) {
 						const Modifiers partial_modifiers = Modifiers.STATIC | Modifiers.UNSAFE;
 						if (method_a.IsPartialDefinition == method_b.IsPartialImplementation) {
 							if ((method_a.ModFlags & partial_modifiers) == (method_b.ModFlags & partial_modifiers) ||
 								method_a.Parent.IsUnsafe && method_b.Parent.IsUnsafe) {
 								if (method_a.IsPartialImplementation) {
 									method_a.SetPartialDefinition (method_b);
 									if (entries.Count == 1)
 										member_hash.Remove (name);
 									else
 										entries.RemoveAt (i);
 								} else {
 									method_b.SetPartialDefinition (method_a);
 									method_a.caching_flags |= MemberCore.Flags.PartialDefinitionExists;
 								}
 								continue;
 							}
 
 							if (method_a.IsStatic != method_b.IsStatic) {
 								Report.SymbolRelatedToPreviousError (ce);
 								Report.Error (763, member.Location,
 									"A partial method declaration and partial method implementation must be both `static' or neither");
 							}
 
 							Report.SymbolRelatedToPreviousError (ce);
 							Report.Error (764, member.Location,
 								"A partial method declaration and partial method implementation must be both `unsafe' or neither");
 							return false;
 						}
 
 						Report.SymbolRelatedToPreviousError (ce);
 						if (method_a.IsPartialDefinition) {
 							Report.Error (756, member.Location, "A partial method `{0}' declaration is already defined",
 								member.GetSignatureForError ());
 						}
 
 						Report.Error (757, member.Location, "A partial method `{0}' implementation is already defined",
 							member.GetSignatureForError ());
 						return false;
 					}
 
 					Report.SymbolRelatedToPreviousError (ce);
 
 					bool is_reserved_a = member is AbstractPropertyEventMethod || member is Operator;
 					bool is_reserved_b = ((MethodSpec) ce).IsReservedMethod;
 
 					if (is_reserved_a || is_reserved_b) {
 						Report.Error (82, member.Location, "A member `{0}' is already reserved",
 							is_reserved_a ?
 							ce.GetSignatureForError () 
 							member.GetSignatureForError ());
 						return false;
 					}
 				} else {
 					Report.SymbolRelatedToPreviousError (ce);
 				}
 
 				if (member is Operator && ce.Kind == MemberKind.Operator) {
 					Report.Error (557, member.Location, "Duplicate user-defined conversion in type `{0}'",
 						member.Parent.GetSignatureForError ());
 					return false;
 				}
 
 				Report.Error (111, member.Location,
 					"A member `{0}' is already defined. Rename this member or use different parameter types",
 					member.GetSignatureForError ());
 				return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="57" endline="161">
<![CDATA[
 
 		[DllImport("fusion", CharSet = CharSet.Unicode)]
 		private static extern int CompareAssemblyIdentity(string pwzAssemblyIdentity1, bool fUnified1, string pwzAssemblyIdentity2, bool fUnified2, out bool pfEquivalent, out AssemblyComparisonResult pResult);
 
 		// internal for use by mcs
 		internal static bool CompareAssemblyIdentityPure(string assemblyIdentity1, bool unified1, string assemblyIdentity2, bool unified2, out AssemblyComparisonResult result)
 		{
 			ParsedAssemblyName name1;
 			ParsedAssemblyName name2;
 
 			if (!ParseAssemblyName(assemblyIdentity1, out name1)
 				|| !ParseAssemblyName(assemblyIdentity2, out name2))
 			{
 				result = AssemblyComparisonResult.NonEquivalent;
 				throw new ArgumentException();
 			}
 
 			bool partial = IsPartial(name1);
 
 			if ((partial && unified1) || IsPartial(name2))
 			{
 				result = AssemblyComparisonResult.NonEquivalent;
 				throw new ArgumentException();
 			}
 			if (!name1.Name.Equals(name2.Name, StringComparison.InvariantCultureIgnoreCase))
 			{
 				result = AssemblyComparisonResult.NonEquivalent;
 				return false;
 			}
 			if (name1.Name.Equals("mscorlib", StringComparison.InvariantCultureIgnoreCase))
 			{
 				result = AssemblyComparisonResult.EquivalentFullMatch;
 				return true;
 			}
 			if (partial && name1.Culture == null)
 			{
 			}
 			else if (!name1.Culture.Equals(name2.Culture, StringComparison.InvariantCultureIgnoreCase))
 			{
 				result = AssemblyComparisonResult.NonEquivalent;
 				return false;
 			}
 			if (IsStrongNamed(name2))
 			{
 				if (partial && name1.PublicKeyToken == null)
 				{
 				}
 				else if (name1.PublicKeyToken != name2.PublicKeyToken)
 				{
 					result = AssemblyComparisonResult.NonEquivalent;
 					return false;
 				}
 				if (partial && name1.Version == null)
 				{
 					result = AssemblyComparisonResult.EquivalentPartialMatch;
 					return true;
 				}
 				else if (IsFrameworkAssembly(name2))
 				{
 					result = partial ? AssemblyComparisonResult.EquivalentPartialFXUnified 
 					return true;
 				}
 				else if (name1.Version < name2.Version)
 				{
 					if (unified2)
 					{
 						result = partial ? AssemblyComparisonResult.EquivalentPartialUnified 
 						return true;
 					}
 					else
 					{
 						result = partial ? AssemblyComparisonResult.NonEquivalentPartialVersion 
 						return false;
 					}
 				}
 				else if (name1.Version > name2.Version)
 				{
 					if (unified1)
 					{
 						result = partial ? AssemblyComparisonResult.EquivalentPartialUnified 
 						return true;
 					}
 					else
 					{
 						result = partial ? AssemblyComparisonResult.NonEquivalentPartialVersion 
 						return false;
 					}
 				}
 				else
 				{
 					result = partial ? AssemblyComparisonResult.EquivalentPartialMatch 
 					return true;
 				}
 			}
 			else if (IsStrongNamed(name1))
 			{
 				result = AssemblyComparisonResult.NonEquivalent;
 				return false;
 			}
 			else
 			{
 				result = partial ? AssemblyComparisonResult.EquivalentPartialWeakNamed 
 				return true;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1189" endline="1247">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value > Int32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2135" endline="2209">
<![CDATA[
 
 		/// <summary>
 		/// Handles #pragma directive
 		/// </summary>
 		void ParsePragmaDirective (string arg)
 		{
 			int c;
 			int length = TokenizePreprocessorIdentifier (out c);
 			if (length == pragma_warning.Length && IsTokenIdentifierEqual (pragma_warning)) {
 				length = TokenizePreprocessorIdentifier (out c);
 
 				//
 				// #pragma warning disable
 				// #pragma warning restore
 				//
 				if (length == pragma_warning_disable.Length) {
 					bool disable = IsTokenIdentifierEqual (pragma_warning_disable);
 					if (disable || IsTokenIdentifierEqual (pragma_warning_restore)) {
 						// skip over white space
 						while (c == '\r' || c == ' ' || c == '\t')
 							c = get_char ();
 						while (c == '\r' || c == ' ' || c == '\t')
 							c = get_char ();
 
 						var loc = Location;
 
 						if (c == '\n' || c == '/') {
 							if (c == '/')
 								ReadSingleLineComment ();
 
 							//
 							// Disable/Restore all warnings
 							//
 							if (disable) {
 								Report.RegisterWarningRegion (loc).WarningDisable (loc.Row);
 							} else {
 								Report.RegisterWarningRegion (loc).WarningEnable (loc.Row);
 							}
 						} else {
 							//
 							// Disable/Restore a warning or group of warnings
 							//
 							int code;
 							do {
 								code = TokenizePragmaNumber (ref c);
 								if (code > 0) {
 									if (disable) {
 										Report.RegisterWarningRegion (loc).WarningDisable (loc, code, Report);
 									} else {
 										Report.RegisterWarningRegion (loc).WarningEnable (loc, code, Report);
 									}
 								}
 							} while (code >= 0 && c != '\n' && c != -1);
 						}
 
 						return;
 					}
 				}
 
 				Report.Warning (1634, 1, Location, "Expected disable or restore");
 				return;
 			}
 
 			//
 			// #pragma checksum
 			//
 			if (length == pragma_checksum.Length && IsTokenIdentifierEqual (pragma_checksum)) {
 				if (c != ' ' || !ParsePragmaChecksum ()) {
 					Report.Warning (1695, 1, Location,
 						"Invalid #pragma checksum syntax. Expected \"filename\" \"{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\" \"XXXX...\"");
 				}
 
 				return;
 			}
 
 			Report.Warning (1633, 1, Location, "Unrecognized #pragma directive");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2937" endline="3037">
<![CDATA[
 		
 		protected override bool CheckBase ()
 		{
 			if (!base.CheckBase ())
 				return false;
 
 			if ((caching_flags & Flags.MethodOverloadsExist) != 0)
 				CheckForDuplications ();
 			
 			if (IsExplicitImpl)
 				return true;
 
 			// For System.Object only
 			if (Parent.BaseType == null)
 				return true;
 
 			MemberSpec candidate;
 			var base_member = FindBaseMember (out candidate);
 
 			if ((ModFlags & Modifiers.OVERRIDE) != 0) {
 				if (base_member == null) {
 					if (candidate == null) {
 						if (this is Method && ((Method)this).ParameterInfo.IsEmpty && MemberName.Name == Destructor.MetadataName && MemberName.Arity == 0) {
 							Report.Error (249, Location, "Do not override `{0}'. Use destructor syntax instead",
 								"object.Finalize()");
 						} else {
 							Report.Error (115, Location, "`{0}' is marked as an override but no suitable {1} found to override",
 								GetSignatureForError (), SimpleName.GetMemberType (this));
 						}
 					} else {
 						Report.SymbolRelatedToPreviousError (candidate);
 						if (this is Event)
 							Report.Error (72, Location, "`{0}'
 								GetSignatureForError (), TypeManager.GetFullNameSignature (candidate));
 						else if (this is PropertyBase)
 							Report.Error (544, Location, "`{0}'
 								GetSignatureForError (), TypeManager.GetFullNameSignature (candidate));
 						else
 							Report.Error (505, Location, "`{0}'
 								GetSignatureForError (), TypeManager.GetFullNameSignature (candidate));
 					}
 
 					return false;
 				}
 
 				if (!CheckOverrideAgainstBase (base_member))
 					return false;
 
 				ObsoleteAttribute oa = base_member.GetAttributeObsolete ();
 				if (oa != null) {
 					if (OptAttributes == null || !OptAttributes.Contains (Module.PredefinedAttributes.Obsolete)) {
 						Report.SymbolRelatedToPreviousError (base_member);
 						Report.Warning (672, 1, Location, "Member `{0}' overrides obsolete member `{1}'. Add the Obsolete attribute to `{0}'",
 							GetSignatureForError (), TypeManager.GetFullNameSignature (base_member));
 					}
 				} else {
 					if (OptAttributes != null && OptAttributes.Contains (Module.PredefinedAttributes.Obsolete)) {
 						Report.SymbolRelatedToPreviousError (base_member);
 						Report.Warning (809, 1, Location, "Obsolete member `{0}' overrides non-obsolete member `{1}'",
 							GetSignatureForError (), TypeManager.GetFullNameSignature (base_member));
 					}
 				}
 
 				base_method = base_member as MethodSpec;
 				return true;
 			}
 
 			if (base_member == null && candidate != null && (!(candidate is IParametersMember) || !(this is IParametersMember)))
 				base_member = candidate;
 
 			if (base_member == null) {
 				if ((ModFlags & Modifiers.NEW) != 0) {
 					if (base_member == null) {
 						Report.Warning (109, 4, Location, "The member `{0}' does not hide an inherited member. The new keyword is not required",
 							GetSignatureForError ());
 					}
 				}
 			} else {
 				if ((ModFlags & Modifiers.NEW) == 0) {
 					ModFlags |= Modifiers.NEW;
 					if (!IsCompilerGenerated) {
 						Report.SymbolRelatedToPreviousError (base_member);
 						if (!IsInterface && (base_member.Modifiers & (Modifiers.ABSTRACT | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) != 0) {
 							Report.Warning (114, 2, Location, "`{0}' hides inherited member `{1}'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword",
 								GetSignatureForError (), base_member.GetSignatureForError ());
 						} else {
 							Report.Warning (108, 2, Location, "`{0}' hides inherited member `{1}'. Use the new keyword if hiding was intended",
 								GetSignatureForError (), base_member.GetSignatureForError ());
 						}
 					}
 				}
 
 				if (!IsInterface && base_member.IsAbstract && candidate == null) {
 					Report.SymbolRelatedToPreviousError (base_member);
 					Report.Error (533, Location, "`{0}' hides inherited abstract member `{1}'",
 						GetSignatureForError (), base_member.GetSignatureForError ());
 				}
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1684" endline="1857">
<![CDATA[
 
 		/// <summary>
 		///   Implements Explicit Reference conversions
 		/// </summary>
 		static Expression ExplicitReferenceConversion (Expression source, TypeSpec source_type, TypeSpec target_type)
 		{
 			//
 			// From object to a generic parameter
 			//
 			if (source_type == TypeManager.object_type && TypeManager.IsGenericParameter (target_type))
 				return source == null ? EmptyExpression.Null 
 
 			//
 			// Explicit type parameter conversion.
 			//
 			if (source_type.Kind == MemberKind.TypeParameter)
 				return ExplicitTypeParameterConversion (source, source_type, target_type);
 
 			bool target_is_value_type = TypeManager.IsStruct (target_type) || TypeManager.IsEnumType (target_type);
 
 			//
 			// Unboxing conversion from System.ValueType to any non-nullable-value-type
 			//
 			if (source_type == TypeManager.value_type && target_is_value_type)
 				return source == null ? EmptyExpression.Null 
 
 			//
 			// From object or dynamic to any reference type or value type (unboxing)
 			//
 			if (source_type == TypeManager.object_type || source_type == InternalType.Dynamic) {
 				if (target_type.IsPointer)
 					return null;
 
 				return
 					source == null ? EmptyExpression.Null 
 					target_is_value_type ? new UnboxCast (source, target_type) 
 					source is Constant ? (Expression) new EmptyConstantCast ((Constant) source, target_type) 
 					new ClassCast (source, target_type);
 			}
 
 			//
 			// From any class S to any class-type T, provided S is a base class of T
 			//
 			if (source_type.Kind == MemberKind.Class && TypeSpec.IsBaseClass (target_type, source_type, true))
 				return source == null ? EmptyExpression.Null 
 
 			//
 			// From any interface-type S to to any class type T, provided T is not
 			// sealed, or provided T implements S.
 			//
 			if (source_type.IsInterface) {
 				if (!target_type.IsSealed || target_type.ImplementsInterface (source_type, true)) {
 					if (source == null)
 						return EmptyExpression.Null;
 
 					//
 					// Unboxing conversion from any interface-type to any non-nullable-value-type that
 					// implements the interface-type
 					//
 					return target_is_value_type ? new UnboxCast (source, target_type) 
 				}
 
 				//
 				// From System.Collections.Generic.IList<T> and its base interfaces to a one-dimensional
 				// array type S[], provided there is an implicit or explicit reference conversion from S to T.
 				//
 				var target_array = target_type as ArrayContainer;
 				if (target_array != null && IList_To_Array (source_type, target_array))
 					return source == null ? EmptyExpression.Null 
 
 				return null;
 			}
 
 			var source_array = source_type as ArrayContainer;
 			if (source_array != null) {
 				var target_array = target_type as ArrayContainer;
 				if (target_array != null) {
 					//
 					// From System.Array to any array-type
 					//
 					if (source_type == TypeManager.array_type)
 						return source == null ? EmptyExpression.Null 
 
 					//
 					// From an array type S with an element type Se to an array type T with an
 					// element type Te provided all the following are true
 					//     * S and T differe only in element type, in other words, S and T
 					//       have the same number of dimensions.
 					//     * Both Se and Te are reference types
 					//     * An explicit reference conversions exist from Se to Te
 					//
 					if (source_array.Rank == target_array.Rank) {
 
 						source_type = source_array.Element;
 						if (!TypeManager.IsReferenceType (source_type))
 							return null;
 
 						var target_element = target_array.Element;
 						if (!TypeManager.IsReferenceType (target_element))
 							return null;
 
 						if (ExplicitReferenceConversionExists (source_type, target_element))
 							return source == null ? EmptyExpression.Null 
 							
 						return null;
 					}
 				}
 
 				//
 				// From a single-dimensional array type S[] to System.Collections.Generic.IList<T> and its base interfaces, 
 				// provided that there is an explicit reference conversion from S to T
 				//
 				if (ArrayToIList (source_array, target_type, true))
 					return source == null ? EmptyExpression.Null 
 
 				return null;
 			}
 
 			//
 			// From any class type S to any interface T, provides S is not sealed
 			// and provided S does not implement T.
 			//
 			if (target_type.IsInterface && !source_type.IsSealed && !source_type.ImplementsInterface (target_type, true)) {
 				return source == null ? EmptyExpression.Null 
 			}
 
 			//
 			// From System delegate to any delegate-type
 			//
 			if (source_type == TypeManager.delegate_type && TypeManager.IsDelegateType (target_type))
 				return source == null ? EmptyExpression.Null 
 
 			//
 			// From variant generic delegate to same variant generic delegate type
 			//
 			if (source_type.IsDelegate && target_type.IsDelegate && source_type.MemberDefinition == target_type.MemberDefinition) {
 				var tparams = source_type.MemberDefinition.TypeParameters;
 				var targs_src = source_type.TypeArguments;
 				var targs_dst = target_type.TypeArguments;
 				int i;
 				for (i = 0; i < tparams.Length; ++i) {
 					//
 					// If TP is invariant, types have to be identical
 					//
 					if (TypeSpecComparer.IsEqual (targs_src[i], targs_dst[i]))
 						continue;
 
 					if (tparams[i].Variance == Variance.Covariant) {
 						//
 						//If TP is covariant, an implicit or explicit identity or reference conversion is required
 						//
 						if (ImplicitReferenceConversionExists (new EmptyExpression (targs_src[i]), targs_dst[i]))
 							continue;
 
 						if (ExplicitReferenceConversionExists (targs_src[i], targs_dst[i]))
 							continue;
 
 					} else if (tparams[i].Variance == Variance.Contravariant) {
 						//
 						//If TP is contravariant, both are either identical or reference types
 						//
 						if (TypeManager.IsReferenceType (targs_src[i]) && TypeManager.IsReferenceType (targs_dst[i]))
 							continue;
 					}
 
 					break;
 				for (i = 0; i < tparams.Length; ++i) {
 					//
 					// If TP is invariant, types have to be identical
 					//
 					if (TypeSpecComparer.IsEqual (targs_src[i], targs_dst[i]))
 						continue;
 
 					if (tparams[i].Variance == Variance.Covariant) {
 						//
 						//If TP is covariant, an implicit or explicit identity or reference conversion is required
 						//
 						if (ImplicitReferenceConversionExists (new EmptyExpression (targs_src[i]), targs_dst[i]))
 							continue;
 
 						if (ExplicitReferenceConversionExists (targs_src[i], targs_dst[i]))
 							continue;
 
 					} else if (tparams[i].Variance == Variance.Contravariant) {
 						//
 						//If TP is contravariant, both are either identical or reference types
 						//
 						if (TypeManager.IsReferenceType (targs_src[i]) && TypeManager.IsReferenceType (targs_dst[i]))
 							continue;
 					}
 
 					break;
 				}
 
 				if (i == tparams.Length)
 					return source == null ? EmptyExpression.Null 
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="317" endline="459">
<![CDATA[
 
 		protected static void WriteType(ModuleBuilder module, ByteBuffer bb, Type type)
 		{
 			while (type.HasElementType)
 			{
 				if (type.__IsVector)
 				{
 					bb.Write(ELEMENT_TYPE_SZARRAY);
 				}
 				else if (type.IsArray)
 				{
 					int rank = type.GetArrayRank();
 					bb.Write(ELEMENT_TYPE_ARRAY);
 					// LAMESPEC the Type production (23.2.12) doesn't include CustomMod* for arrays, but the verifier allows it and ildasm also supports it
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, type.__GetRequiredCustomModifiers());
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, type.__GetOptionalCustomModifiers());
 					WriteType(module, bb, type.GetElementType());
 					bb.WriteCompressedInt(rank);
 					// since a Type doesn't contain the lower/upper bounds
 					// (they act like a custom modifier, so they are part of the signature, but not of the Type),
 					// we set them to the C# compatible values and hope for the best
 					bb.WriteCompressedInt(0);	// boundsCount
 					bb.WriteCompressedInt(rank);	// loCount
 					for (int i = 0; i < rank; i++)
 					{
 						bb.WriteCompressedInt(0);
 					}
 					for (int i = 0; i < rank; i++)
 					{
 						bb.WriteCompressedInt(0);
 					}
 					return;
 				}
 				else if (type.IsByRef)
 				{
 					bb.Write(ELEMENT_TYPE_BYREF);
 				}
 				else if (type.IsPointer)
 				{
 					bb.Write(ELEMENT_TYPE_PTR);
 				}
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, type.__GetRequiredCustomModifiers());
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, type.__GetOptionalCustomModifiers());
 				type = type.GetElementType();
 			}
 			while (type.HasElementType)
 			{
 				if (type.__IsVector)
 				{
 					bb.Write(ELEMENT_TYPE_SZARRAY);
 				}
 				else if (type.IsArray)
 				{
 					int rank = type.GetArrayRank();
 					bb.Write(ELEMENT_TYPE_ARRAY);
 					// LAMESPEC the Type production (23.2.12) doesn't include CustomMod* for arrays, but the verifier allows it and ildasm also supports it
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, type.__GetRequiredCustomModifiers());
 					WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, type.__GetOptionalCustomModifiers());
 					WriteType(module, bb, type.GetElementType());
 					bb.WriteCompressedInt(rank);
 					// since a Type doesn't contain the lower/upper bounds
 					// (they act like a custom modifier, so they are part of the signature, but not of the Type),
 					// we set them to the C# compatible values and hope for the best
 					bb.WriteCompressedInt(0);	// boundsCount
 					bb.WriteCompressedInt(rank);	// loCount
 					for (int i = 0; i < rank; i++)
 					{
 						bb.WriteCompressedInt(0);
 					}
 					return;
 				}
 				else if (type.IsByRef)
 				{
 					bb.Write(ELEMENT_TYPE_BYREF);
 				}
 				else if (type.IsPointer)
 				{
 					bb.Write(ELEMENT_TYPE_PTR);
 				}
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, type.__GetRequiredCustomModifiers());
 				WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, type.__GetOptionalCustomModifiers());
 				type = type.GetElementType();
 			}
 			Universe u = module.universe;
 			if (type == u.System_Void)
 			{
 				bb.Write(ELEMENT_TYPE_VOID);
 			}
 			else if (type == u.System_Boolean)
 			{
 				bb.Write(ELEMENT_TYPE_BOOLEAN);
 			}
 			else if (type == u.System_Char)
 			{
 				bb.Write(ELEMENT_TYPE_CHAR);
 			}
 			else if (type == u.System_SByte)
 			{
 				bb.Write(ELEMENT_TYPE_I1);
 			}
 			else if (type == u.System_Byte)
 			{
 				bb.Write(ELEMENT_TYPE_U1);
 			}
 			else if (type == u.System_Int16)
 			{
 				bb.Write(ELEMENT_TYPE_I2);
 			}
 			else if (type == u.System_UInt16)
 			{
 				bb.Write(ELEMENT_TYPE_U2);
 			}
 			else if (type == u.System_Int32)
 			{
 				bb.Write(ELEMENT_TYPE_I4);
 			}
 			else if (type == u.System_UInt32)
 			{
 				bb.Write(ELEMENT_TYPE_U4);
 			}
 			else if (type == u.System_Int64)
 			{
 				bb.Write(ELEMENT_TYPE_I8);
 			}
 			else if (type == u.System_UInt64)
 			{
 				bb.Write(ELEMENT_TYPE_U8);
 			}
 			else if (type == u.System_Single)
 			{
 				bb.Write(ELEMENT_TYPE_R4);
 			}
 			else if (type == u.System_Double)
 			{
 				bb.Write(ELEMENT_TYPE_R8);
 			}
 			else if (type == u.System_String)
 			{
 				bb.Write(ELEMENT_TYPE_STRING);
 			}
 			else if (type == u.System_IntPtr)
 			{
 				bb.Write(ELEMENT_TYPE_I);
 			}
 			else if (type == u.System_UIntPtr)
 			{
 				bb.Write(ELEMENT_TYPE_U);
 			}
 			else if (type == u.System_TypedReference)
 			{
 				bb.Write(ELEMENT_TYPE_TYPEDBYREF);
 			}
 			else if (type == u.System_Object)
 			{
 				bb.Write(ELEMENT_TYPE_OBJECT);
 			}
 			else if (type.IsGenericParameter)
 			{
 				if (type is UnboundGenericMethodParameter || type.DeclaringMethod != null)
 				{
 					bb.Write(ELEMENT_TYPE_MVAR);
 				}
 				else
 				{
 					bb.Write(ELEMENT_TYPE_VAR);
 				}
 				bb.WriteCompressedInt(type.GenericParameterPosition);
 			}
 			else if (type.IsGenericType)
 			{
 				WriteGenericSignature(module, bb, type);
 			}
 			else
 			{
 				if (type.IsValueType)
 				{
 					bb.Write(ELEMENT_TYPE_VALUETYPE);
 				}
 				else
 				{
 					bb.Write(ELEMENT_TYPE_CLASS);
 				}
 				bb.WriteTypeDefOrRefEncoded(module.GetTypeToken(type).Token);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1478" endline="1487">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			expr.Emit (ec);
 
 			ec.Emit (OpCodes.Isinst, type);
 
 			if (TypeManager.IsGenericParameter (type) || TypeManager.IsNullableType (type))
 				ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="602" endline="635">
<![CDATA[
 
 		internal int ImportType(Type type)
 		{
 			int token;
 			if (!typeTokens.TryGetValue(type, out token))
 			{
 				if (type.HasElementType || (type.IsGenericType && !type.IsGenericTypeDefinition))
 				{
 					ByteBuffer spec = new ByteBuffer(5);
 					Signature.WriteTypeSpec(this, spec, type);
 					token = 0x1B000000 | this.TypeSpec.AddRecord(this.Blobs.Add(spec));
 				}
 				else
 				{
 					TypeRefTable.Record rec = new TypeRefTable.Record();
 					if (type.IsNested)
 					{
 						rec.ResolutionScope = GetTypeToken(type.DeclaringType).Token;
 						rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 						rec.TypeNameSpace = 0;
 					}
 					else
 					{
 						rec.ResolutionScope = ImportAssemblyRef(type.Assembly);
 						rec.TypeName = this.Strings.Add(TypeNameParser.Unescape(type.Name));
 						string ns = type.Namespace;
 						rec.TypeNameSpace = ns == null ? 0 
 					}
 					token = 0x01000000 | this.TypeRef.AddRecord(rec);
 				}
 				typeTokens.Add(type, token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1427" endline="1440">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			ConstructorBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1781" endline="1971">
<![CDATA[
 
 		protected override bool DoDefineMembers ()
 		{
 			if (!base.DoDefineMembers ())
 				return false;
 
 			Location loc = Location;
 
 			var equals_parameters = ParametersCompiled.CreateFullyResolved (
 				new Parameter (new TypeExpression (TypeManager.object_type, loc), "obj", 0, null, loc),	TypeManager.object_type);
 
 			Method equals = new Method (this, null, new TypeExpression (TypeManager.bool_type, loc),
 				Modifiers.PUBLIC | Modifiers.OVERRIDE | Modifiers.DEBUGGER_HIDDEN, new MemberName ("Equals", loc),
 				equals_parameters, null);
 
 			equals_parameters[0].Resolve (equals, 0);
 
 			Method tostring = new Method (this, null, new TypeExpression (TypeManager.string_type, loc),
 				Modifiers.PUBLIC | Modifiers.OVERRIDE | Modifiers.DEBUGGER_HIDDEN, new MemberName ("ToString", loc),
 				Mono.CSharp.ParametersCompiled.EmptyReadOnlyParameters, null);
 
 			ToplevelBlock equals_block = new ToplevelBlock (Compiler, equals.ParameterInfo, loc);
 
 			TypeExpr current_type;
 			if (type_params != null) {
 				var targs = new TypeArguments ();
 				foreach (var type_param in type_params)
 					targs.Add (new TypeParameterExpr (type_param, type_param.Location));
 				foreach (var type_param in type_params)
 					targs.Add (new TypeParameterExpr (type_param, type_param.Location));
 
 				current_type = new GenericTypeExpr (Definition, targs, loc);
 			} else {
 				current_type = new TypeExpression (Definition, loc);
 			}
 
 			var li_other = LocalVariable.CreateCompilerGenerated (CurrentType, equals_block, loc);
 			equals_block.AddStatement (new BlockVariableDeclaration (new TypeExpression (li_other.Type, loc), li_other));
 			var other_variable = new LocalVariableReference (li_other, loc);
 
 			MemberAccess system_collections_generic = new MemberAccess (new MemberAccess (
 				new QualifiedAliasMember ("global", "System", loc), "Collections", loc), "Generic", loc);
 
 			Expression rs_equals = null;
 			Expression string_concat = new StringConstant ("{", loc);
 			Expression rs_hashcode = new IntConstant (-2128831035, loc);
 			for (int i = 0; i < parameters.Count; ++i) {
 				var p = parameters [i];
 				var f = Fields [i];
 
 				MemberAccess equality_comparer = new MemberAccess (new MemberAccess (
 					system_collections_generic, "EqualityComparer",
 						new TypeArguments (new SimpleName (CurrentTypeParameters [i].Name, loc)), loc),
 						"Default", loc);
 
 				Arguments arguments_equal = new Arguments (2);
 				arguments_equal.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				arguments_equal.Add (new Argument (new MemberAccess (other_variable, f.Name)));
 
 				Expression field_equal = new Invocation (new MemberAccess (equality_comparer,
 					"Equals", loc), arguments_equal);
 
 				Arguments arguments_hashcode = new Arguments (1);
 				arguments_hashcode.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				Expression field_hashcode = new Invocation (new MemberAccess (equality_comparer,
 					"GetHashCode", loc), arguments_hashcode);
 
 				IntConstant FNV_prime = new IntConstant (16777619, loc);				
 				rs_hashcode = new Binary (Binary.Operator.Multiply,
 					new Binary (Binary.Operator.ExclusiveOr, rs_hashcode, field_hashcode, loc),
 					FNV_prime, loc);
 
 				Expression field_to_string = new Conditional (new BooleanExpression (new Binary (Binary.Operator.Inequality,
 					new MemberAccess (new This (f.Location), f.Name), new NullLiteral (loc), loc)),
 					new Invocation (new MemberAccess (
 						new MemberAccess (new This (f.Location), f.Name), "ToString"), null),
 					new StringConstant (string.Empty, loc), loc);
 
 				if (rs_equals == null) {
 					rs_equals = field_equal;
 					string_concat = new Binary (Binary.Operator.Addition,
 						string_concat,
 						new Binary (Binary.Operator.Addition,
 							new StringConstant (" " + p.Name + " = ", loc),
 							field_to_string,
 							loc),
 						loc);
 					continue;
 				}
 
 				//
 				// Implementation of ToString () body using string concatenation
 				//				
 				string_concat = new Binary (Binary.Operator.Addition,
 					new Binary (Binary.Operator.Addition,
 						string_concat,
 						new StringConstant (", " + p.Name + " = ", loc),
 						loc),
 					field_to_string,
 					loc);
 
 				rs_equals = new Binary (Binary.Operator.LogicalAnd, rs_equals, field_equal, loc);
 			}
 			for (int i = 0; i < parameters.Count; ++i) {
 				var p = parameters [i];
 				var f = Fields [i];
 
 				MemberAccess equality_comparer = new MemberAccess (new MemberAccess (
 					system_collections_generic, "EqualityComparer",
 						new TypeArguments (new SimpleName (CurrentTypeParameters [i].Name, loc)), loc),
 						"Default", loc);
 
 				Arguments arguments_equal = new Arguments (2);
 				arguments_equal.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				arguments_equal.Add (new Argument (new MemberAccess (other_variable, f.Name)));
 
 				Expression field_equal = new Invocation (new MemberAccess (equality_comparer,
 					"Equals", loc), arguments_equal);
 
 				Arguments arguments_hashcode = new Arguments (1);
 				arguments_hashcode.Add (new Argument (new MemberAccess (new This (f.Location), f.Name)));
 				Expression field_hashcode = new Invocation (new MemberAccess (equality_comparer,
 					"GetHashCode", loc), arguments_hashcode);
 
 				IntConstant FNV_prime = new IntConstant (16777619, loc);				
 				rs_hashcode = new Binary (Binary.Operator.Multiply,
 					new Binary (Binary.Operator.ExclusiveOr, rs_hashcode, field_hashcode, loc),
 					FNV_prime, loc);
 
 				Expression field_to_string = new Conditional (new BooleanExpression (new Binary (Binary.Operator.Inequality,
 					new MemberAccess (new This (f.Location), f.Name), new NullLiteral (loc), loc)),
 					new Invocation (new MemberAccess (
 						new MemberAccess (new This (f.Location), f.Name), "ToString"), null),
 					new StringConstant (string.Empty, loc), loc);
 
 				if (rs_equals == null) {
 					rs_equals = field_equal;
 					string_concat = new Binary (Binary.Operator.Addition,
 						string_concat,
 						new Binary (Binary.Operator.Addition,
 							new StringConstant (" " + p.Name + " = ", loc),
 							field_to_string,
 							loc),
 						loc);
 					continue;
 				}
 
 				//
 				// Implementation of ToString () body using string concatenation
 				//				
 				string_concat = new Binary (Binary.Operator.Addition,
 					new Binary (Binary.Operator.Addition,
 						string_concat,
 						new StringConstant (", " + p.Name + " = ", loc),
 						loc),
 					field_to_string,
 					loc);
 
 				rs_equals = new Binary (Binary.Operator.LogicalAnd, rs_equals, field_equal, loc);
 			}
 
 			string_concat = new Binary (Binary.Operator.Addition,
 				string_concat,
 				new StringConstant (" }", loc),
 				loc);
 
 			//
 			// Equals (object obj) override
 			//		
 			var other_variable_assign = new TemporaryVariableReference (li_other, loc);
 			equals_block.AddStatement (new StatementExpression (
 				new SimpleAssign (other_variable_assign,
 					new As (equals_block.GetParameterReference (0, loc),
 						current_type, loc), loc)));
 
 			Expression equals_test = new Binary (Binary.Operator.Inequality, other_variable, new NullLiteral (loc), loc);
 			if (rs_equals != null)
 				equals_test = new Binary (Binary.Operator.LogicalAnd, equals_test, rs_equals, loc);
 			equals_block.AddStatement (new Return (equals_test, loc));
 
 			equals.Block = equals_block;
 			equals.Define ();
 			AddMethod (equals);
 
 			//
 			// GetHashCode () override
 			//
 			Method hashcode = new Method (this, null, new TypeExpression (TypeManager.int32_type, loc),
 				Modifiers.PUBLIC | Modifiers.OVERRIDE | Modifiers.DEBUGGER_HIDDEN,
 				new MemberName ("GetHashCode", loc),
 				Mono.CSharp.ParametersCompiled.EmptyReadOnlyParameters, null);
 
 			//
 			// Modified FNV with good avalanche behavior and uniform
 			// distribution with larger hash sizes.
 			//
 			// const int FNV_prime = 16777619;
 			// int hash = (int) 2166136261;
 			// foreach (int d in data)
 			//     hash = (hash ^ d) * FNV_prime;
 			// hash += hash << 13;
 			// hash ^= hash >> 7;
 			// hash += hash << 3;
 			// hash ^= hash >> 17;
 			// hash += hash << 5;
 
 			ToplevelBlock hashcode_top = new ToplevelBlock (Compiler, loc);
 			Block hashcode_block = new Block (hashcode_top, loc, loc);
 			hashcode_top.AddStatement (new Unchecked (hashcode_block, loc));
 
 			var li_hash = LocalVariable.CreateCompilerGenerated (TypeManager.int32_type, hashcode_top, loc);
 			hashcode_block.AddStatement (new BlockVariableDeclaration (new TypeExpression (li_hash.Type, loc), li_hash));
 			LocalVariableReference hash_variable_assign = new LocalVariableReference (li_hash, loc);
 			hashcode_block.AddStatement (new StatementExpression (
 				new SimpleAssign (hash_variable_assign, rs_hashcode)));
 
 			var hash_variable = new LocalVariableReference (li_hash, loc);
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.Addition, hash_variable,
 					new Binary (Binary.Operator.LeftShift, hash_variable, new IntConstant (13, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.ExclusiveOr, hash_variable,
 					new Binary (Binary.Operator.RightShift, hash_variable, new IntConstant (7, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.Addition, hash_variable,
 					new Binary (Binary.Operator.LeftShift, hash_variable, new IntConstant (3, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.ExclusiveOr, hash_variable,
 					new Binary (Binary.Operator.RightShift, hash_variable, new IntConstant (17, loc), loc), loc)));
 			hashcode_block.AddStatement (new StatementExpression (
 				new CompoundAssign (Binary.Operator.Addition, hash_variable,
 					new Binary (Binary.Operator.LeftShift, hash_variable, new IntConstant (5, loc), loc), loc)));
 
 			hashcode_block.AddStatement (new Return (hash_variable, loc));
 			hashcode.Block = hashcode_top;
 			hashcode.Define ();
 			AddMethod (hashcode);
 
 			//
 			// ToString () override
 			//
 
 			ToplevelBlock tostring_block = new ToplevelBlock (Compiler, loc);
 			tostring_block.AddStatement (new Return (string_concat, loc));
 			tostring.Block = tostring_block;
 			tostring.Define ();
 			AddMethod (tostring);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="130" endline="285">
<![CDATA[
 
 		// <summary>
 		//   This routine will attempt to simplify the unary expression when the
 		//   argument is a constant.
 		// </summary>
 		Constant TryReduceConstant (ResolveContext ec, Constant e)
 		{
 			if (e is EmptyConstantCast)
 				return TryReduceConstant (ec, ((EmptyConstantCast) e).child);
 			
 			if (e is SideEffectConstant) {
 				Constant r = TryReduceConstant (ec, ((SideEffectConstant) e).value);
 				return r == null ? null 
 			}
 
 			TypeSpec expr_type = e.Type;
 			
 			switch (Oper){
 			case Operator.UnaryPlus
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type || expr_type == TypeManager.uint32_type ||
 				    expr_type == TypeManager.int64_type || expr_type == TypeManager.uint64_type ||
 				    expr_type == TypeManager.float_type || expr_type == TypeManager.double_type ||
 				    expr_type == TypeManager.decimal_type) {
 					return e;
 				}
 				
 				return null;
 				
 			case Operator.UnaryNegation
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (-((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (-((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (-((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (-((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (-((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type) {
 					int value = ((IntConstant)e).Value;
 					if (value == int.MinValue) {
 						if (ec.ConstantCheckState) {
 							ConstantFold.Error_CompileTimeOverflow (ec, loc);
 							return null;
 						}
 						return e;
 					}
 					return new IntConstant (-value, e.Location);
 				}
 				if (expr_type == TypeManager.int64_type) {
 					long value = ((LongConstant)e).Value;
 					if (value == long.MinValue) {
 						if (ec.ConstantCheckState) {
 							ConstantFold.Error_CompileTimeOverflow (ec, loc);
 							return null;
 						}
 						return e;
 					}
 					return new LongConstant (-value, e.Location);
 				}
 				
 				if (expr_type == TypeManager.uint32_type) {
 					UIntLiteral uil = e as UIntLiteral;
 					if (uil != null) {
 						if (uil.Value == int.MaxValue + (uint) 1)
 							return new IntLiteral (int.MinValue, e.Location);
 						return new LongLiteral (-uil.Value, e.Location);
 					}
 					return new LongConstant (-((UIntConstant)e).Value, e.Location);
 				}
 				
 				if (expr_type == TypeManager.uint64_type) {
 					ULongLiteral ull = e as ULongLiteral;
 					if (ull != null && ull.Value == 9223372036854775808)
 						return new LongLiteral (long.MinValue, e.Location);
 					return null;
 				}
 				
 				if (expr_type == TypeManager.float_type) {
 					FloatLiteral fl = e as FloatLiteral;
 					// For better error reporting
 					if (fl != null)
 						return new FloatLiteral (-fl.Value, e.Location);
 
 					return new FloatConstant (-((FloatConstant)e).Value, e.Location);
 				}
 				if (expr_type == TypeManager.double_type) {
 					DoubleLiteral dl = e as DoubleLiteral;
 					// For better error reporting
 					if (dl != null)
 						return new DoubleLiteral (-dl.Value, e.Location);
 
 					return new DoubleConstant (-((DoubleConstant)e).Value, e.Location);
 				}
 				if (expr_type == TypeManager.decimal_type)
 					return new DecimalConstant (-((DecimalConstant)e).Value, e.Location);
 				
 				return null;
 				
 			case Operator.LogicalNot
 				if (expr_type != TypeManager.bool_type)
 					return null;
 				
 				bool b = (bool)e.GetValue ();
 				return new BoolConstant (!b, e.Location);
 				
 			case Operator.OnesComplement
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (~((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (~((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (~((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (~((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (~((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type)
 					return new IntConstant (~((IntConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.uint32_type)
 					return new UIntConstant (~((UIntConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.int64_type)
 					return new LongConstant (~((LongConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.uint64_type){
 					return new ULongConstant (~((ULongConstant)e).Value, e.Location);
 				}
 				if (e is EnumConstant) {
 					e = TryReduceConstant (ec, ((EnumConstant)e).Child);
 					if (e != null)
 						e = new EnumConstant (e, expr_type);
 					return e;
 				}
 				return null;
 			}
 			throw new Exception ("Can not constant fold
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="778" endline="831">
<![CDATA[
 		}		
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="606" endline="623">
<![CDATA[
 
 		public override FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 		{
 			if ((metadataToken >> 24) == FieldTable.Index)
 			{
 				int index = (metadataToken & 0xFFFFFF) - 1;
 				return GetFieldAt(null, index);
 			}
 			else if ((metadataToken >> 24) == MemberRefTable.Index)
 			{
 				FieldInfo field = GetMemberRef((metadataToken & 0xFFFFFF) - 1, genericTypeArguments, genericMethodArguments) as FieldInfo;
 				if (field != null)
 				{
 					return field;
 				}
 			}
 			throw new ArgumentOutOfRangeException();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="3231" endline="3268">
<![CDATA[
 
 		int TokenizeBackslash ()
 		{
 			int c = get_char ();
 			tokens_seen = true;
 			if (c == '\'') {
 				val = new CharLiteral ((char) c, Location);
 				Report.Error (1011, Location, "Empty character literal");
 				return Token.LITERAL;
 			}
 
 			if (c == '\r' || c == '\n') {
 				Report.Error (1010, Location, "Newline in constant");
 				return Token.ERROR;
 			}
 
 			int d;
 			c = escape (c, out d);
 			if (c == -1)
 				return Token.ERROR;
 			if (d != 0)
 				throw new NotImplementedException ();
 
 			val = new CharLiteral ((char) c, Location);
 			c = get_char ();
 
 			if (c != '\'') {
 				Report.Error (1012, Location, "Too many characters in character literal");
 
 				// Try to recover, read until newline or next "'"
 				while ((c = get_char ()) != -1) {
 					if (c == '\n' || c == '\'')
 						break;
 				}
 				while ((c = get_char ()) != -1) {
 					if (c == '\n' || c == '\'')
 						break;
 				}
 			}
 
 			return Token.LITERAL;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="660" endline="670">
<![CDATA[
 
 	public static bool IsBuiltinOrEnum (TypeSpec t)
 	{
 		if (IsBuiltinType (t))
 			return true;
 		
 		if (IsEnumType (t))
 			return true;
 
 		return false;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="50" endline="57">
<![CDATA[
 	}
 
 	static class NullableInfo
 	{
 		public static MethodSpec GetConstructor (TypeSpec nullableType)
 		{
 			return TypeManager.GetPredefinedConstructor (nullableType, Location.Null, GetUnderlyingType (nullableType));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="423" endline="429">
<![CDATA[
 
 		public ReportPrinter SetPrinter (ReportPrinter printer)
 		{
 			ReportPrinter old = this.printer;
 			this.printer = printer;
 			return old;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="327" endline="337">
<![CDATA[
 
 		public void AddConstant (Const constant)
 		{
 			if (!AddMember (constant))
 				return;
 
 			if (constants == null)
 				constants = new List<MemberCore> ();
 			
 			constants.Add (constant);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="527" endline="537">
<![CDATA[
 
 		public void AddEvent (Event e)
 		{
 			if (!AddMember (e))
 				return;
 
 			if (events == null)
 				events = new List<MemberCore> ();
 
 			events.Add (e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="552" endline="562">
<![CDATA[
 
 		public void AddOperator (Operator op)
 		{
 			if (!AddMember (op))
 				return;
 
 			if (operators == null)
 				operators = new List<MemberCore> ();
 
 			operators.Add (op);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1196" endline="1207">
<![CDATA[
 
 		AnonymousMethodBody CompatibleMethodBody (ResolveContext ec, TypeInferenceContext tic, TypeSpec return_type, TypeSpec delegate_type)
 		{
 			ParametersCompiled p = ResolveParameters (ec, tic, delegate_type);
 			if (p == null)
 				return null;
 
 			ParametersBlock b = ec.IsInProbingMode ? (ParametersBlock) Block.PerformClone () 
 
 			return CompatibleMethodFactory (return_type, delegate_type, p, b);
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="869" endline="888">
<![CDATA[
 
 		TypeSpec CompatibleChecks (ResolveContext ec, TypeSpec delegate_type)
 		{
 			if (delegate_type.IsDelegate)
 				return delegate_type;
 
 			if (delegate_type.IsGeneric && delegate_type.GetDefinition () == TypeManager.expression_type) {
 				delegate_type = delegate_type.TypeArguments [0];
 				if (delegate_type.IsDelegate)
 					return delegate_type;
 
 				ec.Report.Error (835, loc, "Cannot convert `{0}' to an expression tree of non-delegate type `{1}'",
 					GetSignatureForError (), TypeManager.CSharpName (delegate_type));
 				return null;
 			}
 
 			ec.Report.Error (1660, loc, "Cannot convert `{0}' to non-delegate type `{1}'",
 				      GetSignatureForError (), TypeManager.CSharpName (delegate_type));
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="74" endline="82">
<![CDATA[
 
 		public Constant ImplicitConversionRequired (ResolveContext ec, TypeSpec type, Location loc)
 		{
 			Constant c = ConvertImplicitly (ec, type);
 			if (c == null)
 				Error_ValueCannotBeConverted (ec, loc, type, false);
 
 			return c;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="35" endline="59">
<![CDATA[
 
 		/// <summary>
 		///   We already know that the statement is unreachable, but we still
 		///   need to resolve it to catch errors.
 		/// </summary>
 		public virtual bool ResolveUnreachable (BlockContext ec, bool warn)
 		{
 			//
 			// This conflicts with csc's way of doing this, but IMHO it's
 			// the right thing to do.
 			//
 			// If something is unreachable, we still check whether it's
 			// correct.  This means that you cannot use unassigned variables
 			// in unreachable code, for instance.
 			//
 
 			if (warn)
 				ec.Report.Warning (162, 2, loc, "Unreachable code detected");
 
 			ec.StartFlowBranching (FlowBranching.BranchingType.Block, loc);
 			bool ok = Resolve (ec);
 			ec.KillFlowBranching ();
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="1178" endline="1188">
<![CDATA[
 
 		public void WarningEnable (Location location, int code, Report Report)
 		{
 			if (!Report.CheckWarningCode (code, location))
 				return;
 
 			if (Report.IsWarningDisabledGlobally (code))
 				Report.Warning (1635, 1, location, "Cannot restore warning `CS{0
 
 			regions.Add (new Enable (location.Row, code));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2262" endline="2282">
<![CDATA[
 		
 		bool pp_unary (ref string s)
 		{
 			s = s.Trim ();
 			int len = s.Length;
 
 			if (len > 0){
 				if (s [0] == '!'){
 					if (len > 1 && s [1] == '='){
 						Error_InvalidDirective ();
 						return false;
 					}
 					s = s.Substring (1);
 					return ! pp_primary (ref s);
 				} else
 					return pp_primary (ref s);
 			} else {
 				Error_InvalidDirective ();
 				return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="3374" endline="3383">
<![CDATA[
 
 		//
 		// Checks if there was incorrect doc comments and raise
 		// warnings.
 		//
 		public void check_incorrect_doc_comment ()
 		{
 			if (xml_comment_buffer.Length > 0)
 				warn_incorrect_doc_comment ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="801" endline="808">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Return target = (Return) t;
 			// It's null for simple return;
 			if (Expr != null)
 				target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1084" endline="1091">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Throw target = (Throw) t;
 
 			if (expr != null)
 				target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7074" endline="7081">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Arglist target = (Arglist) t;
 
 			if (Arguments != null)
 				target.Arguments = Arguments.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8547" endline="8554">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			IndexerExpr target = (IndexerExpr) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9303" endline="9309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CollectionElementInitializer target = (CollectionElementInitializer) t;
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="3362" endline="3373">
<![CDATA[
 
 		//
 		// Updates current comment location.
 		//
 		private void update_comment_location ()
 		{
 			if (current_comment_location.IsNull) {
 				// "-2" is for heading "//" or "/*"
 				current_comment_location =
 					new Location (ref_line, hidden ? -1 
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="549" endline="559">
<![CDATA[
 
 		public void AddFile (SourceFileEntry file)
 		{
 			if (!creating)
 				throw new InvalidOperationException ();
 
 			if (include_files == null)
 				include_files = new List<SourceFileEntry> ();
 
 			include_files.Add (file);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="771" endline="790">
<![CDATA[
 		
 		//
 		// According to section 16.3.1 (using-alias-directive), the namespace-or-type-name is
 		// resolved as if the immediately containing namespace body has no using-directives.
 		//
 		// Section 16.3.2 says that the same rule is applied when resolving the namespace-name
 		// in the using-namespace-directive.
 		//
 		// To implement these rules, the expressions in the using directives are resolved using 
 		// the "doppelganger" (ghostly bodiless duplicate).
 		//
 		NamespaceEntry doppelganger;
 		NamespaceEntry Doppelganger {
 			get {
 				if (!IsImplicit && doppelganger == null) {
 					doppelganger = new NamespaceEntry (ctx, ImplicitParent, file, ns, true);
 					doppelganger.using_aliases = using_aliases;
 				}
 				return doppelganger;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="445" endline="458">
<![CDATA[
 		
 		public void AddMethod (MethodOrOperator method)
 		{
 			if (!AddToContainer (method, method.MemberName.Basename))
 				return;
 			
 			if (methods == null)
 				methods = new List<MemberCore> ();
 
 			if (method.MemberName.Left != null) 
 				AddMemberToList (method, methods, true);
 			else 
 				AddMemberToList (method, methods, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1163" endline="1181">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			//
 			// We use recurse to allow ourselfs to be the source
 			// of an assignment. This little hack prevents us from
 			// having to allocate another expression
 			//
 			if (recurse) {
 				((IAssignMethod) expr).Emit (ec, is_expr && (mode == Mode.PostIncrement || mode == Mode.PostDecrement));
 
 				operation.Emit (ec);
 
 				recurse = false;
 				return;
 			}
 
 			EmitCode (ec, true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1238" endline="1266">
<![CDATA[
 
 		bool decimal_digits (int c)
 		{
 			int d;
 			bool seen_digits = false;
 			
 			if (c != -1){
 				if (number_pos == max_number_size)
 					Error_NumericConstantTooLong ();
 				number_builder [number_pos++] = (char) c;
 			}
 			
 			//
 			// We use peek_char2, because decimal_digits needs to do a 
 			// 2-character look-ahead (5.ToString for example).
 			//
 			while ((d = peek_char2 ()) != -1){
 				if (d >= '0' && d <= '9'){
 					if (number_pos == max_number_size)
 						Error_NumericConstantTooLong ();
 					number_builder [number_pos++] = (char) d;
 					get_char ();
 					seen_digits = true;
 				} else
 					break;
 			}
 			while ((d = peek_char2 ()) != -1){
 				if (d >= '0' && d <= '9'){
 					if (number_pos == max_number_size)
 						Error_NumericConstantTooLong ();
 					number_builder [number_pos++] = (char) d;
 					get_char ();
 					seen_digits = true;
 				} else
 					break;
 			}
 			
 			return seen_digits;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="377" endline="385">
<![CDATA[
 #endif
 		protected virtual Expression ResolveConversions (ResolveContext ec)
 		{
 			source = Convert.ImplicitConversionRequired (ec, source, target.Type, loc);
 			if (source == null)
 				return null;
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="813" endline="865">
<![CDATA[
 	
 	bool ShowMember (MemberInfo mi)
 	{
 		if (mi.MemberType == MemberTypes.Constructor && ((MethodBase) mi).IsStatic)
 			return false;
 		
 		if (show_private)
 			return true;
 
 		if (filter_obsolete && mi.IsDefined (typeof (ObsoleteAttribute), false))
 			return false;
 		
 		switch (mi.MemberType) {
 		case MemberTypes.Constructor
 		case MemberTypes.Method
 			MethodBase mb = mi as MethodBase;
 		
 			if (mb.IsFamily || mb.IsPublic || mb.IsFamilyOrAssembly)
 				return true;
 			
 			if (MethodIsExplicitIfaceImpl (mb))
 				return true;
 					
 			return false;
 		
 		
 		case MemberTypes.Field
 			FieldInfo fi = mi as FieldInfo;
 		
 			if (fi.IsFamily || fi.IsPublic || fi.IsFamilyOrAssembly)
 				return true;
 			
 			return false;
 		
 		
 		case MemberTypes.NestedType
 		case MemberTypes.TypeInfo
 			Type t = mi as Type;
 		
 			switch (t.Attributes & TypeAttributes.VisibilityMask){
 			case TypeAttributes.Public
 			case TypeAttributes.NestedPublic
 			case TypeAttributes.NestedFamily
 			case TypeAttributes.NestedFamORAssem
 				return true;
 			}
 			
 			return false;
 		}
 		
 		// What am I !!!
 		return true;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="160" endline="168">
<![CDATA[
 		}
 
 		public PropertyInfo MetaInfo {
 			get {
 				if ((state & StateFlags.PendingMetaInflate) != 0)
 					throw new NotSupportedException ();
 
 				return info;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="818" endline="834">
<![CDATA[
 		}
 
 		public override bool HasUnresolvedConstraints {
 			get {
 				if (CurrentTypeParameters == null)
 					return false;
 
 				// When overriding base method constraints are fetched from
 				// base method but to find it we have to resolve parameters
 				// to find exact base method match
 				if (IsExplicitImpl || (ModFlags & Modifiers.OVERRIDE) != 0)
 					return base_method == null;
 
 				// Even for non-override generic method constraints check has to be
 				// delayed after all constraints are resolved
 				return true;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="3316" endline="3330">
<![CDATA[
 
 		//
 		// Handles one line xml comment
 		//
 		private void handle_one_line_xml_comment ()
 		{
 			int c;
 			while ((c = peek_char ()) == ' ')
 				get_char (); // skip heading whitespaces.
 			while ((c = peek_char ()) == ' ')
 				get_char (); // skip heading whitespaces.
 			while ((c = peek_char ()) != -1 && c != '\n' && c != '\r') {
 				xml_comment_buffer.Append ((char) get_char ());
 			}
 			while ((c = peek_char ()) != -1 && c != '\n' && c != '\r') {
 				xml_comment_buffer.Append ((char) get_char ());
 			}
 			if (c == '\r' || c == '\n')
 				xml_comment_buffer.Append (Environment.NewLine);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="209" endline="220">
<![CDATA[
 
 		internal override Type BindTypeParameters(IGenericBinder binder)
 		{
 			if (type != null)
 			{
 				return binder.BindTypeParameter(this);
 			}
 			else
 			{
 				return binder.BindMethodParameter(this);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="239" endline="251">
<![CDATA[
 		}
 
 		private void WriteRVA(MetadataWriter mw, uint rva)
 		{
 			if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 			{
 				mw.Write(rva);
 			}
 			else
 			{
 				mw.Write((ulong)rva);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2038" endline="2046">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			if (expr == null)
 				return;
 
 			ShimExpression target = (ShimExpression) t;
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="595" endline="603">
<![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (user_operator != null)
 				return user_operator.CreateExpressionTree (ec);
 
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2063" endline="2074">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			if (scope_initializers != null)
 				EmitScopeInitializers (ec);
 
 			ec.Mark (StartLocation);
 			DoEmit (ec);
 
 			if (SymbolWriter.HasSymbolWriter)
 				EmitSymbolInfo (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="110" endline="123">
<![CDATA[
 
 		static bool CheckConflictingInheritedConstraint (TypeParameterSpec spec, TypeSpec ba, TypeSpec bb, IMemberContext context, Location loc)
 		{
 			if (ba == bb)
 				return true;
 
 			if (TypeSpec.IsBaseClass (ba, bb, false) || TypeSpec.IsBaseClass (bb, ba, false))
 				return true;
 
 			context.Compiler.Report.Error (455, loc,
 				"Type parameter `{0}' inherits conflicting constraints `{1}' and `{2}'",
 				spec.Name, ba.GetSignatureForError (), bb.GetSignatureForError ());
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="585" endline="601">
<![CDATA[
 
 		internal int ImportMethodOrField(Type declaringType, string name, Signature sig)
 		{
 			int token;
 			if (!importedMemberRefs.TryGetValue(new MemberRefKey(declaringType, name, sig), out token))
 			{
 				MemberRefTable.Record rec = new MemberRefTable.Record();
 				rec.Class = GetTypeTokenForMemberRef(declaringType);
 				rec.Name = this.Strings.Add(name);
 				ByteBuffer bb = new ByteBuffer(16);
 				sig.WriteSig(this, bb);
 				rec.Signature = this.Blobs.Add(bb);
 				token = 0x0A000000 | this.MemberRef.AddRecord(rec);
 				importedMemberRefs.Add(new MemberRefKey(declaringType, name, sig), token);
 			}
 			return token;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="311" endline="322">
<![CDATA[
 
 		public static Expression Create (Expression expr, TypeSpec type)
 		{
 			//
 			// Avoid unwraping and wraping of the same type
 			//
 			Unwrap unwrap = expr as Unwrap;
 			if (unwrap != null && expr.Type == NullableInfo.GetUnderlyingType (type))
 				return unwrap.Original;
 		
 			return new Wrap (expr, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="570" endline="581">
<![CDATA[
 
 		public static IList<CustomAttributeData> __GetDeclarativeSecurity(Type type)
 		{
 			if ((type.Attributes & TypeAttributes.HasSecurity) != 0)
 			{
 				return type.Module.GetDeclarativeSecurity(type.MetadataToken);
 			}
 			else
 			{
 				return EmptyList;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="582" endline="593">
<![CDATA[
 
 		public static IList<CustomAttributeData> __GetDeclarativeSecurity(MethodBase method)
 		{
 			if ((method.Attributes & MethodAttributes.HasSecurity) != 0)
 			{
 				return method.Module.GetDeclarativeSecurity(method.MetadataToken);
 			}
 			else
 			{
 				return EmptyList;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\symbolwriter.cs" startline="127" endline="135">
<![CDATA[
 
 		public static int DefineNamespace (string name, CompileUnitEntry source,
 						   string[] using_clauses, int parent)
 		{
 			if (symwriter != null)
 				return symwriter.DefineNamespace (name, source, using_clauses, parent);
 			else
 				return -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="258" endline="268">
<![CDATA[
 
 		public bool CheckWarningCode (int code, Location loc)
 		{
 			if (AllWarningsHashSet == null)
 				AllWarningsHashSet = new HashSet<int> (AllWarnings);
 
 			if (AllWarningsHashSet.Contains (code))
 				return true;
 
 			return CheckWarningCode (code.ToString (), loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="181" endline="189">
<![CDATA[
 
 		public void OpenCompilerGeneratedBlock (int start_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.StartBlock (CodeBlockEntry.Type.CompilerGenerated,
 						   start_offset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="201" endline="211">
<![CDATA[
 
 		public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize)
 		{
 			if (parent == null && (attr & TypeAttributes.Interface) == 0)
 			{
 				parent = universe.System_Object;
 			}
 			TypeBuilder typeBuilder = new TypeBuilder(this, name, parent, attr);
 			PostDefineType(typeBuilder, packingSize, typesize);
 			return typeBuilder;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1655" endline="1669">
<![CDATA[
 
 		int EscapeUnicode (int ch, out int surrogate)
 		{
 			bool error;
 			if (ch == 'U') {
 				ch = getHex (8, out surrogate, out error);
 			} else {
 				ch = getHex (4, out surrogate, out error);
 			}
 
 			if (error)
 				Report.Error (1009, Location, "Unrecognized escape sequence");
 
 			return ch;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="349" endline="357">
<![CDATA[
 
 		public override MethodInfo GetGenericMethodDefinition()
 		{
 			if (gtpb == null)
 			{
 				throw new InvalidOperationException();
 			}
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="155" endline="167">
<![CDATA[
 		
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			base.CloneTo (clonectx, target);
 
 			AQueryClause t = (AQueryClause) target;
 
 			if (block != null)
 				t.block = (QueryBlock) clonectx.LookupBlock (block);
 
 			if (next != null)
 				t.next = (AQueryClause) next.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="466" endline="473">
<![CDATA[
 
 		public static MonoSymbolFile ReadSymbolFile (Assembly assembly)
 		{
 			string filename = assembly.Location;
 			string name = filename + ".mdb";
 
 			return new MonoSymbolFile (name, assembly);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="517" endline="524">
<![CDATA[
 
 		public override EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			EmitContext ec = new EmitContext (this, ig, MemberType);
 
 			ec.CurrentAnonymousMethod = host.Iterator;
 			return ec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9537" endline="9549">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression e = base.DoResolve (ec);
 			if (type == null)
 				return null;
 
 			Expression previous = ec.CurrentInitializerVariable;
 			ec.CurrentInitializerVariable = new InitializerTargetExpression (this);
 			initializers.Resolve (ec);
 			ec.CurrentInitializerVariable = previous;
 			return e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1950" endline="1961">
<![CDATA[
 
 		public bool ResolveConstructor (Location loc, params TypeSpec[] argType)
 		{
 			if (ctor != null)
 				throw new InternalErrorException ("Predefined ctor redefined");
 
 			if (Resolve (loc) == null)
 				return false;
 
 			ctor = TypeManager.GetPredefinedConstructor (type, loc, argType);
 			return ctor != null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="957" endline="978">
<![CDATA[
 
 		protected override Expression ResolveOperatorPredefined (ResolveContext ec, Binary.PredefinedOperator [] operators, bool primitives_only, TypeSpec enum_type)
 		{
 			Expression e = base.ResolveOperatorPredefined (ec, operators, primitives_only, enum_type);
 
 			if (e == this || enum_type != null)
 				return LiftResult (ec, e);
 
 			//
 			// 7.9.9 Equality operators and null
 			//
 			// The == and != operators permit one operand to be a value of a nullable type and
 			// the other to be the null literal, even if no predefined or user-defined operator
 			// (in unlifted or lifted form) exists for the operation.
 			//
 			if (e == null && (Oper & Operator.EqualityMask) != 0) {
 				if ((IsLeftNullLifted && right_unwrap != null) || (IsRightNullLifted && left_unwrap != null))
 					return LiftResult (ec, this);
 			}
 
 			return e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="242" endline="250">
<![CDATA[
 
 		internal void DefineCapturedScope (int scope_id, int id, string captured_name)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedScope (id, captured_name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4427" endline="4436">
<![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (3);
 			args.Add (new Argument (expr.CreateExpressionTree (ec)));
 			args.Add (new Argument (true_expr.CreateExpressionTree (ec)));
 			args.Add (new Argument (false_expr.CreateExpressionTree (ec)));
 			return CreateExpressionFactoryCall (ec, "Condition", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9525" endline="9536">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (base.CreateExpressionTree (ec)));
 			if (!initializers.IsEmpty)
 				args.Add (new Argument (initializers.CreateExpressionTree (ec)));
 
 			return CreateExpressionFactoryCall (ec,
 				initializers.IsCollectionInitializer ? "ListInit" 
 				args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="380" endline="409">
<![CDATA[
 
 		//
 		// Initializes all hoisted variables
 		//
 		public void EmitStoreyInstantiation (EmitContext ec, ExplicitBlock block)
 		{
 			// There can be only one instance variable for each storey type
 			if (Instance != null)
 				throw new InternalErrorException ();
 
 			SymbolWriter.OpenCompilerGeneratedBlock (ec);
 
 			//
 			// Create an instance of a storey
 			//
 			var storey_type_expr = CreateStoreyTypeExpression (ec);
 
 			ResolveContext rc = new ResolveContext (ec.MemberContext);
 			rc.CurrentBlock = block;
 			Expression e = new New (storey_type_expr, null, Location).Resolve (rc);
 			e.Emit (ec);
 
 			Instance = new LocalTemporary (storey_type_expr.Type);
 			Instance.Store (ec);
 
 			EmitHoistedFieldsInitialization (rc, ec);
 
 			SymbolWriter.DefineScopeVariable (ID, Instance.Builder);
 			SymbolWriter.CloseCompilerGeneratedBlock (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="796" endline="815">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			IteratorHost = (IteratorStorey) block.TopBlock.AnonymousMethodStorey;
 
 			BlockContext ctx = new BlockContext (ec, block, ReturnType);
 			ctx.CurrentAnonymousMethod = this;
 
 			ctx.StartFlowBranching (this, ec.CurrentBranching);
 			Block.Resolve (ctx);
 			ctx.EndFlowBranching ();
 
 			var move_next = new IteratorMethod (IteratorHost, new TypeExpression (TypeManager.bool_type, loc),
 				Modifiers.PUBLIC, new MemberName ("MoveNext", Location));
 			move_next.Block.AddStatement (new MoveNextMethodStatement (this));
 			IteratorHost.AddMethod (move_next);
 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="173" endline="192">
<![CDATA[
 
 		public virtual Expression BuildQueryClause (ResolveContext ec, Expression lSide, Parameter parameter)
 		{
 			Arguments args = null;
 			CreateArguments (ec, parameter, ref args);
 			lSide = CreateQueryExpression (lSide, args);
 			if (next != null) {
 				parameter = CreateChildrenParameters (parameter);
 
 				Select s = next as Select;
 				if (s == null || s.IsRequired (parameter))
 					return next.BuildQueryClause (ec, lSide, parameter);
 					
 				// Skip transparent select clause if any clause follows
 				if (next.next != null)
 					return next.next.BuildQueryClause (ec, lSide, parameter);
 			}
 
 			return lSide;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="837" endline="850">
<![CDATA[
 
 		public void AddUsingAlias (string alias, MemberName name, Location loc)
 		{
 			// TODO
 			if (DeclarationFound){
 				Compiler.Report.Error (1529, loc, "A using clause must precede all other namespace elements except extern alias declarations");
 			}
 
 			if (RootContext.Version != LanguageVersion.ISO_1 && alias == "global")
 				Compiler.Report.Warning (440, 2, loc, "An alias named `global' will not be used when resolving 'global
 					" the global namespace will be used instead");
 
 			AddUsingAlias (new LocalUsingAliasEntry (alias, name, loc));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6849" endline="6861">
<![CDATA[
 
 		protected virtual void Error_ThisNotAvailable (ResolveContext ec)
 		{
 			if (ec.IsStatic && !ec.HasSet (ResolveContext.Options.ConstantScope)) {
 				ec.Report.Error (26, loc, "Keyword `this' is not valid in a static property, static method, or static field initializer");
 			} else if (ec.CurrentAnonymousMethod != null) {
 				ec.Report.Error (1673, loc,
 					"Anonymous methods inside structs cannot access instance members of `this'. " +
 					"Consider copying `this' to a local variable outside the anonymous method and using the local instead");
 			} else {
 				ec.Report.Error (27, loc, "Keyword `this' is not available in the current context");
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="390" endline="407">
<![CDATA[
 
 		public static TypeSpec Resolve (ModuleContainer module, MemberKind kind, string ns, string name, int arity, Location loc)
 		{
 			Namespace type_ns = module.GlobalRootNamespace.GetNamespace (ns, true);
 			var te = type_ns.LookupType (module.Compiler, name, arity, false, Location.Null);
 			if (te == null) {
 				module.Compiler.Report.Error (518, loc, "The predefined type `{0}.{1}' is not defined or imported", ns, name);
 				return null;
 			}
 
 			var type = te.Type;
 			if (type.Kind != kind) {
 				module.Compiler.Report.Error (520, loc, "The predefined type `{0}.{1}' is not declared correctly", ns, name);
 				return null;
 			}
 
 			return type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="485" endline="492">
<![CDATA[
 
 		protected override bool AddMemberType (TypeContainer ds)
 		{
 			if (!AddToContainer (ds, ds.Name))
 				return false;
 			ds.NamespaceEntry.NS.AddType (ds.Definition);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="689" endline="700">
<![CDATA[
 
 		public sealed override bool Resolve (BlockContext ec)
 		{
 			if (!DoResolve (ec))
 				return false;
 
 			unwind_protect = ec.CurrentBranching.AddReturnOrigin (ec.CurrentBranching.CurrentUsageVector, this);
 			if (unwind_protect)
 				ec.NeedReturnLabel ();
 			ec.CurrentBranching.CurrentUsageVector.Goto ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="298" endline="305">
<![CDATA[
 
 		private MethodBuilder CreateMethodBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention)
 		{
 			this.ModuleBuilder.MethodDef.AddVirtualRecord();
 			MethodBuilder mb = new MethodBuilder(this, name, attributes, callingConvention);
 			methods.Add(mb);
 			return mb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1846" endline="1866">
<![CDATA[
 
 		protected override TypeExpr DoResolveAsTypeStep (IMemberContext ec)
 		{
 			if (!args.Resolve (ec))
 				return null;
 
 			TypeSpec[] atypes = args.Arguments;
 
 			//
 			// Now bind the parameters
 			//
 			type = open_type.MakeGenericType (atypes);
 
 			//
 			// Check constraints when context is not method/base type
 			//
 			if (!ec.HasUnresolvedConstraints)
 				CheckConstraints (ec);
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="198" endline="209">
<![CDATA[
 
 		private Module LoadModule(int index, byte[] rawModule, string location)
 		{
 			if ((manifestModule.File.records[index].Flags & ContainsNoMetaData) != 0)
 			{
 				return externalModules[index] = new ResourceModule(this, manifestModule.GetString(manifestModule.File.records[index].Name), location);
 			}
 			else
 			{
 				return externalModules[index] = new ModuleReader(this, manifestModule.universe, new MemoryStream(rawModule), location);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="338" endline="349">
<![CDATA[
 
 		public TypeContainer AddTypeContainer (TypeContainer tc)
 		{
 			if (!AddMemberType (tc))
 				return tc;
 
 			if (types == null)
 				types = new List<TypeContainer> ();
 
 			types.Add (tc);
 			return tc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1708" endline="1727">
<![CDATA[
 		
 		void putback (int c)
 		{
 			if (putback_char != -1){
 				Console.WriteLine ("Col
 				Console.WriteLine ("Row
 				Console.WriteLine ("Name
 				Console.WriteLine ("Current [{0}] putting back [{1}]  ", putback_char, c);
 				throw new Exception ("This should not happen putback on putback");
 			}
 			if (c == '\n' || col == 0) {
 				// It won't happen though.
 				line--;
 				ref_line--;
 				col = previous_col;
 			}
 			else
 				col--;
 			putback_char = c;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="210" endline="255">
<![CDATA[
 	}
 
 	class SectionHeader
 	{
 		public const DWORD IMAGE_SCN_CNT_CODE = 0x00000020;
 		public const DWORD IMAGE_SCN_CNT_INITIALIZED_DATA = 0x00000040;
 		public const DWORD IMAGE_SCN_MEM_DISCARDABLE = 0x02000000;
 		public const DWORD IMAGE_SCN_MEM_EXECUTE = 0x20000000;
 		public const DWORD IMAGE_SCN_MEM_READ = 0x40000000;
 		public const DWORD IMAGE_SCN_MEM_WRITE = 0x80000000;
 
 		public string Name;		// 8 byte UTF8 encoded 0-padded
 		public DWORD VirtualSize;
 		public DWORD VirtualAddress;
 		public DWORD SizeOfRawData;
 		public DWORD PointerToRawData;
 		public DWORD PointerToRelocations;
 		public DWORD PointerToLinenumbers;
 		public WORD NumberOfRelocations;
 		public WORD NumberOfLinenumbers;
 		public DWORD Characteristics;
 
 		internal void Read(BinaryReader br)
 		{
 			char[] name = new char[8];
 			int len = 8;
 			for (int i = 0; i < 8; i++)
 			{
 				byte b = br.ReadByte();
 				name[i] = (char)b;
 				if (b == 0 && len == 8)
 				{
 					len = i;
 				}
 			}
 			for (int i = 0; i < 8; i++)
 			{
 				byte b = br.ReadByte();
 				name[i] = (char)b;
 				if (b == 0 && len == 8)
 				{
 					len = i;
 				}
 			}
 			Name = new String(name, 0, len);
 			VirtualSize = br.ReadUInt32();
 			VirtualAddress = br.ReadUInt32();
 			SizeOfRawData = br.ReadUInt32();
 			PointerToRawData = br.ReadUInt32();
 			PointerToRelocations = br.ReadUInt32();
 			PointerToLinenumbers = br.ReadUInt32();
 			NumberOfRelocations = br.ReadUInt16();
 			NumberOfLinenumbers = br.ReadUInt16();
 			Characteristics = br.ReadUInt32();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6689" endline="6723">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (type != null)
 				return this;
 
 			dimensions = rank.Dimension;
 
 			best_type_inference = new InferenceContext ();
 
 			if (!ResolveInitializers (ec))
 				return null;
 
 			best_type_inference.FixAllTypes (ec);
 			array_element_type = best_type_inference.InferredTypeArguments[0];
 			best_type_inference = null;
 
 			if (array_element_type == null || array_element_type == InternalType.MethodGroup || array_element_type == InternalType.AnonymousMethod ||
 				arguments.Count != rank.Dimension) {
 				ec.Report.Error (826, loc,
 					"The type of an implicitly typed array cannot be inferred from the initializer. Try specifying array type explicitly");
 				return null;
 			}
 
 			//
 			// At this point we found common base type for all initializer elements
 			// but we have to be sure that all static initializer elements are of
 			// same type
 			//
 			UnifyInitializerElement (ec);
 
 			type = ArrayContainer.MakeType (array_element_type, dimensions);
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="97" endline="112">
<![CDATA[
 		}
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			bool res = base.CheckOverrideAgainstBase (base_member);
 
 			//
 			// Check that the permissions are not being changed
 			//
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				res = false;
 			}
 
 			return res;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1255" endline="1266">
<![CDATA[
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			var ok = base.CheckOverrideAgainstBase (base_member);
 
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				ok = false;
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="167" endline="179">
<![CDATA[
 
 		private static Type ReadTypeOrVoid(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			if (br.PeekByte() == ELEMENT_TYPE_VOID)
 			{
 				br.ReadByte();
 				return module.universe.System_Void;
 			}
 			else
 			{
 				return ReadType(module, br, context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="238" endline="250">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			if (prepare_for_load)
 				throw new NotImplementedException ();
 
 			source.Emit (ec);
 
 			Store (ec);
 
 			if (leave_copy)
 				Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="88" endline="101">
<![CDATA[
 
 		internal static FieldSignature ReadSig(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			if (br.ReadByte() != FIELD)
 			{
 				throw new BadImageFormatException();
 			}
 			Type fieldType;
 			Type[] optionalCustomModifiers;
 			Type[] requiredCustomModifiers;
 			ReadCustomModifiers(module, br, context, out requiredCustomModifiers, out optionalCustomModifiers);
 			fieldType = ReadType(module, br, context);
 			return new FieldSignature(fieldType, optionalCustomModifiers, requiredCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2843" endline="2853">
<![CDATA[
 
 		public virtual MemberExpr ResolveMemberAccess (ResolveContext ec, Expression left, SimpleName original)
 		{
 			if (left != null && left.IsNull && TypeManager.IsReferenceType (left.Type)) {
 				ec.Report.Warning (1720, 1, left.Location,
 					"Expression will always cause a `{0}'", "System.NullReferenceException");
 			}
 
 			InstanceExpression = left;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="387" endline="394">
<![CDATA[
 
 		public void UsingNamespace(string usingNamespace)
 		{
 			if (moduleBuilder.symbolWriter != null)
 			{
 				moduleBuilder.symbolWriter.UsingNamespace(usingNamespace);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="410" endline="420">
<![CDATA[
 
 		public ConstructorInfo Constructor
 		{
 			get
 			{
 				if (lazyConstructor == null)
 				{
 					lazyConstructor = (ConstructorInfo)module.ResolveMethod(module.CustomAttribute.records[index].Type);
 				}
 				return lazyConstructor;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="320" endline="334">
<![CDATA[
 
 		public void EmitArrayAddress (ArrayContainer ac)
 		{
 			if (ac.Element.IsGenericParameter)
 				ig.Emit (OpCodes.Readonly);
 
 			if (ac.Rank > 1) {
 				if (IsAnonymousStoreyMutateRequired)
 					ac = (ArrayContainer) ac.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 				ig.Emit (OpCodes.Call, ac.GetAddressMethod ());
 			} else {
 				Emit (OpCodes.Ldelema, ac.Element);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6252" endline="6265">
<![CDATA[
 }
 
 void start_block (Location loc)
 {
 	if (current_block == null) {
 		current_block = new ToplevelBlock (compiler, current_local_parameters, loc);
 		parsing_anonymous_method = false;
 	} else if (parsing_anonymous_method) {
 		current_block = new ParametersBlock (current_block, current_local_parameters, loc);
 		parsing_anonymous_method = false;
 	} else {
 		current_block = new ExplicitBlock (current_block, loc, Location.Null);
 	}
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="546" endline="555">
<![CDATA[
 
 		[Conditional ("FULL_AST")]
 		public void AppendTo (object existing, params Location[] locations)
 		{
 			Location[] locs;
 			if (simple_locs.TryGetValue (existing, out locs)) {
 				simple_locs [existing] = locs.Concat (locations).ToArray ();
 				return;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2004" endline="2015">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr != null) {
 				type = expr.Type;
 				eclass = expr.eclass;
 			}
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="808" endline="817">
<![CDATA[
 
 		#region Properties
 
 		public override TypeParameter[] CurrentTypeParameters {
 			get {
 				if (GenericMethod != null)
 					return GenericMethod.CurrentTypeParameters;
 
 				return null;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="719" endline="731">
<![CDATA[
 
 		public void Emit(OpCode opc, Type type)
 		{
 			Emit(opc);
 			if (opc == OpCodes.Ldtoken)
 			{
 				code.Write(moduleBuilder.GetTypeToken(type).Token);
 			}
 			else
 			{
 				code.Write(moduleBuilder.GetTypeTokenForMemberRef(type));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="285" endline="295">
<![CDATA[
 
 		public void Emit (OpCode opcode, MethodSpec method)
 		{
 			if (IsAnonymousStoreyMutateRequired)
 				method = method.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 			if (method.IsConstructor)
 				ig.Emit (opcode, (ConstructorInfo) method.GetMetaInfo ());
 			else
 				ig.Emit (opcode, (MethodInfo) method.GetMetaInfo ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="177" endline="185">
<![CDATA[
 
 		internal ByteReader Slice(int length)
 		{
 			if (end - pos < length)
 				throw new BadImageFormatException();
 			ByteReader br = new ByteReader(buffer, pos, length);
 			pos += length;
 			return br;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="202" endline="214">
<![CDATA[
 
 		protected override bool DefineNestedTypes ()
 		{
 			((EnumSpec) spec).UnderlyingType = base_type_expr == null ? TypeManager.int32_type 
 
 			TypeBuilder.DefineField (UnderlyingValueField, UnderlyingType.GetMetaInfo (),
 				FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
 
 			if (!RootContext.StdLib)
 				Module.hack_corlib_enums.Add (this);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="868" endline="877">
<![CDATA[
 
 		public Label LabelTarget (EmitContext ec)
 		{
 			if (defined)
 				return label;
 
 			label = ec.DefineLabel ();
 			defined = true;
 			return label;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="465" endline="473">
<![CDATA[
 
 		public void AddInterfaceImplementation(Type interfaceType)
 		{
 			if (interfaces == null)
 			{
 				interfaces = new List<Type>();
 			}
 			interfaces.Add(interfaceType);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="66" endline="74">
<![CDATA[
 
 		public void AddOtherMethod(MethodBuilder mdBuilder)
 		{
 			if (otherMethods == null)
 			{
 				otherMethods = new List<MethodBuilder>();
 			}
 			otherMethods.Add(mdBuilder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="171" endline="181">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddModule (ImportedModuleDefinition module)
 		{
 			if (added_modules == null) {
 				added_modules = new List<ImportedModuleDefinition> ();
 				added_modules.Add (module);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="298" endline="328">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			Label loop = ec.DefineLabel ();
 			Label old_begin = ec.LoopBegin;
 			Label old_end = ec.LoopEnd;
 			
 			ec.LoopBegin = ec.DefineLabel ();
 			ec.LoopEnd = ec.DefineLabel ();
 				
 			ec.MarkLabel (loop);
 			EmbeddedStatement.Emit (ec);
 			ec.MarkLabel (ec.LoopBegin);
 
 			//
 			// Dead code elimination
 			//
 			if (expr is Constant){
 				bool res = !((Constant) expr).IsDefaultValue;
 
 				expr.EmitSideEffect (ec);
 				if (res)
 					ec.Emit (OpCodes.Br, loop); 
 			} else
 				expr.EmitBranchable (ec, loop, true);
 			
 			ec.MarkLabel (ec.LoopEnd);
 
 			ec.LoopBegin = old_begin;
 			ec.LoopEnd = old_end;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="829" endline="854">
<![CDATA[
 
 		public void MarkLabel(Label loc)
 		{
 			Debug.Assert(stackHeight == -1 || labelStackHeight[loc.Index] == -1 || stackHeight == labelStackHeight[loc.Index]);
 			labels[loc.Index] = code.Position;
 			if (labelStackHeight[loc.Index] == -1)
 			{
 				if (stackHeight == -1)
 				{
 					// We're at a location that can only be reached by a backward branch,
 					// so according to the "backward branch constraint" that must mean the stack is empty,
 					// but note that this may be an unused label followed by another label that is used and
 					// that does have a non-zero stack height, so we don't yet set stackHeight here.
 					labelStackHeight[loc.Index] = 0;
 				}
 				else
 				{
 					labelStackHeight[loc.Index] = stackHeight;
 				}
 			}
 			else
 			{
 				Debug.Assert(stackHeight == -1 || stackHeight == labelStackHeight[loc.Index]);
 				stackHeight = labelStackHeight[loc.Index];
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6761" endline="6769">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Variable;
 			if (type == null)
 				type = ec.CurrentType;
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="221" endline="231">
<![CDATA[
 
 		internal void DefineAnonymousScope (int id)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			if (anonymous_scopes == null)
 				anonymous_scopes = new Dictionary<int, AnonymousScopeEntry>  ();
 
 			anonymous_scopes.Add (id, new AnonymousScopeEntry (id));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="419" endline="446">
<![CDATA[
 	}
 
 	static class PackedCustomModifiers
 	{
 		// modifiers are packed in a very specific way (and required to be so, otherwise equality checks will fail)
 		// For modifiers[x][y][z]
 		//  x = parameter index, 0 = return type, 1 = first parameters, ...
 		//  y = 0 = optional custom modifiers, 1 = required custom modifiers
 		//  z = the custom modifiers
 		// At any level the reference can be null (and *must* be null, if there are no modifiers below that level).
 		// Empty arrays are not allowed at any level.
 
 		// this can be used to "add" elements to the modifiers array (and the elements are assumed to already be in normalized form)
 		internal static void SetModifiers(ref Type[][][] modifiers, int index, int optOrReq, Type[] add, int count)
 		{
 			if (add != null)
 			{
 				if (modifiers == null)
 				{
 					modifiers = new Type[count][][];
 				}
 				if (modifiers[index] == null)
 				{
 					modifiers[index] = new Type[2][];
 				}
 				modifiers[index][optOrReq] = add;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1382" endline="1397">
<![CDATA[
 
 		/// <summary>
 		///   Attempts to implicitly convert `source' into `target_type', using
 		///   ImplicitConversion.  If there is no implicit conversion, then
 		///   an error is signaled
 		/// </summary>
 		static public Expression ImplicitConversionRequired (ResolveContext ec, Expression source,
 								     TypeSpec target_type, Location loc)
 		{
 			Expression e = ImplicitConversion (ec, source, target_type, loc);
 			if (e != null)
 				return e;
 
 			source.Error_ValueCannotBeConverted (ec, loc, target_type, false);
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cfold.cs" startline="63" endline="80">
<![CDATA[
 
 		static bool ConvertPromotion (ResolveContext rc, ref Constant prim, ref Constant second, TypeSpec type)
 		{
 			Constant c = prim.ConvertImplicitly (rc, type);
 			if (c != null) {
 				prim = c;
 				return true;
 			}
 
 			if (type == TypeManager.uint32_type) {
 				type = TypeManager.int64_type;
 				prim = prim.ConvertImplicitly (rc, type);
 				second = second.ConvertImplicitly (rc, type);
 				return prim != null && second != null;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="128" endline="146">
<![CDATA[
 
 		public void Resolve (ResolveContext ec)
 		{
 			if (Expr == EmptyExpression.Null)
 				return;
 
 //			using (ec.With (ResolveContext.Options.DoFlowAnalysis, true)) {
 				// Verify that the argument is readable
 				if (ArgType != AType.Out)
 					Expr = Expr.Resolve (ec);
 
 				// Verify that the argument is writeable
 				if (Expr != null && IsByRef)
 					Expr = Expr.ResolveLValue (ec, EmptyExpression.OutAccess.Instance);
 
 				if (Expr == null)
 					Expr = EmptyExpression.Null;
 //			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2129" endline="2164">
<![CDATA[
 		}
 
 		public abstract ParametersCompiled ParameterInfo { get ; }
 		public abstract TypeSpec ReturnType { get; }
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant || a.Type == pa.Obsolete || a.Type == pa.Conditional) {
 				Report.Error (1667, a.Location,
 					"Attribute `{0}' is not valid on property or event accessors. It is valid on `{1}' declarations only",
 					TypeManager.CSharpName (a.Type), a.GetValidTargets ());
 				return;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				method_data.MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			ApplyToExtraTarget (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="262" endline="268">
<![CDATA[
 		}
 
 		FieldSpec CreateSiteField (EmitContext ec, FullNamedExpression type)
 		{
 			var site_container = ec.CreateDynamicSite ();
 			return site_container.CreateCallSiteField (type, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1379" endline="1387">
<![CDATA[
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			if (Value >= 0 && type == TypeManager.uint64_type) {
 				return new ULongConstant ((ulong) Value, loc).Resolve (rc);
 			}
 
 			return base.ConvertImplicitly (rc, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1482" endline="1492">
<![CDATA[
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			// boxing is side-effectful, since it involves runtime checks, except when boxing to Object or ValueType
 			// so, we need to emit the box+pop instructions in most cases
 			if (TypeManager.IsStruct (child.Type) &&
 			    (type == TypeManager.object_type || type == TypeManager.value_type))
 				child.EmitSideEffect (ec);
 			else
 				base.EmitSideEffect (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5012" endline="5039">
<![CDATA[
 
 		//
 		// Notice that for ref/out parameters, the type exposed is not the
 		// same type exposed externally.
 		//
 		// for "ref int a"
 		//   externally we expose "int&"
 		//   here we expose       "int".
 		//
 		// We record this in "is_ref".  This means that the type system can treat
 		// the type as it is expected, but when we generate the code, we generate
 		// the alternate kind of code.
 		//
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			// HACK
 			if (ec.IsInProbingMode)
 				return this;
 
 			if (HasOutModifier && ec.DoFlowAnalysis &&
 			    (!ec.OmitStructFlowAnalysis || !VariableInfo.TypeInfo.IsStruct) && !IsAssigned (ec, loc))
 				return null;
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2012" endline="2031">
<![CDATA[
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			// Check this name against other containers
 			NamespaceEntry.NS.VerifyClsCompliance ();
 
 			// Check all container names for user classes
 			if (Kind != MemberKind.Delegate)
 				MemberCache.VerifyClsCompliance (Definition, Report);
 
 			if (BaseType != null && !BaseType.IsCLSCompliant ()) {
 				Report.Warning (3009, 1, Location, "`{0}'
 					GetSignatureForError (), BaseType.GetSignatureForError ());
 			}
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="949" endline="960">
<![CDATA[
 
 		int print_count;
 		public override void Print (AbstractMessage msg)
 		{
 			base.Print (msg);
 
 			if (Stacktrace)
 				Console.WriteLine (FriendlyStackTrace (new StackTrace (true)));
 
 			if (++print_count == Fatal)
 				throw new Exception (msg.Text);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="409" endline="433">
<![CDATA[
 
 		protected void CheckProtectedModifier ()
 		{
 			if ((ModFlags & Modifiers.PROTECTED) == 0)
 				return;
 
 			if (Parent.PartialContainer.Kind == MemberKind.Struct) {
 				Report.Error (666, Location, "`{0}'
 					GetSignatureForError ());
 				return;
 			}
 
 			if ((Parent.ModFlags & Modifiers.STATIC) != 0) {
 				Report.Error (1057, Location, "`{0}'
 					GetSignatureForError ());
 				return;
 			}
 
 			if ((Parent.ModFlags & Modifiers.SEALED) != 0 && (ModFlags & Modifiers.OVERRIDE) == 0 &&
 				!(this is Destructor)) {
 				Report.Warning (628, 4, Location, "`{0}'
 					GetSignatureForError ());
 				return;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="539" endline="546">
<![CDATA[
 
 		protected override UsageVector Merge ()
 		{
 			Report.Debug (2, "  MERGING SIBLINGS", Name);
 			UsageVector vector = UsageVector.MergeSiblings (sibling_list, Location);
 			Report.Debug (2, "  MERGING SIBLINGS DONE", Name, vector);
 			return vector;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="44" endline="54">
<![CDATA[
 		{
 			if (attrs == null)
 				return;
 
 			if (attributes == null)
 				attributes = attrs;
 			else
 				throw new NotImplementedException ();
 
 			attributes.AttachTo (this, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="139" endline="149">
<![CDATA[
 
 		internal int ReadInt32()
 		{
 			if (end - pos < 4)
 				throw new BadImageFormatException();
 			byte b1 = buffer[pos++];
 			byte b2 = buffer[pos++];
 			byte b3 = buffer[pos++];
 			byte b4 = buffer[pos++];
 			return (int)(b1 | (b2 << 8) | (b3 << 16) | (b4 << 24));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1082" endline="1125">
<![CDATA[
 
 		/// <summary>
 		///   Attempts to perform an implicit constant conversion of the IntConstant
 		///   into a different data type using casts (See Implicit Constant
 		///   Expression Conversions)
 		/// </summary>
 		Constant TryImplicitIntConversion (TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type) {
 				if (Value >= SByte.MinValue && Value <= SByte.MaxValue)
 					return new SByteConstant ((sbyte) Value, loc);
 			} 
 			else if (target_type == TypeManager.byte_type) {
 				if (Value >= Byte.MinValue && Value <= Byte.MaxValue)
 					return new ByteConstant ((byte) Value, loc);
 			} 
 			else if (target_type == TypeManager.short_type) {
 				if (Value >= Int16.MinValue && Value <= Int16.MaxValue)
 					return new ShortConstant ((short) Value, loc);
 			} 
 			else if (target_type == TypeManager.ushort_type) {
 				if (Value >= UInt16.MinValue && Value <= UInt16.MaxValue)
 					return new UShortConstant ((ushort) Value, loc);
 			} 
 			else if (target_type == TypeManager.uint32_type) {
 				if (Value >= 0)
 					return new UIntConstant ((uint) Value, loc);
 			} 
 			else if (target_type == TypeManager.uint64_type) {
 				//
 				// we can optimize this case
 				// always fits on a uint64.  But we need an opcode
 				// to do it.
 				//
 				if (Value >= 0)
 					return new ULongConstant ((ulong) Value, loc);
 			} 
 			else if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, loc);
 			else if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, loc);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8433" endline="8468">
<![CDATA[
 		
 		public override void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			prepared = prepare_for_load;
 			Expression value = source;
 
 			if (prepared) {
 				Invocation.EmitCall (ec, InstanceExpression, Getter, arguments, loc, true, false);
 
 				prepared_value = new LocalTemporary (type);
 				prepared_value.Store (ec);
 				source.Emit (ec);
 				prepared_value.Release (ec);
 
 				if (leave_copy) {
 					ec.Emit (OpCodes.Dup);
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			} else if (leave_copy) {
 				temp = new LocalTemporary (Type);
 				source.Emit (ec);
 				temp.Store (ec);
 				value = temp;
 			}
 			
 			if (!prepared)
 				arguments.Add (new Argument (value));
 
 			Invocation.EmitCall (ec, InstanceExpression, Setter, arguments, loc, false, prepared);
 			
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2310" endline="2329">
<![CDATA[
 		
 		bool pp_and (ref string s)
 		{
 			bool va = pp_eq (ref s);
 
 			s = s.Trim ();
 			int len = s.Length;
 			if (len > 0){
 				if (s [0] == '&'){
 					if (len > 2 && s [1] == '&'){
 						s = s.Substring (2);
 						return (va & pp_and (ref s));
 					} else {
 						Error_InvalidDirective ();
 						return false;
 					}
 				} 
 			}
 			return va;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="378" endline="402">
<![CDATA[
 
 		public ResolveFlags ExprClassToResolveFlags {
 			get {
 				switch (eclass) {
 				case ExprClass.Type
 				case ExprClass.Namespace
 					return ResolveFlags.Type;
 					
 				case ExprClass.MethodGroup
 					return ResolveFlags.MethodGroup;
 					
 				case ExprClass.TypeParameter
 					return ResolveFlags.TypeParameter;
 					
 				case ExprClass.Value
 				case ExprClass.Variable
 				case ExprClass.PropertyAccess
 				case ExprClass.EventAccess
 				case ExprClass.IndexerAccess
 					return ResolveFlags.VariableOrValue;
 					
 				default
 					throw new InternalErrorException (loc.ToString () + " " +  GetType () + " ExprClass is Invalid after resolve");
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ModuleWriter.cs" startline="371" endline="380">
<![CDATA[
 
 		internal static void HashChunk(FileStream fs, CryptoStream cs, byte[] buf, int length)
 		{
 			while (length > 0)
 			{
 				int read = fs.Read(buf, 0, Math.Min(buf.Length, length));
 				cs.Write(buf, 0, read);
 				length -= read;
 			}
 			while (length > 0)
 			{
 				int read = fs.Read(buf, 0, Math.Min(buf.Length, length));
 				cs.Write(buf, 0, read);
 				length -= read;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1846" endline="1874">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type)
 				return new SByteConstant ((sbyte)Value, loc);
 			if (target_type == TypeManager.byte_type)
 				return new ByteConstant ((byte)Value, loc);
 			if (target_type == TypeManager.short_type)
 				return new ShortConstant ((short)Value, loc);
 			if (target_type == TypeManager.ushort_type)
 				return new UShortConstant ((ushort)Value, loc);
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int)Value, loc);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint)Value, loc);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long)Value, loc);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong)Value, loc);
 			if (target_type == TypeManager.char_type)
 				return new CharConstant ((char)Value, loc);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float)Value, loc);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double)Value, loc);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3083" endline="3118">
<![CDATA[
 
 		protected static bool CheckAccessModifiers (MemberCore this_member, MemberSpec base_member)
 		{
 			var thisp = this_member.ModFlags & Modifiers.AccessibilityMask;
 			var base_classp = base_member.Modifiers & Modifiers.AccessibilityMask;
 
 			if ((base_classp & (Modifiers.PROTECTED | Modifiers.INTERNAL)) == (Modifiers.PROTECTED | Modifiers.INTERNAL)) {
 				//
 				// It must be at least "protected"
 				//
 				if ((thisp & Modifiers.PROTECTED) == 0) {
 					return false;
 				}
 
 				//
 				// when overriding protected internal, the method can be declared
 				// protected internal only within the same assembly or assembly
 				// which has InternalsVisibleTo
 				//
 				if ((thisp & Modifiers.INTERNAL) != 0) {
 					return base_member.DeclaringType.MemberDefinition.IsInternalAsPublic (this_member.Module.DeclaringAssembly);
 				}
 
 				//
 				// protected overriding protected internal inside same assembly
 				// requires internal modifier as well
 				//
 				if (base_member.DeclaringType.MemberDefinition.IsInternalAsPublic (this_member.Module.DeclaringAssembly)) {
 					return false;
 				}
 
 				return true;
 			}
 
 			return thisp == base_classp;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1008" endline="1069">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < Int16.MinValue || Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < UInt32.MinValue)
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="99" endline="106">
<![CDATA[
 
 		public void AddDefine (string value)
 		{
 			if (conditionals == null)
 				conditionals = new Dictionary<string, bool> (2);
 
 			conditionals [value] = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="107" endline="114">
<![CDATA[
 
 		public void AddUndefine (string value)
 		{
 			if (conditionals == null)
 				conditionals = new Dictionary<string, bool> (2);
 
 			conditionals [value] = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="1394" endline="1408">
<![CDATA[
 
 		void AddAssemblyReference (string alias, string assembly)
 		{
 			if (assembly.Length == 0) {
 				Report.Error (1680, "Invalid reference alias `{0}='. Missing filename", alias);
 				return;
 			}
 
 			if (!IsExternAliasValid (alias)) {
 				Report.Error (1679, "Invalid extern alias for -reference. Alias `{0}' is not a valid identifier", alias);
 				return;
 			}
 
 			RootContext.AssemblyReferencesAliases.Add (Tuple.Create (alias, assembly));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1292" endline="1339">
<![CDATA[
 		}
 
 		// note that interface/delegate co- and contravariance is not considered
 		public bool IsAssignableFrom(Type type)
 		{
 			if (this.Equals(type))
 			{
 				return true;
 			}
 			else if (type == null)
 			{
 				return false;
 			}
 			else if (this.IsArray && type.IsArray)
 			{
 				if (this.GetArrayRank() != type.GetArrayRank())
 				{
 					return false;
 				}
 				else if (this.__IsVector && !type.__IsVector)
 				{
 					return false;
 				}
 				Type e1 = this.GetElementType();
 				Type e2 = type.GetElementType();
 				return e1.IsValueType == e2.IsValueType && e1.IsAssignableFrom(e2);
 			}
 			else if (this.IsSealed)
 			{
 				return false;
 			}
 			else if (this.IsInterface)
 			{
 				return Array.IndexOf(type.GetInterfaces(), this) != -1;
 			}
 			else if (type.IsInterface)
 			{
 				return this == this.Module.universe.System_Object;
 			}
 			else if (type.IsPointer)
 			{
 				return this == this.Module.universe.System_Object || this == this.Module.universe.System_ValueType;
 			}
 			else
 			{
 				return type.IsSubclassOf(this);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="874" endline="893">
<![CDATA[
 
 	/// <summary>
 	///   Utility function that can be used to probe whether a type
 	///   is managed or not.  
 	/// </summary>
 	public static bool VerifyUnmanaged (CompilerContext ctx, TypeSpec t, Location loc)
 	{
 		while (t.IsPointer)
 			t = GetElementType (t);
 		while (t.IsPointer)
 			t = GetElementType (t);
 
 		if (IsUnmanagedType (t))
 			return true;
 
 		ctx.Report.SymbolRelatedToPreviousError (t);
 		ctx.Report.Error (208, loc,
 			"Cannot take the address of, get the size of, or declare a pointer to a managed type `{0}'",
 			CSharpName (t));
 
 		return false;	
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4915" endline="4930">
<![CDATA[
 		}
 
 		#endregion
 
 		public bool IsAssigned (ResolveContext ec, Location loc)
 		{
 			// HACK
 			if (ec.IsInProbingMode)
 				return true;
 			
 			if (!ec.DoFlowAnalysis || !HasOutModifier || ec.CurrentBranching.IsAssigned (VariableInfo))
 				return true;
 
 			ec.Report.Error (269, loc, "Use of unassigned out parameter `{0}'", Name);
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1348" endline="1359">
<![CDATA[
 
 		internal NamespaceEntry (MonoSymbolFile file, MyBinaryReader reader)
 		{
 			Name = reader.ReadString ();
 			Index = reader.ReadLeb128 ();
 			Parent = reader.ReadLeb128 ();
 
 			int count = reader.ReadLeb128 ();
 			UsingClauses = new string [count];
 			for (int i = 0; i < count; i++)
 				UsingClauses [i] = reader.ReadString ();
 			for (int i = 0; i < count; i++)
 				UsingClauses [i] = reader.ReadString ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1249" endline="1257">
<![CDATA[
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (child.Type == target_type)
 				return child;
 
 			// FIXME
 			return child.ConvertExplicitly (in_checked_context, target_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1418" endline="1426">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly(bool in_checked_context, TypeSpec target_type)
 		{
 			if (Child.Type == target_type)
 				return Child;
 
 			return Child.ConvertExplicitly (in_checked_context, target_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="336" endline="367">
<![CDATA[
 
 		Expression CreateExpressionTree (ResolveContext ec, Expression user_op)
 		{
 			string method_name;
 			switch (Oper) {
 			case Operator.AddressOf
 				Error_PointerInsideExpressionTree (ec);
 				return null;
 			case Operator.UnaryNegation
 				if (ec.HasSet (ResolveContext.Options.CheckedScope) && user_op == null && !IsFloat (type))
 					method_name = "NegateChecked";
 				else
 					method_name = "Negate";
 				break;
 			case Operator.OnesComplement
 			case Operator.LogicalNot
 				method_name = "Not";
 				break;
 			case Operator.UnaryPlus
 				method_name = "UnaryPlus";
 				break;
 			default
 				throw new InternalErrorException ("Unknown unary operator " + Oper.ToString ());
 			}
 
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (Expr.CreateExpressionTree (ec)));
 			if (user_op != null)
 				args.Add (new Argument (user_op));
 
 			return CreateExpressionFactoryCall (ec, method_name, args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="228" endline="236">
<![CDATA[
 		}
 
 		public static string MakeName (string name, TypeArguments args)
 		{
 			if (args == null)
 				return name;
 
 			return name + "`" + args.Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="751" endline="777">
<![CDATA[
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			flags |= MethodAttributes.HideBySig | MethodAttributes.SpecialName;
 
 			if (!IsInterface && (ModFlags & (Modifiers.ABSTRACT | Modifiers.EXTERN)) == 0 &&
 				AccessorSecond != null && Get.Block == null && Set.Block == null) {
 				if (RootContext.Version <= LanguageVersion.ISO_2)
 					Report.FeatureIsNotAvailable (Location, "automatically implemented properties");
 
 				Get.ModFlags |= Modifiers.COMPILER_GENERATED;
 				Set.ModFlags |= Modifiers.COMPILER_GENERATED;
 				CreateAutomaticProperty ();
 			}
 
 			if (!DefineAccessors ())
 				return false;
 
 			if (!CheckBase ())
 				return false;
 
 			DefineBuilders (MemberKind.Property, ParametersCompiled.EmptyReadOnlyParameters);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1993" endline="2021">
<![CDATA[
 
 		/// <summary>
 		///   Same as ExplicitConversion, only it doesn't include user defined conversions
 		/// </summary>
 		static public Expression ExplicitConversionStandard (ResolveContext ec, Expression expr,
 								     TypeSpec target_type, Location l)
 		{
 			int errors = ec.Report.Errors;
 			Expression ne = ImplicitConversionStandard (ec, expr, target_type, l);
 			if (ec.Report.Errors > errors)
 				return null;
 
 			if (ne != null)
 				return ne;
 
 			ne = ExplicitNumericConversion (expr, target_type);
 			if (ne != null)
 				return ne;
 
 			ne = ExplicitReferenceConversion (expr, expr.Type, target_type);
 			if (ne != null)
 				return ne;
 
 			if (ec.IsUnsafe && expr.Type.IsPointer && target_type.IsPointer && ((PointerContainer)expr.Type).Element.BuildinType == BuildinTypeSpec.Type.Void)
 				return EmptyCast.Create (expr, target_type);
 
 			expr.Error_ValueCannotBeConverted (ec, l, target_type, true);
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="434" endline="465">
<![CDATA[
 
 #if CECIL
 		protected MonoSymbolFile (string filename, Mono.Cecil.ModuleDefinition module)
 			
 		{
 			CheckGuidMatch (module.Mvid, filename, module.FullyQualifiedName);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Mono.Cecil.ModuleDefinition module)
 		{
 			return ReadSymbolFile (module, module.FullyQualifiedName);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Mono.Cecil.ModuleDefinition module, string filename)
 		{
 			string name = filename + ".mdb";
 
 			return new MonoSymbolFile (name, module);
 		}
 #else
 		protected MonoSymbolFile (string filename, Assembly assembly) 
 		{
 			// Check that the MDB file matches the assembly, if we have been
 			// passed an assembly.
 			if (assembly == null)
 				return;
 			
 			Module[] modules = assembly.GetModules ();
 			Guid assembly_guid = MonoDebuggerSupport.GetGuid (modules [0]);
 
 			CheckGuidMatch (assembly_guid, filename, assembly.Location);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3369" endline="3380">
<![CDATA[
 
 		//
 		// Any type_name independent checks
 		//
 		protected virtual void DoMemberTypeIndependentChecks ()
 		{
 			if ((Parent.ModFlags & Modifiers.SEALED) != 0 &&
 				(ModFlags & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 				Report.Error (549, Location, "New virtual member `{0}' is declared in a sealed class `{1}'",
 					GetSignatureForError (), Parent.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="614" endline="635">
<![CDATA[
 		}
 
 		internal void WriteMethodDefRecord(int baseRVA, MetadataWriter mw, ref int paramList)
 		{
 			if (rva != -1)
 			{
 				mw.Write(rva + baseRVA);
 			}
 			else
 			{
 				mw.Write(0);
 			}
 			mw.Write((short)implFlags);
 			mw.Write((short)attributes);
 			mw.WriteStringIndex(nameIndex);
 			mw.WriteBlobIndex(signature);
 			mw.WriteParam(paramList);
 			if (parameters != null)
 			{
 				paramList += parameters.Count;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\literal.cs" startline="185" endline="199">
<![CDATA[
 
 		public override void Error_ValueCannotBeConverted (ResolveContext ec, Location loc, TypeSpec target, bool expl)
 		{
 			if (target == TypeManager.float_type) {
 				Error_664 (ec, loc, "float", "f");
 				return;
 			}
 
 			if (target == TypeManager.decimal_type) {
 				Error_664 (ec, loc, "decimal", "m");
 				return;
 			}
 
 			base.Error_ValueCannotBeConverted (ec, loc, target, expl);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1627" endline="1640">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			if (arrayAccess)
 				expr = ConvertExpressionToArrayIndex (ec, expr);
 			else
 				expr = Convert.ImplicitConversionRequired (ec, expr, type, loc);
 
 			return expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="266" endline="364">
<![CDATA[
 		
 		void Write (MyBinaryWriter bw, Guid guid)
 		{
 			// Magic number and file version.
 			bw.Write (OffsetTable.Magic);
 			bw.Write (MajorVersion);
 			bw.Write (MinorVersion);
 
 			bw.Write (guid.ToByteArray ());
 
 			//
 			// Offsets of file sections; we must write this after we're done
 			// writing the whole file, so we just reserve the space for it here.
 			//
 			long offset_table_offset = bw.BaseStream.Position;
 			ot.Write (bw, MajorVersion, MinorVersion);
 
 			//
 			// Sort the methods according to their tokens and update their index.
 			//
 			methods.Sort ();
 			for (int i = 0; i < methods.Count; i++)
 				((MethodEntry) methods [i]).Index = i + 1;
 			for (int i = 0; i < methods.Count; i++)
 				((MethodEntry) methods [i]).Index = i + 1;
 
 			//
 			// Write data sections.
 			//
 			ot.DataSectionOffset = (int) bw.BaseStream.Position;
 			foreach (SourceFileEntry source in sources)
 				source.WriteData (bw);
 			foreach (SourceFileEntry source in sources)
 				source.WriteData (bw);
 			foreach (CompileUnitEntry comp_unit in comp_units)
 				comp_unit.WriteData (bw);
 			foreach (CompileUnitEntry comp_unit in comp_units)
 				comp_unit.WriteData (bw);
 			foreach (MethodEntry method in methods)
 				method.WriteData (this, bw);
 			foreach (MethodEntry method in methods)
 				method.WriteData (this, bw);
 			ot.DataSectionSize = (int) bw.BaseStream.Position - ot.DataSectionOffset;
 
 			//
 			// Write the method index table.
 			//
 			ot.MethodTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < methods.Count; i++) {
 				MethodEntry entry = (MethodEntry) methods [i];
 				entry.Write (bw);
 			}
 			for (int i = 0; i < methods.Count; i++) {
 				MethodEntry entry = (MethodEntry) methods [i];
 				entry.Write (bw);
 			}
 			ot.MethodTableSize = (int) bw.BaseStream.Position - ot.MethodTableOffset;
 
 			//
 			// Write source table.
 			//
 			ot.SourceTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < sources.Count; i++) {
 				SourceFileEntry source = (SourceFileEntry) sources [i];
 				source.Write (bw);
 			}
 			for (int i = 0; i < sources.Count; i++) {
 				SourceFileEntry source = (SourceFileEntry) sources [i];
 				source.Write (bw);
 			}
 			ot.SourceTableSize = (int) bw.BaseStream.Position - ot.SourceTableOffset;
 
 			//
 			// Write compilation unit table.
 			//
 			ot.CompileUnitTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < comp_units.Count; i++) {
 				CompileUnitEntry unit = (CompileUnitEntry) comp_units [i];
 				unit.Write (bw);
 			}
 			for (int i = 0; i < comp_units.Count; i++) {
 				CompileUnitEntry unit = (CompileUnitEntry) comp_units [i];
 				unit.Write (bw);
 			}
 			ot.CompileUnitTableSize = (int) bw.BaseStream.Position - ot.CompileUnitTableOffset;
 
 			//
 			// Write anonymous scope table.
 			//
 			ot.AnonymousScopeCount = anonymous_scopes != null ? anonymous_scopes.Count 
 			ot.AnonymousScopeTableOffset = (int) bw.BaseStream.Position;
 			if (anonymous_scopes != null) {
 				foreach (AnonymousScopeEntry scope in anonymous_scopes.Values)
 					scope.Write (bw);
 				foreach (AnonymousScopeEntry scope in anonymous_scopes.Values)
 					scope.Write (bw);
 			}
 			ot.AnonymousScopeTableSize = (int) bw.BaseStream.Position - ot.AnonymousScopeTableOffset;
 
 			//
 			// Fixup offset table.
 			//
 			ot.TypeCount = last_type_index;
 			ot.MethodCount = methods.Count;
 			ot.SourceCount = sources.Count;
 			ot.CompileUnitCount = comp_units.Count;
 
 			//
 			// Write offset table.
 			//
 			ot.TotalFileSize = (int) bw.BaseStream.Position;
 			bw.Seek ((int) offset_table_offset, SeekOrigin.Begin);
 			ot.Write (bw, MajorVersion, MinorVersion);
 			bw.Seek (0, SeekOrigin.End);
 
 #if false
 			Console.WriteLine ("TOTAL
 					   "{3} methods.", NumLineNumbers, LineNumberSize,
 					   ExtendedLineNumberSize, methods.Count);
 #endif
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1553" endline="1626">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < byte.MinValue || Value > byte.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < sbyte.MinValue || Value > sbyte.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (float) char.MinValue || Value > (float) char.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1676" endline="1749">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (double) char.MinValue || Value > (double) char.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="252" endline="370">
<![CDATA[
 
 		internal void Write(MetadataWriter mw, int sdataRVA)
 		{
 			// Now that we're ready to start writing, we need to do some fix ups
 			moduleBuilder.MethodDef.Fixup(this);
 			moduleBuilder.MethodImpl.Fixup(moduleBuilder);
 			moduleBuilder.MethodSemantics.Fixup(moduleBuilder);
 			moduleBuilder.InterfaceImpl.Fixup();
 			moduleBuilder.MemberRef.Fixup(moduleBuilder);
 			moduleBuilder.Constant.Fixup(moduleBuilder);
 			moduleBuilder.FieldMarshal.Fixup(moduleBuilder);
 			moduleBuilder.DeclSecurity.Fixup(moduleBuilder);
 			moduleBuilder.GenericParam.Fixup(moduleBuilder);
 			moduleBuilder.CustomAttribute.Fixup(moduleBuilder);
 			moduleBuilder.FieldLayout.Fixup(moduleBuilder);
 			moduleBuilder.FieldRVA.Fixup(moduleBuilder, sdataRVA);
 			moduleBuilder.ImplMap.Fixup(moduleBuilder);
 			moduleBuilder.MethodSpec.Fixup(moduleBuilder);
 			moduleBuilder.GenericParamConstraint.Fixup(moduleBuilder);
 
 			// Import Address Table
 			AssertRVA(mw, ImportAddressTableRVA);
 			WriteRVA(mw, ImportHintNameTableRVA);
 			WriteRVA(mw, 0);
 
 			// CLI Header
 			AssertRVA(mw, ComDescriptorRVA);
 			cliHeader.MetaDataRVA = MetadataRVA;
 			cliHeader.MetaDataSize = MetadataLength;
 			if (ResourcesLength != 0)
 			{
 				cliHeader.ResourcesRVA = ResourcesRVA;
 				cliHeader.ResourcesSize = ResourcesLength;
 			}
 			if (StrongNameSignatureLength != 0)
 			{
 				cliHeader.StrongNameSignatureRVA = StrongNameSignatureRVA;
 				cliHeader.StrongNameSignatureSize = StrongNameSignatureLength;
 			}
 			cliHeader.Write(mw);
 
 			// alignment padding
 			for (int i = (int)(MethodBodiesRVA - (ComDescriptorRVA + ComDescriptorLength)); i > 0; i--)
 			{
 				mw.Write((byte)0);
 			}
 			for (int i = (int)(MethodBodiesRVA - (ComDescriptorRVA + ComDescriptorLength)); i > 0; i--)
 			{
 				mw.Write((byte)0);
 			}
 
 			// Method Bodies
 			mw.Write(moduleBuilder.methodBodies);
 
 			// alignment padding
 			for (int i = (int)(ResourcesRVA - (MethodBodiesRVA + MethodBodiesLength)); i > 0; i--)
 			{
 				mw.Write((byte)0);
 			}
 			for (int i = (int)(ResourcesRVA - (MethodBodiesRVA + MethodBodiesLength)); i > 0; i--)
 			{
 				mw.Write((byte)0);
 			}
 
 			// Resources
 			mw.Write(moduleBuilder.manifestResources);
 
 			// The strong name signature live here (if it exists), but it will written later
 			// and the following alignment padding will take care of reserving the space.
 
 			// alignment padding
 			for (int i = (int)(MetadataRVA - (ResourcesRVA + ResourcesLength)); i > 0; i--)
 			{
 				mw.Write((byte)0);
 			}
 			for (int i = (int)(MetadataRVA - (ResourcesRVA + ResourcesLength)); i > 0; i--)
 			{
 				mw.Write((byte)0);
 			}
 
 			// Metadata
 			AssertRVA(mw, MetadataRVA);
 			moduleBuilder.WriteMetadata(mw);
 
 			// Debug Directory
 			AssertRVA(mw, DebugDirectoryRVA);
 			WriteDebugDirectory(mw);
 
 			// alignment padding
 			for (int i = (int)(ImportDirectoryRVA - (DebugDirectoryRVA + DebugDirectoryLength + DebugDirectoryContentsLength)); i > 0; i--)
 			{
 				mw.Write((byte)0);
 			}
 			for (int i = (int)(ImportDirectoryRVA - (DebugDirectoryRVA + DebugDirectoryLength + DebugDirectoryContentsLength)); i > 0; i--)
 			{
 				mw.Write((byte)0);
 			}
 
 			// Import Directory
 			AssertRVA(mw, ImportDirectoryRVA);
 			WriteImportDirectory(mw);
 
 			// alignment padding
 			for (int i = (int)(StartupStubRVA - (ImportDirectoryRVA + ImportDirectoryLength)); i > 0; i--)
 			{
 				mw.Write((byte)0);
 			}
 			for (int i = (int)(StartupStubRVA - (ImportDirectoryRVA + ImportDirectoryLength)); i > 0; i--)
 			{
 				mw.Write((byte)0);
 			}
 
 			// Startup Stub
 			AssertRVA(mw, StartupStubRVA);
 			if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_AMD64)
 			{
 				/*
 				 *   48 A1 00 20 40 00 00 00 00 00        mov         rax,qword ptr [0000000000402000h]
 				 *   FF E0                                jmp         rax
 				 */
 				mw.Write((ushort)0xA148);
 				mw.Write(peWriter.Headers.OptionalHeader.ImageBase + ImportAddressTableRVA);
 				mw.Write((ushort)0xE0FF);
 			}
 			else if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_IA64)
 			{
 				mw.Write(new byte[] {
 						0x0B, 0x48, 0x00, 0x02, 0x18, 0x10, 0xA0, 0x40, 0x24, 0x30, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00,
 						0x10, 0x08, 0x00, 0x12, 0x18, 0x10, 0x60, 0x50, 0x04, 0x80, 0x03, 0x00, 0x60, 0x00, 0x80, 0x00
 					});
 				mw.Write(peWriter.Headers.OptionalHeader.ImageBase + StartupStubRVA);
 				mw.Write(peWriter.Headers.OptionalHeader.ImageBase + BaseRVA);
 			}
 			else
 			{
 				mw.Write((ushort)0x25FF);
 				mw.Write((uint)peWriter.Headers.OptionalHeader.ImageBase + ImportAddressTableRVA);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="167" endline="176">
<![CDATA[
 		}
 
 		public string GetSignatureForError ()
 		{
 			string append = TypeArguments == null ? "" 
 			if (Left == null)
 				return Name + append;
 			string connect = is_double_colon ? "
 			return Left.GetSignatureForError () + connect + Name + append;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="788" endline="796">
<![CDATA[
 
 		protected static Type[] BindTypeParameters(IGenericBinder binder, Type[][][] types, int index, int optOrReq)
 		{
 			if (types == null || types[index] == null)
 			{
 				return null;
 			}
 			return BindTypeParameters(binder, types[index][optOrReq]);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="534" endline="569">
<![CDATA[
 
 		static public byte[] ToCapiPublicKeyBlob (RSA rsa) 
 		{
 			RSAParameters p = rsa.ExportParameters (false);
 			int keyLength = p.Modulus.Length; // in bytes
 			byte[] blob = new byte [20 + keyLength];
 
 			blob [0] = 0x06;	// Type - PUBLICKEYBLOB (0x06)
 			blob [1] = 0x02;	// Version - Always CUR_BLOB_VERSION (0x02)
 			// [2], [3]		// RESERVED - Always 0
 			blob [5] = 0x24;	// ALGID - Always 00 24 00 00 (for CALG_RSA_SIGN)
 			blob [8] = 0x52;	// Magic - RSA1 (ASCII in hex)
 			blob [9] = 0x53;
 			blob [10] = 0x41;
 			blob [11] = 0x31;
 
 			byte[] bitlen = GetBytesLE (keyLength << 3);
 			blob [12] = bitlen [0];	// bitlen
 			blob [13] = bitlen [1];	
 			blob [14] = bitlen [2];	
 			blob [15] = bitlen [3];
 
 			// public exponent (DWORD)
 			int pos = 16;
 			int n = p.Exponent.Length;
 			while (n > 0)
 				blob [pos++] = p.Exponent [--n];
 			while (n > 0)
 				blob [pos++] = p.Exponent [--n];
 			// modulus
 			pos = 20;
 			byte[] part = p.Modulus;
 			int len = part.Length;
 			Array.Reverse (part, 0, len);
 			Buffer.BlockCopy (part, 0, blob, pos, len);
 			pos += len;
 			return blob;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2485" endline="2493">
<![CDATA[
 
 		protected override bool ResolveMemberType ()
 		{
 			if (!base.ResolveMemberType ())
 				return false;
 
 			flags |= MethodAttributes.SpecialName | MethodAttributes.HideBySig;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2220" endline="2261">
<![CDATA[
 
 		bool pp_primary (ref string s)
 		{
 			s = s.Trim ();
 			int len = s.Length;
 
 			if (len > 0){
 				char c = s [0];
 				
 				if (c == '('){
 					s = s.Substring (1);
 					bool val = pp_expr (ref s, false);
 					if (s.Length > 0 && s [0] == ')'){
 						s = s.Substring (1);
 						return val;
 					}
 					Error_InvalidDirective ();
 					return false;
 				}
 				
 				if (is_identifier_start_character (c)){
 					int j = 1;
 
 					while (j < len){
 						c = s [j];
 						
 						if (is_identifier_part_character (c)){
 							j++;
 							continue;
 						}
 						bool v = eval_val (s.Substring (0, j));
 						s = s.Substring (j);
 						return v;
 					while (j < len){
 						c = s [j];
 						
 						if (is_identifier_part_character (c)){
 							j++;
 							continue;
 						}
 						bool v = eval_val (s.Substring (0, j));
 						s = s.Substring (j);
 						return v;
 					}
 					bool vv = eval_val (s);
 					s = "";
 					return vv;
 				}
 			}
 			Error_InvalidDirective ();
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6282" endline="6299">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (type != null)
 				return this;
 
 			if (!ResolveArrayType (ec))
 				return null;
 
 			//
 			// validate the initializers and fill in any missing bits
 			//
 			if (!ResolveInitializers (ec))
 				return null;
 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="155" endline="164">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CompletionMemberAccess target = (CompletionMemberAccess) t;
 
 			if (targs != null)
 				target.targs = targs.Clone ();
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="390" endline="449">
<![CDATA[
 		protected int rowCount;
 
 		internal sealed override int RowCount
 		{
 			get { return rowCount; }
 			set { rowCount = value; records = new T[value]; }
 		}
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			throw new InvalidOperationException();
 		}
 
 		internal int AddRecord(T newRecord)
 		{
 			if (rowCount == records.Length)
 			{
 				T[] newarr = new T[records.Length * 2];
 				Array.Copy(records, newarr, records.Length);
 				records = newarr;
 			}
 			records[rowCount++] = newRecord;
 			return rowCount;
 		}
 
 		internal int AddVirtualRecord()
 		{
 			return ++rowCount;
 		}
 
 		internal override void Write(MetadataWriter mw)
 		{
 			throw new InvalidOperationException();
 		}
 	}
 
 	sealed class ModuleTable 
 	{
 		internal const int Index = 0x00;
 
 		internal struct Record
 		{
 			internal short Generation;
 			internal int Name; // -> StringHeap
 			internal int Mvid; // -> GuidHeap
 			internal int EncId; // -> GuidHeap
 			internal int EncBaseId; // -> GuidHeap
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Generation = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Mvid = mr.ReadGuidIndex();
 				records[i].EncId = mr.ReadGuidIndex();
 				records[i].EncBaseId = mr.ReadGuidIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Generation = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Mvid = mr.ReadGuidIndex();
 				records[i].EncId = mr.ReadGuidIndex();
 				records[i].EncBaseId = mr.ReadGuidIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2112" endline="2137">
<![CDATA[
 	}
 
 	sealed class ExportedTypeTable 
 	{
 		internal const int Index = 0x27;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int TypeDefId;
 			internal int TypeName;
 			internal int TypeNamespace;
 			internal int Implementation;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeDefId = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeDefId = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Implementation = mr.ReadImplementation();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2774" endline="2784">
<![CDATA[
 		}
 
 		public override void RegisterFieldForInitialization (MemberCore field, FieldInitializer expression)
 		{
 			if ((field.ModFlags & Modifiers.STATIC) == 0) {
 				Report.Error (573, field.Location, "`{0}'
 					field.GetSignatureForError ());
 				return;
 			}
 			base.RegisterFieldForInitialization (field, expression);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="739" endline="765">
<![CDATA[
 
 		public void EmitCall(OpCode opc, MethodInfo method, Type[] optionalParameterTypes)
 		{
 			if (optionalParameterTypes == null || optionalParameterTypes.Length == 0)
 			{
 				Emit(opc, method);
 			}
 			else
 			{
 				Emit(opc);
 				UpdateStack(opc, method.HasThis, method.ReturnType, method.ParameterCount + optionalParameterTypes.Length);
 				ByteBuffer sig = new ByteBuffer(16);
 				method.MethodSignature.WriteMethodRefSig(moduleBuilder, sig, optionalParameterTypes);
 				MemberRefTable.Record record = new MemberRefTable.Record();
 				if (method.Module == moduleBuilder)
 				{
 					record.Class = method.MetadataToken;
 				}
 				else
 				{
 					record.Class = moduleBuilder.GetTypeTokenForMemberRef(method.DeclaringType ?? method.Module.GetModuleType());
 				}
 				record.Name = moduleBuilder.Strings.Add(method.Name);
 				record.Signature = moduleBuilder.Blobs.Add(sig);
 				code.Write(0x0A000000 | moduleBuilder.MemberRef.FindOrAddRecord(record));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="761" endline="768">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CompoundAssign ctarget = (CompoundAssign) t;
 
 			ctarget.right = ctarget.source = source.Clone (clonectx);
 			ctarget.target = target.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4826" endline="4833">
<![CDATA[
 
 		public bool IsMarshalByRefAccess ()
 		{
 			// Checks possible ldflda of field access expression
 			return !spec.IsStatic && TypeManager.IsValueType (spec.MemberType) &&
 				TypeSpec.IsBaseClass (spec.DeclaringType, TypeManager.mbr_type, false) &&
 				!(InstanceExpression is This);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="149" endline="156">
<![CDATA[
 
 		public Attribute Clone ()
 		{
 			Attribute a = new Attribute (ExplicitTarget, expression, null, loc, nameEscaped);
 			a.PosArguments = PosArguments;
 			a.NamedArguments = NamedArguments;
 			return a;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7531" endline="7540">
<![CDATA[
 
 		public override string GetSignatureForError ()
 		{
 			string name = Name;
 			if (targs != null) {
 				name = Name + "<" + targs.GetSignatureForError () + ">";
 			}
 
 			return alias + "
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="221" endline="233">
<![CDATA[
 
 		public EventSpec CreateEvent (EventInfo ei, TypeSpec declaringType, MethodSpec add, MethodSpec remove)
 		{
 			add.IsAccessor = true;
 			remove.IsAccessor = true;
 
 			if (add.Modifiers != remove.Modifiers)
 				throw new NotImplementedException ("Different accessor modifiers " + ei.Name);
 
 			var event_type = ImportType (ei.EventHandlerType, new DynamicTypeReader (ei));
 			var definition = new ImportedMemberDefinition (ei, event_type,  this);
 			return new EventSpec (declaringType, definition, event_type, add.Modifiers, add, remove);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="187" endline="205">
<![CDATA[
 
 		//
 		// Creates a nested container in this context for all dynamic compiler generated stuff
 		//
 		public DynamicSiteClass CreateDynamicSite ()
 		{
 			if (dynamic_site_container == null) {
 				var mc = MemberContext.CurrentMemberDefinition as MemberBase;
 				dynamic_site_container = new DynamicSiteClass (CurrentTypeDefinition.Parent.PartialContainer, mc, CurrentTypeParameters);
 
 				CurrentTypeDefinition.Module.AddCompilerGeneratedClass (dynamic_site_container);
 				dynamic_site_container.CreateType ();
 				dynamic_site_container.DefineType ();
 				dynamic_site_container.ResolveTypeParameters ();
 				dynamic_site_container.Define ();
 			}
 
 			return dynamic_site_container;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3231" endline="3247">
<![CDATA[
 
 		protected void Error_CannotChangeAccessModifiers (MemberCore member, MemberSpec base_member)
 		{
 			var base_modifiers = base_member.Modifiers;
 
 			// Remove internal modifier from types which are not internally accessible
 			if ((base_modifiers & Modifiers.AccessibilityMask) == (Modifiers.PROTECTED | Modifiers.INTERNAL) &&
 				!base_member.DeclaringType.MemberDefinition.IsInternalAsPublic (member.Module.DeclaringAssembly))
 				base_modifiers = Modifiers.PROTECTED;
 
 			Report.SymbolRelatedToPreviousError (base_member);
 			Report.Error (507, member.Location,
 				"`{0}'
 				member.GetSignatureForError (),
 				ModifiersExtensions.AccessibilityName (base_modifiers),
 				base_member.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="723" endline="735">
<![CDATA[
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (4);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new StringLiteral (name, loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetMember" 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1933" endline="2008">
<![CDATA[
 
 		//
 		// Performs the validation on a Method's modifiers (properties have
 		// the same properties).
 		//
 		// TODO
 		//
 		public bool MethodModifiersValid (MemberCore mc)
 		{
 			const Modifiers vao = (Modifiers.VIRTUAL | Modifiers.ABSTRACT | Modifiers.OVERRIDE);
 			const Modifiers nv = (Modifiers.NEW | Modifiers.VIRTUAL);
 			bool ok = true;
 			var flags = mc.ModFlags;
 			
 			//
 			// At most one of static, virtual or override
 			//
 			if ((flags & Modifiers.STATIC) != 0){
 				if ((flags & vao) != 0){
 					Report.Error (112, mc.Location, "A static member `{0}' cannot be marked as override, virtual or abstract",
 						mc.GetSignatureForError ());
 					ok = false;
 				}
 			}
 
 			if ((flags & Modifiers.OVERRIDE) != 0 && (flags & nv) != 0){
 				Report.Error (113, mc.Location, "A member `{0}' marked as override cannot be marked as new or virtual",
 					mc.GetSignatureForError ());
 				ok = false;
 			}
 
 			//
 			// If the declaration includes the abstract modifier, then the
 			// declaration does not include static, virtual or extern
 			//
 			if ((flags & Modifiers.ABSTRACT) != 0){
 				if ((flags & Modifiers.EXTERN) != 0){
 					Report.Error (
 						180, mc.Location, "`{0}' cannot be both extern and abstract", mc.GetSignatureForError ());
 					ok = false;
 				}
 
 				if ((flags & Modifiers.SEALED) != 0) {
 					Report.Error (502, mc.Location, "`{0}' cannot be both abstract and sealed", mc.GetSignatureForError ());
 					ok = false;
 				}
 
 				if ((flags & Modifiers.VIRTUAL) != 0){
 					Report.Error (503, mc.Location, "The abstract method `{0}' cannot be marked virtual", mc.GetSignatureForError ());
 					ok = false;
 				}
 
 				if ((ModFlags & Modifiers.ABSTRACT) == 0){
 					Report.SymbolRelatedToPreviousError (this);
 					Report.Error (513, mc.Location, "`{0}' is abstract but it is declared in the non-abstract class `{1}'",
 						mc.GetSignatureForError (), GetSignatureForError ());
 					ok = false;
 				}
 			}
 
 			if ((flags & Modifiers.PRIVATE) != 0){
 				if ((flags & vao) != 0){
 					Report.Error (621, mc.Location, "`{0}'
 					ok = false;
 				}
 			}
 
 			if ((flags & Modifiers.SEALED) != 0){
 				if ((flags & Modifiers.OVERRIDE) == 0){
 					Report.Error (238, mc.Location, "`{0}' cannot be sealed because it is not an override", mc.GetSignatureForError ());
 					ok = false;
 				}
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5311" endline="5319">
<![CDATA[
 
 		bool IsSingleDimensionalArrayLength ()
 		{
 			if (best_candidate.DeclaringType != TypeManager.array_type || !best_candidate.HasGet || Name != "Length")
 				return false;
 
 			ArrayContainer ac = InstanceExpression.Type as ArrayContainer;
 			return ac != null && ac.Rank == 1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="680" endline="687">
<![CDATA[
 
 		public bool IsComImport {
 			get {
 				if (OptAttributes == null)
 					return false;
 
 				return OptAttributes.Contains (Module.PredefinedAttributes.ComImport);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="541" endline="549">
<![CDATA[
 
 		private void WriteByteBranchOffset(int offset)
 		{
 			if (offset < -128 || offset > 127)
 			{
 				throw new NotSupportedException("Branch offset of " + offset + " does not fit in one-byte branch target at position " + code.Position);
 			}
 			code.Write((byte)offset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="491" endline="512">
<![CDATA[
 
 		protected override void CreateArguments (ResolveContext ec, Parameter parameter, ref Arguments args)
 		{
 			args = new Arguments (4);
 
 			if (IdentifierType != null)
 				expr = CreateCastExpression (expr);
 
 			args.Add (new Argument (expr));
 
 			outer_selector.SetParameter (parameter.Clone ());
 			var lambda = new LambdaExpression (outer_selector.StartLocation);
 			lambda.Block = outer_selector;
 			args.Add (new Argument (lambda));
 
 			inner_selector.SetParameter (new ImplicitLambdaParameter (identifier.Name, identifier.Location));
 			lambda = new LambdaExpression (inner_selector.StartLocation);
 			lambda.Block = inner_selector;
 			args.Add (new Argument (lambda));
 
 			base.CreateArguments (ec, parameter, ref args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="100" endline="115">
<![CDATA[
 
 		internal void WriteSectionHeader(SectionHeader sectionHeader)
 		{
 			byte[] name = new byte[8];
 			System.Text.Encoding.UTF8.GetBytes(sectionHeader.Name, 0, sectionHeader.Name.Length, name, 0);
 			bw.Write(name);
 			bw.Write(sectionHeader.VirtualSize);
 			bw.Write(sectionHeader.VirtualAddress);
 			bw.Write(sectionHeader.SizeOfRawData);
 			bw.Write(sectionHeader.PointerToRawData);
 			bw.Write(sectionHeader.PointerToRelocations);
 			bw.Write(sectionHeader.PointerToLinenumbers);
 			bw.Write(sectionHeader.NumberOfRelocations);
 			bw.Write(sectionHeader.NumberOfLinenumbers);
 			bw.Write(sectionHeader.Characteristics);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="58" endline="68">
<![CDATA[
 
 		internal override PropertySignature PropertySignature
 		{
 			get
 			{
 				if (sig == null)
 				{
 					sig = PropertySignature.ReadSig(module, module.GetBlob(module.Property.records[index].Type), declaringType);
 				}
 				return sig;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="957" endline="975">
<![CDATA[
 
 		public override void GetPEKind(out PortableExecutableKinds peKind, out ImageFileMachine machine)
 		{
 			peKind = 0;
 			if ((cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_ILONLY) != 0)
 			{
 				peKind |= PortableExecutableKinds.ILOnly;
 			}
 			if ((cliHeader.Flags & CliHeader.COMIMAGE_FLAGS_32BITREQUIRED) != 0)
 			{
 				peKind |= PortableExecutableKinds.Required32Bit;
 			}
 			if (peFile.OptionalHeader.Magic == IMAGE_OPTIONAL_HEADER.IMAGE_NT_OPTIONAL_HDR64_MAGIC)
 			{
 				peKind |= PortableExecutableKinds.PE32Plus;
 			}
 
 			machine = (ImageFileMachine)peFile.FileHeader.Machine;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="278" endline="284">
<![CDATA[
 
 		internal int Add(Guid guid)
 		{
 			Debug.Assert(!frozen);
 			list.Add(guid);
 			return list.Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="62" endline="74">
<![CDATA[
 		}
 
 		void ShowTime (string msg)
 		{
 			if (!timestamps)
 				return;
 
 			stopwatch.Stop ();
 
 			Console.WriteLine ("{0,5}ms {1}", stopwatch.ElapsedMilliseconds, msg);
 
 			stopwatch = Stopwatch.StartNew ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="294" endline="323">
<![CDATA[
 
 		private sealed class Unbinder 
 		{
 			internal static readonly Unbinder Instance = new Unbinder();
 
 			private Unbinder()
 			{
 			}
 
 			public Type BindTypeParameter(Type type)
 			{
 				return type;
 			}
 
 			public Type BindMethodParameter(Type type)
 			{
 				return UnboundGenericMethodParameter.Make(type.GenericParameterPosition);
 			}
 		}
 
 		internal static MethodSignature MakeFromBuilder(Type returnType, Type[] parameterTypes, Type[][][] modifiers, CallingConventions callingConvention, int genericParamCount)
 		{
 			if (genericParamCount > 0)
 			{
 				returnType = returnType.BindTypeParameters(Unbinder.Instance);
 				parameterTypes = BindTypeParameters(Unbinder.Instance, parameterTypes);
 				modifiers = BindTypeParameters(Unbinder.Instance, modifiers);
 			}
 			return new MethodSignature(returnType, parameterTypes, modifiers, callingConvention, genericParamCount);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="396" endline="410">
<![CDATA[
 
 		private PropertyBuilder DefinePropertyImpl(string name, PropertyAttributes attributes, CallingConventions callingConvention, bool patchCallingConvention,
 			Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			if (properties == null)
 			{
 				properties = new List<PropertyBuilder>();
 			}
 			PropertySignature sig = PropertySignature.Create(callingConvention, returnType, returnTypeOptionalCustomModifiers, returnTypeRequiredCustomModifiers,
 				parameterTypes, parameterTypeOptionalCustomModifiers, parameterTypeRequiredCustomModifiers);
 			PropertyBuilder pb = new PropertyBuilder(this, name, attributes, sig, patchCallingConvention);
 			properties.Add(pb);
 			return pb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="771" endline="780">
<![CDATA[
 
 		public void EmitCalli(OpCode opc, CallingConvention callingConvention, Type returnType, Type[] parameterTypes)
 		{
 			returnType = returnType ?? moduleBuilder.universe.System_Void;
 			Emit(opc);
 			UpdateStack(opc, false, returnType, parameterTypes.Length);
 			ByteBuffer sig = new ByteBuffer(16);
 			Signature.WriteStandAloneMethodSig(moduleBuilder, sig, callingConvention, returnType, parameterTypes);
 			code.Write(0x11000000 | moduleBuilder.StandAloneSig.FindOrAddRecord(moduleBuilder.Blobs.Add(sig)));
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6051" endline="6066">
<![CDATA[
 
 void push_current_class (TypeContainer tc, object partial_token)
 {
 	if (RootContext.EvalMode){
 		tc.ModFlags = (tc.ModFlags & ~(Modifiers.PRIVATE|Modifiers.INTERNAL)) | Modifiers.PUBLIC;
 		undo.AddTypeContainer (current_container, tc);
 	}
 
 	if (partial_token != null)
 		current_container = current_container.AddPartial (tc);
 	else
 		current_container = current_container.AddTypeContainer (tc);
 
 	++lexer.parsing_declaration;
 	current_class = tc;
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="150" endline="174">
<![CDATA[
 
 			set {
 				//
 				// If the lookahead was too small, re-read from the beginning. Increase the buffer size while we're at it
 				// This should never happen until we are parsing some weird source code
 				//
 				if (value < buffer_start) {
 					InitializeStream (read_ahead_length);
 
 					//
 					// Discard buffer data after underlying stream changed position
 					// Cannot use handy reader.DiscardBufferedData () because it for
 					// some strange reason resets encoding as well
 					//
 					reader = new StreamReader (stream, reader.CurrentEncoding, true);
 				}
 
 				while (value > buffer_start + char_count) {
 					pos = char_count;
 					if (!ReadBuffer ())
 						throw new InternalErrorException ("Seek beyond end of file
 				}
 				while (value > buffer_start + char_count) {
 					pos = char_count;
 					if (!ReadBuffer ())
 						throw new InternalErrorException ("Seek beyond end of file
 				}
 
 				pos = value - buffer_start;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1827" endline="1838">
<![CDATA[
 
 		protected override string GetSuffix()
 		{
 			if (rank == 1)
 			{
 				return "[*]";
 			}
 			else
 			{
 				return "[" + new String(',', rank - 1) + "]";
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="763" endline="784">
<![CDATA[
 
 	//
 	// Checks whether `type' is a nested child of `parent'.
 	//
 	public static bool IsNestedChildOf (TypeSpec type, ITypeDefinition parent)
 	{
 		if (type == null)
 			return false;
 
 		if (type.MemberDefinition == parent)
 			return false;
 
 		type = type.DeclaringType;
 		while (type != null) {
 			if (type.MemberDefinition == parent)
 				return true;
 
 			type = type.DeclaringType;
 		}
 		while (type != null) {
 			if (type.MemberDefinition == parent)
 				return true;
 
 			type = type.DeclaringType;
 		}
 
 		return false;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="74" endline="86">
<![CDATA[
 
 		public override bool Define ()
 		{
 			if (!ResolveMemberType ())
 				return false;
 
 			const FieldAttributes attr = FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal;
 			FieldBuilder = Parent.TypeBuilder.DefineField (Name, MemberType.GetMetaInfo (), attr);
 			spec = new ConstSpec (Parent.Definition, this, MemberType, FieldBuilder, ModFlags, initializer);
 
 			Parent.MemberCache.AddMember (spec);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2953" endline="2968">
<![CDATA[
 
 		bool OverloadResolver.IErrorHandler.ArgumentMismatch (ResolveContext rc, MemberSpec best, Argument arg, int index)
 		{
 			rc.Report.SymbolRelatedToPreviousError (best);
 			rc.Report.Error (1928, loc,
 				"Type `{0}' does not contain a member `{1}' and the best extension method overload `{2}' has some invalid arguments",
 				queried_type.GetSignatureForError (), Name, best.GetSignatureForError ());
 
 			if (index == 0) {
 				rc.Report.Error (1929, loc,
 					"Extension method instance type `{0}' cannot be converted to `{1}'",
 					arg.Type.GetSignatureForError (), ((MethodSpec)best).Parameters.ExtensionMethodType.GetSignatureForError ());
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="59" endline="69">
<![CDATA[
 
 		public virtual void DefineSymbolInfo (MonoSymbolWriter symwriter)
 		{
 			if (guid != null)
 				file = symwriter.DefineDocument (Path, guid, checksum);
 			else {
 				file = symwriter.DefineDocument (Path);
 				if (AutoGenerated)
 					file.SetAutoGenerated ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3851" endline="3861">
<![CDATA[
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			if ((oper & Operator.LogicalMask) != 0 ||
 				(ec.HasSet (EmitContext.Options.CheckedScope) && (oper == Operator.Multiply || oper == Operator.Addition || oper == Operator.Subtraction))) {
 				base.EmitSideEffect (ec);
 			} else {
 				left.EmitSideEffect (ec);
 				right.EmitSideEffect (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1247" endline="1268">
<![CDATA[
 
 		void DoEmit (EmitContext ec, bool is_expr)
 		{
 			Label is_null_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			unwrap.EmitCheck (ec);
 			ec.Emit (OpCodes.Brfalse, is_null_label);
 
 			if (is_expr) {
 				underlying.Emit (ec);
 				ec.Emit (OpCodes.Br_S, end_label);
 			} else {
 				underlying.EmitStatement (ec);
 			}
 
 			ec.MarkLabel (is_null_label);
 			if (is_expr)
 				LiftedNull.Create (type, loc).Emit (ec);
 
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="785" endline="793">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			// It's null for ResolveLValue used without assignment
 			if (binder_expr == null)
 				EmitCall (ec, setter, Arguments, false);
 			else
 				base.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="794" endline="802">
<![CDATA[
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			// It's null for ResolveLValue used without assignment
 			if (binder_expr == null)
 				EmitCall (ec, setter, Arguments, true);
 			else
 				base.EmitStatement (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="54" endline="61">
<![CDATA[
 		}
 
 		internal byte PeekByte()
 		{
 			if (pos == end)
 				throw new BadImageFormatException();
 			return buffer[pos];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="120" endline="128">
<![CDATA[
 
 		public SourceMethodBuilder OpenMethod (ICompileUnit file, int ns_id, IMethodDef method)
 		{
 			SourceMethodBuilder builder = new SourceMethodBuilder (file, ns_id, method);
 			current_method_stack.Push (current_method);
 			current_method = builder;
 			methods.Add (current_method);
 			return builder;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4193" endline="4209">
<![CDATA[
 
 		protected override void EmitFinallyBody (EmitContext ec)
 		{
 			//
 			// if (lock_taken) Monitor.Exit (expr_copy)
 			//
 			Label skip = ec.DefineLabel ();
 
 			if (lock_taken != null) {
 				lock_taken.Emit (ec);
 				ec.Emit (OpCodes.Brfalse_S, skip);
 			}
 
 			expr_copy.Emit (ec);
 			ec.Emit (OpCodes.Call, TypeManager.void_monitor_exit_object);
 			ec.MarkLabel (skip);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="46" endline="73">
<![CDATA[
 
 		/// <summary>
 		///  This is used to obtain the actual value of the literal
 		///  cast into an object.
 		/// </summary>
 		public abstract object GetValue ();
 
 #if !STATIC
 		//
 		// Returns an object value which is typed to contant type
 		//
 		public virtual object GetTypedValue ()
 		{
 			return GetValue ();
 		}
 #endif
 
 		public override void Error_ValueCannotBeConverted (ResolveContext ec, Location loc, TypeSpec target, bool expl)
 		{
 			if (!expl && IsLiteral && 
 				(TypeManager.IsPrimitiveType (target) || type == TypeManager.decimal_type) &&
 				(TypeManager.IsPrimitiveType (type) || type == TypeManager.decimal_type)) {
 				ec.Report.Error (31, loc, "Constant value `{0}' cannot be converted to a `{1}'",
 					AsString (), TypeManager.CSharpName (target));
 			} else {
 				base.Error_ValueCannotBeConverted (ec, loc, target, expl);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="68" endline="87">
<![CDATA[
 
 		internal CustomAttributeData(Assembly asm, ConstructorInfo constructor, ByteReader br)
 		{
 			this.lazyConstructor = constructor;
 			if (br.Length == 0)
 			{
 				// it's legal to have an empty blob
 				lazyConstructorArguments = Empty<CustomAttributeTypedArgument>.Array;
 				lazyNamedArguments = Empty<CustomAttributeNamedArgument>.Array;
 			}
 			else
 			{
 				if (br.ReadUInt16() != 1)
 				{
 					throw new BadImageFormatException();
 				}
 				lazyConstructorArguments = ReadConstructorArguments(asm, br, constructor);
 				lazyNamedArguments = ReadNamedArguments(asm, br, br.ReadUInt16(), constructor.DeclaringType);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="96" endline="381">
<![CDATA[
 
 		// <summary>
 		//   The type of this flow branching.
 		// </summary>
 		public readonly BranchingType Type;
 
 		// <summary>
 		//   The block this branching is contained in.  This may be null if it's not
 		//   a top-level block and it doesn't declare any local variables.
 		// </summary>
 		public readonly Block Block;
 
 		// <summary>
 		//   The parent of this branching or null if this is the top-block.
 		// </summary>
 		public readonly FlowBranching Parent;
 
 		// <summary>
 		//   Start-Location of this flow branching.
 		// </summary>
 		public readonly Location Location;
 
 		static int next_id = 0;
 		int id;
 
 		// <summary>
 		//   The vector contains a BitArray with information about which local variables
 		//   and parameters are already initialized at the current code position.
 		// </summary>
 		public class UsageVector {
 			// <summary>
 			//   The type of this branching.
 			// </summary>
 			public readonly SiblingType Type;
 
 			// <summary>
 			//   Start location of this branching.
 			// </summary>
 			public Location Location;
 
 			// <summary>
 			//   This is only valid for SwitchSection, Try, Catch and Finally.
 			// </summary>
 			public readonly Block Block;
 
 			// <summary>
 			//   The number of locals in this block.
 			// </summary>
 			public readonly int CountLocals;
 
 			// <summary>
 			//   If not null, then we inherit our state from this vector and do a
 			//   copy-on-write.  If null, then we're the first sibling in a top-level
 			//   block and inherit from the empty vector.
 			// </summary>
 			public readonly UsageVector InheritsFrom;
 
 			// <summary>
 			//   This is used to construct a list of UsageVector's.
 			// </summary>
 			public UsageVector Next;
 
 			//
 			// Private.
 			//
 			MyBitVector locals;
 			bool is_unreachable;
 
 			static int next_id = 0;
 			int id;
 
 			//
 			// Normally, you should not use any of these constructors.
 			//
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc, int num_locals)
 			{
 				this.Type = type;
 				this.Block = block;
 				this.Location = loc;
 				this.InheritsFrom = parent;
 				this.CountLocals = num_locals;
 
 				locals = num_locals == 0 
 					? MyBitVector.Empty
 					
 
 				if (parent != null)
 					is_unreachable = parent.is_unreachable;
 
 				id = ++next_id;
 
 			}
 
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc)
 				
 			{ }
 
 			private UsageVector (MyBitVector locals, bool is_unreachable, Block block, Location loc)
 			{
 				this.Type = SiblingType.Block;
 				this.Location = loc;
 				this.Block = block;
 
 				this.is_unreachable = is_unreachable;
 
 				this.locals = locals;
 
 				id = ++next_id;
 
 			}
 
 			// <summary>
 			//   This does a deep copy of the usage vector.
 			// </summary>
 			public UsageVector Clone ()
 			{
 				UsageVector retval = new UsageVector (Type, null, Block, Location, CountLocals);
 
 				retval.locals = locals.Clone ();
 				retval.is_unreachable = is_unreachable;
 
 				return retval;
 			}
 
 			public bool IsAssigned (VariableInfo var, bool ignoreReachability)
 			{
 				if (!ignoreReachability && !var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsAssigned (locals);
 			}
 
 			public void SetAssigned (VariableInfo var)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetAssigned (locals);
 			}
 
 			public bool IsFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsFieldAssigned (locals, name);
 			}
 
 			public void SetFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetFieldAssigned (locals, name);
 			}
 
 			public bool IsUnreachable {
 				get { return is_unreachable; }
 			}
 
 			public void ResetBarrier ()
 			{
 				is_unreachable = false;
 			}
 
 			public void Goto ()
 			{
 				is_unreachable = true;
 			}
 
 			public static UsageVector MergeSiblings (UsageVector sibling_list, Location loc)
 			{
 				if (sibling_list.Next == null)
 					return sibling_list;
 
 				MyBitVector locals = null;
 				bool is_unreachable = sibling_list.is_unreachable;
 
 				if (!sibling_list.IsUnreachable)
 					locals &= sibling_list.locals;
 
 				for (UsageVector child = sibling_list.Next; child != null; child = child.Next) {
 					is_unreachable &= child.is_unreachable;
 
 					if (!child.IsUnreachable)
 						locals &= child.locals;
 				}
 
 				return new UsageVector (locals, is_unreachable, null, loc);
 			}
 
 			// <summary>
 			//   Merges a child branching.
 			// </summary>
 			public UsageVector MergeChild (UsageVector child, bool overwrite)
 			{
 				Report.Debug (2, "    MERGING CHILD EFFECTS", this, child, Type);
 
 				bool new_isunr = child.is_unreachable;
 
 				//
 				// We've now either reached the point after the branching or we will
 				// never get there since we always return or always throw an exception.
 				//
 				// If we can reach the point after the branching, mark all locals and
 				// parameters as initialized which have been initialized in all branches
 				// we need to look at (see above).
 				//
 
 				if ((Type == SiblingType.SwitchSection) && !new_isunr) {
 					Report.Error (163, Location,
 						      "Control cannot fall through from one " +
 						      "case label to another");
 					return child;
 				}
 
 				locals |= child.locals;
 
 				// throw away un-necessary information about variables in child blocks
 				if (locals.Count != CountLocals)
 					locals = new MyBitVector (locals, CountLocals);
 
 				if (overwrite)
 					is_unreachable = new_isunr;
 				else
 					is_unreachable |= new_isunr;
 
 				return child;
 			}
 
 			public void MergeOrigins (UsageVector o_vectors)
 			{
 				Report.Debug (1, "  MERGING BREAK ORIGINS", this);
 
 				if (o_vectors == null)
 					return;
 
 				if (IsUnreachable && locals != null)
 					locals.SetAll (true);
 
 				for (UsageVector vector = o_vectors; vector != null; vector = vector.Next) {
 					Report.Debug (1, "    MERGING BREAK ORIGIN", vector);
 					if (vector.IsUnreachable)
 						continue;
 					locals &= vector.locals;
 					is_unreachable &= vector.is_unreachable;
 				}
 
 				Report.Debug (1, "  MERGING BREAK ORIGINS DONE", this);
 			}
 
 			//
 			// Debugging stuff.
 			//
 
 			public override string ToString ()
 			{
 				return String.Format ("Vector ({0},{1},{2}-{3})", Type, id, is_unreachable, locals);
 			}
 		}
 
 		// <summary>
 		//   Creates a new flow branching which is contained in `parent'.
 		//   You should only pass non-null for the `block' argument if this block
 		//   introduces any new variables - in this case, we need to create a new
 		//   usage vector with a different size than our parent's one.
 		// </summary>
 		protected FlowBranching (FlowBranching parent, BranchingType type, SiblingType stype,
 					 Block block, Location loc)
 		{
 			Parent = parent;
 			Block = block;
 			Location = loc;
 			Type = type;
 			id = ++next_id;
 
 			UsageVector vector;
 			if (Block != null) {
 				UsageVector parent_vector = parent != null ? parent.CurrentUsageVector 
 				vector = new UsageVector (stype, parent_vector, Block, loc, Block.AssignableSlots);
 			} else {
 				vector = new UsageVector (stype, Parent.CurrentUsageVector, null, loc);
 			}
 
 			AddSibling (vector);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="478" endline="525">
<![CDATA[
 
 		protected void EmitOperator (EmitContext ec, TypeSpec type)
 		{
 			switch (Oper) {
 			case Operator.UnaryPlus
 				Expr.Emit (ec);
 				break;
 				
 			case Operator.UnaryNegation
 				if (ec.HasSet (EmitContext.Options.CheckedScope) && !IsFloat (type)) {
 					ec.Emit (OpCodes.Ldc_I4_0);
 					if (type == TypeManager.int64_type)
 						ec.Emit (OpCodes.Conv_U8);
 					Expr.Emit (ec);
 					ec.Emit (OpCodes.Sub_Ovf);
 				} else {
 					Expr.Emit (ec);
 					ec.Emit (OpCodes.Neg);
 				}
 				
 				break;
 				
 			case Operator.LogicalNot
 				Expr.Emit (ec);
 				ec.Emit (OpCodes.Ldc_I4_0);
 				ec.Emit (OpCodes.Ceq);
 				break;
 				
 			case Operator.OnesComplement
 				Expr.Emit (ec);
 				ec.Emit (OpCodes.Not);
 				break;
 				
 			case Operator.AddressOf
 				((IMemoryLocation)Expr).AddressOf (ec, AddressOp.LoadStore);
 				break;
 				
 			default
 				throw new Exception ("This should not happen
 						     + Oper.ToString ());
 			}
 
 			//
 			// Same trick as in Binary expression
 			//
 			if (enum_conversion != null)
 				enum_conversion.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="232" endline="241">
<![CDATA[
 
 		internal void DefineCapturedVariable (int scope_id, string name, string captured_name,
 						      CapturedVariable.CapturedKind kind)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedVariable (name, captured_name, kind);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="290" endline="309">
<![CDATA[
 
 		protected static Expression CreateRangeVariableType (ResolveContext rc, Parameter parameter, RangeVariable name, Expression init)
 		{
 			var args = new List<AnonymousTypeParameter> (2);
 
 			//
 			// The first argument is the reference to the parameter
 			//
 			args.Add (new AnonymousTypeParameter (new RangeParameterReference (parameter), parameter.Name, parameter.Location));
 
 			//
 			// The second argument is the linq expression
 			//
 			args.Add (new RangeAnonymousTypeParameter (init, name));
 
 			//
 			// Create unique anonymous type
 			//
 			return new NewAnonymousType (args, rc.MemberContext.CurrentMemberDefinition.Parent, name.Location);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\literal.cs" startline="44" endline="61">
<![CDATA[
 
 		public override void Error_ValueCannotBeConverted (ResolveContext ec, Location loc, TypeSpec t, bool expl)
 		{
 			if (t.IsGenericParameter) {
 				ec.Report.Error(403, loc,
 					"Cannot convert null to the type parameter `{0}' because it could be a value " +
 					"type. Consider using `default ({0})' instead", t.Name);
 				return;
 			}
 
 			if (TypeManager.IsValueType (t)) {
 				ec.Report.Error(37, loc, "Cannot convert null to `{0}' because it is a value type",
 					TypeManager.CSharpName(t));
 				return;
 			}
 
 			base.Error_ValueCannotBeConverted (ec, loc, t, expl);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3946" endline="3995">
<![CDATA[
 		}
 
 		#endregion
 
 		protected abstract void EmitPreTryBody (EmitContext ec);
 		protected abstract void EmitTryBody (EmitContext ec);
 		protected abstract void EmitFinallyBody (EmitContext ec);
 
 		protected sealed override void DoEmit (EmitContext ec)
 		{
 			EmitPreTryBody (ec);
 
 			if (resume_points != null) {
 				ec.EmitInt ((int) Iterator.State.Running);
 				ec.Emit (OpCodes.Stloc, iter.CurrentPC);
 			}
 
 			ec.BeginExceptionBlock ();
 
 			if (resume_points != null) {
 				ec.MarkLabel (resume_point);
 
 				// For normal control flow, we want to fall-through the Switch
 				// So, we use CurrentPC rather than the $PC field, and initialize it to an outside value above
 				ec.Emit (OpCodes.Ldloc, iter.CurrentPC);
 				ec.EmitInt (first_resume_pc);
 				ec.Emit (OpCodes.Sub);
 
 				Label [] labels = new Label [resume_points.Count];
 				for (int i = 0; i < resume_points.Count; ++i)
 					labels [i] = resume_points [i].PrepareForEmit (ec);
 				for (int i = 0; i < resume_points.Count; ++i)
 					labels [i] = resume_points [i].PrepareForEmit (ec);
 				ec.Emit (OpCodes.Switch, labels);
 			}
 
 			EmitTryBody (ec);
 
 			ec.BeginFinallyBlock ();
 
 			Label start_finally = ec.DefineLabel ();
 			if (resume_points != null) {
 				ec.Emit (OpCodes.Ldloc, iter.SkipFinally);
 				ec.Emit (OpCodes.Brfalse_S, start_finally);
 				ec.Emit (OpCodes.Endfinally);
 			}
 
 			ec.MarkLabel (start_finally);
 			EmitFinallyBody (ec);
 
 			ec.EndExceptionBlock ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="153" endline="272">
<![CDATA[
 	}
 
 	sealed class IMAGE_OPTIONAL_HEADER
 	{
 		public const WORD IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x10b;
 		public const WORD IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x20b;
 
 		public const WORD IMAGE_SUBSYSTEM_WINDOWS_GUI = 2;
 		public const WORD IMAGE_SUBSYSTEM_WINDOWS_CUI = 3;
 
 		public const WORD IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = 0x0040;
 		public const WORD IMAGE_DLLCHARACTERISTICS_NX_COMPAT = 0x0100;
 		public const WORD IMAGE_DLLCHARACTERISTICS_NO_SEH = 0x0400;
 		public const WORD IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = 0x8000;
 
 		public WORD Magic = IMAGE_NT_OPTIONAL_HDR32_MAGIC;
 		public BYTE MajorLinkerVersion = 8;
 		public BYTE MinorLinkerVersion = 0;
 		public DWORD SizeOfCode;
 		public DWORD SizeOfInitializedData;
 		public DWORD SizeOfUninitializedData;
 		public DWORD AddressOfEntryPoint;
 		public DWORD BaseOfCode;
 		public DWORD BaseOfData;
 		public ULONGLONG ImageBase;
 		public DWORD SectionAlignment = 0x2000;
 		public DWORD FileAlignment = 0x200;
 		public WORD MajorOperatingSystemVersion = 4;
 		public WORD MinorOperatingSystemVersion = 0;
 		public WORD MajorImageVersion = 0;
 		public WORD MinorImageVersion = 0;
 		public WORD MajorSubsystemVersion = 4;
 		public WORD MinorSubsystemVersion = 0;
 		public DWORD Win32VersionValue = 0;
 		public DWORD SizeOfImage;
 		public DWORD SizeOfHeaders;
 		public DWORD CheckSum = 0;
 		public WORD Subsystem;
 		public WORD DllCharacteristics;
 		public ULONGLONG SizeOfStackReserve = 0x100000;
 		public ULONGLONG SizeOfStackCommit = 0x1000;
 		public ULONGLONG SizeOfHeapReserve = 0x100000;
 		public ULONGLONG SizeOfHeapCommit = 0x1000;
 		public DWORD LoaderFlags = 0;
 		public DWORD NumberOfRvaAndSizes = 16;
 		public IMAGE_DATA_DIRECTORY[] DataDirectory = new IMAGE_DATA_DIRECTORY[16];
 
 		internal void Write(BinaryWriter bw)
 		{
 			bw.Write(Magic);
 			bw.Write(MajorLinkerVersion);
 			bw.Write(MinorLinkerVersion);
 			bw.Write(SizeOfCode);
 			bw.Write(SizeOfInitializedData);
 			bw.Write(SizeOfUninitializedData);
 			bw.Write(AddressOfEntryPoint);
 			bw.Write(BaseOfCode);
 			if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
 			{
 				bw.Write(BaseOfData);
 				bw.Write((DWORD)ImageBase);
 			}
 			else
 			{
 				bw.Write(ImageBase);
 			}
 			bw.Write(SectionAlignment);
 			bw.Write(FileAlignment);
 			bw.Write(MajorOperatingSystemVersion);
 			bw.Write(MinorOperatingSystemVersion);
 			bw.Write(MajorImageVersion);
 			bw.Write(MinorImageVersion);
 			bw.Write(MajorSubsystemVersion);
 			bw.Write(MinorSubsystemVersion);
 			bw.Write(Win32VersionValue);
 			bw.Write(SizeOfImage);
 			bw.Write(SizeOfHeaders);
 			bw.Write(CheckSum);
 			bw.Write(Subsystem);
 			bw.Write(DllCharacteristics);
 			if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
 			{
 				bw.Write((DWORD)SizeOfStackReserve);
 			}
 			else
 			{
 				bw.Write(SizeOfStackReserve);
 			}
 			if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
 			{
 				bw.Write((DWORD)SizeOfStackCommit);
 			}
 			else
 			{
 				bw.Write(SizeOfStackCommit);
 			}
 			if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
 			{
 				bw.Write((DWORD)SizeOfHeapReserve);
 			}
 			else
 			{
 				bw.Write(SizeOfHeapReserve);
 			}
 			if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
 			{
 				bw.Write((DWORD)SizeOfHeapCommit);
 			}
 			else
 			{
 				bw.Write(SizeOfHeapCommit);
 			}
 			bw.Write(LoaderFlags);
 			bw.Write(NumberOfRvaAndSizes);
 			for (int i = 0; i < DataDirectory.Length; i++)
 			{
 				bw.Write(DataDirectory[i].VirtualAddress);
 				bw.Write(DataDirectory[i].Size);
 			}
 			for (int i = 0; i < DataDirectory.Length; i++)
 			{
 				bw.Write(DataDirectory[i].VirtualAddress);
 				bw.Write(DataDirectory[i].Size);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4811" endline="4832">
<![CDATA[
 	}
 
 	public class TryCatch 
 		public Block Block;
 		public List<Catch> Specific;
 		public Catch General;
 		bool inside_try_finally, code_follows;
 
 		public TryCatch (Block block, List<Catch> catch_clauses, Location l, bool inside_try_finally)
 		{
 			this.Block = block;
 			this.Specific = catch_clauses;
 			this.inside_try_finally = inside_try_finally;
 
 			Catch c = catch_clauses [0];
 			if (c.IsGeneral) {
 				this.General = c;			
 				catch_clauses.RemoveAt (0);
 			}
 
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="273" endline="289">
<![CDATA[
 
 		private static Type ReadTypeOrByRef(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			if (br.PeekByte() == ELEMENT_TYPE_BYREF)
 			{
 				br.ReadByte();
 				// LAMESPEC it is allowed (by C++/CLI, ilasm and peverify) to have custom modifiers after the BYREF
 				// (which makes sense, as it is analogous to pointers)
 				CustomModifiers mods = ReadCustomModifiers(module, br, context);
 				// C++/CLI generates void& local variables, so we need to use ReadTypeOrVoid here
 				return ReadTypeOrVoid(module, br, context).__MakeByRefType(mods.required, mods.optional);
 			}
 			else
 			{
 				return ReadType(module, br, context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="221" endline="268">
<![CDATA[
 	}
 
 	public sealed class TypeBuilder 
 	{
 		public const int UnspecifiedTypeSize = 0;
 		private readonly ITypeOwner owner;
 		private readonly int token;
 		private int extends;
 		private Type baseType;
 		private readonly int typeName;
 		private readonly int typeNameSpace;
 		private readonly string nameOrFullName;
 		private readonly List<MethodBuilder> methods = new List<MethodBuilder>();
 		private readonly List<FieldBuilder> fields = new List<FieldBuilder>();
 		private List<PropertyBuilder> properties;
 		private List<EventBuilder> events;
 		private TypeAttributes attribs;
 		private TypeFlags typeFlags;
 		private GenericTypeParameterBuilder[] gtpb;
 		private List<CustomAttributeBuilder> declarativeSecurity;
 		private List<Type> interfaces;
 
 		[Flags]
 		private enum TypeFlags
 		{
 			IsGenericTypeDefinition = 1,
 			HasNestedTypes = 2,
 			Baked = 4,
 		}
 
 		internal TypeBuilder(ITypeOwner owner, string name, Type baseType, TypeAttributes attribs)
 		{
 			this.owner = owner;
 			this.token = this.ModuleBuilder.TypeDef.AllocToken();
 			this.nameOrFullName = TypeNameParser.Escape(name);
 			SetParent(baseType);
 			this.attribs = attribs;
 			if (!this.IsNested)
 			{
 				int lastdot = name.LastIndexOf('.');
 				if (lastdot > 0)
 				{
 					this.typeNameSpace = this.ModuleBuilder.Strings.Add(name.Substring(0, lastdot));
 					name = name.Substring(lastdot + 1);
 				}
 			}
 			this.typeName = this.ModuleBuilder.Strings.Add(name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2643" endline="2652">
<![CDATA[
 
 		private int consume_identifier (int s)
 		{
 			int res = consume_identifier (s, false);
 
 			if (doc_state == XmlCommentState.Allowed)
 				doc_state = XmlCommentState.NotAllowed;
 
 			return res;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="700" endline="710">
<![CDATA[
 
 	//
 	// Null is considered to be a reference type
 	//			
 	public static bool IsReferenceType (TypeSpec t)
 	{
 		if (t.IsGenericParameter)
 			return ((TypeParameterSpec) t).IsReferenceType;
 
 		return !t.IsStruct && !IsEnumType (t);
 	}			
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="915" endline="1005">
<![CDATA[
 
 		internal void AddConstant(int parentToken, object defaultValue)
 		{
 			ConstantTable.Record rec = new ConstantTable.Record();
 			rec.Parent = parentToken;
 			ByteBuffer val = new ByteBuffer(16);
 			if (defaultValue == null)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_CLASS;
 				val.Write((int)0);
 			}
 			else if (defaultValue is bool)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_BOOLEAN;
 				val.Write((bool)defaultValue ? (byte)1 
 			}
 			else if (defaultValue is char)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_CHAR;
 				val.Write((char)defaultValue);
 			}
 			else if (defaultValue is sbyte)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_I1;
 				val.Write((sbyte)defaultValue);
 			}
 			else if (defaultValue is byte)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_U1;
 				val.Write((byte)defaultValue);
 			}
 			else if (defaultValue is short)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_I2;
 				val.Write((short)defaultValue);
 			}
 			else if (defaultValue is ushort)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_U2;
 				val.Write((ushort)defaultValue);
 			}
 			else if (defaultValue is int)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_I4;
 				val.Write((int)defaultValue);
 			}
 			else if (defaultValue is uint)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_U4;
 				val.Write((uint)defaultValue);
 			}
 			else if (defaultValue is long)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_I8;
 				val.Write((long)defaultValue);
 			}
 			else if (defaultValue is ulong)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_U8;
 				val.Write((ulong)defaultValue);
 			}
 			else if (defaultValue is float)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_R4;
 				val.Write((float)defaultValue);
 			}
 			else if (defaultValue is double)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_R8;
 				val.Write((double)defaultValue);
 			}
 			else if (defaultValue is string)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_STRING;
 				foreach (char c in (string)defaultValue)
 				{
 					val.Write(c);
 				}
 				foreach (char c in (string)defaultValue)
 				{
 					val.Write(c);
 				}
 			}
 			else if (defaultValue is DateTime)
 			{
 				rec.Type = Signature.ELEMENT_TYPE_I8;
 				val.Write(((DateTime)defaultValue).Ticks);
 			}
 			else
 			{
 				throw new ArgumentException();
 			}
 			rec.Value = this.Blobs.Add(val);
 			this.Constant.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="618" endline="637">
<![CDATA[
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			if ((ModFlags & Modifiers.BACKING_FIELD) != 0)
 				return;
 
 			base.DoMemberTypeDependentChecks ();
 
 			if ((ModFlags & Modifiers.VOLATILE) != 0) {
 				if (!CanBeVolatile ()) {
 					Report.Error (677, Location, "`{0}'
 						GetSignatureForError (), TypeManager.CSharpName (MemberType));
 				}
 
 				if ((ModFlags & Modifiers.READONLY) != 0) {
 					Report.Error (678, Location, "`{0}'
 						GetSignatureForError ());
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="496" endline="539">
<![CDATA[
 
 		//
 		// Load the object from the pointer.  
 		//
 		public void EmitLoadFromPtr (TypeSpec t)
 		{
 			if (t == TypeManager.int32_type)
 				ig.Emit (OpCodes.Ldind_I4);
 			else if (t == TypeManager.uint32_type)
 				ig.Emit (OpCodes.Ldind_U4);
 			else if (t == TypeManager.short_type)
 				ig.Emit (OpCodes.Ldind_I2);
 			else if (t == TypeManager.ushort_type)
 				ig.Emit (OpCodes.Ldind_U2);
 			else if (t == TypeManager.char_type)
 				ig.Emit (OpCodes.Ldind_U2);
 			else if (t == TypeManager.byte_type)
 				ig.Emit (OpCodes.Ldind_U1);
 			else if (t == TypeManager.sbyte_type)
 				ig.Emit (OpCodes.Ldind_I1);
 			else if (t == TypeManager.uint64_type)
 				ig.Emit (OpCodes.Ldind_I8);
 			else if (t == TypeManager.int64_type)
 				ig.Emit (OpCodes.Ldind_I8);
 			else if (t == TypeManager.float_type)
 				ig.Emit (OpCodes.Ldind_R4);
 			else if (t == TypeManager.double_type)
 				ig.Emit (OpCodes.Ldind_R8);
 			else if (t == TypeManager.bool_type)
 				ig.Emit (OpCodes.Ldind_I1);
 			else if (t == TypeManager.intptr_type)
 				ig.Emit (OpCodes.Ldind_I);
 			else if (t.IsEnum) {
 				if (t == TypeManager.enum_type)
 					ig.Emit (OpCodes.Ldind_Ref);
 				else
 					EmitLoadFromPtr (EnumSpec.GetUnderlyingType (t));
 			} else if (TypeManager.IsStruct (t) || TypeManager.IsGenericParameter (t))
 				Emit (OpCodes.Ldobj, t);
 			else if (t.IsPointer)
 				ig.Emit (OpCodes.Ldind_I);
 			else
 				ig.Emit (OpCodes.Ldind_Ref);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="318" endline="330">
<![CDATA[
 
 		protected virtual Expression ResolveEnumOperator (ResolveContext ec, Expression expr)
 		{
 			TypeSpec underlying_type = EnumSpec.GetUnderlyingType (expr.Type);
 			Expression best_expr = ResolvePrimitivePredefinedType (EmptyCast.Create (expr, underlying_type));
 			if (best_expr == null)
 				return null;
 
 			Expr = best_expr;
 			enum_conversion = Convert.ExplicitNumericConversion (new EmptyExpression (best_expr.Type), underlying_type);
 			type = expr.Type;
 			return EmptyCast.Create (this, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="538" endline="557">
<![CDATA[
 
 		/// <summary>
 		///   Returns a fully formed expression after a MemberLookup
 		/// </summary>
 		/// 
 		static Expression ExprClassFromMemberInfo (MemberSpec spec, Location loc)
 		{
 			if (spec is EventSpec)
 				return new EventExpr ((EventSpec) spec, loc);
 			if (spec is ConstSpec)
 				return new ConstantExpr ((ConstSpec) spec, loc);
 			if (spec is FieldSpec)
 				return new FieldExpr ((FieldSpec) spec, loc);
 			if (spec is PropertySpec)
 				return new PropertyExpr ((PropertySpec) spec, loc);
 			if (spec is TypeSpec)
 				return new TypeExpression (((TypeSpec) spec), loc);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="106" endline="199">
<![CDATA[
 
 		internal void SetDllImportPseudoCustomAttribute(string dllName, string entryName, CallingConvention? nativeCallConv, CharSet? nativeCharSet,
 			bool? bestFitMapping, bool? throwOnUnmappableChar, bool? setLastError, bool? preserveSig, bool? exactSpelling)
 		{
 			const short NoMangle = 0x0001;
 			const short CharSetMask = 0x0006;
 			const short CharSetNotSpec = 0x0000;
 			const short CharSetAnsi = 0x0002;
 			const short CharSetUnicode = 0x0004;
 			const short CharSetAuto = 0x0006;
 			const short SupportsLastError = 0x0040;
 			const short CallConvMask = 0x0700;
 			const short CallConvWinapi = 0x0100;
 			const short CallConvCdecl = 0x0200;
 			const short CallConvStdcall = 0x0300;
 			const short CallConvThiscall = 0x0400;
 			const short CallConvFastcall = 0x0500;
 			// non-standard flags
 			const short BestFitOn = 0x0010;
 			const short BestFitOff = 0x0020;
 			const short CharMapErrorOn = 0x1000;
 			const short CharMapErrorOff = 0x2000;
 			int name = this.nameIndex;
 			short flags = CharSetNotSpec | CallConvWinapi;
 			if (bestFitMapping.HasValue)
 			{
 				flags |= bestFitMapping.Value ? BestFitOn 
 			}
 			if (throwOnUnmappableChar.HasValue)
 			{
 				flags |= throwOnUnmappableChar.Value ? CharMapErrorOn 
 			}
 			if (nativeCallConv.HasValue)
 			{
 				flags &= ~CallConvMask;
 				switch (nativeCallConv.Value)
 				{
 					case System.Runtime.InteropServices.CallingConvention.Cdecl
 						flags |= CallConvCdecl;
 						break;
 					case System.Runtime.InteropServices.CallingConvention.FastCall
 						flags |= CallConvFastcall;
 						break;
 					case System.Runtime.InteropServices.CallingConvention.StdCall
 						flags |= CallConvStdcall;
 						break;
 					case System.Runtime.InteropServices.CallingConvention.ThisCall
 						flags |= CallConvThiscall;
 						break;
 					case System.Runtime.InteropServices.CallingConvention.Winapi
 						flags |= CallConvWinapi;
 						break;
 				}
 			}
 			if (nativeCharSet.HasValue)
 			{
 				flags &= ~CharSetMask;
 				switch (nativeCharSet.Value)
 				{
 					case CharSet.Ansi
 					case CharSet.None
 						flags |= CharSetAnsi;
 						break;
 					case CharSet.Auto
 						flags |= CharSetAuto;
 						break;
 					case CharSet.Unicode
 						flags |= CharSetUnicode;
 						break;
 				}
 			}
 			if (entryName != null)
 			{
 				name = this.ModuleBuilder.Strings.Add(entryName);
 			}
 			if (exactSpelling.HasValue && exactSpelling.Value)
 			{
 				flags |= NoMangle;
 			}
 			if (!preserveSig.HasValue || preserveSig.Value)
 			{
 				implFlags |= MethodImplAttributes.PreserveSig;
 			}
 			if (setLastError.HasValue && setLastError.Value)
 			{
 				flags |= SupportsLastError;
 			}
 			ImplMapTable.Record rec = new ImplMapTable.Record();
 			rec.MappingFlags = flags;
 			rec.MemberForwarded = pseudoToken;
 			rec.ImportName = name;
 			rec.ImportScope = this.ModuleBuilder.ModuleRef.FindOrAddRecord(dllName == null ? 0 
 			this.ModuleBuilder.ImplMap.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="135" endline="143">
<![CDATA[
 		}
 
 		public bool IsConstantCompatible {
 			get {
 				if ((Kind & (MemberKind.Enum | MemberKind.Class | MemberKind.Interface | MemberKind.Delegate | MemberKind.ArrayType)) != 0)
 					return true;
 
 				return TypeManager.IsPrimitiveType (this) || this == TypeManager.decimal_type || this == InternalType.Dynamic;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="804" endline="818">
<![CDATA[
 
 		static string GetLookupName (MemberSpec ms)
 		{
 			if (ms.Kind == MemberKind.Indexer)
 				return IndexerNameAlias;
 
 			if (ms.Kind == MemberKind.Constructor) {
 				if (ms.IsStatic)
 					return Constructor.TypeConstructorName;
 
 				return Constructor.ConstructorName;
 			}
 
 			return ms.Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5303" endline="5330">
<![CDATA[
 
 		//
 		// Used to decide whether call or callvirt is needed
 		//
 		static bool IsVirtualCallRequired (Expression instance, MethodSpec method)
 		{
 			//
 			// There are 2 scenarious where we emit callvirt
 			//
 			// Case 1
 			// Case 2
 			// correct NRE exception when the method is called
 			//
 			var decl_type = method.DeclaringType;
 			if (decl_type.IsStruct || decl_type.IsEnum)
 				return false;
 
 			if (instance is BaseThis)
 				return false;
 
 			//
 			// It's non-virtual and will never be null
 			//
 			if (!method.IsVirtual && (instance is This || instance is New || instance is ArrayCreation || instance is DelegateCreation))
 				return false;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="832" endline="840">
<![CDATA[
 		}
 
 		public bool HasExtensionMethodType {
 			get {
 				if (Count == 0)
 					return false;
 
 				return FixedParameters [0].HasExtensionMethodModifier;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1601" endline="1654">
<![CDATA[
 
 		int escape (int c, out int surrogate)
 		{
 			bool error;
 			int d;
 			int v;
 
 			d = peek_char ();
 			if (c != '\\') {
 				surrogate = 0;
 				return c;
 			}
 			
 			switch (d){
 			case 'a'
 				v = '\a'; break;
 			case 'b'
 				v = '\b'; break;
 			case 'n'
 				v = '\n'; break;
 			case 't'
 				v = '\t'; break;
 			case 'v'
 				v = '\v'; break;
 			case 'r'
 				v = '\r'; break;
 			case '\\'
 				v = '\\'; break;
 			case 'f'
 				v = '\f'; break;
 			case '0'
 				v = 0; break;
 			case '"'
 				v = '"'; break;
 			case '\''
 				v = '\''; break;
 			case 'x'
 				v = getHex (-1, out surrogate, out error);
 				if (error)
 					goto default;
 				return v;
 			case 'u'
 			case 'U'
 				return EscapeUnicode (d, out surrogate);
 			default
 				surrogate = 0;
 				Report.Error (1009, Location, "Unrecognized escape sequence `\\{0}'", ((char)d).ToString ());
 				return d;
 			}
 
 			get_char ();
 			surrogate = 0;
 			return v;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="1641" endline="1650">
<![CDATA[
 
 		protected virtual void CheckEqualsAndGetHashCode ()
 		{
 			if (methods == null)
 				return;
 
 			if (HasEquals && !HasGetHashCode) {
 				Report.Warning (659, 3, this.Location, "`{0}' overrides Object.Equals(object) but does not override Object.GetHashCode()", this.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="450" endline="483">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type)
 				return new ShortConstant ((short) Value, Location);
 			if (target_type == TypeManager.ushort_type)
 				return new UShortConstant ((ushort) Value, Location);
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint) Value, Location);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type)
 				return new CharConstant ((char) Value, Location);
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="340" endline="419">
<![CDATA[
 
 		public static Expression ImplicitBoxingConversion (Expression expr, TypeSpec expr_type, TypeSpec target_type)
 		{
 			//
 			// From any value-type to the type object.
 			//
 			if (target_type == TypeManager.object_type || target_type == InternalType.Dynamic) {
 				//
 				// A pointer type cannot be converted to object
 				//
 				if (expr_type.IsPointer)
 					return null;
 
 				if (!TypeManager.IsValueType (expr_type))
 					return null;
 
 				return expr == null ? EmptyExpression.Null 
 			}
 			
 			//
 			// From any value-type to the type System.ValueType.
 			//
 			if (target_type == TypeManager.value_type) {
 				if (!TypeManager.IsValueType (expr_type))
 					return null;
 
 				return expr == null ? EmptyExpression.Null 
 			}
 
 			if (target_type == TypeManager.enum_type) {
 				//
 				// From any enum-type to the type System.Enum.
 				//
 				if (TypeManager.IsEnumType (expr_type))
 					return expr == null ? EmptyExpression.Null 
 			}
 
 			//
 			// From a nullable-type to a reference type, if a boxing conversion exists from
 			// the underlying type to the reference type
 			//
 			if (TypeManager.IsNullableType (expr_type)) {
 				if (!TypeManager.IsReferenceType (target_type))
 					return null;
 
 				var res = ImplicitBoxingConversion (expr, Nullable.NullableInfo.GetUnderlyingType (expr_type), target_type);
 
 				// "cast" underlying type to target type to emit correct InvalidCastException when
 				// underlying hierarchy changes without recompilation
 				if (res != null && expr != null)
 					res = new UnboxCast (res, target_type);
 
 				return res;
 			}
 
 			if (TypeSpec.IsBaseClass (expr_type, target_type, false)) {
 				//
 				// Don't box same type arguments
 				//
 				if (TypeManager.IsGenericParameter (expr_type) && expr_type != target_type)
 					return expr == null ? EmptyExpression.Null 
 
 				return null;
 			}
 
 			// This code is kind of mirrored inside ImplicitStandardConversionExists
 			// with the small distinction that we only probe there
 			//
 			// Always ensure that the code here and there is in sync
 
 			// from any class-type S to any interface-type T.
 			if (target_type.IsInterface) {
 				if (expr_type.ImplementsInterface (target_type, true) &&
 					(TypeManager.IsGenericParameter (expr_type) || TypeManager.IsValueType (expr_type))) {
 					return expr == null ? EmptyExpression.Null 
 				}
 			}
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="168" endline="195">
<![CDATA[
 
 
 		/// <summary>
 		/// Maybe ConvertTo name is better. It tries to convert `this' constant to target_type.
 		/// It throws OverflowException 
 		/// </summary>
 		// DON'T CALL THIS METHOD DIRECTLY AS IT DOES NOT HANDLE ENUMS
 		public abstract Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type);
 
 		/// <summary>
 		///   Attempts to do a compile-time folding of a constant cast.
 		/// </summary>
 		public Constant TryReduce (ResolveContext ec, TypeSpec target_type, Location loc)
 		{
 			try {
 				return TryReduce (ec, target_type);
 			}
 			catch (OverflowException) {
 				if (ec.ConstantCheckState) {				
 					ec.Report.Error (221, loc, "Constant value `{0}' cannot be converted to a `{1}' (use `unchecked' syntax to override)",
 						GetValue ().ToString (), TypeManager.CSharpName (target_type));
 				} else {
 					Error_ValueCannotBeConverted (ec, loc, target_type, false);
 				}
 
 				return New.Constantify (target_type, loc).Resolve (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="292" endline="309">
<![CDATA[
 
 		public void Warning (int code, int level, Location loc, string message)
 		{
 			if (reporting_disabled > 0)
 				return;
 
 			if (!IsWarningEnabled (code, level, loc))
 				return;
 
 			AbstractMessage msg;
 			if (IsWarningAsError (code))
 				msg = new ErrorMessage (code, loc, message, extra_information);
 			else
 				msg = new WarningMessage (code, loc, message, extra_information);
 
 			extra_information.Clear ();
 			printer.Print (msg);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="780" endline="786">
<![CDATA[
 
 		public void EmitHoistingAssignment (EmitContext ec)
 		{
 			SimpleAssign a = new SimpleAssign (GetFieldExpression (ec), new CompilerGeneratedThis (ec.CurrentType, field.Location));
 			if (a.Resolve (new ResolveContext (ec.MemberContext)) != null)
 				a.EmitStatement (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="354" endline="363">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			// TODO
 			LocalTemporary value_target = new LocalTemporary (type);
 
 			value_target.AddressOf (ec, AddressOp.Store);
 			ec.Emit (OpCodes.Initobj, type);
 			value_target.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1689" endline="1697">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			LocalTemporary temp_storage = new LocalTemporary(type);
 
 			temp_storage.AddressOf(ec, AddressOp.LoadStore);
 			ec.Emit(OpCodes.Initobj, type);
 			temp_storage.Emit(ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="100" endline="113">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1025" endline="1038">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="197" endline="204">
<![CDATA[
 
 		internal void Write(ByteBuffer bb)
 		{
 			if (pos + bb.Length > buffer.Length)
 				Grow(bb.Length);
 			Buffer.BlockCopy(bb.buffer, 0, buffer, pos, bb.Length);
 			pos += bb.Length;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="580" endline="591">
<![CDATA[
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetIndex" 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="161" endline="179">
<![CDATA[
 
 		public virtual void Error_NamespaceDoesNotExist (Location loc, string name, int arity, IMemberContext ctx)
 		{
 			FullNamedExpression retval = Lookup (ctx.Compiler, name, -System.Math.Max (1, arity), loc);
 			if (retval != null) {
 				Error_TypeArgumentsCannotBeUsed (ctx.Compiler.Report, loc, retval.Type, arity);
 				return;
 			}
 
 			Namespace ns;
 			if (arity > 0 && namespaces.TryGetValue (name, out ns)) {
 				ns.Error_TypeArgumentsCannotBeUsed (ctx.Compiler.Report, loc, null, arity);
 				return;
 			}
 
 			ctx.Compiler.Report.Error (234, loc,
 				"The type or namespace name `{0}' does not exist in the namespace `{1}'. Are you missing an assembly reference?",
 				name, GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="730" endline="738">
<![CDATA[
 
 		public int AddResumePoint (ResumableStatement stmt)
 		{
 			if (resume_points == null)
 				resume_points = new List<ResumableStatement> ();
 
 			resume_points.Add (stmt);
 			return resume_points.Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4160" endline="4177">
<![CDATA[
 		
 		protected override void EmitPreTryBody (EmitContext ec)
 		{
 			expr_copy.EmitAssign (ec, expr);
 
 			if (lock_taken != null) {
 				//
 				// Initialize ref variable
 				//
 				lock_taken.EmitAssign (ec, new BoolLiteral (false, loc));
 			} else {
 				//
 				// Monitor.Enter (expr_copy)
 				//
 				expr_copy.Emit (ec);
 				ec.Emit (OpCodes.Call, TypeManager.void_monitor_enter_object);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1437" endline="1449">
<![CDATA[
 
 		public bool IsFieldAssigned (ResolveContext ec, string name, Location loc)
 		{
 			if (!ec.DoFlowAnalysis ||
 				ec.OmitStructFlowAnalysis && TypeInfo.IsStruct ||
 				ec.CurrentBranching.IsFieldAssigned (this, name))
 				return true;
 
 			ec.Report.Error (170, loc,
 				      "Use of possibly unassigned field `" + name + "'");
 			ec.CurrentBranching.SetFieldAssigned (this, name);
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="502" endline="524">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label is_null_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			unwrap.EmitCheck (ec);
 			ec.Emit (OpCodes.Brfalse, is_null_label);
 
 			if (user_operator != null) {
 				user_operator.Emit (ec);
 			} else {
 				EmitOperator (ec, NullableInfo.GetUnderlyingType (type));
 			}
 
 			ec.Emit (OpCodes.Newobj, NullableInfo.GetConstructor (type));
 			ec.Emit (OpCodes.Br_S, end_label);
 
 			ec.MarkLabel (is_null_label);
 			LiftedNull.Create (type, loc).Emit (ec);
 
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="576" endline="586">
<![CDATA[
 
 		public static bool ImplicitStandardConversionExists (ResolveContext ec, MethodGroupExpr mg, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.delegate_type || target_type == TypeManager.multicast_delegate_type)
 				return false;
 
 			var invoke = Delegate.GetInvokeMethod (ec.Compiler, target_type);
 
 			Arguments arguments = CreateDelegateMethodArguments (invoke.Parameters, invoke.Parameters.Types, mg.Location);
 			return mg.OverloadResolve (ec, ref arguments, null, OverloadResolver.Restrictions.CovariantDelegate | OverloadResolver.Restrictions.ProbingOnly) != null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1719" endline="1727">
<![CDATA[
 
 		public void SetAll (bool value)
 		{
 			// Don't clobber Empty
 			if (Count == 0)
 				return;
 			shared = value ? null 
 			vector = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="952" endline="964">
<![CDATA[
 		
 		public ParametersCompiled (params Parameter[] parameters)
 		{
 			if (parameters == null || parameters.Length == 0)
 				throw new ArgumentException ("Use EmptyReadOnlyParameters");
 
 			this.parameters = parameters;
 			int count = parameters.Length;
 
 			for (int i = 0; i < count; i++){
 				has_params |= (parameters [i].ModFlags & Parameter.Modifier.PARAMS) != 0;
 			}
 			for (int i = 0; i < count; i++){
 				has_params |= (parameters [i].ModFlags & Parameter.Modifier.PARAMS) != 0;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="530" endline="539">
<![CDATA[
 
 		/// <summary>
 		/// Checks for ObsoleteAttribute presence. It's used for testing of all non-types elements
 		/// </summary>
 		public virtual void CheckObsoleteness (Location loc)
 		{
 			ObsoleteAttribute oa = GetAttributeObsolete ();
 			if (oa != null)
 				AttributeTester.Report_ObsoleteMessage (oa, GetSignatureForError (), loc, Report);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="464" endline="474">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			GroupBy t = (GroupBy) target;
 			if (element_selector != null) {
 				t.element_selector = element_selector.Clone (clonectx);
 				t.element_block = (QueryBlock) element_block.Clone (clonectx);
 			}
 
 			base.CloneTo (clonectx, t);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8786" endline="8795">
<![CDATA[
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Arguments args = new Arguments (3);
 			args.Add (new Argument (source.CreateExpressionTree (ec)));
 			args.Add (new Argument (new TypeOf (new TypeExpression (type, loc), loc)));
 			args.Add (new Argument (new TypeOfMethod (method, loc)));
 			return CreateExpressionFactoryCall (ec, "Convert", args);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3058" endline="3074">
<![CDATA[
 		}
 
 		#endregion
 
 		//
 		// When best candidate is already know this factory can be used
 		// to avoid expensive overload resolution to be called
 		//
 		// NOTE
 		//
 		public static MethodGroupExpr CreatePredefined (MethodSpec best, TypeSpec queriedType, Location loc)
 		{
 			return new MethodGroupExpr (best, queriedType, loc) {
 				best_candidate = best,
 				best_candidate_return = best.ReturnType
 			};
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="691" endline="701">
<![CDATA[
 
 		static public byte[] ToCapiKeyBlob (RSA rsa, bool includePrivateKey) 
 		{
 			if (rsa == null)
 				throw new ArgumentNullException ("rsa");
 
 			if (includePrivateKey)
 				return ToCapiPrivateKeyBlob (rsa);
 			else
 				return ToCapiPublicKeyBlob (rsa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="702" endline="712">
<![CDATA[
 
 		static public byte[] ToCapiKeyBlob (DSA dsa, bool includePrivateKey)
 		{
 			if (dsa == null)
 				throw new ArgumentNullException ("dsa");
 
 			if (includePrivateKey)
 				return ToCapiPrivateKeyBlob (dsa);
 			else
 				return ToCapiPublicKeyBlob (dsa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5003" endline="5011">
<![CDATA[
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			return Parameter.ExpressionTreeVariableReference ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="358" endline="364">
<![CDATA[
 
 
 		public static MethodSpec GetConstructor (CompilerContext ctx, TypeSpec container_type, TypeSpec delType)
 		{
 			var ctor = MemberCache.FindMember (delType, MemberFilter.Constructor (null), BindingRestriction.DeclaredOnly);
 			return (MethodSpec) ctor;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="556" endline="565">
<![CDATA[
 
 		[Conditional ("FULL_AST")]
 		public void AppendToMember (MemberCore existing, params Location[] locations)
 		{
 			MemberLocations member;
 			if (member_locs.TryGetValue (existing, out member)) {
 				member.AddLocations (locations);
 				return;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1104" endline="1119">
<![CDATA[
 
 		bool parse_generic_dimension (out int dimension)
 		{
 			dimension = 1;
 
 		again
 			int the_token = token ();
 			if (the_token == Token.OP_GENERICS_GT)
 				return true;
 			else if (the_token == Token.COMMA) {
 				dimension++;
 				goto again;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2123" endline="2134">
<![CDATA[
 
 		void ReadSingleLineComment ()
 		{
 			if (peek_char () != '/')
 				Report.Warning (1696, 1, Location, "Single-line comment or end-of-line expected");
 
 			// Read everything till the end of the line or file
 			int c;
 			do {
 				c = get_char ();
 			} while (c != -1 && c != '\n');
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1070" endline="1081">
<![CDATA[
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			if (this.type == type)
 				return this;
 
 			Constant c = TryImplicitIntConversion (type);
 			if (c != null)
 				return c.Resolve (rc);
 
 			return base.ConvertImplicitly (rc, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5095" endline="5106">
<![CDATA[
 		}
 		#endregion
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Invocation target = (Invocation) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4802" endline="4810">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			TryFinally target = (TryFinally) t;
 
 			target.stmt = (Statement) stmt.Clone (clonectx);
 			if (fini != null)
 				target.fini = clonectx.LookupBlock (fini);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8148" endline="8156">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			ElementAccess target = (ElementAccess) t;
 
 			target.Expr = Expr.Clone (clonectx);
 			if (Arguments != null)
 				target.Arguments = Arguments.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="246" endline="255">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			If target = (If) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.TrueStatement = TrueStatement.Clone (clonectx);
 			if (FalseStatement != null)
 				target.FalseStatement = FalseStatement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="821" endline="844">
<![CDATA[
 		
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			prepared = prepare_for_load;
 			
 			expr.Emit (ec);
 
 			if (prepare_for_load)
 				ec.Emit (OpCodes.Dup);
 			
 			source.Emit (ec);
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				temporary = new LocalTemporary (expr.Type);
 				temporary.Store (ec);
 			}
 			
 			ec.EmitStoreFromPtr (type);
 			
 			if (temporary != null) {
 				temporary.Emit (ec);
 				temporary.Release (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1314" endline="1321">
<![CDATA[
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec target_type)
 		{
 			// FIXME
 			if (!Convert.ImplicitStandardConversionExists (this, target_type))
 				return null;
 			return child.ConvertImplicitly (rc, target_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="65" endline="74">
<![CDATA[
 
 		public void __SetDataAndRVA(byte[] data)
 		{
 			attribs |= FieldAttributes.HasFieldRVA;
 			FieldRVATable.Record rec = new FieldRVATable.Record();
 			rec.RVA = typeBuilder.ModuleBuilder.initializedData.Position;
 			rec.Field = pseudoToken;
 			typeBuilder.ModuleBuilder.FieldRVA.AddRecord(rec);
 			typeBuilder.ModuleBuilder.initializedData.Write(data);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="126" endline="135">
<![CDATA[
 
 		internal void WriteTypeDefTable(MetadataWriter mw)
 		{
 			int fieldList = 1;
 			int methodList = 1;
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteTypeDefRecord(mw, ref fieldList, ref methodList);
 			}
 			foreach (TypeBuilder type in types)
 			{
 				type.WriteTypeDefRecord(mw, ref fieldList, ref methodList);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7963" endline="7969">
<![CDATA[
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			using (ctx.With (BuilderContext.Options.AllCheckStateFlags, true)) {
 				return Expr.MakeExpression (ctx);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7242" endline="7249">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldtoken, member);
 
 			base.Emit (ec);
 			ec.Emit (OpCodes.Castclass, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="193" endline="201">
<![CDATA[
 
 		protected override void WriteImpl(MetadataWriter mw)
 		{
 			foreach (string str in list)
 			{
 				mw.Write(System.Text.Encoding.UTF8.GetBytes(str));
 				mw.Write((byte)0);
 			}
 			foreach (string str in list)
 			{
 				mw.Write(System.Text.Encoding.UTF8.GetBytes(str));
 				mw.Write((byte)0);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="1409" endline="1424">
<![CDATA[
 
 		void AddResource (AssemblyResource res)
 		{
 			if (RootContext.Resources == null) {
 				RootContext.Resources = new List<AssemblyResource> ();
 				RootContext.Resources.Add (res);
 				return;
 			}
 
 			if (RootContext.Resources.Contains (res)) {
 				ctx.Report.Error (1508, "The resource identifier `{0}' has already been used in this assembly", res.Name);
 				return;
 			}
 
 			RootContext.Resources.Add (res);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="367" endline="395">
<![CDATA[
 	
 	void OutlineMethod (MethodInfo mi)
 	{
 		if (MethodIsExplicitIfaceImpl (mi)) {
 			o.Write (FormatType (mi.ReturnType));
 			o.Write (" ");
 			// MSFT has no way to get the method that we are overriding
 			// from the interface. this would allow us to pretty print
 			// the type name (and be more correct if there compiler
 			// were to do some strange naming thing).
 		} else {
 			o.Write (GetMethodVisibility (mi));
 			o.Write (GetMethodModifiers  (mi));
 			o.Write (FormatType (mi.ReturnType));
 			o.Write (" ");
 		}
 
 		o.Write (mi.Name);
 #if NET_2_0
 		o.Write (FormatGenericParams (mi.GetGenericArguments ()));
 #endif
 		o.Write (" (");
 		OutlineParams (mi.GetParameters ());
 		o.Write (")");
 #if NET_2_0
 		WriteGenericConstraints (mi.GetGenericArguments ());
 #endif
 		o.Write (";");
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9280" endline="9288">
<![CDATA[
 
 		public CollectionElementInitializer (List<Expression> arguments, Location loc)
 			
 		{
 			foreach (Expression e in arguments)
 				base.arguments.Add (new ElementInitializerArgument (e));
 			foreach (Expression e in arguments)
 				base.arguments.Add (new ElementInitializerArgument (e));
 
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="83" endline="97">
<![CDATA[
 
 		/// <summary>
 		///  Emits the field value by evaluating the expression
 		/// </summary>
 		public override void Emit ()
 		{
 			var c = ((ConstSpec) spec).Value as Constant;
 			if (c.Type == TypeManager.decimal_type) {
 				Module.PredefinedAttributes.DecimalConstant.EmitAttribute (FieldBuilder, (decimal) c.GetValue (), c.Location);
 			} else {
 				FieldBuilder.SetConstant (c.GetValue ());
 			}
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="919" endline="927">
<![CDATA[
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (!HasBeenReferenced)
 				ec.Report.Warning (164, 2, loc, "This label has not been referenced");
 
 			LabelTarget (ec);
 			ec.MarkLabel (label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="811" endline="820">
<![CDATA[
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Emit (ec);
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				temporary = new LocalTemporary (expr.Type);
 				temporary.Store (ec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="180" endline="190">
<![CDATA[
 		}
 
 		public void SetConstant(object defaultValue)
 		{
 			if (lazyPseudoToken == 0)
 			{
 				lazyPseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 			}
 			attributes |= PropertyAttributes.HasDefault;
 			typeBuilder.ModuleBuilder.AddConstant(lazyPseudoToken, defaultValue);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="470" endline="480">
<![CDATA[
 
 		public void ReplaceTypeWithPredefined (TypeSpec ts, BuildinTypeSpec pts)
 		{
 			var found = types [ts.Name];
 			cached_types.Remove (ts.Name);
 			if (found.Count == 1) {
 				types[ts.Name][0] = pts;
 			} else {
 				throw new NotImplementedException ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4745" endline="4754">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Catch target = (Catch) t;
 
 			if (type_expr != null)
 				target.type_expr = (FullNamedExpression) type_expr.Clone (clonectx);
 
 			target.block = clonectx.LookupBlock (block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="469" endline="484">
<![CDATA[
 
 		//
 		// Makes const data field inside internal type container
 		//
 		public FieldSpec MakeStaticData (byte[] data, Location loc)
 		{
 			if (static_data == null) {
 				static_data = new StaticDataContainer (this);
 				static_data.CreateType ();
 				static_data.DefineType ();
 
 				AddCompilerGeneratedClass (static_data);
 			}
 
 			return static_data.DefineInitializedData (data, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="889" endline="901">
<![CDATA[
 
 		protected bool VerifyExplicitParameters (ResolveContext ec, TypeSpec delegate_type, AParametersCollection parameters)
 		{
 			if (VerifyParameterCompatibility (ec, delegate_type, parameters, ec.IsInProbingMode))
 				return true;
 
 			if (!ec.IsInProbingMode)
 				ec.Report.Error (1661, loc,
 					"Cannot convert `{0}' to delegate type `{1}' since there is a parameter mismatch",
 					GetSignatureForError (), TypeManager.CSharpName (delegate_type));
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="158" endline="165">
<![CDATA[
 
 		private static void AddAccessor(List<MethodInfo> list, bool nonPublic, MethodInfo method)
 		{
 			if (method != null && (nonPublic || method.IsPublic))
 			{
 				list.Add(method);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="900" endline="906">
<![CDATA[
 
 		internal static LineNumberTable Read (MonoSymbolFile file, MyBinaryReader br)
 		{
 			LineNumberTable lnt = new LineNumberTable (file);
 			lnt.DoRead (file, br);
 			return lnt;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="698" endline="705">
<![CDATA[
 
 		internal MyBinaryReader BinaryReader {
 			get {
 				if (reader == null)
 					throw new InvalidOperationException ();
 
 				return reader;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6736" endline="6744">
<![CDATA[
 
 		protected override Expression ResolveArrayElement (ResolveContext ec, Expression element)
 		{
 			element = element.Resolve (ec);
 			if (element != null)
 				best_type_inference.AddExpression (element);
 
 			return element;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="398" endline="421">
<![CDATA[
 
 		public override Expression BuildQueryClause (ResolveContext ec, Expression lSide, Parameter parameter)
 		{
 /*
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return null;
 
 			if (expr.Type == InternalType.Dynamic || expr.Type == TypeManager.void_type) {
 				ec.Report.Error (1979, expr.Location,
 					"Query expression with a source or join sequence of type `{0}' is not allowed",
 					TypeManager.CSharpName (expr.Type));
 				return null;
 			}
 */
 
 			if (IdentifierType != null)
 				expr = CreateCastExpression (expr);
 
 			if (parameter == null)
 				lSide = expr;
 
 			return next.BuildQueryClause (ec, lSide, new ImplicitLambdaParameter (identifier.Name, identifier.Location));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="404" endline="412">
<![CDATA[
 		}
 
 		public int Column {
 			get {
 				if (token == 0)
 					return 1;
 				int col = (int) (token & column_mask);
 				return col == 255 ? 1 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1662" endline="1675">
<![CDATA[
 
 		public static MyBitVector operator & (MyBitVector a, MyBitVector b)
 		{
 			if (a == b)
 				return a;
 			if (a == null)
 				return b.Clone ();
 			if (b == null)
 				return a.Clone ();
 			if (a.Count > b.Count)
 				return a.Clone ().And (b);
 			else
 				return b.Clone ().And (a);					
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="127" endline="133">
<![CDATA[
 
 		internal void WriteParamRecord(MetadataWriter mw)
 		{
 			mw.Write(flags);
 			mw.Write(sequence);
 			mw.WriteStringIndex(nameIndex);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="322" endline="328">
<![CDATA[
 
 		internal void Write (MonoSymbolFile file, MyBinaryWriter bw)
 		{
 			bw.WriteLeb128 (Index);
 			bw.Write (Name);
 			bw.WriteLeb128 (BlockIndex);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="366" endline="372">
<![CDATA[
 
 		internal void Write (MyBinaryWriter bw)
 		{
 			bw.Write (Name);
 			bw.Write (CapturedName);
 			bw.Write ((byte) Kind);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="756" endline="762">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddBreakOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="763" endline="769">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			Parent.AddContinueOrigin (vector, loc);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="770" endline="776">
<![CDATA[
 
 		public override bool AddReturnOrigin (UsageVector vector, ExitStatement exit_stmt)
 		{
 			Parent.AddReturnOrigin (vector, exit_stmt);
 			stmt.SomeCodeFollows ();
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="187" endline="194">
<![CDATA[
 
 		public void Load (EmitContext ec)
 		{
 			if (expr is VariableReference)
 				expr.Emit (ec);
 			else
 				LocalVariable.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="269" endline="276">
<![CDATA[
 
 		public void Emit (OpCode opcode, TypeSpec type)
 		{
 			if (IsAnonymousStoreyMutateRequired)
 				type = CurrentAnonymousMethod.Storey.Mutator.Mutate (type);
 
 			ig.Emit (opcode, type.GetMetaInfo ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="277" endline="284">
<![CDATA[
 
 		public void Emit (OpCode opcode, FieldSpec field)
 		{
 			if (IsAnonymousStoreyMutateRequired)
 				field = field.Mutate (CurrentAnonymousMethod.Storey.Mutator);
 
 			ig.Emit (opcode, field.GetMetaInfo ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="285" endline="292">
<![CDATA[
 
 		internal void Write (MyBinaryWriter bw)
 		{
 			bw.WriteLeb128 ((int) BlockType);
 			bw.WriteLeb128 (Parent);
 			bw.WriteLeb128 (StartOffset);
 			bw.WriteLeb128 (EndOffset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="51" endline="59">
<![CDATA[
 		{
 			Signature = br.ReadUInt32();
 			if (Signature != IMAGE_NT_HEADERS.MAGIC_SIGNATURE)
 			{
 				throw new BadImageFormatException();
 			}
 			FileHeader.Read(br);
 			OptionalHeader.Read(br);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="732" endline="738">
<![CDATA[
 
 		public void Emit(OpCode opcode, SignatureHelper signature)
 		{
 			Emit(opcode);
 			UpdateStack(opcode, signature.HasThis, signature.ReturnType, signature.ParameterCount);
 			code.Write(0x11000000 | moduleBuilder.StandAloneSig.FindOrAddRecord(moduleBuilder.Blobs.Add(signature.GetSignature(moduleBuilder))));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="803" endline="810">
<![CDATA[
 		
 		public override void Emit (EmitContext ec)
 		{
 			if (!prepared)
 				expr.Emit (ec);
 			
 			ec.EmitLoadFromPtr (Type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8333" endline="8340">
<![CDATA[
 
 		public void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			var ac = (ArrayContainer) ea.Expr.Type;
 
 			LoadArrayAndArguments (ec);
 			ec.EmitArrayAddress (ac);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="150" endline="156">
<![CDATA[
 
 		internal void WriteFieldRecords(MetadataWriter mw)
 		{
 			mw.Write((short)attribs);
 			mw.WriteStringIndex(nameIndex);
 			mw.WriteBlobIndex(signature);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\lambda.cs" startline="187" endline="197">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			if (statement != null) {
 				statement.EmitStatement (ec);
 				ec.Emit (OpCodes.Ret);
 				return;
 			}
 
 			base.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="413" endline="428">
<![CDATA[
 
 		public void DefineManifestResource(string name, Stream stream, ResourceAttributes attribute)
 		{
 			ManifestResourceTable.Record rec = new ManifestResourceTable.Record();
 			rec.Offset = manifestResources.Position;
 			rec.Flags = (int)attribute;
 			rec.Name = this.Strings.Add(name);
 			rec.Implementation = 0;
 			this.ManifestResource.AddRecord(rec);
 			manifestResources.Write(0);	// placeholder for the length
 			manifestResources.Write(stream);
 			int savePosition = manifestResources.Position;
 			manifestResources.Position = rec.Offset;
 			manifestResources.Write(savePosition - (manifestResources.Position + 4));
 			manifestResources.Position = savePosition;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="462" endline="473">
<![CDATA[
 
 		public TypeToken GetTypeToken(Type type)
 		{
 			if (type.Module == this)
 			{
 				return new TypeToken(type.GetModuleBuilderToken());
 			}
 			else
 			{
 				return new TypeToken(ImportType(type));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4554" endline="4562">
<![CDATA[
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.AddressOf (ec, mode);
 				return;
 			}
 
 			Variable.EmitAddressOf (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="369" endline="375">
<![CDATA[
 
 		public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes)
 		{
 			FieldBuilder fb = new FieldBuilder(this, fieldName, type, requiredCustomModifiers, optionalCustomModifiers, attributes);
 			fields.Add(fb);
 			return fb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="753" endline="759">
<![CDATA[
 
 		private AssemblyBuilder DefineDynamicAssemblyImpl(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
 		{
 			AssemblyBuilder asm = new AssemblyBuilder(this, name, dir, requiredPermissions, optionalPermissions, refusedPermissions);
 			dynamicAssemblies.Add(asm);
 			return asm;
  		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="72" endline="79">
<![CDATA[
 
 		public void DefineLocalVariable (int index, string name)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.AddLocal (index, name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="103" endline="110">
<![CDATA[
 
 		public void DefineScopeVariable (int scope, int index)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.AddScopeVariable (scope, index);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="666" endline="702">
<![CDATA[
 	}
 
 	//
 	// Default message recorder, it uses two types of message groups.
 	// Common messages
 	// Merged messages
 	//
 	// Used by the Lambda expressions to compile the code with various
 	// parameter values, or by attribute resolver
 	//
 	class SessionReportPrinter 
 	{
 		List<AbstractMessage> session_messages;
 		//
 		// A collection of exactly same messages reported in all sessions
 		//
 		List<AbstractMessage> common_messages;
 
 		//
 		// A collection of unique messages reported in all sessions
 		//
 		List<AbstractMessage> merged_messages;
 
 		public override void Print (AbstractMessage msg)
 		{
 			//
 			// This line is useful when debugging recorded messages
 			//
 			// Console.WriteLine ("RECORDING
 
 			if (session_messages == null)
 				session_messages = new List<AbstractMessage> ();
 
 			session_messages.Add (msg);
 
 			base.Print (msg);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4012" endline="4024">
<![CDATA[
 
 		public void AddResumePoint (ResumableStatement stmt, int pc)
 		{
 			if (resume_points == null) {
 				resume_points = new List<ResumableStatement> ();
 				first_resume_pc = pc;
 			}
 
 			if (pc != first_resume_pc + resume_points.Count)
 				throw new InternalErrorException ("missed an intervening AddResumePoint?");
 
 			resume_points.Add (stmt);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1300" endline="1308">
<![CDATA[
 
 		public override void EmitBranchable (EmitContext ec, Label label, bool on_true)
 		{
 			child.EmitBranchable (ec, label, on_true);
 
 			// Only to make verifier happy
 			if (TypeManager.IsGenericParameter (type) && child.IsNull)
 				ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\CliHeader.cs" startline="71" endline="90">
<![CDATA[
 
 		internal void Write(IKVM.Reflection.Writer.MetadataWriter mw)
 		{
 			mw.Write(Cb);
 			mw.Write(MajorRuntimeVersion);
 			mw.Write(MinorRuntimeVersion);
 			mw.Write(MetaDataRVA);
 			mw.Write(MetaDataSize);
 			mw.Write(Flags);
 			mw.Write(EntryPointToken);
 			mw.Write(ResourcesRVA);
 			mw.Write(ResourcesSize);
 			mw.Write(StrongNameSignatureRVA);
 			mw.Write(StrongNameSignatureSize);
 			mw.Write(CodeManagerTable);
 			mw.Write(VTableFixupsRVA);
 			mw.Write(VTableFixupsSize);
 			mw.Write(ExportAddressTableJumps);
 			mw.Write(ManagedNativeHeader);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5667" endline="5681">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.EventAccess;
 			type = spec.MemberType;
 
 			ResolveInstanceExpression (ec, null);
 
 			if (!ec.HasSet (ResolveContext.Options.CompoundAssignmentScope)) {
 				Error_AssignmentEventOnly (ec);
 			}
 
 			DoBestMemberChecks (ec, spec);
 			return this;
 		}		
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8627" endline="8635">
<![CDATA[
 
 		protected override void Error_ThisNotAvailable (ResolveContext ec)
 		{
 			if (ec.IsStatic) {
 				ec.Report.Error (1511, loc, "Keyword `base' is not available in a static method");
 			} else {
 				ec.Report.Error (1512, loc, "Keyword `base' is not available in the current context");
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1303" endline="1317">
<![CDATA[
 
 		public override void Emit ()
 		{
 			CheckReservedNameConflict (null, add.Spec);
 			CheckReservedNameConflict (null, remove.Spec);
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			Add.Emit (Parent);
 			Remove.Emit (Parent);
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1419" endline="1444">
<![CDATA[
 
 		protected override Expression ResolveInitializer (BlockContext bc, LocalVariable li, Expression initializer)
 		{
 			initializer = initializer.Resolve (bc);
 			if (initializer == null)
 				return null;
 
 			var c = initializer as Constant;
 			if (c == null) {
 				initializer.Error_ExpressionMustBeConstant (bc, initializer.Location, li.Name);
 				return null;
 			}
 
 			c = c.ConvertImplicitly (bc, li.Type);
 			if (c == null) {
 				if (TypeManager.IsReferenceType (li.Type))
 					initializer.Error_ConstantCanBeInitializedWithNullOnly (bc, li.Type, initializer.Location, li.Name);
 				else
 					initializer.Error_ValueCannotBeConverted (bc, initializer.Location, li.Type, false);
 
 				return null;
 			}
 
 			li.ConstantValue = c;
 			return initializer;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8223" endline="8231">
<![CDATA[
 
 		//
 		// Load the array arguments into the stack.
 		//
 		void LoadArrayAndArguments (EmitContext ec)
 		{
 			ea.Expr.Emit (ec);
 			ea.Arguments.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Module.cs" startline="71" endline="78">
<![CDATA[
 
 		public void Dispose()
 		{
 			if (!imported)
 			{
 				module.stream.Dispose();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="290" endline="302">
<![CDATA[
 		}
 
 		//
 		// This is used to trigger completion generation on the parser
 		public bool CompleteOnEOF;
 		
 		void AddEscapedIdentifier (Location loc)
 		{
 			if (escaped_identifiers == null)
 				escaped_identifiers = new List<Location> ();
 
 			escaped_identifiers.Add (loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="563" endline="572">
<![CDATA[
 
 		public void AddCompilerGeneratedClass (CompilerGeneratedClass c)
 		{
 			Report.Debug (64, "ADD COMPILER GENERATED CLASS", this, c);
 
 			if (compiler_generated == null)
 				compiler_generated = new List<CompilerGeneratedClass> ();
 
 			compiler_generated.Add (c);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1249" endline="1259">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddDeclarator (Declarator decl)
 		{
 			if (declarators == null)
 				declarators = new List<Declarator> ();
 
 			declarators.Add (decl);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="173" endline="180">
<![CDATA[
 
 		public void CloseScope (int end_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.EndBlock (end_offset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="190" endline="197">
<![CDATA[
 
 		public void CloseCompilerGeneratedBlock (int end_offset)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.EndBlock (end_offset);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="814" endline="821">
<![CDATA[
 
 		void SetCustomAttribute (MethodSpec ctor, byte[] data)
 		{
 			if (module_target_attrs != null)
 				module_target_attrs.AddAssemblyAttribute (ctor, data);
 			else
 				Builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), data);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1333" endline="1343">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			// It can be null for static initializers
 			if (base_ctor == null)
 				return;
 			
 			ec.Mark (loc);
 
 			Invocation.EmitCall (ec, new CompilerGeneratedThis (type, loc), base_ctor, argument_list, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7890" endline="7902">
<![CDATA[
 
 		protected override void Error_TypeDoesNotContainDefinition (ResolveContext ec, TypeSpec type, string name)
 		{
 			if (RootContext.Version > LanguageVersion.ISO_2 && !ec.Compiler.IsRuntimeBinder && MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 				ec.Report.SymbolRelatedToPreviousError (type);
 				ec.Report.Error (1061, loc,
 					"Type `{0}' does not contain a definition for `{1}' and no extension method `{1}' of type `{0}' could be found (are you missing a using directive or an assembly reference?)",
 					type.GetSignatureForError (), name);
 				return;
 			}
 
 			base.Error_TypeDoesNotContainDefinition (ec, type, name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="56" endline="515">
<![CDATA[
 			28, 67, 78,
 			105, 108, 109, 114, 162, 164, 168, 169, 183, 184, 197,
 			219, 251, 252, 253, 278, 282,
 			402, 414, 419, 420, 429, 436, 440, 458, 464, 465, 467, 469, 472,
 			612, 618, 626, 628, 642, 649, 652, 658, 659, 660, 661, 665, 672, 675, 693,
 			728,
 			809,
 			1030, 1058, 1066,
 			1522, 1570, 1571, 1572, 1573, 1574, 1580, 1581, 1584, 1587, 1589, 1590, 1591, 1592,
 			1607, 1616, 1633, 1634, 1635, 1685, 1690, 1691, 1692, 1695, 1696, 1699, 1683,
 			1700, 1701, 1702, 1709, 1717, 1718, 1720,
 			1901, 1981,
 			2002, 2023, 2029,
 			3000, 3001, 3002, 3003, 3005, 3006, 3007, 3008, 3009,
 			3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019,
 			3021, 3022, 3023, 3024, 3026, 3027
 		};
 
 		static HashSet<int> AllWarningsHashSet;
 
 		public Report (ReportPrinter printer)
 		{
 			if (printer == null)
 				throw new ArgumentNullException ("printer");
 
 			this.printer = printer;
 			warning_level = 4;
 		}
 
 		public void DisableReporting ()
 		{
 			++reporting_disabled;
 		}
 
 		public void EnableReporting ()
 		{
 			--reporting_disabled;
 		}
 
 		public void FeatureIsNotAvailable (Location loc, string feature)
 		{
 			string version;
 			switch (RootContext.Version) {
 			case LanguageVersion.ISO_1
 				version = "1.0";
 				break;
 			case LanguageVersion.ISO_2
 				version = "2.0";
 				break;
 			case LanguageVersion.V_3
 				version = "3.0";
 				break;
 			default
 				throw new InternalErrorException ("Invalid feature version", RootContext.Version);
 			}
 
 			Error (1644, loc,
 				"Feature `{0}' cannot be used because it is not part of the C# {1} language specification",
 				      feature, version);
 		}
 
 		public void FeatureIsNotSupported (Location loc, string feature)
 		{
 			Error (1644, loc,
 				"Feature `{0}' is not supported in Mono mcs1 compiler. Consider using the `gmcs' compiler instead",
 				feature);
 		}
 		
 		bool IsWarningEnabled (int code, int level, Location loc)
 		{
 			if (WarningLevel < level)
 				return false;
 
 			if (IsWarningDisabledGlobally (code))
 				return false;
 
 			if (warning_regions_table == null || loc.IsNull)
 				return true;
 
 			WarningRegions regions;
 			if (!warning_regions_table.TryGetValue (loc.File, out regions))
 				return true;
 
 			return regions.IsWarningEnabled (code, loc.Row);
 		}
 
 		public bool IsWarningDisabledGlobally (int code)
 		{
 			return warning_ignore_table != null && warning_ignore_table.Contains (code);
 		}
 
 		bool IsWarningAsError (int code)
 		{
 			bool is_error = WarningsAreErrors;
 
 			// Check specific list
 			if (warnings_as_error != null)
 				is_error |= warnings_as_error.Contains (code);
 
 			// Ignore excluded warnings
 			if (warnings_only != null && warnings_only.Contains (code))
 				is_error = false;
 
 			return is_error;
 		}
 		        
 		public void RuntimeMissingSupport (Location loc, string feature) 
 		{
 			Error (-88, loc, "Your .NET Runtime does not support `{0}'. Please use the latest Mono runtime instead.", feature);
 		}
 
 		/// <summary>
 		/// In most error cases is very useful to have information about symbol that caused the error.
 		/// Call this method before you call Report.Error when it makes sense.
 		/// </summary>
 		public void SymbolRelatedToPreviousError (Location loc, string symbol)
 		{
 			SymbolRelatedToPreviousError (loc.ToString ());
 		}
 
 		public void SymbolRelatedToPreviousError (MemberSpec ms)
 		{
 			if (reporting_disabled > 0 || !printer.HasRelatedSymbolSupport)
 				return;
 
 			var mc = ms.MemberDefinition as MemberCore;
 			while (ms is ElementTypeSpec) {
 				ms = ((ElementTypeSpec) ms).Element;
 				mc = ms.MemberDefinition as MemberCore;
 			}
 
 			if (mc != null) {
 				SymbolRelatedToPreviousError (mc);
 			} else {
 				if (ms.DeclaringType != null)
 					ms = ms.DeclaringType;
 
 				var imported_type = ms.MemberDefinition as ImportedTypeDefinition;
 				if (imported_type != null) {
 					var iad = imported_type.DeclaringAssembly as ImportedAssemblyDefinition;
 					SymbolRelatedToPreviousError (iad.Location);
 				}
 			}
 		}
 
 		public void SymbolRelatedToPreviousError (MemberCore mc)
 		{
 			SymbolRelatedToPreviousError (mc.Location, mc.GetSignatureForError ());
 		}
 
 		public void SymbolRelatedToPreviousError (string loc)
 		{
 			string msg = String.Format ("{0} (Location of the symbol related to previous ", loc);
 			if (extra_information.Contains (msg))
 				return;
 
 			extra_information.Add (msg);
 		}
 
 		public void AddWarningAsError (string warningId)
 		{
 			int id;
 			try {
 				id = int.Parse (warningId);
 			} catch {
 				CheckWarningCode (warningId, Location.Null);
 				return;
 			}
 
 			if (!CheckWarningCode (id, Location.Null))
 				return;
 
 			if (warnings_as_error == null)
 				warnings_as_error = new List<int> ();
 			
 			warnings_as_error.Add (id);
 		}
 
 		public void RemoveWarningAsError (string warningId)
 		{
 			int id;
 			try {
 				id = int.Parse (warningId);
 			} catch {
 				CheckWarningCode (warningId, Location.Null);
 				return;
 			}
 
 			if (!CheckWarningCode (id, Location.Null))
 				return;
 
 			if (warnings_only == null)
 				warnings_only = new List<int> ();
 
 			warnings_only.Add (id);
 		}
 
 		public bool CheckWarningCode (string code, Location loc)
 		{
 			Warning (1691, 1, loc, "`{0}' is not a valid warning number", code);
 			return false;
 		}
 
 		public bool CheckWarningCode (int code, Location loc)
 		{
 			if (AllWarningsHashSet == null)
 				AllWarningsHashSet = new HashSet<int> (AllWarnings);
 
 			if (AllWarningsHashSet.Contains (code))
 				return true;
 
 			return CheckWarningCode (code.ToString (), loc);
 		}
 
 		public void ExtraInformation (Location loc, string msg)
 		{
 			extra_information.Add (String.Format ("{0} {1}", loc, msg));
 		}
 
 		public WarningRegions RegisterWarningRegion (Location location)
 		{
 			WarningRegions regions;
 			if (warning_regions_table == null) {
 				regions = null;
 				warning_regions_table = new Dictionary<int, WarningRegions> ();
 			} else {
 				warning_regions_table.TryGetValue (location.File, out regions);
 			}
 
 			if (regions == null) {
 				regions = new WarningRegions ();
 				warning_regions_table.Add (location.File, regions);
 			}
 
 			return regions;
 		}
 
 		public void Warning (int code, int level, Location loc, string message)
 		{
 			if (reporting_disabled > 0)
 				return;
 
 			if (!IsWarningEnabled (code, level, loc))
 				return;
 
 			AbstractMessage msg;
 			if (IsWarningAsError (code))
 				msg = new ErrorMessage (code, loc, message, extra_information);
 			else
 				msg = new WarningMessage (code, loc, message, extra_information);
 
 			extra_information.Clear ();
 			printer.Print (msg);
 		}
 
 		public void Warning (int code, int level, Location loc, string format, string arg)
 		{
 			Warning (code, level, loc, String.Format (format, arg));
 		}
 
 		public void Warning (int code, int level, Location loc, string format, string arg1, string arg2)
 		{
 			Warning (code, level, loc, String.Format (format, arg1, arg2));
 		}
 
 		public void Warning (int code, int level, Location loc, string format, params object[] args)
 		{
 			Warning (code, level, loc, String.Format (format, args));
 		}
 
 		public void Warning (int code, int level, string message)
 		{
 			Warning (code, level, Location.Null, message);
 		}
 
 		public void Warning (int code, int level, string format, string arg)
 		{
 			Warning (code, level, Location.Null, format, arg);
 		}
 
 		public void Warning (int code, int level, string format, string arg1, string arg2)
 		{
 			Warning (code, level, Location.Null, format, arg1, arg2);
 		}
 
 		public void Warning (int code, int level, string format, params string[] args)
 		{
 			Warning (code, level, Location.Null, String.Format (format, args));
 		}
 
 		//
 		// Warnings encountered so far
 		//
 		public int Warnings {
 			get { return printer.WarningsCount; }
 		}
 
 		public void Error (int code, Location loc, string error)
 		{
 			if (reporting_disabled > 0)
 				return;
 
 			ErrorMessage msg = new ErrorMessage (code, loc, error, extra_information);
 			extra_information.Clear ();
 
 			printer.Print (msg);
 		}
 
 		public void Error (int code, Location loc, string format, string arg)
 		{
 			Error (code, loc, String.Format (format, arg));
 		}
 
 		public void Error (int code, Location loc, string format, string arg1, string arg2)
 		{
 			Error (code, loc, String.Format (format, arg1, arg2));
 		}
 
 		public void Error (int code, Location loc, string format, params string[] args)
 		{
 			Error (code, loc, String.Format (format, args));
 		}
 
 		public void Error (int code, string error)
 		{
 			Error (code, Location.Null, error);
 		}
 
 		public void Error (int code, string format, string arg)
 		{
 			Error (code, Location.Null, format, arg);
 		}
 
 		public void Error (int code, string format, string arg1, string arg2)
 		{
 			Error (code, Location.Null, format, arg1, arg2);
 		}
 
 		public void Error (int code, string format, params string[] args)
 		{
 			Error (code, Location.Null, String.Format (format, args));
 		}
 
 		//
 		// Errors encountered so far
 		//
 		public int Errors {
 			get { return printer.ErrorsCount; }
 		}
 
 		public bool IsDisabled {
 			get {
 				return reporting_disabled > 0;
 			}
 		}
 
 		public ReportPrinter Printer {
 			get { return printer; }
 		}
 
 		public void SetIgnoreWarning (int code)
 		{
 			if (warning_ignore_table == null)
 				warning_ignore_table = new HashSet<int> ();
 
 			warning_ignore_table.Add (code);
 		}
 
 		public ReportPrinter SetPrinter (ReportPrinter printer)
 		{
 			ReportPrinter old = this.printer;
 			this.printer = printer;
 			return old;
 		}
 
 		public int WarningLevel {
 			get {
 				return warning_level;
 			}
 			set {
 				warning_level = value;
 			}
 		}
 
 		[Conditional ("MCS_DEBUG")]
 		static public void Debug (string message, params object[] args)
 		{
 			Debug (4, message, args);
 		}
 			
 		[Conditional ("MCS_DEBUG")]
 		static public void Debug (int category, string message, params object[] args)
 		{
 			if ((category & DebugFlags) == 0)
 				return;
 
 			StringBuilder sb = new StringBuilder (message);
 
 			if ((args != null) && (args.Length > 0)) {
 				sb.Append ("
 
 				bool first = true;
 				foreach (object arg in args) {
 					if (first)
 						first = false;
 					else
 						sb.Append (", ");
 					if (arg == null)
 						sb.Append ("null");
 //					else if (arg is ICollection)
 //						sb.Append (PrintCollection ((ICollection) arg));
 					else
 						sb.Append (arg);
 				}
 			}
 
 			Console.WriteLine (sb.ToString ());
 		}
 /*
 		static public string PrintCollection (ICollection collection)
 		{
 			StringBuilder sb = new StringBuilder ();
 
 			sb.Append (collection.GetType ());
 			sb.Append ("(");
 
 			bool first = true;
 			foreach (object o in collection) {
 				if (first)
 					first = false;
 				else
 					sb.Append (", ");
 				sb.Append (o);
 			}
 
 			sb.Append (")");
 			return sb.ToString ();
 		}
 */ 
 	}
 
 	public abstract class AbstractMessage
 	{
 		readonly string[] extra_info;
 		protected readonly int code;
 		protected readonly Location location;
 		readonly string message;
 
 		protected AbstractMessage (int code, Location loc, string msg, List<string> extraInfo)
 		{
 			this.code = code;
 			if (code < 0)
 				this.code = 8000 - code;
 
 			this.location = loc;
 			this.message = msg;
 			if (extraInfo.Count != 0) {
 				this.extra_info = extraInfo.ToArray ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1669" endline="1685">
<![CDATA[
 
 		/// <summary>
 		/// Common method for Obsolete error/warning reporting.
 		/// </summary>
 		public static void Report_ObsoleteMessage (ObsoleteAttribute oa, string member, Location loc, Report Report)
 		{
 			if (oa.IsError) {
 				Report.Error (619, loc, "`{0}' is obsolete
 				return;
 			}
 
 			if (oa.Message == null || oa.Message.Length == 0) {
 				Report.Warning (612, 1, loc, "`{0}' is obsolete", member);
 				return;
 			}
 			Report.Warning (618, 2, loc, "`{0}' is obsolete
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4165" endline="4180">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label end_target = ec.DefineLabel ();
 
 			//
 			// Emit and duplicate left argument
 			//
 			arguments [0].Expr.Emit (ec);
 			ec.Emit (OpCodes.Dup);
 			arguments.RemoveAt (0);
 
 			oper_expr.EmitBranchable (ec, end_target, true);
 			base.Emit (ec);
 			ec.MarkLabel (end_target);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1867" endline="1879">
<![CDATA[
 
 		public virtual void Error_AlreadyDeclared (string name, INamedBlockVariable variable, string reason)
 		{
 			if (reason == null) {
 				Error_AlreadyDeclared (name, variable);
 				return;
 			}
 
 			ParametersBlock.TopBlock.Report.Error (136, variable.Location,
 				"A local variable named `{0}' cannot be declared in this scope because it would give a different meaning " +
 				"to `{0}', which is already used in a `{1}' scope to denote something else",
 				name, reason);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1928" endline="1936">
<![CDATA[
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			// cast to object
 			if (type != targetType)
 				enc.Encode (type);
 
 			enc.Encode (Value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="468" endline="483">
<![CDATA[
 
 		//
 		// This is the first method which is called during the resolving
 		// process; we're called immediately after creating the type parameters
 		// with SRE (by calling `DefineGenericParameters()' on the TypeBuilder /
 		// MethodBuilder).
 		//
 		public void Define (GenericTypeParameterBuilder type, TypeSpec declaringType)
 		{
 			if (builder != null)
 				throw new InternalErrorException ();
 
 			this.builder = type;
 			spec.DeclaringType = declaringType;
 			spec.SetMetaInfo (type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="888" endline="900">
<![CDATA[
 		}
 
 		internal void WriteTypeDefRecord(MetadataWriter mw, ref int fieldList, ref int methodList)
 		{
 			mw.Write((int)attribs);
 			mw.WriteStringIndex(typeName);
 			mw.WriteStringIndex(typeNameSpace);
 			mw.WriteTypeDefOrRef(extends);
 			mw.WriteField(fieldList);
 			mw.WriteMethodDef(methodList);
 			methodList += methods.Count;
 			fieldList += fields.Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="144" endline="170">
<![CDATA[
 
 		internal void Write (BinaryWriter bw, int major_version, int minor_version)
 		{
 			bw.Write (TotalFileSize);
 			bw.Write (DataSectionOffset);
 			bw.Write (DataSectionSize);
 			bw.Write (CompileUnitCount);
 			bw.Write (CompileUnitTableOffset);
 			bw.Write (CompileUnitTableSize);
 			bw.Write (SourceCount);
 			bw.Write (SourceTableOffset);
 			bw.Write (SourceTableSize);
 			bw.Write (MethodCount);
 			bw.Write (MethodTableOffset);
 			bw.Write (MethodTableSize);
 			bw.Write (TypeCount);
 
 			bw.Write (AnonymousScopeCount);
 			bw.Write (AnonymousScopeTableOffset);
 			bw.Write (AnonymousScopeTableSize);
 
 			bw.Write (LineNumberTable_LineBase);
 			bw.Write (LineNumberTable_LineRange);
 			bw.Write (LineNumberTable_OpcodeBase);
 
 			bw.Write ((int) FileFlags);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="620" endline="630">
<![CDATA[
 
 		TypeSpec CreateType (MetaType type, DynamicTypeReader dtype, bool canImportBaseType)
 		{
 			TypeSpec declaring_type;
 			if (type.IsNested && !type.IsGenericParameter)
 				declaring_type = CreateType (type.DeclaringType, new DynamicTypeReader (type.DeclaringType), true);
 			else
 				declaring_type = null;
 
 			return CreateType (type, declaring_type, dtype, canImportBaseType);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="264" endline="279">
<![CDATA[
 
 		internal CodeBlockEntry (int index, MyBinaryReader reader)
 		{
 			this.Index = index;
 			int type_flag = reader.ReadLeb128 ();
 			BlockType = (Type) (type_flag & 0x3f);
 			this.Parent = reader.ReadLeb128 ();
 			this.StartOffset = reader.ReadLeb128 ();
 			this.EndOffset = reader.ReadLeb128 ();
 
 			/* Reserved for future extensions. */
 			if ((type_flag & 0x40) != 0) {
 				int data_size = reader.ReadInt16 ();
 				reader.BaseStream.Position += data_size;
 			}				
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="390" endline="437">
<![CDATA[
 		
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (empty) {
 				expr.EmitSideEffect (ec);
 				return;
 			}
 
 			Label old_begin = ec.LoopBegin;
 			Label old_end = ec.LoopEnd;
 			
 			ec.LoopBegin = ec.DefineLabel ();
 			ec.LoopEnd = ec.DefineLabel ();
 
 			//
 			// Inform whether we are infinite or not
 			//
 			if (expr is Constant){
 				// expr is 'true', since the 'empty' case above handles the 'false' case
 				ec.MarkLabel (ec.LoopBegin);
 				expr.EmitSideEffect (ec);
 				Statement.Emit (ec);
 				ec.Emit (OpCodes.Br, ec.LoopBegin);
 					
 				//
 				// Inform that we are infinite (ie, `we return'), only
 				// if we do not `break' inside the code.
 				//
 				ec.MarkLabel (ec.LoopEnd);
 			} else {
 				Label while_loop = ec.DefineLabel ();
 
 				ec.Emit (OpCodes.Br, ec.LoopBegin);
 				ec.MarkLabel (while_loop);
 
 				Statement.Emit (ec);
 			
 				ec.MarkLabel (ec.LoopBegin);
 				ec.Mark (loc);
 
 				expr.EmitBranchable (ec, while_loop, true);
 				
 				ec.MarkLabel (ec.LoopEnd);
 			}	
 
 			ec.LoopBegin = old_begin;
 			ec.LoopEnd = old_end;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="228" endline="234">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source,
 					bool leave_copy, bool prepare_for_load)
 		{
 			InternalWrap wrap = new InternalWrap (source, expr.Type, loc);
 			((IAssignMethod) expr).EmitAssign (ec, wrap, leave_copy, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="174" endline="183">
<![CDATA[
 
 		private CustomAttributeData(ConstructorInfo constructor, int securityAction, IList<CustomAttributeNamedArgument> namedArguments)
 		{
 			Universe u = constructor.Module.universe;
 			this.lazyConstructor = constructor;
 			List<CustomAttributeTypedArgument> list = new List<CustomAttributeTypedArgument>();
 			list.Add(new CustomAttributeTypedArgument(u.System_Security_Permissions_SecurityAction, securityAction));
 			this.lazyConstructorArguments =  list.AsReadOnly();
 			this.lazyNamedArguments = namedArguments;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="382" endline="397">
<![CDATA[
 
 		public abstract UsageVector CurrentUsageVector {
 			get;
 		}				
 
 		// <summary>
 		//   Creates a sibling of the current usage vector.
 		// </summary>
 		public virtual void CreateSibling (Block block, SiblingType type)
 		{
 			UsageVector vector = new UsageVector (
 				type, Parent.CurrentUsageVector, block, Location);
 			AddSibling (vector);
 
 			Report.Debug (1, "  CREATED SIBLING", CurrentUsageVector);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="77" endline="86">
<![CDATA[
 
 		public void AddOtherMethod(MethodBuilder mdBuilder)
 		{
 			PatchCallingConvention(mdBuilder);
 			if (otherMethods == null)
 			{
 				otherMethods = new List<MethodBuilder>();
 			}
 			otherMethods.Add(mdBuilder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1039" endline="1056">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.Field) {
 				backing_field.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				int errors = Report.Errors;
 				Add.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				if (errors == Report.Errors)
 					Remove.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="526" endline="533">
<![CDATA[
 
 		public override void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			if (Oper == Operator.LogicalNot)
 				Expr.EmitBranchable (ec, target, !on_true);
 			else
 				base.EmitBranchable (ec, target, on_true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1246" endline="1264">
<![CDATA[
 		}
 
 		static string[] attribute_targets = new string [] { "type" };
 
 		public DeclSpace (NamespaceEntry ns, DeclSpace parent, MemberName name,
 				  Attributes attrs)
 			
 		{
 			NamespaceEntry = ns;
 			Basename = name.Basename;
 			defined_names = new Dictionary<string, MemberCore> ();
 			PartialContainer = null;
 			if (name.TypeArguments != null) {
 				is_generic = true;
 				count_type_params = name.TypeArguments.Count;
 			}
 			if (parent != null)
 				count_type_params += parent.count_type_params;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="102" endline="109">
<![CDATA[
 
 		internal override void WriteSig(ModuleBuilder module, ByteBuffer bb)
 		{
 			bb.Write(FIELD);
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_OPT, optionalCustomModifiers);
 			WriteCustomModifiers(module, bb, ELEMENT_TYPE_CMOD_REQD, requiredCustomModifiers);
 			WriteType(module, bb, fieldType);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="103" endline="114">
<![CDATA[
 
 		internal void Finish()
 		{
 			if (bb != null)
 			{
 				throw new InvalidOperationException();
 			}
 			bb = new ByteBuffer(1024);
 			linkOffsets = new List<int>();
 			root.Write(bb, linkOffsets);
 			root = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="409" endline="415">
<![CDATA[
 
 		public virtual void RemoveTypeContainer (TypeContainer next_part)
 		{
 			if (types != null)
 				types.Remove (next_part);
 			RemoveMemberType (next_part);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="364" endline="372">
<![CDATA[
 
 		public void AddressOf (EmitContext ec, AddressOp Mode)
 		{
 			LocalTemporary value_target = new LocalTemporary (type);
 				
 			value_target.AddressOf (ec, AddressOp.Store);
 			ec.Emit (OpCodes.Initobj, type);
 			((IMemoryLocation) value_target).AddressOf (ec, Mode);
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6275" endline="6294">
<![CDATA[
 
 void start_anonymous (bool lambda, ParametersCompiled parameters, Location loc)
 {
 	if (RootContext.Version == LanguageVersion.ISO_1){
 		Report.FeatureIsNotAvailable (loc, "anonymous methods");
 	}
 
 	oob_stack.Push (current_anonymous_method);
 	oob_stack.Push (current_local_parameters);
 	oob_stack.Push (current_variable);
 
 	current_local_parameters = parameters;
 
 	current_anonymous_method = lambda 
 		? new LambdaExpression (loc) 
 		
 
 	// Force the next block to be created as a ToplevelBlock
 	parsing_anonymous_method = true;
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2088" endline="2094">
<![CDATA[
 
 		#region Properties
 
 		protected int Arity {
 			get {
 				return targs == null ? 0 
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1553" endline="1560">
<![CDATA[
 
 		protected bool EqualsHelper(ElementHolderType other)
 		{
 			return other != null
 				&& other.elementType.Equals(elementType)
 				&& Util.ArrayEquals(other.requiredCustomModifiers, requiredCustomModifiers)
 				&& Util.ArrayEquals(other.optionalCustomModifiers, optionalCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="635" endline="644">
<![CDATA[
 	}
 
 	public class FlowBranchingIterator 
 	{
 		Iterator iterator;
 		public FlowBranchingIterator (FlowBranching parent, Iterator iterator)
 			
 		{
 			this.iterator = iterator;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="338" endline="347">
<![CDATA[
 
 		public TypeParameter (TypeParameterSpec spec, DeclSpace parent, TypeSpec parentSpec, MemberName name, Attributes attrs)
 			
 		{
 			this.spec = new TypeParameterSpec (parentSpec, spec.DeclaredPosition, spec.MemberDefinition, spec.SpecialConstraint, spec.Variance, null) {
 				BaseType = spec.BaseType,
 				InterfacesDefined = spec.InterfacesDefined,
 				TypeArguments = spec.TypeArguments
 			};
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="148" endline="158">
<![CDATA[
 
 		public void __SetAssemblyKeyPair(StrongNameKeyPair keyPair)
 		{
 			AssemblyName oldName = GetName();
 			this.keyPair = keyPair;
 			if (keyPair != null)
 			{
 				this.publicKey = keyPair.PublicKey;
 			}
 			universe.RenameAssembly(this, oldName);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1230" endline="1239">
<![CDATA[
 
 		public void __AddAssemblyReference(AssemblyName assemblyName)
 		{
 			if (referencedAssemblyNames == null)
 			{
 				referencedAssemblyNames = new List<AssemblyName>();
 			}
 			FindOrAddAssemblyRef(assemblyName);
 			referencedAssemblyNames.Add((AssemblyName)assemblyName.Clone());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="339" endline="348">
<![CDATA[
 
 		protected virtual void InitializeMemberCache (bool onlyTypes)
 		{
 			MemberDefinition.LoadMembers (this, onlyTypes, ref cache);
 
 			if (onlyTypes)
 				state |= StateFlags.PendingMemberCacheMembers;
 			else
 				state &= ~StateFlags.PendingMemberCacheMembers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="137" endline="145">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Store (ec);
 			if (useDefaultValue)
 				Invocation.EmitCall (ec, this, NullableInfo.GetGetValueOrDefault (expr.Type), null, loc);
 			else
 				Invocation.EmitCall (ec, this, NullableInfo.GetValue (expr.Type), null, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9507" endline="9516">
<![CDATA[
 
 		protected override IMemoryLocation EmitAddressOf (EmitContext ec, AddressOp Mode)
 		{
 			instance = base.EmitAddressOf (ec, Mode);
 
 			if (!initializers.IsEmpty)
 				initializers.Emit (ec);
 
 			return instance;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="525" endline="552">
<![CDATA[
 	}
 
 	sealed class TypeDefTable 
 	{
 		internal const int Index = 0x02;
 
 		internal struct Record
 		{
 			internal int Flags;
 			internal int TypeName;
 			internal int TypeNamespace;
 			internal int Extends;
 			internal int FieldList;
 			internal int MethodList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Extends = mr.ReadTypeDefOrRef();
 				records[i].FieldList = mr.ReadField();
 				records[i].MethodList = mr.ReadMethodDef();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].Flags = mr.ReadInt32();
 				records[i].TypeName = mr.ReadStringIndex();
 				records[i].TypeNamespace = mr.ReadStringIndex();
 				records[i].Extends = mr.ReadTypeDefOrRef();
 				records[i].FieldList = mr.ReadField();
 				records[i].MethodList = mr.ReadMethodDef();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="611" endline="639">
<![CDATA[
 	}
 
 	sealed class MethodDefTable 
 	{
 		internal const int Index = 0x06;
 		private int baseRVA;
 
 		internal struct Record
 		{
 			internal int RVA;
 			internal short ImplFlags;
 			internal short Flags;
 			internal int Name;
 			internal int Signature;
 			internal int ParamList;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].ImplFlags = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 				records[i].ParamList = mr.ReadParam();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].RVA = mr.ReadInt32();
 				records[i].ImplFlags = mr.ReadInt16();
 				records[i].Flags = mr.ReadInt16();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Signature = mr.ReadBlobIndex();
 				records[i].ParamList = mr.ReadParam();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="663" endline="670">
<![CDATA[
 
 		public override bool IsUsed {
 			get {
 				if (IsExplicitImpl)
 					return true;
 
 				return Get.IsUsed | Set.IsUsed;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2602" endline="2614">
<![CDATA[
 
 		public void WrapIntoIterator (IMethodData method, TypeContainer host, TypeSpec iterator_type, bool is_enumerable)
 		{
 			ParametersBlock pb = new ParametersBlock (this, ParametersCompiled.EmptyReadOnlyParameters, StartLocation);
 			pb.EndLocation = EndLocation;
 			pb.statements = statements;
 
 			var iterator = new Iterator (pb, method, host, iterator_type, is_enumerable);
 			am_storey = new IteratorStorey (iterator);
 
 			statements = new List<Statement> (1);
 			AddStatement (new Return (iterator, iterator.Location));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="319" endline="329">
<![CDATA[
 
 		private static bool ParseCulture(string str, out string culture)
 		{
 			if (str == null)
 			{
 				culture = null;
 				return false;
 			}
 			culture = str;
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="336" endline="343">
<![CDATA[
 
 		public FullNamedExpression Lookup (CompilerContext ctx, string name, int arity, Location loc)
 		{
 			if (arity == 0 && namespaces.ContainsKey (name))
 				return namespaces [name];
 
 			return LookupType (ctx, name, arity, false, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2363" endline="2393">
<![CDATA[
 		}
 	}
 
 
 	// TODO
 	public class Class 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.ABSTRACT |
 			Modifiers.SEALED |
 			Modifiers.STATIC |
 			Modifiers.UNSAFE;
 
 		public const TypeAttributes StaticClassAttribute = TypeAttributes.Abstract | TypeAttributes.Sealed;
 
 		public Class (NamespaceEntry ns, DeclSpace parent, MemberName name, Modifiers mod,
 			      Attributes attrs)
 			
 		{
 			var accmods = (Parent == null || Parent.Parent == null) ? Modifiers.INTERNAL 
 			this.ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod, accmods, Location, Report);
 			spec = new TypeSpec (Kind, null, this, null, ModFlags);
 
 			if (IsStatic && RootContext.Version == LanguageVersion.ISO_1) {
 				Report.FeatureIsNotAvailable (Location, "static classes");
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5507" endline="5538">
<![CDATA[
 
 		public abstract SLE.Expression MakeAssignExpression (BuilderContext ctx, Expression source);
 
 		protected abstract Expression OverloadResolve (ResolveContext rc, Expression right_side);
 
 		bool ResolveGetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasGet) {
 				if (InstanceExpression != EmptyExpression.Null) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate);
 					rc.Report.Error (154, loc, "The property or indexer `{0}' cannot be used in this context because it lacks the `get' accessor",
 						best_candidate.GetSignatureForError ());
 					return false;
 				}
 			} else if (!best_candidate.Get.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					rc.Report.Error (271, loc, "The property or indexer `{0}' cannot be used in this context because the get accessor is inaccessible",
 						TypeManager.CSharpSignature (best_candidate));
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					ErrorIsInaccesible (rc, best_candidate.Get.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility) {
 				CheckProtectedMemberAccess (rc, best_candidate.Get);
 			}
 
 			getter = CandidateToBaseOverride (rc, best_candidate.Get);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="311" endline="333">
<![CDATA[
 		}
 
 		public readonly Iterator Iterator;
 
 		TypeExpr iterator_type_expr;
 		Field pc_field;
 		Field current_field;
 
 		TypeExpr enumerator_type;
 		TypeExpr enumerable_type;
 		TypeArguments generic_args;
 		TypeExpr generic_enumerator_type;
 		TypeExpr generic_enumerable_type;
 
 		List<HoistedParameter> hoisted_params_copy;
 		int local_name_idx;
 
 		public IteratorStorey (Iterator iterator)
 			
 			  iterator.OriginalMethod as MemberBase, iterator.GenericMethod == null ? null 
 		{
 			this.Iterator = iterator;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5782" endline="5788">
<![CDATA[
 		}
 
 		public static TemporaryVariableReference Create (TypeSpec type, Block block, Location loc)
 		{
 			var li = LocalVariable.CreateCompilerGenerated (type, block, loc);
 			return new TemporaryVariableReference (li, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="501" endline="507">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			var rc = new ResolveContext (ec.MemberContext);
 			var expr = new Conditional (new BooleanExpression (condition), invoke, assign, loc).Resolve (rc);
 			expr.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1156" endline="1162">
<![CDATA[
 
 		void EmitCode (EmitContext ec, bool is_expr)
 		{
 			recurse = true;
 			this.is_expr = is_expr;
 			((IAssignMethod) expr).EmitAssign (ec, this, is_expr && (mode == Mode.PreIncrement || mode == Mode.PreDecrement), true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="431" endline="447">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label is_null_label = ec.DefineLabel ();
 			Label end_label = ec.DefineLabel ();
 
 			unwrap.EmitCheck (ec);
 			ec.Emit (OpCodes.Brfalse, is_null_label);
 
 			expr.Emit (ec);
 
 			ec.Emit (OpCodes.Br, end_label);
 			ec.MarkLabel (is_null_label);
 
 			null_value.Emit (ec);
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="290" endline="304">
<![CDATA[
 
 		protected static Type ReadRetType(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			switch (br.PeekByte())
 			{
 				case ELEMENT_TYPE_VOID
 					br.ReadByte();
 					return module.universe.System_Void;
 				case ELEMENT_TYPE_TYPEDBYREF
 					br.ReadByte();
 					return module.universe.System_TypedReference;
 				default
 					return ReadTypeOrByRef(module, br, context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="237" endline="250">
<![CDATA[
 
 		private void PostDefineType(TypeBuilder typeBuilder, PackingSize packingSize, int typesize)
 		{
 			types.Add(typeBuilder);
 			fullNameToType.Add(typeBuilder.FullName, typeBuilder);
 			if (packingSize != PackingSize.Unspecified || typesize != 0)
 			{
 				ClassLayoutTable.Record rec = new ClassLayoutTable.Record();
 				rec.PackingSize = (short)packingSize;
 				rec.ClassSize = typesize;
 				rec.Parent = typeBuilder.MetadataToken;
 				this.ClassLayout.AddRecord(rec);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1362" endline="1368">
<![CDATA[
 
 		public bool IsAssigned (ResolveContext ec)
 		{
 			return !ec.DoFlowAnalysis ||
 				(ec.OmitStructFlowAnalysis && TypeInfo.Type.IsStruct) ||
 				ec.CurrentBranching.IsAssigned (this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="54" endline="115">
<![CDATA[
 		private PEFileKinds fileKind = PEFileKinds.Dll;
 		private MethodInfo entryPoint;
 		private VersionInfo versionInfo;
 		private ResourceSection unmanagedResources;
 		private string imageRuntimeVersion;
 		internal int mdStreamVersion = 0x20000;
 		private Module pseudoManifestModule;
 		private readonly List<ResourceFile> resourceFiles = new List<ResourceFile>();
 		private readonly List<ModuleBuilder> modules = new List<ModuleBuilder>();
 		private readonly List<Module> addedModules = new List<Module>();
 		private readonly List<CustomAttributeBuilder> customAttributes = new List<CustomAttributeBuilder>();
 		private readonly List<CustomAttributeBuilder> declarativeSecurity = new List<CustomAttributeBuilder>();
 		private readonly List<Type> typeForwarders = new List<Type>();
 
 		private struct ResourceFile
 		{
 			internal string Name;
 			internal string FileName;
 			internal ResourceAttributes Attributes;
 		}
 
 		internal AssemblyBuilder(Universe universe, AssemblyName name, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
 			
 		{
 			this.name = name.Name;
 			SetVersionHelper(name.Version);
 			if (name.CultureInfo != null && !string.IsNullOrEmpty(name.CultureInfo.Name))
 			{
 				this.culture = name.CultureInfo.Name;
 			}
 			this.flags = name.Flags;
 			this.hashAlgorithm = name.HashAlgorithm;
 			if (this.hashAlgorithm == AssemblyHashAlgorithm.None)
 			{
 				this.hashAlgorithm = AssemblyHashAlgorithm.SHA1;
 			}
 			this.keyPair = name.KeyPair;
 			if (this.keyPair != null)
 			{
 				this.publicKey = this.keyPair.PublicKey;
 			}
 			else
 			{
 				byte[] publicKey = name.GetPublicKey();
 				if (publicKey != null && publicKey.Length != 0)
 				{
 					this.publicKey = (byte[])publicKey.Clone();
 				}
 			}
 			this.dir = dir ?? ".";
 			this.requiredPermissions = requiredPermissions;
 			this.optionalPermissions = optionalPermissions;
 			this.refusedPermissions = refusedPermissions;
 			if (universe.HasMscorlib && universe.Mscorlib.ImageRuntimeVersion != null)
 			{
 				this.imageRuntimeVersion = universe.Mscorlib.ImageRuntimeVersion;
 			}
 			else
 			{
 				this.imageRuntimeVersion = typeof(object).Assembly.ImageRuntimeVersion;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1651" endline="1657">
<![CDATA[
 
 		#region Properties
 
 		public IAssemblyDefinition DeclaringAssembly {
 			get {
 				return importer.GetAssemblyDefinition (provider.Module.Assembly);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="449" endline="456">
<![CDATA[
 
 		public override MemberInfo Member
 		{
 			get
 			{
 				// return the right ConstructorInfo wrapper
 				return method.Module.ResolveMethod(method.MetadataToken);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="598" endline="613">
<![CDATA[
 
 		public ExpressionStatement CreateExpressionTreeVariable (BlockContext ec)
 		{
 			if ((modFlags & Modifier.ISBYREF) != 0)
 				ec.Report.Error (1951, Location, "An expression tree parameter cannot use `ref' or `out' modifier");
 
 			expr_tree_variable = TemporaryVariableReference.Create (ResolveParameterExpressionType (ec, Location).Type, ec.CurrentBlock.ParametersBlock, Location);
 			expr_tree_variable = (TemporaryVariableReference) expr_tree_variable.Resolve (ec);
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (new TypeOf (
 				new TypeExpression (parameter_type, Location), Location)));
 			arguments.Add (new Argument (new StringConstant (Name, Location)));
 			return new SimpleAssign (ExpressionTreeVariableReference (),
 				Expression.CreateExpressionFactoryCall (ec, "Parameter", null, arguments, Location));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1164" endline="1198">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			Label end_label = ec.DefineLabel ();
 
 			if (unwrap != null) {
 				Label is_null_label = ec.DefineLabel ();
 
 				unwrap.EmitCheck (ec);
 				ec.Emit (OpCodes.Brfalse, is_null_label);
 
 				left.Emit (ec);
 				ec.Emit (OpCodes.Br, end_label);
 
 				ec.MarkLabel (is_null_label);
 				right.Emit (ec);
 
 				ec.MarkLabel (end_label);
 				return;
 			}
 
 			left.Emit (ec);
 			ec.Emit (OpCodes.Dup);
 
 			// Only to make verifier happy
 			if (left.Type.IsGenericParameter)
 				ec.Emit (OpCodes.Box, left.Type);
 
 			ec.Emit (OpCodes.Brtrue, end_label);
 
 			ec.Emit (OpCodes.Pop);
 			right.Emit (ec);
 
 			ec.MarkLabel (end_label);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5888" endline="5895">
<![CDATA[
 
 		protected override void Error_TypeOrNamespaceNotFound (IMemberContext ec)
 		{
 			if (RootContext.Version < LanguageVersion.V_3)
 				base.Error_TypeOrNamespaceNotFound (ec);
 			else
 				ec.Compiler.Report.Error (825, loc, "The contextual keyword `var' may only appear within a local variable declaration");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="199" endline="211">
<![CDATA[
 
 		protected virtual void CreateArguments (ResolveContext ec, Parameter parameter, ref Arguments args)
 		{
 			args = new Arguments (2);
 
 			LambdaExpression selector = new LambdaExpression (loc);
 
 			block.SetParameter (parameter);
 			selector.Block = block;
 			selector.Block.AddStatement (new ContextualReturn (expr));
 
 			args.Add (new Argument (selector));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="531" endline="539">
<![CDATA[
 
 		public void IsClsCompliant (IMemberContext ctx)
 		{
 			if (parameter_type.IsCLSCompliant ())
 				return;
 
 			ctx.Compiler.Report.Warning (3001, 1, Location,
 				"Argument type `{0}' is not CLS-compliant", parameter_type.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1637" endline="1644">
<![CDATA[
 
 		public Expression CreateReferenceExpression (ResolveContext rc, Location loc)
 		{
 			if (IsConstant && const_value != null)
 				return Constant.CreateConstantFromValue (Type, const_value.GetValue (), loc).Resolve (rc);
 
 			return new LocalVariableReference (this, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="408" endline="415">
<![CDATA[
 
 		public TypeSpec Resolve (Location loc)
 		{
 			if (type == null)
 				type = Resolve (module, kind, ns, name, arity, loc);
 
 			return type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="256" endline="264">
<![CDATA[
 		}
 
 		public void Store (EmitContext ec)
 		{
 			if (builder == null)
 				builder = ec.GetTemporaryLocal (type);
 
 			ec.Emit (OpCodes.Stloc, builder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="769" endline="784">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			if (right_side == EmptyExpression.OutAccess.Instance) {
 				right_side.DoResolveLValue (rc, this);
 				return null;
 			}
 
 			if (DoResolveCore (rc)) {
 				setter_args = CreateSetterArguments (rc, right_side);
 				setter = CreateCallSiteBinder (rc, setter_args, true);
 			}
 
 			eclass = ExprClass.Variable;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="591" endline="600">
<![CDATA[
 
 		public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
 		{
 			attribs |= TypeAttributes.HasSecurity;
 			if (declarativeSecurity == null)
 			{
 				declarativeSecurity = new List<CustomAttributeBuilder>();
 			}
 			declarativeSecurity.Add(customBuilder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="267" endline="276">
<![CDATA[
 
 		public void __AddDeclarativeSecurity(CustomAttributeBuilder customBuilder)
 		{
 			attributes |= MethodAttributes.HasSecurity;
 			if (declarativeSecurity == null)
 			{
 				declarativeSecurity = new List<CustomAttributeBuilder>();
 			}
 			declarativeSecurity.Add(customBuilder);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="781" endline="791">
<![CDATA[
 
 		public void EmitCalli(OpCode opc, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
 		{
 			returnType = returnType ?? moduleBuilder.universe.System_Void;
 			optionalParameterTypes = optionalParameterTypes ?? Type.EmptyTypes;
 			Emit(opc);
 			UpdateStack(opc, (callingConvention & CallingConventions.HasThis | CallingConventions.ExplicitThis) == CallingConventions.HasThis, returnType, parameterTypes.Length + optionalParameterTypes.Length);
 			ByteBuffer sig = new ByteBuffer(16);
 			Signature.WriteStandAloneMethodSig(moduleBuilder, sig, callingConvention, returnType, parameterTypes, optionalParameterTypes);
 			code.Write(0x11000000 | moduleBuilder.StandAloneSig.FindOrAddRecord(moduleBuilder.Blobs.Add(sig)));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="363" endline="371">
<![CDATA[
 		}
 
 		public void AddScopeVariable (int scope, int index)
 		{
 			if (_scope_vars == null)
 				_scope_vars = new List<ScopeVariable> ();
 			_scope_vars.Add (
 				new ScopeVariable (scope, index));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5743" endline="5754">
<![CDATA[
 
 		protected override void DoEmit (EmitContext ec)
 		{
 			Label old_begin = ec.LoopBegin, old_end = ec.LoopEnd;
 			ec.LoopBegin = ec.DefineLabel ();
 			ec.LoopEnd = ec.DefineLabel ();
 
 			statement.Emit (ec);
 
 			ec.LoopBegin = old_begin;
 			ec.LoopEnd = old_end;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="856" endline="874">
<![CDATA[
 	}
 
 	public class DynamicSiteClass 
 	{
 		//
 		// Holds the type to access the site. It gets inflated
 		// by MVARs for generic call sites
 		//
 		TypeSpec instance_type;
 
 		public DynamicSiteClass (TypeContainer parent, MemberBase host, TypeParameter[] tparams)
 			
 		{
 			if (tparams != null) {
 				mutator = new TypeParameterMutator (tparams, CurrentTypeParameters);
 			}
 
 			parent.DynamicSitesCounter++;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="396" endline="413">
<![CDATA[
 	
 	void OutlineOperator (MethodInfo mi)
 	{
 		o.Write (GetMethodVisibility (mi));
 		o.Write (GetMethodModifiers  (mi));
 		if (mi.Name == "op_Explicit" || mi.Name == "op_Implicit") {
 			o.Write (mi.Name.Substring (3).ToLower ());
 			o.Write (" operator ");
 			o.Write (FormatType (mi.ReturnType));
 		} else {
 			o.Write (FormatType (mi.ReturnType));
 			o.Write (" operator ");
 			o.Write (OperatorFromName (mi.Name));
 		}
 		o.Write (" (");
 		OutlineParams (mi.GetParameters ());
 		o.Write (");");
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="841" endline="852">
<![CDATA[
 	
 		protected void Error_CannotModifyIntermediateExpressionValue (ResolveContext ec)
 		{
 			ec.Report.SymbolRelatedToPreviousError (type);
 			if (ec.CurrentInitializerVariable != null) {
 				ec.Report.Error (1918, loc, "Members of value type `{0}' cannot be assigned using a property `{1}' object initializer",
 					TypeManager.CSharpName (type), GetSignatureForError ());
 			} else {
 				ec.Report.Error (1612, loc, "Cannot modify a value type return value of `{0}'. Consider storing the value in a temporary variable",
 					GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1989" endline="2027">
<![CDATA[
 	}
 
 	sealed class AssemblyRefTable 
 	{
 		internal const int Index = 0x23;
 
 		internal struct Record
 		{
 			internal ushort MajorVersion;
 			internal ushort MinorVersion;
 			internal ushort BuildNumber;
 			internal ushort RevisionNumber;
 			internal int Flags;
 			internal int PublicKeyOrToken;
 			internal int Name;
 			internal int Culture;
 			internal int HashValue;
 		}
 
 		internal int FindOrAddRecord(Record rec)
 		{
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Name == rec.Name
 					&& records[i].MajorVersion == rec.MajorVersion
 					&& records[i].MinorVersion == rec.MinorVersion
 					&& records[i].BuildNumber == rec.BuildNumber
 					&& records[i].RevisionNumber == rec.RevisionNumber
 					&& records[i].Flags == rec.Flags
 					&& records[i].PublicKeyOrToken == rec.PublicKeyOrToken
 					&& records[i].Culture == rec.Culture
 					&& records[i].HashValue == rec.HashValue
 					)
 				{
 					return i + 1;
 				}
 			}
 			for (int i = 0; i < rowCount; i++)
 			{
 				if (records[i].Name == rec.Name
 					&& records[i].MajorVersion == rec.MajorVersion
 					&& records[i].MinorVersion == rec.MinorVersion
 					&& records[i].BuildNumber == rec.BuildNumber
 					&& records[i].RevisionNumber == rec.RevisionNumber
 					&& records[i].Flags == rec.Flags
 					&& records[i].PublicKeyOrToken == rec.PublicKeyOrToken
 					&& records[i].Culture == rec.Culture
 					&& records[i].HashValue == rec.HashValue
 					)
 				{
 					return i + 1;
 				}
 			}
 			return AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="738" endline="746">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			//
 			// Invocation on delegates call the virtual Invoke member
 			// so we are always `instance' calls
 			//
 			Invocation.EmitCall (ec, InstanceExpr, method, arguments, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1325" endline="1332">
<![CDATA[
 	
 		// 
 		// root_types contains all the types.  All TopLevel types
 		// hence have a parent that points to `root_types', that is
 		// why there is a non-obvious test down here.
 		//
 		public bool IsTopLevel {
 			get { return (Parent != null && Parent.Parent == null); }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2283" endline="2309">
<![CDATA[
 		
 		bool pp_eq (ref string s)
 		{
 			bool va = pp_unary (ref s);
 
 			s = s.Trim ();
 			int len = s.Length;
 			if (len > 0){
 				if (s [0] == '='){
 					if (len > 2 && s [1] == '='){
 						s = s.Substring (2);
 						return va == pp_unary (ref s);
 					} else {
 						Error_InvalidDirective ();
 						return false;
 					}
 				} else if (s [0] == '!' && len > 1 && s [1] == '='){
 					s = s.Substring (2);
 
 					return va != pp_unary (ref s);
 
 				} 
 			}
 
 			return va;
 				
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3043" endline="3082">
<![CDATA[
 
 		//
 		// Performs various checks on the MethodInfo `mb' regarding the modifier flags
 		// that have been defined.
 		//
 		protected virtual bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			bool ok = true;
 
 			if ((base_member.Modifiers & (Modifiers.ABSTRACT | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0) {
 				Report.SymbolRelatedToPreviousError (base_member);
 				Report.Error (506, Location,
 					"`{0}'
 					 GetSignatureForError (), TypeManager.CSharpSignature (base_member));
 				ok = false;
 			}
 
 			// Now we check that the overriden method is not final	
 			if ((base_member.Modifiers & Modifiers.SEALED) != 0) {
 				Report.SymbolRelatedToPreviousError (base_member);
 				Report.Error (239, Location, "`{0}'
 							  GetSignatureForError (), TypeManager.CSharpSignature (base_member));
 				ok = false;
 			}
 
 			var base_member_type = ((IInterfaceMemberSpec) base_member).MemberType;
 			if (!TypeSpecComparer.Override.IsEqual (MemberType, base_member_type)) {
 				Report.SymbolRelatedToPreviousError (base_member);
 				if (this is PropertyBasedMember) {
 					Report.Error (1715, Location, "`{0}'
 						GetSignatureForError (), TypeManager.CSharpName (base_member_type), TypeManager.CSharpSignature (base_member));
 				} else {
 					Report.Error (508, Location, "`{0}'
 						GetSignatureForError (), TypeManager.CSharpName (base_member_type), TypeManager.CSharpSignature (base_member));
 				}
 				ok = false;
 			}
 
 			return ok;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="258" endline="293">
<![CDATA[
 		}
 
 		private sealed class Binder 
 		{
 			private readonly Type declaringType;
 			private readonly Type[] methodArgs;
 
 			internal Binder(Type declaringType, Type[] methodArgs)
 			{
 				this.declaringType = declaringType;
 				this.methodArgs = methodArgs;
 			}
 
 			public Type BindTypeParameter(Type type)
 			{
 				return declaringType.GetGenericTypeArgument(type.GenericParameterPosition);
 			}
 
 			public Type BindMethodParameter(Type type)
 			{
 				if (methodArgs == null)
 				{
 					return type;
 				}
 				return methodArgs[type.GenericParameterPosition];
 			}
 		}
 
 		internal MethodSignature Bind(Type type, Type[] methodArgs)
 		{
 			Binder binder = new Binder(type, methodArgs);
 			return new MethodSignature(returnType.BindTypeParameters(binder),
 				BindTypeParameters(binder, parameterTypes),
 				BindTypeParameters(binder, modifiers),
 				callingConvention, genericParamCount);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="658" endline="671">
<![CDATA[
 
 		static string GetBodyIdentifierFromName (string name)
 		{
 			string identifier = name;
 
 			if (name.Length > 0 && name [name.Length - 1] == ']') {
 				string tmp = name.Substring (0, name.Length - 1).Trim (wsChars);
 				int last = tmp.LastIndexOf ('[');
 				if (last > 0)
 					identifier = tmp.Substring (0, last).Trim (wsChars);
 			}
 
 			return identifier;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3196" endline="3213">
<![CDATA[
 
 		public override void Emit()
 		{
 			// for extern static method must be specified either DllImport attribute or MethodImplAttribute.
 			// We are more strict than csc and report this as an error because SRE does not allow emit that
 			if ((ModFlags & Modifiers.EXTERN) != 0 && !is_external_implementation) {
 				if (this is Constructor) {
 					Report.Error (824, Location,
 						"Constructor `{0}' is marked `external' but has no external implementation specified", GetSignatureForError ());
 				} else {
 					Report.Error (626, Location,
 						"`{0}' is marked as an external but has no DllImport attribute. Consider adding a DllImport attribute to specify the external implementation",
 						GetSignatureForError ());
 				}
 			}
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="739" endline="765">
<![CDATA[
 
 		//
 		// Called back from Yield
 		//
 		public void MarkYield (EmitContext ec, Expression expr, int resume_pc, bool unwind_protect, Label resume_point)
 		{
 			// Store the new current
 			ec.Emit (OpCodes.Ldarg_0);
 			expr.Emit (ec);
 			ec.Emit (OpCodes.Stfld, IteratorHost.CurrentField.Spec);
 
 			// store resume program-counter
 			ec.Emit (OpCodes.Ldarg_0);
 			ec.EmitInt (resume_pc);
 			ec.Emit (OpCodes.Stfld, IteratorHost.PC.Spec);
 
 			// mark finally blocks as disabled
 			if (unwind_protect && skip_finally != null) {
 				ec.EmitInt (1);
 				ec.Emit (OpCodes.Stloc, skip_finally);
 			}
 
 			// Return ok
 			ec.Emit (unwind_protect ? OpCodes.Leave 
 
 			ec.MarkLabel (resume_point);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2399" endline="2408">
<![CDATA[
 
 		protected ParametersBlock (ParametersCompiled parameters, Location start)
 			
 		{
 			if (parameters == null)
 				throw new ArgumentNullException ("parameters");
 
 			this.parameters = parameters;
 			ParametersBlock = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="82" endline="96">
<![CDATA[
 		}
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, InvokeBuilder.MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="45" endline="56">
<![CDATA[
 		{
 			if (UseNativeFusion)
 			{
 				bool equivalent;
 				Marshal.ThrowExceptionForHR(CompareAssemblyIdentity(assemblyIdentity1, unified1, assemblyIdentity2, unified2, out equivalent, out result));
 				return equivalent;
 			}
 			else
 			{
 				return CompareAssemblyIdentityPure(assemblyIdentity1, unified1, assemblyIdentity2, unified2, out result);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="469" endline="801">
<![CDATA[
 
 		protected MethodOrOperator (DeclSpace parent, GenericMethod generic, FullNamedExpression type, Modifiers mod,
 				Modifiers allowed_mod, MemberName name,
 				Attributes attrs, ParametersCompiled parameters)
 			
 					attrs, parameters)
 		{
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			if (a.Type == pa.DllImport) {
 				const Modifiers extern_static = Modifiers.EXTERN | Modifiers.STATIC;
 				if ((ModFlags & extern_static) != extern_static) {
 					Report.Error (601, a.Location, "The DllImport attribute must be specified on a method marked `static' and `extern'");
 				}
 				is_external_implementation = true;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (MethodBuilder != null)
 				MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Method; 
 			}
 		}
 
 		protected override bool CheckForDuplications ()
 		{
 			return Parent.MemberCache.CheckExistingMembersOverloads (this, parameters);
 		}
 
 		public virtual EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			return new EmitContext (this, ig, MemberType);
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!CheckBase ())
 				return false;
 
 			MemberKind kind;
 			if (this is Operator)
 				kind = MemberKind.Operator;
 			else if (this is Destructor)
 				kind = MemberKind.Destructor;
 			else
 				kind = MemberKind.Method;
 
 			if (IsPartialDefinition) {
 				caching_flags &= ~Flags.Excluded_Undetected;
 				caching_flags |= Flags.Excluded;
 
 				// Add to member cache only when a partial method implementation has not been found yet
 				if ((caching_flags & Flags.PartialDefinitionExists) == 0) {
 //					MethodBase mb = new PartialMethodDefinitionInfo (this);
 
 					spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, null, parameters, ModFlags);
 					Parent.MemberCache.AddMember (spec);
 				}
 
 				return true;
 			}
 
 			MethodData = new MethodData (
 				this, ModFlags, flags, this, MethodBuilder, GenericMethod, base_method);
 
 			if (!MethodData.Define (Parent.PartialContainer, GetFullName (MemberName), Report))
 				return false;
 					
 			MethodBuilder = MethodData.MethodBuilder;
 
 			spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, MethodBuilder, parameters, ModFlags);
 			if (MemberName.Arity > 0)
 				spec.IsGeneric = true;
 			
 			Parent.MemberCache.AddMember (this, MethodBuilder.Name, spec);
 
 			return true;
 		}
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			CheckAbstractAndExtern (block != null);
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0) {
 				for (int i = 0; i < parameters.Count; ++i) {
 					IParameterData p = parameters.FixedParameters [i];
 					if (p.ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (752, Location, "`{0}'
 							GetSignatureForError ());
 					}
 
 					if (p.HasDefaultValue && IsPartialImplementation)
 						((Parameter) p).Warning_UselessOptionalParameter (Report);
 				}
 			}
 		}
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			if (MemberType.IsStatic) {
 				Error_StaticReturnType ();
 			}
 		}
 
 		public override void Emit ()
 		{
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (MethodBuilder);
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			if (MethodData != null)
 				MethodData.Emit (Parent);
 
 			base.Emit ();
 
 			Block = null;
 			MethodData = null;
 		}
 
 		protected void Error_ConditionalAttributeIsNotValid ()
 		{
 			Report.Error (577, Location,
 				"Conditional not valid on `{0}' because it is a constructor, destructor, operator or explicit interface implementation",
 				GetSignatureForError ());
 		}
 
 		public bool IsPartialDefinition {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block == null;
 			}
 		}
 
 		public bool IsPartialImplementation {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block != null;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#region IMethodData Members
 
 		public TypeSpec ReturnType {
 			get {
 				return MemberType;
 			}
 		}
 
 		public MemberName MethodName {
 			get {
 				return MemberName;
 			}
 		}
 
 		/// <summary>
 		/// Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
 		/// </summary>
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.Excluded) != 0)
 				return new string [0];
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 			string[] conditions;
 
 			if (base_method == null) {
 				if (OptAttributes == null)
 					return null;
 
 				Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 				if (attrs == null)
 					return null;
 
 				conditions = new string[attrs.Length];
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			} else {
 				conditions = base_method.MemberDefinition.ConditionalConditions();
 			}
 
 			if (conditions != null)
 				caching_flags |= Flags.Excluded;
 
 			return conditions;
 		}
 
 		GenericMethod IMethodData.GenericMethod {
 			get {
 				return GenericMethod;
 			}
 		}
 
 		public virtual void EmitExtraSymbolInfo (SourceMethod source)
 		{ }
 
 		#endregion
 
 	}
 
 	public class SourceMethod 
 	{
 		MethodBase method;
 		SourceMethodBuilder builder;
 
 		protected SourceMethod (DeclSpace parent, MethodBase method, ICompileUnit file)
 		{
 			this.method = method;
 			
 			builder = SymbolWriter.OpenMethod (file, parent.NamespaceEntry.SymbolFileID, this);
 		}
 
 		public string Name {
 			get { return method.Name; }
 		}
 
 		public int Token {
 			get {
 				MethodToken token;
 				var mb = method as MethodBuilder;
 				if (mb != null)
 					token = mb.GetToken ();
 				else
 					token = ((ConstructorBuilder) method).GetToken ();
 #if STATIC
 				if (token.IsPseudoToken)
 					return ((ModuleBuilder) method.Module).ResolvePseudoToken (token.Token);
 #endif
 				return token.Token;
 			}
 		}
 
 		public void CloseMethod ()
 		{
 			SymbolWriter.CloseMethod ();
 		}
 
 		public void SetRealMethodName (string name)
 		{
 			if (builder != null)
 				builder.SetRealMethodName (name);
 		}
 
 		public static SourceMethod Create (DeclSpace parent, MethodBase method, Block block)
 		{
 			if (!SymbolWriter.HasSymbolWriter)
 				return null;
 			if (block == null)
 				return null;
 
 			Location start_loc = block.StartLocation;
 			if (start_loc.IsNull)
 				return null;
 
 			ICompileUnit compile_unit = start_loc.CompilationUnit;
 			if (compile_unit == null)
 				return null;
 
 			return new SourceMethod (parent, method, compile_unit);
 		}
 	}
 
 	public class Method 
 	{
 		Method partialMethodImplementation;
 
 		public Method (DeclSpace parent, GenericMethod generic,
 			       FullNamedExpression return_type, Modifiers mod,
 			       MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs, parameters)
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="576" endline="582">
<![CDATA[
 
 		bool IsBitwiseBoolean {
 			get {
 				return (Oper == Operator.BitwiseAnd || Oper == Operator.BitwiseOr) &&
 				((left_unwrap != null && left_unwrap.Type == TypeManager.bool_type) ||
 				 (right_unwrap != null && right_unwrap.Type == TypeManager.bool_type));
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="119" endline="126">
<![CDATA[
 		}
 
 		bool IsAnonymousStoreyMutateRequired {
 			get {
 				return CurrentAnonymousMethod != null &&
 					CurrentAnonymousMethod.Storey != null &&
 					CurrentAnonymousMethod.Storey.Mutator != null;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="95" endline="102">
<![CDATA[
 
 		public MemberName (MemberName left, MemberName right, Location loc)
 			
 		{
 			if (right.is_double_colon)
 				throw new InternalErrorException ("Cannot append double_colon member name");
 			this.Left = (right.Left == null) ? left 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2619" endline="2626">
<![CDATA[
 		public Struct (NamespaceEntry ns, DeclSpace parent, MemberName name,
 			       Modifiers mod, Attributes attrs)
 			
 		{
 			var accmods = parent.Parent == null ? Modifiers.INTERNAL 
 			this.ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod, accmods, Location, Report) | Modifiers.SEALED ;
 			spec = new TypeSpec (Kind, null, this, null, ModFlags);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="94" endline="109">
<![CDATA[
 		}
 
 		#endregion
 
 		public static bool CheckConflictingInheritedConstraint (TypeParameterSpec spec, TypeSpec bb, IMemberContext context, Location loc)
 		{
 			if (spec.HasSpecialClass && bb.IsStruct) {
 				context.Compiler.Report.Error (455, loc,
 					"Type parameter `{0}' inherits conflicting constraints `{1}' and `{2}'",
 					spec.Name, "class", bb.GetSignatureForError ());
 
 				return false;
 			}
 
 			return CheckConflictingInheritedConstraint (spec, spec.BaseType, bb, context, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="300" endline="308">
<![CDATA[
 	
 	void OutlineConstructor (ConstructorInfo ci)
 	{
 		o.Write (GetMethodVisibility (ci));
 		o.Write (RemoveGenericArity (t.Name));
 		o.Write (" (");
 		OutlineParams (ci.GetParameters ());
 		o.Write (");");
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="551" endline="562">
<![CDATA[
 
 		public MethodToken GetConstructorToken(ConstructorInfo constructor)
 		{
 			if (constructor.Module == this && constructor.GetMethodInfo() is MethodBuilder)
 			{
 				return new MethodToken(constructor.MetadataToken);
 			}
 			else
 			{
 				return new MethodToken(ImportMember(constructor));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="633" endline="655">
<![CDATA[
 
 		static public RSA FromCapiKeyBlob (byte[] blob, int offset) 
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			switch (blob [offset]) {
 				case 0x00
 					// this could be a public key inside an header
 					// like "sn -e" would produce
 					if (blob [offset + 12] == 0x06) {
 						return FromCapiPublicKeyBlob (blob, offset + 12);
 					}
 					break;
 				case 0x06
 					return FromCapiPublicKeyBlob (blob, offset);
 				case 0x07
 					return FromCapiPrivateKeyBlob (blob, offset);
 			}
 			throw new CryptographicException ("Unknown blob format.");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="270" endline="339">
<![CDATA[
 
 		private static TypeSpec FindDocumentedTypeNonArray (MemberCore mc, 
 			string identifier, DeclSpace ds, string cref, Report r)
 		{
 			switch (identifier) {
 			case "int"
 				return TypeManager.int32_type;
 			case "uint"
 				return TypeManager.uint32_type;
 			case "short"
 				return TypeManager.short_type;;
 			case "ushort"
 				return TypeManager.ushort_type;
 			case "long"
 				return TypeManager.int64_type;
 			case "ulong"
 				return TypeManager.uint64_type;;
 			case "float"
 				return TypeManager.float_type;;
 			case "double"
 				return TypeManager.double_type;
 			case "char"
 				return TypeManager.char_type;;
 			case "decimal"
 				return TypeManager.decimal_type;;
 			case "byte"
 				return TypeManager.byte_type;;
 			case "sbyte"
 				return TypeManager.sbyte_type;;
 			case "object"
 				return TypeManager.object_type;;
 			case "bool"
 				return TypeManager.bool_type;;
 			case "string"
 				return TypeManager.string_type;;
 			case "void"
 				return TypeManager.void_type;;
 			}
 			FullNamedExpression e = ds.LookupNamespaceOrType (identifier, 0, mc.Location, false);
 			if (e != null) {
 				if (!(e is TypeExpr))
 					return null;
 				return e.Type;
 			}
 			int index = identifier.LastIndexOf ('.');
 			if (index < 0)
 				return null;
 
 			var nsName = identifier.Substring (0, index);
 			var typeName = identifier.Substring (index + 1);
 			Namespace ns = ds.NamespaceEntry.NS.GetNamespace (nsName, false);
 			ns = ns ?? mc.Module.GlobalRootNamespace.GetNamespace(nsName, false);
 			if (ns != null) {
 				var te = ns.LookupType(mc.Compiler, typeName, 0, true, mc.Location);
 				if(te != null)
 					return te.Type;
 			}
 
 			int warn;
 			TypeSpec parent = FindDocumentedType (mc, identifier.Substring (0, index), ds, cref, r);
 			if (parent == null)
 				return null;
 			// no need to detect warning 419 here
 			var ts = FindDocumentedMember (mc, parent,
 				identifier.Substring (index + 1),
 				null, ds, out warn, cref, false, null, r) as TypeSpec;
 			if (ts != null)
 				return ts;
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="402" endline="409">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Assign _target = (Assign) t;
 
 			_target.target = target.Clone (clonectx);
 			_target.source = source.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="329" endline="336">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Do target = (Do) t;
 
 			target.EmbeddedStatement = EmbeddedStatement.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="443" endline="450">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			While target = (While) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.Statement = Statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3862" endline="3869">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Binary target = (Binary) t;
 
 			target.left = left.Clone (clonectx);
 			target.right = right.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1199" endline="1206">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			NullCoalescingOperator target = (NullCoalescingOperator) t;
 
 			target.left = left.Clone (clonectx);
 			target.right = right.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1278" endline="1287">
<![CDATA[
 
 		protected abstract string OperatorName { get; }
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Probe target = (Probe) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.ProbeType = ProbeType.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1606" endline="1613">
<![CDATA[
 		
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Cast target = (Cast) t;
 
 			target.target_type = target_type.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\EventInfoImpl.cs" startline="130" endline="136">
<![CDATA[
 		}
 
 		private void ComputeFlags()
 		{
 			module.MethodSemantics.ComputeFlags(module, this.MetadataToken, out isPublic, out isStatic);
 			flagsCached = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PropertyInfoImpl.cs" startline="148" endline="154">
<![CDATA[
 		}
 
 		private void ComputeFlags()
 		{
 			module.MethodSemantics.ComputeFlags(module, this.MetadataToken, out isPublic, out isStatic);
 			flagsCached = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5755" endline="5763">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Foreach target = (Foreach) t;
 
 			target.type = type.Clone (clonectx);
 			target.expr = expr.Clone (clonectx);
 			target.statement = statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4518" endline="4526">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Conditional target = (Conditional) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.true_expr = true_expr.Clone (clonectx);
 			target.false_expr = false_expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2409" endline="2422">
<![CDATA[
 
 		protected ParametersBlock (ParametersBlock source, ParametersCompiled parameters)
 			
 		{
 			this.parameters = parameters;
 			this.statements = source.statements;
 			this.scope_initializers = source.scope_initializers;
 
 			this.resolved = true;
 			this.unreachable = source.unreachable;
 			this.am_storey = source.am_storey;
 
 			ParametersBlock = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2813" endline="2822">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.ComImport && !attributes.Contains (pa.Guid)) {
 				a.Error_MissingGuidAttribute ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\VersionInfo.cs" startline="227" endline="243">
<![CDATA[
 
 		private static void WriteString(ByteBuffer bb, string name, string value)
 		{
 			value = value ?? " ";
 			int pos = bb.Position;
 			bb.Write((short)0);					// wLength (placeholder)
 			bb.Write((short)(value.Length + 1));// wValueLength
 			bb.Write((short)1);					// wType
 			WriteUTF16Z(bb, name);
 			bb.Align(4);
 			WriteUTF16Z(bb, value);
 			bb.Align(4);
 			int savedPos = bb.Position;
 			bb.Position = pos;
 			bb.Write((short)(savedPos - pos));
 			bb.Position = savedPos;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="578" endline="592">
<![CDATA[
 
 		public override MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 		{
 			switch (metadataToken >> 24)
 			{
 				case FieldTable.Index
 					return ResolveField(metadataToken, genericTypeArguments, genericMethodArguments);
 				case MemberRefTable.Index
 					return GetMemberRef((metadataToken & 0xFFFFFF) - 1, genericTypeArguments, genericMethodArguments);
 				case MethodDefTable.Index
 				case MethodSpecTable.Index
 					return ResolveMethod(metadataToken, genericTypeArguments, genericMethodArguments);
 			}
 			throw new ArgumentOutOfRangeException();
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="110" endline="6171">
<![CDATA[
 		bool global_attrs_enabled = true;
   public System.IO.TextWriter ErrorOutput = System.Console.Out;
 public CSharpParser (SeekableStreamReader reader, CompilationUnit file, ModuleContainer module)
 {
 	if (RootContext.EvalMode)
 		undo = new Undo ();
 
 	this.file = file;
 	this.module = module;
 	this.compiler = module.Compiler;
 	current_namespace = new NamespaceEntry (module, null, file, null);
 	current_class = current_namespace.SlaveDeclSpace;
 	current_container = current_class.PartialContainer; // == RootContest.ToplevelTypes
 	oob_stack.Clear ();
 	lexer = new Tokenizer (reader, file, compiler);
 	
 	use_global_stacks = true;
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="288" endline="299">
<![CDATA[
 
 	void OutlineEvent (EventInfo ei)
 	{
 		MethodBase accessor = ei.GetAddMethod (true);
 		
 		o.Write (GetMethodVisibility (accessor));
 		o.Write ("event ");
 		o.Write (FormatType (ei.EventHandlerType));
 		o.Write (" ");
 		o.Write (ei.Name);
 		o.Write (";");
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="778" endline="788">
<![CDATA[
 
 		public override void Emit ()
 		{
 			if ((AccessorFirst.ModFlags & (Modifiers.STATIC | Modifiers.COMPILER_GENERATED)) == Modifiers.COMPILER_GENERATED && Parent.PartialContainer.HasExplicitLayout) {
 				Report.Error (842, Location,
 					"Automatically implemented property `{0}' cannot be used inside a type with an explicit StructLayout attribute",
 					GetSignatureForError ());
 			}
 
 			base.Emit ();
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6207" endline="6214">
<![CDATA[
 
 void CheckToken (int error, int yyToken, string msg, Location loc)
 {
 	if (yyToken >= Token.FIRST_KEYWORD && yyToken <= Token.LAST_KEYWORD)
 		Report.Error (error, loc, "{0}
 	else
 		Report.Error (error, loc, msg);
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2785" endline="2812">
<![CDATA[
 
 	}
 
 	/// <summary>
 	///   Interfaces
 	/// </summary>
 	public sealed class Interface 
 
 		/// <summary>
 		///   Modifiers allowed in a class declaration
 		/// </summary>
 		public const Modifiers AllowedModifiers =
 			Modifiers.NEW       |
 			Modifiers.PUBLIC    |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL  |
 		 	Modifiers.UNSAFE    |
 			Modifiers.PRIVATE;
 
 		public Interface (NamespaceEntry ns, DeclSpace parent, MemberName name, Modifiers mod,
 				  Attributes attrs)
 			
 		{
 			var accmods = parent.Parent == null ? Modifiers.INTERNAL 
 
 			this.ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod, accmods, name.Location, Report);
 			spec = new TypeSpec (Kind, null, this, null, ModFlags);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2927" endline="2936">
<![CDATA[
 		public InterfaceMemberBase (DeclSpace parent, GenericMethod generic,
 				   FullNamedExpression type, Modifiers mod, Modifiers allowed_mod,
 				   MemberName name, Attributes attrs)
 			
 				name, attrs)
 		{
 			IsInterface = parent.PartialContainer.Kind == MemberKind.Interface;
 			IsExplicitImpl = (MemberName.Left != null);
 			explicit_mod_flags = mod;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="364" endline="379">
<![CDATA[
 
 		#region Properties
 
 		//
 		// Explicit struct layout set by parent
 		//
 		public CharSet? CharSet {
 			get; set;
 		}		
 
 		#endregion
 
 		public override Constant ConvertInitializer (ResolveContext rc, Constant expr)
 		{
 			return expr.ImplicitConversionRequired (rc, TypeManager.int32_type, Location);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="181" endline="187">
<![CDATA[
 
 		public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes)
 		{
 			this.attr = genericParameterAttributes;
 			// for now we'll back patch the table
 			this.ModuleBuilder.GenericParam.PatchAttribute(paramPseudoIndex, genericParameterAttributes);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1342" endline="1348">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			Child = Child.Resolve (rc);
 			this.eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="171" endline="177">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			expr = expr.Resolve (ec);
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="281" endline="290">
<![CDATA[
 
 		public void AddMember (InterfaceMemberBase imb, string exlicitName, MemberSpec ms)
 		{
 			// Explicit names cannot be looked-up but can be used for
 			// collision checking (no name mangling needed)
 			if (imb.IsExplicitImpl)
 				AddMember (exlicitName, ms);
 			else
 				AddMember (ms);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="493" endline="500">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = InternalType.Dynamic;
 			eclass = ExprClass.Value;
 			condition = condition.Resolve (rc);
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1993" endline="2002">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				Error_ConditionalAttributeIsNotValid ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2336" endline="2345">
<![CDATA[
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				Error_ConditionalAttributeIsNotValid ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="2394" endline="2401">
<![CDATA[
 
 		public override void AddBasesForPart (DeclSpace part, List<FullNamedExpression> bases)
 		{
 			if (part.Name == "System.Object")
 				Report.Error (537, part.Location,
 					"The class System.Object cannot have a base class or implement an interface.");
 			base.AddBasesForPart (part, bases);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="269" endline="282">
<![CDATA[
 
 		private void WriteEntry(ByteBuffer bb, ref int offset, Dictionary<string, int> strings, ref int stringTableOffset, ByteBuffer stringTable)
 		{
 			WriteNameOrOrdinal(bb, OrdinalOrName, strings, ref stringTableOffset, stringTable);
 			if (Data == null)
 			{
 				bb.Write(0x80000000U | (uint)offset);
 			}
 			else
 			{
 				bb.Write(offset);
 			}
 			offset += 16 + entries.Count * 8;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="35" endline="41">
<![CDATA[
 		}
 
 		public void RegisterNamespace (Namespace child)
 		{
 			if (child != this)
 				all_namespaces.Add (child.Name, child);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1200" endline="1215">
<![CDATA[
 			}
 
 			#endregion
 		}
 
 		Expression initializer;
 		protected FullNamedExpression type_expr;
 		protected LocalVariable li;
 		protected List<Declarator> declarators;
 
 		public BlockVariableDeclaration (FullNamedExpression type, LocalVariable li)
 		{
 			this.type_expr = type;
 			this.li = li;
 			this.loc = type_expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9517" endline="9524">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			base.CloneTo (clonectx, t);
 
 			NewInitialize target = (NewInitialize) t;
 			target.initializers = (CollectionOrObjectInitializers) initializers.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5539" endline="5564">
<![CDATA[
 
 		bool ResolveSetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasSet) {
 				rc.Report.Error (200, loc, "Property or indexer `{0}' cannot be assigned to (it is read-only)",
 					GetSignatureForError ());
 				return false;
 			}
 
 			if (!best_candidate.Set.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					rc.Report.Error (272, loc, "The property or indexer `{0}' cannot be used in this context because the set accessor is inaccessible",
 						GetSignatureForError ());
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					ErrorIsInaccesible (rc, best_candidate.Set.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility)
 				CheckProtectedMemberAccess (rc, best_candidate.Set);
 
 			setter = CandidateToBaseOverride (rc, best_candidate.Set);
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="556" endline="563">
<![CDATA[
 
 		public override bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			vector = vector.Clone ();
 			vector.Next = break_origins;
 			break_origins = vector;
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="580" endline="587">
<![CDATA[
 
 		public override bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			vector = vector.Clone ();
 			vector.Next = continue_origins;
 			continue_origins = vector;
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\CustomAttributeData.cs" startline="228" endline="295">
<![CDATA[
 
 		private static CustomAttributeTypedArgument ReadFixedArg(Assembly asm, ByteReader br, Type type)
 		{
 			Universe u = asm.universe;
 			if (type == u.System_String)
 			{
 				return new CustomAttributeTypedArgument(type, br.ReadString());
 			}
 			else if (type == u.System_Type)
 			{
 				return new CustomAttributeTypedArgument(type, ReadType(asm, br));
 			}
 			else if (type == u.System_Object)
 			{
 				return ReadFixedArg(asm, br, ReadFieldOrPropType(asm, br));
 			}
 			else if (type.IsArray)
 			{
 				int length = br.ReadInt32();
 				if (length == -1)
 				{
 					return new CustomAttributeTypedArgument(type, null);
 				}
 				Type elementType = type.GetElementType();
 				CustomAttributeTypedArgument[] array = new CustomAttributeTypedArgument[length];
 				for (int i = 0; i < length; i++)
 				{
 					array[i] = ReadFixedArg(asm, br, elementType);
 				}
 				for (int i = 0; i < length; i++)
 				{
 					array[i] = ReadFixedArg(asm, br, elementType);
 				}
 				return new CustomAttributeTypedArgument(type, array);
 			}
 			else if (type.IsEnum)
 			{
 				return new CustomAttributeTypedArgument(type, ReadFixedArg(asm, br, type.GetEnumUnderlyingTypeImpl()).Value);
 			}
 			else
 			{
 				switch (Type.GetTypeCode(type))
 				{
 					case TypeCode.Boolean
 						return new CustomAttributeTypedArgument(type, br.ReadByte() != 0);
 					case TypeCode.Char
 						return new CustomAttributeTypedArgument(type, br.ReadChar());
 					case TypeCode.Single
 						return new CustomAttributeTypedArgument(type, br.ReadSingle());
 					case TypeCode.Double
 						return new CustomAttributeTypedArgument(type, br.ReadDouble());
 					case TypeCode.SByte
 						return new CustomAttributeTypedArgument(type, br.ReadSByte());
 					case TypeCode.Int16
 						return new CustomAttributeTypedArgument(type, br.ReadInt16());
 					case TypeCode.Int32
 						return new CustomAttributeTypedArgument(type, br.ReadInt32());
 					case TypeCode.Int64
 						return new CustomAttributeTypedArgument(type, br.ReadInt64());
 					case TypeCode.Byte
 						return new CustomAttributeTypedArgument(type, br.ReadByte());
 					case TypeCode.UInt16
 						return new CustomAttributeTypedArgument(type, br.ReadUInt16());
 					case TypeCode.UInt32
 						return new CustomAttributeTypedArgument(type, br.ReadUInt32());
 					case TypeCode.UInt64
 						return new CustomAttributeTypedArgument(type, br.ReadUInt64());
 					default
 						throw new InvalidOperationException();
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="87" endline="95">
<![CDATA[
 	}
 
 	public class ParenthesizedExpression 
 	{
 		public ParenthesizedExpression (Expression expr)
 			
 		{
 			loc = expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4320" endline="4332">
<![CDATA[
 	}
 
 	//
 	// A boolean-expression is an expression that yields a result
 	// of type bool
 	//
 	public class BooleanExpression 
 	{
 		public BooleanExpression (Expression expr)
 			
 		{
 			this.loc = expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="141" endline="147">
<![CDATA[
 
 		public void __SetAssemblyCulture(string cultureName)
 		{
 			AssemblyName oldName = GetName();
 			this.culture = cultureName;
 			universe.RenameAssembly(this, oldName);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="111" endline="119">
<![CDATA[
 
 		public void MarkSequencePoint (int offset, SourceFileEntry file, int line, int column,
 					       bool is_hidden)
 		{
 			if (current_method == null)
 				return;
 
 			current_method.MarkSequencePoint (offset, file, line, column, is_hidden);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1514" endline="1521">
<![CDATA[
 
 		public MyBitVector (MyBitVector InheritsFrom, int Count)
 		{
 			if (InheritsFrom != null)
 				shared = InheritsFrom.MakeShared (Count);
 
 			this.Count = Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="878" endline="892">
<![CDATA[
 
 		protected override void AddSibling (UsageVector sibling)
 		{
 			switch (sibling.Type) {
 			case SiblingType.Try
 				try_vector = sibling;
 				break;
 			case SiblingType.Finally
 				finally_vector = sibling;
 				break;
 			default
 				throw new InvalidOperationException ();
 			}
 			current_vector = sibling;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5076" endline="5082">
<![CDATA[
 		public Invocation (Expression expr, Arguments arguments)
 		{
 			this.expr = expr;		
 			this.arguments = arguments;
 			if (expr != null)
 				loc = expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="502" endline="517">
<![CDATA[
 			}
 		}
 
 		//
 		// Keep resolved value because field initializers have their own rules
 		//
 		ExpressionStatement resolved;
 		IMemberContext mc;
 
 		public FieldInitializer (FieldSpec spec, Expression expression, IMemberContext mc)
 			
 		{
 			this.mc = mc;
 			if (!spec.IsStatic)
 				((FieldExpr)target).InstanceExpression = CompilerGeneratedThis.Instance;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1229" endline="1238">
<![CDATA[
 		public EmptyConstantCast (Constant child, TypeSpec type)
 			
 		{
 			if (child == null)
 				throw new ArgumentNullException ("child");
 
 			this.child = child;
 			this.eclass = child.eclass;
 			this.type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="91" endline="197">
<![CDATA[
 	}
 
 	sealed class IMAGE_OPTIONAL_HEADER
 	{
 		public const WORD IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x10b;
 		public const WORD IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x20b;
 
 		public const WORD IMAGE_SUBSYSTEM_WINDOWS_GUI = 2;
 		public const WORD IMAGE_SUBSYSTEM_WINDOWS_CUI = 3;
 
 		public const WORD IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = 0x0040;
 		public const WORD IMAGE_DLLCHARACTERISTICS_NX_COMPAT = 0x0100;
 		public const WORD IMAGE_DLLCHARACTERISTICS_NO_SEH = 0x0400;
 		public const WORD IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = 0x8000;
 
 		public WORD Magic;
 		public BYTE MajorLinkerVersion;
 		public BYTE MinorLinkerVersion;
 		public DWORD SizeOfCode;
 		public DWORD SizeOfInitializedData;
 		public DWORD SizeOfUninitializedData;
 		public DWORD AddressOfEntryPoint;
 		public DWORD BaseOfCode;
 		public DWORD BaseOfData;
 		public ULONGLONG ImageBase;
 		public DWORD SectionAlignment;
 		public DWORD FileAlignment;
 		public WORD MajorOperatingSystemVersion;
 		public WORD MinorOperatingSystemVersion;
 		public WORD MajorImageVersion;
 		public WORD MinorImageVersion;
 		public WORD MajorSubsystemVersion;
 		public WORD MinorSubsystemVersion;
 		public DWORD Win32VersionValue;
 		public DWORD SizeOfImage;
 		public DWORD SizeOfHeaders;
 		public DWORD CheckSum;
 		public WORD Subsystem;
 		public WORD DllCharacteristics;
 		public ULONGLONG SizeOfStackReserve;
 		public ULONGLONG SizeOfStackCommit;
 		public ULONGLONG SizeOfHeapReserve;
 		public ULONGLONG SizeOfHeapCommit;
 		public DWORD LoaderFlags;
 		public DWORD NumberOfRvaAndSizes;
 		public IMAGE_DATA_DIRECTORY[] DataDirectory;
 
 		internal void Read(BinaryReader br)
 		{
 			Magic = br.ReadUInt16();
 			if (Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC && Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)
 			{
 				throw new BadImageFormatException();
 			}
 			MajorLinkerVersion = br.ReadByte();
 			MinorLinkerVersion = br.ReadByte();
 			SizeOfCode = br.ReadUInt32();
 			SizeOfInitializedData = br.ReadUInt32();
 			SizeOfUninitializedData = br.ReadUInt32();
 			AddressOfEntryPoint = br.ReadUInt32();
 			BaseOfCode = br.ReadUInt32();
 			if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
 			{
 				BaseOfData = br.ReadUInt32();
 				ImageBase = br.ReadUInt32();
 			}
 			else
 			{
 				ImageBase = br.ReadUInt64();
 			}
 			SectionAlignment = br.ReadUInt32();
 			FileAlignment = br.ReadUInt32();
 			MajorOperatingSystemVersion = br.ReadUInt16();
 			MinorOperatingSystemVersion = br.ReadUInt16();
 			MajorImageVersion = br.ReadUInt16();
 			MinorImageVersion = br.ReadUInt16();
 			MajorSubsystemVersion = br.ReadUInt16();
 			MinorSubsystemVersion = br.ReadUInt16();
 			Win32VersionValue = br.ReadUInt32();
 			SizeOfImage = br.ReadUInt32();
 			SizeOfHeaders = br.ReadUInt32();
 			CheckSum = br.ReadUInt32();
 			Subsystem = br.ReadUInt16();
 			DllCharacteristics = br.ReadUInt16();
 			if (Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
 			{
 				SizeOfStackReserve = br.ReadUInt32();
 				SizeOfStackCommit = br.ReadUInt32();
 				SizeOfHeapReserve = br.ReadUInt32();
 				SizeOfHeapCommit = br.ReadUInt32();
 			}
 			else
 			{
 				SizeOfStackReserve = br.ReadUInt64();
 				SizeOfStackCommit = br.ReadUInt64();
 				SizeOfHeapReserve = br.ReadUInt64();
 				SizeOfHeapCommit = br.ReadUInt64();
 			}
 			LoaderFlags = br.ReadUInt32();
 			NumberOfRvaAndSizes = br.ReadUInt32();
 			DataDirectory = new IMAGE_DATA_DIRECTORY[NumberOfRvaAndSizes];
 			for (uint i = 0; i < NumberOfRvaAndSizes; i++)
 			{
 				DataDirectory[i] = new IMAGE_DATA_DIRECTORY();
 				DataDirectory[i].Read(br);
 			}
 			for (uint i = 0; i < NumberOfRvaAndSizes; i++)
 			{
 				DataDirectory[i] = new IMAGE_DATA_DIRECTORY();
 				DataDirectory[i].Read(br);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7908" endline="7914">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			MemberAccess target = (MemberAccess) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1035" endline="1041">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			GotoCase target = (GotoCase) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4273" endline="4279">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Unchecked target = (Unchecked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4303" endline="4309">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Checked target = (Checked) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4335" endline="4341">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Unsafe target = (Unsafe) t;
 
 			target.Block = clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="767" endline="773">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Unary target = (Unary) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1214" endline="1220">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			UnaryMutator target = (UnaryMutator) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1698" endline="1711">
<![CDATA[
 
 #if NET_4_0 && !STATIC
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			return SLE.Expression.Default (type.GetMetaInfo ());
 		}
 #endif
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			DefaultValueExpression target = (DefaultValueExpression) t;
 			
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7970" endline="7976">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CheckedExpr target = (CheckedExpr) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8025" endline="8031">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			UnCheckedExpr target = (UnCheckedExpr) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="82" endline="88">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Yield target = (Yield) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1757" endline="1766">
<![CDATA[
 	}
 
 	sealed class MultiArrayType 
 	{
 		private readonly int rank;
 
 		internal static Type Make(Type type, int rank, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new MultiArrayType(type, rank, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="108" endline="114">
<![CDATA[
 		}
 
 		protected override bool DoResolve (BlockContext ec)
 		{
 			iterator = ec.CurrentIterator;
 			return Yield.CheckContext (ec, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="159" endline="166">
<![CDATA[
 
 		// this is used in combination with delay signing
 		public void __SetAssemblyPublicKey(byte[] publicKey)
 		{
 			AssemblyName oldName = GetName();
 			this.publicKey = publicKey == null ? null 
 			universe.RenameAssembly(this, oldName);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1445" endline="1475">
<![CDATA[
 			}
 
 			#endregion
 		}
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.VIRTUAL |
 			Modifiers.SEALED |
 			Modifiers.OVERRIDE |
 			Modifiers.UNSAFE |
 			Modifiers.EXTERN |
 			Modifiers.ABSTRACT;
 
 		const Modifiers AllowedInterfaceModifiers =
 			Modifiers.NEW;
 
 		readonly ParametersCompiled parameters;
 
 		public Indexer (DeclSpace parent, FullNamedExpression type, MemberName name, Modifiers mod,
 				ParametersCompiled parameters, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedInterfaceModifiers 
 				name, attrs)
 		{
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2323" endline="2376">
<![CDATA[
 	}
 
 	public partial class TypeManager
 	{
 		public static Variance CheckTypeVariance (TypeSpec t, Variance expected, IMemberContext member)
 		{
 			var tp = t as TypeParameterSpec;
 			if (tp != null) {
 				Variance v = tp.Variance;
 				if (expected == Variance.None && v != expected ||
 					expected == Variance.Covariant && v == Variance.Contravariant ||
 					expected == Variance.Contravariant && v == Variance.Covariant) {
 					((TypeParameter)tp.MemberDefinition).ErrorInvalidVariance (member, expected);
 				}
 
 				return expected;
 			}
 
 			if (t.TypeArguments.Length > 0) {
 				var targs_definition = t.MemberDefinition.TypeParameters;
 				TypeSpec[] targs = GetTypeArguments (t);
 				for (int i = 0; i < targs.Length; ++i) {
 					Variance v = targs_definition[i].Variance;
 					CheckTypeVariance (targs[i], (Variance) ((int)v * (int)expected), member);
 				}
 
 				return expected;
 			}
 
 			if (t.IsArray)
 				return CheckTypeVariance (GetElementType (t), expected, member);
 
 			return Variance.None;
 		}
 	}
 
 	//
 	// Implements C# type inference
 	//
 	class TypeInference
 	{
 		//
 		// Tracks successful rate of type inference
 		//
 		int score = int.MaxValue;
 		readonly Arguments arguments;
 		readonly int arg_count;
 
 		public TypeInference (Arguments arguments)
 		{
 			this.arguments = arguments;
 			if (arguments != null)
 				arg_count = arguments.Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2264" endline="2270">
<![CDATA[
 
 		public void WrapIntoDestructor (TryFinally tf, ExplicitBlock tryBlock)
 		{
 			tryBlock.statements = statements;
 			statements = new List<Statement> (1);
 			statements.Add (tf);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="877" endline="883">
<![CDATA[
 
 		void Error_ObsoleteSecurityAttribute (Attribute a, string option)
 		{
 			Report.Warning (1699, 1, a.Location,
 				"Use compiler option `{0}' or appropriate project settings instead of `{1}' attribute",
 				option, a.Name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="626" endline="632">
<![CDATA[
 
 		static public Expression Create (ResolveContext ec, MethodGroupExpr mge,
 						 TypeSpec target_type, Location loc)
 		{
 			ImplicitDelegateCreation d = new ImplicitDelegateCreation (target_type, mge, loc);
 			return d.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="340" endline="360">
<![CDATA[
 
 		//
 		// Returns a MemberInfo that is referenced in XML documentation
 		// (by "see" or "seealso" elements).
 		//
 		private static MemberSpec FindDocumentedMember (MemberCore mc,
 			TypeSpec type, string member_name, AParametersCollection param_list, 
 			DeclSpace ds, out int warning_type, string cref,
 			bool warn419, string name_for_error, Report r)
 		{
 //			for (; type != null; type = type.DeclaringType) {
 				var mi = FindDocumentedMemberNoNest (
 					mc, type, member_name, param_list, ds,
 					out warning_type, cref, warn419,
 					name_for_error, r);
 				if (mi != null)
 					return mi; // new FoundMember (type, mi);
 //			}
 			warning_type = 0;
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="113" endline="158">
<![CDATA[
 
 		public static Constant CreateConstantFromValue (TypeSpec t, object v, Location loc)
 		{
 			if (t == TypeManager.int32_type)
 				return new IntConstant ((int) v, loc);
 			if (t == TypeManager.string_type)
 				return new StringConstant ((string) v, loc);
 			if (t == TypeManager.uint32_type)
 				return new UIntConstant ((uint) v, loc);
 			if (t == TypeManager.int64_type)
 				return new LongConstant ((long) v, loc);
 			if (t == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) v, loc);
 			if (t == TypeManager.float_type)
 				return new FloatConstant ((float) v, loc);
 			if (t == TypeManager.double_type)
 				return new DoubleConstant ((double) v, loc);
 			if (t == TypeManager.short_type)
 				return new ShortConstant ((short)v, loc);
 			if (t == TypeManager.ushort_type)
 				return new UShortConstant ((ushort)v, loc);
 			if (t == TypeManager.sbyte_type)
 				return new SByteConstant ((sbyte)v, loc);
 			if (t == TypeManager.byte_type)
 				return new ByteConstant ((byte)v, loc);
 			if (t == TypeManager.char_type)
 				return new CharConstant ((char)v, loc);
 			if (t == TypeManager.bool_type)
 				return new BoolConstant ((bool) v, loc);
 			if (t == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) v, loc);
 			if (TypeManager.IsEnumType (t)) {
 				var real_type = EnumSpec.GetUnderlyingType (t);
 				return new EnumConstant (CreateConstantFromValue (real_type, v, loc).Resolve (null), t);
 			}
 			if (v == null) {
 				if (TypeManager.IsNullableType (t))
 					return Nullable.LiftedNull.Create (t, loc);
 
 				if (TypeManager.IsReferenceType (t))
 					return new NullConstant (t, loc);
 			}
 
 			throw new InternalErrorException ("Constant value `{0}' has unexpected underlying type `{1}'",
 				v, TypeManager.CSharpName (t));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1312" endline="1378">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < Int16.MinValue || Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < Int32.MinValue || Value > Int32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < UInt32.MinValue || Value > UInt32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1543" endline="1553">
<![CDATA[
 	}
 
 	class ImportedMemberDefinition 
 	{
 		readonly TypeSpec type;
 
 		public ImportedMemberDefinition (MemberInfo member, TypeSpec type, MetadataImporter importer)
 			
 		{
 			this.type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1515" endline="1546">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   This is used to perform explicit numeric conversions.
 	///
 	///   Explicit numeric conversions might trigger exceptions in a checked
 	///   context, so they should generate the conv.ovf opcodes instead of
 	///   conv opcodes.
 	/// </summary>
 	public class ConvCast 
 		public enum Mode 
 			I1_U1, I1_U2, I1_U4, I1_U8, I1_CH,
 			U1_I1, U1_CH,
 			I2_I1, I2_U1, I2_U2, I2_U4, I2_U8, I2_CH,
 			U2_I1, U2_U1, U2_I2, U2_CH,
 			I4_I1, I4_U1, I4_I2, I4_U2, I4_U4, I4_U8, I4_CH,
 			U4_I1, U4_U1, U4_I2, U4_U2, U4_I4, U4_CH,
 			I8_I1, I8_U1, I8_I2, I8_U2, I8_I4, I8_U4, I8_U8, I8_CH, I8_I,
 			U8_I1, U8_U1, U8_I2, U8_U2, U8_I4, U8_U4, U8_I8, U8_CH, U8_I,
 			CH_I1, CH_U1, CH_I2,
 			R4_I1, R4_U1, R4_I2, R4_U2, R4_I4, R4_U4, R4_I8, R4_U8, R4_CH,
 			R8_I1, R8_U1, R8_I2, R8_U2, R8_I4, R8_U4, R8_I8, R8_U8, R8_CH, R8_R4,
 			I_I8,
 		}
 
 		Mode mode;
 		
 		public ConvCast (Expression child, TypeSpec return_type, Mode m)
 			
 		{
 			mode = m;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1737" endline="1747">
<![CDATA[
 	}
 	
 	class OpcodeCast 
 	{
 		readonly OpCode op;
 		
 		public OpcodeCast (Expression child, TypeSpec return_type, OpCode op)
 			
 		{
 			this.op = op;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4094" endline="4105">
<![CDATA[
 	}
 
 	public class Lock 
 		Expression expr;
 		TemporaryVariableReference expr_copy;
 		TemporaryVariableReference lock_taken;
 			
 		public Lock (Expression expr, Statement stmt, Location loc)
 			
 		{
 			this.expr = expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4755" endline="4764">
<![CDATA[
 	}
 
 	public class TryFinally 
 		Block fini;
 
 		public TryFinally (Statement stmt, Block fini, Location loc)
 			 
 		{
 			this.fini = fini;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5078" endline="5086">
<![CDATA[
 		}
 
 		VariableDeclaration decl;
 
 		public Using (VariableDeclaration decl, Statement stmt, Location loc)
 			
 		{
 			this.decl = decl;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="706" endline="716">
<![CDATA[
 	}
 
 	class DynamicMemberBinder 
 	{
 		readonly string name;
 
 		public DynamicMemberBinder (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="646" endline="653">
<![CDATA[
 		}
 
 		Options flags;
 
 		public bool HasSet (Options options)
 		{
 			return (this.flags & options) == options;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="928" endline="937">
<![CDATA[
 
 		//
 		// Implementation of expression to expression tree conversion
 		//
 		public abstract Expression CreateExpressionTree (ResolveContext ec);
 
 		protected Expression CreateExpressionFactoryCall (ResolveContext ec, string name, Arguments args)
 		{
 			return CreateExpressionFactoryCall (ec, name, null, args, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="899" endline="906">
<![CDATA[
 		}
 
 		public void AddUsageVector (FlowBranching.UsageVector vector)
 		{
 			vector = vector.Clone ();
 			vector.Next = vectors;
 			vectors = vector;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="630" endline="637">
<![CDATA[
 
 		//
 		// Creates method owned type parameter
 		//
 		public TypeParameterSpec (int index, ITypeDefinition definition, SpecialConstraint spec, Variance variance, MetaType info)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="236" endline="242">
<![CDATA[
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			base_type = TypeManager.enum_type;
 			base_class = base_type_expr;
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="129" endline="136">
<![CDATA[
 
 		private static Type ReadFunctionPointer(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// TODO like .NET we return System.IntPtr here, but ideally we should fire an event in Universe that
 			// the user can hook to provide a custom type (or we simply should build in full support for function pointer types)
 			MethodSignature.ReadStandAloneMethodSig(module, br, context);
 			return module.universe.System_IntPtr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="142" endline="154">
<![CDATA[
 
 			#endregion
 		}
 
 		public AQueryClause next;
 		public QueryBlock block;
 
 		protected AQueryClause (QueryBlock block, Expression expr, Location loc)
 			 
 		{
 			this.block = block;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="141" endline="153">
<![CDATA[
 	}
 
 	public class ConstInitializer 
 	{
 		bool in_transit;
 		readonly FieldBase field;
 
 		public ConstInitializer (FieldBase field, Expression value, Location loc)
 			
 		{
 			this.loc = loc;
 			this.field = field;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2214" endline="2228">
<![CDATA[
 	}
 
 	/// <summary>
 	///   A generic method definition.
 	/// </summary>
 	public class GenericMethod 
 	{
 		ParametersCompiled parameters;
 
 		public GenericMethod (NamespaceEntry ns, DeclSpace parent, MemberName name,
 				      FullNamedExpression return_type, ParametersCompiled parameters)
 			
 		{
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1550" endline="1564">
<![CDATA[
 		}
 	}
 	
 	//
 	// This represents a typecast in the source language.
 	//
 	public class Cast 
 		Expression target_type;
 
 		public Cast (Expression cast_type, Expression expr, Location loc)
 			
 		{
 			this.target_type = cast_type;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1296" endline="1309">
<![CDATA[
 		}
 
 		protected ParametersBlock block;
 
 		public TypeSpec ReturnType;
 
 		object return_label;
 
 		protected AnonymousExpression (ParametersBlock block, TypeSpec return_type, Location loc)
 		{
 			this.ReturnType = return_type;
 			this.block = block;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2076" endline="2082">
<![CDATA[
 
 		protected ATypeNameExpression (string name, TypeArguments targs, Location l)
 		{
 			this.name = name;
 			this.targs = targs;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="86" endline="98">
<![CDATA[
 	}
 	
 	public class CompletionMemberAccess 
 		Expression expr;
 		string partial_name;
 		TypeArguments targs;
 		
 		public CompletionMemberAccess (Expression e, string partial_name, Location l)
 		{
 			this.expr = e;
 			this.loc = l;
 			this.partial_name = partial_name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="611" endline="625">
<![CDATA[
 
 		#endregion
 	}
 
 	//
 	// Created from the conversion code
 	//
 	public class ImplicitDelegateCreation 
 	{
 		ImplicitDelegateCreation (TypeSpec t, MethodGroupExpr mg, Location l)
 		{
 			type = t;
 			this.method_group = mg;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="633" endline="650">
<![CDATA[
 	}
 	
 	//
 	// A delegate-creation-expression, invoked from the `New' class 
 	//
 	public class NewDelegate 
 	{
 		public Arguments Arguments;
 
 		//
 		// This constructor is invoked from the `New' expression
 		//
 		public NewDelegate (TypeSpec type, Arguments Arguments, Location loc)
 		{
 			this.type = type;
 			this.Arguments = Arguments;
 			this.loc  = loc; 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="692" endline="708">
<![CDATA[
 	}
 
 	//
 	// Invocation converted to delegate Invoke call
 	//
 	class DelegateInvocation 
 	{
 		readonly Expression InstanceExpr;
 		Arguments arguments;
 		MethodSpec method;
 		
 		public DelegateInvocation (Expression instance_expr, Arguments args, Location loc)
 		{
 			this.InstanceExpr = instance_expr;
 			this.arguments = args;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\Method.cs" startline="358" endline="371">
<![CDATA[
 	}
 
 	sealed class ParameterInfoImpl 
 	{
 		private readonly MethodDefImpl method;
 		private readonly int position;
 		private readonly int index;
 
 		internal ParameterInfoImpl(MethodDefImpl method, int position, int index)
 		{
 			this.method = method;
 			this.position = position;
 			this.index = index;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="256" endline="267">
<![CDATA[
 	}
 
 	public class Do 
 		public Expression expr;
 		public Statement  EmbeddedStatement;
 
 		public Do (Statement statement, BooleanExpression bool_expr, Location l)
 		{
 			expr = bool_expr;
 			EmbeddedStatement = statement;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="337" endline="349">
<![CDATA[
 	}
 
 	public class While 
 		public Expression expr;
 		public Statement Statement;
 		bool infinite, empty;
 
 		public While (BooleanExpression bool_expr, Statement statement, Location l)
 		{
 			this.expr = bool_expr;
 			Statement = statement;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="851" endline="867">
<![CDATA[
 	}
 
 	public class LabeledStatement 
 		string name;
 		bool defined;
 		bool referenced;
 		Label label;
 		Block block;
 
 		FlowBranching.UsageVector vectors;
 		
 		public LabeledStatement (string name, Block block, Location l)
 		{
 			this.name = name;
 			this.block = block;
 			this.loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1445" endline="1486">
<![CDATA[
 	}
 
 	//
 	// The information about a user-perceived local variable
 	//
 	public class LocalVariable 
 	{
 		[Flags]
 		public enum Flags
 		{
 			Used = 1,
 			IsThis = 1 << 1,
 			AddressTaken = 1 << 2,
 			CompilerGenerated = 1 << 3,
 			Constant = 1 << 4,
 			ForeachVariable = 1 << 5,
 			FixedVariable = 1 << 6,
 			UsingVariable = 1 << 7,
 //			DefinitelyAssigned = 1 << 8,
 			IsLocked = 1 << 9,
 
 			ReadonlyMask = ForeachVariable | FixedVariable | UsingVariable
 		}
 
 		TypeSpec type;
 		readonly string name;
 		readonly Location loc;
 		readonly Block block;
 		Flags flags;
 		Constant const_value;
 
 		public VariableInfo VariableInfo;
 		HoistedVariable hoisted_variant;
 
 		LocalBuilder builder;
 
 		public LocalVariable (Block block, string name, Location loc)
 		{
 			this.block = block;
 			this.name = name;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4549" endline="4561">
<![CDATA[
 		}
 
 
 		VariableDeclaration decl;
 		Statement statement;
 		bool has_ret;
 
 		public Fixed (VariableDeclaration decl, Statement stmt, Location l)
 		{
 			this.decl = decl;
 			statement = stmt;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1019" endline="1031">
<![CDATA[
 	}
 
 	public class NullCoalescingOperator 
 	{
 		Expression left, right;
 		Unwrap unwrap;
 
 		public NullCoalescingOperator (Expression left, Expression right, Location loc)
 		{
 			this.left = left;
 			this.right = right;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="1207" endline="1221">
<![CDATA[
 	}
 
 	public class LiftedUnaryMutator 
 	{
 		public readonly UnaryMutator.Mode Mode;
 		Expression expr;
 		UnaryMutator underlying;
 		Unwrap unwrap;
 
 		public LiftedUnaryMutator (UnaryMutator.Mode mode, Expression expr, Location loc)
 		{
 			this.expr = expr;
 			this.Mode = mode;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="61" endline="80">
<![CDATA[
 		}
 	}
 
 	//
 	// A set of parsed constraints for a type parameter
 	//
 	public class Constraints
 	{
 		SimpleMemberName tparam;
 		List<FullNamedExpression> constraints;
 		Location loc;
 		bool resolved;
 		bool resolving;
 		
 		public Constraints (SimpleMemberName tparam, List<FullNamedExpression> constraints, Location loc)
 		{
 			this.tparam = tparam;
 			this.constraints = constraints;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1814" endline="1836">
<![CDATA[
 		}
 	}
 
 	//
 	// A type expression of generic type with type arguments
 	//
 	class GenericTypeExpr 
 	{
 		TypeArguments args;
 		TypeSpec open_type;
 		bool constraints_checked;
 
 		/// <summary>
 		///   Instantiate the generic type `t' with the type arguments `args'.
 		///   Use this constructor if you already know the fully resolved
 		///   generic type.
 		/// </summary>		
 		public GenericTypeExpr (TypeSpec open_type, TypeArguments args, Location l)
 		{
 			this.open_type = open_type;
 			loc = l;
 			this.args = args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="968" endline="998">
<![CDATA[
 		}
 
 		[Flags]
 		public enum Mode 
 			IsIncrement    = 0,
 			IsDecrement    = 1,
 			IsPre          = 0,
 			IsPost         = 2,
 			
 			PreIncrement   = 0,
 			PreDecrement   = IsDecrement,
 			PostIncrement  = IsPost,
 			PostDecrement  = IsPost | IsDecrement
 		}
 
 		Mode mode;
 		bool is_expr, recurse;
 
 		Expression expr;
 
 		// Holds the real operation
 		Expression operation;
 
 		static TypeSpec[] predefined;
 
 		public UnaryMutator (Mode m, Expression e, Location loc)
 		{
 			mode = m;
 			this.loc = loc;
 			expr = e;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1221" endline="1241">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Base class for the `Is' and `As' classes. 
 	/// </summary>
 	///
 	/// <remarks>
 	///   FIXME
 	///   size. 
 	/// </remarks>
 	public abstract class Probe 
 		public Expression ProbeType;
 		protected Expression expr;
 		protected TypeExpr probe_type_expr;
 		
 		public Probe (Expression expr, Expression probe_type, Location l)
 		{
 			ProbeType = probe_type;
 			loc = l;
 			this.expr = expr;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4853" endline="5519">
<![CDATA[
 	}
 
 	/// <summary>
 	///   This represents a reference to a parameter in the intermediate
 	///   representation.
 	/// </summary>
 	public class ParameterReference 
 	{
 		protected ParametersBlock.ParameterInfo pi;
 
 		public ParameterReference (ParametersBlock.ParameterInfo pi, Location loc)
 		{
 			this.pi = pi;
 			this.loc = loc;
 		}
 
 		#region Properties
 
 		public override bool IsLockedByStatement {
 			get {
 				return pi.IsLocked;
 			}
 			set	{
 				pi.IsLocked = value;
 			}
 		}
 
 		public override bool IsRef {
 			get { return (pi.Parameter.ModFlags & Parameter.Modifier.ISBYREF) != 0; }
 		}
 
 		bool HasOutModifier {
 			get { return pi.Parameter.ModFlags == Parameter.Modifier.OUT; }
 		}
 
 		public override HoistedVariable GetHoistedVariable (AnonymousExpression ae)
 		{
 			return pi.Parameter.HoistedVariant;
 		}
 
 		//
 		// A ref or out parameter is classified as a moveable variable, even 
 		// if the argument given for the parameter is a fixed variable
 		//		
 		public override bool IsFixed {
 			get { return !IsRef; }
 		}
 
 		public override string Name {
 			get { return Parameter.Name; }
 		}
 
 		public Parameter Parameter {
 			get { return pi.Parameter; }
 		}
 
 		public override VariableInfo VariableInfo {
 			get { return pi.VariableInfo; }
 		}
 
 		protected override ILocalVariable Variable {
 			get { return Parameter; }
 		}
 
 		#endregion
 
 		public bool IsAssigned (ResolveContext ec, Location loc)
 		{
 			// HACK
 			if (ec.IsInProbingMode)
 				return true;
 			
 			if (!ec.DoFlowAnalysis || !HasOutModifier || ec.CurrentBranching.IsAssigned (VariableInfo))
 				return true;
 
 			ec.Report.Error (269, loc, "Use of unassigned out parameter `{0}'", Name);
 			return false;
 		}
 
 		public override void SetHasAddressTaken ()
 		{
 			Parameter.HasAddressTaken = true;
 		}
 
 		void SetAssigned (ResolveContext ec)
 		{
 			if (HasOutModifier && ec.DoFlowAnalysis)
 				ec.CurrentBranching.SetAssigned (VariableInfo);
 		}
 
 		bool DoResolveBase (ResolveContext ec)
 		{
 			type = pi.ParameterType;
 			eclass = ExprClass.Variable;
 
 			//
 			// If we are referencing a parameter from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (pi)) {
 				if (Parameter.HasAddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (IsRef) {
 					ec.Report.Error (1628, loc,
 						"Parameter `{0}' cannot be used inside `{1}' when using `ref' or `out' modifier",
 						Name, ec.CurrentAnonymousMethod.ContainerType);
 				}
 
 				if (ec.IsVariableCapturingRequired && !pi.Block.ParametersBlock.IsExpressionTree) {
 					AnonymousMethodStorey storey = pi.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureParameter (ec, this);
 				}
 			}
 
 			return true;
 		}
 
 		public override int GetHashCode ()
 		{
 			return Name.GetHashCode ();
 		}
 
 		public override bool Equals (object obj)
 		{
 			ParameterReference pr = obj as ParameterReference;
 			if (pr == null)
 				return false;
 
 			return Name == pr.Name;
 		}
 
 		public override void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			//
 			// ParameterReferences might already be a reference
 			//
 			if (IsRef) {
 				EmitLoad (ec);
 				return;
 			}
 
 			base.AddressOf (ec, mode);
 		}
 		
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			// Nothing to clone
 			return;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			return Parameter.ExpressionTreeVariableReference ();
 		}
 
 		//
 		// Notice that for ref/out parameters, the type exposed is not the
 		// same type exposed externally.
 		//
 		// for "ref int a"
 		//   externally we expose "int&"
 		//   here we expose       "int".
 		//
 		// We record this in "is_ref".  This means that the type system can treat
 		// the type as it is expected, but when we generate the code, we generate
 		// the alternate kind of code.
 		//
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			// HACK
 			if (ec.IsInProbingMode)
 				return this;
 
 			if (HasOutModifier && ec.DoFlowAnalysis &&
 			    (!ec.OmitStructFlowAnalysis || !VariableInfo.TypeInfo.IsStruct) && !IsAssigned (ec, loc))
 				return null;
 
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			SetAssigned (ec);
 			return base.DoResolveLValue (ec, right_side);
 		}
 
 		static public void EmitLdArg (EmitContext ec, int x)
 		{
 			switch (x) {
 			case 0
 			case 1
 			case 2
 			case 3
 			default
 				if (x > byte.MaxValue)
 					ec.Emit (OpCodes.Ldarg, x);
 				else
 					ec.Emit (OpCodes.Ldarg_S, (byte) x);
 				break;
 			}
 		}
 	}
 	
 	/// <summary>
 	///   Invocation of methods or delegates.
 	/// </summary>
 	public class Invocation 
 	{
 		protected Arguments arguments;
 		protected Expression expr;
 		protected MethodGroupExpr mg;
 		
 		public Invocation (Expression expr, Arguments arguments)
 		{
 			this.expr = expr;		
 			this.arguments = arguments;
 			if (expr != null)
 				loc = expr.Location;
 		}
 
 		#region Properties
 		public Arguments Arguments {
 			get {
 				return arguments;
 			}
 		}
 		
 		public Expression Expression {
 			get {
 				return expr;
 			}
 		}
 		#endregion
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Invocation target = (Invocation) t;
 
 			if (arguments != null)
 				target.arguments = arguments.Clone (clonectx);
 
 			target.expr = expr.Clone (clonectx);
 		}
 
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			Expression instance = mg.IsInstance ?
 				mg.InstanceExpression.CreateExpressionTree (ec) 
 				new NullLiteral (loc);
 
 			var args = Arguments.CreateForExpressionTree (ec, arguments,
 				instance,
 				mg.CreateExpressionTree (ec));
 
 			return CreateExpressionFactoryCall (ec, "Call", args);
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			Expression member_expr;
 			var atn = expr as ATypeNameExpression;
 			if (atn != null) {
 				member_expr = atn.LookupNameExpression (ec, MemberLookupRestrictions.InvocableOnly | MemberLookupRestrictions.ReadAccess);
 				if (member_expr != null)
 					member_expr = member_expr.Resolve (ec);
 			} else {
 				member_expr = expr.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.MethodGroup);
 			}
 
 			if (member_expr == null)
 				return null;
 
 			//
 			// Next, evaluate all the expressions in the argument list
 			//
 			bool dynamic_arg = false;
 			if (arguments != null)
 				arguments.Resolve (ec, out dynamic_arg);
 
 			TypeSpec expr_type = member_expr.Type;
 			if (expr_type == InternalType.Dynamic)
 				return DoResolveDynamic (ec, member_expr);
 
 			mg = member_expr as MethodGroupExpr;
 			Expression invoke = null;
 
 			if (mg == null) {
 				if (expr_type != null && TypeManager.IsDelegateType (expr_type)) {
 					invoke = new DelegateInvocation (member_expr, arguments, loc);
 					invoke = invoke.Resolve (ec);
 					if (invoke == null || !dynamic_arg)
 						return invoke;
 				} else {
 					if (member_expr is RuntimeValueExpression) {
 						ec.Report.Error (Report.RuntimeErrorId, loc, "Cannot invoke a non-delegate type `{0}'",
 							member_expr.Type.GetSignatureForError ()); ;
 						return null;
 					}
 
 					MemberExpr me = member_expr as MemberExpr;
 					if (me == null) {
 						member_expr.Error_UnexpectedKind (ec, ResolveFlags.MethodGroup, loc);
 						return null;
 					}
 
 					ec.Report.Error (1955, loc, "The member `{0}' cannot be used as method or delegate",
 							member_expr.GetSignatureForError ());
 					return null;
 				}
 			}
 
 			if (invoke == null) {
 				mg = DoResolveOverload (ec);
 				if (mg == null)
 					return null;
 			}
 
 			if (dynamic_arg)
 				return DoResolveDynamic (ec, member_expr);
 
 			var method = mg.BestCandidate;
 			type = mg.BestCandidateReturnType;
 		
 			if (arguments == null && method.DeclaringType == TypeManager.object_type && method.Name == Destructor.MetadataName) {
 				if (mg.IsBase)
 					ec.Report.Error (250, loc, "Do not directly call your base class Finalize method. It is called automatically from your destructor");
 				else
 					ec.Report.Error (245, loc, "Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available");
 				return null;
 			}
 
 			IsSpecialMethodInvocation (ec, method, loc);
 			
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		protected virtual Expression DoResolveDynamic (ResolveContext ec, Expression memberExpr)
 		{
 			Arguments args;
 			DynamicMemberBinder dmb = memberExpr as DynamicMemberBinder;
 			if (dmb != null) {
 				args = dmb.Arguments;
 				if (arguments != null)
 					args.AddRange (arguments);
 			} else if (mg == null) {
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				args.Insert (0, new Argument (memberExpr));
 				this.expr = null;
 			} else {
 				if (mg.IsBase) {
 					ec.Report.Error (1971, loc,
 						"The base call to method `{0}' cannot be dynamically dispatched. Consider casting the dynamic arguments or eliminating the base access",
 						mg.Name);
 					return null;
 				}
 
 				if (arguments == null)
 					args = new Arguments (1);
 				else
 					args = arguments;
 
 				MemberAccess ma = expr as MemberAccess;
 				if (ma != null) {
 					var left_type = ma.LeftExpression as TypeExpr;
 					if (left_type != null) {
 						args.Insert (0, new Argument (new TypeOf (left_type, loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						//
 						// Any value type has to be pass as by-ref to get back the same
 						// instance on which the member was called
 						//
 						var mod = TypeManager.IsValueType (ma.LeftExpression.Type) ? Argument.AType.Ref 
 						args.Insert (0, new Argument (ma.LeftExpression.Resolve (ec), mod));
 					}
 				} else {	// is SimpleName
 					if (ec.IsStatic) {
 						args.Insert (0, new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc).Resolve (ec), Argument.AType.DynamicTypeName));
 					} else {
 						args.Insert (0, new Argument (new This (loc).Resolve (ec)));
 					}
 				}
 			}
 
 			return new DynamicInvocation (expr as ATypeNameExpression, args, loc).Resolve (ec);
 		}
 
 		protected virtual MethodGroupExpr DoResolveOverload (ResolveContext ec)
 		{
 			return mg.OverloadResolve (ec, ref arguments, null, OverloadResolver.Restrictions.None);
 		}
 
 		static MetaType[] GetVarargsTypes (MethodSpec mb, Arguments arguments)
 		{
 			AParametersCollection pd = mb.Parameters;
 
 			Argument a = arguments[pd.Count - 1];
 			Arglist list = (Arglist) a.Expr;
 
 			return list.ArgumentTypes;
 		}
 
 		//
 		// If a member is a method or event, or if it is a constant, field or property of either a delegate type
 		// or the type dynamic, then the member is invocable
 		//
 		public static bool IsMemberInvocable (MemberSpec member)
 		{
 			switch (member.Kind) {
 			case MemberKind.Event
 				return true;
 			case MemberKind.Field
 			case MemberKind.Property
 				var m = member as IInterfaceMemberSpec;
 				return m.MemberType.IsDelegate || m.MemberType == InternalType.Dynamic;
 			default
 				return false;
 			}
 		}
 
 		public static bool IsSpecialMethodInvocation (ResolveContext ec, MethodSpec method, Location loc)
 		{
 			if (!method.IsReservedMethod)
 				return false;
 
 			if (ec.HasSet (ResolveContext.Options.InvokeSpecialName) || ec.CurrentMemberDefinition.IsCompilerGenerated)
 				return false;
 
 			ec.Report.SymbolRelatedToPreviousError (method);
 			ec.Report.Error (571, loc, "`{0}'
 				method.GetSignatureForError ());
 	
 			return true;
 		}
 
 		//
 		// Used to decide whether call or callvirt is needed
 		//
 		static bool IsVirtualCallRequired (Expression instance, MethodSpec method)
 		{
 			//
 			// There are 2 scenarious where we emit callvirt
 			//
 			// Case 1
 			// Case 2
 			// correct NRE exception when the method is called
 			//
 			var decl_type = method.DeclaringType;
 			if (decl_type.IsStruct || decl_type.IsEnum)
 				return false;
 
 			if (instance is BaseThis)
 				return false;
 
 			//
 			// It's non-virtual and will never be null
 			//
 			if (!method.IsVirtual && (instance is This || instance is New || instance is ArrayCreation || instance is DelegateCreation))
 				return false;
 
 			return true;
 		}
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
 		
 		// `dup_args' leaves an extra copy of the arguments on the stack
 		// `omit_args' does not leave any arguments at all.
 		// So, basically, you could make one call with `dup_args' set to true,
 		// and then another with `omit_args' set to true, and the two calls
 		// would have the same set of arguments. However, each argument would
 		// only have been evaluated once.
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc,
 		                             bool dup_args, bool omit_args)
 		{
 			LocalTemporary this_arg = null;
 
 			// Speed up the check by not doing it on not allowed targets
 			if (method.ReturnType == TypeManager.void_type && method.IsConditionallyExcluded (loc))
 				return;
 
 			OpCode call_op;
 			TypeSpec iexpr_type;
 
 			if (method.IsStatic) {
 				iexpr_type = null;
 				call_op = OpCodes.Call;
 			} else {
 				iexpr_type = instance_expr.Type;
 
 				if (IsVirtualCallRequired (instance_expr, method)) {
 					call_op = OpCodes.Callvirt;
 				} else {
 					call_op = OpCodes.Call;
 				}
 
 				//
 				// If this is ourselves, push "this"
 				//
 				if (!omit_args) {
 					TypeSpec t = iexpr_type;
 
 					//
 					// Push the instance expression
 					//
 					if ((iexpr_type.IsStruct && (call_op == OpCodes.Callvirt || (call_op == OpCodes.Call && method.DeclaringType == iexpr_type))) ||
 						iexpr_type.IsGenericParameter || TypeManager.IsNullableType (method.DeclaringType)) {
 						//
 						// If the expression implements IMemoryLocation, then
 						// we can optimize and use AddressOf on the
 						// return.
 						//
 						// If not we have to use some temporary storage for
 						// it.
 						var iml = instance_expr as IMemoryLocation;
 						if (iml != null) {
 							iml.AddressOf (ec, AddressOp.LoadStore);
 						} else {
 							LocalTemporary temp = new LocalTemporary (iexpr_type);
 							instance_expr.Emit (ec);
 							temp.Store (ec);
 							temp.AddressOf (ec, AddressOp.Load);
 						}
 
 						// avoid the overhead of doing this all the time.
 						if (dup_args)
 							t = ReferenceContainer.MakeType (iexpr_type);
 					} else if (iexpr_type.IsEnum || iexpr_type.IsStruct) {
 						instance_expr.Emit (ec);
 						ec.Emit (OpCodes.Box, iexpr_type);
 						t = iexpr_type = TypeManager.object_type;
 					} else {
 						instance_expr.Emit (ec);
 					}
 
 					if (dup_args) {
 						ec.Emit (OpCodes.Dup);
 						if (Arguments != null && Arguments.Count != 0) {
 							this_arg = new LocalTemporary (t);
 							this_arg.Store (ec);
 						}
 					}
 				}
 			}
 
 			if (!omit_args && Arguments != null) {
 				var dup_arg_exprs = Arguments.Emit (ec, dup_args);
 				if (dup_args) {
 					this_arg.Emit (ec);
 					LocalTemporary lt;
 					foreach (var dup in dup_arg_exprs) {
 						dup.Emit (ec);
 						lt = dup as LocalTemporary;
 						if (lt != null)
 							lt.Release (ec);
 					}
 				}
 			}
 
 			if (call_op == OpCodes.Callvirt && (iexpr_type.IsGenericParameter || iexpr_type.IsStruct)) {
 				ec.Emit (OpCodes.Constrained, iexpr_type);
 			}
 
 			if (method.Parameters.HasArglist) {
 				var varargs_types = GetVarargsTypes (method, Arguments);
 				ec.Emit (call_op, method, varargs_types);
 				return;
 			}
 
 			//
 			// If you have
 			// this.DoFoo ();
 			// and DoFoo is not virtual, you can omit the callvirt,
 			// because you don't need the null checking behavior.
 			//
 			ec.Emit (call_op, method);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			mg.EmitCall (ec, arguments);
 		}
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			return MakeExpression (ctx, mg.InstanceExpression, mg.BestCandidate, arguments);
 		}
 
 		public static SLE.Expression MakeExpression (BuilderContext ctx, Expression instance, MethodSpec mi, Arguments args)
 		{
 #if STATIC
 			throw new NotSupportedException ();
 #else
 			var instance_expr = instance == null ? null 
 			return SLE.Expression.Call (instance_expr, (MethodInfo) mi.GetMetaInfo (), Arguments.MakeExpression (args, ctx));
 #endif
 		}
 	}
 
 	//
 	// Implements simple new expression 
 	//
 	public class New 
 	{
 		protected Arguments arguments;
 
 		//
 		// During bootstrap, it contains the RequestedType,
 		// but if `type' is not null, it *might* contain a NewDelegate
 		// (because of field multi-initialization)
 		//
 		protected Expression RequestedType;
 
 		protected MethodSpec method;
 
 		public New (Expression requested_type, Arguments arguments, Location l)
 		{
 			RequestedType = requested_type;
 			this.arguments = arguments;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8032" endline="8049">
<![CDATA[
 	}
 
 	/// <summary>
 	///   An Element Access expression.
 	///
 	///   During semantic analysis these are transformed into 
 	///   IndexerAccess, ArrayAccess or a PointerArithmetic.
 	/// </summary>
 	public class ElementAccess 
 		public Arguments Arguments;
 		public Expression Expr;
 
 		public ElementAccess (Expression e, Arguments args, Location loc)
 		{
 			Expr = e;
 			this.loc = loc;
 			this.Arguments = args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9058" endline="9073">
<![CDATA[
 	}
 
 	//
 	// Implements the `stackalloc' keyword
 	//
 	public class StackAlloc 
 		TypeSpec otype;
 		Expression t;
 		Expression count;
 		
 		public StackAlloc (Expression type, Expression count, Location l)
 		{
 			t = type;
 			this.count = count;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="109" endline="119">
<![CDATA[
 		}
 
 		// <summary>
 		//   Starts a new code branching.  This inherits the state of all local
 		//   variables and parameters from the current branching.
 		// </summary>
 		public FlowBranching StartFlowBranching (FlowBranching.BranchingType type, Location loc)
 		{
 			current_flow_branching = FlowBranching.CreateBranching (CurrentBranching, type, null, loc);
 			return current_flow_branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="240" endline="256">
<![CDATA[
 		}
 
 		readonly Arguments arguments;
 		protected IDynamicBinder binder;
 		protected Expression binder_expr;
 
 		// Used by BinderFlags
 		protected CSharpBinderFlags flags;
 
 		TypeSpec binder_type;
 
 		public DynamicExpressionStatement (IDynamicBinder binder, Arguments args, Location loc)
 		{
 			this.binder = binder;
 			this.arguments = args;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="537" endline="546">
<![CDATA[
 	}
 
 	class DynamicConstructorBinder 
 	{
 		public DynamicConstructorBinder (TypeSpec type, Arguments args, Location loc)
 			
 		{
 			this.type = type;
 			base.binder = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="624" endline="635">
<![CDATA[
 	}
 
 	class DynamicInvocation 
 	{
 		ATypeNameExpression member;
 
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 			this.member = member;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="736" endline="828">
<![CDATA[
 	}
 
 	//
 	// Any member binder which can be source and target of assignment
 	//
 	abstract class DynamicMemberAssignable 
 	{
 		Expression setter;
 		Arguments setter_args;
 
 		protected DynamicMemberAssignable (Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 		}
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			//
 			// DoResolve always uses getter
 			//
 			return CreateCallSiteBinder (ec, args, false);
 		}
 
 		protected abstract Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet);
 
 		protected virtual Arguments CreateSetterArguments (ResolveContext rc, Expression rhs)
 		{
 			var setter_args = new Arguments (Arguments.Count + 1);
 			setter_args.AddRange (Arguments);
 			setter_args.Add (new Argument (rhs));
 			return setter_args;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			if (right_side == EmptyExpression.OutAccess.Instance) {
 				right_side.DoResolveLValue (rc, this);
 				return null;
 			}
 
 			if (DoResolveCore (rc)) {
 				setter_args = CreateSetterArguments (rc, right_side);
 				setter = CreateCallSiteBinder (rc, setter_args, true);
 			}
 
 			eclass = ExprClass.Variable;
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			// It's null for ResolveLValue used without assignment
 			if (binder_expr == null)
 				EmitCall (ec, setter, Arguments, false);
 			else
 				base.Emit (ec);
 		}
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			// It's null for ResolveLValue used without assignment
 			if (binder_expr == null)
 				EmitCall (ec, setter, Arguments, true);
 			else
 				base.EmitStatement (ec);
 		}
 
 		#region IAssignMethod Members
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			throw new NotImplementedException ();
 		}
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load)
 		{
 			EmitCall (ec, setter, setter_args, !leave_copy);
 		}
 
 		#endregion
 	}
 
 	class DynamicUnaryConversion 
 	{
 		readonly string name;
 
 		public DynamicUnaryConversion (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 			base.binder = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="922" endline="928">
<![CDATA[
 
 		public ParametersImported (IParameterData[] param, TypeSpec[] types, bool hasParams)
 		{
 			this.parameters = param;
 			this.types = types;
 			this.has_params = hasParams;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="73" endline="89">
<![CDATA[
 	}
 
 	public sealed class LocalBuilder
 	{
 		private readonly Type localType;
 		private readonly int index;
 		private readonly bool pinned;
 		internal string name;
 		internal int startOffset;
 		internal int endOffset;
 
 		internal LocalBuilder(Type localType, int index, bool pinned)
 		{
 			this.localType = localType;
 			this.index = index;
 			this.pinned = pinned;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="44" endline="50">
<![CDATA[
 
 		private FieldSignature(Type fieldType, Type[] optionalCustomModifiers, Type[] requiredCustomModifiers)
 		{
 			this.fieldType = fieldType;
 			this.optionalCustomModifiers = optionalCustomModifiers;
 			this.requiredCustomModifiers = requiredCustomModifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1614" endline="1626">
<![CDATA[
 	}
 
 	public class ImplicitCast 
 	{
 		bool arrayAccess;
 
 		public ImplicitCast (Expression expr, TypeSpec target, bool arrayAccess)
 			
 		{
 			this.loc = expr.Location;
 			this.type = target;
 			this.arrayAccess = arrayAccess;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ResourceModule.cs" startline="35" endline="41">
<![CDATA[
 		internal ResourceModule(Assembly assembly, string scopeName, string location)
 			
 		{
 			this.assembly = assembly;
 			this.scopeName = scopeName;
 			this.location = location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2646" endline="2658">
<![CDATA[
 
 		//
 		// Recreates a top level block from parameters block. Used for
 		// compiler generated methods where the original block comes from
 		// explicit child block. This works for already resolved blocks
 		// only to ensure we resolve them in the correct flow order
 		//
 		public ToplevelBlock (ParametersBlock source, ParametersCompiled parameters)
 			
 		{
 			this.compiler = source.TopBlock.compiler;
 			top_block = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="373" endline="389">
<![CDATA[
 	}
 
 	//
 	// Generic lifting expression, supports all S/S? -> T/T? cases
 	//
 	public class Lifted 
 	{
 		Expression expr, null_value;
 		Unwrap unwrap;
 
 		public Lifted (Expression expr, Unwrap unwrap, TypeSpec type)
 		{
 			this.expr = expr;
 			this.unwrap = unwrap;
 			this.loc = expr.Location;
 			this.type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8741" endline="8780">
<![CDATA[
 
 		private EmptyExpressionStatement ()
 		{
 			loc = Location.Null;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			return null;
 		}
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			// Do nothing
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			eclass = ExprClass.Value;
 			type = TypeManager.object_type;
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			// Do nothing
 		}
 	}	
 
 	public class UserCast 
 		MethodSpec method;
 		Expression source;
 		
 		public UserCast (MethodSpec method, Expression source, Location l)
 		{
 			this.method = method;
 			this.source = source;
 			type = method.ReturnType;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="349" endline="519">
<![CDATA[
 
 		TypeBuilder fixed_buffer_type;
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.UNSAFE;
 
 		public FixedField (DeclSpace parent, FullNamedExpression type, Modifiers mod, MemberName name, Attributes attrs)
 			
 		{
 		}
 
 		#region Properties
 
 		//
 		// Explicit struct layout set by parent
 		//
 		public CharSet? CharSet {
 			get; set;
 		}		
 
 		#endregion
 
 		public override Constant ConvertInitializer (ResolveContext rc, Constant expr)
 		{
 			return expr.ImplicitConversionRequired (rc, TypeManager.int32_type, Location);
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!TypeManager.IsPrimitiveType (MemberType)) {
 				Report.Error (1663, Location,
 					"`{0}'
 					GetSignatureForError ());
 			} else if (declarators != null) {
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Fields.IndexOf (this);
 				foreach (var d in declarators) {
 					var f = new FixedField (Parent, t, ModFlags, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 					f.initializer = d.Initializer;
 					((ConstInitializer) f.initializer).Name = d.Name.Value;
 					Parent.PartialContainer.Fields.Insert (++index, f);
 				}
 			}
 			
 			// Create nested fixed buffer container
 			string name = String.Format ("<{0}>__FixedBuffer{1}", Name, GlobalCounter++);
 			fixed_buffer_type = Parent.TypeBuilder.DefineNestedType (name, Parent.Module.DefaultCharSetType |
 				TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit, TypeManager.value_type.GetMetaInfo ());
 
 			fixed_buffer_type.DefineField (FixedElementName, MemberType.GetMetaInfo (), FieldAttributes.Public);
 			
 			FieldBuilder = Parent.TypeBuilder.DefineField (Name, fixed_buffer_type, ModifiersExtensions.FieldAttr (ModFlags));
 			var element_spec = new FieldSpec (null, this, MemberType, FieldBuilder, ModFlags);
 			spec = new FixedFieldSpec (Parent.Definition, this, FieldBuilder, element_spec, ModFlags);
 
 			Parent.MemberCache.AddMember (spec);
 			return true;
 		}
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			if (!IsUnsafe)
 				Expression.UnsafeError (Report, Location);
 
 			if (Parent.PartialContainer.Kind != MemberKind.Struct) {
 				Report.Error (1642, Location, "`{0}'
 					GetSignatureForError ());
 			}
 		}
 
 		public override void Emit()
 		{
 			ResolveContext rc = new ResolveContext (this);
 			IntConstant buffer_size_const = initializer.Resolve (rc) as IntConstant;
 			if (buffer_size_const == null)
 				return;
 
 			int buffer_size = buffer_size_const.Value;
 
 			if (buffer_size <= 0) {
 				Report.Error (1665, Location, "`{0}'
 				return;
 			}
 
 			int type_size = Expression.GetTypeSize (MemberType);
 
 			if (buffer_size > int.MaxValue / type_size) {
 				Report.Error (1664, Location, "Fixed size buffer `{0}' of length `{1}' and type `{2}' exceeded 2^31 limit",
 					GetSignatureForError (), buffer_size.ToString (), TypeManager.CSharpName (MemberType));
 				return;
 			}
 
 			EmitFieldSize (buffer_size);
 
 			Module.PredefinedAttributes.UnsafeValueType.EmitAttribute (fixed_buffer_type);
 			Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (fixed_buffer_type);
 			fixed_buffer_type.CreateType ();
 
 			base.Emit ();
 		}
 
 		void EmitFieldSize (int buffer_size)
 		{
 			PredefinedAttribute pa;
 			AttributeEncoder encoder;
 
 			pa = Module.PredefinedAttributes.StructLayout;
 			if (pa.Constructor == null && !pa.ResolveConstructor (Location, TypeManager.short_type))
 				return;
 
 			var char_set_type = Module.PredefinedTypes.CharSet.Resolve (Location);
 			if (char_set_type == null)
 				return;
 
 			var field_size = pa.GetField ("Size", TypeManager.int32_type, Location);
 			var field_charset = pa.GetField ("CharSet", char_set_type, Location);
 			if (field_size == null || field_charset == null)
 				return;
 
 			var char_set = CharSet ?? Module.DefaultCharSet;
 
 			encoder = new AttributeEncoder ();
 			encoder.Encode ((short)LayoutKind.Sequential);
 			encoder.EncodeNamedArguments (
 				new [] { field_size, field_charset },
 				new Constant [] { new IntConstant (buffer_size, Location), new IntConstant ((int) char_set, Location) }
 			);
 
 			pa.EmitAttribute (fixed_buffer_type, encoder);
 
 			//
 			// Don't emit FixedBufferAttribute attribute for private types
 			//
 			if ((ModFlags & Modifiers.PRIVATE) != 0)
 				return;
 
 			pa = Module.PredefinedAttributes.FixedBuffer;
 			if (pa.Constructor == null && !pa.ResolveConstructor (Location, TypeManager.type_type, TypeManager.int32_type))
 				return;
 
 			encoder = new AttributeEncoder ();
 			encoder.EncodeTypeName (MemberType);
 			encoder.Encode (buffer_size);
 			encoder.EncodeEmptyNamedArguments ();
 
 			pa.EmitAttribute (FieldBuilder, encoder);
 		}
 	}
 
 	class FixedFieldSpec 
 	{
 		readonly FieldSpec element;
 
 		public FixedFieldSpec (TypeSpec declaringType, IMemberDefinition definition, FieldInfo info, FieldSpec element, Modifiers modifiers)
 			
 		{
 			this.element = element;
 
 			// It's never CLS-Compliant
 			state &= ~StateFlags.CLSCompliant_Undetected;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\EventBuilder.cs" startline="44" endline="50">
<![CDATA[
 		internal EventBuilder(TypeBuilder typeBuilder, string name, EventAttributes attributes, Type eventtype)
 		{
 			this.typeBuilder = typeBuilder;
 			this.name = name;
 			this.attributes = attributes;
 			this.eventtype = typeBuilder.ModuleBuilder.GetTypeTokenForMemberRef(eventtype);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2878" endline="3005">
<![CDATA[
 
 		public abstract void SetTypeArguments (ResolveContext ec, TypeArguments ta);
 	}
 
 	// 
 	// Represents a group of extension method candidates for whole namespace
 	// 
 	class ExtensionMethodGroupExpr 
 	{
 		NamespaceEntry namespace_entry;
 		public readonly Expression ExtensionExpression;
 
 		public ExtensionMethodGroupExpr (IList<MethodSpec> list, NamespaceEntry n, Expression extensionExpr, Location l)
 			
 		{
 			this.namespace_entry = n;
 			this.ExtensionExpression = extensionExpr;
 		}
 
 		public override bool IsStatic {
 			get { return true; }
 		}
 
 		public override IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			if (namespace_entry == null)
 				return null;
 
 			//
 			// For extension methodgroup we are not looking for base members but parent
 			// namespace extension methods
 			//
 			int arity = type_arguments == null ? 0 
 			var found = namespace_entry.LookupExtensionMethod (DeclaringType, Name, arity, ref namespace_entry);
 			if (found == null)
 				return null;
 
 			return found.Cast<MemberSpec> ().ToList ();
 		}
 
 		public override MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 		{
 			// We are already here
 			return null;
 		}
 
 		public override MethodGroupExpr OverloadResolve (ResolveContext ec, ref Arguments arguments, OverloadResolver.IErrorHandler ehandler, OverloadResolver.Restrictions restr)
 		{
 			if (arguments == null)
 				arguments = new Arguments (1);
 
 			arguments.Insert (0, new Argument (ExtensionExpression, Argument.AType.ExtensionType));
 			var res = base.OverloadResolve (ec, ref arguments, ehandler ?? this, restr);
 
 			// Store resolved argument and restore original arguments
 			if (res == null) {
 				// Clean-up modified arguments for error reporting
 				arguments.RemoveAt (0);
 				return null;
 			}
 
 			var me = ExtensionExpression as MemberExpr;
 			if (me != null)
 				me.ResolveInstanceExpression (ec, null);
 
 			InstanceExpression = null;
 			return this;
 		}
 
 		#region IErrorHandler Members
 
 		bool OverloadResolver.IErrorHandler.AmbiguousCandidates (ResolveContext rc, MemberSpec best, MemberSpec ambiguous)
 		{
 			return false;
 		}
 
 		bool OverloadResolver.IErrorHandler.ArgumentMismatch (ResolveContext rc, MemberSpec best, Argument arg, int index)
 		{
 			rc.Report.SymbolRelatedToPreviousError (best);
 			rc.Report.Error (1928, loc,
 				"Type `{0}' does not contain a member `{1}' and the best extension method overload `{2}' has some invalid arguments",
 				queried_type.GetSignatureForError (), Name, best.GetSignatureForError ());
 
 			if (index == 0) {
 				rc.Report.Error (1929, loc,
 					"Extension method instance type `{0}' cannot be converted to `{1}'",
 					arg.Type.GetSignatureForError (), ((MethodSpec)best).Parameters.ExtensionMethodType.GetSignatureForError ());
 			}
 
 			return true;
 		}
 
 		bool OverloadResolver.IErrorHandler.NoArgumentMatch (ResolveContext rc, MemberSpec best)
 		{
 			return false;
 		}
 
 		bool OverloadResolver.IErrorHandler.TypeInferenceFailed (ResolveContext rc, MemberSpec best)
 		{
 			return false;
 		}
 
 		#endregion
 	}
 
 	/// <summary>
 	///   MethodGroupExpr represents a group of method candidates which
 	///   can be resolved to the best method overload
 	/// </summary>
 	public class MethodGroupExpr 
 	{
 		protected IList<MemberSpec> Methods;
 		MethodSpec best_candidate;
 		TypeSpec best_candidate_return;
 		protected TypeArguments type_arguments;
 
  		SimpleName simple_name;
 		protected TypeSpec queried_type;
 
 		public MethodGroupExpr (IList<MemberSpec> mi, TypeSpec type, Location loc)
 		{
 			Methods = mi;
 			this.loc = loc;
 			this.type = InternalType.MethodGroup;
 
 			eclass = ExprClass.MethodGroup;
 			queried_type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1021" endline="1027">
<![CDATA[
 		protected TypeCast (Expression child, TypeSpec return_type)
 		{
 			eclass = child.eclass;
 			loc = child.Location;
 			type = return_type;
 			this.child = child;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="431" endline="449">
<![CDATA[
 		}
 	}
 
 	public class GroupBy 
 	{
 		Expression element_selector;
 		QueryBlock element_block;
 
 		public GroupBy (QueryBlock block, Expression elementSelector, QueryBlock elementBlock, Expression keySelector, Location loc)
 			
 		{
 			//
 			// Optimizes clauses like `group A by A'
 			//
 			if (!elementSelector.Equals (keySelector)) {
 				this.element_selector = elementSelector;
 				this.element_block = elementBlock;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8362" endline="8381">
<![CDATA[
 	}
 
 	//
 	// Indexer access expression
 	//
 	class IndexerExpr 
 	{
 		LocalTemporary prepared_value;
 		IList<MemberSpec> indexers;
 		Arguments arguments;
 		TypeSpec queried_type;
 		
 		public IndexerExpr (IList<MemberSpec> indexers, TypeSpec queriedType, ElementAccess ea)
 			
 		{
 			this.indexers = indexers;
 			this.queried_type = queriedType;
 			this.InstanceExpression = ea.Expr;
 			this.arguments = ea.Arguments;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="945" endline="2100">
<![CDATA[
 	}
 
 	public class IntConstant 
 		public readonly int Value;
 
 		public IntConstant (int v, Location loc)
 			base (loc)
 		{
 			Value = v;
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			enc.Encode (Value);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.EmitInt (Value);
 		}
 
 		public override string AsString ()
 		{
 			return Value.ToString ();
 		}
 
 		public override object GetValue ()
 		{
 			return Value;
 		}
 
 		public override Constant Increment ()
 		{
 			return new IntConstant (checked(Value + 1), loc);
 		}
 
 		public override bool IsDefaultValue {
 			get {
 				return Value == 0;
 			}
 		}
 		
 		public override bool IsNegative {
 			get {
 				return Value < 0;
 			}
 		}
 		
 		public override bool IsOneInteger {
 			get {
 				return Value == 1;
 			}
 		}		
 
 		public override bool IsZeroInteger {
 			get { return Value == 0; }
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < Int16.MinValue || Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < UInt32.MinValue)
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			if (this.type == type)
 				return this;
 
 			Constant c = TryImplicitIntConversion (type);
 			if (c != null)
 				return c.Resolve (rc);
 
 			return base.ConvertImplicitly (rc, type);
 		}
 
 		/// <summary>
 		///   Attempts to perform an implicit constant conversion of the IntConstant
 		///   into a different data type using casts (See Implicit Constant
 		///   Expression Conversions)
 		/// </summary>
 		Constant TryImplicitIntConversion (TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type) {
 				if (Value >= SByte.MinValue && Value <= SByte.MaxValue)
 					return new SByteConstant ((sbyte) Value, loc);
 			} 
 			else if (target_type == TypeManager.byte_type) {
 				if (Value >= Byte.MinValue && Value <= Byte.MaxValue)
 					return new ByteConstant ((byte) Value, loc);
 			} 
 			else if (target_type == TypeManager.short_type) {
 				if (Value >= Int16.MinValue && Value <= Int16.MaxValue)
 					return new ShortConstant ((short) Value, loc);
 			} 
 			else if (target_type == TypeManager.ushort_type) {
 				if (Value >= UInt16.MinValue && Value <= UInt16.MaxValue)
 					return new UShortConstant ((ushort) Value, loc);
 			} 
 			else if (target_type == TypeManager.uint32_type) {
 				if (Value >= 0)
 					return new UIntConstant ((uint) Value, loc);
 			} 
 			else if (target_type == TypeManager.uint64_type) {
 				//
 				// we can optimize this case
 				// always fits on a uint64.  But we need an opcode
 				// to do it.
 				//
 				if (Value >= 0)
 					return new ULongConstant ((ulong) Value, loc);
 			} 
 			else if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, loc);
 			else if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, loc);
 
 			return null;
 		}
 	}
 
 	public class UIntConstant 
 		public readonly uint Value;
 
 		public UIntConstant (uint v, Location loc)
 			base (loc)
 		{
 			Value = v;
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint32_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			enc.Encode (Value);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.EmitInt (unchecked ((int) Value));
 		}
 
 		public override string AsString ()
 		{
 			return Value.ToString ();
 		}
 
 		public override object GetValue ()
 		{
 			return Value;
 		}
 
 		public override Constant Increment ()
 		{
 			return new UIntConstant (checked(Value + 1), loc);
 		}
 	
 		public override bool IsDefaultValue {
 			get {
 				return Value == 0;
 			}
 		}
 
 		public override bool IsNegative {
 			get {
 				return false;
 			}
 		}
 		
 		public override bool IsOneInteger {
 			get {
 				return Value == 1;
 			}
 		}		
 
 		public override bool IsZeroInteger {
 			get { return Value == 0; }
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value > Int32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong) Value, Location);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
 
 	}
 
 	public class LongConstant 
 		public readonly long Value;
 
 		public LongConstant (long v, Location loc)
 			base (loc)
 		{
 			Value = v;
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.int64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			enc.Encode (Value);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.EmitLong (Value);
 		}
 
 		public override string AsString ()
 		{
 			return Value.ToString ();
 		}
 
 		public override object GetValue ()
 		{
 			return Value;
 		}
 
 		public override Constant Increment ()
 		{
 			return new LongConstant (checked(Value + 1), loc);
 		}
 		
 		public override bool IsDefaultValue {
 			get {
 				return Value == 0;
 			}
 		}
 
 		public override bool IsNegative {
 			get {
 				return Value < 0;
 			}
 		}
 		
 		public override bool IsOneInteger {
 			get {
 				return Value == 1;
 			}
 		}		
 
 		public override bool IsZeroInteger {
 			get { return Value == 0; }
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue)
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < Int16.MinValue || Value > Int16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < UInt16.MinValue || Value > UInt16.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < Int32.MinValue || Value > Int32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < UInt32.MinValue || Value > UInt32.MaxValue)
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < Char.MinValue || Value > Char.MaxValue)
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec type)
 		{
 			if (Value >= 0 && type == TypeManager.uint64_type) {
 				return new ULongConstant ((ulong) Value, loc).Resolve (rc);
 			}
 
 			return base.ConvertImplicitly (rc, type);
 		}
 	}
 
 	public class ULongConstant 
 		public readonly ulong Value;
 
 		public ULongConstant (ulong v, Location loc)
 			base (loc)
 		{
 			Value = v;
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.uint64_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			enc.Encode (Value);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.EmitLong (unchecked ((long) Value));
 		}
 
 		public override string AsString ()
 		{
 			return Value.ToString ();
 		}
 
 		public override object GetValue ()
 		{
 			return Value;
 		}
 
 		public override Constant Increment ()
 		{
 			return new ULongConstant (checked(Value + 1), loc);
 		}
 
 		public override bool IsDefaultValue {
 			get {
 				return Value == 0;
 			}
 		}
 
 		public override bool IsNegative {
 			get {
 				return false;
 			}
 		}
 		
 		public override bool IsOneInteger {
 			get {
 				return Value == 1;
 			}
 		}		
 
 		public override bool IsZeroInteger {
 			get { return Value == 0; }
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context && Value > Byte.MaxValue)
 					throw new OverflowException ();
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context && Value > ((ulong) SByte.MaxValue))
 					throw new OverflowException ();
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context && Value > ((ulong) Int16.MaxValue))
 					throw new OverflowException ();
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value > UInt16.MaxValue)
 					throw new OverflowException ();
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context && Value > UInt32.MaxValue)
 					throw new OverflowException ();
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if  (in_checked_context && Value > UInt32.MaxValue)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context && Value > Int64.MaxValue)
 					throw new OverflowException ();
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context && Value > Char.MaxValue)
 					throw new OverflowException ();
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
 
 	}
 
 	public class FloatConstant 
 		public float Value;
 
 		public FloatConstant (float v, Location loc)
 			base (loc)
 		{
 			Value = v;
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.float_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			enc.Encode (Value);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldc_R4, Value);
 		}
 
 		public override string AsString ()
 		{
 			return Value.ToString ();
 		}
 
 		public override object GetValue ()
 		{
 			return Value;
 		}
 
 		public override bool IsDefaultValue {
 			get {
 				return Value == 0;
 			}
 		}
 
 		public override bool IsNegative {
 			get {
 				return Value < 0;
 			}
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < byte.MinValue || Value > byte.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < sbyte.MinValue || Value > sbyte.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (float) char.MinValue || Value > (float) char.MaxValue || float.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
 
 	}
 
 	public class DoubleConstant 
 		public double Value;
 
 		public DoubleConstant (double v, Location loc)
 			base (loc)
 		{
 			Value = v;
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.double_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			enc.Encode (Value);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldc_R8, Value);
 		}
 
 		public override string AsString ()
 		{
 			return Value.ToString ();
 		}
 
 		public override object GetValue ()
 		{
 			return Value;
 		}
 
 		public override bool IsDefaultValue {
 			get {
 				return Value == 0;
 			}
 		}
 
 		public override bool IsNegative {
 			get {
 				return Value < 0;
 			}
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context){
 					if (Value < Byte.MinValue || Value > Byte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context){
 					if (Value < SByte.MinValue || Value > SByte.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context){
 					if (Value < short.MinValue || Value > short.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context){
 					if (Value < ushort.MinValue || Value > ushort.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context){
 					if (Value < int.MinValue || Value > int.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context){
 					if (Value < uint.MinValue || Value > uint.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context){
 					if (Value < long.MinValue || Value > long.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context){
 					if (Value < ulong.MinValue || Value > ulong.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context){
 					if (Value < (double) char.MinValue || Value > (double) char.MaxValue || double.IsNaN (Value))
 						throw new OverflowException ();
 				}
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
 
 	}
 
 	public class DecimalConstant 
 		public readonly decimal Value;
 
 		public DecimalConstant (decimal d, Location loc)
 			base (loc)
 		{
 			Value = d;
 		}
 
 		override public string AsString ()
 		{
 			return Value.ToString () + "M";
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.decimal_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override object GetValue ()
 		{
 			return (object) Value;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			int [] words = decimal.GetBits (Value);
 			int power = (words [3] >> 16) & 0xff;
 
 			if (power == 0) {
 				if (Value <= int.MaxValue && Value >= int.MinValue) {
 					if (TypeManager.void_decimal_ctor_int_arg == null) {
 						TypeManager.void_decimal_ctor_int_arg = TypeManager.GetPredefinedConstructor (
 							TypeManager.decimal_type, loc, TypeManager.int32_type);
 
 						if (TypeManager.void_decimal_ctor_int_arg == null)
 							return;
 					}
 
 					ec.EmitInt ((int) Value);
 					ec.Emit (OpCodes.Newobj, TypeManager.void_decimal_ctor_int_arg);
 					return;
 				}
 
 				if (Value <= long.MaxValue && Value >= long.MinValue) {
 					if (TypeManager.void_decimal_ctor_long_arg == null) {
 						TypeManager.void_decimal_ctor_long_arg = TypeManager.GetPredefinedConstructor (
 							TypeManager.decimal_type, loc, TypeManager.int64_type);
 
 						if (TypeManager.void_decimal_ctor_long_arg == null)
 							return;
 					}
 
 					ec.EmitLong ((long) Value);
 					ec.Emit (OpCodes.Newobj, TypeManager.void_decimal_ctor_long_arg);
 					return;
 				}
 			}
 
 			ec.EmitInt (words [0]);
 			ec.EmitInt (words [1]);
 			ec.EmitInt (words [2]);
 
 			// sign
 			ec.EmitInt (words [3] >> 31);
 
 			// power
 			ec.EmitInt (power);
 
 			if (TypeManager.void_decimal_ctor_five_args == null) {
 				TypeManager.void_decimal_ctor_five_args = TypeManager.GetPredefinedConstructor (
 					TypeManager.decimal_type, loc, TypeManager.int32_type, TypeManager.int32_type,
 					TypeManager.int32_type, TypeManager.bool_type, TypeManager.byte_type);
 
 				if (TypeManager.void_decimal_ctor_five_args == null)
 					return;
 			}
 
 			ec.Emit (OpCodes.Newobj, TypeManager.void_decimal_ctor_five_args);
 		}
 
 		public override bool IsDefaultValue {
 			get {
 				return Value == 0;
 			}
 		}
 
 		public override bool IsNegative {
 			get {
 				return Value < 0;
 			}
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.sbyte_type)
 				return new SByteConstant ((sbyte)Value, loc);
 			if (target_type == TypeManager.byte_type)
 				return new ByteConstant ((byte)Value, loc);
 			if (target_type == TypeManager.short_type)
 				return new ShortConstant ((short)Value, loc);
 			if (target_type == TypeManager.ushort_type)
 				return new UShortConstant ((ushort)Value, loc);
 			if (target_type == TypeManager.int32_type)
 				return new IntConstant ((int)Value, loc);
 			if (target_type == TypeManager.uint32_type)
 				return new UIntConstant ((uint)Value, loc);
 			if (target_type == TypeManager.int64_type)
 				return new LongConstant ((long)Value, loc);
 			if (target_type == TypeManager.uint64_type)
 				return new ULongConstant ((ulong)Value, loc);
 			if (target_type == TypeManager.char_type)
 				return new CharConstant ((char)Value, loc);
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float)Value, loc);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double)Value, loc);
 
 			return null;
 		}
 
 	}
 
 	public class StringConstant 
 		public readonly string Value;
 
 		public StringConstant (string s, Location loc)
 			base (loc)
 		{
 			Value = s;
 		}
 
 		// FIXME
 		override public string AsString ()
 		{
 			return "\"" + Value + "\"";
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			type = TypeManager.string_type;
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		public override object GetValue ()
 		{
 			return Value;
 		}
 		
 		public override void Emit (EmitContext ec)
 		{
 			if (Value == null) {
 				ec.Emit (OpCodes.Ldnull);
 				return;
 			}
 
 			//
 			// Use string.Empty for both literals and constants even if
 			// it's not allowed at language level
 			//
 			if (Value.Length == 0 && RootContext.Optimize && ec.CurrentType != TypeManager.string_type) {
 				if (TypeManager.string_empty == null)
 					TypeManager.string_empty = TypeManager.GetPredefinedField (TypeManager.string_type, "Empty", loc, TypeManager.string_type);
 
 				if (TypeManager.string_empty != null) {
 					ec.Emit (OpCodes.Ldsfld, TypeManager.string_empty);
 					return;
 				}
 			}
 
 			ec.Emit (OpCodes.Ldstr, Value);
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			// cast to object
 			if (type != targetType)
 				enc.Encode (type);
 
 			enc.Encode (Value);
 		}
 
 		public override bool IsDefaultValue {
 			get {
 				return Value == null;
 			}
 		}
 
 		public override bool IsNegative {
 			get {
 				return false;
 			}
 		}
 
 		public override bool IsNull {
 			get {
 				return IsDefaultValue;
 			}
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			return null;
 		}
 	}
 
 	//
 	// Null constant can have its own type, think of `default (Foo)'
 	//
 	public class NullConstant 
 	{
 		public NullConstant (TypeSpec type, Location loc)
 			
 		{
 			eclass = ExprClass.Value;
 			this.type = type;
 		}
 
 		public override string AsString ()
 		{
 			return GetSignatureForError ();
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (type == InternalType.Null || type == TypeManager.object_type) {
 				// Optimized version, also avoids referencing literal internal type
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (this));
 				return CreateExpressionFactoryCall (ec, "Constant", args);
 			}
 
 			return base.CreateExpressionTree (ec);
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return this;
 		}
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			// Type it as string cast
 			if (targetType == TypeManager.object_type || targetType == InternalType.Null)
 				enc.Encode (TypeManager.string_type);
 
 			var ac = targetType as ArrayContainer;
 			if (ac != null) {
 				if (ac.Rank != 1 || ac.Element.IsArray)
 					base.EncodeAttributeValue (rc, enc, targetType);
 				else
 					enc.Encode (uint.MaxValue);
 			} else {
 				enc.Encode (byte.MaxValue);
 			}
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldnull);
 
 			// Only to make verifier happy
 			if (TypeManager.IsGenericParameter (type))
 				ec.Emit (OpCodes.Unbox_Any, type);
 		}
 
 		public override string ExprClassName {
 			get {
 				return GetSignatureForError ();
 			}
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return "null";
 		}
 
 		public override Constant ConvertExplicitly (bool inCheckedContext, TypeSpec targetType)
 		{
 			if (targetType.IsPointer) {
 				if (IsLiteral || this is NullPointer)
 					return new EmptyConstantCast (new NullPointer (loc), targetType);
 
 				return null;
 			}
 
 			// Exlude internal compiler types
 			if (targetType.Kind == MemberKind.InternalCompilerType && targetType != InternalType.Dynamic && targetType != InternalType.Null)
 				return null;
 
 			if (!IsLiteral && !Convert.ImplicitStandardConversionExists (this, targetType))
 				return null;
 
 			if (TypeManager.IsReferenceType (targetType))
 				return new NullConstant (targetType, loc);
 
 			if (TypeManager.IsNullableType (targetType))
 				return Nullable.LiftedNull.Create (targetType, loc);
 
 			return null;
 		}
 
 		public override Constant ConvertImplicitly (ResolveContext rc, TypeSpec targetType)
 		{
 			return ConvertExplicitly (false, targetType);
 		}
 
 		public override object GetValue ()
 		{
 			return null;
 		}
 
 		public override bool IsDefaultValue {
 			get { return true; }
 		}
 
 		public override bool IsNegative {
 			get { return false; }
 		}
 
 		public override bool IsNull {
 			get { return true; }
 		}
 
 		public override bool IsZeroInteger {
 			get { return true; }
 		}
 	}
 
 	/// <summary>
 	///   The value is constant, but when emitted has a side effect.  This is
 	///   used by BitwiseAnd to ensure that the second expression is invoked
 	///   regardless of the value of the left side.  
 	/// </summary>
 	public class SideEffectConstant 
 		public Constant value;
 		Expression side_effect;
 		
 		public SideEffectConstant (Constant value, Expression side_effect, Location loc) 
 		{
 			this.value = value;
 			while (side_effect is SideEffectConstant)
 				side_effect = ((SideEffectConstant) side_effect).side_effect;
 			while (side_effect is SideEffectConstant)
 				side_effect = ((SideEffectConstant) side_effect).side_effect;
 			this.side_effect = side_effect;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1899" endline="1910">
<![CDATA[
 		}
 
 		readonly Expression expr, orig_expr;
 
 		private ReducedExpression (Expression expr, Expression orig_expr)
 		{
 			this.expr = expr;
 			this.eclass = expr.eclass;
 			this.type = expr.Type;
 			this.orig_expr = orig_expr;
 			this.loc = orig_expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="513" endline="520">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			Join t = (Join) target;
 			t.inner_selector = (QueryBlock) inner_selector.Clone (clonectx);
 			t.outer_selector = (QueryBlock) outer_selector.Clone (clonectx);
 			base.CloneTo (clonectx, t);
 		}	
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="326" endline="333">
<![CDATA[
 
 		public void SetSignature(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			this.returnType = returnType ?? this.Module.universe.System_Void;
 			this.parameterTypes = Util.Copy(parameterTypes);
 			this.modifiers = PackedCustomModifiers.CreateFromExternal(returnTypeOptionalCustomModifiers, returnTypeRequiredCustomModifiers,
 				parameterTypeOptionalCustomModifiers, parameterTypeRequiredCustomModifiers, this.parameterTypes.Length);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="233" endline="255">
<![CDATA[
 	}
 
 	/// <summary>
 	///   An exception used to terminate the compiler resolution phase and provide completions
 	/// </summary>
 	/// <remarks>
 	///   This is thrown when we want to return the completions or
 	///   terminate the completion process by AST nodes used in
 	///   the completion process.
 	/// </remarks>
 	public class CompletionResult 
 		string [] result;
 		string base_text;
 		
 		public CompletionResult (string base_text, string [] res)
 		{
 			if (base_text == null)
 				throw new ArgumentNullException ("base_text");
 			this.base_text = base_text;
 
 			result = res;
 			Array.Sort (result);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="55" endline="62">
<![CDATA[
 
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    TypeArguments args, Location loc)
 			
 		{
 			if (args != null && args.Count > 0)
 				this.TypeArguments = args;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="205" endline="220">
<![CDATA[
 
 		public MethodEntry DefineMethod (CompileUnitEntry comp_unit, int token,
 						 ScopeVariable[] scope_vars, LocalVariableEntry[] locals,
 						 LineNumberEntry[] lines, CodeBlockEntry[] code_blocks,
 						 string real_name, MethodEntry.Flags flags,
 						 int namespace_id)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			MethodEntry method = new MethodEntry (
 				this, comp_unit, token, scope_vars, locals, lines, code_blocks, 
 				real_name, flags, namespace_id);
 			AddMethod (method);
 			return method;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1276" endline="1284">
<![CDATA[
 		internal ArrayMethod(Module module, Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
 		{
 			this.module = module;
 			this.arrayClass = arrayClass;
 			this.methodName = methodName;
 			this.callingConvention = callingConvention;
 			this.returnType = returnType ?? module.universe.System_Void;
 			this.parameterTypes = Util.Copy(parameterTypes);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9235" endline="9242">
<![CDATA[
 	
 		public override void EmitStatement (EmitContext ec)
 		{
 			if (source is CollectionOrObjectInitializers)
 				source.Emit (ec);
 			else
 				base.EmitStatement (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4718" endline="4729">
<![CDATA[
 		}
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			ResolveInstanceExpression (rc, null);
 			DoBestMemberChecks (rc, constant);
 
 			var c = constant.GetConstant (rc);
 
 			// Creates reference expression to the constant value
 			return Constant.CreateConstant (rc, constant.MemberType, c.GetValue (), loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1177" endline="1186">
<![CDATA[
 		}
 
 		private int AddTypeRefByName(int resolutionScope, string ns, string name)
 		{
 			TypeRefTable.Record rec = new TypeRefTable.Record();
 			rec.ResolutionScope = resolutionScope;
 			rec.TypeName = this.Strings.Add(name);
 			rec.TypeNameSpace = ns == null ? 0 
 			return 0x01000000 | this.TypeRef.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="219" endline="227">
<![CDATA[
 		}
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			if (leave_copy)
 				Load (ec);
 
 			Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1121" endline="1128">
<![CDATA[
 
 		public OperatorCast (Expression child, TypeSpec target_type, bool find_explicit)
 			
 		{
 			conversion_operator = GetConversionOperator (find_explicit);
 			if (conversion_operator == null)
 				throw new InternalErrorException ("Outer conversion routine is out of sync");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="37" endline="44">
<![CDATA[
 		private readonly byte[] buffer = new byte[8];
 
 		internal MetadataWriter(ModuleBuilder module, Stream stream)
 			
 		{
 			this.moduleBuilder = module;
 			this.stream = stream;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="196" endline="203">
<![CDATA[
 		public AnonymousMethodStorey (Block block, TypeContainer parent, MemberBase host, TypeParameter[] tparams, string name)
 			
 				tparams, Modifiers.SEALED)
 		{
 			Parent = parent;
 			OriginalSourceBlock = block;
 			ID = unique_id++;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="793" endline="828">
<![CDATA[
 		}
 
 		public readonly int LineBase;
 		public readonly int LineRange;
 		public readonly byte OpcodeBase;
 		public readonly int MaxAddressIncrement;
 
 #region Configurable constants
 		public const int Default_LineBase = -1;
 		public const int Default_LineRange = 8;
 		public const byte Default_OpcodeBase = 9;
 
 		public const bool SuppressDuplicates = true;
 #endregion
 
 		public const byte DW_LNS_copy = 1;
 		public const byte DW_LNS_advance_pc = 2;
 		public const byte DW_LNS_advance_line = 3;
 		public const byte DW_LNS_set_file = 4;
 		public const byte DW_LNS_const_add_pc = 8;
 
 		public const byte DW_LNE_end_sequence = 1;
 
 		// MONO extensions.
 		public const byte DW_LNE_MONO_negate_is_hidden = 0x40;
 
 		internal const byte DW_LNE_MONO__extensions_start = 0x40;
 		internal const byte DW_LNE_MONO__extensions_end   = 0x7f;
 
 		protected LineNumberTable (MonoSymbolFile file)
 		{
 			this.LineBase = file.OffsetTable.LineNumberTable_LineBase;
 			this.LineRange = file.OffsetTable.LineNumberTable_LineRange;
 			this.OpcodeBase = (byte) file.OffsetTable.LineNumberTable_OpcodeBase;
 			this.MaxAddressIncrement = (255 - OpcodeBase) / LineRange;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="51" endline="59">
<![CDATA[
 		public TypeSpec (MemberKind kind, TypeSpec declaringType, ITypeDefinition definition, MetaType info, Modifiers modifiers)
 			
 		{
 			this.declaringType = declaringType;
 			this.info = info;
 
 			if (definition != null && definition.TypeParametersCount > 0)
 				state |= StateFlags.IsGeneric;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="978" endline="1123">
<![CDATA[
 
 		readonly string name;
 
 		InternalType (string name, MemberCache cache)
 			
 		{
 			this.cache = cache;
 		}
 
 		InternalType (string name)
 			
 		{
 			this.name = name;
 			this.definition = this;
 			cache = MemberCache.Empty;
 
 			// Make all internal types CLS-compliant, non-obsolete
 			state = (state & ~(StateFlags.CLSCompliant_Undetected | StateFlags.Obsolete_Undetected)) | StateFlags.CLSCompliant;
 		}
 
 		#region Properties
 
 		public override int Arity {
 			get {
 				return 0;
 			}
 		}
 
 		IAssemblyDefinition ITypeDefinition.DeclaringAssembly {
 			get {
 				throw new NotImplementedException ();
 			}
 		}
 
 		bool IMemberDefinition.IsImported {
 			get {
 				return false;
 			}
 		}
 
 		public override string Name {
 			get {
 				return name;
 			}
 		}
 
 		string ITypeDefinition.Namespace {
 			get {
 				return null;
 			}
 		}
 
 		int ITypeDefinition.TypeParametersCount {
 			get {
 				return 0;
 			}
 		}
 
 		TypeParameterSpec[] ITypeDefinition.TypeParameters {
 			get {
 				return null;
 			}
 		}
 
 		#endregion
 
 		public override string GetSignatureForError ()
 		{
 			return name;
 		}
 
 		#region ITypeDefinition Members
 
 		TypeSpec ITypeDefinition.GetAttributeCoClass ()
 		{
 			return null;
 		}
 
 		string ITypeDefinition.GetAttributeDefaultMember ()
 		{
 			return null;
 		}
 
 		AttributeUsageAttribute ITypeDefinition.GetAttributeUsage (PredefinedAttribute pa)
 		{
 			return null;
 		}
 
 		bool ITypeDefinition.IsInternalAsPublic (IAssemblyDefinition assembly)
 		{
 			throw new NotImplementedException ();
 		}
 
 		void ITypeDefinition.LoadMembers (TypeSpec declaringType, bool onlyTypes, ref MemberCache cache)
 		{
 			throw new NotImplementedException ();
 		}
 
 		string[] IMemberDefinition.ConditionalConditions ()
 		{
 			return null;
 		}
 
 		ObsoleteAttribute IMemberDefinition.GetAttributeObsolete ()
 		{
 			return null;
 		}
 
 		bool IMemberDefinition.IsNotCLSCompliant ()
 		{
 			return false;
 		}
 
 		void IMemberDefinition.SetIsAssigned ()
 		{
 		}
 
 		void IMemberDefinition.SetIsUsed ()
 		{
 		}
 
 		#endregion
 	}
 
 	public abstract class ElementTypeSpec 
 	{
 		protected ElementTypeSpec (MemberKind kind, TypeSpec element, MetaType info)
 			
 		{
 			this.Element = element;
 
 			// Some flags can be copied directly from the element
 			const StateFlags shared_flags = StateFlags.CLSCompliant | StateFlags.CLSCompliant_Undetected
 				| StateFlags.Obsolete | StateFlags.Obsolete_Undetected | StateFlags.HasDynamicElement;
 			state &= ~shared_flags;
 			state |= (element.state & shared_flags);
 
 			if (element == InternalType.Dynamic)
 				state |= StateFlags.HasDynamicElement;
 
 			// Has to use its own type definition instead of just element definition to
 			// correctly identify itself for cases like x.MemberDefininition == predefined.MemberDefinition
 			this.definition = this;
 
 			cache = MemberCache.Empty;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3334" endline="3349">
<![CDATA[
 
 		public OverloadResolver (IList<MemberSpec> members, TypeArguments targs, Restrictions restrictions, Location loc)
 			
 		{
 			if (members == null || members.Count == 0)
 				throw new ArgumentException ("empty members set");
 
 			this.members = members;
 			this.loc = loc;
 			type_arguments = targs;
 			this.restrictions = restrictions;
 			if (IsDelegateInvoke)
 				this.restrictions |= Restrictions.NoBaseMembers;
 
 			base_provider = NoBaseMembers.Instance;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="512" endline="520">
<![CDATA[
 		}
 
 		protected override void AddSibling (UsageVector sibling)
 		{
 			if (sibling_list != null && sibling_list.Type == SiblingType.Block)
 				throw new InternalErrorException ("Blocks don't have sibling flow paths");
 			sibling.Next = sibling_list;
 			sibling_list = sibling;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="187" endline="196">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			// TODO
 			base.Emit (ec);
 
 			// Release temporary variable when used
 			if (variable != null)
 				variable.Release (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8953" endline="8960">
<![CDATA[
 
 		void MakeArray (ComposedTypeSpecifier spec)
 		{
 			if (spec.Next != null)
 				MakeArray (spec.Next);
 
 			type = ArrayContainer.MakeType (type, spec.Dimension);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="606" endline="616">
<![CDATA[
 		}
 	
 		protected readonly AnonymousMethodStorey storey;
 		protected Field field;
 		Dictionary<AnonymousExpression, FieldExpr> cached_inner_access; // TODO
 		FieldExpr cached_outer_access;
 
 		protected HoistedVariable (AnonymousMethodStorey storey, string name, TypeSpec type)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="91" endline="99">
<![CDATA[
 
 		public MemberFilter (string name, int arity, MemberKind kind, AParametersCollection param, TypeSpec type)
 		{
 			Name = name;
 			Kind = kind;
 			Parameters = param;
 			MemberType = type;
 			this.arity = arity;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="381" endline="387">
<![CDATA[
 
 		public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			return DefinePropertyImpl(name, attributes, CallingConventions.Standard, true, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers,
 				parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="388" endline="395">
<![CDATA[
 
 		public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention,
 			Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			return DefinePropertyImpl(name, attributes, callingConvention, false, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers,
 				parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4242" endline="4249">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Lock target = (Lock) t;
 
 			target.expr = expr.Clone (clonectx);
 			target.stmt = Statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="63" endline="276">
<![CDATA[
 
 		protected FieldBase (DeclSpace parent, FullNamedExpression type, Modifiers mod,
 				     Modifiers allowed_mod, MemberName name, Attributes attrs)
 			
 				name, attrs)
 		{
 			if ((mod & Modifiers.ABSTRACT) != 0)
 				Report.Error (681, Location, "The modifier 'abstract' is not valid on fields. Try using a property instead");
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Field;
 			}
 		}
 
 		public Expression Initializer {
 			get {
 				return initializer;
 			}
 			set {
 				this.initializer = value;
 			}
 		}
 
 		public FieldSpec Spec {
 			get {
 				return spec;
 			}
 		}
 
 		public override string[] ValidAttributeTargets  {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.FieldOffset) {
 				status |= Status.HAS_OFFSET;
 
 				if (!Parent.PartialContainer.HasExplicitLayout) {
 					Report.Error (636, Location, "The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)");
 					return;
 				}
 
 				if ((ModFlags & Modifiers.STATIC) != 0 || this is Const) {
 					Report.Error (637, Location, "The FieldOffset attribute is not allowed on static or const fields");
 					return;
 				}
 			}
 
 			if (a.Type == pa.FixedBuffer) {
 				Report.Error (1716, Location, "Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead");
 				return;
 			}
 
 #if false
 			if (a.Type == pa.MarshalAs) {
 				UnmanagedMarshal marshal = a.GetMarshal (this);
 				if (marshal != null) {
 					FieldBuilder.SetMarshal (marshal);
 				}
 				return;
 			}
 #endif
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			if (a.Type == pa.Dynamic) {
 				a.Error_MisusedDynamicAttribute ();
 				return;
 			}
 
 			FieldBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public void SetCustomAttribute (MethodSpec ctor, byte[] data)
 		{
 			FieldBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), data);
 		}
 
  		protected override bool CheckBase ()
 		{
  			if (!base.CheckBase ())
  				return false;
 
 			MemberSpec candidate;
 			var conflict_symbol = MemberCache.FindBaseMember (this, out candidate);
 			if (conflict_symbol == null)
 				conflict_symbol = candidate;
 
  			if (conflict_symbol == null) {
  				if ((ModFlags & Modifiers.NEW) != 0) {
  					Report.Warning (109, 4, Location, "The member `{0}' does not hide an inherited member. The new keyword is not required",
 						GetSignatureForError ());
  				}
  			} else {
 				if ((ModFlags & (Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.BACKING_FIELD)) == 0) {
 					Report.SymbolRelatedToPreviousError (conflict_symbol);
 					Report.Warning (108, 2, Location, "`{0}' hides inherited member `{1}'. Use the new keyword if hiding was intended",
 						GetSignatureForError (), conflict_symbol.GetSignatureForError ());
 				}
 
 				if (conflict_symbol.IsAbstract) {
 					Report.SymbolRelatedToPreviousError (conflict_symbol);
 					Report.Error (533, Location, "`{0}' hides inherited abstract member `{1}'",
 						GetSignatureForError (), conflict_symbol.GetSignatureForError ());
 				}
 			}
  
  			return true;
  		}
 
 		public virtual Constant ConvertInitializer (ResolveContext rc, Constant expr)
 		{
 			return expr.ConvertImplicitly (rc, MemberType);
 		}
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			if (MemberType.IsGenericParameter)
 				return;
 
 			if (MemberType.IsStatic)
 				Error_VariableOfStaticClass (Location, GetSignatureForError (), MemberType, Report);
 
 			CheckBase ();
 			IsTypePermitted ();
 		}
 
 		//
 		//   Represents header string for documentation comment.
 		//
 		public override string DocCommentHeader {
 			get { return "F
 		}
 
 		public override void Emit ()
 		{
 			if (member_type == InternalType.Dynamic) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (FieldBuilder);
 			} else if (!(Parent is CompilerGeneratedClass) && member_type.HasDynamicElement) {
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (FieldBuilder, member_type, Location);
 			}
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (FieldBuilder);
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			if (((status & Status.HAS_OFFSET) == 0) && (ModFlags & (Modifiers.STATIC | Modifiers.BACKING_FIELD)) == 0 && Parent.PartialContainer.HasExplicitLayout) {
 				Report.Error (625, Location, "`{0}'
 			}
 
 			base.Emit ();
 		}
 
 		public static void Error_VariableOfStaticClass (Location loc, string variable_name, TypeSpec static_class, Report Report)
 		{
 			Report.SymbolRelatedToPreviousError (static_class);
 			Report.Error (723, loc, "`{0}'
 				variable_name);
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (!MemberType.IsCLSCompliant () || this is FixedField) {
 				Report.Warning (3003, 1, Location, "Type of `{0}' is not CLS-compliant",
 					GetSignatureForError ());
 			}
 			return true;
 		}
 	}
 
 	//
 	// Field specification
 	//
 	public class FieldSpec 
 	{
 		FieldInfo metaInfo;
 		TypeSpec memberType;
 
 		public FieldSpec (TypeSpec declaringType, IMemberDefinition definition, TypeSpec memberType, FieldInfo info, Modifiers modifiers)
 			
 		{
 			this.metaInfo = info;
 			this.memberType = memberType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="49" endline="55">
<![CDATA[
 		public MethodCore (DeclSpace parent, GenericMethod generic,
 			FullNamedExpression type, Modifiers mod, Modifiers allowed_mod,
 			MemberName name, Attributes attrs, ParametersCompiled parameters)
 			
 		{
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="96" endline="110">
<![CDATA[
 
 	}
 
 	public class PropertySpec 
 	{
 		PropertyInfo info;
 		TypeSpec memberType;
 		MethodSpec set, get;
 
 		public PropertySpec (MemberKind kind, TypeSpec declaringType, IMemberDefinition definition, TypeSpec memberType, PropertyInfo info, Modifiers modifiers)
 			
 		{
 			this.info = info;
 			this.memberType = memberType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4761" endline="4768">
<![CDATA[
 
 		public FieldExpr (FieldSpec spec, Location loc)
 		{
 			this.spec = spec;
 			this.loc = loc;
 
 			type = spec.MemberType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5759" endline="5768">
<![CDATA[
 		}
 
 		LocalVariable li;
 
 		public TemporaryVariableReference (LocalVariable li, Location loc)
 		{
 			this.li = li;
 			this.type = li.Type;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4125" endline="4139">
<![CDATA[
 	}
 
 	//
 	// User-defined conditional logical operator
 	//
 	public class ConditionalLogicalOperator 
 		readonly bool is_and;
 		Expression oper_expr;
 
 		public ConditionalLogicalOperator (MethodSpec oper, Arguments arguments, Func<ResolveContext, Expression, Expression> expr_tree, bool is_and, Location loc)
 			
 		{
 			this.is_and = is_and;
 			eclass = ExprClass.Unresolved;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1330" endline="1347">
<![CDATA[
 	}
 
 	public struct NamespaceEntry
 	{
 		#region This is actually written to the symbol file
 		public readonly string Name;
 		public readonly int Index;
 		public readonly int Parent;
 		public readonly string[] UsingClauses;
 		#endregion
 
 		public NamespaceEntry (string name, int index, string[] using_clauses, int parent)
 		{
 			this.Name = name;
 			this.Index = index;
 			this.Parent = parent;
 			this.UsingClauses = using_clauses != null ? using_clauses 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5986" endline="6030">
<![CDATA[
 		}
 	}
 
 	/// <summary>
 	///   14.5.10.2
 	/// </summary>
 	///
 	/// <remarks>
 	///   There are two possible scenarios here
 	///   expression that specifies the dimensions and optionally the
 	///   initialization data and the other which does not need dimensions
 	///   specified but where initialization data is mandatory.
 	/// </remarks>
 	public class ArrayCreation 
 	{
 		FullNamedExpression requested_base_type;
 		ArrayInitializer initializers;
 
 		//
 		// The list of Argument types.
 		// This is used to construct the `newarray' or constructor signature
 		//
 		protected List<Expression> arguments;
 		
 		protected TypeSpec array_element_type;
 		int num_arguments = 0;
 		protected int dimensions;
 		protected readonly ComposedTypeSpecifier rank;
 		Expression first_emit;
 		LocalTemporary first_emit_temp;
 
 		protected List<Expression> array_data;
 
 		Dictionary<int, int> bounds;
 
 		// The number of constants in array initializers
 		int const_initializers_count;
 		bool only_constant_initializers;
 
 		public ArrayCreation (FullNamedExpression requested_base_type, List<Expression> exprs, ComposedTypeSpecifier rank, ArrayInitializer initializers, Location l)
 			
 		{
 			arguments = new List<Expression> (exprs);
 			num_arguments = arguments.Count;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="205" endline="212">
<![CDATA[
 		public MethodSpec (MemberKind kind, TypeSpec declaringType, IMemberDefinition details, TypeSpec returnType,
 			MethodBase info, AParametersCollection parameters, Modifiers modifiers)
 			
 		{
 			this.metaInfo = info;
 			this.parameters = parameters;
 			this.returnType = returnType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1370" endline="1405">
<![CDATA[
 	}
 	
 	public class Constructor 
 		public ConstructorBuilder ConstructorBuilder;
 		public ConstructorInitializer Initializer;
 		SecurityType declarative_security;
 		bool has_compliant_args;
 
 		// <summary>
 		//   Modifiers allowed for a constructor.
 		// </summary>
 		public const Modifiers AllowedModifiers =
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.STATIC |
 			Modifiers.UNSAFE |
 			Modifiers.EXTERN |		
 			Modifiers.PRIVATE;
 
 		static readonly string[] attribute_targets = new string [] { "method" };
 
 		public static readonly string ConstructorName = ".ctor";
 		public static readonly string TypeConstructorName = ".cctor";
 
 		//
 		// The spec claims that static is not permitted, but
 		// my very own code has static constructors.
 		//
 		public Constructor (DeclSpace parent, string name, Modifiers mod, Attributes attrs, ParametersCompiled args,
 				    ConstructorInitializer init, Location loc)
 			
 				new MemberName (name, loc), attrs, args)
 		{
 			Initializer = init;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1740" endline="1750">
<![CDATA[
 
 		public MethodData (InterfaceMemberBase member,
 				   Modifiers modifiers, MethodAttributes flags, 
 				   IMethodData method, MethodBuilder builder,
 				   GenericMethod generic, MethodSpec parent_method)
 			
 		{
 			this.builder = builder;
 			this.GenericMethod = generic;
 			this.parent_method = parent_method;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="38" endline="44">
<![CDATA[
 		public SourceFile (string name, string path, int index, bool is_include)
 		{
 			this.Index = index;
 			this.Name = name;
 			this.Path = path;
 			this.IsIncludeFile = is_include;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="99" endline="106">
<![CDATA[
 
 		public CompletionMemberAccess (Expression e, string partial_name, TypeArguments targs, Location l)
 		{
 			this.expr = e;
 			this.loc = l;
 			this.partial_name = partial_name;
 			this.targs = targs;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="42" endline="48">
<![CDATA[
 		internal TextSection(PEWriter peWriter, CliHeader cliHeader, ModuleBuilder moduleBuilder, int strongNameSignatureLength)
 		{
 			this.peWriter = peWriter;
 			this.cliHeader = cliHeader;
 			this.moduleBuilder = moduleBuilder;
 			this.strongNameSignatureLength = (uint)strongNameSignatureLength;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="321" endline="328">
<![CDATA[
 
 		public PredefinedType (ModuleContainer module, MemberKind kind, string ns, string name)
 		{
 			this.module = module;
 			this.kind = kind;
 			this.name = name;
 			this.ns = ns;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="135" endline="145">
<![CDATA[
 
 		public If (Expression bool_expr,
 			   Statement true_statement,
 			   Statement false_statement,
 			   Location l)
 		{
 			this.expr = bool_expr;
 			TrueStatement = true_statement;
 			FalseStatement = false_statement;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3159" endline="3173">
<![CDATA[
 		}
 
 		//
 		// The types allowed to be implicitly cast from
 		// on the governing type
 		//
 		static TypeSpec [] allowed_types;
 
 		public Switch (Expression e, ExplicitBlock block, List<SwitchSection> sects, Location l)
 		{
 			Expr = e;
 			this.block = block;
 			Sections = sects;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2070" endline="2077">
<![CDATA[
 
 		public Binary (Operator oper, Expression left, Expression right, Location loc)
 		{
 			this.oper = oper;
 			this.left = left;
 			this.right = right;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\codegen.cs" startline="91" endline="101">
<![CDATA[
 		public EmitContext (IMemberContext rc, ILGenerator ig, TypeSpec return_type)
 		{
 			this.MemberContext = rc;
 			this.ig = ig;
 
 			this.return_type = return_type;
 
 #if STATIC
 			ig.__CleverExceptionBlockAssistance ();
 #endif
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="194" endline="201">
<![CDATA[
 
 		public LineNumberEntry (int file, int row, int offset, bool is_hidden)
 		{
 			this.File = file;
 			this.Row = row;
 			this.Offset = offset;
 			this.IsHidden = is_hidden;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="233" endline="263">
<![CDATA[
 
 		public override string ToString ()
 		{
 			return String.Format ("[Line {0}
 		}
 	}
 
 	public class CodeBlockEntry
 	{
 		public int Index;
 		#region This is actually written to the symbol file
 		public int Parent;
 		public Type BlockType;
 		public int StartOffset;
 		public int EndOffset;
 		#endregion
 
 		public enum Type {
 			Lexical			= 1,
 			CompilerGenerated	= 2,
 			IteratorBody		= 3,
 			IteratorDispatcher	= 4
 		}
 
 		public CodeBlockEntry (int index, int parent, Type type, int start_offset)
 		{
 			this.Index = index;
 			this.Parent = parent;
 			this.BlockType = type;
 			this.StartOffset = start_offset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4395" endline="4409">
<![CDATA[
 	}
 	
 	/// <summary>
 	///   Implements the ternary conditional operator (?
 	/// </summary>
 	public class Conditional 
 		Expression expr, true_expr, false_expr;
 
 		public Conditional (Expression expr, Expression true_expr, Expression false_expr, Location loc)
 		{
 			this.expr = expr;
 			this.true_expr = true_expr;
 			this.false_expr = false_expr;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2096" endline="2103">
<![CDATA[
 
 		private GenericTypeInstance(Type type, Type[] args, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
 		{
 			this.type = type;
 			this.args = args;
 			this.requiredCustomModifiers = requiredCustomModifiers;
 			this.optionalCustomModifiers = optionalCustomModifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1729" endline="1739">
<![CDATA[
 		}
 
 		public MethodData (InterfaceMemberBase member,
 				   Modifiers modifiers, MethodAttributes flags, IMethodData method)
 		{
 			this.member = member;
 			this.modifiers = modifiers;
 			this.flags = flags;
 
 			this.method = method;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="47" endline="54">
<![CDATA[
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    Location loc)
 		{
 			this.Name = name;
 			this.Location = loc;
 			this.is_double_colon = is_double_colon;
 			this.Left = left;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="514" endline="524">
<![CDATA[
 	}
 
 	class DynamicConversion 
 	{
 		public DynamicConversion (TypeSpec targetType, CSharpBinderFlags flags, Arguments args, Location loc)
 			
 		{
 			type = targetType;
 			base.flags = flags;
 			base.binder = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="907" endline="921">
<![CDATA[
 		}
 	}
 
 	//
 	// A collection of imported or resolved parameters
 	//
 	public class ParametersImported 
 	{
 		public ParametersImported (IParameterData [] parameters, TypeSpec [] types, bool hasArglist, bool hasParams)
 		{
 			this.parameters = parameters;
 			this.types = types;
 			this.has_arglist = hasArglist;
 			this.has_params = hasParams;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="326" endline="332">
<![CDATA[
 
 		public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
 		{
 			MethodBuilder mb = CreateMethodBuilder(name, attributes, callingConvention);
 			mb.SetSignature(returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 			return mb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="69" endline="246">
<![CDATA[
 	}
 
 	/// <summary>
 	/// Class for applying custom attributes on the return type
 	/// </summary>
 	public class ReturnParameter 
 	{
 		MemberCore method;
 
 		// TODO
 		public ReturnParameter (MemberCore method, MethodBuilder mb, Location location)
 		{
 			this.method = method;
 			try {
 				builder = mb.DefineParameter (0, ParameterAttributes.None, "");			
 			}
 			catch (ArgumentOutOfRangeException) {
 				method.Compiler.Report.RuntimeMissingSupport (location, "custom attributes on the return type");
 			}
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant) {
 				method.Compiler.Report.Warning (3023, 1, a.Location,
 					"CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead");
 			}
 
 			// This occurs after Warning -28
 			if (builder == null)
 				return;
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.ReturnValue;
 			}
 		}
 
 		/// <summary>
 		/// Is never called
 		/// </summary>
 		public override string[] ValidAttributeTargets {
 			get {
 				return null;
 			}
 		}
 	}
 
 	public class ImplicitLambdaParameter 
 	{
 		public ImplicitLambdaParameter (string name, Location loc)
 			
 		{
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (parameter_type == null)
 				throw new InternalErrorException ("A type of implicit lambda parameter `{0}' is not set",
 					Name);
 
 			base.idx = index;
 			return parameter_type;
 		}
 
 		public void SetParameterType (TypeSpec type)
 		{
 			parameter_type = type;
 		}
 	}
 
 	public class ParamsParameter 
 		public ParamsParameter (FullNamedExpression type, string name, Attributes attrs, Location loc)
 			base (type, name, Parameter.Modifier.PARAMS, attrs, loc)
 		{
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (base.Resolve (ec, index) == null)
 				return null;
 
 			var ac = parameter_type as ArrayContainer;
 			if (ac == null || ac.Rank != 1) {
 				ec.Compiler.Report.Error (225, Location, "The params parameter must be a single dimensional array");
 				return null;
 			}
 
 			return parameter_type;
 		}
 
 		public override void ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			base.ApplyAttributes (mb, cb, index, pa);
 			pa.ParamArray.EmitAttribute (builder);
 		}
 	}
 
 	public class ArglistParameter 
 		// Doesn't have proper type because it's never chosen for better conversion
 		public ArglistParameter (Location loc) 
 			base (null, String.Empty, Parameter.Modifier.NONE, null, loc)
 		{
 			parameter_type = InternalType.Arglist;
 		}
 
 		public override void  ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			// Nothing to do
 		}
 
 		public override bool CheckAccessibility (InterfaceMemberBase member)
 		{
 			return true;
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			return parameter_type;
 		}
 	}
 
 	public interface IParameterData
 	{
 		Expression DefaultValue { get; }
 		bool HasExtensionMethodModifier { get; }
 		bool HasDefaultValue { get; }
 		Parameter.Modifier ModFlags { get; }
 		string Name { get; }
 	}
 
 	//
 	// Parameter information created by parser
 	//
 	public class Parameter 
 	{
 		[Flags]
 		public enum Modifier 
 			NONE    = 0,
 			REF     = REFMASK | ISBYREF,
 			OUT     = OUTMASK | ISBYREF,
 			PARAMS  = 4,
 			// This is a flag which says that it's either REF or OUT.
 			ISBYREF = 8,
 			REFMASK	= 32,
 			OUTMASK = 64,
 			This	= 128
 		}
 
 		static string[] attribute_targets = new string [] { "param" };
 
 		FullNamedExpression texpr;
 		readonly Modifier modFlags;
 		string name;
 		Expression default_expr;
 		protected TypeSpec parameter_type;
 		readonly Location loc;
 		protected int idx;
 		public bool HasAddressTaken;
 
 		TemporaryVariableReference expr_tree_variable;
 		static TypeExpr parameter_expr_tree_type;
 
 		HoistedVariable hoisted_variant;
 
 		public Parameter (FullNamedExpression type, string name, Modifier mod, Attributes attrs, Location loc)
 		{
 			this.name = name;
 			modFlags = mod;
 			this.loc = loc;
 			texpr = type;
 
 			// Only assign, attributes will be attached during resolve
 			base.attributes = attrs;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MethodSignature.cs" startline="41" endline="48">
<![CDATA[
 		private MethodSignature(Type returnType, Type[] parameterTypes, Type[][][] modifiers, CallingConventions callingConvention, int genericParamCount)
 		{
 			this.returnType = returnType;
 			this.parameterTypes = parameterTypes;
 			this.modifiers = modifiers;
 			this.callingConvention = callingConvention;
 			this.genericParamCount = genericParamCount;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="451" endline="471">
<![CDATA[
 	}
 
 	public class For 
 		Expression Test;
 		Statement InitStatement;
 		Statement Increment;
 		public Statement Statement;
 		bool infinite, empty;
 		
 		public For (Statement init_statement,
 			    BooleanExpression test,
 			    Statement increment,
 			    Statement statement,
 			    Location l)
 		{
 			InitStatement = init_statement;
 			Test = test;
 			Increment = increment;
 			Statement = statement;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5694" endline="5710">
<![CDATA[
 
 			#endregion
 		}
 
 		Expression type;
 		LocalVariable variable;
 		Expression expr;
 		Statement statement;
 
 		public Foreach (Expression type, LocalVariable var, Expression expr, Statement stmt, Location l)
 		{
 			this.type = type;
 			this.variable = var;
 			this.expr = expr;
 			statement = stmt;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="319" endline="337">
<![CDATA[
 	}
 
 	//
 	// A type parameter for a generic type or generic method definition
 	//
 	public class TypeParameter 
 	{
 		static readonly string[] attribute_target = new string [] { "type parameter" };
 		
 		Constraints constraints;
 		GenericTypeParameterBuilder builder;
 		TypeParameterSpec spec;
 
 		public TypeParameter (DeclSpace parent, int index, MemberName name, Constraints constraints, Attributes attrs, Variance variance)
 			
 		{
 			this.constraints = constraints;
 			this.spec = new TypeParameterSpec (null, index, this, SpecialConstraint.None, variance, null);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\PropertyBuilder.cs" startline="44" endline="51">
<![CDATA[
 		internal PropertyBuilder(TypeBuilder typeBuilder, string name, PropertyAttributes attributes, PropertySignature sig, bool patchCallingConvention)
 		{
 			this.typeBuilder = typeBuilder;
 			this.name = name;
 			this.attributes = attributes;
 			this.sig = sig;
 			this.patchCallingConvention = patchCallingConvention;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4181" endline="4197">
<![CDATA[
 	}
 
 	public class PointerArithmetic 
 		Expression left, right;
 		Binary.Operator op;
 
 		//
 		// We assume that `l' is always a pointer
 		//
 		public PointerArithmetic (Binary.Operator op, Expression l, Expression r, TypeSpec t, Location loc)
 		{
 			type = t;
 			this.loc = loc;
 			left = l;
 			right = r;
 			this.op = op;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="476" endline="487">
<![CDATA[
 		}
 
 		Expression condition;
 		ExpressionStatement invoke, assign;
 
 		public DynamicEventCompoundAssign (string name, Arguments args, ExpressionStatement assignment, ExpressionStatement invoke, Location loc)
 		{
 			condition = new IsEvent (name, args, loc);
 			this.invoke = invoke;
 			this.assign = assignment;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="684" endline="692">
<![CDATA[
 
 		public override bool AddReturnOrigin (UsageVector vector, ExitStatement stmt)
 		{
 			vector = vector.Clone ();
 			vector.Location = stmt.loc;
 			vector.Next = return_origins;
 			return_origins = vector;
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="49" endline="56">
<![CDATA[
 	public Outline (Type t, TextWriter output, bool declared_only, bool show_private, bool filter_obsolete)
 	{
 		this.t = t;
 		this.o = new IndentedTextWriter (output, "\t");
 		this.declared_only = declared_only;
 		this.show_private = show_private;
 		this.filter_obsolete = filter_obsolete;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="537" endline="548">
<![CDATA[
 		}
 
 		public CompileUnitEntry (MonoSymbolFile file, SourceFileEntry source)
 		{
 			this.file = file;
 			this.source = source;
 
 			this.Index = file.AddCompileUnit (this);
 
 			creating = true;
 			namespaces = new List<NamespaceEntry> ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="275" endline="282">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (DoResolveCore (ec))
 				binder_expr = binder.CreateCallSiteBinder (ec, arguments);
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="38" endline="47">
<![CDATA[
 		public UserOperatorCall (MethodSpec oper, Arguments args, Func<ResolveContext, Expression, Expression> expr_tree, Location loc)
 		{
 			this.oper = oper;
 			this.arguments = args;
 			this.expr_tree = expr_tree;
 
 			type = oper.ReturnType;
 			eclass = ExprClass.Value;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\StandAloneMethodSig.cs" startline="39" endline="47">
<![CDATA[
 		internal __StandAloneMethodSig(bool unmanaged, CallingConvention unmanagedCallingConvention, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
 		{
 			this.unmanaged = unmanaged;
 			this.unmanagedCallingConvention = unmanagedCallingConvention;
 			this.callingConvention = callingConvention;
 			this.returnType = returnType;
 			this.parameterTypes = parameterTypes;
 			this.optionalParameterTypes = optionalParameterTypes;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="2326" endline="2335">
<![CDATA[
 		
 		public Operator (DeclSpace parent, OpType type, FullNamedExpression ret_type,
 				 Modifiers mod_flags, ParametersCompiled parameters,
 				 ToplevelBlock block, Attributes attrs, Location loc)
 			
 				new MemberName (GetMetadataName (type), loc), attrs, parameters)
 		{
 			OperatorType = type;
 			Block = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\CustomAttributeBuilder.cs" startline="62" endline="71">
<![CDATA[
 
 		public CustomAttributeBuilder(ConstructorInfo con, object[] constructorArgs, PropertyInfo[] namedProperties, object[] propertyValues, FieldInfo[] namedFields, object[] fieldValues)
 		{
 			this.con = con;
 			this.constructorArgs = constructorArgs;
 			this.namedProperties = namedProperties;
 			this.propertyValues = propertyValues;
 			this.namedFields = namedFields;
 			this.fieldValues = fieldValues;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="48" endline="58">
<![CDATA[
 
 		private PropertySignature(CallingConventions callingConvention, Type propertyType, Type[] optionalCustomModifiers, Type[] requiredCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeOptionalCustomModifiers, Type[][] parameterTypeRequiredCustomModifiers)
 		{
 			this.callingConvention = callingConvention;
 			this.propertyType = propertyType;
 			this.optionalCustomModifiers = optionalCustomModifiers;
 			this.requiredCustomModifiers = requiredCustomModifiers;
 			this.parameterTypes = parameterTypes;
 			this.parameterOptionalCustomModifiers = parameterTypeOptionalCustomModifiers;
 			this.parameterRequiredCustomModifiers = parameterTypeRequiredCustomModifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="766" endline="778">
<![CDATA[
 
 		//
 		// Our constructor
 		//
 		public Iterator (ParametersBlock block, IMethodData method, TypeContainer host, TypeSpec iterator_type, bool is_enumerable)
 			
 		{
 			this.OriginalMethod = method;
 			this.OriginalIteratorType = iterator_type;
 			this.IsEnumerable = is_enumerable;
 			this.Host = host;
 			this.type = method.ReturnType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="700" endline="709">
<![CDATA[
 
 		private NamespaceEntry (ModuleContainer ctx, NamespaceEntry parent, CompilationUnit file, Namespace ns, bool slave)
 		{
 			this.ctx = ctx;
 			this.parent = parent;
 			this.file = file;
 			this.IsImplicit = true;
 			this.ns = ns;
 			this.SlaveDeclSpace = slave ? new RootDeclSpace (this) 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6011" endline="6044">
<![CDATA[
 		int num_arguments = 0;
 		protected int dimensions;
 		protected readonly ComposedTypeSpecifier rank;
 		Expression first_emit;
 		LocalTemporary first_emit_temp;
 
 		protected List<Expression> array_data;
 
 		Dictionary<int, int> bounds;
 
 		// The number of constants in array initializers
 		int const_initializers_count;
 		bool only_constant_initializers;
 
 		public ArrayCreation (FullNamedExpression requested_base_type, List<Expression> exprs, ComposedTypeSpecifier rank, ArrayInitializer initializers, Location l)
 			
 		{
 			arguments = new List<Expression> (exprs);
 			num_arguments = arguments.Count;
 		}
 
 		//
 		// For expressions like int[] foo = new int[] { 1, 2, 3 };
 		//
 		public ArrayCreation (FullNamedExpression requested_base_type, ComposedTypeSpecifier rank, ArrayInitializer initializers, Location loc)
 		{
 			this.requested_base_type = requested_base_type;
 			this.rank = rank;
 			this.initializers = initializers;
 			this.loc = loc;
 
 			if (rank != null)
 				num_arguments = rank.Dimension;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ParameterBuilder.cs" startline="39" endline="46">
<![CDATA[
 		internal ParameterBuilder(ModuleBuilder moduleBuilder, int sequence, ParameterAttributes attribs, string name)
 		{
 			this.moduleBuilder = moduleBuilder;
 			this.flags = (short)attribs;
 			this.sequence = (short)sequence;
 			this.nameIndex = name == null ? 0 
 			this.name = name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2379" endline="2398">
<![CDATA[
 		}
 
 		protected ParametersCompiled parameters;
 		protected ParameterInfo[] parameter_info;
 		bool resolved;
 		protected bool unreachable;
 		protected ToplevelBlock top_block;
 
 		public ParametersBlock (Block parent, ParametersCompiled parameters, Location start)
 			
 		{
 			if (parameters == null)
 				throw new ArgumentNullException ("parameters");
 
 			this.parameters = parameters;
 			ParametersBlock = this;
 
 			this.top_block = parent.ParametersBlock.top_block;
 			ProcessParameters ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="547" endline="555">
<![CDATA[
 	}
 
 	public class FlowBranchingBreakable 
 	{
 		UsageVector break_origins;
 
 		public FlowBranchingBreakable (FlowBranching parent, BranchingType type, SiblingType stype, Block block, Location loc)
 			
 		{ }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="571" endline="579">
<![CDATA[
 	}
 
 	public class FlowBranchingContinuable 
 	{
 		UsageVector continue_origins;
 
 		public FlowBranchingContinuable (FlowBranching parent, BranchingType type, SiblingType stype, Block block, Location loc)
 			
 		{ }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="749" endline="757">
<![CDATA[
 		}
 		
 		/// <summary>
 		///   Reports that we were expecting `expr' to be of class `expected'
 		/// </summary>
 		public void Error_UnexpectedKind (Report r, MemberCore mc, string expected, Location loc)
 		{
 			Error_UnexpectedKind (r, mc, expected, ExprClassName, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="833" endline="840">
<![CDATA[
 		}
 
 		static readonly string[] attribute_targets = new string [] { "event" };
 
 		public EventProperty (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="299" endline="314">
<![CDATA[
 	}
 
 	public struct LocalVariableEntry
 	{
 		#region This is actually written to the symbol file
 		public readonly int Index;
 		public readonly string Name;
 		public readonly int BlockIndex;
 		#endregion
 
 		public LocalVariableEntry (int index, string name, int block)
 		{
 			this.Index = index;
 			this.Name = name;
 			this.BlockIndex = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="335" endline="358">
<![CDATA[
 	}
 
 	public struct CapturedVariable
 	{
 		#region This is actually written to the symbol file
 		public readonly string Name;
 		public readonly string CapturedName;
 		public readonly CapturedKind Kind;
 		#endregion
 
 		public enum CapturedKind 
 		{
 			Local,
 			Parameter,
 			This
 		}
 
 		public CapturedVariable (string name, string captured_name,
 					 CapturedKind kind)
 		{
 			this.Name = name;
 			this.CapturedName = captured_name;
 			this.Kind = kind;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="95" endline="101">
<![CDATA[
 
 		public void SetLocalSymInfo(string name, int startOffset, int endOffset)
 		{
 			this.name = name;
 			this.startOffset = startOffset;
 			this.endOffset = endOffset;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5331" endline="5351">
<![CDATA[
 
 		/// <remarks>
 		///   is_base tells whether we want to force the use of the `call'
 		///   opcode instead of using callvirt.  Call is required to call
 		///   a specific method, while callvirt will always use the most
 		///   recent method in the vtable.
 		///
 		///   is_static tells whether this is an invocation on a static method
 		///
 		///   instance_expr is an expression that represents the instance
 		///   it must be non-null if is_static is false.
 		///
 		///   method is the method to invoke.
 		///
 		///   Arguments is the list of arguments to pass to the method or constructor.
 		/// </remarks>
 		public static void EmitCall (EmitContext ec, Expression instance_expr,
 					     MethodSpec method, Arguments Arguments, Location loc)
 		{
 			EmitCall (ec, instance_expr, method, Arguments, loc, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="117" endline="147">
<![CDATA[
 		}
 	}
 
 	public class ImplicitLambdaParameter 
 	{
 		public ImplicitLambdaParameter (string name, Location loc)
 			
 		{
 		}
 
 		public override TypeSpec Resolve (IMemberContext ec, int index)
 		{
 			if (parameter_type == null)
 				throw new InternalErrorException ("A type of implicit lambda parameter `{0}' is not set",
 					Name);
 
 			base.idx = index;
 			return parameter_type;
 		}
 
 		public void SetParameterType (TypeSpec type)
 		{
 			parameter_type = type;
 		}
 	}
 
 	public class ParamsParameter 
 		public ParamsParameter (FullNamedExpression type, string name, Attributes attrs, Location loc)
 			base (type, name, Parameter.Modifier.PARAMS, attrs, loc)
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="105" endline="112">
<![CDATA[
 
 		//
 		//  Returns a constant instance based on Type
 		//
 		public static Constant CreateConstant (ResolveContext rc, TypeSpec t, object v, Location loc)
 		{
 			return CreateConstantFromValue (t, v, loc).Resolve (rc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1569" endline="1579">
<![CDATA[
 	}
 
 	class ImportedParameterMemberDefinition 
 	{
 		readonly AParametersCollection parameters;
 
 		public ImportedParameterMemberDefinition (MethodBase provider, TypeSpec type, AParametersCollection parameters, MetadataImporter importer)
 			
 		{
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="268" endline="276">
<![CDATA[
 		}
 
 		protected RangeVariable identifier;
 
 		protected ARangeVariableQueryClause (QueryBlock block, RangeVariable identifier, Expression expr, Location loc)
 			
 		{
 			this.identifier = identifier;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1765" endline="1780">
<![CDATA[
 		}
 	}
 
 	//
 	// Opcode casts expression with 2 opcodes but only
 	// single expression tree node
 	//
 	class OpcodeCastDuplex 
 	{
 		readonly OpCode second;
 
 		public OpcodeCastDuplex (Expression child, TypeSpec returnType, OpCode first, OpCode second)
 			
 		{
 			this.second = second;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8998" endline="9013">
<![CDATA[
 	}
 
 
 	//
 	// This class is used to represent the address of an array, used
 	// only by the Fixed statement, this generates "&a [0]" construct
 	// for fixed (char *pa = a)
 	//
 	public class ArrayPtr 
 		TypeSpec array_type;
 		
 		public ArrayPtr (Expression array, TypeSpec array_type, Location l)
 			base (array, array_type, l)
 		{
 			this.array_type = array_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9495" endline="9506">
<![CDATA[
 
 			#endregion
 		}
 
 		CollectionOrObjectInitializers initializers;
 		IMemoryLocation instance;
 
 		public NewInitialize (FullNamedExpression requested_type, Arguments arguments, CollectionOrObjectInitializers initializers, Location l)
 			
 		{
 			this.initializers = initializers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="636" endline="644">
<![CDATA[
 
 		//
 		// When a return type is known not to be dynamic
 		//
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, TypeSpec type, Location loc)
 			
 		{
 			this.type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1613" endline="1623">
<![CDATA[
 	}
 
 	class ImportedGenericMethodDefinition 
 	{
 		readonly TypeParameterSpec[] tparams;
 
 		public ImportedGenericMethodDefinition (MethodInfo provider, TypeSpec type, AParametersCollection parameters, TypeParameterSpec[] tparams, MetadataImporter importer)
 			
 		{
 			this.tparams = tparams;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="242" endline="414">
<![CDATA[
 
 			internal const string Prefix = "set_";
 
 			protected ParametersCompiled parameters;
 
 			public SetMethod (PropertyBase method, Modifiers modifiers, ParametersCompiled parameters, Attributes attrs, Location loc)
 				
 			{
 				this.parameters = parameters;
 			}
 
 			protected override void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Target == AttributeTargets.Parameter) {
 					parameters[0].ApplyAttributeBuilder (a, ctor, cdata, pa);
 					return;
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override ParametersCompiled ParameterInfo {
 			    get {
 			        return parameters;
 			    }
 			}
 
 			public override MethodBuilder Define (DeclSpace parent)
 			{
 				parameters.Resolve (this);
 				
 				base.Define (parent);
 
 				Spec = new MethodSpec (MemberKind.Method, parent.PartialContainer.Definition, this, ReturnType, null, ParameterInfo, ModFlags);
 
 				method_data = new MethodData (method, ModFlags, flags, this);
 
 				if (!method_data.Define (parent, method.GetFullName (MemberName), Report))
 					return null;
 
 				Spec.SetMetaInfo (method_data.MethodBuilder);
 
 				return method_data.MethodBuilder;
 			}
 
 			public override TypeSpec ReturnType {
 				get {
 					return TypeManager.void_type;
 				}
 			}
 
 			public override string[] ValidAttributeTargets {
 				get {
 					return attribute_targets;
 				}
 			}
 		}
 
 		static string[] attribute_targets = new string [] { "property" };
 
 		public abstract class PropertyMethod 
 		{
 			public const Modifiers AllowedModifiers =
 				Modifiers.PUBLIC |
 				Modifiers.PROTECTED |
 				Modifiers.INTERNAL |
 				Modifiers.PRIVATE;
 		
 			protected readonly PropertyBase method;
 			protected MethodAttributes flags;
 
 			public PropertyMethod (PropertyBase method, string prefix, Modifiers modifiers, Attributes attrs, Location loc)
 				
 			{
 				this.method = method;
 				this.ModFlags = modifiers | (method.ModFlags & (Modifiers.STATIC | Modifiers.UNSAFE));
 			}
 
 			public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Type == pa.MethodImpl) {
 					method.is_external_implementation = a.IsInternalCall ();
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override AttributeTargets AttributeTargets {
 				get {
 					return AttributeTargets.Method;
 				}
 			}
 
 			public override bool IsClsComplianceRequired ()
 			{
 				return method.IsClsComplianceRequired ();
 			}
 
 			public virtual MethodBuilder Define (DeclSpace parent)
 			{
 				TypeContainer container = parent.PartialContainer;
 
 				//
 				// Check for custom access modifier
 				//
 				if ((ModFlags & Modifiers.AccessibilityMask) == 0) {
 					ModFlags |= method.ModFlags;
 					flags = method.flags;
 				} else {
 					if (container.Kind == MemberKind.Interface)
 						Report.Error (275, Location, "`{0}'
 							GetSignatureForError ());
 
 					if ((method.ModFlags & Modifiers.ABSTRACT) != 0 && (ModFlags & Modifiers.PRIVATE) != 0) {
 						Report.Error (442, Location, "`{0}'
 					}
 
 					CheckModifiers (ModFlags);
 					ModFlags |= (method.ModFlags & (~Modifiers.AccessibilityMask));
 					ModFlags |= Modifiers.PROPERTY_CUSTOM;
 					flags = ModifiersExtensions.MethodAttr (ModFlags);
 					flags |= (method.flags & (~MethodAttributes.MemberAccessMask));
 				}
 
 				CheckAbstractAndExtern (block != null);
 				CheckProtectedModifier ();
 
 				if (block != null && block.IsIterator)
 					Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 
 				return null;
 			}
 
 			public bool HasCustomAccessModifier {
 				get {
 					return (ModFlags & Modifiers.PROPERTY_CUSTOM) != 0;
 				}
 			}
 
 			public PropertyBase Property {
 				get {
 					return method;
 				}
 			}
 
 			public override ObsoleteAttribute GetAttributeObsolete ()
 			{
 				return method.GetAttributeObsolete ();
 			}
 
 			public override string GetSignatureForError()
 			{
 				return method.GetSignatureForError () + "." + prefix.Substring (0, 3);
 			}
 
 			void CheckModifiers (Modifiers modflags)
 			{
 				if (!ModifiersExtensions.IsRestrictedModifier (modflags & Modifiers.AccessibilityMask, method.ModFlags & Modifiers.AccessibilityMask)) {
 					Report.Error (273, Location,
 						"The accessibility modifier of the `{0}' accessor must be more restrictive than the modifier of the property or indexer `{1}'",
 						GetSignatureForError (), method.GetSignatureForError ());
 				}
 			}
 		}
 
 		PropertyMethod get, set, first;
 		PropertyBuilder PropertyBuilder;
 
 		public PropertyBase (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags,
 				     Modifiers allowed_mod, MemberName name, Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="305" endline="320">
<![CDATA[
 	}
 
 	public class PredefinedType
 	{
 		string name;
 		string ns;
 		int arity;
 		MemberKind kind;
 		ModuleContainer module;
 		protected TypeSpec type;
 
 		public PredefinedType (ModuleContainer module, MemberKind kind, string ns, string name, int arity)
 			
 		{
 			this.arity = arity;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Universe.cs" startline="745" endline="752">
<![CDATA[
 
 #if NET_4_0
 		[Obsolete]
 #endif
 		public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
 		{
 			return DefineDynamicAssemblyImpl(name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="119" endline="508">
<![CDATA[
 		int id;
 
 		// <summary>
 		//   The vector contains a BitArray with information about which local variables
 		//   and parameters are already initialized at the current code position.
 		// </summary>
 		public class UsageVector {
 			// <summary>
 			//   The type of this branching.
 			// </summary>
 			public readonly SiblingType Type;
 
 			// <summary>
 			//   Start location of this branching.
 			// </summary>
 			public Location Location;
 
 			// <summary>
 			//   This is only valid for SwitchSection, Try, Catch and Finally.
 			// </summary>
 			public readonly Block Block;
 
 			// <summary>
 			//   The number of locals in this block.
 			// </summary>
 			public readonly int CountLocals;
 
 			// <summary>
 			//   If not null, then we inherit our state from this vector and do a
 			//   copy-on-write.  If null, then we're the first sibling in a top-level
 			//   block and inherit from the empty vector.
 			// </summary>
 			public readonly UsageVector InheritsFrom;
 
 			// <summary>
 			//   This is used to construct a list of UsageVector's.
 			// </summary>
 			public UsageVector Next;
 
 			//
 			// Private.
 			//
 			MyBitVector locals;
 			bool is_unreachable;
 
 			static int next_id = 0;
 			int id;
 
 			//
 			// Normally, you should not use any of these constructors.
 			//
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc, int num_locals)
 			{
 				this.Type = type;
 				this.Block = block;
 				this.Location = loc;
 				this.InheritsFrom = parent;
 				this.CountLocals = num_locals;
 
 				locals = num_locals == 0 
 					? MyBitVector.Empty
 					
 
 				if (parent != null)
 					is_unreachable = parent.is_unreachable;
 
 				id = ++next_id;
 
 			}
 
 			public UsageVector (SiblingType type, UsageVector parent, Block block, Location loc)
 				
 			{ }
 
 			private UsageVector (MyBitVector locals, bool is_unreachable, Block block, Location loc)
 			{
 				this.Type = SiblingType.Block;
 				this.Location = loc;
 				this.Block = block;
 
 				this.is_unreachable = is_unreachable;
 
 				this.locals = locals;
 
 				id = ++next_id;
 
 			}
 
 			// <summary>
 			//   This does a deep copy of the usage vector.
 			// </summary>
 			public UsageVector Clone ()
 			{
 				UsageVector retval = new UsageVector (Type, null, Block, Location, CountLocals);
 
 				retval.locals = locals.Clone ();
 				retval.is_unreachable = is_unreachable;
 
 				return retval;
 			}
 
 			public bool IsAssigned (VariableInfo var, bool ignoreReachability)
 			{
 				if (!ignoreReachability && !var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsAssigned (locals);
 			}
 
 			public void SetAssigned (VariableInfo var)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetAssigned (locals);
 			}
 
 			public bool IsFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return true;
 
 				return var.IsFieldAssigned (locals, name);
 			}
 
 			public void SetFieldAssigned (VariableInfo var, string name)
 			{
 				if (!var.IsParameter && IsUnreachable)
 					return;
 
 				var.SetFieldAssigned (locals, name);
 			}
 
 			public bool IsUnreachable {
 				get { return is_unreachable; }
 			}
 
 			public void ResetBarrier ()
 			{
 				is_unreachable = false;
 			}
 
 			public void Goto ()
 			{
 				is_unreachable = true;
 			}
 
 			public static UsageVector MergeSiblings (UsageVector sibling_list, Location loc)
 			{
 				if (sibling_list.Next == null)
 					return sibling_list;
 
 				MyBitVector locals = null;
 				bool is_unreachable = sibling_list.is_unreachable;
 
 				if (!sibling_list.IsUnreachable)
 					locals &= sibling_list.locals;
 
 				for (UsageVector child = sibling_list.Next; child != null; child = child.Next) {
 					is_unreachable &= child.is_unreachable;
 
 					if (!child.IsUnreachable)
 						locals &= child.locals;
 				}
 
 				return new UsageVector (locals, is_unreachable, null, loc);
 			}
 
 			// <summary>
 			//   Merges a child branching.
 			// </summary>
 			public UsageVector MergeChild (UsageVector child, bool overwrite)
 			{
 				Report.Debug (2, "    MERGING CHILD EFFECTS", this, child, Type);
 
 				bool new_isunr = child.is_unreachable;
 
 				//
 				// We've now either reached the point after the branching or we will
 				// never get there since we always return or always throw an exception.
 				//
 				// If we can reach the point after the branching, mark all locals and
 				// parameters as initialized which have been initialized in all branches
 				// we need to look at (see above).
 				//
 
 				if ((Type == SiblingType.SwitchSection) && !new_isunr) {
 					Report.Error (163, Location,
 						      "Control cannot fall through from one " +
 						      "case label to another");
 					return child;
 				}
 
 				locals |= child.locals;
 
 				// throw away un-necessary information about variables in child blocks
 				if (locals.Count != CountLocals)
 					locals = new MyBitVector (locals, CountLocals);
 
 				if (overwrite)
 					is_unreachable = new_isunr;
 				else
 					is_unreachable |= new_isunr;
 
 				return child;
 			}
 
 			public void MergeOrigins (UsageVector o_vectors)
 			{
 				Report.Debug (1, "  MERGING BREAK ORIGINS", this);
 
 				if (o_vectors == null)
 					return;
 
 				if (IsUnreachable && locals != null)
 					locals.SetAll (true);
 
 				for (UsageVector vector = o_vectors; vector != null; vector = vector.Next) {
 					Report.Debug (1, "    MERGING BREAK ORIGIN", vector);
 					if (vector.IsUnreachable)
 						continue;
 					locals &= vector.locals;
 					is_unreachable &= vector.is_unreachable;
 				}
 
 				Report.Debug (1, "  MERGING BREAK ORIGINS DONE", this);
 			}
 
 			//
 			// Debugging stuff.
 			//
 
 			public override string ToString ()
 			{
 				return String.Format ("Vector ({0},{1},{2}-{3})", Type, id, is_unreachable, locals);
 			}
 		}
 
 		// <summary>
 		//   Creates a new flow branching which is contained in `parent'.
 		//   You should only pass non-null for the `block' argument if this block
 		//   introduces any new variables - in this case, we need to create a new
 		//   usage vector with a different size than our parent's one.
 		// </summary>
 		protected FlowBranching (FlowBranching parent, BranchingType type, SiblingType stype,
 					 Block block, Location loc)
 		{
 			Parent = parent;
 			Block = block;
 			Location = loc;
 			Type = type;
 			id = ++next_id;
 
 			UsageVector vector;
 			if (Block != null) {
 				UsageVector parent_vector = parent != null ? parent.CurrentUsageVector 
 				vector = new UsageVector (stype, parent_vector, Block, loc, Block.AssignableSlots);
 			} else {
 				vector = new UsageVector (stype, Parent.CurrentUsageVector, null, loc);
 			}
 
 			AddSibling (vector);
 		}
 
 		public abstract UsageVector CurrentUsageVector {
 			get;
 		}				
 
 		// <summary>
 		//   Creates a sibling of the current usage vector.
 		// </summary>
 		public virtual void CreateSibling (Block block, SiblingType type)
 		{
 			UsageVector vector = new UsageVector (
 				type, Parent.CurrentUsageVector, block, Location);
 			AddSibling (vector);
 
 			Report.Debug (1, "  CREATED SIBLING", CurrentUsageVector);
 		}
 
 		public void CreateSibling ()
 		{
 			CreateSibling (null, SiblingType.Conditional);
 		}
 
 		protected abstract void AddSibling (UsageVector uv);
 
 		protected abstract UsageVector Merge ();
 
 		public UsageVector MergeChild (FlowBranching child)
 		{
 			return CurrentUsageVector.MergeChild (child.Merge (), true);
  		}
 
 		public virtual bool CheckRethrow (Location loc)
 		{
 			return Parent.CheckRethrow (loc);
 		}
 
 		public virtual bool AddResumePoint (ResumableStatement stmt, Location loc, out int pc)
 		{
 			return Parent.AddResumePoint (stmt, loc, out pc);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddBreakOrigin (UsageVector vector, Location loc)
 		{
 			return Parent.AddBreakOrigin (vector, loc);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddContinueOrigin (UsageVector vector, Location loc)
 		{
 			return Parent.AddContinueOrigin (vector, loc);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddReturnOrigin (UsageVector vector, ExitStatement stmt)
 		{
 			return Parent.AddReturnOrigin (vector, stmt);
 		}
 
 		// returns true if we crossed an unwind-protected region (try/catch/finally, lock, using, ...)
 		public virtual bool AddGotoOrigin (UsageVector vector, Goto goto_stmt)
 		{
 			return Parent.AddGotoOrigin (vector, goto_stmt);
 		}
 
 		public bool IsAssigned (VariableInfo vi)
 		{
 			return CurrentUsageVector.IsAssigned (vi, false);
 		}
 
 		public bool IsFieldAssigned (VariableInfo vi, string field_name)
 		{
 			return CurrentUsageVector.IsAssigned (vi, false) || CurrentUsageVector.IsFieldAssigned (vi, field_name);
 		}
 
 		protected static Report Report {
 			get { return RootContext.ToplevelTypes.Compiler.Report; }
 		}
 
 		public void SetAssigned (VariableInfo vi)
 		{
 			CurrentUsageVector.SetAssigned (vi);
 		}
 
 		public void SetFieldAssigned (VariableInfo vi, string name)
 		{
 			CurrentUsageVector.SetFieldAssigned (vi, name);
 		}
 
 #if DEBUG
 		public override string ToString ()
 		{
 			StringBuilder sb = new StringBuilder ();
 			sb.Append (GetType ());
 			sb.Append (" (");
 
 			sb.Append (id);
 			sb.Append (",");
 			sb.Append (Type);
 			if (Block != null) {
 				sb.Append (" - ");
 				sb.Append (Block.ID);
 				sb.Append (" - ");
 				sb.Append (Block.StartLocation);
 			}
 			sb.Append (" - ");
 			// sb.Append (Siblings.Length);
 			// sb.Append (" - ");
 			sb.Append (CurrentUsageVector);
 			sb.Append (")");
 			return sb.ToString ();
 		}
 #endif
 
 		public string Name {
 			get { return String.Format ("{0} ({1}
 		}
 	}
 
 	public class FlowBranchingBlock 
 	{
 		UsageVector sibling_list = null;
 
 		public FlowBranchingBlock (FlowBranching parent, BranchingType type,
 					   SiblingType stype, Block block, Location loc)
 			
 		{ }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="186" endline="476">
<![CDATA[
 	}
 
 	public interface IGenericMethodDefinition 
 	{
 		TypeParameterSpec[] TypeParameters { get; }
 		int TypeParametersCount { get; }
 
 //		MethodInfo MakeGenericMethod (TypeSpec[] targs);
 	}
 
 	public sealed class MethodSpec 
 	{
 		MethodBase metaInfo, inflatedMetaInfo;
 		AParametersCollection parameters;
 		TypeSpec returnType;
 
 		TypeSpec[] targs;
 		TypeParameterSpec[] constraints;
 
 		public MethodSpec (MemberKind kind, TypeSpec declaringType, IMemberDefinition details, TypeSpec returnType,
 			MethodBase info, AParametersCollection parameters, Modifiers modifiers)
 			
 		{
 			this.metaInfo = info;
 			this.parameters = parameters;
 			this.returnType = returnType;
 		}
 
 		#region Properties
 
 		public override int Arity {
 			get {
 				return IsGeneric ? GenericDefinition.TypeParametersCount 
 			}
 		}
 
 		public TypeParameterSpec[] Constraints {
 			get {
 				if (constraints == null && IsGeneric)
 					constraints = GenericDefinition.TypeParameters;
 
 				return constraints;
 			}
 		}
 
 		public bool IsConstructor {
 			get {
 				return Kind == MemberKind.Constructor;
 			}
 		}
 
 		public IGenericMethodDefinition GenericDefinition {
 			get {
 				return (IGenericMethodDefinition) definition;
 			}
 		}
 
 		public bool IsExtensionMethod {
 			get {
 				return IsStatic && parameters.HasExtensionMethodType;
 			}
 		}
 
 		public bool IsSealed {
 			get {
 				return (Modifiers & Modifiers.SEALED) != 0;
 			}
 		}
 
 		// When is virtual or abstract
 		public bool IsVirtual {
 			get {
 				return (Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT | Modifiers.OVERRIDE)) != 0;
 			}
 		}
 
 		public bool IsReservedMethod {
 			get {
 				return Kind == MemberKind.Operator || IsAccessor;
 			}
 		}
 
 		TypeSpec IInterfaceMemberSpec.MemberType {
 			get {
 				return returnType;
 			}
 		}
 
 		public AParametersCollection Parameters {
 			get { 
 				return parameters;
 			}
 		}
 
 		public TypeSpec ReturnType {
 			get {
 				return returnType;
 			}
 		}
 
 		public TypeSpec[] TypeArguments {
 			get {
 				return targs;
 			}
 		}
 
 		#endregion
 
 		public MethodSpec GetGenericMethodDefinition ()
 		{
 			if (!IsGeneric && !DeclaringType.IsGeneric)
 				return this;
 
 			return MemberCache.GetMember (declaringType, this);
 		}
 
 		public MethodBase GetMetaInfo ()
 		{
 			//
 			// inflatedMetaInfo is extra field needed for cases where we
 			// inflate method but another nested type can later inflate
 			// again (the cache would be build with inflated metaInfo) and
 			// TypeBuilder can work with method definitions only
 			//
 			if (inflatedMetaInfo == null) {
 				if ((state & StateFlags.PendingMetaInflate) != 0) {
 					var dt_meta = DeclaringType.GetMetaInfo ();
 
 					if (DeclaringType.IsTypeBuilder) {
 						if (IsConstructor)
 							inflatedMetaInfo = TypeBuilder.GetConstructor (dt_meta, (ConstructorInfo) metaInfo);
 						else
 							inflatedMetaInfo = TypeBuilder.GetMethod (dt_meta, (MethodInfo) metaInfo);
 					} else {
 #if STATIC
 						// it should not be reached
 						throw new NotImplementedException ();
 #else
 						inflatedMetaInfo = MethodInfo.GetMethodFromHandle (metaInfo.MethodHandle, dt_meta.TypeHandle);
 #endif
 					}
 
 					state &= ~StateFlags.PendingMetaInflate;
 				} else {
 					inflatedMetaInfo = metaInfo;
 				}
 			}
 
 			if ((state & StateFlags.PendingMakeMethod) != 0) {
 				var sre_targs = new MetaType[targs.Length];
 				for (int i = 0; i < sre_targs.Length; ++i)
 					sre_targs[i] = targs[i].GetMetaInfo ();
 
 				inflatedMetaInfo = ((MethodInfo) inflatedMetaInfo).MakeGenericMethod (sre_targs);
 				state &= ~StateFlags.PendingMakeMethod;
 			}
 
 			return inflatedMetaInfo;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			string name;
 			if (IsConstructor) {
 				name = DeclaringType.GetSignatureForError () + "." + DeclaringType.Name;
 			} else if (Kind == MemberKind.Operator) {
 				var op = Operator.GetType (Name).Value;
 				if (op == Operator.OpType.Implicit || op == Operator.OpType.Explicit) {
 					name = DeclaringType.GetSignatureForError () + "." + Operator.GetName (op) + " operator " + returnType.GetSignatureForError ();
 				} else {
 					name = DeclaringType.GetSignatureForError () + ".operator " + Operator.GetName (op);
 				}
 			} else if (IsAccessor) {
 				int split = Name.IndexOf ('_');
 				name = Name.Substring (split + 1);
 				var postfix = Name.Substring (0, split);
 				if (split == 3) {
 					var pc = parameters.Count;
 					if (pc > 0 && postfix == "get") {
 						name = "this" + parameters.GetSignatureForError ("[", "]", pc);
 					} else if (pc > 1 && postfix == "set") {
 						name = "this" + parameters.GetSignatureForError ("[", "]", pc - 1);
 					}
 				}
 
 				return DeclaringType.GetSignatureForError () + "." + name + "." + postfix;
 			} else {
 				name = base.GetSignatureForError ();
 				if (targs != null)
 					name += "<" + TypeManager.CSharpName (targs) + ">";
 				else if (IsGeneric)
 					name += "<" + TypeManager.CSharpName (GenericDefinition.TypeParameters) + ">";
 			}
 
 			return name + parameters.GetSignatureForError ();
 		}
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var ms = (MethodSpec) base.InflateMember (inflator);
 			ms.inflatedMetaInfo = null;
 			ms.returnType = inflator.Inflate (returnType);
 			ms.parameters = parameters.Inflate (inflator);
 			if (IsGeneric)
 				ms.constraints = TypeParameterSpec.InflateConstraints (inflator, Constraints);
 
 			return ms;
 		}
 
 		public MethodSpec MakeGenericMethod (params TypeSpec[] targs)
 		{
 			if (targs == null)
 				throw new ArgumentNullException ();
 // TODO MemberCache
 //			if (generic_intances != null && generic_intances.TryGetValue (targs, out ginstance))
 //				return ginstance;
 
 			//if (generic_intances == null)
 			//    generic_intances = new Dictionary<TypeSpec[], Method> (TypeSpecArrayComparer.Default);
 
 			var inflator = new TypeParameterInflator (DeclaringType, GenericDefinition.TypeParameters, targs);
 
 			var inflated = (MethodSpec) MemberwiseClone ();
 			inflated.declaringType = inflator.TypeInstance;
 			inflated.returnType = inflator.Inflate (returnType);
 			inflated.parameters = parameters.Inflate (inflator);
 			inflated.targs = targs;
 			inflated.constraints = TypeParameterSpec.InflateConstraints (inflator, constraints ?? GenericDefinition.TypeParameters);
 			inflated.state |= StateFlags.PendingMakeMethod;
 
 			//			if (inflated.parent == null)
 			//				inflated.parent = parent;
 
 			//generic_intances.Add (targs, inflated);
 			return inflated;
 		}
 
 		public MethodSpec Mutate (TypeParameterMutator mutator)
 		{
 			var targs = TypeArguments;
 			if (targs != null)
 				targs = mutator.Mutate (targs);
 
 			var decl = DeclaringType;
 			if (DeclaringType.IsGenericOrParentIsGeneric) {
 				decl = mutator.Mutate (decl);
 			}
 
 			if (targs == TypeArguments && decl == DeclaringType)
 				return this;
 
 			var ms = (MethodSpec) MemberwiseClone ();
 			if (decl != DeclaringType) {
 				ms.inflatedMetaInfo = null;
 				ms.declaringType = decl;
 				ms.state |= StateFlags.PendingMetaInflate;
 			}
 
 			if (targs != null) {
 				ms.targs = targs;
 				ms.state |= StateFlags.PendingMakeMethod;
 			}
 
 			return ms;
 		}
 
 		public void SetMetaInfo (MethodInfo info)
 		{
 			if (this.metaInfo != null)
 				throw new InternalErrorException ("MetaInfo reset");
 
 			this.metaInfo = info;
 		}
 	}
 
 	public abstract class MethodOrOperator 
 	{
 		public MethodBuilder MethodBuilder;
 		ReturnParameter return_attributes;
 		SecurityType declarative_security;
 		protected MethodData MethodData;
 
 		static string[] attribute_targets = new string [] { "method", "return" };
 
 		protected MethodOrOperator (DeclSpace parent, GenericMethod generic, FullNamedExpression type, Modifiers mod,
 				Modifiers allowed_mod, MemberName name,
 				Attributes attrs, ParametersCompiled parameters)
 			
 					attrs, parameters)
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1322" endline="1336">
<![CDATA[
 	}
 
 	/// <summary>
 	///  This class is used to wrap literals which belong inside Enums
 	/// </summary>
 	public class EnumConstant 
 	{
 		public Constant Child;
 
 		public EnumConstant (Constant child, TypeSpec enum_type)
 			
 		{
 			this.Child = child;
 			this.type = enum_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1796" endline="1802">
<![CDATA[
 
 		public TypeParameterName (string name, Attributes attrs, Variance variance, Location loc)
 			
 		{
 			attributes = attrs;
 			this.variance = variance;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="2229" endline="2235">
<![CDATA[
 
 		public GenericMethod (NamespaceEntry ns, DeclSpace parent, MemberName name, TypeParameter[] tparams,
 					  FullNamedExpression return_type, ParametersCompiled parameters)
 			
 		{
 			this.type_params = tparams;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="718" endline="1185">
<![CDATA[
 				switch (ExplicitTarget) {
 				case "return"
 				case "param"
 				case "field"
 				case "method"
 				case "property"
 				case "module"
 				}
 				throw new InternalErrorException ("Unknown explicit target
 			}
 				
 			StringBuilder sb = new StringBuilder ();
 			foreach (string s in valid_targets) {
 				sb.Append (s);
 				sb.Append (", ");
 			}
 			sb.Remove (sb.Length - 2, 2);
 			Report.Error (657, Location, "`{0}' is not a valid attribute location for this declaration. " +
 				"Valid attribute locations for this declaration are `{1}'", ExplicitTarget, sb.ToString ());
 			return false;
 		}
 
 		/// <summary>
 		/// Tests permitted SecurityAction for assembly or other types
 		/// </summary>
 		protected virtual bool IsSecurityActionValid (bool for_assembly)
 		{
 			SecurityAction action = GetSecurityActionValue ();
 
 			switch (action) {
 #pragma warning disable 618
 			case SecurityAction.Demand
 			case SecurityAction.Assert
 			case SecurityAction.Deny
 			case SecurityAction.PermitOnly
 			case SecurityAction.LinkDemand
 			case SecurityAction.InheritanceDemand
 				if (!for_assembly)
 					return true;
 				break;
 
 			case SecurityAction.RequestMinimum
 			case SecurityAction.RequestOptional
 			case SecurityAction.RequestRefuse
 				if (for_assembly)
 					return true;
 				break;
 #pragma warning restore 618
 
 			default
 				Error_AttributeEmitError ("SecurityAction is out of range");
 				return false;
 			}
 
 			Error_AttributeEmitError (String.Concat ("SecurityAction `", action, "' is not valid for this declaration"));
 			return false;
 		}
 
 		System.Security.Permissions.SecurityAction GetSecurityActionValue ()
 		{
 			return (SecurityAction) ((Constant) PosArguments[0].Expr).GetValue ();
 		}
 
 		/// <summary>
 		/// Creates instance of SecurityAttribute class and add result of CreatePermission method to permission table.
 		/// </summary>
 		/// <returns></returns>
 		public void ExtractSecurityPermissionSet (MethodSpec ctor, ref SecurityType permissions)
 		{
 #if STATIC
 			object[] values = new object [PosArguments.Count];
 			for (int i = 0; i < values.Length; ++i)
 				values [i] = ((Constant) PosArguments [i].Expr).GetValue ();
 
 			PropertyInfo[] prop;
 			object[] prop_values;
 			if (named_values == null) {
 				prop = null;
 				prop_values = null;
 			} else {
 				prop = new PropertyInfo[named_values.Count];
 				prop_values = new object [named_values.Count];
 				for (int i = 0; i < prop.Length; ++i) {
 					prop [i] = ((PropertyExpr) named_values [i].Key).PropertyInfo.MetaInfo;
 					prop_values [i] = ((Constant) named_values [i].Value.Expr).GetValue ();
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			var cab = new CustomAttributeBuilder ((ConstructorInfo) ctor.GetMetaInfo (), values, prop, prop_values);
 			permissions.Add (cab);
 #else
 			Type orig_assembly_type = null;
 
 			if (Type.MemberDefinition is TypeContainer) {
 				if (!RootContext.StdLib) {
 					orig_assembly_type = System.Type.GetType (Type.GetMetaInfo ().FullName);
 				} else {
 					string orig_version_path = Environment.GetEnvironmentVariable ("__SECURITY_BOOTSTRAP_DB");
 					if (orig_version_path == null) {
 						Error_AttributeEmitError ("security custom attributes can not be referenced from defining assembly");
 						return;
 					}
 
 					if (orig_sec_assembly == null) {
 						string file = Path.Combine (orig_version_path, Path.GetFileName (RootContext.OutputFile));
 						orig_sec_assembly = Assembly.LoadFile (file);
 					}
 
 					orig_assembly_type = orig_sec_assembly.GetType (Type.GetMetaInfo ().FullName, true);
 					if (orig_assembly_type == null) {
 						Report.Warning (-112, 1, Location, "Self-referenced security attribute `{0}' " +
 								"was not found in previous version of assembly");
 						return;
 					}
 				}
 			}
 
 			SecurityAttribute sa;
 			object[] args;
 
 			// For all non-selfreferencing security attributes we can avoid all hacks
 			if (orig_assembly_type == null) {
 				args = new object[PosArguments.Count];
 				for (int j = 0; j < args.Length; ++j) {
 					args[j] = ((Constant) PosArguments[j].Expr).GetValue ();
 				}
 
 				sa = (SecurityAttribute) Activator.CreateInstance (Type.GetMetaInfo (), args);
 
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						pi.SetValue (sa, ((Constant) named_values [i].Value.Expr).GetValue (), null);
 					}
 				}
 			} else {
 				// HACK
 				args = new object[] { GetSecurityActionValue () };
 				sa = (SecurityAttribute) Activator.CreateInstance (orig_assembly_type, args);
 
 				// All types are from newly created assembly but for invocation with old one we need to convert them
 				if (named_values != null) {
 					for (int i = 0; i < named_values.Count; ++i) {
 						PropertyInfo emited_pi = ((PropertyExpr) named_values[i].Key).PropertyInfo.MetaInfo;
 						// FIXME
 						// TODO
 						PropertyInfo pi = orig_assembly_type.GetProperty (emited_pi.Name);
 
 						pi.SetValue (sa, ((Constant) named_values[i].Value.Expr).GetValue (), null);
 					}
 				}
 			}
 
 			IPermission perm;
 			perm = sa.CreatePermission ();
 			SecurityAction action = (SecurityAction) args [0];
 
 			// IS is correct because for corlib we are using an instance from old corlib
 			if (!(perm is System.Security.CodeAccessPermission)) {
 				switch (action) {
 				case SecurityAction.Demand
 					action = (SecurityAction)13;
 					break;
 				case SecurityAction.LinkDemand
 					action = (SecurityAction)14;
 					break;
 				case SecurityAction.InheritanceDemand
 					action = (SecurityAction)15;
 					break;
 				}
 			}
 
 			if (permissions == null)
 				permissions = new SecurityType ();
 
 			PermissionSet ps;
 			if (!permissions.TryGetValue (action, out ps)) {
 				if (sa is PermissionSetAttribute)
 					ps = new PermissionSet (sa.Unrestricted ? PermissionState.Unrestricted 
 				else
 					ps = new PermissionSet (PermissionState.None);
 
 				permissions.Add (action, ps);
 			} else if (!ps.IsUnrestricted () && (sa is PermissionSetAttribute) && sa.Unrestricted) {
 				ps = ps.Union (new PermissionSet (PermissionState.Unrestricted));
 				permissions [action] = ps;
 			}
 			ps.AddPermission (perm);
 #endif
 		}
 
 		public Constant GetNamedValue (string name)
 		{
 			if (named_values == null)
 				return null;
 
 			for (int i = 0; i < named_values.Count; ++i) {
 				if (named_values [i].Value.Name == name)
 					return named_values [i].Value.Expr as Constant;
 			}
 
 			return null;
 		}
 
 		public CharSet GetCharSetValue ()
 		{
 			return (CharSet)System.Enum.Parse (typeof (CharSet), ((Constant) PosArguments [0].Expr).GetValue ().ToString ());
 		}
 
 		public bool HasField (string fieldName)
 		{
 			if (named_values == null)
 				return false;
 
 			foreach (var na in named_values) {
 				if (na.Value.Name == fieldName)
 					return true;
 			}
 
 			return false;
 		}
 
 		//
 		// Returns true for MethodImplAttribute with MethodImplOptions.InternalCall value
 		// 
 		public bool IsInternalCall ()
 		{
 			MethodImplOptions options = 0;
 			if (PosArguments.Count == 1) {
 				options = (MethodImplOptions) System.Enum.Parse (typeof (MethodImplOptions), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 			} else if (HasField ("Value")) {
 				var named = GetNamedValue ("Value");
 				options = (MethodImplOptions) System.Enum.Parse (typeof (MethodImplOptions), named.GetValue ().ToString ());
 			}
 
 			return (options & MethodImplOptions.InternalCall) != 0;
 		}
 
 		//
 		// Returns true for StructLayoutAttribute with LayoutKind.Explicit value
 		// 
 		public bool IsExplicitLayoutKind ()
 		{
 			if (PosArguments == null || PosArguments.Count != 1)
 				return false;
 
 			var value = (LayoutKind) System.Enum.Parse (typeof (LayoutKind), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 			return value == LayoutKind.Explicit;
 		}
 
 		public Expression GetParameterDefaultValue ()
 		{
 			if (PosArguments == null)
 				return null;
 
 			return PosArguments[0].Expr;
 		}
 
 		public override bool Equals (object obj)
 		{
 			Attribute a = obj as Attribute;
 			if (a == null)
 				return false;
 
 			return Type == a.Type && Target == a.Target;
 		}
 
 		public override int GetHashCode ()
 		{
 			return type.GetHashCode () ^ Target.GetHashCode ();
 		}
 
 		/// <summary>
 		/// Emit attribute for Attributable symbol
 		/// </summary>
 		public void Emit (Dictionary<Attribute, List<Attribute>> allEmitted)
 		{
 			var ctor = Resolve ();
 			if (ctor == null)
 				return;
 
 			var predefined = context.Module.PredefinedAttributes;
 
 			AttributeUsageAttribute usage_attr = Type.GetAttributeUsage (predefined.AttributeUsage);
 			if ((usage_attr.ValidOn & Target) == 0) {
 				Report.Error (592, Location, "The attribute `{0}' is not valid on this declaration type. " +
 					      "It is valid on `{1}' declarations only",
 					GetSignatureForError (), GetValidTargets ());
 				return;
 			}
 
 			byte[] cdata;
 			if (PosArguments == null && named_values == null) {
 				cdata = AttributeEncoder.Empty;
 			} else {
 				AttributeEncoder encoder = new AttributeEncoder ();
 
 				if (PosArguments != null) {
 					var param_types = ctor.Parameters.Types;
 					for (int j = 0; j < PosArguments.Count; ++j) {
 						var pt = param_types[j];
 						var arg_expr = PosArguments[j].Expr;
 						if (j == 0) {
 							if (Type == predefined.IndexerName || Type == predefined.Conditional) {
 								string v = ((StringConstant) arg_expr).Value;
 								if (!Tokenizer.IsValidIdentifier (v) || Tokenizer.IsKeyword (v)) {
 									context.Compiler.Report.Error (633, arg_expr.Location,
 										"The argument to the `{0}' attribute must be a valid identifier", GetSignatureForError ());
 								}
 							} else if (Type == predefined.Guid) {
 								try {
 									string v = ((StringConstant) arg_expr).Value;
 									new Guid (v);
 								} catch (Exception e) {
 									Error_AttributeEmitError (e.Message);
 									return;
 								}
 							} else if (Type == predefined.AttributeUsage) {
 								int v = ((IntConstant) ((EnumConstant) arg_expr).Child).Value;
 								if (v == 0) {
 									context.Compiler.Report.Error (591, Location, "Invalid value for argument to `{0}' attribute",
 										"System.AttributeUsage");
 								}
 							} else if (Type == predefined.MarshalAs) {
 								if (PosArguments.Count == 1) {
 									var u_type = (UnmanagedType) System.Enum.Parse (typeof (UnmanagedType), ((Constant) PosArguments[0].Expr).GetValue ().ToString ());
 									if (u_type == UnmanagedType.ByValArray && !(Owner is FieldBase)) {
 										Error_AttributeEmitError ("Specified unmanaged type is only valid on fields");
 									}
 								}
 							} else if (Type == predefined.DllImport) {
 								if (PosArguments.Count == 1) {
 									var value = ((Constant) PosArguments[0].Expr).GetValue () as string;
 									if (string.IsNullOrEmpty (value))
 										Error_AttributeEmitError ("DllName cannot be empty");
 								}
 							} else if (Type == predefined.MethodImpl && pt == TypeManager.short_type &&
 								!System.Enum.IsDefined (typeof (MethodImplOptions), ((Constant) arg_expr).GetValue ().ToString ())) {
 								Error_AttributeEmitError ("Incorrect argument value.");
 								return;
 							}
 						}
 
 						arg_expr.EncodeAttributeValue (context, encoder, pt);
 					}
 				}
 
 				if (named_values != null) {
 					encoder.Encode ((ushort) named_values.Count);
 					foreach (var na in named_values) {
 						if (na.Key is FieldExpr)
 							encoder.Encode ((byte) 0x53);
 						else
 							encoder.Encode ((byte) 0x54);
 
 						encoder.Encode (na.Key.Type);
 						encoder.Encode (na.Value.Name);
 						na.Value.Expr.EncodeAttributeValue (context, encoder, na.Key.Type);
 					}
 				} else {
 					encoder.EncodeEmptyNamedArguments ();
 				}
 
 				cdata = encoder.ToArray ();
 			}
 
 			try {
 				foreach (Attributable target in targets)
 					target.ApplyAttributeBuilder (this, ctor, cdata, predefined);
 			} catch (Exception e) {
 				Error_AttributeEmitError (e.Message);
 				return;
 			}
 
 			if (!usage_attr.AllowMultiple && allEmitted != null) {
 				if (allEmitted.ContainsKey (this)) {
 					var a = allEmitted [this];
 					if (a == null) {
 						a = new List<Attribute> (2);
 						allEmitted [this] = a;
 					}
 					a.Add (this);
 				} else {
 					allEmitted.Add (this, null);
 				}
 			}
 
 			if (!RootContext.VerifyClsCompliance)
 				return;
 
 			// Here we are testing attribute arguments for array usage (error 3016)
 			if (Owner.IsClsComplianceRequired ()) {
 				if (PosArguments != null)
 					PosArguments.CheckArrayAsAttribute (context.Compiler);
 			
 				if (NamedArguments == null)
 					return;
 
 				NamedArguments.CheckArrayAsAttribute (context.Compiler);
 			}
 		}
 
 		private Expression GetValue () 
 		{
 			if (PosArguments == null || PosArguments.Count < 1)
 				return null;
 
 			return PosArguments [0].Expr;
 		}
 
 		public string GetString () 
 		{
 			Expression e = GetValue ();
 			if (e is StringConstant)
 				return ((StringConstant)e).Value;
 			return null;
 		}
 
 		public bool GetBoolean () 
 		{
 			Expression e = GetValue ();
 			if (e is BoolConstant)
 				return ((BoolConstant)e).Value;
 			return false;
 		}
 
 		public TypeSpec GetArgumentType ()
 		{
 			TypeOf e = GetValue () as TypeOf;
 			if (e == null)
 				return null;
 			return e.TypeArgument;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			throw new NotSupportedException ("ET");
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			throw new NotImplementedException ();
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			throw new NotImplementedException ();
 		}
 	}
 	
 
 	/// <summary>
 	/// For global attributes (assembly, module) we need special handling.
 	/// Attributes can be located in the several files
 	/// </summary>
 	public class GlobalAttribute 
 	{
 		public readonly NamespaceEntry ns;
 
 		public GlobalAttribute (NamespaceEntry ns, string target, ATypeNameExpression expression,
 					Arguments[] args, Location loc, bool nameEscaped)
 			base (target, expression, args, loc, nameEscaped)
 		{
 			this.ns = ns;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\argument.cs" startline="174" endline="180">
<![CDATA[
 
 		public NamedArgument (string name, Location loc, Expression expr, AType modifier)
 			
 		{
 			this.Name = name;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="694" endline="701">
<![CDATA[
 
 		public SourceFileEntry (MonoSymbolFile file, string file_name,
 					byte[] guid, byte[] checksum)
 			
 		{
 			this.guid = guid;
 			this.hash = checksum;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="389" endline="397">
<![CDATA[
 	}
 
 	class QueryStartClause 
 	{
 		public QueryStartClause (QueryBlock block, Expression expr, RangeVariable identifier, Location loc)
 			
 		{
 			block.AddRangeVariable (identifier);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="717" endline="725">
<![CDATA[
 		}
 
 		readonly ParameterReference parameter;
 
 		public HoistedParameter (AnonymousMethodStorey scope, ParameterReference par)
 			
 		{
 			this.parameter = par;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="755" endline="766">
<![CDATA[
 		}
 	}
 
 	class HoistedLocalVariable 
 	{
 		readonly string name;
 
 		public HoistedLocalVariable (AnonymousMethodStorey scope, LocalVariable local, string name)
 			
 		{
 			this.name = local.Name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="591" endline="603">
<![CDATA[
 		}
 
 		// Used for underlying binary operator
 		readonly Binary.Operator op;
 		Expression right;
 		Expression left;
 
 		public CompoundAssign (Binary.Operator op, Expression target, Expression source, Location loc)
 			
 		{
 			right = source;
 			this.op = op;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1402" endline="1409">
<![CDATA[
 		public AnonymousMethodBody (ParametersCompiled parameters,
 					ParametersBlock block, TypeSpec return_type, TypeSpec delegate_type,
 					Location loc)
 			
 		{
 			this.type = delegate_type;
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="524" endline="536">
<![CDATA[
 		}
 	}
 
 	public class GroupJoin 
 	{
 		readonly RangeVariable into;
 
 		public GroupJoin (QueryBlock block, RangeVariable lt, Expression inner,
 			QueryBlock outerSelector, QueryBlock innerSelector, RangeVariable into, Location loc)
 			
 		{
 			this.into = into;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1593" endline="1603">
<![CDATA[
 	}
 
 	public class IndexerSpec 
 	{
 		AParametersCollection parameters;
 
 		public IndexerSpec (TypeSpec declaringType, IMemberDefinition definition, TypeSpec memberType, AParametersCollection parameters, PropertyInfo info, Modifiers modifiers)
 			
 		{
 			this.parameters = parameters;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="459" endline="736">
<![CDATA[
 	}
 
 	public abstract class MethodOrOperator 
 	{
 		public MethodBuilder MethodBuilder;
 		ReturnParameter return_attributes;
 		SecurityType declarative_security;
 		protected MethodData MethodData;
 
 		static string[] attribute_targets = new string [] { "method", "return" };
 
 		protected MethodOrOperator (DeclSpace parent, GenericMethod generic, FullNamedExpression type, Modifiers mod,
 				Modifiers allowed_mod, MemberName name,
 				Attributes attrs, ParametersCompiled parameters)
 			
 					attrs, parameters)
 		{
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.MethodImpl) {
 				is_external_implementation = a.IsInternalCall ();
 			}
 
 			if (a.Type == pa.DllImport) {
 				const Modifiers extern_static = Modifiers.EXTERN | Modifiers.STATIC;
 				if ((ModFlags & extern_static) != extern_static) {
 					Report.Error (601, a.Location, "The DllImport attribute must be specified on a method marked `static' and `extern'");
 				}
 				is_external_implementation = true;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (MethodBuilder != null)
 				MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Method; 
 			}
 		}
 
 		protected override bool CheckForDuplications ()
 		{
 			return Parent.MemberCache.CheckExistingMembersOverloads (this, parameters);
 		}
 
 		public virtual EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			return new EmitContext (this, ig, MemberType);
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!CheckBase ())
 				return false;
 
 			MemberKind kind;
 			if (this is Operator)
 				kind = MemberKind.Operator;
 			else if (this is Destructor)
 				kind = MemberKind.Destructor;
 			else
 				kind = MemberKind.Method;
 
 			if (IsPartialDefinition) {
 				caching_flags &= ~Flags.Excluded_Undetected;
 				caching_flags |= Flags.Excluded;
 
 				// Add to member cache only when a partial method implementation has not been found yet
 				if ((caching_flags & Flags.PartialDefinitionExists) == 0) {
 //					MethodBase mb = new PartialMethodDefinitionInfo (this);
 
 					spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, null, parameters, ModFlags);
 					Parent.MemberCache.AddMember (spec);
 				}
 
 				return true;
 			}
 
 			MethodData = new MethodData (
 				this, ModFlags, flags, this, MethodBuilder, GenericMethod, base_method);
 
 			if (!MethodData.Define (Parent.PartialContainer, GetFullName (MemberName), Report))
 				return false;
 					
 			MethodBuilder = MethodData.MethodBuilder;
 
 			spec = new MethodSpec (kind, Parent.Definition, this, ReturnType, MethodBuilder, parameters, ModFlags);
 			if (MemberName.Arity > 0)
 				spec.IsGeneric = true;
 			
 			Parent.MemberCache.AddMember (this, MethodBuilder.Name, spec);
 
 			return true;
 		}
 
 		protected override void DoMemberTypeIndependentChecks ()
 		{
 			base.DoMemberTypeIndependentChecks ();
 
 			CheckAbstractAndExtern (block != null);
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0) {
 				for (int i = 0; i < parameters.Count; ++i) {
 					IParameterData p = parameters.FixedParameters [i];
 					if (p.ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (752, Location, "`{0}'
 							GetSignatureForError ());
 					}
 
 					if (p.HasDefaultValue && IsPartialImplementation)
 						((Parameter) p).Warning_UselessOptionalParameter (Report);
 				}
 			}
 		}
 
 		protected override void DoMemberTypeDependentChecks ()
 		{
 			base.DoMemberTypeDependentChecks ();
 
 			if (MemberType.IsStatic) {
 				Error_StaticReturnType ();
 			}
 		}
 
 		public override void Emit ()
 		{
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (MethodBuilder);
 			if ((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0)
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			if (MethodData != null)
 				MethodData.Emit (Parent);
 
 			base.Emit ();
 
 			Block = null;
 			MethodData = null;
 		}
 
 		protected void Error_ConditionalAttributeIsNotValid ()
 		{
 			Report.Error (577, Location,
 				"Conditional not valid on `{0}' because it is a constructor, destructor, operator or explicit interface implementation",
 				GetSignatureForError ());
 		}
 
 		public bool IsPartialDefinition {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block == null;
 			}
 		}
 
 		public bool IsPartialImplementation {
 			get {
 				return (ModFlags & Modifiers.PARTIAL) != 0 && Block != null;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#region IMethodData Members
 
 		public TypeSpec ReturnType {
 			get {
 				return MemberType;
 			}
 		}
 
 		public MemberName MethodName {
 			get {
 				return MemberName;
 			}
 		}
 
 		/// <summary>
 		/// Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
 		/// </summary>
 		public override string[] ConditionalConditions ()
 		{
 			if ((caching_flags & (Flags.Excluded_Undetected | Flags.Excluded)) == 0)
 				return null;
 
 			if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.Excluded) != 0)
 				return new string [0];
 
 			caching_flags &= ~Flags.Excluded_Undetected;
 			string[] conditions;
 
 			if (base_method == null) {
 				if (OptAttributes == null)
 					return null;
 
 				Attribute[] attrs = OptAttributes.SearchMulti (Module.PredefinedAttributes.Conditional);
 				if (attrs == null)
 					return null;
 
 				conditions = new string[attrs.Length];
 				for (int i = 0; i < conditions.Length; ++i)
 					conditions[i] = attrs[i].GetConditionalAttributeValue ();
 			} else {
 				conditions = base_method.MemberDefinition.ConditionalConditions();
 			}
 
 			if (conditions != null)
 				caching_flags |= Flags.Excluded;
 
 			return conditions;
 		}
 
 		GenericMethod IMethodData.GenericMethod {
 			get {
 				return GenericMethod;
 			}
 		}
 
 		public virtual void EmitExtraSymbolInfo (SourceMethod source)
 		{ }
 
 		#endregion
 
 	}
 
 	public class SourceMethod 
 	{
 		MethodBase method;
 		SourceMethodBuilder builder;
 
 		protected SourceMethod (DeclSpace parent, MethodBase method, ICompileUnit file)
 		{
 			this.method = method;
 			
 			builder = SymbolWriter.OpenMethod (file, parent.NamespaceEntry.SymbolFileID, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1387" endline="1405">
<![CDATA[
 	}
 
 	public class ImportedAssemblyDefinition 
 	{
 		readonly Assembly assembly;
 		readonly AssemblyName aname;
 		readonly MetadataImporter importer;
 		bool cls_compliant;
 		bool contains_extension_methods;
 
 		List<AssemblyName> internals_visible_to;
 		Dictionary<IAssemblyDefinition, AssemblyName> internals_visible_to_cache;
 
 		public ImportedAssemblyDefinition (Assembly assembly, MetadataImporter importer)
 		{
 			this.assembly = assembly;
 			this.aname = assembly.GetName ();
 			this.importer = importer;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="76" endline="88">
<![CDATA[
 
 		protected abstract int GetLength();
 	}
 
 	sealed class TableHeap 
 	{
 		internal void Freeze(MetadataWriter mw)
 		{
 			if (frozen)
 				throw new InvalidOperationException();
 			frozen = true;
 			unalignedlength = GetLength(mw);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="684" endline="693">
<![CDATA[
 		}
 
 		public SourceFileEntry (MonoSymbolFile file, string file_name)
 		{
 			this.file = file;
 			this.file_name = file_name;
 			this.Index = file.AddSource (this);
 
 			creating = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2005" endline="2069">
<![CDATA[
 		}
 
 		[Flags]
 		public enum Operator {
 			Multiply	= 0 | ArithmeticMask,
 			Division	= 1 | ArithmeticMask,
 			Modulus		= 2 | ArithmeticMask,
 			Addition	= 3 | ArithmeticMask | AdditionMask,
 			Subtraction = 4 | ArithmeticMask | SubtractionMask,
 
 			LeftShift	= 5 | ShiftMask,
 			RightShift	= 6 | ShiftMask,
 
 			LessThan	= 7 | ComparisonMask | RelationalMask,
 			GreaterThan	= 8 | ComparisonMask | RelationalMask,
 			LessThanOrEqual		= 9 | ComparisonMask | RelationalMask,
 			GreaterThanOrEqual	= 10 | ComparisonMask | RelationalMask,
 			Equality	= 11 | ComparisonMask | EqualityMask,
 			Inequality	= 12 | ComparisonMask | EqualityMask,
 
 			BitwiseAnd	= 13 | BitwiseMask,
 			ExclusiveOr	= 14 | BitwiseMask,
 			BitwiseOr	= 15 | BitwiseMask,
 
 			LogicalAnd	= 16 | LogicalMask,
 			LogicalOr	= 17 | LogicalMask,
 
 			//
 			// Operator masks
 			//
 			ValuesOnlyMask	= ArithmeticMask - 1,
 			ArithmeticMask	= 1 << 5,
 			ShiftMask		= 1 << 6,
 			ComparisonMask	= 1 << 7,
 			EqualityMask	= 1 << 8,
 			BitwiseMask		= 1 << 9,
 			LogicalMask		= 1 << 10,
 			AdditionMask	= 1 << 11,
 			SubtractionMask	= 1 << 12,
 			RelationalMask	= 1 << 13
 		}
 
 		protected enum State
 		{
 			None = 0,
 			Compound = 1 << 1,
 			LeftNullLifted = 1 << 2,
 			RightNullLifted = 1 << 3
 		}
 
 		readonly Operator oper;
 		protected Expression left, right;
 		protected State state;
 		Expression enum_conversion;
 
 		static PredefinedOperator[] standard_operators;
 		static PredefinedOperator[] equality_operators;
 		static PredefinedOperator[] pointer_operators;
 		
 		public Binary (Operator oper, Expression left, Expression right, bool isCompound, Location loc)
 			
 		{
 			if (isCompound)
 				state |= State.Compound;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="85" endline="95">
<![CDATA[
 		public BlockContext (IMemberContext mc, ExplicitBlock block, TypeSpec returnType)
 			
 		{
 			if (returnType == null)
 				throw new ArgumentNullException ("returnType");
 
 			this.return_type = returnType;
 
 			// TODO
 			CurrentBlock = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8834" endline="8905">
<![CDATA[
 
 		public readonly int Dimension;
 		public readonly Location Location;
 
 		public ComposedTypeSpecifier (int specifier, Location loc)
 		{
 			this.Dimension = specifier;
 			this.Location = loc;
 		}
 
 		#region Properties
 		public bool IsNullable {
 			get {
 				return Dimension == -1;
 			}
 		}
 
 		public bool IsPointer {
 			get {
 				return Dimension == -2;
 			}
 		}
 
 		public ComposedTypeSpecifier Next { get; set; }
 
 		#endregion
 
 		public static ComposedTypeSpecifier CreateArrayDimension (int dimension, Location loc)
 		{
 			return new ComposedTypeSpecifier (dimension, loc);
 		}
 
 		public static ComposedTypeSpecifier CreateNullable (Location loc)
 		{
 			return new ComposedTypeSpecifier (-1, loc);
 		}
 
 		public static ComposedTypeSpecifier CreatePointer (Location loc)
 		{
 			return new ComposedTypeSpecifier (-2, loc);
 		}
 
 		public string GetSignatureForError ()
 		{
 			string s =
 				IsPointer ? "*" 
 				IsNullable ? "?" 
 				ArrayContainer.GetPostfixSignature (Dimension);
 
 			return Next != null ? s + Next.GetSignatureForError () 
 		}
 	}
 
 	// <summary>
 	//   This class is used to "construct" the type during a typecast
 	//   operation.  Since the Type.GetType class in .NET can parse
 	//   the type specification, we just use this to construct the type
 	//   one bit at a time.
 	// </summary>
 	public class ComposedCast 
 		FullNamedExpression left;
 		ComposedTypeSpecifier spec;
 		
 		public ComposedCast (FullNamedExpression left, ComposedTypeSpecifier spec)
 		{
 			if (spec == null)
 				throw new ArgumentNullException ("spec");
 
 			this.left = left;
 			this.spec = spec;
 			this.loc = spec.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="479" endline="490">
<![CDATA[
 
 		private string GetTypeName(int typeNamespace, int typeName)
 		{
 			if (typeNamespace == 0)
 			{
 				return GetString(typeName);
 			}
 			else
 			{
 				return GetString(typeNamespace) + "." + GetString(typeName);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="64" endline="71">
<![CDATA[
 		protected FieldBase (DeclSpace parent, FullNamedExpression type, Modifiers mod,
 				     Modifiers allowed_mod, MemberName name, Attributes attrs)
 			
 				name, attrs)
 		{
 			if ((mod & Modifiers.ABSTRACT) != 0)
 				Report.Error (681, Location, "The modifier 'abstract' is not valid on fields. Try using a property instead");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="122" endline="244">
<![CDATA[
 
 			#endregion
 		}
 
 		[Flags]
 		enum CachedMethods
 		{
 			Equals				= 1,
 			GetHashCode			= 1 << 1,
 			HasStaticFieldInitializer	= 1 << 2
 		}
 
 
 		// Whether this is a struct, class or interface
 		public readonly MemberKind Kind;
 
 		// Holds a list of classes and structures
 		protected List<TypeContainer> types;
 
 		List<MemberCore> ordered_explicit_member_list;
 		List<MemberCore> ordered_member_list;
 
 		// Holds the list of properties
 		List<MemberCore> properties;
 
 		// Holds the list of constructors
 		protected List<Constructor> instance_constructors;
 
 		// Holds the list of fields
 		protected List<FieldBase> fields;
 
 		// Holds a list of fields that have initializers
 		protected List<FieldInitializer> initialized_fields;
 
 		// Holds a list of static fields that have initializers
 		protected List<FieldInitializer> initialized_static_fields;
 
 		// Holds the list of constants
 		protected List<MemberCore> constants;
 
 		// Holds the methods.
 		List<MemberCore> methods;
 
 		// Holds the events
 		protected List<MemberCore> events;
 
 		// Holds the indexers
 		List<MemberCore> indexers;
 
 		// Holds the operators
 		List<MemberCore> operators;
 
 		// Holds the compiler generated classes
 		protected List<CompilerGeneratedClass> compiler_generated;
 
 		Dictionary<MethodSpec, Method> hoisted_base_call_proxies;
 
 		Dictionary<string, FullNamedExpression> Cache = new Dictionary<string, FullNamedExpression> ();
 
 		//
 		// Pointers to the default constructor and the default static constructor
 		//
 		protected Constructor default_constructor;
 		protected Constructor default_static_constructor;
 
 		//
 		// Points to the first non-static field added to the container.
 		//
 		// This is an arbitrary choice.  We are interested in looking at _some_ non-static field,
 		// and the first one's as good as any.
 		//
 		FieldBase first_nonstatic_field;
 
 		//
 		// This one is computed after we can distinguish interfaces
 		// from classes from the arraylist `type_bases' 
 		//
 		protected TypeSpec base_type;
 		protected TypeExpr base_type_expr;
 		protected TypeExpr[] iface_exprs;
 
 		protected List<FullNamedExpression> type_bases;
 
 		bool members_defined;
 		bool members_defined_ok;
 		bool type_defined;
 
 		TypeContainer InTransit;
 
 		GenericTypeParameterBuilder[] all_tp_builders;
 
 		public const string DefaultIndexerName = "Item";
 
 		private bool seen_normal_indexers = false;
 		private string indexer_name = DefaultIndexerName;
 		protected bool requires_delayed_unmanagedtype_check;
 		bool error;
 
 		private CachedMethods cached_method;
 
 		protected TypeSpec spec;
 		TypeSpec current_type;
 
 		List<TypeContainer> partial_parts;
 
 		public int DynamicSitesCounter;
 
 		/// <remarks>
 		///  The pending methods that need to be implemented
 		//   (interfaces or abstract methods)
 		/// </remarks>
 		PendingImplementation pending;
 
 		public TypeContainer (NamespaceEntry ns, DeclSpace parent, MemberName name,
 				      Attributes attrs, MemberKind kind)
 			
 		{
 			if (parent != null && parent.NamespaceEntry != ns)
 				throw new InternalErrorException ("A nested type should be in the same NamespaceEntry as its enclosing class");
 
 			this.Kind = kind;
 			this.PartialContainer = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\ExceptionHandlingClause.cs" startline="47" endline="56">
<![CDATA[
 		internal ExceptionHandlingClause(ModuleReader module, int flags, int tryOffset, int tryLength, int handlerOffset, int handlerLength, int classTokenOrfilterOffset, IGenericContext context)
 		{
 			this.flags = flags;
 			this.tryOffset = tryOffset;
 			this.tryLength = tryLength;
 			this.handlerOffset = handlerOffset;
 			this.handlerLength = handlerLength;
 			this.catchType = flags == (int)ExceptionHandlingClauseOptions.Clause && classTokenOrfilterOffset != 0 ? module.ResolveType(classTokenOrfilterOffset, context) 
 			this.filterOffset = flags == (int)ExceptionHandlingClauseOptions.Filter ? classTokenOrfilterOffset 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3324" endline="3335">
<![CDATA[
 		protected MemberBase (DeclSpace parent, GenericMethod generic,
 				      FullNamedExpression type, Modifiers mod, Modifiers allowed_mod, Modifiers def_mod,
 				      MemberName name, Attributes attrs)
 			
 		{
 			this.ds = generic != null ? generic 
 			this.type_expr = type;
 			ModFlags = ModifiersExtensions.Check (allowed_mod, mod, def_mod, Location, Report);
 			GenericMethod = generic;
 			if (GenericMethod != null)
 				GenericMethod.ModFlags = ModFlags;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="683" endline="699">
<![CDATA[
 
 		public NamespaceEntry (ModuleContainer ctx, NamespaceEntry parent, CompilationUnit file, string name)
 		{
 			this.ctx = ctx;
 			this.parent = parent;
 			this.file = file;
 			entries.Add (this);
 
 			if (parent != null)
 				ns = parent.NS.GetNamespace (name, true);
 			else if (name != null)
 				ns = ctx.GlobalRootNamespace.GetNamespace (name, true);
 			else
 				ns = ctx.GlobalRootNamespace;
 
 			SlaveDeclSpace = new RootDeclSpace (this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9130" endline="9136">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			StackAlloc target = (StackAlloc) t;
 			target.count = count.Clone (clonectx);
 			target.t = t.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="276" endline="285">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			base.DoResolve (rc);
 
 			if (type != null)
 				type = NullableInfo.GetUnderlyingType (type);
 
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="365" endline="372">
<![CDATA[
 
 		public void CreateSymbolFile (Guid guid, FileStream fs)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			Write (new MyBinaryWriter (fs), guid);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1669" endline="1680">
<![CDATA[
 
 		protected abstract string GetSuffix();
 
 		protected abstract Type Wrap(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
 	}
 
 	sealed class ArrayType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new ArrayType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1886" endline="1958">
<![CDATA[
 		}
 
 		private sealed class ParameterInfoImpl 
 		{
 			private readonly MethodInfo method;
 			private readonly Type type;
 			private readonly int pos;
 
 			internal ParameterInfoImpl(MethodInfo method, Type type, int pos)
 			{
 				this.method = method;
 				this.type = type;
 				this.pos = pos;
 			}
 
 			public override Type ParameterType
 			{
 				get { return type; }
 			}
 
 			public override string Name
 			{
 				get { return null; }
 			}
 
 			public override ParameterAttributes Attributes
 			{
 				get { return ParameterAttributes.None; }
 			}
 
 			public override int Position
 			{
 				get { return pos; }
 			}
 
 			public override object RawDefaultValue
 			{
 				get { return null; }
 			}
 
 			public override Type[] GetOptionalCustomModifiers()
 			{
 				return Empty<Type>.Array;
 			}
 
 			public override Type[] GetRequiredCustomModifiers()
 			{
 				return Empty<Type>.Array;
 			}
 
 			public override MemberInfo Member
 			{
 				get { return method.IsConstructor ? (MethodBase)new ConstructorInfoImpl(method) 
 			}
 
 			public override int MetadataToken
 			{
 				get { return 0x8000000; }
 			}
 
 			internal override Module Module
 			{
 				get { return method.Module; }
 			}
 		}
 	}
 
 	sealed class ByRefType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new ByRefType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1999" endline="2006">
<![CDATA[
 	}
 
 	sealed class PointerType 
 	{
 		internal static Type Make(Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
 		{
 			return type.Module.CanonicalizeType(new PointerType(type, requiredCustomModifiers, optionalCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="340" endline="363">
<![CDATA[
 	}
 
 	/// <summary>
 	/// Fixed buffer implementation
 	/// </summary>
 	public class FixedField 
 	{
 		public const string FixedElementName = "FixedElementField";
 		static int GlobalCounter = 0;
 
 		TypeBuilder fixed_buffer_type;
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.UNSAFE;
 
 		public FixedField (DeclSpace parent, FullNamedExpression type, Modifiers mod, MemberName name, Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="531" endline="556">
<![CDATA[
 		}
 	}
 
 	//
 	// The Field class is used to represents class/struct fields during parsing.
 	//
 	public class Field 
 		// <summary>
 		//   Modifiers allowed in a class declaration
 		// </summary>
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE |
 			Modifiers.STATIC |
 			Modifiers.VOLATILE |
 			Modifiers.UNSAFE |
 			Modifiers.READONLY;
 
 		public Field (DeclSpace parent, FullNamedExpression type, Modifiers mod, MemberName name,
 			      Attributes attrs)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="986" endline="1002">
<![CDATA[
 			}
 		}
 
 
 		static readonly string[] attribute_targets = new string [] { "event", "field", "method" };
 		static readonly string[] attribute_targets_interface = new string[] { "event", "method" };
 
 		Expression initializer;
 		Field backing_field;
 		List<FieldDeclarator> declarators;
 
 		public EventField (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			Add = new AddDelegateMethod (this);
 			Remove = new RemoveDelegateMethod (this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="536" endline="545">
<![CDATA[
 
 		protected override Expression ResolveEnumOperator (ResolveContext ec, Expression expr)
 		{
 			expr = base.ResolveEnumOperator (ec, expr);
 			if (expr == null)
 				return null;
 
 			Expr = LiftExpression (ec, Expr);
 			return LiftExpression (ec, expr);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="135" endline="155">
<![CDATA[
 			}
 		}
 
 		public static readonly string UnderlyingValueField = "value__";
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE;
 
 		public Enum (NamespaceEntry ns, DeclSpace parent, TypeExpression type,
 			     Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			base_type_expr = type;
 			var accmods = IsTopLevel ? Modifiers.INTERNAL 
 			ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod_flags, accmods, Location, Report);
 			spec = new EnumSpec (null, this, null, null, ModFlags);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="72" endline="95">
<![CDATA[
 		{
 			switch (type) {
 			case BranchingType.Exception
 			case BranchingType.Labeled
 			case BranchingType.Toplevel
 			case BranchingType.TryCatch
 				throw new InvalidOperationException ();
 
 			case BranchingType.Switch
 				return new FlowBranchingBreakable (parent, type, SiblingType.SwitchSection, block, loc);
 
 			case BranchingType.Block
 				return new FlowBranchingBlock (parent, type, SiblingType.Block, block, loc);
 
 			case BranchingType.Loop
 				return new FlowBranchingBreakable (parent, type, SiblingType.Conditional, block, loc);
 
 			case BranchingType.Embedded
 				return new FlowBranchingContinuable (parent, type, SiblingType.Conditional, block, loc);
 
 			default
 				return new FlowBranchingBlock (parent, type, SiblingType.Conditional, block, loc);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="960" endline="967">
<![CDATA[
 
 		/// <summary>
 		///  User-defined Implicit conversions
 		/// </summary>
 		static public Expression ImplicitUserConversion (ResolveContext ec, Expression source, TypeSpec target, Location loc)
 		{
 			return UserDefinedConversion (ec, source, target, true, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="968" endline="975">
<![CDATA[
 
 		/// <summary>
 		///  User-defined Explicit conversions
 		/// </summary>
 		static Expression ExplicitUserConversion (ResolveContext ec, Expression source, TypeSpec target, Location loc)
 		{
 			return UserDefinedConversion (ec, source, target, false, loc);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\convert.cs" startline="1230" endline="1246">
<![CDATA[
 
 
 		/// <summary>
 		///   Attempts to apply the `Standard Implicit
 		///   Conversion' rules to the expression `expr' into
 		///   the `target_type'.  It returns a new expression
 		///   that can be used in a context that expects a
 		///   `target_type'.
 		///
 		///   This is different from `ImplicitConversion' in that the
 		///   user defined implicit conversions are excluded.
 		/// </summary>
 		static public Expression ImplicitConversionStandard (ResolveContext ec, Expression expr,
 								     TypeSpec target_type, Location loc)
 		{
 			return ImplicitConversionStandard (ec, expr, target_type, loc, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="190" endline="205">
<![CDATA[
 
 		public enum Operation {
 			//
 			// If you change this, review the whole InterfaceMethod routine as there
 			// are a couple of assumptions on these three states
 			//
 			Lookup, ClearOne, ClearAll
 		}
 
 		/// <summary>
 		///   Whether the specified method is an interface method implementation
 		/// </summary>
 		public MethodSpec IsInterfaceMethod (MemberName name, TypeSpec ifaceType, MethodData method)
 		{
 			return InterfaceMethod (name, ifaceType, method, Operation.Lookup);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="1098" endline="1105">
<![CDATA[
 
 		public void DefineUnmanagedResource(string resourceFileName)
 		{
 			// This method reads the specified resource file (Win32 .res file) and converts it into the appropriate format and embeds it in the .rsrc section,
 			// also setting the Resource Directory entry.
 			unmanagedResources = new ResourceSection();
 			unmanagedResources.ExtractResources(System.IO.File.ReadAllBytes(resourceFileName));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5822" endline="5828">
<![CDATA[
 
 		public void EmitAssign (EmitContext ec, Expression source)
 		{
 			li.CreateBuilder (ec);
 
 			EmitAssign (ec, source, false, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="435" endline="442">
<![CDATA[
 
 		public void SetMetaInfo (MetaType info)
 		{
 			if (this.info != null)
 				throw new InternalErrorException ("MetaInfo reset");
 
 			this.info = info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="451" endline="458">
<![CDATA[
 
 		public void SetMetaInfo (MethodInfo info)
 		{
 			if (this.metaInfo != null)
 				throw new InternalErrorException ("MetaInfo reset");
 
 			this.metaInfo = info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="139" endline="267">
<![CDATA[
 
 		const Modifiers AllowedModifiers =
 			Modifiers.NEW |
 			Modifiers.PUBLIC |
 			Modifiers.PROTECTED |
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE;
 
 		public Enum (NamespaceEntry ns, DeclSpace parent, TypeExpression type,
 			     Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			base_type_expr = type;
 			var accmods = IsTopLevel ? Modifiers.INTERNAL 
 			ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod_flags, accmods, Location, Report);
 			spec = new EnumSpec (null, this, null, null, ModFlags);
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Enum;
 			}
 		}
 
 		public TypeExpr BaseTypeExpression {
 			get {
 				return base_type_expr;
 			}
 		}
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed | base.TypeAttr;
 			}
 		}
 
 		public TypeSpec UnderlyingType {
 			get {
 				return ((EnumSpec) spec).UnderlyingType;
 			}
 		}
 
 		#endregion
 
 		public void AddEnumMember (EnumMember em)
 		{
 			if (em.Name == UnderlyingValueField) {
 				Report.Error (76, em.Location, "An item in an enumeration cannot have an identifier `{0}'",
 					UnderlyingValueField);
 				return;
 			}
 
 			AddConstant (em);
 		}
 
 		public static void Error_1008 (Location loc, Report Report)
 		{
 			Report.Error (1008, loc,
 				"Type byte, sbyte, short, ushort, int, uint, long or ulong expected");
 		}
 
 		protected override bool DefineNestedTypes ()
 		{
 			((EnumSpec) spec).UnderlyingType = base_type_expr == null ? TypeManager.int32_type 
 
 			TypeBuilder.DefineField (UnderlyingValueField, UnderlyingType.GetMetaInfo (),
 				FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
 
 			if (!RootContext.StdLib)
 				Module.hack_corlib_enums.Add (this);
 
 			return true;
 		}
 
 		protected override bool DoDefineMembers ()
 		{
 			if (constants != null) {
 				for (int i = 0; i < constants.Count; ++i) {
 					EnumMember em = (EnumMember) constants [i];
 					if (em.Initializer == null) {
 						em.Initializer = new ImplicitInitializer (em, i == 0 ? null 
 					}
 
 					em.Define ();
 				}
 			}
 
 			return true;
 		}
 
 		public override bool IsUnmanagedType ()
 		{
 			return true;
 		}
 
 		protected override TypeExpr[] ResolveBaseTypes (out TypeExpr base_class)
 		{
 			base_type = TypeManager.enum_type;
 			base_class = base_type_expr;
 			return null;
 		}
 
 		protected override bool VerifyClsCompliance ()
 		{
 			if (!base.VerifyClsCompliance ())
 				return false;
 
 			if (UnderlyingType == TypeManager.uint32_type ||
 				UnderlyingType == TypeManager.uint64_type ||
 				UnderlyingType == TypeManager.ushort_type) {
 				Report.Warning (3009, 1, Location, "`{0}'
 			}
 
 			return true;
 		}	
 	}
 
 	class EnumSpec 
 	{
 		TypeSpec underlying;
 
 		public EnumSpec (TypeSpec declaringType, ITypeDefinition definition, TypeSpec underlyingType, MetaType info, Modifiers modifiers)
 			
 		{
 			this.underlying = underlyingType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="440" endline="446">
<![CDATA[
 			set {
 				get = value;
 				if (first == null)
 					first = value;
 
 				Parent.AddMember (get);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="453" endline="459">
<![CDATA[
 			set {
 				set = value;
 				if (first == null)
 					first = value;
 
 				Parent.AddMember (set);
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="98" endline="136">
<![CDATA[
 		public Namespace (Namespace parent, string name)
 		{
 			// Expression members.
 			this.eclass = ExprClass.Namespace;
 			this.Type = InternalType.FakeInternalType;
 			this.loc = Location.Null;
 
 			this.parent = parent;
 
 			if (parent != null)
 				this.root = parent.root;
 			else
 				this.root = this as RootNamespace;
 
 			if (this.root == null)
 				throw new InternalErrorException ("Root namespaces must be created using RootNamespace");
 			
 			string pname = parent != null ? parent.fullname 
 				
 			if (pname == "")
 				fullname = name;
 			else
 				fullname = parent.fullname + "." + name;
 
 			if (fullname == null)
 				throw new InternalErrorException ("Namespace has a null fullname");
 
 			if (parent != null && parent.MemberName != MemberName.Null)
 				MemberName = new MemberName (parent.MemberName, name);
 			else if (name.Length == 0)
 				MemberName = MemberName.Null;
 			else
 				MemberName = new MemberName (name);
 
 			namespaces = new Dictionary<string, Namespace> ();
 			cached_types = new Dictionary<string, TypeExpr> ();
 
 			root.RegisterNamespace (this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldInfo.cs" startline="113" endline="120">
<![CDATA[
 		}
 
 		internal abstract int ImportTo(Emit.ModuleBuilder module);
 
 		internal virtual FieldInfo BindTypeParameters(Type type)
 		{
 			return new GenericFieldInstance(this.DeclaringType.BindTypeParameters(type), this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.cs" startline="1221" endline="1233">
<![CDATA[
 
   /** the generated parser, with debugging messages.
       Maintains a state and a value stack, currently with fixed maximum size.
       @param yyLex scanner.
       @param yydebug debug message writer implementing yyDebug, or null.
       @return result of the last reduction, if any.
       @throws yyException on irrecoverable parse error.
     */
   internal Object yyparse (yyParser.yyInput yyLex, Object yyd)
 				 {
     this.debug = (yydebug.yyDebug)yyd;
     return yyparse(yyLex);
   }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9310" endline="9316">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			base.expr = new AddMemberAccess (ec.CurrentInitializerVariable, loc);
 
 			return base.DoResolve (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ByteReader.cs" startline="186" endline="192">
<![CDATA[
 
 		// NOTE this method only works if the original offset was aligned and for alignments that are a power of 2
 		internal void Align(int alignment)
 		{
 			alignment--;
 			pos = (pos + alignment) & ~alignment;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\FieldSignature.cs" startline="80" endline="87">
<![CDATA[
 
 		internal FieldSignature ExpandTypeParameters(Type declaringType)
 		{
 			return new FieldSignature(
 				fieldType.BindTypeParameters(declaringType),
 				BindTypeParameters(declaringType, optionalCustomModifiers),
 				BindTypeParameters(declaringType, requiredCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="531" endline="539">
<![CDATA[
 
 		[Conditional ("FULL_AST")]
 		public void AddStatement (object element, params Location[] locations)
 		{
 			if (locations.Length == 0)
 				throw new ArgumentException ("Statement is missing semicolon location");
 
 			simple_locs.Add (element, locations);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="2089" endline="2095">
<![CDATA[
 
 		private static bool IsEmpty(Type[][] mods, int i)
 		{
 			// we need to be extra careful, because mods doesn't not need to be in canonical format
 			// (Signature.ReadGenericInst() calls Make() directly, without copying the modifier arrays)
 			return mods == null || mods[i] == null || mods[i].Length == 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1113" endline="1122">
<![CDATA[
 
 		public TypeParameterInflator (TypeSpec type, TypeParameterSpec[] tparams, TypeSpec[] targs)
 		{
 			if (tparams.Length != targs.Length)
 				throw new ArgumentException ("Invalid arguments");
 
 			this.tparams = tparams;
 			this.targs = targs;
 			this.type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\PropertySignature.cs" startline="108" endline="119">
<![CDATA[
 
 		internal PropertySignature ExpandTypeParameters(Type declaringType)
 		{
 			return new PropertySignature(
 				callingConvention,
 				propertyType.BindTypeParameters(declaringType),
 				BindTypeParameters(declaringType, optionalCustomModifiers),
 				BindTypeParameters(declaringType, requiredCustomModifiers),
 				BindTypeParameters(declaringType, parameterTypes),
 				BindTypeParameters(declaringType, parameterOptionalCustomModifiers),
 				BindTypeParameters(declaringType, parameterRequiredCustomModifiers));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="516" endline="523">
<![CDATA[
 
 		protected AbstractMessage (AbstractMessage aMsg)
 		{
 			this.code = aMsg.code;
 			this.location = aMsg.location;
 			this.message = aMsg.message;
 			this.extra_info = aMsg.extra_info;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\AssemblyReader.cs" startline="39" endline="45">
<![CDATA[
 		internal AssemblyReader(string location, ModuleReader manifestModule)
 			
 		{
 			this.location = location;
 			this.manifestModule = manifestModule;
 			externalModules = new Module[manifestModule.File.records.Length];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1085" endline="1095">
<![CDATA[
 
 		TypeInfo (StructInfo struct_info, int offset)
 		{
 			this.struct_info = struct_info;
 			this.Offset = offset;
 			this.Length = struct_info.Length;
 			this.TotalLength = struct_info.TotalLength;
 			this.SubStructInfo = struct_info.StructFields;
 			this.Type = struct_info.Type;
 			this.IsStruct = true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\TypeDefImpl.cs" startline="40" endline="46">
<![CDATA[
 		internal TypeDefImpl(ModuleReader module, int index)
 		{
 			this.module = module;
 			this.index = index;
 			this.typeName = TypeNameParser.Escape(module.GetString(module.TypeDef.records[index].TypeName));
 			this.typeNamespace = TypeNameParser.Escape(module.GetString(module.TypeDef.records[index].TypeNamespace));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="57" endline="69">
<![CDATA[
  		public Delegate (NamespaceEntry ns, DeclSpace parent, FullNamedExpression type,
 				 Modifiers mod_flags, MemberName name, ParametersCompiled param_list,
 				 Attributes attrs)
 			
 
 		{
 			this.ReturnType = type;
 			ModFlags        = ModifiersExtensions.Check (AllowedModifiers, mod_flags,
 							   IsTopLevel ? Modifiers.INTERNAL 
 							   Modifiers.PRIVATE, name.Location, Report);
 			parameters      = param_list;
 			spec = new TypeSpec (Kind, null, this, null, ModFlags | Modifiers.SEALED);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1463" endline="1474">
<![CDATA[
 
 		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
 		{
 			// Only boxing to object type is supported
 			if (targetType != TypeManager.object_type) {
 				base.EncodeAttributeValue (rc, enc, targetType);
 				return;
 			}
 
 			enc.Encode (child.Type);
 			child.EncodeAttributeValue (rc, enc, child.Type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\FieldBuilder.cs" startline="41" endline="53">
<![CDATA[
 		internal FieldBuilder(TypeBuilder type, string name, Type fieldType, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attribs)
 		{
 			this.typeBuilder = type;
 			this.name = name;
 			this.pseudoToken = type.ModuleBuilder.AllocPseudoToken();
 			this.nameIndex = type.ModuleBuilder.Strings.Add(name);
 			this.fieldSig = FieldSignature.Create(fieldType, optionalCustomModifiers, requiredCustomModifiers);
 			ByteBuffer sig = new ByteBuffer(5);
 			fieldSig.WriteSig(this.typeBuilder.ModuleBuilder, sig);
 			this.signature = this.typeBuilder.ModuleBuilder.Blobs.Add(sig);
 			this.attribs = attribs;
 			this.typeBuilder.ModuleBuilder.Field.AddVirtualRecord();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="2106" endline="2114">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext rc)
 		{
 			value = value.Resolve (rc);
 
 			type = value.Type;
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="284" endline="291">
<![CDATA[
 
 		public ConstructorBuilder DefineConstructor(MethodAttributes attribs, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
 		{
 			attribs |= MethodAttributes.RTSpecialName | MethodAttributes.SpecialName;
 			string name = (attribs & MethodAttributes.Static) == 0 ? ConstructorInfo.ConstructorName 
 			MethodBuilder mb = DefineMethod(name, attribs, callingConvention, null, null, null, parameterTypes, requiredCustomModifiers, optionalCustomModifiers);
 			return new ConstructorBuilder(mb);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\context.cs" startline="120" endline="131">
<![CDATA[
 
 		// <summary>
 		//   Starts a new code branching for block `block'.
 		// </summary>
 		public FlowBranching StartFlowBranching (Block block)
 		{
 			Set (Options.DoFlowAnalysis);
 
 			current_flow_branching = FlowBranching.CreateBranching (
 				CurrentBranching, FlowBranching.BranchingType.Block, block, block.StartLocation);
 			return current_flow_branching;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="155" endline="163">
<![CDATA[
 
 		public int DefineNamespace (string name, CompileUnitEntry unit,
 					    string[] using_clauses, int parent)
 		{
 			if ((unit == null) || (using_clauses == null))
 				throw new NullReferenceException ();
 
 			return unit.DefineNamespace (name, using_clauses, parent);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1310" endline="1321">
<![CDATA[
 		}
 
 		protected VariableInfo (string name, TypeSpec type, int offset)
 		{
 			this.Name = name;
 			this.Offset = offset;
 			this.TypeInfo = TypeInfo.GetTypeInfo (type);
 
 			Length = TypeInfo.TotalLength;
 
 			Initialize ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1322" endline="1335">
<![CDATA[
 
 		protected VariableInfo (VariableInfo parent, TypeInfo type)
 		{
 			this.Name = parent.Name;
 			this.TypeInfo = type;
 			this.Offset = parent.Offset + type.Offset;
 			this.Parent = parent;
 			this.Length = type.TotalLength;
 
 			this.IsParameter = parent.IsParameter;
 			this.LocalInfo = parent.LocalInfo;
 
 			Initialize ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="86" endline="93">
<![CDATA[
 
 		internal void Write(byte[] value)
 		{
 			if (pos + value.Length > buffer.Length)
 				Grow(value.Length);
 			Buffer.BlockCopy(value, 0, buffer, pos, value.Length);
 			pos += value.Length;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1778" endline="1809">
<![CDATA[
 		public int ID = id++;
 
 		static int clone_id_counter;
 		int clone_id;
 #endif
 
 //		int assignable_slots;
 		bool unreachable_shown;
 		bool unreachable;
 		
 		public Block (Block parent, Location start, Location end)
 			
 		{
 		}
 
 		public Block (Block parent, Flags flags, Location start, Location end)
 		{
 			if (parent != null) {
 				// the appropriate constructors will fixup these fields
 				ParametersBlock = parent.ParametersBlock;
 				Explicit = parent.Explicit;
 			}
 			
 			this.Parent = parent;
 			this.flags = flags;
 			this.StartLocation = start;
 			this.EndLocation = end;
 			this.loc = start;
 			statements = new List<Statement> (4);
 
 			this.original = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2637" endline="2645">
<![CDATA[
 
 		public ToplevelBlock (CompilerContext ctx, ParametersCompiled parameters, Location start)
 			
 		{
 			this.compiler = ctx;
 			top_block = this;
 
 			ProcessParameters ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="590" endline="598">
<![CDATA[
 
 		protected bool DefineAccessors ()
 		{
 			first.Define (Parent);
 			if (AccessorSecond != null)
 				AccessorSecond.Define (Parent);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="63" endline="70">
<![CDATA[
 		}
 
 		private void Grow(int minGrow)
 		{
 			byte[] newbuf = new byte[Math.Max(buffer.Length + minGrow, buffer.Length * 2)];
 			Buffer.BlockCopy(buffer, 0, newbuf, 0, buffer.Length);
 			buffer = newbuf;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5535" endline="5576">
<![CDATA[
 		}
 
 		#endregion
 
 		/// <summary>
 		/// Converts complex core type syntax like 'new int ()' to simple constant
 		/// </summary>
 		public static Constant Constantify (TypeSpec t, Location loc)
 		{
 			if (t == TypeManager.int32_type)
 				return new IntConstant (0, loc);
 			if (t == TypeManager.uint32_type)
 				return new UIntConstant (0, loc);
 			if (t == TypeManager.int64_type)
 				return new LongConstant (0, loc);
 			if (t == TypeManager.uint64_type)
 				return new ULongConstant (0, loc);
 			if (t == TypeManager.float_type)
 				return new FloatConstant (0, loc);
 			if (t == TypeManager.double_type)
 				return new DoubleConstant (0, loc);
 			if (t == TypeManager.short_type)
 				return new ShortConstant (0, loc);
 			if (t == TypeManager.ushort_type)
 				return new UShortConstant (0, loc);
 			if (t == TypeManager.sbyte_type)
 				return new SByteConstant (0, loc);
 			if (t == TypeManager.byte_type)
 				return new ByteConstant (0, loc);
 			if (t == TypeManager.char_type)
 				return new CharConstant ('\0', loc);
 			if (t == TypeManager.bool_type)
 				return new BoolConstant (false, loc);
 			if (t == TypeManager.decimal_type)
 				return new DecimalConstant (0, loc);
 			if (TypeManager.IsEnumType (t))
 				return new EnumConstant (Constantify (EnumSpec.GetUnderlyingType (t), loc), t);
 			if (TypeManager.IsNullableType (t))
 				return Nullable.LiftedNull.Create (t, loc);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\MethodBuilder.cs" startline="55" endline="71">
<![CDATA[
 		private bool initLocals = true;
 
 		internal MethodBuilder(TypeBuilder typeBuilder, string name, MethodAttributes attributes, CallingConventions callingConvention)
 		{
 			this.typeBuilder = typeBuilder;
 			this.name = name;
 			this.pseudoToken = typeBuilder.ModuleBuilder.AllocPseudoToken();
 			// because all the MethodBuilders constitute a virtual MethodDef table, we cannot allocate the string during WriteMethodDefRecord,
 			// since by then the metadata has already been frozen
 			this.nameIndex = typeBuilder.ModuleBuilder.Strings.Add(name);
 			this.attributes = attributes;
 			if ((attributes & MethodAttributes.Static) == 0)
 			{
 				callingConvention |= CallingConventions.HasThis;
 			}
 			this.callingConvention = callingConvention;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="339" endline="347">
<![CDATA[
 
 		public void SetNestedStoryParent (AnonymousMethodStorey parentStorey)
 		{
 			Parent = parentStorey;
 			type_params = null;
 			spec.IsGeneric = false;
 			spec.DeclaringType = parentStorey.CurrentType;
 			MemberName.TypeArguments = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="106" endline="116">
<![CDATA[
 		public int LineNumberTable_LineBase = LineNumberTable.Default_LineBase;
 		public int LineNumberTable_LineRange = LineNumberTable.Default_LineRange;
 		public int LineNumberTable_OpcodeBase = LineNumberTable.Default_OpcodeBase;
 		#endregion
 
 		internal OffsetTable ()
 		{
 			int platform = (int) Environment.OSVersion.Platform;
 			if ((platform != 4) && (platform != 128))
 				FileFlags |= Flags.WindowsFileNames;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="51" endline="57">
<![CDATA[
 			set
 			{
 				if (value > this.Length || value > buffer.Length)
 					throw new ArgumentOutOfRangeException();
 				__length = Math.Max(__length, pos);
 				pos = value;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assembly.cs" startline="1052" endline="1064">
<![CDATA[
 		public AssemblyReferencesLoader (CompilerContext compiler)
 		{
 			this.compiler = compiler;
 
 			if (RootContext.LoadDefaultReferences)
 				default_references = GetDefaultReferences ();
 			else
 				default_references = new string[0];
 
 			paths = new List<string> ();
 			paths.AddRange (RootContext.ReferencesLookupPaths);
 			paths.Add (Directory.GetCurrentDirectory ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\ModuleReader.cs" startline="60" endline="112">
<![CDATA[
 		private readonly PEReader peFile = new PEReader();
 		private readonly CliHeader cliHeader = new CliHeader();
 		private string imageRuntimeVersion;
 		private int metadataStreamVersion;
 		private byte[] stringHeap;
 		private byte[] blobHeap;
 		private byte[] userStringHeap;
 		private byte[] guidHeap;
 		private TypeDefImpl[] typeDefs;
 		private TypeDefImpl moduleType;
 		private Assembly[] assemblyRefs;
 		private Type[] typeRefs;
 		private Type[] typeSpecs;
 		private FieldInfo[] fields;
 		private MethodBase[] methods;
 		private MemberInfo[] memberRefs;
 		private Dictionary<int, string> strings = new Dictionary<int, string>();
 		private Dictionary<string, Type> types = new Dictionary<string, Type>();
 		private Dictionary<string, LazyForwardedType> forwardedTypes = new Dictionary<string, LazyForwardedType>();
 
 		private sealed class LazyForwardedType
 		{
 			private readonly int assemblyRef;
 			private Type type;
 
 			internal LazyForwardedType(int assemblyRef)
 			{
 				this.assemblyRef = assemblyRef;
 			}
 
 			internal Type GetType(ModuleReader module, string typeName)
 			{
 				if (type == null)
 				{
 					Assembly asm = module.ResolveAssemblyRef(assemblyRef);
 					type = asm.GetType(typeName, true);
 				}
 				return type;
 			}
 		}
 
 		internal ModuleReader(AssemblyReader assembly, Universe universe, Stream stream, string location)
 			
 		{
 			this.stream = stream;
 			this.location = location;
 			Read();
 			if (assembly == null && AssemblyTable.records.Length != 0)
 			{
 				assembly = new AssemblyReader(location, this);
 			}
 			this.assembly = assembly;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="2012" endline="2020">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldnull);
 
 			// Only to make verifier happy
 			if (TypeManager.IsGenericParameter (type))
 				ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1323" endline="1333">
<![CDATA[
 
 		public override void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			if (expr_unwrap != null) {
 				expr_unwrap.EmitCheck (ec);
 			} else {
 				expr.Emit (ec);
 				ec.Emit (OpCodes.Isinst, probe_type_expr.Type);
 			}			
 			ec.Emit (on_true ? OpCodes.Brtrue 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="388" endline="401">
<![CDATA[
 		}
 
 		public void DefineMethod (MonoSymbolFile file)
 		{
 			LineNumberEntry[] lines = new LineNumberEntry [method_lines_pos];
 			Array.Copy (method_lines, lines, method_lines_pos);
 
 			MethodEntry entry = new MethodEntry (
 				file, _comp_unit.Entry, _method.Token, ScopeVariables,
 				Locals, lines, Blocks, RealMethodName, 0, //_method_flags,
 				_ns_id);
 
 			file.AddMethod (entry);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="38" endline="48">
<![CDATA[
 		}
 
 		internal abstract int RowCount { get; set; }
 
 		internal abstract void Write(MetadataWriter mw);
 		internal abstract void Read(MetadataReader mr);
 
 		internal int GetLength(MetadataWriter md)
 		{
 			return RowCount * GetRowSize(new RowSizeCalc(md));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5815" endline="5821">
<![CDATA[
 		
 		public override void Emit (EmitContext ec)
 		{
 			li.CreateBuilder (ec);
 
 			Emit (ec, false);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4787" endline="4794">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			local_info.SetIsUsed ();
 
 			DoResolveBase (ec);
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1213" endline="1219">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			AnonymousMethodExpression target = (AnonymousMethodExpression) t;
 
 			target.Block = (ParametersBlock) clonectx.LookupBlock (Block);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="621" endline="627">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			StatementExpression target = (StatementExpression) t;
 
 			target.expr = (ExpressionStatement) expr.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="353" endline="364">
<![CDATA[
 
 		static bool IsValidArgumentType (TypeSpec t)
 		{
 			if (t.IsArray)
 				t = TypeManager.GetElementType (t);
 
 			return t == TypeManager.string_type ||
 				TypeManager.IsPrimitiveType (t) ||
 				TypeManager.IsEnumType (t) ||
 				t == TypeManager.object_type ||
 				t == TypeManager.type_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="327" endline="629">
<![CDATA[
 		
 		Constraints constraints;
 		GenericTypeParameterBuilder builder;
 		TypeParameterSpec spec;
 
 		public TypeParameter (DeclSpace parent, int index, MemberName name, Constraints constraints, Attributes attrs, Variance variance)
 			
 		{
 			this.constraints = constraints;
 			this.spec = new TypeParameterSpec (null, index, this, SpecialConstraint.None, variance, null);
 		}
 
 		public TypeParameter (TypeParameterSpec spec, DeclSpace parent, TypeSpec parentSpec, MemberName name, Attributes attrs)
 			
 		{
 			this.spec = new TypeParameterSpec (parentSpec, spec.DeclaredPosition, spec.MemberDefinition, spec.SpecialConstraint, spec.Variance, null) {
 				BaseType = spec.BaseType,
 				InterfacesDefined = spec.InterfacesDefined,
 				TypeArguments = spec.TypeArguments
 			};
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.GenericParameter;
 			}
 		}
 
 		public IAssemblyDefinition DeclaringAssembly {
 			get	{
 				return Module.DeclaringAssembly;
 			}
 		}
 
 		public override string DocCommentHeader {
 			get {
 				throw new InvalidOperationException (
 					"Unexpected attempt to get doc comment from " + this.GetType ());
 			}
 		}
 
 		public bool IsMethodTypeParameter {
 			get {
 				return spec.IsMethodOwned;
 			}
 		}
 
 		public string Namespace {
 			get {
 				return null;
 			}
 		}
 
 		public TypeParameterSpec Type {
 			get {
 				return spec;
 			}
 		}
 
 		public int TypeParametersCount {
 			get {
 				return 0;
 			}
 		}
 
 		public TypeParameterSpec[] TypeParameters {
 			get {
 				return null;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_target;
 			}
 		}
 
 		public Variance Variance {
 			get {
 				return spec.Variance;
 			}
 		}
 
 		#endregion
 
 		//
 		// This is called for each part of a partial generic type definition.
 		//
 		// If partial type parameters constraints are not null and we don't
 		// already have constraints they become our constraints. If we already
 		// have constraints, we must check that they're the same.
 		//
 		public bool AddPartialConstraints (TypeContainer part, TypeParameter tp)
 		{
 			if (builder == null)
 				throw new InvalidOperationException ();
 
 			var new_constraints = tp.constraints;
 			if (new_constraints == null)
 				return true;
 
 			// TODO
 			//tp.Define (null, -1, part.Definition);
 			tp.spec.DeclaringType = part.Definition;
 			if (!tp.ResolveConstraints (part))
 				return false;
 
 			if (constraints != null)
 				return spec.HasSameConstraintsDefinition (tp.Type);
 
 			// Copy constraint from resolved part to partial container
 			spec.SpecialConstraint = tp.spec.SpecialConstraint;
 			spec.InterfacesDefined = tp.spec.InterfacesDefined;
 			spec.TypeArguments = tp.spec.TypeArguments;
 			spec.BaseType = tp.spec.BaseType;
 			
 			return true;
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public void CheckGenericConstraints ()
 		{
 			if (constraints != null)
 				constraints.CheckGenericConstraints (this);
 		}
 
 		public TypeParameter CreateHoistedCopy (TypeContainer declaringType, TypeSpec declaringSpec)
 		{
 			return new TypeParameter (spec, declaringType, declaringSpec, MemberName, null);
 		}
 
 		public override bool Define ()
 		{
 			return true;
 		}
 
 		//
 		// This is the first method which is called during the resolving
 		// process; we're called immediately after creating the type parameters
 		// with SRE (by calling `DefineGenericParameters()' on the TypeBuilder /
 		// MethodBuilder).
 		//
 		public void Define (GenericTypeParameterBuilder type, TypeSpec declaringType)
 		{
 			if (builder != null)
 				throw new InternalErrorException ();
 
 			this.builder = type;
 			spec.DeclaringType = declaringType;
 			spec.SetMetaInfo (type);
 		}
 
 		public void EmitConstraints (GenericTypeParameterBuilder builder)
 		{
 			var attr = GenericParameterAttributes.None;
 			if (spec.Variance == Variance.Contravariant)
 				attr |= GenericParameterAttributes.Contravariant;
 			else if (spec.Variance == Variance.Covariant)
 				attr |= GenericParameterAttributes.Covariant;
 
 			if (spec.HasSpecialClass)
 				attr |= GenericParameterAttributes.ReferenceTypeConstraint;
 			else if (spec.HasSpecialStruct)
 				attr |= GenericParameterAttributes.NotNullableValueTypeConstraint | GenericParameterAttributes.DefaultConstructorConstraint;
 
 			if (spec.HasSpecialConstructor)
 				attr |= GenericParameterAttributes.DefaultConstructorConstraint;
 
 			if (spec.BaseType != TypeManager.object_type)
 				builder.SetBaseTypeConstraint (spec.BaseType.GetMetaInfo ());
 
 			if (spec.InterfacesDefined != null)
 				builder.SetInterfaceConstraints (spec.InterfacesDefined.Select (l => l.GetMetaInfo ()).ToArray ());
 
 			if (spec.TypeArguments != null)
 				builder.SetInterfaceConstraints (spec.TypeArguments.Select (l => l.GetMetaInfo ()).ToArray ());
 
 			builder.SetGenericParameterAttributes (attr);
 		}
 
 		public override void Emit ()
 		{
 			EmitConstraints (builder);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			base.Emit ();
 		}
 
 		public void ErrorInvalidVariance (IMemberContext mc, Variance expected)
 		{
 			Report.SymbolRelatedToPreviousError (mc.CurrentMemberDefinition);
 			string input_variance = Variance == Variance.Contravariant ? "contravariant" 
 			string gtype_variance;
 			switch (expected) {
 			case Variance.Contravariant
 			case Variance.Covariant
 			default
 			}
 
 			Delegate d = mc as Delegate;
 			string parameters = d != null ? d.Parameters.GetSignatureForError () 
 
 			Report.Error (1961, Location,
 				"The {2} type parameter `{0}' must be {3} valid on `{1}{4}'",
 					GetSignatureForError (), mc.GetSignatureForError (), input_variance, gtype_variance, parameters);
 		}
 
 		public TypeSpec GetAttributeCoClass ()
 		{
 			return null;
 		}
 
 		public string GetAttributeDefaultMember ()
 		{
 			throw new NotSupportedException ();
 		}
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			throw new NotSupportedException ();
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return MemberName.Name;
 		}
 
 		bool ITypeDefinition.IsInternalAsPublic (IAssemblyDefinition assembly)
 		{
 			throw new NotImplementedException ();
 		}
 
 		public void LoadMembers (TypeSpec declaringType, bool onlyTypes, ref MemberCache cache)
 		{
 			throw new NotSupportedException ("Not supported for compiled definition");
 		}
 
 		//
 		// Resolves all type parameter constraints
 		//
 		public bool ResolveConstraints (IMemberContext context)
 		{
 			if (constraints != null)
 				return constraints.Resolve (context, this);
 
 			if (spec.BaseType == null)
 				spec.BaseType = TypeManager.object_type;
 
 			return true;
 		}
 
 		public static TypeParameter FindTypeParameter (TypeParameter[] tparams, string name)
 		{
 			foreach (var tp in tparams) {
 				if (tp.Name == name)
 					return tp;
 			}
 
 			return null;
 		}
 
 		public override bool IsClsComplianceRequired ()
 		{
 			return false;
 		}
 
 		public new void VerifyClsCompliance ()
 		{
 			if (constraints != null)
 				constraints.VerifyClsCompliance (Report);
 		}
 	}
 
 	[System.Diagnostics.DebuggerDisplay ("{DisplayDebugInfo()}")]
 	public class TypeParameterSpec 
 	{
 		public static readonly new TypeParameterSpec[] EmptyTypes = new TypeParameterSpec[0];
 
 		Variance variance;
 		SpecialConstraint spec;
 		readonly int tp_pos;
 		TypeSpec[] targs;
 		TypeSpec[] ifaces_defined;
 
 		//
 		// Creates type owned type parameter
 		//
 		public TypeParameterSpec (TypeSpec declaringType, int index, ITypeDefinition definition, SpecialConstraint spec, Variance variance, MetaType info)
 			
 		{
 			this.variance = variance;
 			this.spec = spec;
 			state &= ~StateFlags.Obsolete_Undetected;
 			tp_pos = index;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="335" endline="342">
<![CDATA[
 
 		void AddSourceFile (string f)
 		{
 			if (first_source == null)
 				first_source = f;
 
 			Location.AddFile (Report, f);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="926" endline="937">
<![CDATA[
 		public int ID = counter++;
 #endif
 
 		protected MemberSpec (MemberKind kind, TypeSpec declaringType, IMemberDefinition definition, Modifiers modifiers)
 		{
 			this.Kind = kind;
 			this.declaringType = declaringType;
 			this.definition = definition;
 			this.modifiers = modifiers;
 
 			state = StateFlags.Obsolete_Undetected | StateFlags.CLSCompliant_Undetected | StateFlags.MissingDependency_Undetected;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1440" endline="1454">
<![CDATA[
 	}
 
 	/// <summary>
 	///   This kind of cast is used to encapsulate Value Types in objects.
 	///
 	///   The effect of it is to box the value type emitted by the previous
 	///   operation.
 	/// </summary>
 	public class BoxedCast 
 
 		public BoxedCast (Expression expr, TypeSpec target_type)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="291" endline="299">
<![CDATA[
 	}
 
 	public class Wrap 
 	{
 		private Wrap (Expression expr, TypeSpec type)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="329" endline="340">
<![CDATA[
 	}
 
 	//
 	// Represents null literal lifted to nullable type
 	//
 	public class LiftedNull 
 	{
 		private LiftedNull (TypeSpec nullable_type, Location loc)
 			
 		{
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1493" endline="1500">
<![CDATA[
 
 		//
 		// Used by variable declarators
 		//
 		public LocalVariable (LocalVariable li, string name, Location loc)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7462" endline="7476">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the qualified-alias-member (
 	/// </summary>
 	public class QualifiedAliasMember 
 	{
 		readonly string alias;
 		public static readonly string GlobalAlias = "global";
 
 		public QualifiedAliasMember (string alias, string identifier, Location l)
 			
 		{
 			this.alias = alias;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9137" endline="9150">
<![CDATA[
 	}
 
 	//
 	// An object initializer expression
 	//
 	public class ElementInitializer 
 	{
 		public readonly string Name;
 
 		public ElementInitializer (string name, Expression initializer, Location loc)
 			
 		{
 			this.Name = name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="558" endline="750">
<![CDATA[
 	}
 
 	class DynamicIndexBinder 
 	{
 		bool can_be_mutator;
 
 		public DynamicIndexBinder (Arguments args, Location loc)
 			
 		{
 		}
 
 		public DynamicIndexBinder (CSharpBinderFlags flags, Arguments args, Location loc)
 			
 		{
 			base.flags = flags;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			can_be_mutator = true;
 			return base.DoResolve (ec);
 		}
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (3);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetIndex" 
 		}
 
 		protected override Arguments CreateSetterArguments (ResolveContext rc, Expression rhs)
 		{
 			//
 			// Indexer has arguments which complicates things as the setter and getter
 			// are called in two steps when unary mutator is used. We have to make a
 			// copy of all variable arguments to not duplicate any side effect.
 			//
 			// ++d[++arg, Foo ()]
 			//
 
 			if (!can_be_mutator)
 				return base.CreateSetterArguments (rc, rhs);
 
 			var setter_args = new Arguments (Arguments.Count + 1);
 			for (int i = 0; i < Arguments.Count; ++i) {
 				var expr = Arguments[i].Expr;
 
 				if (expr is Constant || expr is VariableReference || expr is This) {
 					setter_args.Add (Arguments [i]);
 					continue;
 				}
 
 				LocalVariable temp = LocalVariable.CreateCompilerGenerated (expr.Type, rc.CurrentBlock, loc);
 				expr = new SimpleAssign (temp.CreateReferenceExpression (rc, expr.Location), expr).Resolve (rc);
 				Arguments[i].Expr = temp.CreateReferenceExpression (rc, expr.Location).Resolve (rc);
 				setter_args.Add (Arguments [i].Clone (expr));
 			}
 
 			setter_args.Add (new Argument (rhs));
 			return setter_args;
 		}
 	}
 
 	class DynamicInvocation 
 	{
 		ATypeNameExpression member;
 
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 			this.member = member;
 		}
 
 		//
 		// When a return type is known not to be dynamic
 		//
 		public DynamicInvocation (ATypeNameExpression member, Arguments args, TypeSpec type, Location loc)
 			
 		{
 			this.type = type;
 		}
 
 		public static DynamicInvocation CreateSpecialNameInvoke (ATypeNameExpression member, Arguments args, Location loc)
 		{
 			return new DynamicInvocation (member, args, loc) {
 				flags = CSharpBinderFlags.InvokeSpecialName
 			};
 		}
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (member != null ? 5 
 			bool is_member_access = member is MemberAccess;
 
 			CSharpBinderFlags call_flags;
 			if (!is_member_access && member is SimpleName) {
 				call_flags = CSharpBinderFlags.InvokeSimpleName;
 				is_member_access = true;
 			} else {
 				call_flags = 0;
 			}
 
 			binder_args.Add (new Argument (new BinderFlags (call_flags, this)));
 
 			if (is_member_access)
 				binder_args.Add (new Argument (new StringLiteral (member.Name, member.Location)));
 
 			if (member != null && member.HasTypeArguments) {
 				TypeArguments ta = member.TypeArguments;
 				if (ta.Resolve (ec)) {
 					var targs = new ArrayInitializer (ta.Count, loc);
 					foreach (TypeSpec t in ta.Arguments)
 						targs.Add (new TypeOf (new TypeExpression (t, loc), loc));
 
 					binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (targs, loc)));
 				}
 			} else if (is_member_access) {
 				binder_args.Add (new Argument (new NullLiteral (loc)));
 			}
 
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 
 			Expression real_args;
 			if (args == null) {
 				// Cannot be null because .NET trips over
 				real_args = new ArrayCreation (
 					new MemberAccess (GetBinderNamespace (loc), "CSharpArgumentInfo", loc),
 					new ArrayInitializer (0, loc), loc);
 			} else {
 				real_args = new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc);
 			}
 
 			binder_args.Add (new Argument (real_args));
 
 			return new Invocation (GetBinder (is_member_access ? "InvokeMember" 
 		}
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			flags |= CSharpBinderFlags.ResultDiscarded;
 			base.EmitStatement (ec);
 		}
 	}
 
 	class DynamicMemberBinder 
 	{
 		readonly string name;
 
 		public DynamicMemberBinder (string name, Arguments args, Location loc)
 			
 		{
 			this.name = name;
 		}
 
 		public DynamicMemberBinder (string name, CSharpBinderFlags flags, Arguments args, Location loc)
 			
 		{
 			base.flags = flags;
 		}
 
 		protected override Expression CreateCallSiteBinder (ResolveContext ec, Arguments args, bool isSet)
 		{
 			Arguments binder_args = new Arguments (4);
 
 			binder_args.Add (new Argument (new BinderFlags (flags, this)));
 			binder_args.Add (new Argument (new StringLiteral (name, loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			isSet |= (flags & CSharpBinderFlags.ValueFromCompoundAssignment) != 0;
 			return new Invocation (GetBinder (isSet ? "SetMember" 
 		}
 	}
 
 	//
 	// Any member binder which can be source and target of assignment
 	//
 	abstract class DynamicMemberAssignable 
 	{
 		Expression setter;
 		Arguments setter_args;
 
 		protected DynamicMemberAssignable (Arguments args, Location loc)
 			
 		{
 			base.binder = this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="572" endline="578">
<![CDATA[
 
 		public void SetDefinition (ITypeDefinition td, MetaType type, Modifiers mod)
 		{
 			this.definition = td;
 			this.info = type;
 			this.modifiers |= (mod & ~Modifiers.AccessibilityMask);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\TypeNameParser.cs" startline="108" endline="124">
<![CDATA[
 
 		private TypeNameParser(ref Parser parser, bool withAssemblyName)
 		{
 			bool genericParameter = parser.pos != 0;
 			name = parser.NextNamePart();
 			nested = null;
 			parser.ParseNested(ref nested);
 			genericParameters = null;
 			parser.ParseGenericParameters(ref genericParameters);
 			modifiers = null;
 			parser.ParseModifiers(ref modifiers);
 			assemblyName = null;
 			if (withAssemblyName)
 			{
 				parser.ParseAssemblyName(genericParameter, ref assemblyName);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="445" endline="454">
<![CDATA[
 
 		public void DefineVersionInfoResource(string product, string productVersion, string company, string copyright, string trademark)
 		{
 			versionInfo = new VersionInfo();
 			versionInfo.product = product;
 			versionInfo.informationalVersion = productVersion;
 			versionInfo.company = company;
 			versionInfo.copyright = copyright;
 			versionInfo.trademark = trademark;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="503" endline="516">
<![CDATA[
 	}
 
 	class IteratorMethod 
 	{
 		readonly IteratorStorey host;
 
 		public IteratorMethod (IteratorStorey host, FullNamedExpression returnType, Modifiers mod, MemberName name)
 			
 			  name, ParametersCompiled.EmptyReadOnlyParameters, null)
 		{
 			this.host = host;
 
 			Block = new ToplevelBlock (host.Compiler, ParametersCompiled.EmptyReadOnlyParameters, Location);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1068" endline="1084">
<![CDATA[
 
 		private TypeInfo (TypeSpec type)
 		{
 			this.Type = type;
 
 			struct_info = StructInfo.GetStructInfo (type);
 			if (struct_info != null) {
 				Length = struct_info.Length;
 				TotalLength = struct_info.TotalLength;
 				SubStructInfo = struct_info.StructFields;
 				IsStruct = true;
 			} else {
 				Length = 0;
 				TotalLength = 1;
 				IsStruct = false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="95" endline="103">
<![CDATA[
 		Unwrap (Expression expr, bool useDefaultValue)
 		{
 			this.expr = expr;
 			this.loc = expr.Location;
 			this.useDefaultValue = useDefaultValue;
 
 			type = NullableInfo.GetUnderlyingType (expr.Type);
 			eclass = expr.eclass;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8341" endline="8349">
<![CDATA[
 
 		public SLE.Expression MakeAssignExpression (BuilderContext ctx, Expression source)
 		{
 #if NET_4_0
 			return SLE.Expression.ArrayAccess (ea.Expr.MakeExpression (ctx), MakeExpressionArguments (ctx));
 #else
 			throw new NotImplementedException ();
 #endif
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="293" endline="299">
<![CDATA[
 
 		static public void Push (CompilationUnit compile_unit, SourceFile file)
 		{
 			current_source = file != null ? file.Index 
 			current_compile_unit = compile_unit != null ? compile_unit.Index 
 			// File is always pushed before being changed.
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="1349" endline="1355">
<![CDATA[
 
 		public VariableInfo (LocalVariable local_info, int offset)
 			
 		{
 			this.LocalInfo = local_info;
 			this.IsParameter = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="317" endline="361">
<![CDATA[
 		}
 
 		/// <summary>
 		///   XML documentation comment
 		/// </summary>
 		protected string comment;
 
 		/// <summary>
 		///   Represents header string for documentation comment 
 		///   for each member types.
 		/// </summary>
 		public abstract string DocCommentHeader { get; }
 
 		[Flags]
 		public enum Flags {
 			Obsolete_Undetected = 1,		// Obsolete attribute has not been detected yet
 			Obsolete = 1 << 1,			// Type has obsolete attribute
 			ClsCompliance_Undetected = 1 << 2,	// CLS Compliance has not been detected yet
 			ClsCompliant = 1 << 3,			// Type is CLS Compliant
 			CloseTypeCreated = 1 << 4,		// Tracks whether we have Closed the type
 			HasCompliantAttribute_Undetected = 1 << 5,	// Presence of CLSCompliantAttribute has not been detected
 			HasClsCompliantAttribute = 1 << 6,			// Type has CLSCompliantAttribute
 			ClsCompliantAttributeFalse = 1 << 7,			// Member has CLSCompliant(false)
 			Excluded_Undetected = 1 << 8,		// Conditional attribute has not been detected yet
 			Excluded = 1 << 9,					// Method is conditional
 			MethodOverloadsExist = 1 << 10,		// Test for duplication must be performed
 			IsUsed = 1 << 11,
 			IsAssigned = 1 << 12,				// Field is assigned
 			HasExplicitLayout	= 1 << 13,
 			PartialDefinitionExists	= 1 << 14,	// Set when corresponding partial method definition exists
 			HasStructLayout		= 1 << 15			// Has StructLayoutAttribute
 		}
 
 		/// <summary>
 		///   MemberCore flags at first detected then cached
 		/// </summary>
 		internal Flags caching_flags;
 
 		public MemberCore (DeclSpace parent, MemberName name, Attributes attrs)
 		{
 			this.Parent = parent as TypeContainer;
 			member_name = name;
 			caching_flags = Flags.Obsolete_Undetected | Flags.ClsCompliance_Undetected | Flags.HasCompliantAttribute_Undetected | Flags.Excluded_Undetected;
 			AddAttributes (attrs, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="117" endline="127">
<![CDATA[
 		public Attribute (string target, ATypeNameExpression expr, Arguments[] args, Location loc, bool nameEscaped)
 		{
 			this.expression = expr;
 			if (args != null) {
 				PosArguments = args [0];
 				NamedArguments = args [1];				
 			}
 			this.loc = loc;
 			ExplicitTarget = target;
 			this.nameEscaped = nameEscaped;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ILGenerator.cs" startline="689" endline="695">
<![CDATA[
 
 		public void Emit(OpCode opc, MethodInfo method)
 		{
 			Emit(opc);
 			WriteToken(moduleBuilder.GetMethodTokenForIL(method));
 			UpdateStack(opc, method.HasThis, method.ReturnType, method.ParameterCount);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="310" endline="322">
<![CDATA[
 
 		public override void Error_ValueCannotBeConverted (ResolveContext ec, Location loc, TypeSpec target, bool expl)
 		{
 			try {
 				ConvertExplicitly (true, target);
 				base.Error_ValueCannotBeConverted (ec, loc, target, expl);
 			}
 			catch
 			{
 				ec.Report.Error (31, loc, "Constant value `{0}' cannot be converted to a `{1}'",
 					GetValue ().ToString (), TypeManager.CSharpName (target));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ResourceSection.cs" startline="325" endline="351">
<![CDATA[
 	}
 
 	struct RESOURCEHEADER
 	{
 		internal int DataSize;
 		internal int HeaderSize;
 		internal OrdinalOrName TYPE;
 		internal OrdinalOrName NAME;
 		internal int DataVersion;
 		internal ushort MemoryFlags;
 		internal ushort LanguageId;
 		internal int Version;
 		internal int Characteristics;
 
 		internal RESOURCEHEADER(ByteReader br)
 		{
 			DataSize = br.ReadInt32();
 			HeaderSize = br.ReadInt32();
 			TYPE = ReadOrdinalOrName(br);
 			NAME = ReadOrdinalOrName(br);
 			br.Align(4);
 			DataVersion = br.ReadInt32();
 			MemoryFlags = br.ReadUInt16();
 			LanguageId = br.ReadUInt16();
 			Version = br.ReadInt32();
 			Characteristics = br.ReadInt32();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1701" endline="1712">
<![CDATA[
 
 		public void PrepareForFlowAnalysis (BlockContext bc)
 		{
 			//
 			// No need for definitely assigned check for these guys
 			//
 			if ((flags & (Flags.Constant | Flags.ReadonlyMask | Flags.CompilerGenerated)) != 0)
 				return;
 
 			VariableInfo = new VariableInfo (this, bc.FlowOffset);
 			bc.FlowOffset += VariableInfo.Length;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1310" endline="1322">
<![CDATA[
 		
 		public override void Emit (EmitContext ec)
 		{
 			if (expr_unwrap != null) {
 				expr_unwrap.EmitCheck (ec);
 				return;
 			}
 
 			expr.Emit (ec);
 			ec.Emit (OpCodes.Isinst, probe_type_expr.Type);
 			ec.Emit (OpCodes.Ldnull);
 			ec.Emit (OpCodes.Cgt_Un);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="414" endline="422">
<![CDATA[
 		}
 
 		public void SetIgnoreWarning (int code)
 		{
 			if (warning_ignore_table == null)
 				warning_ignore_table = new HashSet<int> ();
 
 			warning_ignore_table.Add (code);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="74" endline="84">
<![CDATA[
 
 		public string ReadString (int offset)
 		{
 			long old_pos = BaseStream.Position;
 			BaseStream.Position = offset;
 
 			string text = ReadString ();
 
 			BaseStream.Position = old_pos;
 			return text;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="672" endline="713">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type)
 				return new ShortConstant ((short) Value, Location);
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new UShortConstant ((ushort) Value, Location);
 			} if (target_type == TypeManager.int32_type)
 				  return new IntConstant ((int) Value, Location);
 			if (target_type == TypeManager.uint32_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			} if (target_type == TypeManager.int64_type)
 				  return new LongConstant ((long) Value, Location);
 			if (target_type == TypeManager.uint64_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new ULongConstant ((ulong) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context && Value < 0)
 					throw new OverflowException ();
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="595" endline="611">
<![CDATA[
 	}
 
 	public class FlowBranchingLabeled 
 	{
 		LabeledStatement stmt;
 		UsageVector actual;
 
 		public FlowBranchingLabeled (FlowBranching parent, LabeledStatement stmt)
 			
 		{
 			this.stmt = stmt;
 			CurrentUsageVector.MergeOrigins (stmt.JumpOrigins);
 			actual = CurrentUsageVector.Clone ();
 
 			// stand-in for backward jumps
 			CurrentUsageVector.ResetBarrier ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4178" endline="4192">
<![CDATA[
 
 		protected override void EmitTryBody (EmitContext ec)
 		{
 			//
 			// Monitor.Enter (expr_copy, ref lock_taken)
 			//
 			if (lock_taken != null) {
 				expr_copy.Emit (ec);
 				lock_taken.LocalInfo.CreateBuilder (ec);
 				lock_taken.AddressOf (ec, AddressOp.Load);
 				ec.Emit (OpCodes.Call, TypeManager.void_monitor_enter_object);
 			}
 
 			Statement.Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="45" endline="57">
<![CDATA[
 		internal GenericTypeParameterBuilder(string name, TypeBuilder type, MethodBuilder method, int position)
 		{
 			this.name = name;
 			this.type = type;
 			this.method = method;
 			this.position = position;
 			GenericParamTable.Record rec = new GenericParamTable.Record();
 			rec.Number = (short)position;
 			rec.Flags = 0;
 			rec.Owner = type != null ? type.MetadataToken 
 			rec.Name = this.ModuleBuilder.Strings.Add(name);
 			this.paramPseudoIndex = this.ModuleBuilder.GenericParam.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="182" endline="195">
<![CDATA[
 		}
 
 		#endregion
 
 		public void AddEnumMember (EnumMember em)
 		{
 			if (em.Name == UnderlyingValueField) {
 				Report.Error (76, em.Location, "An item in an enumeration cannot have an identifier `{0}'",
 					UnderlyingValueField);
 				return;
 			}
 
 			AddConstant (em);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5705" endline="5719">
<![CDATA[
 
 		#endregion
 
 		void Error_AssignmentEventOnly (ResolveContext ec)
 		{
 			if (spec.DeclaringType == ec.CurrentType || TypeManager.IsNestedChildOf (ec.CurrentType, spec.DeclaringType.MemberDefinition)) {
 				ec.Report.Error (79, loc,
 					"The event `{0}' can only appear on the left hand side of `+=' or `-=' operator",
 					GetSignatureForError ());
 			} else {
 				ec.Report.Error (70, loc,
 					"The event `{0}' can only appear on the left hand side of += or -= when used outside of the type `{1}'",
 					GetSignatureForError (), spec.DeclaringType.GetSignatureForError ());
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="4935" endline="4971">
<![CDATA[
 
 		static readonly int [] codes = {
 			191,	// instance, write access
 			192,	// instance, out access
 			198,	// static, write access
 			199,	// static, out access
 			1648,	// member of value instance, write access
 			1649,	// member of value instance, out access
 			1650,	// member of value static, write access
 			1651	// member of value static, out access
 		};
 
 		static readonly string [] msgs = {
 			/*0191*/ "A readonly field `{0}' cannot be assigned to (except in a constructor or a variable initializer)",
 			/*0192*/ "A readonly field `{0}' cannot be passed ref or out (except in a constructor)",
 			/*0198*/ "A static readonly field `{0}' cannot be assigned to (except in a static constructor or a variable initializer)",
 			/*0199*/ "A static readonly field `{0}' cannot be passed ref or out (except in a static constructor)",
 			/*1648*/ "Members of readonly field `{0}' cannot be modified (except in a constructor or a variable initializer)",
 			/*1649*/ "Members of readonly field `{0}' cannot be passed ref or out (except in a constructor)",
 			/*1650*/ "Fields of static readonly field `{0}' cannot be assigned to (except in a static constructor or a variable initializer)",
 			/*1651*/ "Fields of static readonly field `{0}' cannot be passed ref or out (except in a static constructor)"
 		};
 
 		// The return value is always null.  Returning a value simplifies calling code.
 		Expression Report_AssignToReadonly (ResolveContext ec, Expression right_side)
 		{
 			int i = 0;
 			if (right_side == EmptyExpression.OutAccess.Instance || right_side == EmptyExpression.LValueMemberOutAccess)
 				i += 1;
 			if (IsStatic)
 				i += 2;
 			if (right_side == EmptyExpression.LValueMemberAccess || right_side == EmptyExpression.LValueMemberOutAccess)
 				i += 4;
 			ec.Report.Error (codes [i], loc, msgs [i], GetSignatureForError ());
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="711" endline="718">
<![CDATA[
 		
 	public static bool IsValueType (TypeSpec t)
 	{
 		if (t.IsGenericParameter)
 			return ((TypeParameterSpec) t).IsValueType;
 
 		return t.IsStruct || IsEnumType (t);
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="305" endline="316">
<![CDATA[
 
 		protected static Type ReadParam(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			switch (br.PeekByte())
 			{
 				case ELEMENT_TYPE_TYPEDBYREF
 					br.ReadByte();
 					return module.universe.System_TypedReference;
 				default
 					return ReadTypeOrByRef(module, br, context);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="84" endline="93">
<![CDATA[
 
 		public void ImportAssembly (Assembly assembly, RootNamespace targetNamespace)
 		{
 			// It can be used more than once when importing same assembly
 			// into 2 or more global aliases
 			var definition = GetAssemblyDefinition (assembly);
 
 			var all_types = assembly.GetTypes ();
 			ImportTypes (all_types, targetNamespace, definition.HasExtensionMethod);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6879" endline="6892">
<![CDATA[
 
 		public static bool IsThisAvailable (ResolveContext ec, bool ignoreAnonymous)
 		{
 			if (ec.IsStatic || ec.HasAny (ResolveContext.Options.FieldInitializerScope | ResolveContext.Options.BaseInitializer | ResolveContext.Options.ConstantScope))
 				return false;
 
 			if (ignoreAnonymous || ec.CurrentAnonymousMethod == null)
 				return true;
 
 			if (TypeManager.IsStruct (ec.CurrentType) && ec.CurrentIterator == null)
 				return false;
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1819" endline="1826">
<![CDATA[
 		}
 
 		#endregion
 
 		public static bool operator == (TypeSpec type, PredefinedAttribute pa)
 		{
 			return type == pa.type && pa.type != null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="585" endline="598">
<![CDATA[
 			}
 		}
 
 		readonly string full_name;
 		readonly Module module;
 		Dictionary<string, MetaType> types;
 
 		public MissingAssembly (Universe universe, string fullName)
 			
 		{
 			this.full_name = fullName;
 			this.module = new MissingModule (universe, this);
 			types = new Dictionary<string, MetaType> ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="638" endline="663">
<![CDATA[
 
 		/// <summary>
 		/// Analyze whether CLS-Compliant verification must be execute for this MemberCore.
 		/// </summary>
 		public override bool IsClsComplianceRequired ()
 		{
 			if ((caching_flags & Flags.ClsCompliance_Undetected) == 0)
 				return (caching_flags & Flags.ClsCompliant) != 0;
 
 			caching_flags &= ~Flags.ClsCompliance_Undetected;
 
 			if (HasClsCompliantAttribute) {
 				if ((caching_flags & Flags.ClsCompliantAttributeFalse) != 0)
 					return false;
 
 				caching_flags |= Flags.ClsCompliant;
 				return true;
 			}
 
 			if (Parent.PartialContainer.IsClsComplianceRequired ()) {
 				caching_flags |= Flags.ClsCompliant;
 				return true;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="91" endline="118">
<![CDATA[
 	}
 
 	/// <summary>
 	///   This is an arbitrarily seekable StreamReader wrapper.
 	///
 	///   It uses a self-tuning buffer to cache the seekable data,
 	///   but if the seek is too far, it may read the underly
 	///   stream all over from the beginning.
 	/// </summary>
 	public class SeekableStreamReader 
 	{
 		StreamReader reader;
 		Stream stream;
 
 		static char[] buffer;
 		int read_ahead_length;	// the length of read buffer
 		int buffer_start;       // in chars
 		int char_count;         // count of filled characters in buffer[]
 		int pos;                // index into buffer[]
 
 		public SeekableStreamReader (Stream stream, Encoding encoding)
 		{
 			this.stream = stream;
 
 			const int default_read_ahead = 2048;
 			InitializeStream (default_read_ahead);
 			reader = new StreamReader (stream, encoding, true);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1511" endline="1519">
<![CDATA[
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (!Define (ec))
 				return null;
 
 			eclass = ExprClass.Value;
 			return this;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4620" endline="4627">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Fixed target = (Fixed) t;
 
 			target.decl = (VariableDeclaration) decl.Clone (clonectx);
 			target.statement = statement.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="5162" endline="5169">
<![CDATA[
 
 		protected override void CloneTo (CloneContext clonectx, Statement t)
 		{
 			Using target = (Using) t;
 
 			target.decl = (VariableDeclaration) decl.Clone (clonectx);
 			target.stmt = stmt.Clone (clonectx);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="600" endline="620">
<![CDATA[
 
 		void EmitMoveNext_NoResumePoints (EmitContext ec, Block original_block)
 		{
 			ec.Emit (OpCodes.Ldarg_0);
 			ec.Emit (OpCodes.Ldfld, IteratorHost.PC.Spec);
 
 			ec.Emit (OpCodes.Ldarg_0);
 			ec.EmitInt ((int) State.After);
 			ec.Emit (OpCodes.Stfld, IteratorHost.PC.Spec);
 
 			// We only care if the PC is zero (start executing) or non-zero (don't do anything)
 			ec.Emit (OpCodes.Brtrue, move_next_error);
 
 			SymbolWriter.StartIteratorBody (ec);
 			original_block.Emit (ec);
 			SymbolWriter.EndIteratorBody (ec);
 
 			ec.MarkLabel (move_next_error);
 			ec.Emit (OpCodes.Ldc_I4_0);
 			ec.Emit (OpCodes.Ret);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1205" endline="1211">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			child.Emit (ec);
 
 			ec.Emit (OpCodes.Call, operators [type]);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1982" endline="1995">
<![CDATA[
 	}
 
 	//
 	// Standard composite pattern
 	//
 	public abstract class CompositeExpression 
 	{
 		protected Expression expr;
 
 		protected CompositeExpression (Expression expr)
 		{
 			this.expr = expr;
 			this.loc = expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="595" endline="604">
<![CDATA[
 	}
 	
 	public class StatementExpression 
 		ExpressionStatement expr;
 		
 		public StatementExpression (ExpressionStatement expr)
 		{
 			this.expr = expr;
 			loc = expr.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1932" endline="1943">
<![CDATA[
 	}
 
 	//
 	// Generic type with unbound type arguments, used for typeof (G<,,>)
 	//
 	class GenericOpenTypeExpr 
 	{
 		public GenericOpenTypeExpr (TypeSpec type, /*UnboundTypeArguments args,*/ Location loc)
 		{
 			this.type = type.GetDefinition ();
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8608" endline="8616">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			ec.Report.Error (831, loc, "An expression tree may not contain a base access");
 			return base.CreateExpressionTree (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\Heaps.cs" startline="62" endline="75">
<![CDATA[
 		}
 
 		protected abstract void WriteImpl(MetadataWriter mw);
 	}
 
 	abstract class SimpleHeap 
 	{
 		internal void Freeze()
 		{
 			if (frozen)
 				throw new InvalidOperationException();
 			frozen = true;
 			unalignedlength = GetLength();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="1750" endline="1779">
<![CDATA[
 
 		int TokenizePreprocessorIdentifier (out int c)
 		{
 			// skip over white space
 			do {
 				c = get_char ();
 			} while (c == '\r' || c == ' ' || c == '\t');
 
 
 			int pos = 0;
 			while (c != -1 && c >= 'a' && c <= 'z') {
 				id_builder[pos++] = (char) c;
 				c = get_char ();
 				if (c == '\\') {
 					int peek = peek_char ();
 					if (peek == 'U' || peek == 'u') {
 						int surrogate;
 						c = EscapeUnicode (c, out surrogate);
 						if (surrogate != 0) {
 							if (is_identifier_part_character ((char) c)) {
 								id_builder[pos++] = (char) c;
 							}
 							c = surrogate;
 						}
 					}
 				}
 			}
 			while (c != -1 && c >= 'a' && c <= 'z') {
 				id_builder[pos++] = (char) c;
 				c = get_char ();
 				if (c == '\\') {
 					int peek = peek_char ();
 					if (peek == 'U' || peek == 'u') {
 						int surrogate;
 						c = EscapeUnicode (c, out surrogate);
 						if (surrogate != 0) {
 							if (is_identifier_part_character ((char) c)) {
 								id_builder[pos++] = (char) c;
 							}
 							c = surrogate;
 						}
 					}
 				}
 			}
 
 			return pos;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\const.cs" startline="98" endline="108">
<![CDATA[
 
 		public static void Error_InvalidConstantType (TypeSpec t, Location loc, Report Report)
 		{
 			if (t.IsGenericParameter) {
 				Report.Error (1959, loc,
 					"Type parameter `{0}' cannot be declared const", TypeManager.CSharpName (t));
 			} else {
 				Report.Error (283, loc,
 					"The type `{0}' cannot be declared const", TypeManager.CSharpName (t));
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\pending.cs" startline="359" endline="392">
<![CDATA[
 		
 		/// <summary>
 		///   This function tells whether one of our base classes implements
 		///   the given method (which turns out, it is valid to have an interface
 		///   implementation in a base
 		/// </summary>
 		bool BaseImplements (TypeSpec iface_type, MethodSpec mi, out MethodSpec base_method)
 		{
 			var base_type = container.BaseType;
 
 			//
 			// Setup filter with no return type to give better error message
 			// about mismatch at return type when the check bellow rejects them
 			//
 			var filter = new MemberFilter (mi.Name, mi.Arity, MemberKind.Method, mi.Parameters, null);
 
 			base_method = (MethodSpec) MemberCache.FindMember (base_type, filter, BindingRestriction.None);
 
 			if (base_method == null || (base_method.Modifiers & Modifiers.PUBLIC) == 0)
 				return false;
 
 			if (base_method.DeclaringType.IsInterface)
 				return false;
 
 			if (!TypeSpecComparer.Override.IsEqual (mi.ReturnType, base_method.ReturnType))
 				return false;
 
 			if (!base_method.IsAbstract && !base_method.IsVirtual)
 				// FIXME
 				//        However, it's too late now, the MethodBuilder has already been created (see bug 377519)
 				DefineProxy (iface_type, base_method, mi);
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5040" endline="5048">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (!DoResolveBase (ec))
 				return null;
 
 			SetAssigned (ec);
 			return base.DoResolveLValue (ec, right_side);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\assign.cs" startline="228" endline="237">
<![CDATA[
 
 		#region IAssignMethod Members
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Emit (ec);
 
 			if (leave_copy)
 				Emit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="315" endline="321">
<![CDATA[
 
 		internal LocalVariableEntry (MonoSymbolFile file, MyBinaryReader reader)
 		{
 			Index = reader.ReadLeb128 ();
 			Name = reader.ReadString ();
 			BlockIndex = reader.ReadLeb128 ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="359" endline="365">
<![CDATA[
 
 		internal CapturedVariable (MyBinaryReader reader)
 		{
 			Name = reader.ReadString ();
 			CapturedName = reader.ReadString ();
 			Kind = (CapturedKind) reader.ReadByte ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\PEReader.cs" startline="49" endline="90">
<![CDATA[
 
 		internal void Read(BinaryReader br)
 		{
 			Signature = br.ReadUInt32();
 			if (Signature != IMAGE_NT_HEADERS.MAGIC_SIGNATURE)
 			{
 				throw new BadImageFormatException();
 			}
 			FileHeader.Read(br);
 			OptionalHeader.Read(br);
 		}
 	}
 
 	sealed class IMAGE_FILE_HEADER
 	{
 		public const WORD IMAGE_FILE_MACHINE_I386 = 0x014c;
 		public const WORD IMAGE_FILE_MACHINE_IA64 = 0x0200;
 		public const WORD IMAGE_FILE_MACHINE_AMD64 = 0x8664;
 
 		public const WORD IMAGE_FILE_32BIT_MACHINE = 0x0100;
 		public const WORD IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002;
 		public const WORD IMAGE_FILE_LARGE_ADDRESS_AWARE = 0x0020;
 		public const WORD IMAGE_FILE_DLL = 0x2000;
 
 		public WORD Machine;
 		public WORD NumberOfSections;
 		public DWORD TimeDateStamp;
 		public DWORD PointerToSymbolTable;
 		public DWORD NumberOfSymbols;
 		public WORD SizeOfOptionalHeader;
 		public WORD Characteristics;
 
 		internal void Read(BinaryReader br)
 		{
 			Machine = br.ReadUInt16();
 			NumberOfSections = br.ReadUInt16();
 			TimeDateStamp = br.ReadUInt32();
 			PointerToSymbolTable = br.ReadUInt32();
 			NumberOfSymbols = br.ReadUInt32();
 			SizeOfOptionalHeader = br.ReadUInt16();
 			Characteristics = br.ReadUInt16();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1929" endline="1962">
<![CDATA[
 	}
 
 	sealed class AssemblyTable 
 	{
 		internal const int Index = 0x20;
 
 		internal struct Record
 		{
 			internal int HashAlgId;
 			internal ushort MajorVersion;
 			internal ushort MinorVersion;
 			internal ushort BuildNumber;
 			internal ushort RevisionNumber;
 			internal int Flags;
 			internal int PublicKey;
 			internal int Name;
 			internal int Culture;
 		}
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].HashAlgId = mr.ReadInt32();
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKey = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].HashAlgId = mr.ReadInt32();
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKey = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2028" endline="2043">
<![CDATA[
 
 		internal override void Read(MetadataReader mr)
 		{
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKeyOrToken = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 			for (int i = 0; i < records.Length; i++)
 			{
 				records[i].MajorVersion = mr.ReadUInt16();
 				records[i].MinorVersion = mr.ReadUInt16();
 				records[i].BuildNumber = mr.ReadUInt16();
 				records[i].RevisionNumber = mr.ReadUInt16();
 				records[i].Flags = mr.ReadInt32();
 				records[i].PublicKeyOrToken = mr.ReadBlobIndex();
 				records[i].Name = mr.ReadStringIndex();
 				records[i].Culture = mr.ReadStringIndex();
 				records[i].HashValue = mr.ReadBlobIndex();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\iterators.cs" startline="621" endline="686">
<![CDATA[
 
 		void EmitMoveNext (EmitContext ec)
 		{
 			move_next_ok = ec.DefineLabel ();
 			move_next_error = ec.DefineLabel ();
 
 			if (resume_points == null) {
 				EmitMoveNext_NoResumePoints (ec, block);
 				return;
 			}
 
 			current_pc = ec.GetTemporaryLocal (TypeManager.uint32_type);
 			ec.Emit (OpCodes.Ldarg_0);
 			ec.Emit (OpCodes.Ldfld, IteratorHost.PC.Spec);
 			ec.Emit (OpCodes.Stloc, current_pc);
 
 			// We're actually in state 'running', but this is as good a PC value as any if there's an abnormal exit
 			ec.Emit (OpCodes.Ldarg_0);
 			ec.EmitInt ((int) State.After);
 			ec.Emit (OpCodes.Stfld, IteratorHost.PC.Spec);
 
 			Label [] labels = new Label [1 + resume_points.Count];
 			labels [0] = ec.DefineLabel ();
 
 			bool need_skip_finally = false;
 			for (int i = 0; i < resume_points.Count; ++i) {
 				ResumableStatement s = resume_points [i];
 				need_skip_finally |= s is ExceptionStatement;
 				labels [i+1] = s.PrepareForEmit (ec);
 			}
 			for (int i = 0; i < resume_points.Count; ++i) {
 				ResumableStatement s = resume_points [i];
 				need_skip_finally |= s is ExceptionStatement;
 				labels [i+1] = s.PrepareForEmit (ec);
 			}
 
 			if (need_skip_finally) {
 				skip_finally = ec.GetTemporaryLocal (TypeManager.bool_type);
 				ec.Emit (OpCodes.Ldc_I4_0);
 				ec.Emit (OpCodes.Stloc, skip_finally);
 			}
 
 			SymbolWriter.StartIteratorDispatcher (ec);
 			ec.Emit (OpCodes.Ldloc, current_pc);
 			ec.Emit (OpCodes.Switch, labels);
 
 			ec.Emit (OpCodes.Br, move_next_error);
 			SymbolWriter.EndIteratorDispatcher (ec);
 
 			ec.MarkLabel (labels [0]);
 
 			SymbolWriter.StartIteratorBody (ec);
 			block.Emit (ec);
 			SymbolWriter.EndIteratorBody (ec);
 
 			SymbolWriter.StartIteratorDispatcher (ec);
 
 			ec.Emit (OpCodes.Ldarg_0);
 			ec.EmitInt ((int) State.After);
 			ec.Emit (OpCodes.Stfld, IteratorHost.PC.Spec);
 
 			ec.MarkLabel (move_next_error);
 			ec.EmitInt (0);
 			ec.Emit (OpCodes.Ret);
 
 			ec.MarkLabel (move_next_ok);
 			ec.Emit (OpCodes.Ldc_I4_1);
 			ec.Emit (OpCodes.Ret);
 
 			SymbolWriter.EndIteratorDispatcher (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MemberInfo.cs" startline="43" endline="53">
<![CDATA[
 		}
 
 		public abstract Module Module
 		{
 			get;
 		}
 
 		public bool IsDefined(Type attributeType, bool inherit)
 		{
 			return CustomAttributeData.__GetCustomAttributes(this, attributeType, inherit).Count != 0;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="1451" endline="1503">
<![CDATA[
 		}
 
 		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
 		{
 			if (target_type == TypeManager.byte_type) {
 				if (in_checked_context && Value > Byte.MaxValue)
 					throw new OverflowException ();
 				return new ByteConstant ((byte) Value, Location);
 			}
 			if (target_type == TypeManager.sbyte_type) {
 				if (in_checked_context && Value > ((ulong) SByte.MaxValue))
 					throw new OverflowException ();
 				return new SByteConstant ((sbyte) Value, Location);
 			}
 			if (target_type == TypeManager.short_type) {
 				if (in_checked_context && Value > ((ulong) Int16.MaxValue))
 					throw new OverflowException ();
 				return new ShortConstant ((short) Value, Location);
 			}
 			if (target_type == TypeManager.ushort_type) {
 				if (in_checked_context && Value > UInt16.MaxValue)
 					throw new OverflowException ();
 				return new UShortConstant ((ushort) Value, Location);
 			}
 			if (target_type == TypeManager.int32_type) {
 				if (in_checked_context && Value > UInt32.MaxValue)
 					throw new OverflowException ();
 				return new IntConstant ((int) Value, Location);
 			}
 			if (target_type == TypeManager.uint32_type) {
 				if  (in_checked_context && Value > UInt32.MaxValue)
 					throw new OverflowException ();
 				return new UIntConstant ((uint) Value, Location);
 			}
 			if (target_type == TypeManager.int64_type) {
 				if (in_checked_context && Value > Int64.MaxValue)
 					throw new OverflowException ();
 				return new LongConstant ((long) Value, Location);
 			}
 			if (target_type == TypeManager.float_type)
 				return new FloatConstant ((float) Value, Location);
 			if (target_type == TypeManager.double_type)
 				return new DoubleConstant ((double) Value, Location);
 			if (target_type == TypeManager.char_type) {
 				if (in_checked_context && Value > Char.MaxValue)
 					throw new OverflowException ();
 				return new CharConstant ((char) Value, Location);
 			}
 			if (target_type == TypeManager.decimal_type)
 				return new DecimalConstant ((decimal) Value, Location);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1235" endline="1254">
<![CDATA[
 	}
 
 	//
 	// Before emitting any code we have to change all MVAR references to VAR
 	// when the method is of generic type and has hoisted variables
 	//
 	public class TypeParameterMutator
 	{
 		TypeParameter[] mvar;
 		TypeParameter[] var;
 		Dictionary<TypeSpec, TypeSpec> mutated_typespec = new Dictionary<TypeSpec, TypeSpec> ();
 
 		public TypeParameterMutator (TypeParameter[] mvar, TypeParameter[] var)
 		{
 			if (mvar.Length != var.Length)
 				throw new ArgumentException ();
 
 			this.mvar = mvar;
 			this.var = var;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5288" endline="5302">
<![CDATA[
 
 		public static bool IsSpecialMethodInvocation (ResolveContext ec, MethodSpec method, Location loc)
 		{
 			if (!method.IsReservedMethod)
 				return false;
 
 			if (ec.HasSet (ResolveContext.Options.InvokeSpecialName) || ec.CurrentMemberDefinition.IsCompilerGenerated)
 				return false;
 
 			ec.Report.SymbolRelatedToPreviousError (method);
 			ec.Report.Error (571, loc, "`{0}'
 				method.GetSignatureForError ());
 	
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="290" endline="300">
<![CDATA[
 		}
 
 		#endregion
 
 		public MethodSpec GetGenericMethodDefinition ()
 		{
 			if (!IsGeneric && !DeclaringType.IsGeneric)
 				return this;
 
 			return MemberCache.GetMember (declaringType, this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="442" endline="456">
<![CDATA[
 	}
 
 	public class AnonymousScopeEntry
 	{
 		#region This is actually written to the symbol file
 		public readonly int ID;
 		#endregion
 
 		List<CapturedVariable> captured_vars = new List<CapturedVariable> ();
 		List<CapturedScope> captured_scopes = new List<CapturedScope> ();
 
 		public AnonymousScopeEntry (int id)
 		{
 			this.ID = id;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4310" endline="4320">
<![CDATA[
 	}
 
 	public class Unsafe 
 		public Block Block;
 
 		public Unsafe (Block b, Location loc)
 		{
 			Block = b;
 			Block.Unsafe = true;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="6053" endline="6060">
<![CDATA[
 
 		//
 		// For expressions like int[] foo = { 1, 2, 3 };
 		//
 		public ArrayCreation (FullNamedExpression requested_base_type, ArrayInitializer initializers)
 			
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8966" endline="8978">
<![CDATA[
 	}
 
 	public class FixedBufferPtr 
 		Expression array;
 
 		public FixedBufferPtr (Expression array, TypeSpec array_type, Location l)
 		{
 			this.array = array;
 			this.loc = l;
 
 			type = PointerContainer.MakeType (array_type);
 			eclass = ExprClass.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1533" endline="1544">
<![CDATA[
 
 		//
 		// Encodes single property named argument per call
 		//
 		public void EncodeNamedPropertyArgument (PropertySpec property, Constant value)
 		{
 			Encode ((ushort) 1);	// length
 			Encode ((byte) 0x54); // property
 			Encode (property.MemberType);
 			Encode (property.Name);
 			value.EncodeAttributeValue (null, this, property.MemberType);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1545" endline="1556">
<![CDATA[
 
 		//
 		// Encodes single field named argument per call
 		//
 		public void EncodeNamedFieldArgument (FieldSpec field, Constant value)
 		{
 			Encode ((ushort) 1);	// length
 			Encode ((byte) 0x53); // field
 			Encode (field.MemberType);
 			Encode (field.Name);
 			value.EncodeAttributeValue (null, this, field.MemberType);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8594" endline="8600">
<![CDATA[
 
 		public BaseThis (TypeSpec type, Location loc)
 			
 		{
 			this.type = type;
 			eclass = ExprClass.Variable;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\nullable.cs" startline="28" endline="34">
<![CDATA[
 		public NullableType (TypeExpr underlying, Location l)
 		{
 			this.underlying = underlying;
 			loc = l;
 
 			eclass = ExprClass.Type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\dynamic.cs" startline="57" endline="82">
<![CDATA[
 	}
 
 	#region Dynamic runtime binder expressions
 
 	//
 	// Expression created from runtime dynamic object value by dynamic binder
 	//
 	public class RuntimeValueExpression 
 	{
 #if !NET_4_0
 		public class DynamicMetaObject
 		{
 			public TypeSpec RuntimeType;
 			public TypeSpec LimitType;
 			public SLE.Expression Expression;
 		}
 #endif
 
 		readonly DynamicMetaObject obj;
 
 		public RuntimeValueExpression (DynamicMetaObject obj, TypeSpec type)
 		{
 			this.obj = obj;
 			this.type = type;
 			this.eclass = ExprClass.Variable;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4250" endline="4260">
<![CDATA[
 	}
 
 	public class Unchecked 
 		public Block Block;
 		
 		public Unchecked (Block b, Location loc)
 		{
 			Block = b;
 			b.Unchecked = true;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4280" endline="4290">
<![CDATA[
 	}
 
 	public class Checked 
 		public Block Block;
 		
 		public Checked (Block b, Location loc)
 		{
 			Block = b;
 			b.Unchecked = false;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\generic.cs" startline="1311" endline="1323">
<![CDATA[
 	}
 
 	/// <summary>
 	///   A TypeExpr which already resolved to a type parameter.
 	/// </summary>
 	public class TypeParameterExpr 
 		
 		public TypeParameterExpr (TypeParameter type_parameter, Location loc)
 		{
 			this.type = type_parameter.Type;
 			this.eclass = ExprClass.TypeParameter;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="343" endline="354">
<![CDATA[
 
 		public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention,
 			Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers,
 			Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers,
 			CallingConvention nativeCallConv, CharSet nativeCharSet)
 		{
 			MethodBuilder mb = DefineMethod(name, attributes | MethodAttributes.PinvokeImpl, callingConvention,
 				returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers,
 				parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers);
 			mb.SetDllImportPseudoCustomAttribute(dllName, entryName, nativeCallConv, nativeCharSet, null, null, null, null, null);
 			return mb;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="82" endline="90">
<![CDATA[
 
 		public MemberFilter (MethodSpec m)
 		{
 			Name = m.Name;
 			Kind = MemberKind.Method;
 			Parameters = m.Parameters;
 			MemberType = m.ReturnType;
 			arity = m.Arity;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="134" endline="140">
<![CDATA[
 
 		public void __SetAssemblyVersion(Version version)
 		{
 			AssemblyName oldName = GetName();
 			SetVersionHelper(version);
 			universe.RenameAssembly(this, oldName);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\literal.cs" startline="200" endline="206">
<![CDATA[
 
 		static void Error_664 (ResolveContext ec, Location loc, string type, string suffix)
 		{
 			ec.Report.Error (664, loc,
 				"Literal of type double cannot be implicitly converted to type `{0}'. Add suffix `{1}' to create a literal of this type",
 				type, suffix);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\field.cs" startline="242" endline="248">
<![CDATA[
 
 		public static void Error_VariableOfStaticClass (Location loc, string variable_name, TypeSpec static_class, Report Report)
 		{
 			Report.SymbolRelatedToPreviousError (static_class);
 			Report.Error (723, loc, "`{0}'
 				variable_name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="624" endline="635">
<![CDATA[
 	}
 
 	sealed class ManifestModule 
 	{
 		private readonly AssemblyBuilder assembly;
 		private readonly Guid guid = Guid.NewGuid();
 
 		internal ManifestModule(AssemblyBuilder assembly)
 			
 		{
 			this.assembly = assembly;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4984" endline="4996">
<![CDATA[
 
 		public override void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			//
 			// ParameterReferences might already be a reference
 			//
 			if (IsRef) {
 				EmitLoad (ec);
 				return;
 			}
 
 			base.AddressOf (ec, mode);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="39" endline="45">
<![CDATA[
 		internal GenericMethodInstance(Type declaringType, MethodInfo method, Type[] methodArgs)
 		{
 			System.Diagnostics.Debug.Assert(!(method is GenericMethodInstance));
 			this.declaringType = declaringType;
 			this.method = method;
 			this.methodArgs = methodArgs;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="22" endline="29">
<![CDATA[
 		public RootNamespace (string alias_name)
 			
 		{
 			this.alias_name = alias_name;
 
 			all_namespaces = new Dictionary<string, Namespace> ();
 			all_namespaces.Add ("", this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="804" endline="864">
<![CDATA[
 		}
 
 		internal void WriteMetadata(MetadataWriter mw)
 		{
 			mw.Write(0x424A5342);			// Signature ("BSJB")
 			mw.Write((ushort)1);			// MajorVersion
 			mw.Write((ushort)1);			// MinorVersion
 			mw.Write(0);					// Reserved
 			byte[] version = StringToPaddedUTF8(asm.ImageRuntimeVersion);
 			mw.Write(version.Length);		// Length
 			mw.Write(version);
 			mw.Write((ushort)0);			// Flags
 			// #Blob is the only optional heap
 			if (Blobs.IsEmpty)
 			{
 				mw.Write((ushort)4);		// Streams
 			}
 			else
 			{
 				mw.Write((ushort)5);		// Streams
 			}
 
 			int offset = GetHeaderLength();
 
 			// Streams
 			mw.Write(offset);				// Offset
 			mw.Write(Tables.Length);		// Size
 			mw.Write(StringToPaddedUTF8("#~"));
 			offset += Tables.Length;
 
 			mw.Write(offset);				// Offset
 			mw.Write(Strings.Length);		// Size
 			mw.Write(StringToPaddedUTF8("#Strings"));
 			offset += Strings.Length;
 
 			mw.Write(offset);				// Offset
 			mw.Write(UserStrings.Length);	// Size
 			mw.Write(StringToPaddedUTF8("#US"));
 			offset += UserStrings.Length;
 
 			mw.Write(offset);				// Offset
 			mw.Write(Guids.Length);			// Size
 			mw.Write(StringToPaddedUTF8("#GUID"));
 			offset += Guids.Length;
 
 			if (!Blobs.IsEmpty)
 			{
 				mw.Write(offset);				// Offset
 				mw.Write(Blobs.Length);			// Size
 				mw.Write(StringToPaddedUTF8("#Blob"));
 			}
 
 			Tables.Write(mw);
 			Strings.Write(mw);
 			UserStrings.Write(mw);
 			Guids.Write(mw);
 			if (!Blobs.IsEmpty)
 			{
 				Blobs.Write(mw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="728" endline="737">
<![CDATA[
 	}
 
 	public class FlowBranchingTryCatch 
 	{
 		TryCatch stmt;
 		public FlowBranchingTryCatch (FlowBranching parent, TryCatch stmt)
 			
 		{
 			this.stmt = stmt;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="867" endline="877">
<![CDATA[
 		}
 
 		SavedOrigin saved_origins;
 
 		public FlowBranchingException (FlowBranching parent,
 					       ExceptionStatement stmt)
 			
 				null, stmt.loc)
 		{
 			this.stmt = stmt;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolWriter.cs" startline="241" endline="266">
<![CDATA[
 	}
 
 	public class SourceMethodBuilder
 	{
 		List<LocalVariableEntry> _locals;
 		List<CodeBlockEntry> _blocks;
 		List<ScopeVariable> _scope_vars;
 #if NET_2_1
 		System.Collections.Stack _block_stack;
 #else		
 		Stack<CodeBlockEntry> _block_stack;
 #endif
 		string _real_name;
 		IMethodDef _method;
 		ICompileUnit _comp_unit;
 //		MethodEntry.Flags _method_flags;
 		int _ns_id;
 
 		public SourceMethodBuilder (ICompileUnit comp_unit, int ns_id, IMethodDef method)
 		{
 			this._comp_unit = comp_unit;
 			this._method = method;
 			this._ns_id = ns_id;
 
 			method_lines = new LineNumberEntry [32];
 		}
 
 		private LineNumberEntry [] method_lines;
 		private int method_lines_pos = 0;
 		public SourceMethodBuilder (ICompileUnit comp_unit, int ns_id, IMethodDef method)
 		{
 			this._comp_unit = comp_unit;
 			this._method = method;
 			this._ns_id = ns_id;
 
 			method_lines = new LineNumberEntry [32];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Signature.cs" startline="120" endline="128">
<![CDATA[
 
 		internal static Type ReadTypeSpec(ModuleReader module, ByteReader br, IGenericContext context)
 		{
 			// LAMESPEC a TypeSpec can contain custom modifiers (C++/CLI generates "newarr (TypeSpec with custom modifiers)")
 			SkipCustomModifiers(br);
 			// LAMESPEC anything can be adorned by (useless) custom modifiers
 			// also, VAR and MVAR are also used in TypeSpec (contrary to what the spec says)
 			return ReadType(module, br, context);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="730" endline="747">
<![CDATA[
 
 		internal SourceFileEntry (MonoSymbolFile file, MyBinaryReader reader)
 		{
 			this.file = file;
 
 			Index = reader.ReadInt32 ();
 			DataOffset = reader.ReadInt32 ();
 
 			int old_pos = (int) reader.BaseStream.Position;
 			reader.BaseStream.Position = DataOffset;
 
 			file_name = reader.ReadString ();
 			guid = reader.ReadBytes (16);
 			hash = reader.ReadBytes (16);
 			auto_generated = reader.ReadByte () == 1;
 
 			reader.BaseStream.Position = old_pos;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\AssemblyBuilder.cs" startline="116" endline="133">
<![CDATA[
 
 		private void SetVersionHelper(Version version)
 		{
 			if (version == null)
 			{
 				majorVersion = 0;
 				minorVersion = 0;
 				buildVersion = 0;
 				revisionVersion = 0;
 			}
 			else
 			{
 				majorVersion = (ushort)version.Major;
 				minorVersion = (ushort)version.Minor;
 				buildVersion = version.Build == -1 ? (ushort)0 
 				revisionVersion = version.Revision == -1 ? (ushort)0 
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9272" endline="9279">
<![CDATA[
 		}
 
 		public CollectionElementInitializer (Expression argument)
 			
 		{
 			base.arguments.Add (new ElementInitializerArgument (argument));
 			this.loc = argument.Location;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5470" endline="5480">
<![CDATA[
 		
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="747" endline="756">
<![CDATA[
 
 		public override void EmitStatement (EmitContext ec)
 		{
 			Emit (ec);
 			// 
 			// Pop the return value if there is one
 			//
 			if (type != TypeManager.void_type)
 				ec.Emit (OpCodes.Pop);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="3213" endline="3219">
<![CDATA[
 
 		#region IBaseMembersProvider Members
 
 		public virtual IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			return baseType == null ? null 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="992" endline="1338">
<![CDATA[
 
 		Expression initializer;
 		Field backing_field;
 		List<FieldDeclarator> declarators;
 
 		public EventField (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 		{
 			Add = new AddDelegateMethod (this);
 			Remove = new RemoveDelegateMethod (this);
 		}
 
 		#region Properties
 
 		bool HasBackingField {
 			get {
 				return !IsInterface && (ModFlags & Modifiers.ABSTRACT) == 0;
 			}
 		}
 
 		public Expression Initializer {
 			get {
 				return initializer;
 			}
 			set {
 				initializer = value;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return HasBackingField ? attribute_targets 
 			}
 		}
 
 		#endregion
 
 		public void AddDeclarator (FieldDeclarator declarator)
 		{
 			if (declarators == null)
 				declarators = new List<FieldDeclarator> (2);
 
 			declarators.Add (declarator);
 
 			// TODO
 			Parent.AddMember (this, declarator.Name.Value);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.Field) {
 				backing_field.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				int errors = Report.Errors;
 				Add.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				if (errors == Report.Errors)
 					Remove.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		public override bool Define()
 		{
 			var mod_flags_src = ModFlags;
 
 			if (!base.Define ())
 				return false;
 
 			if (declarators != null) {
 				if ((mod_flags_src & Modifiers.DEFAULT_ACCESS_MODIFER) != 0)
 					mod_flags_src &= ~(Modifiers.AccessibilityMask | Modifiers.DEFAULT_ACCESS_MODIFER);
 
 				var t = new TypeExpression (MemberType, TypeExpression.Location);
 				int index = Parent.PartialContainer.Events.IndexOf (this);
 				foreach (var d in declarators) {
 					var ef = new EventField (Parent, t, mod_flags_src, new MemberName (d.Name.Value, d.Name.Location), OptAttributes);
 
 					if (d.Initializer != null)
 						ef.initializer = d.Initializer;
 
 					Parent.PartialContainer.Events.Insert (++index, ef);
 				}
 			}
 
 			if (!HasBackingField) {
 				SetIsUsed ();
 				return true;
 			}
 
 			if (Add.IsInterfaceImplementation)
 				SetIsUsed ();
 
 			backing_field = new Field (Parent,
 				new TypeExpression (MemberType, Location),
 				Modifiers.BACKING_FIELD | Modifiers.COMPILER_GENERATED | Modifiers.PRIVATE | (ModFlags & (Modifiers.STATIC | Modifiers.UNSAFE)),
 				MemberName, null);
 
 			Parent.PartialContainer.AddField (backing_field);
 			backing_field.Initializer = Initializer;
 			backing_field.ModFlags &= ~Modifiers.COMPILER_GENERATED;
 
 			// Call define because we passed fields definition
 			backing_field.Define ();
 
 			// Set backing field for event fields
 			spec.BackingField = backing_field.Spec;
 
 			return true;
 		}
 	}
 
 	public abstract class Event 
 	{
 		public abstract class AEventAccessor 
 		{
 			protected readonly Event method;
 			ParametersCompiled parameters;
 
 			static readonly string[] attribute_targets = new string [] { "method", "param", "return" };
 
 			public const string AddPrefix = "add_";
 			public const string RemovePrefix = "remove_";
 
 			protected AEventAccessor (Event method, string prefix, Attributes attrs, Location loc)
 				
 			{
 				this.method = method;
 				this.ModFlags = method.ModFlags;
 				this.parameters = ParametersCompiled.CreateImplicitParameter (method.TypeExpression, loc);
 			}
 
 			public bool IsInterfaceImplementation {
 				get { return method_data.implementing != null; }
 			}
 
 			public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Type == pa.MethodImpl) {
 					method.is_external_implementation = a.IsInternalCall ();
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			protected override void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Target == AttributeTargets.Parameter) {
 					parameters[0].ApplyAttributeBuilder (a, ctor, cdata, pa);
 					return;
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override AttributeTargets AttributeTargets {
 				get {
 					return AttributeTargets.Method;
 				}
 			}
 
 			public override bool IsClsComplianceRequired ()
 			{
 				return method.IsClsComplianceRequired ();
 			}
 
 			public virtual MethodBuilder Define (DeclSpace parent)
 			{
 				parameters.Resolve (this);
 
 				method_data = new MethodData (method, method.ModFlags,
 					method.flags | MethodAttributes.HideBySig | MethodAttributes.SpecialName, this);
 
 				if (!method_data.Define (parent, method.GetFullName (MemberName), Report))
 					return null;
 
 				MethodBuilder mb = method_data.MethodBuilder;
 
 				Spec = new MethodSpec (MemberKind.Method, parent.PartialContainer.Definition, this, ReturnType, mb, ParameterInfo, method.ModFlags);
 				Spec.IsAccessor = true;
 
 				return mb;
 			}
 
 			public override TypeSpec ReturnType {
 				get {
 					return TypeManager.void_type;
 				}
 			}
 
 			public override ObsoleteAttribute GetAttributeObsolete ()
 			{
 				return method.GetAttributeObsolete ();
 			}
 
 			public override string[] ValidAttributeTargets {
 				get {
 					return attribute_targets;
 				}
 			}
 
 			public override ParametersCompiled ParameterInfo {
 				get {
 					return parameters;
 				}
 			}
 		}
 
 		AEventAccessor add, remove;
 		EventBuilder EventBuilder;
 		protected EventSpec spec;
 
 		protected Event (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs)
 		{
 		}
 
 		#region Properties
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Event;
 			}
 		}
 
 		public AEventAccessor Add {
 			get {
 				return this.add;
 			}
 			set {
 				add = value;
 				Parent.AddMember (value);
 			}
 		}
 
 		public AEventAccessor Remove {
 			get {
 				return this.remove;
 			}
 			set {
 				remove = value;
 				Parent.AddMember (value);
 			}
 		}
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			EventBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		protected override bool CheckOverrideAgainstBase (MemberSpec base_member)
 		{
 			var ok = base.CheckOverrideAgainstBase (base_member);
 
 			if (!CheckAccessModifiers (this, base_member)) {
 				Error_CannotChangeAccessModifiers (this, base_member);
 				ok = false;
 			}
 
 			return ok;
 		}
 
 		public override bool Define ()
 		{
 			if (!base.Define ())
 				return false;
 
 			if (!TypeManager.IsDelegateType (MemberType)) {
 				Report.Error (66, Location, "`{0}'
 			}
 
 			if (!CheckBase ())
 				return false;
 
 			//
 			// Now define the accessors
 			//
 			var AddBuilder = Add.Define (Parent);
 			if (AddBuilder == null)
 				return false;
 
 			var RemoveBuilder = remove.Define (Parent);
 			if (RemoveBuilder == null)
 				return false;
 
 			EventBuilder = Parent.TypeBuilder.DefineEvent (GetFullName (MemberName), EventAttributes.None, MemberType.GetMetaInfo ());
 			EventBuilder.SetAddOnMethod (AddBuilder);
 			EventBuilder.SetRemoveOnMethod (RemoveBuilder);
 
 			spec = new EventSpec (Parent.Definition, this, MemberType, ModFlags, Add.Spec, remove.Spec);
 
 			Parent.MemberCache.AddMember (this, Name, spec);
 			Parent.MemberCache.AddMember (this, AddBuilder.Name, Add.Spec);
 			Parent.MemberCache.AddMember (this, RemoveBuilder.Name, remove.Spec);
 
 			return true;
 		}
 
 		public override void Emit ()
 		{
 			CheckReservedNameConflict (null, add.Spec);
 			CheckReservedNameConflict (null, remove.Spec);
 
 			if (OptAttributes != null) {
 				OptAttributes.Emit ();
 			}
 
 			Add.Emit (Parent);
 			Remove.Emit (Parent);
 
 			base.Emit ();
 		}
 
 		//
 		//   Represents header string for documentation comment.
 		//
 		public override string DocCommentHeader {
 			get { return "E
 		}
 	}
 
 	public class EventSpec 
 	{
 		MethodSpec add, remove;
 		FieldSpec backing_field;
 
 		public EventSpec (TypeSpec declaringType, IMemberDefinition definition, TypeSpec eventType, Modifiers modifiers, MethodSpec add, MethodSpec remove)
 			
 		{
 			this.AccessorAdd = add;
 			this.AccessorRemove = remove;
 			this.MemberType = eventType;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="499" endline="519">
<![CDATA[
 
 		/// <summary>
 		///   Emits the code for the expression
 		/// </summary>
 		///
 		/// <remarks>
 		///   The Emit method is invoked to generate the code
 		///   for the expression.  
 		/// </remarks>
 		public abstract void Emit (EmitContext ec);
 
 
 		// Emit code to branch to @target if this expression is equivalent to @on_true.
 		// The default implementation is to emit the value, and then emit a brtrue or brfalse.
 		// Subclasses can provide more efficient implementations, but those MUST be equivalent,
 		// including the use of conditional branches.  Note also that a branch MUST be emitted
 		public virtual void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			Emit (ec);
 			ec.Emit (on_true ? OpCodes.Brtrue 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1243" endline="1254">
<![CDATA[
 		}
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if ((a.HasSecurityAttribute)) {
 				a.Error_InvalidSecurityParent ();
 				return;
 			}
 
 			EventBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="60" endline="70">
<![CDATA[
 				
 		/// <summary>
 		///   Return value indicates whether all code paths emitted return.
 		/// </summary>
 		protected abstract void DoEmit (EmitContext ec);
 
 		public virtual void Emit (EmitContext ec)
 		{
 			ec.Mark (loc);
 			DoEmit (ec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8617" endline="8626">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			base.Emit (ec);
 
 			if (ec.CurrentType.IsStruct) {
 				ec.Emit (OpCodes.Ldobj, ec.CurrentType);
 				ec.Emit (OpCodes.Box, ec.CurrentType);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="281" endline="287">
<![CDATA[
 
 		public override void DefineConstants ()
 		{
 			if (!Parameters.IsEmpty) {
 				parameters.ResolveDefaultValues (this);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9014" endline="9021">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			base.Emit (ec);
 			
 			ec.EmitInt (0);
 			ec.Emit (OpCodes.Ldelema, array_type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5304" endline="5310">
<![CDATA[
 
 		void Error_PropertyNotValid (ResolveContext ec)
 		{
 			ec.Report.SymbolRelatedToPreviousError (best_candidate);
 			ec.Report.Error (1546, loc, "Property or event `{0}' is not supported by the C# language",
 				GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1899" endline="1905">
<![CDATA[
 					
 		public virtual void Error_AlreadyDeclaredTypeParameter (string name, Location loc)
 		{
 			ParametersBlock.TopBlock.Report.Error (412, loc,
 				"The type parameter name `{0}' is the same as local variable or parameter name",
 				name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="198" endline="205">
<![CDATA[
 
 		static void Error_InvalidNamedArgument (ResolveContext rc, NamedArgument name)
 		{
 			rc.Report.Error (617, name.Location, "`{0}' is not a valid named attribute argument. Named attribute arguments " +
 				      "must be fields which are not readonly, static, const or read-write properties which are " +
 				      "public and not static",
 			      name.Name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="206" endline="212">
<![CDATA[
 
 		static void Error_InvalidNamedArgumentType (ResolveContext rc, NamedArgument name)
 		{
 			rc.Report.Error (655, name.Location,
 				"`{0}' is not a valid named attribute argument because it is not a valid attribute parameter type",
 				name.Name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1475" endline="1481">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			base.Emit (ec);
 			
 			ec.Emit (OpCodes.Box, child.Type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="789" endline="797">
<![CDATA[
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			rc.Report.Error (1947, loc,
 				"A range variable `{0}' cannot be assigned to. Consider using `let' clause to store the value",
 				Name);
 
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="757" endline="763">
<![CDATA[
 
 		public override void Error_AlreadyDeclaredTypeParameter (string name, Location loc)
 		{
 			TopBlock.Report.Error (1948, loc,
 				"A range variable `{0}' conflicts with a method type parameter",
 				name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="604" endline="611">
<![CDATA[
 
 		internal CompileUnitEntry (MonoSymbolFile file, MyBinaryReader reader)
 		{
 			this.file = file;
 
 			Index = reader.ReadInt32 ();
 			DataOffset = reader.ReadInt32 ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="361" endline="367">
<![CDATA[
 
 		public static void Error_TypeDoesNotContainDefinition (ResolveContext ec, Location loc, TypeSpec type, string name)
 		{
 			ec.Report.SymbolRelatedToPreviousError (type);
 			ec.Report.Error (117, loc, "`{0}' does not contain a definition for `{1}'",
 				TypeManager.CSharpName (type), name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="579" endline="587">
<![CDATA[
 
 		public void SetDefinition (TypeSpec ts)
 		{
 			this.definition = ts.MemberDefinition;
 			this.info = ts.GetMetaInfo ();
 			this.BaseType = ts.BaseType;
 			this.Interfaces = ts.Interfaces;
 			this.modifiers = ts.Modifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9707" endline="9713">
<![CDATA[
 		
 		public AnonymousTypeParameter (Parameter parameter)
 			
 		{
 			this.Name = parameter.Name;
 			this.loc = parameter.Location;
 		}		
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1508" endline="1514">
<![CDATA[
 
 		public override void Emit (EmitContext ec)
 		{
 			base.Emit (ec);
 
 			ec.Emit (OpCodes.Unbox_Any, type);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1184" endline="1190">
<![CDATA[
 
 		public static void Error_AddressOfCapturedVar (ResolveContext ec, IVariableReference var, Location loc)
 		{
 			ec.Report.Error (1686, loc,
 				"Local variable or parameter `{0}' cannot have their address taken and be used inside an anonymous method or lambda expression",
 				var.Name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="66" endline="72">
<![CDATA[
 
 		public override void Error_NamespaceDoesNotExist (Location loc, string name, int arity, IMemberContext ctx)
 		{
 			ctx.Compiler.Report.Error (400, loc,
 				"The type or namespace name `{0}' could not be found in the global namespace (are you missing an assembly reference?)",
 				name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9587" endline="9602">
<![CDATA[
 	}
 
 	public class NewAnonymousType 
 	{
 		static readonly AnonymousTypeParameter[] EmptyParameters = new AnonymousTypeParameter[0];
 
 		List<AnonymousTypeParameter> parameters;
 		readonly TypeContainer parent;
 		AnonymousTypeClass anonymous_type;
 
 		public NewAnonymousType (List<AnonymousTypeParameter> parameters, TypeContainer parent, Location loc)
 			 
 		{
 			this.parameters = parameters;
 			this.parent = parent;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1122" endline="1248">
<![CDATA[
 
 			public AttributeUsageAttribute AttributeUsage;
 			public ObsoleteAttribute Obsolete;
 			public string[] Conditionals;
 			public string DefaultIndexerName;
 			public bool IsNotCLSCompliant;
 			public TypeSpec CoClass;
 			
 			public static AttributesBag Read (MemberInfo mi, MetadataImporter importer)
 			{
 				AttributesBag bag = null;
 				List<string> conditionals = null;
 
 				// It should not throw any loading exception
 				IList<CustomAttributeData> attrs = CustomAttributeData.GetCustomAttributes (mi);
 
 				string ns, name;
 				foreach (var a in attrs) {
 					importer.GetCustomAttributeTypeName (a, out ns, out name);
 					if (name == "ObsoleteAttribute") {
 						if (ns != "System")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						var args = a.ConstructorArguments;
 
 						if (args.Count == 1) {
 							bag.Obsolete = new ObsoleteAttribute ((string) args[0].Value);
 						} else if (args.Count == 2) {
 							bag.Obsolete = new ObsoleteAttribute ((string) args[0].Value, (bool) args[1].Value);
 						} else {
 							bag.Obsolete = new ObsoleteAttribute ();
 						}
 
 						continue;
 					}
 
 					if (name == "ConditionalAttribute") {
 						if (ns != "System.Diagnostics")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						if (conditionals == null)
 							conditionals = new List<string> (2);
 
 						conditionals.Add ((string) a.ConstructorArguments[0].Value);
 						continue;
 					}
 
 					if (name == "CLSCompliantAttribute") {
 						if (ns != "System")
 							continue;
 
 						if (bag == null)
 							bag = new AttributesBag ();
 
 						bag.IsNotCLSCompliant = !(bool) a.ConstructorArguments[0].Value;
 						continue;
 					}
 
 					// Type only attributes
 					if (mi.MemberType == MemberTypes.TypeInfo || mi.MemberType == MemberTypes.NestedType) {
 						if (name == "DefaultMemberAttribute") {
 							if (ns != "System.Reflection")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.DefaultIndexerName = (string) a.ConstructorArguments[0].Value;
 							continue;
 						}
 
 						if (name == "AttributeUsageAttribute") {
 							if (ns != "System")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.AttributeUsage = new AttributeUsageAttribute ((AttributeTargets) a.ConstructorArguments[0].Value);
 							foreach (var named in a.NamedArguments) {
 								if (named.MemberInfo.Name == "AllowMultiple")
 									bag.AttributeUsage.AllowMultiple = (bool) named.TypedValue.Value;
 								else if (named.MemberInfo.Name == "Inherited")
 									bag.AttributeUsage.Inherited = (bool) named.TypedValue.Value;
 							}
 							continue;
 						}
 
 						// Interface only attribute
 						if (name == "CoClassAttribute") {
 							if (ns != "System.Runtime.InteropServices")
 								continue;
 
 							if (bag == null)
 								bag = new AttributesBag ();
 
 							bag.CoClass = importer.ImportType ((MetaType) a.ConstructorArguments[0].Value);
 							continue;
 						}
 					}
 				}
 
 				if (bag == null)
 					return Default;
 
 				if (conditionals != null)
 					bag.Conditionals = conditionals.ToArray ();
 				
 				return bag;
 			}
 		}
 
 		protected readonly MemberInfo provider;
 		protected AttributesBag cattrs;
 		protected readonly MetadataImporter importer;
 
 		public ImportedDefinition (MemberInfo provider, MetadataImporter importer)
 		{
 			this.provider = provider;
 			this.importer = importer;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\import.cs" startline="1306" endline="1318">
<![CDATA[
 	}
 
 	public class ImportedModuleDefinition
 	{
 		readonly Module module;
 		bool cls_compliant;
 		readonly MetadataImporter importer;
 		
 		public ImportedModuleDefinition (Module module, MetadataImporter importer)
 		{
 			this.module = module;
 			this.importer = importer;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="701" endline="713">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the return statement
 	/// </summary>
 	public class Return 
 	{
 		protected Expression Expr;
 		public Return (Expression expr, Location l)
 		{
 			Expr = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4689" endline="4867">
<![CDATA[
 		}
 	}
 
 	//
 	// Resolved reference to a local variable
 	//
 	public class LocalVariableReference 
 	{
 		public LocalVariable local_info;
 
 		public LocalVariableReference (LocalVariable li, Location l)
 		{
 			this.local_info = li;
 			loc = l;
 		}
 
 		public override VariableInfo VariableInfo {
 			get { return local_info.VariableInfo; }
 		}
 
 		public override HoistedVariable GetHoistedVariable (AnonymousExpression ae)
 		{
 			return local_info.HoistedVariant;
 		}
 
 		#region Properties
 
 		//		
 		// A local variable is always fixed
 		//
 		public override bool IsFixed {
 			get {
 				return true;
 			}
 		}
 
 		public override bool IsLockedByStatement {
 			get {
 				return local_info.IsLocked;
 			}
 			set {
 				local_info.IsLocked = value;
 			}
 		}
 
 		public override bool IsRef {
 			get { return false; }
 		}
 
 		public override string Name {
 			get { return local_info.Name; }
 		}
 
 		#endregion
 
 		public bool VerifyAssigned (ResolveContext ec)
 		{
 			VariableInfo variable_info = local_info.VariableInfo;
 			return variable_info == null || variable_info.IsAssigned (ec, loc);
 		}
 
 		public override void SetHasAddressTaken ()
 		{
 			local_info.AddressTaken = true;
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null)
 				return hv.CreateExpressionTree ();
 
 			Arguments arg = new Arguments (1);
 			arg.Add (new Argument (this));
 			return CreateExpressionFactoryCall (ec, "Constant", arg);
 		}
 
 		void DoResolveBase (ResolveContext ec)
 		{
 			VerifyAssigned (ec);
 
 			//
 			// If we are referencing a variable from the external block
 			// flag it for capturing
 			//
 			if (ec.MustCaptureVariable (local_info)) {
 				if (local_info.AddressTaken)
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, this, loc);
 
 				if (ec.IsVariableCapturingRequired) {
 					AnonymousMethodStorey storey = local_info.Block.Explicit.CreateAnonymousMethodStorey (ec);
 					storey.CaptureLocalVariable (ec, local_info);
 				}
 			}
 
 			eclass = ExprClass.Variable;
 			type = local_info.Type;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			local_info.SetIsUsed ();
 
 			DoResolveBase (ec);
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			// is out param
 			if (right_side == EmptyExpression.OutAccess.Instance)
 				local_info.SetIsUsed ();
 
 			if (local_info.IsReadonly && !ec.HasAny (ResolveContext.Options.FieldInitializerScope | ResolveContext.Options.UsingInitializerScope)) {
 				int code;
 				string msg;
 				if (right_side == EmptyExpression.OutAccess.Instance) {
 					code = 1657; msg = "Cannot pass `{0}' as a ref or out argument because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberAccess) {
 					code = 1654; msg = "Cannot assign to members of `{0}' because it is a `{1}'";
 				} else if (right_side == EmptyExpression.LValueMemberOutAccess) {
 					code = 1655; msg = "Cannot pass members of `{0}' as ref or out arguments because it is a `{1}'";
 				} else if (right_side == EmptyExpression.UnaryAddress) {
 					code = 459; msg = "Cannot take the address of {1} `{0}'";
 				} else {
 					code = 1656; msg = "Cannot assign to `{0}' because it is a `{1}'";
 				}
 				ec.Report.Error (code, loc, msg, Name, local_info.GetReadOnlyContext ());
 			} else if (VariableInfo != null) {
 				VariableInfo.SetAssigned (ec);
 			}
 
 			DoResolveBase (ec);
 
 			return base.DoResolveLValue (ec, right_side);
 		}
 
 		public override int GetHashCode ()
 		{
 			return local_info.GetHashCode ();
 		}
 
 		public override bool Equals (object obj)
 		{
 			LocalVariableReference lvr = obj as LocalVariableReference;
 			if (lvr == null)
 				return false;
 
 			return local_info == lvr.local_info;
 		}
 
 		protected override ILocalVariable Variable {
 			get { return local_info; }
 		}
 
 		public override string ToString ()
 		{
 			return String.Format ("{0} ({1}
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			// Nothing
 		}
 	}
 
 	/// <summary>
 	///   This represents a reference to a parameter in the intermediate
 	///   representation.
 	/// </summary>
 	public class ParameterReference 
 	{
 		protected ParametersBlock.ParameterInfo pi;
 
 		public ParameterReference (ParametersBlock.ParameterInfo pi, Location loc)
 		{
 			this.pi = pi;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2979" endline="4697">
<![CDATA[
 
 		#endregion
 	}
 
 	/// <summary>
 	///   MethodGroupExpr represents a group of method candidates which
 	///   can be resolved to the best method overload
 	/// </summary>
 	public class MethodGroupExpr 
 	{
 		protected IList<MemberSpec> Methods;
 		MethodSpec best_candidate;
 		TypeSpec best_candidate_return;
 		protected TypeArguments type_arguments;
 
  		SimpleName simple_name;
 		protected TypeSpec queried_type;
 
 		public MethodGroupExpr (IList<MemberSpec> mi, TypeSpec type, Location loc)
 		{
 			Methods = mi;
 			this.loc = loc;
 			this.type = InternalType.MethodGroup;
 
 			eclass = ExprClass.MethodGroup;
 			queried_type = type;
 		}
 
 		public MethodGroupExpr (MethodSpec m, TypeSpec type, Location loc)
 			
 		{
 		}
 
 		#region Properties
 
 		public MethodSpec BestCandidate {
 			get {
 				return best_candidate;
 			}
 		}
 
 		public TypeSpec BestCandidateReturnType {
 			get {
 				return best_candidate_return;
 			}
 		}
 
 		protected override TypeSpec DeclaringType {
 			get {
 				return queried_type;
 			}
 		}
 
 		public override bool IsInstance {
 			get {
 				if (best_candidate != null)
 					return !best_candidate.IsStatic;
 
 				return false;
 			}
 		}
 
 		public override bool IsStatic {
 			get {
 				if (best_candidate != null)
 					return best_candidate.IsStatic;
 
 				return false;
 			}
 		}
 
 		public override string Name {
 			get {
 				if (best_candidate != null)
 					return best_candidate.Name;
 
 				// TODO
 				return Methods.First ().Name;
 			}
 		}
 
 		#endregion
 
 		//
 		// When best candidate is already know this factory can be used
 		// to avoid expensive overload resolution to be called
 		//
 		// NOTE
 		//
 		public static MethodGroupExpr CreatePredefined (MethodSpec best, TypeSpec queriedType, Location loc)
 		{
 			return new MethodGroupExpr (best, queriedType, loc) {
 				best_candidate = best,
 				best_candidate_return = best.ReturnType
 			};
 		}
 
 		public override string GetSignatureForError ()
 		{
 			if (best_candidate != null)
 				return best_candidate.GetSignatureForError ();
 
 			return Methods.First ().GetSignatureForError ();
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			if (best_candidate == null) {
 				ec.Report.Error (1953, loc, "An expression tree cannot contain an expression with method group");
 				return null;
 			}
 
 			if (best_candidate.IsConditionallyExcluded (loc))
 				ec.Report.Error (765, loc,
 					"Partial methods with only a defining declaration or removed conditional methods cannot be used in an expression tree");
 			
 			return new TypeOfMethod (best_candidate, loc);
 		}
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			this.eclass = ExprClass.MethodGroup;
 
 			if (InstanceExpression != null) {
 				InstanceExpression = InstanceExpression.Resolve (ec);
 				if (InstanceExpression == null)
 					return null;
 			}
 
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			throw new NotSupportedException ();
 		}
 		
 		public void EmitCall (EmitContext ec, Arguments arguments)
 		{
 			Invocation.EmitCall (ec, InstanceExpression, best_candidate, arguments, loc);			
 		}
 
 		public override void Error_ValueCannotBeConverted (ResolveContext ec, Location loc, TypeSpec target, bool expl)
 		{
 			ec.Report.Error (428, loc, "Cannot convert method group `{0}' to non-delegate type `{1}'. Consider using parentheses to invoke the method",
 				Name, TypeManager.CSharpName (target));
 		}
 
 		public static bool IsExtensionMethodArgument (Expression expr)
 		{
 			//
 			// LAMESPEC
 			//
 			return !(expr is TypeExpr) && !(expr is BaseThis);
 		}
 
 		/// <summary>
 		///   Find the Applicable Function Members (7.4.2.1)
 		///
 		///   me
 		///       it might contain constructors or methods (or anything
 		///       that maps to a method).
 		///
 		///   Arguments
 		///
 		///   loc
 		///        location for "probing" purposes.
 		///
 		///   Returns
 		///            that is the best match of me on Arguments.
 		///
 		/// </summary>
 		public virtual MethodGroupExpr OverloadResolve (ResolveContext ec, ref Arguments args, OverloadResolver.IErrorHandler cerrors, OverloadResolver.Restrictions restr)
 		{
 			// TODO
 			if (best_candidate != null && best_candidate.Kind == MemberKind.Destructor)
 				return this;
 
 			var r = new OverloadResolver (Methods, type_arguments, restr, loc);
 			if ((restr & OverloadResolver.Restrictions.NoBaseMembers) == 0) {
 				r.BaseMembersProvider = this;
 			}
 
 			if (cerrors != null)
 				r.CustomErrors = cerrors;
 
 			// TODO
 			best_candidate = r.ResolveMember<MethodSpec> (ec, ref args);
 			if (best_candidate == null)
 				return r.BestCandidateIsDynamic ? this 
 
 			// Overload resolver had to create a new method group, all checks bellow have already been executed
 			if (r.BestCandidateNewMethodGroup != null)
 				return r.BestCandidateNewMethodGroup;
 
 			if (best_candidate.Kind == MemberKind.Method && (restr & OverloadResolver.Restrictions.ProbingOnly) == 0) {
 				if (InstanceExpression != null) {
 					if (best_candidate.IsExtensionMethod && args[0].Expr == InstanceExpression) {
 						InstanceExpression = null;
 					} else {
 						if (best_candidate.IsStatic && simple_name != null) {
 							InstanceExpression = ProbeIdenticalTypeName (ec, InstanceExpression, simple_name);
 						}
 
 						InstanceExpression.Resolve (ec);
 					}
 				}
 
 				ResolveInstanceExpression (ec, null);
 				if (InstanceExpression != null)
 					CheckProtectedMemberAccess (ec, best_candidate);
 			}
 
 			var base_override = CandidateToBaseOverride (ec, best_candidate);
 			if (base_override == best_candidate) {
 				best_candidate_return = r.BestCandidateReturnType;
 			} else {
 				best_candidate = base_override;
 				best_candidate_return = best_candidate.ReturnType;
 			}
 
 			return this;
 		}
 
 		public override MemberExpr ResolveMemberAccess (ResolveContext ec, Expression left, SimpleName original)
 		{
 			simple_name = original;
 			return base.ResolveMemberAccess (ec, left, original);
 		}
 
 		public override void SetTypeArguments (ResolveContext ec, TypeArguments ta)
 		{
 			type_arguments = ta;
 		}
 
 		#region IBaseMembersProvider Members
 
 		public virtual IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 		{
 			return baseType == null ? null 
 		}
 
 		public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 		{
 			if (queried_type == member.DeclaringType)
 				return null;
 
 			return MemberCache.FindMember (queried_type, new MemberFilter ((MethodSpec) member),
 				BindingRestriction.InstanceOnly | BindingRestriction.OverrideOnly) as IParametersMember;
 		}
 
 		//
 		// Extension methods lookup after ordinary methods candidates failed to apply
 		//
 		public virtual MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 		{
 			if (InstanceExpression == null)
 				return null;
 
 			InstanceExpression = InstanceExpression.Resolve (rc);
 			if (!IsExtensionMethodArgument (InstanceExpression))
 				return null;
 
 			int arity = type_arguments == null ? 0 
 			NamespaceEntry methods_scope = null;
 			var methods = rc.LookupExtensionMethod (InstanceExpression.Type, Methods[0].Name, arity, ref methods_scope);
 			if (methods == null)
 				return null;
 
 			var emg = new ExtensionMethodGroupExpr (methods, methods_scope, InstanceExpression, loc);
 			emg.SetTypeArguments (rc, type_arguments);
 			return emg;
 		}
 
 		#endregion
 	}
 
 	public struct OverloadResolver
 	{
 		[Flags]
 		public enum Restrictions
 		{
 			None = 0,
 			DelegateInvoke = 1,
 			ProbingOnly	= 1 << 1,
 			CovariantDelegate = 1 << 2,
 			NoBaseMembers = 1 << 3,
 			BaseMembersIncluded = 1 << 4
 		}
 
 		public interface IBaseMembersProvider
 		{
 			IList<MemberSpec> GetBaseMembers (TypeSpec baseType);
 			IParametersMember GetOverrideMemberParameters (MemberSpec member);
 			MethodGroupExpr LookupExtensionMethod (ResolveContext rc);
 		}
 
 		public interface IErrorHandler
 		{
 			bool AmbiguousCandidates (ResolveContext rc, MemberSpec best, MemberSpec ambiguous);
 			bool ArgumentMismatch (ResolveContext rc, MemberSpec best, Argument a, int index);
 			bool NoArgumentMatch (ResolveContext rc, MemberSpec best);
 			bool TypeInferenceFailed (ResolveContext rc, MemberSpec best);
 		}
 
 		sealed class NoBaseMembers 
 		{
 			public static readonly IBaseMembersProvider Instance = new NoBaseMembers ();
 
 			public IList<MemberSpec> GetBaseMembers (TypeSpec baseType)
 			{
 				return null;
 			}
 
 			public IParametersMember GetOverrideMemberParameters (MemberSpec member)
 			{
 				return null;
 			}
 
 			public MethodGroupExpr LookupExtensionMethod (ResolveContext rc)
 			{
 				return null;
 			}
 		}
 
 		struct AmbiguousCandidate
 		{
 			public readonly MemberSpec Member;
 			public readonly bool Expanded;
 			public readonly AParametersCollection Parameters;
 
 			public AmbiguousCandidate (MemberSpec member, AParametersCollection parameters, bool expanded)
 			{
 				Member = member;
 				Parameters = parameters;
 				Expanded = expanded;
 			}
 		}
 
 		Location loc;
 		IList<MemberSpec> members;
 		TypeArguments type_arguments;
 		IBaseMembersProvider base_provider;
 		IErrorHandler custom_errors;
 		Restrictions restrictions;
 		MethodGroupExpr best_candidate_extension_group;
 		TypeSpec best_candidate_return_type;
 
 		SessionReportPrinter lambda_conv_msgs;
 		ReportPrinter prev_recorder;
 
 		public OverloadResolver (IList<MemberSpec> members, Restrictions restrictions, Location loc)
 			
 		{
 		}
 
 		public OverloadResolver (IList<MemberSpec> members, TypeArguments targs, Restrictions restrictions, Location loc)
 			
 		{
 			if (members == null || members.Count == 0)
 				throw new ArgumentException ("empty members set");
 
 			this.members = members;
 			this.loc = loc;
 			type_arguments = targs;
 			this.restrictions = restrictions;
 			if (IsDelegateInvoke)
 				this.restrictions |= Restrictions.NoBaseMembers;
 
 			base_provider = NoBaseMembers.Instance;
 		}
 
 		#region Properties
 
 		public IBaseMembersProvider BaseMembersProvider {
 			get {
 				return base_provider;
 			}
 			set {
 				base_provider = value;
 			}
 		}
 
 		public bool BestCandidateIsDynamic { get; set; }
 
 		//
 		// Best candidate was found in newly created MethodGroupExpr, used by extension methods
 		//
 		public MethodGroupExpr BestCandidateNewMethodGroup {
 			get {
 				return best_candidate_extension_group;
 			}
 		}
 
 		//
 		// Return type can be different between best candidate and closest override
 		//
 		public TypeSpec BestCandidateReturnType {
 			get {
 				return best_candidate_return_type;
 			}
 		}
 
 		public IErrorHandler CustomErrors {
 			get {
 				return custom_errors;
 			}
 			set {
 				custom_errors = value;
 			}
 		}
 
 		TypeSpec DelegateType {
 			get {
 				if ((restrictions & Restrictions.DelegateInvoke) == 0)
 					throw new InternalErrorException ("Not running in delegate mode", loc);
 
 				return members [0].DeclaringType;
 			}
 		}
 
 		bool IsProbingOnly {
 			get {
 				return (restrictions & Restrictions.ProbingOnly) != 0;
 			}
 		}
 
 		bool IsDelegateInvoke {
 			get {
 				return (restrictions & Restrictions.DelegateInvoke) != 0;
 			}
 		}
 
 		#endregion
 
 		//
 		//  7.4.3.3  Better conversion from expression
 		//  Returns 
 		//              2    if a->q is better,
 		//              0 if neither is better
 		//
 		static int BetterExpressionConversion (ResolveContext ec, Argument a, TypeSpec p, TypeSpec q)
 		{
 			TypeSpec argument_type = a.Type;
 
 			//
 			// If argument is an anonymous function
 			//
 			if (argument_type == InternalType.AnonymousMethod && RootContext.Version > LanguageVersion.ISO_2) {
 				//
 				// p and q are delegate types or expression tree types
 				//
 				if (p.GetDefinition () == TypeManager.expression_type || q.GetDefinition () == TypeManager.expression_type) {
 					if (q.MemberDefinition != p.MemberDefinition) {
 						return 0;
 					}
 
 					//
 					// Uwrap delegate from Expression<T>
 					//
 					q = TypeManager.GetTypeArguments (q)[0];
 					p = TypeManager.GetTypeArguments (p)[0];
 				}
 
 				var p_m = Delegate.GetInvokeMethod (ec.Compiler, p);
 				var q_m = Delegate.GetInvokeMethod (ec.Compiler, q);
 
 				//
 				// With identical parameter lists
 				//
 				if (!TypeSpecComparer.Equals (p_m.Parameters.Types,q_m.Parameters.Types))
 					return 0;
 
 				p = p_m.ReturnType;
 				q = q_m.ReturnType;
 
 				//
 				// if p is void returning, and q has a return type Y, then C2 is the better conversion.
 				//
 				if (p == TypeManager.void_type) {
 					return q != TypeManager.void_type ? 2 
 				}
 
 				//
 				// if p has a return type Y, and q is void returning, then C1 is the better conversion.
 				//
 				if (q == TypeManager.void_type) {
 					return p != TypeManager.void_type ? 1
 				}
 			} else {
 				if (argument_type == p)
 					return 1;
 
 				if (argument_type == q)
 					return 2;
 			}
 
 			return BetterTypeConversion (ec, p, q);
 		}
 
 		//
 		// 7.4.3.4  Better conversion from type
 		//
 		public static int BetterTypeConversion (ResolveContext ec, TypeSpec p, TypeSpec q)
 		{
 			if (p == null || q == null)
 				throw new InternalErrorException ("BetterTypeConversion got a null conversion");
 
 			if (p == TypeManager.int32_type) {
 				if (q == TypeManager.uint32_type || q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.int64_type) {
 				if (q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.sbyte_type) {
 				if (q == TypeManager.byte_type || q == TypeManager.ushort_type ||
 					q == TypeManager.uint32_type || q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == TypeManager.short_type) {
 				if (q == TypeManager.ushort_type || q == TypeManager.uint32_type ||
 					q == TypeManager.uint64_type)
 					return 1;
 			} else if (p == InternalType.Dynamic) {
 				// Dynamic is never better
 				return 2;
 			}
 
 			if (q == TypeManager.int32_type) {
 				if (p == TypeManager.uint32_type || p == TypeManager.uint64_type)
 					return 2;
 			} if (q == TypeManager.int64_type) {
 				if (p == TypeManager.uint64_type)
 					return 2;
 			} else if (q == TypeManager.sbyte_type) {
 				if (p == TypeManager.byte_type || p == TypeManager.ushort_type ||
 					p == TypeManager.uint32_type || p == TypeManager.uint64_type)
 					return 2;
 			} if (q == TypeManager.short_type) {
 				if (p == TypeManager.ushort_type || p == TypeManager.uint32_type ||
 					p == TypeManager.uint64_type)
 					return 2;
 			} else if (q == InternalType.Dynamic) {
 				// Dynamic is never better
 				return 1;
 			}
 
 			// FIXME
 
 			// TODO
 			Expression p_tmp = new EmptyExpression (p);
 			Expression q_tmp = new EmptyExpression (q);
 
 			bool p_to_q = Convert.ImplicitConversionExists (ec, p_tmp, q);
 			bool q_to_p = Convert.ImplicitConversionExists (ec, q_tmp, p);
 
 			if (p_to_q && !q_to_p)
 				return 1;
 
 			if (q_to_p && !p_to_q)
 				return 2;
 
 			return 0;
 		}
 
 		/// <summary>
 		///   Determines "Better function" between candidate
 		///   and the current best match
 		/// </summary>
 		/// <remarks>
 		///    Returns a boolean indicating 
 		///     false if candidate ain't better
 		///     true  if candidate is better than the current best match
 		/// </remarks>
 		static bool BetterFunction (ResolveContext ec, Arguments args, MemberSpec candidate, AParametersCollection cparam, bool candidate_params,
 			MemberSpec best, AParametersCollection bparam, bool best_params)
 		{
 			AParametersCollection candidate_pd = ((IParametersMember) candidate).Parameters;
 			AParametersCollection best_pd = ((IParametersMember) best).Parameters;
 
 			bool better_at_least_one = false;
 			bool same = true;
 			int args_count = args == null ? 0 
 			int j = 0;
 			Argument a = null;
 			TypeSpec ct, bt;
 			for (int c_idx = 0, b_idx = 0; j < args_count; ++j, ++c_idx, ++b_idx) {
 				a = args[j];
 
 				// Default arguments are ignored for better decision
 				if (a.IsDefaultArgument)
 					break;
 
 				//
 				// When comparing named argument the parameter type index has to be looked up
 				// in original parameter set (override version for virtual members)
 				//
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int idx = cparam.GetParameterIndexByName (na.Name);
 					ct = candidate_pd.Types[idx];
 					if (candidate_params && candidate_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						ct = TypeManager.GetElementType (ct);
 
 					idx = bparam.GetParameterIndexByName (na.Name);
 					bt = best_pd.Types[idx];
 					if (best_params && best_pd.FixedParameters[idx].ModFlags == Parameter.Modifier.PARAMS)
 						bt = TypeManager.GetElementType (bt);
 				} else {
 					ct = candidate_pd.Types[c_idx];
 					bt = best_pd.Types[b_idx];
 
 					if (candidate_params && candidate_pd.FixedParameters[c_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						ct = TypeManager.GetElementType (ct);
 						--c_idx;
 					}
 
 					if (best_params && best_pd.FixedParameters[b_idx].ModFlags == Parameter.Modifier.PARAMS) {
 						bt = TypeManager.GetElementType (bt);
 						--b_idx;
 					}
 				}
 
 				if (TypeSpecComparer.IsEqual (ct, bt))
 					continue;
 
 				same = false;
 				int result = BetterExpressionConversion (ec, a, ct, bt);
 
 				// for each argument, the conversion to 'ct' should be no worse than 
 				// the conversion to 'bt'.
 				if (result == 2)
 					return false;
 
 				// for at least one argument, the conversion to 'ct' should be better than 
 				// the conversion to 'bt'.
 				if (result != 0)
 					better_at_least_one = true;
 			}
 
 			if (better_at_least_one)
 				return true;
 
 			//
 			// This handles the case
 			//
 			//   Add (float f1, float f2, float f3);
 			//   Add (params decimal [] foo);
 			//
 			// The call Add (3, 4, 5) should be ambiguous.  Without this check, the
 			// first candidate would've chosen as better.
 			//
 			if (!same && !a.IsDefaultArgument)
 				return false;
 
 			//
 			// The two methods have equal non-optional parameter types, apply tie-breaking rules
 			//
 
 			//
 			// This handles the following cases
 			//
 			//  Foo (int i) is better than Foo (int i, long l = 0)
 			//  Foo (params int[] args) is better than Foo (int i = 0, params int[] args)
 			//
 			// Prefer non-optional version
 			//
 			// LAMESPEC
 			//
 			if (candidate_params == best_params && candidate_pd.Count != best_pd.Count) {
 				if (candidate_pd.Count >= best_pd.Count)
 					return false;
 
 				if (j < candidate_pd.Count && candidate_pd.FixedParameters[j].HasDefaultValue)
 					return false;
 
 				return true;
 			}
 
 			//
 			// One is a non-generic method and second is a generic method, then non-generic is better
 			//
 			if (best.IsGeneric != candidate.IsGeneric)
 				return best.IsGeneric;
 
 			//
 			// This handles the following cases
 			//
 			//   Trim () is better than Trim (params char[] chars)
 			//   Concat (string s1, string s2, string s3) is better than
 			//     Concat (string s1, params string [] srest)
 			//   Foo (int, params int [] rest) is better than Foo (params int [] rest)
 			//
 			// Prefer non-expanded version
 			//
 			if (candidate_params != best_params)
 				return best_params;
 
 			int candidate_param_count = candidate_pd.Count;
 			int best_param_count = best_pd.Count;
 
 			if (candidate_param_count != best_param_count)
 				// can only happen if (candidate_params && best_params)
 				return candidate_param_count > best_param_count && best_pd.HasParams;
 
 			//
 			// Both methods have the same number of parameters, and the parameters have equal types
 			// Pick the "more specific" signature using rules over original (non-inflated) types
 			//
 			var candidate_def_pd = ((IParametersMember) candidate.MemberDefinition).Parameters;
 			var best_def_pd = ((IParametersMember) best.MemberDefinition).Parameters;
 
 			bool specific_at_least_once = false;
 			for (j = 0; j < args_count; ++j) {
 				NamedArgument na = args_count == 0 ? null 
 				if (na != null) {
 					ct = candidate_def_pd.Types[cparam.GetParameterIndexByName (na.Name)];
 					bt = best_def_pd.Types[bparam.GetParameterIndexByName (na.Name)];
 				} else {
 					ct = candidate_def_pd.Types[j];
 					bt = best_def_pd.Types[j];
 				}
 
 				if (ct == bt)
 					continue;
 				TypeSpec specific = MoreSpecific (ct, bt);
 				if (specific == bt)
 					return false;
 				if (specific == ct)
 					specific_at_least_once = true;
 			}
 
 			if (specific_at_least_once)
 				return true;
 
 			return false;
 		}
 
 		public static void Error_ConstructorMismatch (ResolveContext rc, TypeSpec type, int argCount, Location loc)
 		{
 			rc.Report.Error (1729, loc,
 				"The type `{0}' does not contain a constructor that takes `{1}' arguments",
 				type.GetSignatureForError (), argCount.ToString ());
 		}
 
 		//
 		// Determines if the candidate method is applicable to the given set of arguments
 		// There could be two different set of parameters for same candidate where one
 		// is the closest override for default values and named arguments checks and second
 		// one being the virtual base for the parameter types and modifiers.
 		//
 		// A return value rates candidate method compatibility,
 		// 0 = the best, int.MaxValue = the worst
 		//
 		int IsApplicable (ResolveContext ec, ref Arguments arguments, int arg_count, ref MemberSpec candidate, IParametersMember pm, ref bool params_expanded_form, ref bool dynamicArgument, ref TypeSpec returnType)
 		{
 			// Parameters of most-derived type used mainly for named and optional parameters
 			var pd = pm.Parameters;
 
 			// Used for params modifier only, that's legacy of C# 1.0 which uses base type for
 			// params modifier instead of most-derived type
 			var cpd = ((IParametersMember) candidate).Parameters;
 			int param_count = pd.Count;
 			int optional_count = 0;
 			int score;
 			Arguments orig_args = arguments;
 
 			if (arg_count != param_count) {
 				for (int i = 0; i < pd.Count; ++i) {
 					if (pd.FixedParameters[i].HasDefaultValue) {
 						optional_count = pd.Count - i;
 						break;
 					}
 				}
 
 				if (optional_count != 0) {
 					// Readjust expected number when params used
 					if (cpd.HasParams) {
 						optional_count--;
 						if (arg_count < param_count)
 							param_count--;
 					} else if (arg_count > param_count) {
 						int args_gap = System.Math.Abs (arg_count - param_count);
 						return int.MaxValue - 10000 + args_gap;
 					}
 				} else if (arg_count != param_count) {
 					int args_gap = System.Math.Abs (arg_count - param_count);
 					if (!cpd.HasParams)
 						return int.MaxValue - 10000 + args_gap;
 					if (arg_count < param_count - 1)
 						return int.MaxValue - 10000 + args_gap;
 				}
 
 				// Resize to fit optional arguments
 				if (optional_count != 0) {
 					if (arguments == null) {
 						arguments = new Arguments (optional_count);
 					} else {
 						// Have to create a new container, so the next run can do same
 						var resized = new Arguments (param_count);
 						resized.AddRange (arguments);
 						arguments = resized;
 					}
 
 					for (int i = arg_count; i < param_count; ++i)
 						arguments.Add (null);
 				}
 			}
 
 			if (arg_count > 0) {
 				//
 				// Shuffle named arguments to the right positions if there are any
 				//
 				if (arguments[arg_count - 1] is NamedArgument) {
 					arg_count = arguments.Count;
 
 					for (int i = 0; i < arg_count; ++i) {
 						bool arg_moved = false;
 						while (true) {
 							NamedArgument na = arguments[i] as NamedArgument;
 							if (na == null)
 								break;
 
 							int index = pd.GetParameterIndexByName (na.Name);
 
 							// Named parameter not found
 							if (index < 0)
 								return (i + 1) * 3;
 
 							// already reordered
 							if (index == i)
 								break;
 
 							Argument temp;
 							if (index >= param_count) {
 								// When using parameters which should not be available to the user
 								if ((cpd.FixedParameters[index].ModFlags & Parameter.Modifier.PARAMS) == 0)
 									break;
 
 								arguments.Add (null);
 								++arg_count;
 								temp = null;
 							} else {
 								temp = arguments[index];
 
 								// The slot has been taken by positional argument
 								if (temp != null && !(temp is NamedArgument))
 									break;
 							}
 
 							if (!arg_moved) {
 								arguments = arguments.MarkOrderedArgument (na);
 								arg_moved = true;
 							}
 
 							arguments[index] = arguments[i];
 							arguments[i] = temp;
 
 							if (temp == null)
 								break;
 						}
 					}
 				} else {
 					arg_count = arguments.Count;
 				}
 			} else if (arguments != null) {
 				arg_count = arguments.Count;
 			}
 
 			//
 			// 1. Handle generic method using type arguments when specified or type inference
 			//
 			TypeSpec[] ptypes;
 			var ms = candidate as MethodSpec;
 			if (ms != null && ms.IsGeneric) {
 				// Setup constraint checker for probing only
 				ConstraintChecker cc = new ConstraintChecker (null);
 
 				if (type_arguments != null) {
 					var g_args_count = ms.Arity;
 					if (g_args_count != type_arguments.Count)
 						return int.MaxValue - 20000 + System.Math.Abs (type_arguments.Count - g_args_count);
 
 					ms = ms.MakeGenericMethod (type_arguments.Arguments);
 				} else {
 					// TODO
 					// for now it simplifies things. I should probably add a callback to ResolveContext
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 
 					var ti = new TypeInference (arguments);
 					TypeSpec[] i_args = ti.InferMethodArguments (ec, ms);
 					lambda_conv_msgs.EndSession ();
 
 					if (i_args == null)
 						return ti.InferenceScore - 20000;
 
 					if (i_args.Length != 0) {
 						ms = ms.MakeGenericMethod (i_args);
 					}
 
 					cc.IgnoreInferredDynamic = true;
 				}
 
 				//
 				// Type arguments constraints have to match for the method to be applicable
 				//
 				if (!cc.CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc)) {
 					candidate = ms;
 					return int.MaxValue - 25000;
 				}
 
 				//
 				// We have a generic return type and at same time the method is override which
 				// means we have to also inflate override return type in case the candidate is
 				// best candidate and override return type is different to base return type.
 				// 
 				// virtual Foo<T, object> with override Foo<T, dynamic>
 				//
 				if (candidate != pm) {
 					MethodSpec override_ms = (MethodSpec) pm;
 					var inflator = new TypeParameterInflator (ms.DeclaringType, override_ms.GenericDefinition.TypeParameters, ms.TypeArguments);
 					returnType = inflator.Inflate (returnType);
 				} else {
 					returnType = ms.ReturnType;
 				}
 
 				candidate = ms;
 				ptypes = ms.Parameters.Types;
 			} else {
 				if (type_arguments != null)
 					return int.MaxValue - 15000;
 
 				ptypes = cpd.Types;
 			}
 
 			//
 			// 2. Each argument has to be implicitly convertible to method parameter
 			//
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 
 			for (int i = 0; i < arg_count; i++) {
 				Argument a = arguments[i];
 				if (a == null) {
 					if (!pd.FixedParameters[i].HasDefaultValue) {
 						arguments = orig_args;
 						return arg_count * 2 + 2;
 					}
 
 					//
 					// Get the default value expression, we can use the same expression
 					// if the type matches
 					//
 					Expression e = pd.FixedParameters[i].DefaultValue;
 					if (!(e is Constant) || e.Type.IsGenericOrParentIsGeneric) {
 						//
 						// LAMESPEC
 						//
 						if (e == EmptyExpression.MissingValue && ptypes[i] == TypeManager.object_type || ptypes[i] == InternalType.Dynamic) {
 							e = new MemberAccess (new MemberAccess (new MemberAccess (
 								new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Reflection", loc), "Missing", loc), "Value", loc);
 						} else {
 							e = new DefaultValueExpression (new TypeExpression (ptypes [i], loc), loc);
 						}
 
 						e = e.Resolve (ec);
 					}
 
 					arguments[i] = new Argument (e, Argument.AType.Default);
 					continue;
 				}
 
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = (pd.FixedParameters[i].ModFlags & ~Parameter.Modifier.PARAMS) | (cpd.FixedParameters[i].ModFlags & Parameter.Modifier.PARAMS);
 					pt = ptypes [i];
 				} else if (!params_expanded_form) {
 					params_expanded_form = true;
 					pt = ((ElementTypeSpec) pt).Element;
 					i -= 2;
 					continue;
 				}
 
 				score = 1;
 				if (!params_expanded_form) {
 					if (a.ArgType == Argument.AType.ExtensionType) {
 						//
 						// Indentity, implicit reference or boxing conversion must exist for the extension parameter
 						//
 						var at = a.Type;
 						if (at == pt || TypeSpecComparer.IsEqual (at, pt) ||
 							Convert.ImplicitReferenceConversionExists (a.Expr, pt) ||
 							Convert.ImplicitBoxingConversion (EmptyExpression.Null, at, pt) != null) {
 							score = 0;
 							continue;
 						}
 					} else {
 						score = IsArgumentCompatible (ec, a, p_mod & ~Parameter.Modifier.PARAMS, pt);
 
 						if (score < 0)
 							dynamicArgument = true;
 					}
 				}
 
 				//
 				// It can be applicable in expanded form (when not doing exact match like for delegates)
 				//
 				if (score != 0 && (p_mod & Parameter.Modifier.PARAMS) != 0 && (restrictions & Restrictions.CovariantDelegate) == 0) {
 					if (!params_expanded_form)
 						pt = ((ElementTypeSpec) pt).Element;
 
 					if (score > 0)
 						score = IsArgumentCompatible (ec, a, Parameter.Modifier.NONE, pt);
 
 					if (score == 0) {
 						params_expanded_form = true;
 					} else if (score < 0) {
 						params_expanded_form = true;
 						dynamicArgument = true;
 					}
 				}
 
 				if (score > 0) {
 					if (params_expanded_form)
 						++score;
 					return (arg_count - i) * 2 + score;
 				}
 			}
 
 			//
 			// When params parameter has no argument it will be provided later if the method is the best candidate
 			//
 			if (arg_count + 1 == pd.Count && (cpd.FixedParameters [arg_count].ModFlags & Parameter.Modifier.PARAMS) != 0)
 				params_expanded_form = true;
 
 			//
 			// Restore original arguments for dynamic binder to keep the intention of original source code
 			//
 			if (dynamicArgument)
 				arguments = orig_args;
 
 			return 0;
 		}
 
 		//
 		// Tests argument compatibility with the parameter
 		// The possible return values are
 		// 0 - success
 		// 1 - modifier mismatch
 		// 2 - type mismatch
 		// -1 - dynamic binding required
 		//
 		int IsArgumentCompatible (ResolveContext ec, Argument argument, Parameter.Modifier param_mod, TypeSpec parameter)
 		{
 			//
 			// Types have to be identical when ref or out modifer
 			// is used and argument is not of dynamic type
 			//
 			if ((argument.Modifier | param_mod) != 0) {
 				if (argument.Type != parameter) {
 					//
 					// Do full equality check after quick path
 					//
 					if (!TypeSpecComparer.IsEqual (argument.Type, parameter)) {
 						//
 						// Using dynamic for ref/out parameter can still succeed at runtime
 						//
 						if (argument.Type == InternalType.Dynamic && argument.Modifier == 0 && (restrictions & Restrictions.CovariantDelegate) == 0)
 							return -1;
 
 						return 2;
 					}
 				}
 
 				if (argument.Modifier != param_mod) {
 					//
 					// Using dynamic for ref/out parameter can still succeed at runtime
 					//
 					if (argument.Type == InternalType.Dynamic && argument.Modifier == 0 && (restrictions & Restrictions.CovariantDelegate) == 0)
 						return -1;
 
 					return 1;
 				}
 
 			} else {
 				if (argument.Type == InternalType.Dynamic && (restrictions & Restrictions.CovariantDelegate) == 0)
 					return -1;
 
 				//
 				// Deploy custom error reporting for lambda methods. When probing lambda methods
 				// keep all errors reported in separate set and once we are done and no best
 				// candidate found, this set is used to report more details about what was wrong
 				// with lambda body
 				//
 				if (argument.Expr.Type == InternalType.AnonymousMethod) {
 					if (lambda_conv_msgs == null) {
 						lambda_conv_msgs = new SessionReportPrinter ();
 						prev_recorder = ec.Report.SetPrinter (lambda_conv_msgs);
 					}
 				}
 
 				if (!Convert.ImplicitConversionExists (ec, argument.Expr, parameter)) {
 					if (lambda_conv_msgs != null) {
 						lambda_conv_msgs.EndSession ();
 					}
 
 					return 2;
 				}
 			}
 
 			return 0;
 		}
 
 		static TypeSpec MoreSpecific (TypeSpec p, TypeSpec q)
 		{
 			if (TypeManager.IsGenericParameter (p) && !TypeManager.IsGenericParameter (q))
 				return q;
 			if (!TypeManager.IsGenericParameter (p) && TypeManager.IsGenericParameter (q))
 				return p;
 
 			var ac_p = p as ArrayContainer;
 			if (ac_p != null) {
 				var ac_q = ((ArrayContainer) q);
 				TypeSpec specific = MoreSpecific (ac_p.Element, ac_q.Element);
 				if (specific == ac_p.Element)
 					return p;
 				if (specific == ac_q.Element)
 					return q;
 			} else if (TypeManager.IsGenericType (p)) {
 				var pargs = TypeManager.GetTypeArguments (p);
 				var qargs = TypeManager.GetTypeArguments (q);
 
 				bool p_specific_at_least_once = false;
 				bool q_specific_at_least_once = false;
 
 				for (int i = 0; i < pargs.Length; i++) {
 					TypeSpec specific = MoreSpecific (pargs[i], qargs[i]);
 					if (specific == pargs[i])
 						p_specific_at_least_once = true;
 					if (specific == qargs[i])
 						q_specific_at_least_once = true;
 				}
 
 				if (p_specific_at_least_once && !q_specific_at_least_once)
 					return p;
 				if (!p_specific_at_least_once && q_specific_at_least_once)
 					return q;
 			}
 
 			return null;
 		}
 
 		//
 		// Find the best method from candidate list
 		//
 		public T ResolveMember<T> (ResolveContext rc, ref Arguments args) where T 
 		{
 			List<AmbiguousCandidate> ambiguous_candidates = null;
 
 			MemberSpec best_candidate;
 			Arguments best_candidate_args = null;
 			bool best_candidate_params = false;
 			bool best_candidate_dynamic = false;
 			int best_candidate_rate;
 			IParametersMember best_parameter_member = null;
 
 			int args_count = args != null ? args.Count 
 
 			Arguments candidate_args = args;
 			bool error_mode = false;
 			var current_type = rc.CurrentType;
 			MemberSpec invocable_member = null;
 
 			// Be careful, cannot return until error reporter is restored
 			while (true) {
 				best_candidate = null;
 				best_candidate_rate = int.MaxValue;
 
 				var type_members = members;
 				try {
 
 					do {
 						for (int i = 0; i < type_members.Count; ++i) {
 							var member = type_members[i];
 
 							//
 							// Methods in a base class are not candidates if any method in a derived
 							// class is applicable
 							//
 							if ((member.Modifiers & Modifiers.OVERRIDE) != 0)
 								continue;
 
 							if (!error_mode) {
 								if (!member.IsAccessible (current_type))
 									continue;
 
 								if (rc.Compiler.IsRuntimeBinder && !member.DeclaringType.IsAccessible (current_type))
 									continue;
 							}
 
 							IParametersMember pm = member as IParametersMember;
 							if (pm == null) {
 								//
 								// Will use it later to report ambiguity between best method and invocable member
 								//
 								if (Invocation.IsMemberInvocable (member))
 									invocable_member = member;
 
 								continue;
 							}
 
 							//
 							// Overload resolution is looking for base member but using parameter names
 							// and default values from the closest member. That means to do expensive lookup
 							// for the closest override for virtual or abstract members
 							//
 							if ((member.Modifiers & (Modifiers.VIRTUAL | Modifiers.ABSTRACT)) != 0) {
 								var override_params = base_provider.GetOverrideMemberParameters (member);
 								if (override_params != null)
 									pm = override_params;
 							}
 
 							//
 							// Check if the member candidate is applicable
 							//
 							bool params_expanded_form = false;
 							bool dynamic_argument = false;
 							TypeSpec rt = pm.MemberType;
 							int candidate_rate = IsApplicable (rc, ref candidate_args, args_count, ref member, pm, ref params_expanded_form, ref dynamic_argument, ref rt);
 
 							//
 							// How does it score compare to others
 							//
 							if (candidate_rate < best_candidate_rate) {
 								best_candidate_rate = candidate_rate;
 								best_candidate = member;
 								best_candidate_args = candidate_args;
 								best_candidate_params = params_expanded_form;
 								best_candidate_dynamic = dynamic_argument;
 								best_parameter_member = pm;
 								best_candidate_return_type = rt;
 							} else if (candidate_rate == 0) {
 								//
 								// The member look is done per type for most operations but sometimes
 								// it's not possible like for binary operators overload because they
 								// are unioned between 2 sides
 								//
 								if ((restrictions & Restrictions.BaseMembersIncluded) != 0) {
 									if (TypeSpec.IsBaseClass (best_candidate.DeclaringType, member.DeclaringType, true))
 										continue;
 								}
 
 								bool is_better;
 								if (best_candidate.DeclaringType.IsInterface && member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 									//
 									// We pack all interface members into top level type which makes the overload resolution
 									// more complicated for interfaces. We accomodate for this by removing methods with same
 									// signature when building the cache hence this path should not really be hit often
 									//
 									// Example
 									// interface IA { void Foo (int arg); }
 									// interface IB 
 									//
 									// IB
 									//
 									is_better = true;
 									if (ambiguous_candidates != null) {
 										foreach (var amb_cand in ambiguous_candidates) {
 											if (member.DeclaringType.ImplementsInterface (best_candidate.DeclaringType, false)) {
 												continue;
 											}
 
 											is_better = false;
 											break;
 										}
 
 										if (is_better)
 											ambiguous_candidates = null;
 									}
 								} else {
 									// Is the new candidate better
 									is_better = BetterFunction (rc, candidate_args, member, pm.Parameters, params_expanded_form, best_candidate, best_parameter_member.Parameters, best_candidate_params);
 								}
 
 								if (is_better) {
 									best_candidate = member;
 									best_candidate_args = candidate_args;
 									best_candidate_params = params_expanded_form;
 									best_candidate_dynamic = dynamic_argument;
 									best_parameter_member = pm;
 									best_candidate_return_type = rt;
 								} else {
 									// It's not better but any other found later could be but we are not sure yet
 									if (ambiguous_candidates == null)
 										ambiguous_candidates = new List<AmbiguousCandidate> ();
 
 									ambiguous_candidates.Add (new AmbiguousCandidate (member, pm.Parameters, params_expanded_form));
 								}
 							}
 
 							// Restore expanded arguments
 							if (candidate_args != args)
 								candidate_args = args;
 						}
 					} while (best_candidate_rate != 0 && (type_members = base_provider.GetBaseMembers (type_members[0].DeclaringType.BaseType)) != null);
 				} finally {
 					if (prev_recorder != null)
 						rc.Report.SetPrinter (prev_recorder);
 				}
 
 				//
 				// We've found exact match
 				//
 				if (best_candidate_rate == 0)
 					break;
 
 				//
 				// Try extension methods lookup when no ordinary method match was found and provider enables it
 				//
 				if (!error_mode) {
 					var emg = base_provider.LookupExtensionMethod (rc);
 					if (emg != null) {
 						emg = emg.OverloadResolve (rc, ref args, null, restrictions);
 						if (emg != null) {
 							best_candidate_extension_group = emg;
 							return (T) (MemberSpec) emg.BestCandidate;
 						}
 					}
 				}
 
 				// Don't run expensive error reporting mode for probing
 				if (IsProbingOnly)
 					return null;
 
 				if (error_mode)
 					break;
 
 				lambda_conv_msgs = null;
 				error_mode = true;
 			}
 
 			//
 			// No best member match found, report an error
 			//
 			if (best_candidate_rate != 0 || error_mode) {
 				ReportOverloadError (rc, best_candidate, best_parameter_member, best_candidate_args, best_candidate_params);
 				return null;
 			}
 
 			if (best_candidate_dynamic) {
 				if (args[0].ArgType == Argument.AType.ExtensionType) {
 					rc.Report.Error (1973, loc,
 						"Type `{0}' does not contain a member `{1}' and the best extension method overload `{2}' cannot be dynamically dispatched. Consider calling the method without the extension method syntax",
 						args [0].Type.GetSignatureForError (), best_candidate.Name, best_candidate.GetSignatureForError ());
 				}
 
 				BestCandidateIsDynamic = true;
 				return null;
 			}
 
 			if (ambiguous_candidates != null) {
 				//
 				// Now check that there are no ambiguities i.e the selected method
 				// should be better than all the others
 				//
 				for (int ix = 0; ix < ambiguous_candidates.Count; ix++) {
 					var candidate = ambiguous_candidates [ix];
 
 					if (!BetterFunction (rc, best_candidate_args, best_candidate, best_parameter_member.Parameters, best_candidate_params, candidate.Member, candidate.Parameters, candidate.Expanded)) {
 						var ambiguous = candidate.Member;
 						if (custom_errors == null || !custom_errors.AmbiguousCandidates (rc, best_candidate, ambiguous)) {
 							rc.Report.SymbolRelatedToPreviousError (best_candidate);
 							rc.Report.SymbolRelatedToPreviousError (ambiguous);
 							rc.Report.Error (121, loc, "The call is ambiguous between the following methods or properties
 								best_candidate.GetSignatureForError (), ambiguous.GetSignatureForError ());
 						}
 
 						return (T) best_candidate;
 					}
 				}
 			}
 
 			if (invocable_member != null) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.SymbolRelatedToPreviousError (invocable_member);
 				rc.Report.Warning (467, 2, loc, "Ambiguity between method `{0}' and invocable non-method `{1}'. Using method group",
 					best_candidate.GetSignatureForError (), invocable_member.GetSignatureForError ());
 			}
 
 			//
 			// And now check if the arguments are all
 			// compatible, perform conversions if
 			// necessary etc. and return if everything is
 			// all right
 			//
 			if (!VerifyArguments (rc, ref best_candidate_args, best_candidate, best_parameter_member, best_candidate_params))
 				return null;
 
 			if (best_candidate == null)
 				return null;
 
 			//
 			// Check ObsoleteAttribute on the best method
 			//
 			ObsoleteAttribute oa = best_candidate.GetAttributeObsolete ();
 			if (oa != null && !rc.IsObsolete)
 				AttributeTester.Report_ObsoleteMessage (oa, best_candidate.GetSignatureForError (), loc, rc.Report);
 
 			var dep = best_candidate.GetMissingDependencies ();
 			if (dep != null) {
 				ImportedTypeDefinition.Error_MissingDependency (rc, dep, loc);
 			}
 
 			best_candidate.MemberDefinition.SetIsUsed ();
 
 			args = best_candidate_args;
 			return (T) best_candidate;
 		}
 
 		public MethodSpec ResolveOperator (ResolveContext rc, ref Arguments args)
 		{
 			return ResolveMember<MethodSpec> (rc, ref args);
 		}
 
 		void ReportArgumentMismatch (ResolveContext ec, int idx, MemberSpec method,
 													Argument a, AParametersCollection expected_par, TypeSpec paramType)
 		{
 			if (custom_errors != null && custom_errors.ArgumentMismatch (ec, method, a, idx))
 				return;
 
 			if (a is CollectionElementInitializer.ElementInitializerArgument) {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				if ((expected_par.FixedParameters[idx].ModFlags & Parameter.Modifier.ISBYREF) != 0) {
 					ec.Report.Error (1954, loc, "The best overloaded collection initalizer method `{0}' cannot have 'ref', or `out' modifier",
 						TypeManager.CSharpSignature (method));
 					return;
 				}
 				ec.Report.Error (1950, loc, "The best overloaded collection initalizer method `{0}' has some invalid arguments",
 					  TypeManager.CSharpSignature (method));
 			} else if (IsDelegateInvoke) {
 				ec.Report.Error (1594, loc, "Delegate `{0}' has some invalid arguments",
 					DelegateType.GetSignatureForError ());
 			} else {
 				ec.Report.SymbolRelatedToPreviousError (method);
 				ec.Report.Error (1502, loc, "The best overloaded method match for `{0}' has some invalid arguments",
 					method.GetSignatureForError ());
 			}
 
 			Parameter.Modifier mod = idx >= expected_par.Count ? 0 
 
 			string index = (idx + 1).ToString ();
 			if (((mod & (Parameter.Modifier.REF | Parameter.Modifier.OUT)) ^
 				(a.Modifier & (Parameter.Modifier.REF | Parameter.Modifier.OUT))) != 0) {
 				if ((mod & Parameter.Modifier.ISBYREF) == 0)
 					ec.Report.Error (1615, loc, "Argument `#{0}' does not require `{1}' modifier. Consider removing `{1}' modifier",
 						index, Parameter.GetModifierSignature (a.Modifier));
 				else
 					ec.Report.Error (1620, loc, "Argument `#{0}' is missing `{1}' modifier",
 						index, Parameter.GetModifierSignature (mod));
 			} else {
 				string p1 = a.GetSignatureForError ();
 				string p2 = TypeManager.CSharpName (paramType);
 
 				if (p1 == p2) {
 					ec.Report.ExtraInformation (loc, "(equally named types possibly from different assemblies in previous ");
 					ec.Report.SymbolRelatedToPreviousError (a.Expr.Type);
 					ec.Report.SymbolRelatedToPreviousError (paramType);
 				}
 
 				ec.Report.Error (1503, loc,
 					"Argument `#{0}' cannot convert `{1}' expression to type `{2}'", index, p1, p2);
 			}
 		}
 
 		//
 		// We have failed to find exact match so we return error info about the closest match
 		//
 		void ReportOverloadError (ResolveContext rc, MemberSpec best_candidate, IParametersMember pm, Arguments args, bool params_expanded)
 		{
 			int ta_count = type_arguments == null ? 0 
 			int arg_count = args == null ? 0 
 
 			if (ta_count != best_candidate.Arity && (ta_count > 0 || ((IParametersMember) best_candidate).Parameters.IsEmpty)) {
 				var mg = new MethodGroupExpr (new [] { best_candidate }, best_candidate.DeclaringType, loc);
 				mg.Error_TypeArgumentsCannotBeUsed (rc.Report, loc, best_candidate, ta_count);
 				return;
 			}
 
 			if (lambda_conv_msgs != null) {
 				if (lambda_conv_msgs.Merge (rc.Report.Printer))
 					return;
 			}
 
 			//
 			// For candidates which match on parameters count report more details about incorrect arguments
 			//
 			if (pm != null) {
 				int unexpanded_count = ((IParametersMember) best_candidate).Parameters.HasParams ? pm.Parameters.Count - 1 
 				if (pm.Parameters.Count == arg_count || params_expanded || unexpanded_count == arg_count) {
 					// Reject any inaccessible member
 					if (!best_candidate.IsAccessible (rc.CurrentType) || !best_candidate.DeclaringType.IsAccessible (rc.CurrentType)) {
 						rc.Report.SymbolRelatedToPreviousError (best_candidate);
 						Expression.ErrorIsInaccesible (rc, best_candidate.GetSignatureForError (), loc);
 						return;
 					}
 
 					var ms = best_candidate as MethodSpec;
 					if (ms != null && ms.IsGeneric) {
 						bool constr_ok = true;
 						if (ms.TypeArguments != null)
 							constr_ok = new ConstraintChecker (rc.MemberContext).CheckAll (ms.GetGenericMethodDefinition (), ms.TypeArguments, ms.Constraints, loc);
 
 						if (ta_count == 0) {
 							if (custom_errors != null && custom_errors.TypeInferenceFailed (rc, best_candidate))
 								return;
 
 							if (constr_ok) {
 								rc.Report.Error (411, loc,
 									"The type arguments for method `{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly",
 									ms.GetGenericMethodDefinition ().GetSignatureForError ());
 							}
 
 							return;
 						}
 					}
 
 					VerifyArguments (rc, ref args, best_candidate, pm, params_expanded);
 					return;
 				}
 			}
 
 			//
 			// We failed to find any method with correct argument count, report best candidate
 			//
 			if (custom_errors != null && custom_errors.NoArgumentMatch (rc, best_candidate))
 				return;
 
 			if (best_candidate.Kind == MemberKind.Constructor) {
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				Error_ConstructorMismatch (rc, best_candidate.DeclaringType, arg_count, loc);
 			} else if (IsDelegateInvoke) {
 				rc.Report.SymbolRelatedToPreviousError (DelegateType);
 				rc.Report.Error (1593, loc, "Delegate `{0}' does not take `{1}' arguments",
 					DelegateType.GetSignatureForError (), arg_count.ToString ());
 			} else {
 				string name = best_candidate.Kind == MemberKind.Indexer ? "this" 
 				rc.Report.SymbolRelatedToPreviousError (best_candidate);
 				rc.Report.Error (1501, loc, "No overload for method `{0}' takes `{1}' arguments",
 					name, arg_count.ToString ());
 			}
 		}
 
 		bool VerifyArguments (ResolveContext ec, ref Arguments args, MemberSpec member, IParametersMember pm, bool chose_params_expanded)
 		{
 			var pd = pm.Parameters;
 			TypeSpec[] ptypes = ((IParametersMember) member).Parameters.Types;
 
 			Parameter.Modifier p_mod = 0;
 			TypeSpec pt = null;
 			int a_idx = 0, a_pos = 0;
 			Argument a = null;
 			ArrayInitializer params_initializers = null;
 			bool has_unsafe_arg = pm.MemberType.IsPointer;
 			int arg_count = args == null ? 0 
 
 			for (; a_idx < arg_count; a_idx++, ++a_pos) {
 				a = args[a_idx];
 				if (p_mod != Parameter.Modifier.PARAMS) {
 					p_mod = pd.FixedParameters[a_idx].ModFlags;
 					pt = ptypes[a_idx];
 					has_unsafe_arg |= pt.IsPointer;
 
 					if (p_mod == Parameter.Modifier.PARAMS) {
 						if (chose_params_expanded) {
 							params_initializers = new ArrayInitializer (arg_count - a_idx, a.Expr.Location);
 							pt = TypeManager.GetElementType (pt);
 						}
 					}
 				}
 
 				//
 				// Types have to be identical when ref or out modifer is used 
 				//
 				if (a.Modifier != 0 || (p_mod & ~Parameter.Modifier.PARAMS) != 0) {
 					if ((p_mod & ~Parameter.Modifier.PARAMS) != a.Modifier)
 						break;
 
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt))
 						continue;
 
 					break;
 				}
 
 				NamedArgument na = a as NamedArgument;
 				if (na != null) {
 					int name_index = pd.GetParameterIndexByName (na.Name);
 					if (name_index < 0 || name_index >= pd.Count) {
 						if (IsDelegateInvoke) {
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 							ec.Report.Error (1746, na.Location,
 								"The delegate `{0}' does not contain a parameter named `{1}'",
 								DelegateType.GetSignatureForError (), na.Name);
 						} else {
 							ec.Report.SymbolRelatedToPreviousError (member);
 							ec.Report.Error (1739, na.Location,
 								"The best overloaded method match for `{0}' does not contain a parameter named `{1}'",
 								TypeManager.CSharpSignature (member), na.Name);
 						}
 					} else if (args[name_index] != a) {
 						if (IsDelegateInvoke)
 							ec.Report.SymbolRelatedToPreviousError (DelegateType);
 						else
 							ec.Report.SymbolRelatedToPreviousError (member);
 
 						ec.Report.Error (1744, na.Location,
 							"Named argument `{0}' cannot be used for a parameter which has positional argument specified",
 							na.Name);
 					}
 				}
 				
 				if (a.Expr.Type == InternalType.Dynamic)
 					continue;
 
 				if ((restrictions & Restrictions.CovariantDelegate) != 0 && !Delegate.IsTypeCovariant (a.Expr, pt)) {
 					custom_errors.NoArgumentMatch (ec, member);
 					return false;
 				}
 
 				Expression conv = null;
 				if (a.ArgType == Argument.AType.ExtensionType) {
 					if (a.Expr.Type == pt || TypeSpecComparer.IsEqual (a.Expr.Type, pt)) {
 						conv = a.Expr;
 					} else {
 						conv = Convert.ImplicitReferenceConversion (a.Expr, pt, false);
 						if (conv == null)
 							conv = Convert.ImplicitBoxingConversion (a.Expr, a.Expr.Type, pt);
 					}
 				} else {
 					conv = Convert.ImplicitConversion (ec, a.Expr, pt, loc);
 				}
 
 				if (conv == null)
 					break;
 
 				//
 				// Convert params arguments to an array initializer
 				//
 				if (params_initializers != null) {
 					// we choose to use 'a.Expr' rather than 'conv' so that
 					// we don't hide the kind of expression we have (esp. CompoundAssign.Helper)
 					params_initializers.Add (a.Expr);
 					args.RemoveAt (a_idx--);
 					--arg_count;
 					continue;
 				}
 
 				// Update the argument with the implicit conversion
 				a.Expr = conv;
 			}
 
 			if (a_idx != arg_count) {
 				ReportArgumentMismatch (ec, a_pos, member, a, pd, pt);
 				return false;
 			}
 
 			//
 			// Fill not provided arguments required by params modifier
 			//
 			if (params_initializers == null && pd.HasParams && arg_count + 1 == pd.Count) {
 				if (args == null)
 					args = new Arguments (1);
 
 				pt = ptypes[pd.Count - 1];
 				pt = TypeManager.GetElementType (pt);
 				has_unsafe_arg |= pt.IsPointer;
 				params_initializers = new ArrayInitializer (0, loc);
 			}
 
 			//
 			// Append an array argument with all params arguments
 			//
 			if (params_initializers != null) {
 				args.Add (new Argument (
 					new ArrayCreation (new TypeExpression (pt, loc), params_initializers, loc).Resolve (ec)));
 				arg_count++;
 			}
 
 			if (has_unsafe_arg && !ec.IsUnsafe) {
 				Expression.UnsafeError (ec, loc);
 			}
 
 			//
 			// We could infer inaccesible type arguments
 			//
 			if (type_arguments == null && member.IsGeneric) {
 				var ms = (MethodSpec) member;
 				foreach (var ta in ms.TypeArguments) {
 					if (!ta.IsAccessible (ec.CurrentType)) {
 						ec.Report.SymbolRelatedToPreviousError (ta);
 						Expression.ErrorIsInaccesible (ec, member.GetSignatureForError (), loc);
 						break;
 					}
 				}
 			}
 
 			return true;
 		}
 	}
 
 	public class ConstantExpr 
 	{
 		ConstSpec constant;
 
 		public ConstantExpr (ConstSpec constant, Location loc)
 		{
 			this.constant = constant;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="5408" endline="5579">
<![CDATA[
 	}
 
 	abstract class PropertyOrIndexerExpr<T> 
 	{
 		// getter and setter can be different for base calls
 		MethodSpec getter, setter;
 		protected T best_candidate;
 
 		protected LocalTemporary temp;
 		protected bool prepared;
 
 		protected PropertyOrIndexerExpr (Location l)
 		{
 			loc = l;
 		}
 
 		#region Properties
 
 		public MethodSpec Getter {
 			get {
 				return getter;
 			}
 			set {
 				getter = value;
 			}
 		}
 
 		public MethodSpec Setter {
 			get {
 				return setter;
 			}
 			set {
 				setter = value;
 			}
 		}
 
 		#endregion
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, null);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.Resolve (ec);
 			}
 
 			if (!ResolveGetter (ec))
 				return null;
 
 			return this;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			if (right_side == EmptyExpression.OutAccess.Instance) {
 				// TODO
 				INamedBlockVariable variable = null;
 				if (best_candidate != null && ec.CurrentBlock.ParametersBlock.TopBlock.GetLocalName (best_candidate.Name, ec.CurrentBlock, ref variable) && variable is Linq.RangeVariable) {
 					ec.Report.Error (1939, loc, "A range variable `{0}' may not be passes as `ref' or `out' parameter",
 						best_candidate.Name);
 				} else {
 					right_side.DoResolveLValue (ec, this);
 				}
 				return null;
 			}
 
 			// if the property/indexer returns a value type, and we try to set a field in it
 			if (right_side == EmptyExpression.LValueMemberAccess || right_side == EmptyExpression.LValueMemberOutAccess) {
 				Error_CannotModifyIntermediateExpressionValue (ec);
 			}
 
 			if (eclass == ExprClass.Unresolved) {
 				var expr = OverloadResolve (ec, right_side);
 				if (expr == null)
 					return null;
 
 				if (expr != this)
 					return expr.ResolveLValue (ec, right_side);
 			}
 
 			if (!ResolveSetter (ec))
 				return null;
 
 			return this;
 		}
 
 		//
 		// Implements the IAssignMethod interface for assignments
 		//
 		public abstract void Emit (EmitContext ec, bool leave_copy);
 		public abstract void EmitAssign (EmitContext ec, Expression source, bool leave_copy, bool prepare_for_load);
 
 		public override void Emit (EmitContext ec)
 		{
 			Emit (ec, false);
 		}
 
 		public abstract SLE.Expression MakeAssignExpression (BuilderContext ctx, Expression source);
 
 		protected abstract Expression OverloadResolve (ResolveContext rc, Expression right_side);
 
 		bool ResolveGetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasGet) {
 				if (InstanceExpression != EmptyExpression.Null) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate);
 					rc.Report.Error (154, loc, "The property or indexer `{0}' cannot be used in this context because it lacks the `get' accessor",
 						best_candidate.GetSignatureForError ());
 					return false;
 				}
 			} else if (!best_candidate.Get.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					rc.Report.Error (271, loc, "The property or indexer `{0}' cannot be used in this context because the get accessor is inaccessible",
 						TypeManager.CSharpSignature (best_candidate));
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Get);
 					ErrorIsInaccesible (rc, best_candidate.Get.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility) {
 				CheckProtectedMemberAccess (rc, best_candidate.Get);
 			}
 
 			getter = CandidateToBaseOverride (rc, best_candidate.Get);
 			return true;
 		}
 
 		bool ResolveSetter (ResolveContext rc)
 		{
 			if (!best_candidate.HasSet) {
 				rc.Report.Error (200, loc, "Property or indexer `{0}' cannot be assigned to (it is read-only)",
 					GetSignatureForError ());
 				return false;
 			}
 
 			if (!best_candidate.Set.IsAccessible (rc.CurrentType)) {
 				if (best_candidate.HasDifferentAccessibility) {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					rc.Report.Error (272, loc, "The property or indexer `{0}' cannot be used in this context because the set accessor is inaccessible",
 						GetSignatureForError ());
 				} else {
 					rc.Report.SymbolRelatedToPreviousError (best_candidate.Set);
 					ErrorIsInaccesible (rc, best_candidate.Set.GetSignatureForError (), loc);
 				}
 			}
 
 			if (best_candidate.HasDifferentAccessibility)
 				CheckProtectedMemberAccess (rc, best_candidate.Set);
 
 			setter = CandidateToBaseOverride (rc, best_candidate.Set);
 			return true;
 		}
 	}
 
 	/// <summary>
 	///   Fully resolved expression that evaluates to an Event
 	/// </summary>
 	public class EventExpr 
 	{
 		readonly EventSpec spec;
 		MethodSpec op;
 
 		public EventExpr (EventSpec spec, Location loc)
 		{
 			this.spec = spec;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="60" endline="69">
<![CDATA[
 	}
 	
 	public class CompletionSimpleName 
 		public string Prefix;
 		
 		public CompletionSimpleName (string prefix, Location l)
 		{
 			this.loc = l;
 			this.Prefix = prefix;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="150" endline="174">
<![CDATA[
 				AppendResults (results, partial_name, r);
 			}
 
 			throw new CompletionResult (partial_name == null ? "" 
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			CompletionMemberAccess target = (CompletionMemberAccess) t;
 
 			if (targs != null)
 				target.targs = targs.Clone ();
 
 			target.expr = expr.Clone (clonectx);
 		}
 	}
 
 	public class CompletionElementInitializer 
 		string partial_name;
 		
 		public CompletionElementInitializer (string partial_name, Location l)
 		{
 			this.partial_name = partial_name;
 			this.loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="340" endline="351">
<![CDATA[
 	}
 
 	sealed class GenericParameterInfoImpl 
 	{
 		private readonly GenericMethodInstance method;
 		private readonly ParameterInfo parameterInfo;
 
 		internal GenericParameterInfoImpl(GenericMethodInstance method, ParameterInfo parameterInfo)
 		{
 			this.method = method;
 			this.parameterInfo = parameterInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\GenericWrappers.cs" startline="523" endline="534">
<![CDATA[
 	}
 
 	sealed class GenericEventInfo 
 	{
 		private readonly Type typeInstance;
 		private readonly EventInfo eventInfo;
 
 		internal GenericEventInfo(Type typeInstance, EventInfo eventInfo)
 		{
 			this.typeInstance = typeInstance;
 			this.eventInfo = eventInfo;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="972" endline="985">
<![CDATA[
 	}
 
 	/// <summary>
 	///   `goto case' statement
 	/// </summary>
 	public class GotoCase 
 		Expression expr;
 		SwitchLabel sl;
 		
 		public GotoCase (Expression e, Location l)
 		{
 			expr = e;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1042" endline="1051">
<![CDATA[
 	}
 	
 	public class Throw 
 		Expression expr;
 		
 		public Throw (Expression expr, Location l)
 		{
 			this.expr = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2986" endline="3007">
<![CDATA[
 	}
 	
 	public class SwitchLabel {
 		Expression label;
 		object converted;
 		Location loc;
 
 		Label il_label;
 		bool  il_label_set;
 		Label il_label_code;
 		bool  il_label_code_set;
 
 		public static readonly object NullStringCase = new object ();
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="2999" endline="3109">
<![CDATA[
 
 		//
 		// if expr == null, then it is the default case.
 		//
 		public SwitchLabel (Expression expr, Location l)
 		{
 			label = expr;
 			loc = l;
 		}
 
 		public Expression Label {
 			get {
 				return label;
 			}
 		}
 
 		public Location Location {
 			get { return loc; }
 		}
 
 		public object Converted {
 			get {
 				return converted;
 			}
 		}
 
 		public Label GetILLabel (EmitContext ec)
 		{
 			if (!il_label_set){
 				il_label = ec.DefineLabel ();
 				il_label_set = true;
 			}
 			return il_label;
 		}
 
 		public Label GetILLabelCode (EmitContext ec)
 		{
 			if (!il_label_code_set){
 				il_label_code = ec.DefineLabel ();
 				il_label_code_set = true;
 			}
 			return il_label_code;
 		}				
 		
 		//
 		// Resolves the expression, reduces it to a literal if possible
 		// and then converts it to the requested type.
 		//
 		public bool ResolveAndReduce (ResolveContext ec, TypeSpec required_type, bool allow_nullable)
 		{	
 			Expression e = label.Resolve (ec);
 
 			if (e == null)
 				return false;
 
 			Constant c = e as Constant;
 			if (c == null){
 				ec.Report.Error (150, loc, "A constant value is expected");
 				return false;
 			}
 
 			if (required_type == TypeManager.string_type && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 
 			if (allow_nullable && c.GetValue () == null) {
 				converted = NullStringCase;
 				return true;
 			}
 			
 			c = c.ImplicitConversionRequired (ec, required_type, loc);
 			if (c == null)
 				return false;
 
 			converted = c.GetValue ();
 			return true;
 		}
 
 		public void Error_AlreadyOccurs (ResolveContext ec, TypeSpec switch_type, SwitchLabel collision_with)
 		{
 			string label;
 			if (converted == null)
 				label = "default";
 			else if (converted == NullStringCase)
 				label = "null";
 			else
 				label = converted.ToString ();
 			
 			ec.Report.SymbolRelatedToPreviousError (collision_with.loc, null);
 			ec.Report.Error (152, loc, "The label `case {0}
 		}
 
 		public SwitchLabel Clone (CloneContext clonectx)
 		{
 			if (label == null)
 				return this;
 
 			return new SwitchLabel (label.Clone (clonectx), loc);
 		}
 	}
 
 	public class SwitchSection {
 		public readonly List<SwitchLabel> Labels;
 		public readonly Block Block;
 		
 		public SwitchSection (List<SwitchLabel> labels, Block block)
 		{
 			Labels = labels;
 			Block = block;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="3921" endline="3938">
<![CDATA[
 	}
 
 	// Base class for statements that are implemented in terms of try...finally
 	public abstract class ExceptionStatement 
 	{
 		bool code_follows;
 		Iterator iter;
 		List<ResumableStatement> resume_points;
 		int first_resume_pc;
 		protected Statement stmt;
 		Label dispose_try_block;
 		bool prepared_for_dispose, emitted_dispose;
 
 		protected ExceptionStatement (Statement stmt, Location loc)
 		{
 			this.stmt = stmt;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="4628" endline="4642">
<![CDATA[
 	}
 
 	public class Catch 
 	{
 		Block block;
 		LocalVariable li;
 		FullNamedExpression type_expr;
 		CompilerAssign assign;
 		TypeSpec type;
 		
 		public Catch (Block block, Location loc)
 		{
 			this.block = block;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="106" endline="790">
<![CDATA[
 	}
 	
 	//
 	//   Unary implements unary expressions.
 	//
 	public class Unary 
 	{
 		public enum Operator 
 			UnaryPlus, UnaryNegation, LogicalNot, OnesComplement,
 			AddressOf,  TOP
 		}
 
 		static TypeSpec[][] predefined_operators;
 
 		public readonly Operator Oper;
 		public Expression Expr;
 		Expression enum_conversion;
 
 		public Unary (Operator op, Expression expr, Location loc)
 		{
 			Oper = op;
 			Expr = expr;
 			this.loc = loc;
 		}
 
 		// <summary>
 		//   This routine will attempt to simplify the unary expression when the
 		//   argument is a constant.
 		// </summary>
 		Constant TryReduceConstant (ResolveContext ec, Constant e)
 		{
 			if (e is EmptyConstantCast)
 				return TryReduceConstant (ec, ((EmptyConstantCast) e).child);
 			
 			if (e is SideEffectConstant) {
 				Constant r = TryReduceConstant (ec, ((SideEffectConstant) e).value);
 				return r == null ? null 
 			}
 
 			TypeSpec expr_type = e.Type;
 			
 			switch (Oper){
 			case Operator.UnaryPlus
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type || expr_type == TypeManager.uint32_type ||
 				    expr_type == TypeManager.int64_type || expr_type == TypeManager.uint64_type ||
 				    expr_type == TypeManager.float_type || expr_type == TypeManager.double_type ||
 				    expr_type == TypeManager.decimal_type) {
 					return e;
 				}
 				
 				return null;
 				
 			case Operator.UnaryNegation
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (-((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (-((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (-((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (-((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (-((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type) {
 					int value = ((IntConstant)e).Value;
 					if (value == int.MinValue) {
 						if (ec.ConstantCheckState) {
 							ConstantFold.Error_CompileTimeOverflow (ec, loc);
 							return null;
 						}
 						return e;
 					}
 					return new IntConstant (-value, e.Location);
 				}
 				if (expr_type == TypeManager.int64_type) {
 					long value = ((LongConstant)e).Value;
 					if (value == long.MinValue) {
 						if (ec.ConstantCheckState) {
 							ConstantFold.Error_CompileTimeOverflow (ec, loc);
 							return null;
 						}
 						return e;
 					}
 					return new LongConstant (-value, e.Location);
 				}
 				
 				if (expr_type == TypeManager.uint32_type) {
 					UIntLiteral uil = e as UIntLiteral;
 					if (uil != null) {
 						if (uil.Value == int.MaxValue + (uint) 1)
 							return new IntLiteral (int.MinValue, e.Location);
 						return new LongLiteral (-uil.Value, e.Location);
 					}
 					return new LongConstant (-((UIntConstant)e).Value, e.Location);
 				}
 				
 				if (expr_type == TypeManager.uint64_type) {
 					ULongLiteral ull = e as ULongLiteral;
 					if (ull != null && ull.Value == 9223372036854775808)
 						return new LongLiteral (long.MinValue, e.Location);
 					return null;
 				}
 				
 				if (expr_type == TypeManager.float_type) {
 					FloatLiteral fl = e as FloatLiteral;
 					// For better error reporting
 					if (fl != null)
 						return new FloatLiteral (-fl.Value, e.Location);
 
 					return new FloatConstant (-((FloatConstant)e).Value, e.Location);
 				}
 				if (expr_type == TypeManager.double_type) {
 					DoubleLiteral dl = e as DoubleLiteral;
 					// For better error reporting
 					if (dl != null)
 						return new DoubleLiteral (-dl.Value, e.Location);
 
 					return new DoubleConstant (-((DoubleConstant)e).Value, e.Location);
 				}
 				if (expr_type == TypeManager.decimal_type)
 					return new DecimalConstant (-((DecimalConstant)e).Value, e.Location);
 				
 				return null;
 				
 			case Operator.LogicalNot
 				if (expr_type != TypeManager.bool_type)
 					return null;
 				
 				bool b = (bool)e.GetValue ();
 				return new BoolConstant (!b, e.Location);
 				
 			case Operator.OnesComplement
 				// Unary numeric promotions
 				if (expr_type == TypeManager.byte_type)
 					return new IntConstant (~((ByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.sbyte_type)
 					return new IntConstant (~((SByteConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.short_type)
 					return new IntConstant (~((ShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.ushort_type)
 					return new IntConstant (~((UShortConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.char_type)
 					return new IntConstant (~((CharConstant)e).Value, e.Location);
 				
 				// Predefined operators
 				if (expr_type == TypeManager.int32_type)
 					return new IntConstant (~((IntConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.uint32_type)
 					return new UIntConstant (~((UIntConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.int64_type)
 					return new LongConstant (~((LongConstant)e).Value, e.Location);
 				if (expr_type == TypeManager.uint64_type){
 					return new ULongConstant (~((ULongConstant)e).Value, e.Location);
 				}
 				if (e is EnumConstant) {
 					e = TryReduceConstant (ec, ((EnumConstant)e).Child);
 					if (e != null)
 						e = new EnumConstant (e, expr_type);
 					return e;
 				}
 				return null;
 			}
 			throw new Exception ("Can not constant fold
 		}
 		
 		protected virtual Expression ResolveOperator (ResolveContext ec, Expression expr)
 		{
 			eclass = ExprClass.Value;
 
 			if (predefined_operators == null)
 				CreatePredefinedOperatorsTable ();
 
 			TypeSpec expr_type = expr.Type;
 			Expression best_expr;
 
 			//
 			// Primitive types first
 			//
 			if (TypeManager.IsPrimitiveType (expr_type)) {
 				best_expr = ResolvePrimitivePredefinedType (expr);
 				if (best_expr == null)
 					return null;
 
 				type = best_expr.Type;
 				Expr = best_expr;
 				return this;
 			}
 
 			//
 			// E operator ~(E x);
 			//
 			if (Oper == Operator.OnesComplement && TypeManager.IsEnumType (expr_type))
 				return ResolveEnumOperator (ec, expr);
 
 			return ResolveUserType (ec, expr);
 		}
 
 		protected virtual Expression ResolveEnumOperator (ResolveContext ec, Expression expr)
 		{
 			TypeSpec underlying_type = EnumSpec.GetUnderlyingType (expr.Type);
 			Expression best_expr = ResolvePrimitivePredefinedType (EmptyCast.Create (expr, underlying_type));
 			if (best_expr == null)
 				return null;
 
 			Expr = best_expr;
 			enum_conversion = Convert.ExplicitNumericConversion (new EmptyExpression (best_expr.Type), underlying_type);
 			type = expr.Type;
 			return EmptyCast.Create (this, type);
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			return CreateExpressionTree (ec, null);
 		}
 
 		Expression CreateExpressionTree (ResolveContext ec, Expression user_op)
 		{
 			string method_name;
 			switch (Oper) {
 			case Operator.AddressOf
 				Error_PointerInsideExpressionTree (ec);
 				return null;
 			case Operator.UnaryNegation
 				if (ec.HasSet (ResolveContext.Options.CheckedScope) && user_op == null && !IsFloat (type))
 					method_name = "NegateChecked";
 				else
 					method_name = "Negate";
 				break;
 			case Operator.OnesComplement
 			case Operator.LogicalNot
 				method_name = "Not";
 				break;
 			case Operator.UnaryPlus
 				method_name = "UnaryPlus";
 				break;
 			default
 				throw new InternalErrorException ("Unknown unary operator " + Oper.ToString ());
 			}
 
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (Expr.CreateExpressionTree (ec)));
 			if (user_op != null)
 				args.Add (new Argument (user_op));
 
 			return CreateExpressionFactoryCall (ec, method_name, args);
 		}
 
 		static void CreatePredefinedOperatorsTable ()
 		{
 			predefined_operators = new TypeSpec [(int) Operator.TOP] [];
 
 			//
 			// 7.6.1 Unary plus operator
 			//
 			predefined_operators [(int) Operator.UnaryPlus] = new TypeSpec [] {
 				TypeManager.int32_type, TypeManager.uint32_type,
 				TypeManager.int64_type, TypeManager.uint64_type,
 				TypeManager.float_type, TypeManager.double_type,
 				TypeManager.decimal_type
 			};
 
 			//
 			// 7.6.2 Unary minus operator
 			//
 			predefined_operators [(int) Operator.UnaryNegation] = new TypeSpec [] {
 				TypeManager.int32_type, 
 				TypeManager.int64_type,
 				TypeManager.float_type, TypeManager.double_type,
 				TypeManager.decimal_type
 			};
 
 			//
 			// 7.6.3 Logical negation operator
 			//
 			predefined_operators [(int) Operator.LogicalNot] = new TypeSpec [] {
 				TypeManager.bool_type
 			};
 
 			//
 			// 7.6.4 Bitwise complement operator
 			//
 			predefined_operators [(int) Operator.OnesComplement] = new TypeSpec [] {
 				TypeManager.int32_type, TypeManager.uint32_type,
 				TypeManager.int64_type, TypeManager.uint64_type
 			};
 		}
 
 		//
 		// Unary numeric promotions
 		//
 		static Expression DoNumericPromotion (Operator op, Expression expr)
 		{
 			TypeSpec expr_type = expr.Type;
 			if ((op == Operator.UnaryPlus || op == Operator.UnaryNegation || op == Operator.OnesComplement) &&
 				expr_type == TypeManager.byte_type || expr_type == TypeManager.sbyte_type ||
 				expr_type == TypeManager.short_type || expr_type == TypeManager.ushort_type ||
 				expr_type == TypeManager.char_type)
 				return Convert.ImplicitNumericConversion (expr, TypeManager.int32_type);
 
 			if (op == Operator.UnaryNegation && expr_type == TypeManager.uint32_type)
 				return Convert.ImplicitNumericConversion (expr, TypeManager.int64_type);
 
 			return expr;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (Oper == Operator.AddressOf) {
 				return ResolveAddressOf (ec);
 			}
 
 			Expr = Expr.Resolve (ec);
 			if (Expr == null)
 				return null;
 
 			if (Expr.Type == InternalType.Dynamic) {
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (Expr));
 				return new DynamicUnaryConversion (GetOperatorExpressionTypeName (), args, loc).Resolve (ec);
 			}
 
 			if (TypeManager.IsNullableType (Expr.Type))
 				return new Nullable.LiftedUnaryOperator (Oper, Expr, loc).Resolve (ec);
 
 			//
 			// Attempt to use a constant folding operation.
 			//
 			Constant cexpr = Expr as Constant;
 			if (cexpr != null) {
 				cexpr = TryReduceConstant (ec, cexpr);
 				if (cexpr != null)
 					return cexpr.Resolve (ec);
 			}
 
 			Expression expr = ResolveOperator (ec, Expr);
 			if (expr == null)
 				Error_OperatorCannotBeApplied (ec, loc, OperName (Oper), Expr.Type);
 			
 			//
 			// Reduce unary operator on predefined types
 			//
 			if (expr == this && Oper == Operator.UnaryPlus)
 				return Expr;
 
 			return expr;
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right)
 		{
 			return null;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			EmitOperator (ec, type);
 		}
 
 		protected void EmitOperator (EmitContext ec, TypeSpec type)
 		{
 			switch (Oper) {
 			case Operator.UnaryPlus
 				Expr.Emit (ec);
 				break;
 				
 			case Operator.UnaryNegation
 				if (ec.HasSet (EmitContext.Options.CheckedScope) && !IsFloat (type)) {
 					ec.Emit (OpCodes.Ldc_I4_0);
 					if (type == TypeManager.int64_type)
 						ec.Emit (OpCodes.Conv_U8);
 					Expr.Emit (ec);
 					ec.Emit (OpCodes.Sub_Ovf);
 				} else {
 					Expr.Emit (ec);
 					ec.Emit (OpCodes.Neg);
 				}
 				
 				break;
 				
 			case Operator.LogicalNot
 				Expr.Emit (ec);
 				ec.Emit (OpCodes.Ldc_I4_0);
 				ec.Emit (OpCodes.Ceq);
 				break;
 				
 			case Operator.OnesComplement
 				Expr.Emit (ec);
 				ec.Emit (OpCodes.Not);
 				break;
 				
 			case Operator.AddressOf
 				((IMemoryLocation)Expr).AddressOf (ec, AddressOp.LoadStore);
 				break;
 				
 			default
 				throw new Exception ("This should not happen
 						     + Oper.ToString ());
 			}
 
 			//
 			// Same trick as in Binary expression
 			//
 			if (enum_conversion != null)
 				enum_conversion.Emit (ec);
 		}
 
 		public override void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			if (Oper == Operator.LogicalNot)
 				Expr.EmitBranchable (ec, target, !on_true);
 			else
 				base.EmitBranchable (ec, target, on_true);
 		}
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			Expr.EmitSideEffect (ec);
 		}
 
 		public static void Error_OperatorCannotBeApplied (ResolveContext ec, Location loc, string oper, TypeSpec t)
 		{
 			ec.Report.Error (23, loc, "The `{0}' operator cannot be applied to operand of type `{1}'",
 				oper, TypeManager.CSharpName (t));
 		}
 
 		//
 		// Converts operator to System.Linq.Expressions.ExpressionType enum name
 		//
 		string GetOperatorExpressionTypeName ()
 		{
 			switch (Oper) {
 			case Operator.OnesComplement
 				return "OnesComplement";
 			case Operator.LogicalNot
 				return "Not";
 			case Operator.UnaryNegation
 				return "Negate";
 			case Operator.UnaryPlus
 				return "UnaryPlus";
 			default
 				throw new NotImplementedException ("Unknown express type operator " + Oper.ToString ());
 			}
 		}
 
 		static bool IsFloat (TypeSpec t)
 		{
 			return t == TypeManager.float_type || t == TypeManager.double_type;
 		}
 
 		//
 		// Returns a stringified representation of the Operator
 		//
 		public static string OperName (Operator oper)
 		{
 			switch (oper) {
 			case Operator.UnaryPlus
 				return "+";
 			case Operator.UnaryNegation
 				return "-";
 			case Operator.LogicalNot
 				return "!";
 			case Operator.OnesComplement
 				return "~";
 			case Operator.AddressOf
 				return "&";
 			}
 
 			throw new NotImplementedException (oper.ToString ());
 		}
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			var expr = Expr.MakeExpression (ctx);
 			bool is_checked = ctx.HasSet (BuilderContext.Options.CheckedScope);
 
 			switch (Oper) {
 			case Operator.UnaryNegation
 				return is_checked ? SLE.Expression.NegateChecked (expr) 
 			case Operator.LogicalNot
 				return SLE.Expression.Not (expr);
 #if NET_4_0
 			case Operator.OnesComplement
 				return SLE.Expression.OnesComplement (expr);
 #endif
 			default
 				throw new NotImplementedException (Oper.ToString ());
 			}
 		}
 
 		public static void Reset ()
 		{
 			predefined_operators = null;
 		}
 
 		Expression ResolveAddressOf (ResolveContext ec)
 		{
 			if (!ec.IsUnsafe)
 				UnsafeError (ec, loc);
 
 			Expr = Expr.DoResolveLValue (ec, EmptyExpression.UnaryAddress);
 			if (Expr == null || Expr.eclass != ExprClass.Variable) {
 				ec.Report.Error (211, loc, "Cannot take the address of the given expression");
 				return null;
 			}
 
 			if (!TypeManager.VerifyUnmanaged (ec.Compiler, Expr.Type, loc)) {
 				return null;
 			}
 
 			IVariableReference vr = Expr as IVariableReference;
 			bool is_fixed;
 			if (vr != null) {
 				VariableInfo vi = vr.VariableInfo;
 				if (vi != null) {
 					if (vi.LocalInfo != null)
 						vi.LocalInfo.SetIsUsed ();
 
 					//
 					// A variable is considered definitely assigned if you take its address.
 					//
 					vi.SetAssigned (ec);
 				}
 
 				is_fixed = vr.IsFixed;
 				vr.SetHasAddressTaken ();
 
 				if (vr.IsHoisted) {
 					AnonymousMethodExpression.Error_AddressOfCapturedVar (ec, vr, loc);
 				}
 			} else {
 				IFixedExpression fe = Expr as IFixedExpression;
 				is_fixed = fe != null && fe.IsFixed;
 			}
 
 			if (!is_fixed && !ec.HasSet (ResolveContext.Options.FixedInitializerScope)) {
 				ec.Report.Error (212, loc, "You can only take the address of unfixed expression inside of a fixed statement initializer");
 			}
 
 			type = PointerContainer.MakeType (Expr.Type);
 			eclass = ExprClass.Value;
 			return this;
 		}
 
 		Expression ResolvePrimitivePredefinedType (Expression expr)
 		{
 			expr = DoNumericPromotion (Oper, expr);
 			TypeSpec expr_type = expr.Type;
 			TypeSpec[] predefined = predefined_operators [(int) Oper];
 			foreach (TypeSpec t in predefined) {
 				if (t == expr_type)
 					return expr;
 			}
 			return null;
 		}
 
 		//
 		// Perform user-operator overload resolution
 		//
 		protected virtual Expression ResolveUserOperator (ResolveContext ec, Expression expr)
 		{
 			CSharp.Operator.OpType op_type;
 			switch (Oper) {
 			case Operator.LogicalNot
 				op_type = CSharp.Operator.OpType.LogicalNot; break;
 			case Operator.OnesComplement
 				op_type = CSharp.Operator.OpType.OnesComplement; break;
 			case Operator.UnaryNegation
 				op_type = CSharp.Operator.OpType.UnaryNegation; break;
 			case Operator.UnaryPlus
 				op_type = CSharp.Operator.OpType.UnaryPlus; break;
 			default
 				throw new InternalErrorException (Oper.ToString ());
 			}
 
 			var methods = MemberCache.GetUserOperator (expr.Type, op_type, false);
 			if (methods == null)
 				return null;
 
 			Arguments args = new Arguments (1);
 			args.Add (new Argument (expr));
 
 			var res = new OverloadResolver (methods, OverloadResolver.Restrictions.BaseMembersIncluded | OverloadResolver.Restrictions.NoBaseMembers, loc);
 			var oper = res.ResolveOperator (ec, ref args);
 
 			if (oper == null)
 				return null;
 
 			Expr = args [0].Expr;
 			return new UserOperatorCall (oper, args, CreateExpressionTree, expr.Location);
 		}
 
 		//
 		// Unary user type overload resolution
 		//
 		Expression ResolveUserType (ResolveContext ec, Expression expr)
 		{
 			Expression best_expr = ResolveUserOperator (ec, expr);
 			if (best_expr != null)
 				return best_expr;
 
 			TypeSpec[] predefined = predefined_operators [(int) Oper];
 			foreach (TypeSpec t in predefined) {
 				Expression oper_expr = Convert.ImplicitUserConversion (ec, expr, t, expr.Location);
 				if (oper_expr == null)
 					continue;
 
 				//
 				// decimal type is predefined but has user-operators
 				//
 				if (oper_expr.Type == TypeManager.decimal_type)
 					oper_expr = ResolveUserType (ec, oper_expr);
 				else
 					oper_expr = ResolvePrimitivePredefinedType (oper_expr);
 
 				if (oper_expr == null)
 					continue;
 
 				if (best_expr == null) {
 					best_expr = oper_expr;
 					continue;
 				}
 
 				int result = OverloadResolver.BetterTypeConversion (ec, best_expr.Type, t);
 				if (result == 0) {
 					ec.Report.Error (35, loc, "Operator `{0}' is ambiguous on an operand of type `{1}'",
 						OperName (Oper), TypeManager.CSharpName (expr.Type));
 					break;
 				}
 
 				if (result == 2)
 					best_expr = oper_expr;
 			}
 			
 			if (best_expr == null)
 				return null;
 			
 			//
 			// HACK
 			//
 			if (best_expr.Type == TypeManager.decimal_type)
 				return best_expr;			
 
 			Expr = best_expr;
 			type = best_expr.Type;
 			return this;			
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Unary target = (Unary) t;
 
 			target.Expr = Expr.Clone (clonectx);
 		}
 	}
 
 	//
 	// Unary operators are turned into Indirection expressions
 	// after semantic analysis (this is so we can take the address
 	// of an indirection).
 	//
 	public class Indirection 
 		Expression expr;
 		LocalTemporary temporary;
 		bool prepared;
 		
 		public Indirection (Expression expr, Location l)
 		{
 			this.expr = expr;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1641" endline="1654">
<![CDATA[
 	}
 	
 	//
 	// C# 2.0 Default value expression
 	//
 	public class DefaultValueExpression 
 	{
 		Expression expr;
 
 		public DefaultValueExpression (Expression expr, Location loc)
 		{
 			this.expr = expr;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="4527" endline="4703">
<![CDATA[
 	}
 
 	public abstract class VariableReference 
 		LocalTemporary temp;
 
 		#region Abstract
 		public abstract HoistedVariable GetHoistedVariable (AnonymousExpression ae);
 
 		public abstract bool IsLockedByStatement { get; set; }
 
 		public abstract bool IsFixed { get; }
 		public abstract bool IsRef { get; }
 		public abstract string Name { get; }
 		public abstract void SetHasAddressTaken ();
 
 		//
 		// Variable IL data, it has to be protected to encapsulate hoisted variables
 		//
 		protected abstract ILocalVariable Variable { get; }
 		
 		//
 		// Variable flow-analysis data
 		//
 		public abstract VariableInfo VariableInfo { get; }
 		#endregion
 
 		public virtual void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.AddressOf (ec, mode);
 				return;
 			}
 
 			Variable.EmitAddressOf (ec);
 		}
 
 		public override Expression DoResolveLValue (ResolveContext rc, Expression right_side)
 		{
 			if (IsLockedByStatement) {
 				rc.Report.Warning (728, 2, loc,
 					"Possibly incorrect assignment to `{0}' which is the argument to a using or lock statement",
 					Name);
 			}
 
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			Emit (ec, false);
 		}
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			// do nothing
 		}
 
 		//
 		// This method is used by parameters that are references, that are
 		// being passed as references
 		// is already stored in the parameter, not the address of the pointer,
 		// and not the value of the variable).
 		//
 		public void EmitLoad (EmitContext ec)
 		{
 			Variable.Emit (ec);
 		}
 
 		public void Emit (EmitContext ec, bool leave_copy)
 		{
 			Report.Debug (64, "VARIABLE EMIT", this, Variable, type, IsRef, loc);
 
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.Emit (ec, leave_copy);
 				return;
 			}
 
 			EmitLoad (ec);
 
 			if (IsRef) {
 				//
 				// If we are a reference, we loaded on the stack a pointer
 				// Now lets load the real value
 				//
 				ec.EmitLoadFromPtr (type);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 		}
 
 		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy,
 					bool prepare_for_load)
 		{
 			HoistedVariable hv = GetHoistedVariable (ec);
 			if (hv != null) {
 				hv.EmitAssign (ec, source, leave_copy, prepare_for_load);
 				return;
 			}
 
 			New n_source = source as New;
 			if (n_source != null) {
 				if (!n_source.Emit (ec, this)) {
 					if (leave_copy) {
 						EmitLoad (ec);
 						if (IsRef)
 							ec.EmitLoadFromPtr (type);
 					}
 					return;
 				}
 			} else {
 				if (IsRef)
 					EmitLoad (ec);
 
 				source.Emit (ec);
 			}
 
 			if (leave_copy) {
 				ec.Emit (OpCodes.Dup);
 				if (IsRef) {
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
 			}
 
 			if (IsRef)
 				ec.EmitStoreFromPtr (type);
 			else
 				Variable.EmitAssign (ec);
 
 			if (temp != null) {
 				temp.Emit (ec);
 				temp.Release (ec);
 			}
 		}
 
 
 		public HoistedVariable GetHoistedVariable (ResolveContext rc)
 		{
 			return GetHoistedVariable (rc.CurrentAnonymousMethod);
 		}
 
 		public HoistedVariable GetHoistedVariable (EmitContext ec)
 		{
 			return GetHoistedVariable (ec.CurrentAnonymousMethod);
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return Name;
 		}
 
 		public bool IsHoisted {
 			get { return GetHoistedVariable ((AnonymousExpression) null) != null; }
 		}
 	}
 
 	//
 	// Resolved reference to a local variable
 	//
 	public class LocalVariableReference 
 	{
 		public LocalVariable local_info;
 
 		public LocalVariableReference (LocalVariable li, Location l)
 		{
 			this.local_info = li;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5892" endline="5909">
<![CDATA[
 	}
 
 	//
 	// Array initializer expression, the expression is allowed in
 	// variable or field initialization only which makes it tricky as
 	// the type has to be infered based on the context either from field
 	// type or variable type (think of multiple declarators)
 	//
 	public class ArrayInitializer 
 	{
 		List<Expression> elements;
 		BlockVariableDeclaration variable;
 
 		public ArrayInitializer (List<Expression> init, Location loc)
 		{
 			elements = init;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7082" endline="7095">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the typeof operator
 	/// </summary>
 	public class TypeOf 
 		FullNamedExpression QueriedType;
 		TypeSpec typearg;
 
 		public TypeOf (FullNamedExpression queried_type, Location l)
 		{
 			QueriedType = queried_type;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7220" endline="7292">
<![CDATA[
 	}
 
 	class TypeOfMethod 
 	{
 		public TypeOfMethod (MethodSpec method, Location loc)
 			
 		{
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (member.IsConstructor) {
 				type = ec.Module.PredefinedTypes.ConstructorInfo.Resolve (loc);
 			} else {
 				type = ec.Module.PredefinedTypes.MethodInfo.Resolve (loc);
 			}
 
 			if (type == null)
 				return null;
 
 			return base.DoResolve (ec);
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			ec.Emit (OpCodes.Ldtoken, member);
 
 			base.Emit (ec);
 			ec.Emit (OpCodes.Castclass, type);
 		}
 
 		protected override string GetMethodName {
 			get { return "GetMethodFromHandle"; }
 		}
 
 		protected override PredefinedType GetDeclaringType (PredefinedTypes types)
 		{
 			return types.MethodBase;
 		}
 
 		protected override PredefinedType GetRuntimeHandle (PredefinedTypes types)
 		{
 			return types.RuntimeMethodHandle;
 		}
 
 		protected override MethodSpec TypeFromHandle {
 			get {
 				return TypeManager.methodbase_get_type_from_handle;
 			}
 			set {
 				TypeManager.methodbase_get_type_from_handle = value;
 			}
 		}
 
 		protected override MethodSpec TypeFromHandleGeneric {
 			get {
 				return TypeManager.methodbase_get_type_from_handle_generic;
 			}
 			set {
 				TypeManager.methodbase_get_type_from_handle_generic = value;
 			}
 		}
 	}
 
 	abstract class TypeOfMember<T> 
 	{
 		protected readonly T member;
 
 		protected TypeOfMember (T member, Location loc)
 		{
 			this.member = member;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7402" endline="7416">
<![CDATA[
 		}
 	}
 
 	/// <summary>
 	///   Implements the sizeof expression
 	/// </summary>
 	public class SizeOf 
 		readonly Expression QueriedType;
 		TypeSpec type_queried;
 		
 		public SizeOf (Expression queried_type, Location l)
 		{
 			this.QueriedType = queried_type;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7471" endline="7928">
<![CDATA[
 
 		public QualifiedAliasMember (string alias, string identifier, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public QualifiedAliasMember (string alias, string identifier, TypeArguments targs, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public QualifiedAliasMember (string alias, string identifier, int arity, Location l)
 			
 		{
 			this.alias = alias;
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			if (alias == GlobalAlias) {
 				expr = ec.Module.GlobalRootNamespace;
 				return base.ResolveAsTypeStep (ec, silent);
 			}
 
 			int errors = ec.Compiler.Report.Errors;
 			expr = ec.LookupNamespaceAlias (alias);
 			if (expr == null) {
 				if (errors == ec.Compiler.Report.Errors)
 					ec.Compiler.Report.Error (432, loc, "Alias `{0}' not found", alias);
 				return null;
 			}
 
 			FullNamedExpression fne = base.ResolveAsTypeStep (ec, silent);
 			if (fne == null)
 				return null;
 
 			if (expr.eclass == ExprClass.Type) {
 				if (!silent) {
 					ec.Compiler.Report.Error (431, loc,
 						"Alias `{0}' cannot be used with '
 				}
 				return null;
 			}
 
 			return fne;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return ResolveAsTypeStep (ec, false);
 		}
 
 		protected override void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			rc.Compiler.Report.Error (687, loc,
 				"A namespace alias qualifier `{0}' did not resolve to a namespace or a type",
 				GetSignatureForError ());
 		}
 
 		public override string GetSignatureForError ()
 		{
 			string name = Name;
 			if (targs != null) {
 				name = Name + "<" + targs.GetSignatureForError () + ">";
 			}
 
 			return alias + "
 		}
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			return DoResolve (rc);
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			// Nothing 
 		}
 	}
 
 	/// <summary>
 	///   Implements the member access expression
 	/// </summary>
 	public class MemberAccess 
 	{
 		protected Expression expr;
 
 		public MemberAccess (Expression expr, string id)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, TypeArguments args, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public MemberAccess (Expression expr, string identifier, int arity, Location loc)
 			
 		{
 			this.expr = expr;
 		}
 
 		public Expression LeftExpression {
 			get {
 				return expr;
 			}
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return DoResolveName (ec, null);
 		}
 
 		public override Expression DoResolveLValue (ResolveContext ec, Expression right_side)
 		{
 			return DoResolveName (ec, right_side);
 		}
 
 		Expression DoResolveName (ResolveContext rc, Expression right_side)
 		{
 			Expression e = LookupNameExpression (rc, right_side == null ? MemberLookupRestrictions.ReadAccess 
 			if (e == null)
 				return null;
 
 			if (right_side != null) {
 				if (e is TypeExpr) {
 					e.Error_UnexpectedKind (rc, ResolveFlags.VariableOrValue, loc);
 					return null;
 				}
 
 				e = e.ResolveLValue (rc, right_side);
 			} else {
 				e = e.Resolve (rc, ResolveFlags.VariableOrValue | ResolveFlags.Type);
 			}
 
 			return e;
 		}
 
 		public override Expression LookupNameExpression (ResolveContext rc, MemberLookupRestrictions restrictions)
 		{
 			var sn = expr as SimpleName;
 			const ResolveFlags flags = ResolveFlags.VariableOrValue | ResolveFlags.Type;
 
 			//
 			// Resolve the expression with flow analysis turned off, we'll do the definite
 			// assignment checks later.  This is because we don't know yet what the expression
 			// will resolve to - it may resolve to a FieldExpr and in this case we must do the
 			// definite assignment check on the actual field and not on the whole struct.
 			//
 			using (rc.Set (ResolveContext.Options.OmitStructFlowAnalysis)) {
 				if (sn != null) {
 					expr = sn.LookupNameExpression (rc, MemberLookupRestrictions.ReadAccess | MemberLookupRestrictions.ExactArity);
 
 					// Call resolve on expression which does have type set as we need expression type
 					// TODO
 					if (expr is VariableReference || expr is ConstantExpr || expr is Linq.TransparentMemberAccess) {
 						using (rc.With (ResolveContext.Options.DoFlowAnalysis, false)) {
 							expr = expr.Resolve (rc);
 						}
 					} else if (expr is TypeParameterExpr) {
 						expr.Error_UnexpectedKind (rc, flags, sn.Location);
 						expr = null;
 					}
 				} else {
 					expr = expr.Resolve (rc, flags);
 				}
 			}
 
 			if (expr == null)
 				return null;
 
 			Namespace ns = expr as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 					return null;
 				}
 
 				if (HasTypeArguments)
 					return new GenericTypeExpr (retval.Type, targs, loc);
 
 				return retval;
 			}
 
 			MemberExpr me;
 			TypeSpec expr_type = expr.Type;
 			if (expr_type == InternalType.Dynamic) {
 				me = expr as MemberExpr;
 				if (me != null)
 					me.ResolveInstanceExpression (rc, null);
 
 				Arguments args = new Arguments (1);
 				args.Add (new Argument (expr));
 				return new DynamicMemberBinder (Name, args, loc);
 			}
 
 			const MemberKind dot_kinds = MemberKind.Class | MemberKind.Struct | MemberKind.Delegate | MemberKind.Enum |
 				MemberKind.Interface | MemberKind.TypeParameter | MemberKind.ArrayType;
 
 			if ((expr_type.Kind & dot_kinds) == 0 || expr_type == TypeManager.void_type) {
 				if (expr_type == InternalType.Null && rc.Compiler.IsRuntimeBinder)
 					rc.Report.Error (Report.RuntimeErrorId, loc, "Cannot perform member binding on `null' value");
 				else
 					Unary.Error_OperatorCannotBeApplied (rc, loc, ".", expr_type);
 				return null;
 			}
 
 			var current_type = rc.CurrentType;
 			var lookup_arity = Arity;
 			bool errorMode = false;
 			Expression member_lookup;
 			while (true) {
 				member_lookup = MemberLookup (errorMode ? null 
 				if (member_lookup == null) {
 					//
 					// Try to look for extension method when member lookup failed
 					//
 					if (MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 						NamespaceEntry scope = null;
 						var methods = rc.LookupExtensionMethod (expr_type, Name, lookup_arity, ref scope);
 						if (methods != null) {
 							var emg = new ExtensionMethodGroupExpr (methods, scope, expr, loc);
 							if (HasTypeArguments) {
 								if (!targs.Resolve (rc))
 									return null;
 
 								emg.SetTypeArguments (rc, targs);
 							}
 
 							// TODO
 							return emg.Resolve (rc);
 						}
 					}
 				}
 
 				if (errorMode) {
 					if (member_lookup == null) {
 						if (expr is TypeExpr)
 							base.Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 						else
 							Error_TypeDoesNotContainDefinition (rc, expr_type, Name);
 
 						return null;
 					}
 
 					if (member_lookup is MethodGroupExpr) {
 						// Leave it to overload resolution to report correct error
 					} else {
 						// TODO
 						ErrorIsInaccesible (rc, member_lookup.GetSignatureForError (), loc);
 					}
 					break;
 				}
 
 				if (member_lookup != null)
 					break;
 
 				current_type = null;
 				lookup_arity = 0;
 				restrictions &= ~MemberLookupRestrictions.InvocableOnly;
 				errorMode = true;
 			}
 
 			TypeExpr texpr = member_lookup as TypeExpr;
 			if (texpr != null) {
 				if (!(expr is TypeExpr)) {
 					me = expr as MemberExpr;
 					if (me == null || me.ProbeIdenticalTypeName (rc, expr, sn) == expr) {
 						rc.Report.Error (572, loc, "`{0}'
 							Name, member_lookup.GetSignatureForError ());
 						return null;
 					}
 				}
 
 				if (!texpr.Type.IsAccessible (rc.CurrentType)) {
 					rc.Report.SymbolRelatedToPreviousError (member_lookup.Type);
 					ErrorIsInaccesible (rc, member_lookup.Type.GetSignatureForError (), loc);
 					return null;
 				}
 
 				if (HasTypeArguments) {
 					return new GenericTypeExpr (member_lookup.Type, targs, loc);
 				}
 
 				return member_lookup;
 			}
 
 			me = member_lookup as MemberExpr;
 
 			if (sn != null && me.IsStatic)
 				expr = me.ProbeIdenticalTypeName (rc, expr, sn);
 
 			me = me.ResolveMemberAccess (rc, expr, sn);
 
 			if (Arity > 0) {
 				if (!targs.Resolve (rc))
 					return null;
 
 				me.SetTypeArguments (rc, targs);
 			}
 
 			if (sn != null && (!TypeManager.IsValueType (expr_type) || me is PropertyExpr)) {
 				if (me.IsInstance) {
 					LocalVariableReference var = expr as LocalVariableReference;
 					if (var != null && !var.VerifyAssigned (rc))
 						return null;
 				}
 			}
 
 			return me;
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			return ResolveNamespaceOrType (ec, silent);
 		}
 
 		public FullNamedExpression ResolveNamespaceOrType (IMemberContext rc, bool silent)
 		{
 			FullNamedExpression expr_resolved = expr.ResolveAsTypeStep (rc, silent);
 
 			if (expr_resolved == null)
 				return null;
 
 			Namespace ns = expr_resolved as Namespace;
 			if (ns != null) {
 				FullNamedExpression retval = ns.Lookup (rc.Compiler, Name, Arity, loc);
 
 				if (retval == null) {
 					if (!silent)
 						ns.Error_NamespaceDoesNotExist (loc, Name, Arity, rc);
 				} else if (HasTypeArguments) {
 					retval = new GenericTypeExpr (retval.Type, targs, loc).ResolveAsTypeStep (rc, silent);
 				}
 
 				return retval;
 			}
 
 			TypeExpr tnew_expr = expr_resolved.ResolveAsTypeTerminal (rc, false);
 			if (tnew_expr == null)
 				return null;
 
 			TypeSpec expr_type = tnew_expr.Type;
 			if (TypeManager.IsGenericParameter (expr_type)) {
 				rc.Compiler.Report.Error (704, loc, "A nested type cannot be specified through a type parameter `{0}'",
 					tnew_expr.GetSignatureForError ());
 				return null;
 			}
 
 			TypeSpec nested = null;
 			while (expr_type != null) {
 				nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 				if (nested == null) {
 					if (silent)
 						return null;
 
 					if (expr_type == tnew_expr.Type) {
 						Error_IdentifierNotFound (rc, expr_type, Name);
 						return null;
 					}
 
 					expr_type = tnew_expr.Type;
 					nested = MemberCache.FindNestedType (expr_type, Name, Arity);
 					ErrorIsInaccesible (rc, nested.GetSignatureForError (), loc);
 					break;
 				}
 
 				if (nested.IsAccessible (rc.CurrentType))
 					break;
 
 				// Keep looking after inaccessible candidate
 				expr_type = nested.DeclaringType.BaseType;
 			}
 			
 			TypeExpr texpr;
 			if (Arity > 0) {
 				if (HasTypeArguments) {
 					texpr = new GenericTypeExpr (nested, targs, loc);
 				} else {
 					texpr = new GenericOpenTypeExpr (nested, loc);
 				}
 			} else {
 				texpr = new TypeExpression (nested, loc);
 			}
 
 			return texpr.ResolveAsTypeStep (rc, false);
 		}
 
 		protected virtual void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			var nested = MemberCache.FindNestedType (expr_type, Name, -System.Math.Max (1, Arity));
 
 			if (nested != null) {
 				Error_TypeArgumentsCannotBeUsed (rc.Compiler.Report, expr.Location, nested, Arity);
 				return;
 			}
 
 			var any_other_member = MemberLookup (null, rc.CurrentType, expr_type, Name, 0, MemberLookupRestrictions.None, loc);
 			if (any_other_member != null) {
 				any_other_member.Error_UnexpectedKind (rc.Compiler.Report, null, "type", loc);
 				return;
 			}
 
 			rc.Compiler.Report.Error (426, loc, "The nested type `{0}' does not exist in the type `{1}'",
 				Name, expr_type.GetSignatureForError ());
 		}
 
 		protected override void Error_TypeDoesNotContainDefinition (ResolveContext ec, TypeSpec type, string name)
 		{
 			if (RootContext.Version > LanguageVersion.ISO_2 && !ec.Compiler.IsRuntimeBinder && MethodGroupExpr.IsExtensionMethodArgument (expr)) {
 				ec.Report.SymbolRelatedToPreviousError (type);
 				ec.Report.Error (1061, loc,
 					"Type `{0}' does not contain a definition for `{1}' and no extension method `{1}' of type `{0}' could be found (are you missing a using directive or an assembly reference?)",
 					type.GetSignatureForError (), name);
 				return;
 			}
 
 			base.Error_TypeDoesNotContainDefinition (ec, type, name);
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return expr.GetSignatureForError () + "." + base.GetSignatureForError ();
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			MemberAccess target = (MemberAccess) t;
 
 			target.expr = expr.Clone (clonectx);
 		}
 	}
 
 	/// <summary>
 	///   Implements checked expressions
 	/// </summary>
 	public class CheckedExpr 
 
 		public Expression Expr;
 
 		public CheckedExpr (Expression e, Location l)
 		{
 			Expr = e;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7977" endline="7990">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements the unchecked expression
 	/// </summary>
 	public class UnCheckedExpr 
 
 		public Expression Expr;
 
 		public UnCheckedExpr (Expression e, Location l)
 		{
 			Expr = e;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8157" endline="8176">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Implements array access 
 	/// </summary>
 	public class ArrayAccess 
 		//
 		// Points to our "data" repository
 		//
 		ElementAccess ea;
 
 		LocalTemporary temp, expr_copy;
 		Expression[] prepared_arguments;
 		bool prepared;
 		
 		public ArrayAccess (ElementAccess ea_data, Location l)
 		{
 			ea = ea_data;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8826" endline="8842">
<![CDATA[
 	}
 
 	//
 	// Holds additional type specifiers like ?, *, []
 	//
 	public class ComposedTypeSpecifier
 	{
 		public static readonly ComposedTypeSpecifier SingleDimension = new ComposedTypeSpecifier (1, Location.Null);
 
 		public readonly int Dimension;
 		public readonly Location Location;
 
 		public ComposedTypeSpecifier (int specifier, Location loc)
 		{
 			this.Dimension = specifier;
 			this.Location = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="9317" endline="9334">
<![CDATA[
 	}
 	
 	//
 	// A block of object or collection initializers
 	//
 	public class CollectionOrObjectInitializers 
 	{
 		IList<Expression> initializers;
 		bool is_collection_initialization;
 		
 		public static readonly CollectionOrObjectInitializers Empty = 
 			new CollectionOrObjectInitializers (Array.AsReadOnly (new Expression [0]), Location.Null);
 
 		public CollectionOrObjectInitializers (IList<Expression> initializers, Location loc)
 		{
 			this.initializers = initializers;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ikvm.cs" startline="694" endline="706">
<![CDATA[
 		}
 	}
 
 	public class MissingType 
 	{
 		readonly string full_name;
 		readonly MissingAssembly assembly;
 
 		public MissingType (string typeName, MissingAssembly assembly)
 		{
 			this.full_name = typeName;
 			this.assembly = assembly;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="786" endline="1264">
<![CDATA[
 	}
 
 	public class Method 
 	{
 		Method partialMethodImplementation;
 
 		public Method (DeclSpace parent, GenericMethod generic,
 			       FullNamedExpression return_type, Modifiers mod,
 			       MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs, parameters)
 		{
 		}
 
 		protected Method (DeclSpace parent, FullNamedExpression return_type, Modifiers mod, Modifiers amod,
 					MemberName name, ParametersCompiled parameters, Attributes attrs)
 			
 		{
 		}
 
 		#region Properties
 
 		public override TypeParameter[] CurrentTypeParameters {
 			get {
 				if (GenericMethod != null)
 					return GenericMethod.CurrentTypeParameters;
 
 				return null;
 			}
 		}
 
 		public override bool HasUnresolvedConstraints {
 			get {
 				if (CurrentTypeParameters == null)
 					return false;
 
 				// When overriding base method constraints are fetched from
 				// base method but to find it we have to resolve parameters
 				// to find exact base method match
 				if (IsExplicitImpl || (ModFlags & Modifiers.OVERRIDE) != 0)
 					return base_method == null;
 
 				// Even for non-override generic method constraints check has to be
 				// delayed after all constraints are resolved
 				return true;
 			}
 		}
 
 		public TypeParameterSpec[] TypeParameters {
 			get {
 				// TODO
 				return CurrentTypeParameters.Select (l => l.Type).ToArray ();
 			}
 		}
 
 		public int TypeParametersCount {
 			get {
 				return CurrentTypeParameters == null ? 0 
 			}
 		}
 
 #endregion
 
 		public override string GetSignatureForError()
 		{
 			return base.GetSignatureForError () + parameters.GetSignatureForError ();
 		}
 
 		void Error_DuplicateEntryPoint (Method b)
 		{
 			Report.Error (17, b.Location,
 				"Program `{0}' has more than one entry point defined
 				b.Module.Builder.ScopeName, b.GetSignatureForError ());
 		}
 
 		bool IsEntryPoint ()
 		{
 			if (ReturnType != TypeManager.void_type &&
 				ReturnType != TypeManager.int32_type)
 				return false;
 
 			if (parameters.IsEmpty)
 				return true;
 
 			if (parameters.Count > 1)
 				return false;
 
 			var ac = parameters.Types [0] as ArrayContainer;
 			return ac != null && ac.Rank == 1 && ac.Element == TypeManager.string_type &&
 					(parameters[0].ModFlags & ~Parameter.Modifier.PARAMS) == Parameter.Modifier.NONE;
 		}
 
 		public override FullNamedExpression LookupNamespaceOrType (string name, int arity, Location loc, bool ignore_cs0104)
 		{
 			if (arity == 0) {
 				TypeParameter[] tp = CurrentTypeParameters;
 				if (tp != null) {
 					TypeParameter t = TypeParameter.FindTypeParameter (tp, name);
 					if (t != null)
 						return new TypeParameterExpr (t, loc);
 				}
 			}
 
 			return base.LookupNamespaceOrType (name, arity, loc, ignore_cs0104);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				if (IsExplicitImpl) {
 					Error_ConditionalAttributeIsNotValid ();
 					return;
 				}
 
 				if ((ModFlags & Modifiers.OVERRIDE) != 0) {
 					Report.Error (243, Location, "Conditional not valid on `{0}' because it is an override method", GetSignatureForError ());
 					return;
 				}
 
 				if (ReturnType != TypeManager.void_type) {
 					Report.Error (578, Location, "Conditional not valid on `{0}' because its return type is not void", GetSignatureForError ());
 					return;
 				}
 
 				if (IsInterface) {
 					Report.Error (582, Location, "Conditional not valid on interface members");
 					return;
 				}
 
 				if (MethodData.implementing != null) {
 					Report.SymbolRelatedToPreviousError (MethodData.implementing.DeclaringType);
 					Report.Error (629, Location, "Conditional member `{0}' cannot implement interface member `{1}'",
 						GetSignatureForError (), TypeManager.CSharpSignature (MethodData.implementing));
 					return;
 				}
 
 				for (int i = 0; i < parameters.Count; ++i) {
 					if (parameters.FixedParameters [i].ModFlags == Parameter.Modifier.OUT) {
 						Report.Error (685, Location, "Conditional method `{0}' cannot have an out parameter", GetSignatureForError ());
 						return;
 					}
 				}
 			}
 
 			if (a.Type == pa.Extension) {
 				a.Error_MisusedExtensionAttribute ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		protected virtual void DefineTypeParameters ()
 		{
 			var tparams = CurrentTypeParameters;
 
 			TypeParameterSpec[] base_tparams = null;
 			TypeParameterSpec[] base_decl_tparams = TypeParameterSpec.EmptyTypes;
 			TypeSpec[] base_targs = TypeSpec.EmptyTypes;
 			if (((ModFlags & Modifiers.OVERRIDE) != 0 || IsExplicitImpl)) {
 				if (base_method != null) {
 					base_tparams = base_method.GenericDefinition.TypeParameters;
 				
 					if (base_method.DeclaringType.IsGeneric) {
 						base_decl_tparams = base_method.DeclaringType.MemberDefinition.TypeParameters;
 
 						var base_type_parent = CurrentType;
 						while (base_type_parent.BaseType != base_method.DeclaringType) {
 							base_type_parent = base_type_parent.BaseType;
 						}
 
 						base_targs = base_type_parent.BaseType.TypeArguments;
 					}
 
 					if (base_method.IsGeneric) {
 						ObsoleteAttribute oa;
 						foreach (var base_tp in base_tparams) {
 							oa = base_tp.BaseType.GetAttributeObsolete ();
 							if (oa != null) {
 								AttributeTester.Report_ObsoleteMessage (oa, base_tp.BaseType.GetSignatureForError (), Location, Report);
 							}
 
 							if (base_tp.InterfacesDefined != null) {
 								foreach (var iface in base_tp.InterfacesDefined) {
 									oa = iface.GetAttributeObsolete ();
 									if (oa != null) {
 										AttributeTester.Report_ObsoleteMessage (oa, iface.GetSignatureForError (), Location, Report);
 									}
 								}
 							}
 						}
 
 						if (base_decl_tparams.Length != 0) {
 							base_decl_tparams = base_decl_tparams.Concat (base_tparams).ToArray ();
 							base_targs = base_targs.Concat (tparams.Select<TypeParameter, TypeSpec> (l => l.Type)).ToArray ();
 						} else {
 							base_decl_tparams = base_tparams;
 							base_targs = tparams.Select (l => l.Type).ToArray ();
 						}
 					}
 				} else if (MethodData.implementing != null) {
 					base_tparams = MethodData.implementing.GenericDefinition.TypeParameters;
 					if (MethodData.implementing.DeclaringType.IsGeneric) {
 						base_decl_tparams = MethodData.implementing.DeclaringType.MemberDefinition.TypeParameters;
 						foreach (var iface in Parent.CurrentType.Interfaces) {
 							if (iface == MethodData.implementing.DeclaringType) {
 								base_targs = iface.TypeArguments;
 								break;
 							}
 						}
 					}
 				}
 			}
 
 			for (int i = 0; i < tparams.Length; ++i) {
 				var tp = tparams[i];
 
 				if (!tp.ResolveConstraints (this))
 					continue;
 
 				//
 				// Copy base constraints for override/explicit methods
 				//
 				if (base_tparams != null) {
 					var base_tparam = base_tparams[i];
 					var local_tparam = tp.Type;
 					local_tparam.SpecialConstraint = base_tparam.SpecialConstraint;
 
 					var inflator = new TypeParameterInflator (CurrentType, base_decl_tparams, base_targs);
 					base_tparam.InflateConstraints (inflator, local_tparam);
 
 					//
 					// Check all type argument constraints for possible collision
 					// introduced by inflating inherited constraints in this context
 					//
 					// Conflict example
 					//
 					// class A<T> { virtual void Foo<U> () where U 
 					// class B 
 					//
 					var local_tparam_targs = local_tparam.TypeArguments;
 					if (local_tparam_targs != null) {					
 						for (int ii = 0; ii < local_tparam_targs.Length; ++ii) {
 							var ta = local_tparam_targs [ii];
 							if (!ta.IsClass && !ta.IsStruct)
 								continue;
 
 							if (Constraints.CheckConflictingInheritedConstraint (local_tparam, ta, this, Location)) {
 								local_tparam.ChangeTypeArgumentToBaseType (ii);
 							}
 						}
 					}
 
 					continue;
 				}
 				
 				if (MethodData.implementing != null) {
 					var base_tp = MethodData.implementing.Constraints[i];
 					if (!tp.Type.HasSameConstraintsImplementation (base_tp)) {
 						Report.SymbolRelatedToPreviousError (MethodData.implementing);
 						Report.Error (425, Location,
 							"The constraints for type parameter `{0}' of method `{1}' must match the constraints for type parameter `{2}' of interface method `{3}'. Consider using an explicit interface implementation instead",
 							tp.GetSignatureForError (), GetSignatureForError (), base_tp.GetSignatureForError (), MethodData.implementing.GetSignatureForError ());
 					}
 				}
 			}
 		}
 
 		//
 		// Creates the type
 		//
 		public override bool Define ()
 		{
 			if (type_expr.Type == TypeManager.void_type && parameters.IsEmpty && MemberName.Arity == 0 && MemberName.Name == Destructor.MetadataName) {
 				Report.Warning (465, 1, Location, "Introducing `Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?");
 			}
 
 			if (!base.Define ())
 				return false;
 
 			if (partialMethodImplementation != null && IsPartialDefinition)
 				MethodBuilder = partialMethodImplementation.MethodBuilder;
 
 			if (RootContext.StdLib && TypeManager.IsSpecialType (ReturnType)) {
 				Error1599 (Location, ReturnType, Report);
 				return false;
 			}
 
 			if (CurrentTypeParameters == null) {
 				if (base_method != null) {
 					if (parameters.Count == 1 && ParameterTypes[0] == TypeManager.object_type && Name == "Equals")
 						Parent.PartialContainer.Mark_HasEquals ();
 					else if (parameters.IsEmpty && Name == "GetHashCode")
 						Parent.PartialContainer.Mark_HasGetHashCode ();
 				}
 					
 			} else {
 				DefineTypeParameters ();
 			}
 
 			if (block != null && block.IsIterator) {
 				//
 				// Current method is turned into automatically generated
 				// wrapper which creates an instance of iterator
 				//
 				Iterator.CreateIterator (this, Parent.PartialContainer, ModFlags, Compiler);
 				ModFlags |= Modifiers.DEBUGGER_HIDDEN;
 			}
 
 			if ((ModFlags & Modifiers.STATIC) == 0)
 				return true;
 
 			if (parameters.HasExtensionMethodType) {
 				if (Parent.PartialContainer.IsStatic && !Parent.IsGeneric) {
 					if (!Parent.IsTopLevel)
 						Report.Error (1109, Location, "`{0}'
 							GetSignatureForError ());
 
 					PredefinedAttribute pa = Module.PredefinedAttributes.Extension;
 					if (!pa.IsDefined) {
 						Report.Error (1110, Location,
 							"`{0}'
 							GetSignatureForError ());
 					}
 
 					ModFlags |= Modifiers.METHOD_EXTENSION;
 					Parent.PartialContainer.ModFlags |= Modifiers.METHOD_EXTENSION;
 					Spec.DeclaringType.SetExtensionMethodContainer ();
 					Parent.Module.HasExtensionMethod = true;
 				} else {
 					Report.Error (1106, Location, "`{0}'
 						GetSignatureForError ());
 				}
 			}
 
 			//
 			// This is used to track the Entry Point,
 			//
 			if (RootContext.NeedsEntryPoint &&
 				Name == "Main" &&
 				(RootContext.MainClass == null ||
 				RootContext.MainClass == Parent.TypeBuilder.FullName)){
 				if (IsEntryPoint ()) {
 
 					if (Parent.DeclaringAssembly.EntryPoint == null) {
 						if (Parent.IsGeneric || MemberName.IsGeneric) {
 							Report.Warning (402, 4, Location, "`{0}'
 								GetSignatureForError ());
 						} else {
 							SetIsUsed ();
 							Parent.DeclaringAssembly.EntryPoint = this;
 						}
 					} else {
 						Error_DuplicateEntryPoint (Parent.DeclaringAssembly.EntryPoint);
 						Error_DuplicateEntryPoint (this);
 					}
 				} else {
 					Report.Warning (28, 4, Location, "`{0}' has the wrong signature to be an entry point",
 						GetSignatureForError ());
 				}
 			}
 
 			return true;
 		}
 
 		//
 		// Emits the code
 		// 
 		public override void Emit ()
 		{
 			try {
 				if (IsPartialDefinition) {
 					//
 					// Use partial method implementation builder for partial method declaration attributes
 					//
 					if (partialMethodImplementation != null) {
 						MethodBuilder = partialMethodImplementation.MethodBuilder;
 					}
 
 					return;
 				}
 				
 				if ((ModFlags & Modifiers.PARTIAL) != 0 && (caching_flags & Flags.PartialDefinitionExists) == 0) {
 					Report.Error (759, Location, "A partial method `{0}' implementation is missing a partial method declaration",
 						GetSignatureForError ());
 				}
 
 				if (CurrentTypeParameters != null) {
 					var ge = type_expr as GenericTypeExpr;
 					if (ge != null)
 						ge.CheckConstraints (this);
 
 					foreach (Parameter p in parameters.FixedParameters) {
 						ge = p.TypeExpression as GenericTypeExpr;
 						if (ge != null)
 							ge.CheckConstraints (this);
 					}
 
 					for (int i = 0; i < CurrentTypeParameters.Length; ++i) {
 						var tp = CurrentTypeParameters [i];
 						tp.CheckGenericConstraints ();
 						tp.Emit ();
 					}
 				}
 
 				base.Emit ();
 				
 				if ((ModFlags & Modifiers.METHOD_EXTENSION) != 0)
 					Module.PredefinedAttributes.Extension.EmitAttribute (MethodBuilder);
 			} catch {
 				Console.WriteLine ("Internal compiler error at {0}
 						   Location, MethodBuilder);
 				throw;
 			}
 		}
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			// TODO
 			if (overload is Operator)
 				return overload.EnableOverloadChecks (this);
 
 			if (overload is Indexer)
 				return false;
 
 			return base.EnableOverloadChecks (overload);
 		}
 
 		public static void Error1599 (Location loc, TypeSpec t, Report Report)
 		{
 			Report.Error (1599, loc, "Method or delegate cannot return type `{0}'", TypeManager.CSharpName (t));
 		}
 
 		protected override bool ResolveMemberType ()
 		{
 			if (GenericMethod != null) {
 				MethodBuilder = Parent.TypeBuilder.DefineMethod (GetFullName (MemberName), flags);
 				if (!GenericMethod.Define (this))
 					return false;
 			}
 
 			return base.ResolveMemberType ();
 		}
 
 		public void SetPartialDefinition (Method methodDefinition)
 		{
 			caching_flags |= Flags.PartialDefinitionExists;
 			methodDefinition.partialMethodImplementation = this;
 
 			// Ensure we are always using method declaration parameters
 			for (int i = 0; i < methodDefinition.parameters.Count; ++i ) {
 				parameters [i].Name = methodDefinition.parameters [i].Name;
 				parameters [i].DefaultValue = methodDefinition.parameters [i].DefaultValue;
 			}
 
 			if (methodDefinition.attributes == null)
 				return;
 
 			if (attributes == null) {
 				attributes = methodDefinition.attributes;
 			} else {
 				attributes.Attrs.AddRange (methodDefinition.attributes.Attrs);
 			}
 		}
 	}
 
 	public abstract class ConstructorInitializer 
 	{
 		Arguments argument_list;
 		MethodSpec base_ctor;
 
 		public ConstructorInitializer (Arguments argument_list, Location loc)
 		{
 			this.argument_list = argument_list;
 			this.loc = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="44" endline="253">
<![CDATA[
 
 		bool is_double_colon;
 
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    Location loc)
 		{
 			this.Name = name;
 			this.Location = loc;
 			this.is_double_colon = is_double_colon;
 			this.Left = left;
 		}
 
 		private MemberName (MemberName left, string name, bool is_double_colon,
 				    TypeArguments args, Location loc)
 			
 		{
 			if (args != null && args.Count > 0)
 				this.TypeArguments = args;
 		}
 
 		public MemberName (string name)
 			
 		{ }
 
 		public MemberName (string name, Location loc)
 			
 		{ }
 
 		public MemberName (string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, string name)
 			
 		{ }
 
 		public MemberName (MemberName left, string name, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (string alias, string name, TypeArguments args, Location loc)
 			
 		{ }
 
 		public MemberName (MemberName left, MemberName right)
 			
 		{ }
 
 		public MemberName (MemberName left, MemberName right, Location loc)
 			
 		{
 			if (right.is_double_colon)
 				throw new InternalErrorException ("Cannot append double_colon member name");
 			this.Left = (right.Left == null) ? left 
 		}
 
 		// TODO
 		public string GetName ()
 		{
 			return GetName (false);
 		}
 
 		public int Arity {
 			get {
 				return TypeArguments == null ? 0 
 			}
 		}
 
 		public bool IsGeneric {
 			get {
 				if (TypeArguments != null)
 					return true;
 				else if (Left != null)
 					return Left.IsGeneric;
 				else
 					return false;
 			}
 		}
 
 		public string GetName (bool is_generic)
 		{
 			string name = is_generic ? Basename 
 			if (Left != null)
 				return Left.GetName (is_generic) + (is_double_colon ? "
 
 			return name;
 		}
 
 		public ATypeNameExpression GetTypeExpression ()
 		{
 			if (Left == null) {
 				if (TypeArguments != null)
 					return new SimpleName (Name, TypeArguments, Location);
 				
 				return new SimpleName (Name, Location);
 			}
 
 			if (is_double_colon) {
 				if (Left.Left != null)
 					throw new InternalErrorException ("The left side of a 
 				return new QualifiedAliasMember (Left.Name, Name, TypeArguments, Location);
 			}
 
 			Expression lexpr = Left.GetTypeExpression ();
 			return new MemberAccess (lexpr, Name, TypeArguments, Location);
 		}
 
 		public MemberName Clone ()
 		{
 			MemberName left_clone = Left == null ? null 
 			return new MemberName (left_clone, Name, is_double_colon, TypeArguments, Location);
 		}
 
 		public string Basename {
 			get {
 				if (TypeArguments != null)
 					return MakeName (Name, TypeArguments);
 				return Name;
 			}
 		}
 
 		public string GetSignatureForError ()
 		{
 			string append = TypeArguments == null ? "" 
 			if (Left == null)
 				return Name + append;
 			string connect = is_double_colon ? "
 			return Left.GetSignatureForError () + connect + Name + append;
 		}
 
 		public override bool Equals (object other)
 		{
 			return Equals (other as MemberName);
 		}
 
 		public bool Equals (MemberName other)
 		{
 			if (this == other)
 				return true;
 			if (other == null || Name != other.Name)
 				return false;
 			if (is_double_colon != other.is_double_colon)
 				return false;
 
 			if ((TypeArguments != null) &&
 			    (other.TypeArguments == null || TypeArguments.Count != other.TypeArguments.Count))
 				return false;
 
 			if ((TypeArguments == null) && (other.TypeArguments != null))
 				return false;
 
 			if (Left == null)
 				return other.Left == null;
 
 			return Left.Equals (other.Left);
 		}
 
 		public override int GetHashCode ()
 		{
 			int hash = Name.GetHashCode ();
 			for (MemberName n = Left; n != null; n = n.Left)
 				hash ^= n.Name.GetHashCode ();
 			if (is_double_colon)
 				hash ^= 0xbadc01d;
 
 			if (TypeArguments != null)
 				hash ^= TypeArguments.Count << 5;
 
 			return hash & 0x7FFFFFFF;
 		}
 
 		public int CountTypeArguments {
 			get {
 				if (TypeArguments != null)
 					return TypeArguments.Count;
 				else if (Left != null)
 					return Left.CountTypeArguments; 
 				else
 					return 0;
 			}
 		}
 
 		public static string MakeName (string name, TypeArguments args)
 		{
 			if (args == null)
 				return name;
 
 			return name + "`" + args.Count;
 		}
 
 		public static string MakeName (string name, int count)
 		{
 			return name + "`" + count;
 		}
 	}
 
 	public class SimpleMemberName
 	{
 		public string Value;
 		public Location Location;
 
 		public SimpleMemberName (string name, Location loc)
 		{
 			this.Value = name;
 			this.Location = loc;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="192" endline="695">
<![CDATA[
 	}
 
 	public interface IParameterData
 	{
 		Expression DefaultValue { get; }
 		bool HasExtensionMethodModifier { get; }
 		bool HasDefaultValue { get; }
 		Parameter.Modifier ModFlags { get; }
 		string Name { get; }
 	}
 
 	//
 	// Parameter information created by parser
 	//
 	public class Parameter 
 	{
 		[Flags]
 		public enum Modifier 
 			NONE    = 0,
 			REF     = REFMASK | ISBYREF,
 			OUT     = OUTMASK | ISBYREF,
 			PARAMS  = 4,
 			// This is a flag which says that it's either REF or OUT.
 			ISBYREF = 8,
 			REFMASK	= 32,
 			OUTMASK = 64,
 			This	= 128
 		}
 
 		static string[] attribute_targets = new string [] { "param" };
 
 		FullNamedExpression texpr;
 		readonly Modifier modFlags;
 		string name;
 		Expression default_expr;
 		protected TypeSpec parameter_type;
 		readonly Location loc;
 		protected int idx;
 		public bool HasAddressTaken;
 
 		TemporaryVariableReference expr_tree_variable;
 		static TypeExpr parameter_expr_tree_type;
 
 		HoistedVariable hoisted_variant;
 
 		public Parameter (FullNamedExpression type, string name, Modifier mod, Attributes attrs, Location loc)
 		{
 			this.name = name;
 			modFlags = mod;
 			this.loc = loc;
 			texpr = type;
 
 			// Only assign, attributes will be attached during resolve
 			base.attributes = attrs;
 		}
 
 		#region Properties
 
 		public DefaultParameterValueExpression DefaultValue {
 			get {
 				return default_expr as DefaultParameterValueExpression;
 			}
 			set {
 				default_expr = value;
 			}
 		}
 
 		Expression IParameterData.DefaultValue {
 			get {
 				var expr = default_expr as DefaultParameterValueExpression;
 				return expr == null ? default_expr 
 			}
 		}
 
 		bool HasOptionalExpression {
 			get {
 				return default_expr is DefaultParameterValueExpression;
 			}
 		}
 
 		public Location Location {
 			get {
 				return loc;
 			}
 		}
 
 		public TypeSpec Type {
 			get {
 				return parameter_type;
 			}
 		}
 
 		public FullNamedExpression TypeExpression  {
 			get {
 				return texpr;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.In && ModFlags == Modifier.OUT) {
 				a.Report.Error (36, a.Location, "An out parameter cannot have the `In' attribute");
 				return;
 			}
 
 			if (a.Type == pa.ParamArray) {
 				a.Report.Error (674, a.Location, "Do not use `System.ParamArrayAttribute'. Use the `params' keyword instead");
 				return;
 			}
 
 			if (a.Type == pa.Out && (ModFlags & Modifier.REF) == Modifier.REF &&
 			    !OptAttributes.Contains (pa.In)) {
 				a.Report.Error (662, a.Location,
 					"Cannot specify only `Out' attribute on a ref parameter. Use both `In' and `Out' attributes or neither");
 				return;
 			}
 
 			if (a.Type == pa.CLSCompliant) {
 				a.Report.Warning (3022, 1, a.Location, "CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead");
 			}
 
 			if (a.Type == pa.DefaultParameterValue || a.Type == pa.OptionalParameter) {
 				if (HasOptionalExpression) {
 					a.Report.Error (1745, a.Location,
 						"Cannot specify `{0}' attribute on optional parameter `{1}'",
 						TypeManager.CSharpName (a.Type).Replace ("Attribute", ""), Name);
 				}
 
 				if (a.Type == pa.DefaultParameterValue)
 					return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 		
 		public virtual bool CheckAccessibility (InterfaceMemberBase member)
 		{
 			if (parameter_type == null)
 				return true;
 
 			return member.IsAccessibleAs (parameter_type);
 		}
 
 		public static void Reset ()
 		{
 			parameter_expr_tree_type = null;
 		}
 
 		// <summary>
 		//   Resolve is used in method definitions
 		// </summary>
 		public virtual TypeSpec Resolve (IMemberContext rc, int index)
 		{
 			if (parameter_type != null)
 				return parameter_type;
 
 			if (attributes != null)
 				attributes.AttachTo (this, rc);
 
 			var expr = texpr.ResolveAsTypeTerminal (rc, false);
 			if (expr == null)
 				return null;
 
 			this.idx = index;
 			texpr = expr;
 			parameter_type = texpr.Type;
 	
 			if ((modFlags & Parameter.Modifier.ISBYREF) != 0 &&
 				TypeManager.IsSpecialType (parameter_type)) {
 				rc.Compiler.Report.Error (1601, Location, "Method or delegate parameter cannot be of type `{0}'",
 					GetSignatureForError ());
 				return null;
 			}
 
 			TypeManager.CheckTypeVariance (parameter_type,
 				(modFlags & Parameter.Modifier.ISBYREF) != 0 ? Variance.None 
 				rc);
 
 			if (parameter_type.IsStatic) {
 				rc.Compiler.Report.Error (721, Location, "`{0}'
 					texpr.GetSignatureForError ());
 				return parameter_type;
 			}
 
 			if ((modFlags & Modifier.This) != 0 && (parameter_type.IsPointer || parameter_type == InternalType.Dynamic)) {
 				rc.Compiler.Report.Error (1103, Location, "The extension method cannot be of type `{0}'",
 					TypeManager.CSharpName (parameter_type));
 			}
 
 			return parameter_type;
 		}
 
 		public void ResolveDefaultValue (ResolveContext rc)
 		{
 			//
 			// Default value was specified using an expression
 			//
 			if (default_expr != null) {
 				((DefaultParameterValueExpression)default_expr).Resolve (rc, this);
 				return;
 			}
 
 			if (attributes == null)
 				return;
 			
 			var opt_attr = attributes.Search (rc.Module.PredefinedAttributes.OptionalParameter);
 			var def_attr = attributes.Search (rc.Module.PredefinedAttributes.DefaultParameterValue);
 			if (def_attr != null) {
 				if (def_attr.Resolve () == null)
 					return;
 
 				var default_expr_attr = def_attr.GetParameterDefaultValue ();
 				if (default_expr_attr == null)
 					return;
 
 				var dpa_rc = def_attr.CreateResolveContext ();
 				default_expr = default_expr_attr.Resolve (dpa_rc);
 
 				if (default_expr is BoxedCast)
 					default_expr = ((BoxedCast) default_expr).Child;
 
 				Constant c = default_expr as Constant;
 				if (c == null) {
 					if (parameter_type == TypeManager.object_type) {
 						rc.Compiler.Report.Error (1910, default_expr.Location,
 							"Argument of type `{0}' is not applicable for the DefaultParameterValue attribute",
 							default_expr.Type.GetSignatureForError ());
 					} else {
 						rc.Compiler.Report.Error (1909, default_expr.Location,
 							"The DefaultParameterValue attribute is not applicable on parameters of type `{0}'",
 							default_expr.Type.GetSignatureForError ()); ;
 					}
 
 					default_expr = null;
 					return;
 				}
 
 				if (TypeSpecComparer.IsEqual (default_expr.Type, parameter_type) ||
 					(default_expr is NullConstant && TypeManager.IsReferenceType (parameter_type) && !parameter_type.IsGenericParameter) ||
 					TypeSpecComparer.IsEqual (parameter_type, TypeManager.object_type)) {
 					return;
 				}
 
 				//
 				// LAMESPEC
 				// User operators returning same type as parameter type are considered
 				// valid for this attribute only
 				//
 				// struct S { public static implicit operator S (int i) {} }
 				//
 				// void M ([DefaultParameterValue (3)]S s)
 				//
 				var expr = Convert.ImplicitUserConversion (dpa_rc, default_expr, parameter_type, loc);
 				if (expr != null && TypeSpecComparer.IsEqual (expr.Type, parameter_type)) {
 					return;
 				}
 				
 				rc.Compiler.Report.Error (1908, default_expr.Location, "The type of the default value should match the type of the parameter");
 				return;
 			}
 
 			if (opt_attr != null) {
 				default_expr = EmptyExpression.MissingValue;
 			}
 		}
 
 		public bool HasDefaultValue {
 			get { return default_expr != null; }
 		}
 
 		public bool HasExtensionMethodModifier {
 			get { return (modFlags & Modifier.This) != 0; }
 		}
 
 		//
 		// Hoisted parameter variant
 		//
 		public HoistedVariable HoistedVariant {
 			get {
 				return hoisted_variant;
 			}
 			set {
 				hoisted_variant = value;
 			}
 		}
 
 		public Modifier ModFlags {
 			get { return modFlags & ~Modifier.This; }
 		}
 
 		public string Name {
 			get { return name; }
 			set { name = value; }
 		}
 
 		public override AttributeTargets AttributeTargets {
 			get {
 				return AttributeTargets.Parameter;
 			}
 		}
 
 		public virtual string GetSignatureForError ()
 		{
 			string type_name;
 			if (parameter_type != null)
 				type_name = TypeManager.CSharpName (parameter_type);
 			else
 				type_name = texpr.GetSignatureForError ();
 
 			string mod = GetModifierSignature (modFlags);
 			if (mod.Length > 0)
 				return String.Concat (mod, " ", type_name);
 
 			return type_name;
 		}
 
 		public static string GetModifierSignature (Modifier mod)
 		{
 			switch (mod) {
 			case Modifier.OUT
 				return "out";
 			case Modifier.PARAMS
 				return "params";
 			case Modifier.REF
 				return "ref";
 			case Modifier.This
 				return "this";
 			default
 				return "";
 			}
 		}
 
 		public void IsClsCompliant (IMemberContext ctx)
 		{
 			if (parameter_type.IsCLSCompliant ())
 				return;
 
 			ctx.Compiler.Report.Warning (3001, 1, Location,
 				"Argument type `{0}' is not CLS-compliant", parameter_type.GetSignatureForError ());
 		}
 
 		public virtual void ApplyAttributes (MethodBuilder mb, ConstructorBuilder cb, int index, PredefinedAttributes pa)
 		{
 			if (builder != null)
 				throw new InternalErrorException ("builder already exists");
 
 			var pattrs = ParametersCompiled.GetParameterAttribute (modFlags);
 			if (HasOptionalExpression)
 				pattrs |= ParameterAttributes.Optional;
 
 			if (mb == null)
 				builder = cb.DefineParameter (index, pattrs, Name);
 			else
 				builder = mb.DefineParameter (index, pattrs, Name);
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (HasDefaultValue) {
 				//
 				// Emit constant values for true constants only, the other
 				// constant-like expressions will rely on default value expression
 				//
 				var def_value = DefaultValue;
 				Constant c = def_value != null ? def_value.Child as Constant 
 				if (c != null) {
 					if (default_expr.Type == TypeManager.decimal_type) {
 						pa.DecimalConstant.EmitAttribute (builder, (decimal) c.GetValue (), c.Location);
 					} else {
 						builder.SetConstant (c.GetValue ());
 					}
 				} else if (default_expr.Type.IsStruct) {
 					//
 					// Handles special case where default expression is used with value-type
 					//
 					// void Foo (S s = default (S)) {}
 					//
 					builder.SetConstant (null);
 				}
 			}
 
 			if (parameter_type != null) {
 				if (parameter_type == InternalType.Dynamic) {
 					pa.Dynamic.EmitAttribute (builder);
 				} else if (parameter_type.HasDynamicElement) {
 					pa.Dynamic.EmitAttribute (builder, parameter_type, Location);
 				}
 			}
 		}
 
 		public Parameter Clone ()
 		{
 			Parameter p = (Parameter) MemberwiseClone ();
 			if (attributes != null)
 				p.attributes = attributes.Clone ();
 
 			return p;
 		}
 
 		public ExpressionStatement CreateExpressionTreeVariable (BlockContext ec)
 		{
 			if ((modFlags & Modifier.ISBYREF) != 0)
 				ec.Report.Error (1951, Location, "An expression tree parameter cannot use `ref' or `out' modifier");
 
 			expr_tree_variable = TemporaryVariableReference.Create (ResolveParameterExpressionType (ec, Location).Type, ec.CurrentBlock.ParametersBlock, Location);
 			expr_tree_variable = (TemporaryVariableReference) expr_tree_variable.Resolve (ec);
 
 			Arguments arguments = new Arguments (2);
 			arguments.Add (new Argument (new TypeOf (
 				new TypeExpression (parameter_type, Location), Location)));
 			arguments.Add (new Argument (new StringConstant (Name, Location)));
 			return new SimpleAssign (ExpressionTreeVariableReference (),
 				Expression.CreateExpressionFactoryCall (ec, "Parameter", null, arguments, Location));
 		}
 
 		public void Emit (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			ParameterReference.EmitLdArg (ec, arg_idx);
 		}
 
 		public void EmitAssign (EmitContext ec)
 		{
 			int arg_idx = idx;
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			if (arg_idx <= 255)
 				ec.Emit (OpCodes.Starg_S, (byte) arg_idx);
 			else
 				ec.Emit (OpCodes.Starg, arg_idx);
 		}
 
 		public void EmitAddressOf (EmitContext ec)
 		{
 			int arg_idx = idx;
 
 			if (!ec.IsStatic)
 				arg_idx++;
 
 			bool is_ref = (ModFlags & Modifier.ISBYREF) != 0;
 			if (is_ref) {
 				ParameterReference.EmitLdArg (ec, arg_idx);
 			} else {
 				if (arg_idx <= 255)
 					ec.Emit (OpCodes.Ldarga_S, (byte) arg_idx);
 				else
 					ec.Emit (OpCodes.Ldarga, arg_idx);
 			}
 		}
 
 		public TemporaryVariableReference ExpressionTreeVariableReference ()
 		{
 			return expr_tree_variable;
 		}
 
 		//
 		// System.Linq.Expressions.ParameterExpression type
 		//
 		public static TypeExpr ResolveParameterExpressionType (IMemberContext ec, Location location)
 		{
 			if (parameter_expr_tree_type != null)
 				return parameter_expr_tree_type;
 
 			TypeSpec p_type = ec.Module.PredefinedTypes.ParameterExpression.Resolve (location);
 			parameter_expr_tree_type = new TypeExpression (p_type, location).
 				ResolveAsTypeTerminal (ec, false);
 
 			return parameter_expr_tree_type;
 		}
 
 		public void Warning_UselessOptionalParameter (Report Report)
 		{
 			Report.Warning (1066, 1, Location,
 				"The default value specified for optional parameter `{0}' will never be used",
 				Name);
 		}
 	}
 
 	//
 	// Imported or resolved parameter information
 	//
 	public class ParameterData 
 	{
 		readonly string name;
 		readonly Parameter.Modifier modifiers;
 		readonly Expression default_value;
 
 		public ParameterData (string name, Parameter.Modifier modifiers)
 		{
 			this.name = name;
 			this.modifiers = modifiers;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Reader\GenericTypeParameter.cs" startline="100" endline="291">
<![CDATA[
 		private readonly int position;
 
 		private sealed class DummyModule 
 		{
 			internal DummyModule()
 				
 			{
 			}
 
 			public override bool Equals(object obj)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override int GetHashCode()
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ToString()
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override int MDStreamVersion
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Assembly Assembly
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			internal override Type GetTypeImpl(string typeName)
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override void GetTypesImpl(List<Type> list)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string FullyQualifiedName
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override string Name
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Guid ModuleVersionId
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ResolveString(int metadataToken)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override Type[] __ResolveOptionalParameterTypes(int metadataToken)
 			{
 				throw new InvalidOperationException();
 			}
 
 			public override string ScopeName
 			{
 				get { throw new InvalidOperationException(); }
 			}
 
 			public override AssemblyName[] __GetReferencedAssemblies()
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override Type GetModuleType()
 			{
 				throw new InvalidOperationException();
 			}
 
 			internal override ByteReader GetBlob(int blobIndex)
 			{
 				throw new InvalidOperationException();
 			}
 		}
 
 		internal static Type Make(int position)
 		{
 			return module.CanonicalizeType(new UnboundGenericMethodParameter(position));
 		}
 
 		private UnboundGenericMethodParameter(int position)
 		{
 			this.position = position;
 		}
 
 		public override bool Equals(object obj)
 		{
 			UnboundGenericMethodParameter other = obj as UnboundGenericMethodParameter;
 			return other != null && other.position == position;
 		}
 
 		public override int GetHashCode()
 		{
 			return position;
 		}
 
 		public override string Namespace
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override string Name
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override int MetadataToken
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override Module Module
 		{
 			get { return module; }
 		}
 
 		public override int GenericParameterPosition
 		{
 			get { return position; }
 		}
 
 		public override Type DeclaringType
 		{
 			get { return null; }
 		}
 
 		public override MethodBase DeclaringMethod
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		public override Type[] GetGenericParameterConstraints()
 		{
 			throw new InvalidOperationException();
 		}
 
 		public override GenericParameterAttributes GenericParameterAttributes
 		{
 			get { throw new InvalidOperationException(); }
 		}
 
 		internal override Type BindTypeParameters(IGenericBinder binder)
 		{
 			return binder.BindMethodParameter(this);
 		}
 	}
 
 	sealed class GenericTypeParameter 
 	{
 		private readonly ModuleReader module;
 		private readonly int index;
 
 		internal GenericTypeParameter(ModuleReader module, int index)
 		{
 			this.module = module;
 			this.index = index;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="1033" endline="1069">
<![CDATA[
 		}
 
 		[Flags]
 		public enum Flags
 		{
 			LocalNamesAmbiguous	= 1
 		}
 
 		public const int Size = 12;
 
 		internal MethodEntry (MonoSymbolFile file, MyBinaryReader reader, int index)
 		{
 			this.SymbolFile = file;
 			this.index = index;
 
 			Token = reader.ReadInt32 ();
 			DataOffset = reader.ReadInt32 ();
 			LineNumberTableOffset = reader.ReadInt32 ();
 
 			long old_pos = reader.BaseStream.Position;
 			reader.BaseStream.Position = DataOffset;
 
 			CompileUnitIndex = reader.ReadLeb128 ();
 			LocalVariableTableOffset = reader.ReadLeb128 ();
 			NamespaceID = reader.ReadLeb128 ();
 
 			CodeBlockTableOffset = reader.ReadLeb128 ();
 			ScopeVariableTableOffset = reader.ReadLeb128 ();
 
 			RealNameOffset = reader.ReadLeb128 ();
 
 			flags = (Flags) reader.ReadLeb128 ();
 
 			reader.BaseStream.Position = old_pos;
 
 			CompileUnit = file.GetCompileUnit (CompileUnitIndex);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="36" endline="53">
<![CDATA[
 		private readonly List<Type> args = new List<Type>();
 		private readonly List<LocalBuilder> locals = new List<LocalBuilder>();
 		private readonly List<Type[]> requiredCustomModifiers = new List<Type[]>();
 		private readonly List<Type[]> optionalCustomModifiers = new List<Type[]>();
 		private readonly List<Type> optionalArgs = new List<Type>();
 		private Type returnType;
 		private Type[] returnTypeRequiredCustomModifiers;
 		private Type[] returnTypeOptionalCustomModifiers;
 		private CallingConventions callingConvention;
 		private CallingConvention unmanagedCallConv;
 		private bool unmanaged;
 		private bool optional;
 
 		private SignatureHelper(ModuleBuilder module, byte type)
 		{
 			this.module = module;
 			this.type = type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\CliHeader.cs" startline="53" endline="70">
<![CDATA[
 		{
 			Cb = br.ReadUInt32();
 			MajorRuntimeVersion = br.ReadUInt16();
 			MinorRuntimeVersion = br.ReadUInt16();
 			MetaDataRVA = br.ReadUInt32();
 			MetaDataSize = br.ReadUInt32();
 			Flags = br.ReadUInt32();
 			EntryPointToken = br.ReadUInt32();
 			ResourcesRVA = br.ReadUInt32();
 			ResourcesSize = br.ReadUInt32();
 			StrongNameSignatureRVA = br.ReadUInt32();
 			StrongNameSignatureSize = br.ReadUInt32();
 			CodeManagerTable = br.ReadUInt32();
 			VTableFixupsRVA = br.ReadUInt32();
 			VTableFixupsSize = br.ReadUInt32();
 			ExportAddressTableJumps = br.ReadUInt32();
 			ManagedNativeHeader = br.ReadUInt32();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7524" endline="7530">
<![CDATA[
 
 		protected override void Error_IdentifierNotFound (IMemberContext rc, TypeSpec expr_type, string identifier)
 		{
 			rc.Compiler.Report.Error (687, loc,
 				"A namespace alias qualifier `{0}' did not resolve to a namespace or a type",
 				GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\corlib\Mono.Security.Cryptography\CryptoConvert.cs" startline="661" endline="676">
<![CDATA[
 
 		static public DSA FromCapiKeyBlobDSA (byte[] blob, int offset)
 		{
 			if (blob == null)
 				throw new ArgumentNullException ("blob");
 			if (offset >= blob.Length)
 				throw new ArgumentException ("blob is too small.");
 
 			switch (blob [offset]) {
 				case 0x06
 					return FromCapiPublicKeyBlobDSA (blob, offset);
 				case 0x07
 					return FromCapiPrivateKeyBlobDSA (blob, offset);
 			}
 			throw new CryptographicException ("Unknown blob format.");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="303" endline="334">
<![CDATA[
 
 		//
 		// Given a path specification, splits the path from the file/pattern
 		//
 		static void SplitPathAndPattern (string spec, out string path, out string pattern)
 		{
 			int p = spec.LastIndexOf ('/');
 			if (p != -1){
 				//
 				// Windows does not like /file.cs, switch that to
 				// "\", "file.cs"
 				//
 				if (p == 0){
 					path = "\\";
 					pattern = spec.Substring (1);
 				} else {
 					path = spec.Substring (0, p);
 					pattern = spec.Substring (p + 1);
 				}
 				return;
 			}
 
 			p = spec.LastIndexOf ('\\');
 			if (p != -1){
 				path = spec.Substring (0, p);
 				pattern = spec.Substring (p + 1);
 				return;
 			}
 
 			path = ".";
 			pattern = spec;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="2458" endline="2534">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Represents a namespace or a type.  The name of the class was inspired by
 	///   section 10.8.1 (Fully Qualified Names).
 	/// </summary>
 	public abstract class FullNamedExpression 
 	{
 		protected override void CloneTo (CloneContext clonectx, Expression target)
 		{
 			// Do nothing, most unresolved type expressions cannot be
 			// resolved to different type
 		}
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			throw new NotSupportedException ("ET");
 		}
 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			return this;
 		}
 
 		public override void Emit (EmitContext ec)
 		{
 			throw new InternalErrorException ("FullNamedExpression `{0}' found in resolved tree",
 				GetSignatureForError ());
 		}
 	}
 	
 	/// <summary>
 	///   Expression that evaluates to a type
 	/// </summary>
 	public abstract class TypeExpr 
 		public override FullNamedExpression ResolveAsTypeStep (IMemberContext ec, bool silent)
 		{
 			TypeExpr t = DoResolveAsTypeStep (ec);
 			if (t == null)
 				return null;
 
 			eclass = ExprClass.Type;
 			return t;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			return ResolveAsTypeTerminal (ec, false);
 		}
 
 		protected abstract TypeExpr DoResolveAsTypeStep (IMemberContext ec);
 
 		public override bool Equals (object obj)
 		{
 			TypeExpr tobj = obj as TypeExpr;
 			if (tobj == null)
 				return false;
 
 			return Type == tobj.Type;
 		}
 
 		public override int GetHashCode ()
 		{
 			return Type.GetHashCode ();
 		}
 	}
 
 	/// <summary>
 	///   Fully resolved Expression that already evaluated to a type
 	/// </summary>
 	public class TypeExpression 
 		public TypeExpression (TypeSpec t, Location l)
 		{
 			Type = t;
 			eclass = ExprClass.Type;
 			loc = l;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\complete.cs" startline="70" endline="79">
<![CDATA[
 		
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			var results = new List<string> ();
 
 			AppendResults (results, Prefix, Evaluator.GetVarNames ());
 			AppendResults (results, Prefix, ec.CurrentMemberDefinition.Parent.NamespaceEntry.CompletionGetTypesStartingWith (Prefix));
 			AppendResults (results, Prefix, Evaluator.GetUsingList ());
 			
 			throw new CompletionResult (Prefix, results.ToArray ());
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\TypeBuilder.cs" startline="158" endline="166">
<![CDATA[
 		}
 
 		private void AddConstraint(Type type)
 		{
 			GenericParamConstraintTable.Record rec = new GenericParamConstraintTable.Record();
 			rec.Owner = paramPseudoIndex;
 			rec.Constraint = this.ModuleBuilder.GetTypeTokenForMemberRef(type);
 			this.ModuleBuilder.GenericParamConstraint.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="248" endline="868">
<![CDATA[
 			new char [] {' ', '\t', '\n', '\r'};
 
 		//
 		// returns a full runtime type name from a name which might
 		// be C# specific type name.
 		//
 		private static TypeSpec FindDocumentedType (MemberCore mc, string name, DeclSpace ds, string cref, Report r)
 		{
 			bool is_array = false;
 			string identifier = name;
 			if (name [name.Length - 1] == ']') {
 				string tmp = name.Substring (0, name.Length - 1).Trim (wsChars);
 				if (tmp [tmp.Length - 1] == '[') {
 					identifier = tmp.Substring (0, tmp.Length - 1).Trim (wsChars);
 					is_array = true;
 				}
 			}
 			TypeSpec t = FindDocumentedTypeNonArray (mc, identifier, ds, cref, r);
 			if (t != null && is_array)
 				t = ArrayContainer.MakeType (t);
 			return t;
 		}
 
 		private static TypeSpec FindDocumentedTypeNonArray (MemberCore mc, 
 			string identifier, DeclSpace ds, string cref, Report r)
 		{
 			switch (identifier) {
 			case "int"
 				return TypeManager.int32_type;
 			case "uint"
 				return TypeManager.uint32_type;
 			case "short"
 				return TypeManager.short_type;;
 			case "ushort"
 				return TypeManager.ushort_type;
 			case "long"
 				return TypeManager.int64_type;
 			case "ulong"
 				return TypeManager.uint64_type;;
 			case "float"
 				return TypeManager.float_type;;
 			case "double"
 				return TypeManager.double_type;
 			case "char"
 				return TypeManager.char_type;;
 			case "decimal"
 				return TypeManager.decimal_type;;
 			case "byte"
 				return TypeManager.byte_type;;
 			case "sbyte"
 				return TypeManager.sbyte_type;;
 			case "object"
 				return TypeManager.object_type;;
 			case "bool"
 				return TypeManager.bool_type;;
 			case "string"
 				return TypeManager.string_type;;
 			case "void"
 				return TypeManager.void_type;;
 			}
 			FullNamedExpression e = ds.LookupNamespaceOrType (identifier, 0, mc.Location, false);
 			if (e != null) {
 				if (!(e is TypeExpr))
 					return null;
 				return e.Type;
 			}
 			int index = identifier.LastIndexOf ('.');
 			if (index < 0)
 				return null;
 
 			var nsName = identifier.Substring (0, index);
 			var typeName = identifier.Substring (index + 1);
 			Namespace ns = ds.NamespaceEntry.NS.GetNamespace (nsName, false);
 			ns = ns ?? mc.Module.GlobalRootNamespace.GetNamespace(nsName, false);
 			if (ns != null) {
 				var te = ns.LookupType(mc.Compiler, typeName, 0, true, mc.Location);
 				if(te != null)
 					return te.Type;
 			}
 
 			int warn;
 			TypeSpec parent = FindDocumentedType (mc, identifier.Substring (0, index), ds, cref, r);
 			if (parent == null)
 				return null;
 			// no need to detect warning 419 here
 			var ts = FindDocumentedMember (mc, parent,
 				identifier.Substring (index + 1),
 				null, ds, out warn, cref, false, null, r) as TypeSpec;
 			if (ts != null)
 				return ts;
 			return null;
 		}
 
 		//
 		// Returns a MemberInfo that is referenced in XML documentation
 		// (by "see" or "seealso" elements).
 		//
 		private static MemberSpec FindDocumentedMember (MemberCore mc,
 			TypeSpec type, string member_name, AParametersCollection param_list, 
 			DeclSpace ds, out int warning_type, string cref,
 			bool warn419, string name_for_error, Report r)
 		{
 //			for (; type != null; type = type.DeclaringType) {
 				var mi = FindDocumentedMemberNoNest (
 					mc, type, member_name, param_list, ds,
 					out warning_type, cref, warn419,
 					name_for_error, r);
 				if (mi != null)
 					return mi; // new FoundMember (type, mi);
 //			}
 			warning_type = 0;
 			return null;
 		}
 
 		private static MemberSpec FindDocumentedMemberNoNest (
 			MemberCore mc, TypeSpec type, string member_name,
 			AParametersCollection param_list, DeclSpace ds, out int warning_type, 
 			string cref, bool warn419, string name_for_error, Report Report)
 		{
 			warning_type = 0;
 //			var filter = new MemberFilter (member_name, 0, MemberKind.All, param_list, null);
 			IList<MemberSpec> found = null;
 			while (type != null && found == null) {
 				found = MemberCache.FindMembers (type, member_name, false);
 				type = type.DeclaringType;
 			}
 
 			if (found == null)
 				return null;
 
 			if (warn419 && found.Count > 1) {
 				Report419 (mc, name_for_error, found.ToArray (), Report);
 			}
 
 			return found [0];
 
 /*
 			if (param_list == null) {
 				// search for fields/events etc.
 				mis = TypeManager.MemberLookup (type, null,
 					type, MemberKind.All,
 					BindingRestriction.None,
 					member_name, null);
 				mis = FilterOverridenMembersOut (mis);
 				if (mis == null || mis.Length == 0)
 					return null;
 				if (warn419 && IsAmbiguous (mis))
 					Report419 (mc, name_for_error, mis, Report);
 				return mis [0];
 			}
 
 			MethodSignature msig = new MethodSignature (member_name, null, param_list);
 			mis = FindMethodBase (type, 
 				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
 				msig);
 
 			if (warn419 && mis.Length > 0) {
 				if (IsAmbiguous (mis))
 					Report419 (mc, name_for_error, mis, Report);
 				return mis [0];
 			}
 
 			// search for operators (whose parameters exactly
 			// matches with the list) and possibly report CS1581.
 			string oper = null;
 			string return_type_name = null;
 			if (member_name.StartsWith ("implicit operator ")) {
 				Operator.GetMetadataName (Operator.OpType.Implicit);
 				return_type_name = member_name.Substring (18).Trim (wsChars);
 			}
 			else if (member_name.StartsWith ("explicit operator ")) {
 				oper = Operator.GetMetadataName (Operator.OpType.Explicit);
 				return_type_name = member_name.Substring (18).Trim (wsChars);
 			}
 			else if (member_name.StartsWith ("operator ")) {
 				oper = member_name.Substring (9).Trim (wsChars);
 				switch (oper) {
 				// either unary or binary
 				case "+"
 					oper = param_list.Length == 2 ?
 						Operator.GetMetadataName (Operator.OpType.Addition) 
 						Operator.GetMetadataName (Operator.OpType.UnaryPlus);
 					break;
 				case "-"
 					oper = param_list.Length == 2 ?
 						Operator.GetMetadataName (Operator.OpType.Subtraction) 
 						Operator.GetMetadataName (Operator.OpType.UnaryNegation);
 					break;
 				default
 					oper = Operator.GetMetadataName (oper);
 					if (oper != null)
 						break;
 
 					warning_type = 1584;
 					Report.Warning (1020, 1, mc.Location, "Overloadable {0} operator is expected", param_list.Length == 2 ? "binary" 
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					return null;
 				}
 			}
 			// here we still don't consider return type (to
 			// detect CS1581 or CS1002+CS1584).
 			msig = new MethodSignature (oper, null, param_list);
 
 			mis = FindMethodBase (type, 
 				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
 				msig);
 			if (mis.Length == 0)
 				return null; // CS1574
 			var mi = mis [0];
 			TypeSpec expected = mi is MethodSpec ?
 				((MethodSpec) mi).ReturnType 
 				mi is PropertySpec ?
 				((PropertySpec) mi).PropertyType 
 				null;
 			if (return_type_name != null) {
 				TypeSpec returnType = FindDocumentedType (mc, return_type_name, ds, cref, Report);
 				if (returnType == null || returnType != expected) {
 					warning_type = 1581;
 					Report.Warning (1581, 1, mc.Location, "Invalid return type in XML comment cref attribute `{0}'", cref);
 					return null;
 				}
 			}
 			return mis [0];
 */ 
 		}
 
 		//
 		// Processes "see" or "seealso" elements.
 		// Checks cref attribute.
 		//
 		private static void HandleXrefCommon (MemberCore mc,
 			DeclSpace ds, XmlElement xref, Report Report)
 		{
 			string cref = xref.GetAttribute ("cref").Trim (wsChars);
 			// when, XmlReader, "if (cref == null)"
 			if (!xref.HasAttribute ("cref"))
 				return;
 			if (cref.Length == 0)
 				Report.Warning (1001, 1, mc.Location, "Identifier expected");
 				// ... and continue until CS1584.
 
 			string signature; // "x
 			string name; // method invokation "(...)" are removed
 			string parameters; // method parameter list
 
 			// When it found '?
 			// MS ignores not only its member kind, but also
 			// the entire syntax correctness. Nor it also does
 			// type fullname resolution i.e. "T
 			// as T
 			// T
 			if (cref.Length > 2 && cref [1] == '
 				return;
 			else
 				signature = cref;
 
 			// Also note that without "T
 			// indication fails.
 
 			int parens_pos = signature.IndexOf ('(');
 			int brace_pos = parens_pos >= 0 ? -1 
 				signature.IndexOf ('[');
 			if (parens_pos > 0 && signature [signature.Length - 1] == ')') {
 				name = signature.Substring (0, parens_pos).Trim (wsChars);
 				parameters = signature.Substring (parens_pos + 1, signature.Length - parens_pos - 2).Trim (wsChars);
 			}
 			else if (brace_pos > 0 && signature [signature.Length - 1] == ']') {
 				name = signature.Substring (0, brace_pos).Trim (wsChars);
 				parameters = signature.Substring (brace_pos + 1, signature.Length - brace_pos - 2).Trim (wsChars);
 			}
 			else {
 				name = signature;
 				parameters = null;
 			}
 			Normalize (mc, ref name, Report);
 
 			string identifier = GetBodyIdentifierFromName (name);
 
 			// Check if identifier is valid.
 			// This check is not necessary to mark as error, but
 			// csc specially reports CS1584 for wrong identifiers.
 			string [] name_elems = identifier.Split ('.');
 			for (int i = 0; i < name_elems.Length; i++) {
 				string nameElem = GetBodyIdentifierFromName (name_elems [i]);
 				if (i > 0)
 					Normalize (mc, ref nameElem, Report);
 				if (!Tokenizer.IsValidIdentifier (nameElem)
 					&& nameElem.IndexOf ("operator") < 0) {
 					Report.Warning (1584, 1, mc.Location, "XML comment on `{0}' has syntactically incorrect cref attribute `{1}'",
 						mc.GetSignatureForError (), cref);
 					xref.SetAttribute ("cref", "!
 					return;
 				}
 			}
 
 			// check if parameters are valid
 			AParametersCollection parameter_types;
 			if (parameters == null)
 				parameter_types = null;
 			else if (parameters.Length == 0)
 				parameter_types = ParametersCompiled.EmptyReadOnlyParameters;
 			else {
 				string [] param_list = parameters.Split (',');
 				var plist = new List<TypeSpec> ();
 				for (int i = 0; i < param_list.Length; i++) {
 					string param_type_name = param_list [i].Trim (wsChars);
 					Normalize (mc, ref param_type_name, Report);
 					TypeSpec param_type = FindDocumentedType (mc, param_type_name, ds, cref, Report);
 					if (param_type == null) {
 						Report.Warning (1580, 1, mc.Location, "Invalid type for parameter `{0}' in XML comment cref attribute `{1}'",
 							(i + 1).ToString (), cref);
 						return;
 					}
 					plist.Add (param_type);
 				}
 
 				parameter_types = ParametersCompiled.CreateFullyResolved (plist.ToArray ());
 			}
 
 			TypeSpec type = FindDocumentedType (mc, name, ds, cref, Report);
 			if (type != null
 				// delegate must not be referenced with args
 				&& (!type.IsDelegate
 				|| parameter_types == null)) {
 				string result = GetSignatureForDoc (type)
 					+ (brace_pos < 0 ? String.Empty 
 				xref.SetAttribute ("cref", "T
 				return; // a type
 			}
 
 			int period = name.LastIndexOf ('.');
 			if (period > 0) {
 				string typeName = name.Substring (0, period);
 				string member_name = name.Substring (period + 1);
 				string lookup_name = member_name == "this" ? MemberCache.IndexerNameAlias 
 				Normalize (mc, ref lookup_name, Report);
 				Normalize (mc, ref member_name, Report);
 				type = FindDocumentedType (mc, typeName, ds, cref, Report);
 				int warn_result;
 				if (type != null) {
 					var mi = FindDocumentedMember (mc, type, lookup_name, parameter_types, ds, out warn_result, cref, true, name, Report);
 					if (warn_result > 0)
 						return;
 					if (mi != null) {
 						// we cannot use 'type' directly
 						// to get its name, since mi
 						// could be from DeclaringType
 						// for nested types.
 						xref.SetAttribute ("cref", GetMemberDocHead (mi) + GetSignatureForDoc (mi.DeclaringType) + "." + member_name + GetParametersFormatted (mi));
 						return; // a member of a type
 					}
 				}
 			} else {
 				int warn_result;
 				var mi = FindDocumentedMember (mc, ds.PartialContainer.Definition, name, parameter_types, ds, out warn_result, cref, true, name, Report);
 
 				if (warn_result > 0)
 					return;
 				if (mi != null) {
 					// we cannot use 'type' directly
 					// to get its name, since mi
 					// could be from DeclaringType
 					// for nested types.
 					xref.SetAttribute ("cref", GetMemberDocHead (mi) + GetSignatureForDoc (mi.DeclaringType) + "." + name + GetParametersFormatted (mi));
 					return; // local member name
 				}
 			}
 
 			// It still might be part of namespace name.
 			Namespace ns = ds.NamespaceEntry.NS.GetNamespace (name, false);
 			if (ns != null) {
 				xref.SetAttribute ("cref", "N
 				return; // a namespace
 			}
 			if (mc.Module.GlobalRootNamespace.IsNamespace (name)) {
 				xref.SetAttribute ("cref", "N
 				return; // a namespace
 			}
 
 			Report.Warning (1574, 1, mc.Location, "XML comment on `{0}' has cref attribute `{1}' that could not be resolved",
 				mc.GetSignatureForError (), cref);
 
 			xref.SetAttribute ("cref", "!
 		}
 
 		static string GetParametersFormatted (MemberSpec mi)
 		{
 			var pm = mi as IParametersMember;
 			if (pm == null || pm.Parameters.IsEmpty)
 				return string.Empty;
 
 			AParametersCollection parameters = pm.Parameters;
 /*
 			if (parameters == null || parameters.Count == 0)
 				return String.Empty;
 */
 			StringBuilder sb = new StringBuilder ();
 			sb.Append ('(');
 			for (int i = 0; i < parameters.Count; i++) {
 //				if (is_setter && i + 1 == parameters.Count)
 //					break; // skip "value".
 				if (i > 0)
 					sb.Append (',');
 				TypeSpec t = parameters.Types [i];
 				sb.Append (GetSignatureForDoc (t));
 			}
 			sb.Append (')');
 			return sb.ToString ();
 		}
 
 		static string GetBodyIdentifierFromName (string name)
 		{
 			string identifier = name;
 
 			if (name.Length > 0 && name [name.Length - 1] == ']') {
 				string tmp = name.Substring (0, name.Length - 1).Trim (wsChars);
 				int last = tmp.LastIndexOf ('[');
 				if (last > 0)
 					identifier = tmp.Substring (0, last).Trim (wsChars);
 			}
 
 			return identifier;
 		}
 
 		static void Report419 (MemberCore mc, string member_name, MemberSpec [] mis, Report Report)
 		{
 			Report.Warning (419, 3, mc.Location, 
 				"Ambiguous reference in cref attribute `{0}'. Assuming `{1}' but other overloads including `{2}' have also matched",
 				member_name,
 				TypeManager.GetFullNameSignature (mis [0]),
 				TypeManager.GetFullNameSignature (mis [1]));
 		}
 
 		//
 		// Get a prefix from member type for XML documentation (used
 		// to formalize cref target name).
 		//
 		static string GetMemberDocHead (MemberSpec type)
 		{
 			if (type is FieldSpec)
 				return "F
 			if (type is MethodSpec)
 				return "M
 			if (type is EventSpec)
 				return "E
 			if (type is PropertySpec)
 				return "P
 			if (type is TypeSpec)
 				return "T
 
 			return "!
 		}
 
 		// MethodCore
 
 		//
 		// Returns a string that represents the signature for this 
 		// member which should be used in XML documentation.
 		//
 		public static string GetMethodDocCommentName (MemberCore mc, ParametersCompiled parameters, DeclSpace ds)
 		{
 			IParameterData [] plist = parameters.FixedParameters;
 			string paramSpec = String.Empty;
 			if (plist != null) {
 				StringBuilder psb = new StringBuilder ();
 				int i = 0;
 				foreach (Parameter p in plist) {
 					psb.Append (psb.Length != 0 ? "," 
 					psb.Append (GetSignatureForDoc (parameters.Types [i++]));
 					if ((p.ModFlags & Parameter.Modifier.ISBYREF) != 0)
 						psb.Append ('@');
 				}
 				paramSpec = psb.ToString ();
 			}
 
 			if (paramSpec.Length > 0)
 				paramSpec += ")";
 
 			string name = mc.Name;
 			if (mc is Constructor)
 				name = "#ctor";
 			else if (mc is InterfaceMemberBase) {
 				var imb = (InterfaceMemberBase) mc;
 				name = imb.GetFullName (imb.ShortName);
 			}
 			name = name.Replace ('.', '#');
 
 			if (mc.MemberName.TypeArguments != null && mc.MemberName.TypeArguments.Count > 0)
 				name += "``" + mc.MemberName.CountTypeArguments;
 
 			string suffix = String.Empty;
 			Operator op = mc as Operator;
 			if (op != null) {
 				switch (op.OperatorType) {
 				case Operator.OpType.Implicit
 				case Operator.OpType.Explicit
 					suffix = "~" + GetSignatureForDoc (op.ReturnType);
 					break;
 				}
 			}
 			return String.Concat (mc.DocCommentHeader, ds.Name, ".", name, paramSpec, suffix);
 		}
 
 		static string GetSignatureForDoc (TypeSpec type)
 		{
 			var tp = type as TypeParameterSpec;
 			if (tp != null) {
 				int c = 0;
 				type = type.DeclaringType;
 				while (type != null && type.DeclaringType != null) {
 					type = type.DeclaringType;
 					c += type.MemberDefinition.TypeParametersCount;
 				}
 				var prefix = tp.IsMethodOwned ? "``" 
 				return prefix + (c + tp.DeclaredPosition);
 			}
 
 			var pp = type as PointerContainer;
 			if (pp != null)
 				return GetSignatureForDoc (pp.Element) + "*";
 
 			ArrayContainer ap = type as ArrayContainer;
 			if (ap != null)
 				return GetSignatureForDoc (ap.Element) +
 					ArrayContainer.GetPostfixSignature (ap.Rank);
 
 			if (TypeManager.IsGenericType (type)) {
 				string g = type.MemberDefinition.Namespace;
 				if (g != null && g.Length > 0)
 					g += '.';
 				int idx = type.Name.LastIndexOf ('`');
 				g += (idx < 0 ? type.Name 
 				int argpos = 0;
 				foreach (TypeSpec t in TypeManager.GetTypeArguments (type))
 					g += (argpos++ > 0 ? "," 
 				g += '}';
 				return g;
 			}
 
 			string name = type.GetMetaInfo ().FullName != null ? type.GetMetaInfo ().FullName 
 			return name.Replace ("+", ".").Replace ('&', '@');
 		}
 
 		//
 		// Raised (and passed an XmlElement that contains the comment)
 		// when GenerateDocComment is writing documentation expectedly.
 		//
 		// FIXME
 		// that means removal of DOM use.
 		//
 		internal static void OnMethodGenerateDocComment (
 			MethodCore mc, XmlElement el, Report Report)
 		{
 			var paramTags = new Dictionary<string, string> ();
 			foreach (XmlElement pelem in el.SelectNodes ("param")) {
 				string xname = pelem.GetAttribute ("name");
 				if (xname.Length == 0)
 					continue; // really? but MS looks doing so
 				if (xname != "" && mc.ParameterInfo.GetParameterIndexByName (xname) < 0)
 					Report.Warning (1572, 2, mc.Location, "XML comment on `{0}' has a param tag for `{1}', but there is no parameter by that name",
 						mc.GetSignatureForError (), xname);
 				else if (paramTags.ContainsKey (xname))
 					Report.Warning (1571, 2, mc.Location, "XML comment on `{0}' has a duplicate param tag for `{1}'",
 						mc.GetSignatureForError (), xname);
 				paramTags [xname] = xname;
 			}
 			IParameterData [] plist = mc.ParameterInfo.FixedParameters;
 			foreach (Parameter p in plist) {
 				if (paramTags.Count > 0 && !paramTags.ContainsKey (p.Name))
 					Report.Warning (1573, 4, mc.Location, "Parameter `{0}' has no matching param tag in the XML comment for `{1}'",
 						p.Name, mc.GetSignatureForError ());
 			}
 		}
 
 		private static void Normalize (MemberCore mc, ref string name, Report Report)
 		{
 			if (name.Length > 0 && name [0] == '@')
 				name = name.Substring (1);
 			else if (name == "this")
 				name = "Item";
 			else if (Tokenizer.IsKeyword (name) && !IsTypeName (name))
 				Report.Warning (1041, 1, mc.Location, "Identifier expected. `{0}' is a keyword", name);
 		}
 
 		private static bool IsTypeName (string name)
 		{
 			switch (name) {
 			case "bool"
 			case "byte"
 			case "char"
 			case "decimal"
 			case "double"
 			case "float"
 			case "int"
 			case "long"
 			case "object"
 			case "sbyte"
 			case "short"
 			case "string"
 			case "uint"
 			case "ulong"
 			case "ushort"
 			case "void"
 				return true;
 			}
 			return false;
 		}
 	}
 
 	//
 	// Implements XML documentation generation.
 	//
 	public class Documentation
 	{
 		public Documentation (string xml_output_filename)
 		{
 			docfilename = xml_output_filename;
 			XmlDocumentation = new XmlDocument ();
 			XmlDocumentation.PreserveWhitespace = false;
 		}
 
 		private string docfilename;
 
 		//
 		// Used to create element which helps well-formedness checking.
 		//
 		public XmlDocument XmlDocumentation;
 
 		//
 		// The output for XML documentation.
 		//
 		public XmlWriter XmlCommentOutput;
 
 		//
 		// Stores XmlDocuments that are included in XML documentation.
 		// Keys are included filenames, values are XmlDocuments.
 		//
 		public Dictionary<string, XmlDocument> StoredDocuments = new Dictionary<string, XmlDocument> ();
 		public Documentation (string xml_output_filename)
 		{
 			docfilename = xml_output_filename;
 			XmlDocumentation = new XmlDocument ();
 			XmlDocumentation.PreserveWhitespace = false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\SignatureHelper.cs" startline="102" endline="112">
<![CDATA[
 
 		public static SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers)
 		{
 			SignatureHelper sig = new SignatureHelper(mod as ModuleBuilder, Signature.PROPERTY);
 			sig.callingConvention = callingConvention;
 			sig.returnType = returnType;
 			sig.returnTypeOptionalCustomModifiers = requiredReturnTypeCustomModifiers;
 			sig.returnTypeRequiredCustomModifiers = optionalReturnTypeCustomModifiers;
 			sig.AddArguments(parameterTypes, requiredParameterTypeCustomModifiers, optionalParameterTypeCustomModifiers);
 			return sig;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\statement.cs" startline="1073" endline="1083">
<![CDATA[
 			
 		protected override void DoEmit (EmitContext ec)
 		{
 			if (expr == null)
 				ec.Emit (OpCodes.Rethrow);
 			else {
 				expr.Emit (ec);
 
 				ec.Emit (OpCodes.Throw);
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\anonymous.cs" startline="1432" endline="1440">
<![CDATA[
 		}
 
 		#endregion
 
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			ec.Report.Error (1945, loc, "An expression tree cannot contain an anonymous method expression");
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="7049" endline="7055">
<![CDATA[
 		}
 		
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			ec.Report.Error (1952, loc, "An expression tree cannot contain a method with variable arguments");
 			return null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\constant.cs" startline="357" endline="364">
<![CDATA[
 		
 		public override void Emit (EmitContext ec)
 		{
 			if (Value)
 				ec.Emit (OpCodes.Ldc_I4_1);
 			else
 				ec.Emit (OpCodes.Ldc_I4_0);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="1712" endline="4007">
<![CDATA[
 	}
 
 	/// <summary>
 	///   Binary operators
 	/// </summary>
 	public class Binary 
 	{
 		protected class PredefinedOperator {
 			protected readonly TypeSpec left;
 			protected readonly TypeSpec right;
 			public readonly Operator OperatorsMask;
 			public TypeSpec ReturnType;
 
 			public PredefinedOperator (TypeSpec ltype, TypeSpec rtype, Operator op_mask)
 				
 			{
 			}
 
 			public PredefinedOperator (TypeSpec type, Operator op_mask, TypeSpec return_type)
 				
 			{
 			}
 
 			public PredefinedOperator (TypeSpec type, Operator op_mask)
 				
 			{
 			}
 
 			public PredefinedOperator (TypeSpec ltype, TypeSpec rtype, Operator op_mask, TypeSpec return_type)
 			{
 				if ((op_mask & Operator.ValuesOnlyMask) != 0)
 					throw new InternalErrorException ("Only masked values can be used");
 
 				this.left = ltype;
 				this.right = rtype;
 				this.OperatorsMask = op_mask;
 				this.ReturnType = return_type;
 			}
 
 			public virtual Expression ConvertResult (ResolveContext ec, Binary b)
 			{
 				b.type = ReturnType;
 
 				b.left = Convert.ImplicitConversion (ec, b.left, left, b.left.Location);
 				b.right = Convert.ImplicitConversion (ec, b.right, right, b.right.Location);
 
 				//
 				// A user operators does not support multiple user conversions, but decimal type
 				// is considered to be predefined type therefore we apply predefined operators rules
 				// and then look for decimal user-operator implementation
 				//
 				if (left == TypeManager.decimal_type)
 					return b.ResolveUserOperator (ec, b.left, b.right);
 
 				var c = b.right as Constant;
 				if (c != null) {
 					if (c.IsDefaultValue && (b.oper == Operator.Addition || b.oper == Operator.Subtraction || (b.oper == Operator.BitwiseOr && !(b is Nullable.LiftedBinaryOperator))))
 						return ReducedExpression.Create (b.left, b).Resolve (ec);
 					if ((b.oper == Operator.Multiply || b.oper == Operator.Division) && c.IsOneInteger)
 						return ReducedExpression.Create (b.left, b).Resolve (ec);
 					return b;
 				}
 
 				c = b.left as Constant;
 				if (c != null) {
 					if (c.IsDefaultValue && (b.oper == Operator.Addition || b.oper == Operator.Subtraction || (b.oper == Operator.BitwiseOr && !(b is Nullable.LiftedBinaryOperator))))
 						return ReducedExpression.Create (b.right, b).Resolve (ec);
 					if (b.oper == Operator.Multiply && c.IsOneInteger)
 						return ReducedExpression.Create (b.right, b).Resolve (ec);
 					return b;
 				}
 
 				return b;
 			}
 
 			public bool IsPrimitiveApplicable (TypeSpec ltype, TypeSpec rtype)
 			{
 				//
 				// We are dealing with primitive types only
 				//
 				return left == ltype && ltype == rtype;
 			}
 
 			public virtual bool IsApplicable (ResolveContext ec, Expression lexpr, Expression rexpr)
 			{
 				// Quick path
 				if (left == lexpr.Type && right == rexpr.Type)
 					return true;
 
 				return Convert.ImplicitConversionExists (ec, lexpr, left) &&
 					Convert.ImplicitConversionExists (ec, rexpr, right);
 			}
 
 			public PredefinedOperator ResolveBetterOperator (ResolveContext ec, PredefinedOperator best_operator)
 			{
 				int result = 0;
 				if (left != null && best_operator.left != null) {
 					result = OverloadResolver.BetterTypeConversion (ec, best_operator.left, left);
 				}
 
 				//
 				// When second argument is same as the first one, the result is same
 				//
 				if (right != null && (left != right || best_operator.left != best_operator.right)) {
 					result |= OverloadResolver.BetterTypeConversion (ec, best_operator.right, right);
 				}
 
 				if (result == 0 || result > 2)
 					return null;
 
 				return result == 1 ? best_operator 
 			}
 		}
 
 		class PredefinedStringOperator 
 			public PredefinedStringOperator (TypeSpec type, Operator op_mask)
 				
 			{
 				ReturnType = TypeManager.string_type;
 			}
 
 			public PredefinedStringOperator (TypeSpec ltype, TypeSpec rtype, Operator op_mask)
 				
 			{
 				ReturnType = TypeManager.string_type;
 			}
 
 			public override Expression ConvertResult (ResolveContext ec, Binary b)
 			{
 				//
 				// Use original expression for nullable arguments
 				//
 				Nullable.Unwrap unwrap = b.left as Nullable.Unwrap;
 				if (unwrap != null)
 					b.left = unwrap.Original;
 
 				unwrap = b.right as Nullable.Unwrap;
 				if (unwrap != null)
 					b.right = unwrap.Original;
 
 				b.left = Convert.ImplicitConversion (ec, b.left, left, b.left.Location);
 				b.right = Convert.ImplicitConversion (ec, b.right, right, b.right.Location);
 
 				//
 				// Start a new concat expression using converted expression
 				//
 				return StringConcat.Create (ec, b.left, b.right, b.loc);
 			}
 		}
 
 		class PredefinedShiftOperator 
 			public PredefinedShiftOperator (TypeSpec ltype, Operator op_mask) 
 				base (ltype, TypeManager.int32_type, op_mask)
 			{
 			}
 
 			public override Expression ConvertResult (ResolveContext ec, Binary b)
 			{
 				b.left = Convert.ImplicitConversion (ec, b.left, left, b.left.Location);
 
 				Expression expr_tree_expr = Convert.ImplicitConversion (ec, b.right, TypeManager.int32_type, b.right.Location);
 
 				int right_mask = left == TypeManager.int32_type || left == TypeManager.uint32_type ? 0x1f 
 
 				//
 				// b = b.left >> b.right & (0x1f|0x3f)
 				//
 				b.right = new Binary (Operator.BitwiseAnd,
 					b.right, new IntConstant (right_mask, b.right.Location), b.loc).Resolve (ec);
 
 				//
 				// Expression tree representation does not use & mask
 				//
 				b.right = ReducedExpression.Create (b.right, expr_tree_expr).Resolve (ec);
 				b.type = ReturnType;
 
 				//
 				// Optimize shift by 0
 				//
 				var c = b.right as Constant;
 				if (c != null && c.IsDefaultValue)
 					return ReducedExpression.Create (b.left, b).Resolve (ec);
 
 				return b;
 			}
 		}
 
 		class PredefinedEqualityOperator 
 		{
 			MethodSpec equal_method, inequal_method;
 
 			public PredefinedEqualityOperator (TypeSpec arg, TypeSpec retType)
 				
 			{
 			}
 
 			public override Expression ConvertResult (ResolveContext ec, Binary b)
 			{
 				b.type = ReturnType;
 
 				b.left = Convert.ImplicitConversion (ec, b.left, left, b.left.Location);
 				b.right = Convert.ImplicitConversion (ec, b.right, right, b.right.Location);
 
 				Arguments args = new Arguments (2);
 				args.Add (new Argument (b.left));
 				args.Add (new Argument (b.right));
 
 				MethodSpec method;
 				if (b.oper == Operator.Equality) {
 					if (equal_method == null) {
 						equal_method = TypeManager.GetPredefinedMethod (left,
 							new MemberFilter (CSharp.Operator.GetMetadataName (CSharp.Operator.OpType.Equality), 0, MemberKind.Operator, null, ReturnType), b.loc);
 					}
 
 					method = equal_method;
 				} else {
 					if (inequal_method == null) {
 						inequal_method = TypeManager.GetPredefinedMethod (left,
 							new MemberFilter (CSharp.Operator.GetMetadataName (CSharp.Operator.OpType.Inequality), 0, MemberKind.Operator, null, ReturnType), b.loc);
 					}
 
 					method = inequal_method;
 				}
 
 				return new UserOperatorCall (method, args, b.CreateExpressionTree, b.loc);
 			}
 		}
 
 		class PredefinedPointerOperator 
 		{
 			public PredefinedPointerOperator (TypeSpec ltype, TypeSpec rtype, Operator op_mask)
 				
 			{
 			}
 
 			public PredefinedPointerOperator (TypeSpec ltype, TypeSpec rtype, Operator op_mask, TypeSpec retType)
 				
 			{
 			}
 
 			public PredefinedPointerOperator (TypeSpec type, Operator op_mask, TypeSpec return_type)
 				
 			{
 			}
 
 			public override bool IsApplicable (ResolveContext ec, Expression lexpr, Expression rexpr)
 			{
 				if (left == null) {
 					if (!lexpr.Type.IsPointer)
 						return false;
 				} else {
 					if (!Convert.ImplicitConversionExists (ec, lexpr, left))
 						return false;
 				}
 
 				if (right == null) {
 					if (!rexpr.Type.IsPointer)
 						return false;
 				} else {
 					if (!Convert.ImplicitConversionExists (ec, rexpr, right))
 						return false;
 				}
 
 				return true;
 			}
 
 			public override Expression ConvertResult (ResolveContext ec, Binary b)
 			{
 				if (left != null) {
 					b.left = EmptyCast.Create (b.left, left);
 				} else if (right != null) {
 					b.right = EmptyCast.Create (b.right, right);
 				}
 
 				TypeSpec r_type = ReturnType;
 				Expression left_arg, right_arg;
 				if (r_type == null) {
 					if (left == null) {
 						left_arg = b.left;
 						right_arg = b.right;
 						r_type = b.left.Type;
 					} else {
 						left_arg = b.right;
 						right_arg = b.left;
 						r_type = b.right.Type;
 					}
 				} else {
 					left_arg = b.left;
 					right_arg = b.right;
 				}
 
 				return new PointerArithmetic (b.oper, left_arg, right_arg, r_type, b.loc).Resolve (ec);
 			}
 		}
 
 		[Flags]
 		public enum Operator {
 			Multiply	= 0 | ArithmeticMask,
 			Division	= 1 | ArithmeticMask,
 			Modulus		= 2 | ArithmeticMask,
 			Addition	= 3 | ArithmeticMask | AdditionMask,
 			Subtraction = 4 | ArithmeticMask | SubtractionMask,
 
 			LeftShift	= 5 | ShiftMask,
 			RightShift	= 6 | ShiftMask,
 
 			LessThan	= 7 | ComparisonMask | RelationalMask,
 			GreaterThan	= 8 | ComparisonMask | RelationalMask,
 			LessThanOrEqual		= 9 | ComparisonMask | RelationalMask,
 			GreaterThanOrEqual	= 10 | ComparisonMask | RelationalMask,
 			Equality	= 11 | ComparisonMask | EqualityMask,
 			Inequality	= 12 | ComparisonMask | EqualityMask,
 
 			BitwiseAnd	= 13 | BitwiseMask,
 			ExclusiveOr	= 14 | BitwiseMask,
 			BitwiseOr	= 15 | BitwiseMask,
 
 			LogicalAnd	= 16 | LogicalMask,
 			LogicalOr	= 17 | LogicalMask,
 
 			//
 			// Operator masks
 			//
 			ValuesOnlyMask	= ArithmeticMask - 1,
 			ArithmeticMask	= 1 << 5,
 			ShiftMask		= 1 << 6,
 			ComparisonMask	= 1 << 7,
 			EqualityMask	= 1 << 8,
 			BitwiseMask		= 1 << 9,
 			LogicalMask		= 1 << 10,
 			AdditionMask	= 1 << 11,
 			SubtractionMask	= 1 << 12,
 			RelationalMask	= 1 << 13
 		}
 
 		protected enum State
 		{
 			None = 0,
 			Compound = 1 << 1,
 			LeftNullLifted = 1 << 2,
 			RightNullLifted = 1 << 3
 		}
 
 		readonly Operator oper;
 		protected Expression left, right;
 		protected State state;
 		Expression enum_conversion;
 
 		static PredefinedOperator[] standard_operators;
 		static PredefinedOperator[] equality_operators;
 		static PredefinedOperator[] pointer_operators;
 		
 		public Binary (Operator oper, Expression left, Expression right, bool isCompound, Location loc)
 			
 		{
 			if (isCompound)
 				state |= State.Compound;
 		}
 
 		public Binary (Operator oper, Expression left, Expression right, Location loc)
 		{
 			this.oper = oper;
 			this.left = left;
 			this.right = right;
 			this.loc = loc;
 		}
 
 		#region Properties
 
 		public bool IsCompound {
 			get {
 				return (state & State.Compound) != 0;
 			}
 		}
 
 		public Operator Oper {
 			get {
 				return oper;
 			}
 		}
 
 		#endregion
 
 		/// <summary>
 		///   Returns a stringified representation of the Operator
 		/// </summary>
 		string OperName (Operator oper)
 		{
 			string s;
 			switch (oper){
 			case Operator.Multiply
 				s = "*";
 				break;
 			case Operator.Division
 				s = "/";
 				break;
 			case Operator.Modulus
 				s = "%";
 				break;
 			case Operator.Addition
 				s = "+";
 				break;
 			case Operator.Subtraction
 				s = "-";
 				break;
 			case Operator.LeftShift
 				s = "<<";
 				break;
 			case Operator.RightShift
 				s = ">>";
 				break;
 			case Operator.LessThan
 				s = "<";
 				break;
 			case Operator.GreaterThan
 				s = ">";
 				break;
 			case Operator.LessThanOrEqual
 				s = "<=";
 				break;
 			case Operator.GreaterThanOrEqual
 				s = ">=";
 				break;
 			case Operator.Equality
 				s = "==";
 				break;
 			case Operator.Inequality
 				s = "!=";
 				break;
 			case Operator.BitwiseAnd
 				s = "&";
 				break;
 			case Operator.BitwiseOr
 				s = "|";
 				break;
 			case Operator.ExclusiveOr
 				s = "^";
 				break;
 			case Operator.LogicalOr
 				s = "||";
 				break;
 			case Operator.LogicalAnd
 				s = "&&";
 				break;
 			default
 				s = oper.ToString ();
 				break;
 			}
 
 			if (IsCompound)
 				return s + "=";
 
 			return s;
 		}
 
 		public static void Error_OperatorCannotBeApplied (ResolveContext ec, Expression left, Expression right, Operator oper, Location loc)
 		{
 			new Binary (oper, left, right, loc).Error_OperatorCannotBeApplied (ec, left, right);
 		}
 
 		public static void Error_OperatorCannotBeApplied (ResolveContext ec, Expression left, Expression right, string oper, Location loc)
 		{
 			string l, r;
 			l = TypeManager.CSharpName (left.Type);
 			r = TypeManager.CSharpName (right.Type);
 
 			ec.Report.Error (19, loc, "Operator `{0}' cannot be applied to operands of type `{1}' and `{2}'",
 				oper, l, r);
 		}
 		
 		protected void Error_OperatorCannotBeApplied (ResolveContext ec, Expression left, Expression right)
 		{
 			Error_OperatorCannotBeApplied (ec, left, right, OperName (oper), loc);
 		}
 
 		//
 		// Converts operator to System.Linq.Expressions.ExpressionType enum name
 		//
 		string GetOperatorExpressionTypeName ()
 		{
 			switch (oper) {
 			case Operator.Addition
 				return IsCompound ? "AddAssign" 
 			case Operator.BitwiseAnd
 				return IsCompound ? "AndAssign" 
 			case Operator.BitwiseOr
 				return IsCompound ? "OrAssign" 
 			case Operator.Division
 				return IsCompound ? "DivideAssign" 
 			case Operator.ExclusiveOr
 				return IsCompound ? "ExclusiveOrAssign" 
 			case Operator.Equality
 				return "Equal";
 			case Operator.GreaterThan
 				return "GreaterThan";
 			case Operator.GreaterThanOrEqual
 				return "GreaterThanOrEqual";
 			case Operator.Inequality
 				return "NotEqual";
 			case Operator.LeftShift
 				return IsCompound ? "LeftShiftAssign" 
 			case Operator.LessThan
 				return "LessThan";
 			case Operator.LessThanOrEqual
 				return "LessThanOrEqual";
 			case Operator.LogicalAnd
 				return "And";
 			case Operator.LogicalOr
 				return "Or";
 			case Operator.Modulus
 				return IsCompound ? "ModuloAssign" 
 			case Operator.Multiply
 				return IsCompound ? "MultiplyAssign" 
 			case Operator.RightShift
 				return IsCompound ? "RightShiftAssign" 
 			case Operator.Subtraction
 				return IsCompound ? "SubtractAssign" 
 			default
 				throw new NotImplementedException ("Unknown expression type operator " + oper.ToString ());
 			}
 		}
 
 		static CSharp.Operator.OpType ConvertBinaryToUserOperator (Operator op)
 		{
 			switch (op) {
 			case Operator.Addition
 				return CSharp.Operator.OpType.Addition;
 			case Operator.BitwiseAnd
 			case Operator.LogicalAnd
 				return CSharp.Operator.OpType.BitwiseAnd;
 			case Operator.BitwiseOr
 			case Operator.LogicalOr
 				return CSharp.Operator.OpType.BitwiseOr;
 			case Operator.Division
 				return CSharp.Operator.OpType.Division;
 			case Operator.Equality
 				return CSharp.Operator.OpType.Equality;
 			case Operator.ExclusiveOr
 				return CSharp.Operator.OpType.ExclusiveOr;
 			case Operator.GreaterThan
 				return CSharp.Operator.OpType.GreaterThan;
 			case Operator.GreaterThanOrEqual
 				return CSharp.Operator.OpType.GreaterThanOrEqual;
 			case Operator.Inequality
 				return CSharp.Operator.OpType.Inequality;
 			case Operator.LeftShift
 				return CSharp.Operator.OpType.LeftShift;
 			case Operator.LessThan
 				return CSharp.Operator.OpType.LessThan;
 			case Operator.LessThanOrEqual
 				return CSharp.Operator.OpType.LessThanOrEqual;
 			case Operator.Modulus
 				return CSharp.Operator.OpType.Modulus;
 			case Operator.Multiply
 				return CSharp.Operator.OpType.Multiply;
 			case Operator.RightShift
 				return CSharp.Operator.OpType.RightShift;
 			case Operator.Subtraction
 				return CSharp.Operator.OpType.Subtraction;
 			default
 				throw new InternalErrorException (op.ToString ());
 			}
 		}
 
 		public static void EmitOperatorOpcode (EmitContext ec, Operator oper, TypeSpec l)
 		{
 			OpCode opcode;
 
 			switch (oper){
 			case Operator.Multiply
 				if (ec.HasSet (EmitContext.Options.CheckedScope)) {
 					if (l == TypeManager.int32_type || l == TypeManager.int64_type)
 						opcode = OpCodes.Mul_Ovf;
 					else if (!IsFloat (l))
 						opcode = OpCodes.Mul_Ovf_Un;
 					else
 						opcode = OpCodes.Mul;
 				} else
 					opcode = OpCodes.Mul;
 				
 				break;
 				
 			case Operator.Division
 				if (IsUnsigned (l))
 					opcode = OpCodes.Div_Un;
 				else
 					opcode = OpCodes.Div;
 				break;
 				
 			case Operator.Modulus
 				if (IsUnsigned (l))
 					opcode = OpCodes.Rem_Un;
 				else
 					opcode = OpCodes.Rem;
 				break;
 
 			case Operator.Addition
 				if (ec.HasSet (EmitContext.Options.CheckedScope)) {
 					if (l == TypeManager.int32_type || l == TypeManager.int64_type)
 						opcode = OpCodes.Add_Ovf;
 					else if (!IsFloat (l))
 						opcode = OpCodes.Add_Ovf_Un;
 					else
 						opcode = OpCodes.Add;
 				} else
 					opcode = OpCodes.Add;
 				break;
 
 			case Operator.Subtraction
 				if (ec.HasSet (EmitContext.Options.CheckedScope)) {
 					if (l == TypeManager.int32_type || l == TypeManager.int64_type)
 						opcode = OpCodes.Sub_Ovf;
 					else if (!IsFloat (l))
 						opcode = OpCodes.Sub_Ovf_Un;
 					else
 						opcode = OpCodes.Sub;
 				} else
 					opcode = OpCodes.Sub;
 				break;
 
 			case Operator.RightShift
 				if (IsUnsigned (l))
 					opcode = OpCodes.Shr_Un;
 				else
 					opcode = OpCodes.Shr;
 				break;
 				
 			case Operator.LeftShift
 				opcode = OpCodes.Shl;
 				break;
 
 			case Operator.Equality
 				opcode = OpCodes.Ceq;
 				break;
 
 			case Operator.Inequality
 				ec.Emit (OpCodes.Ceq);
 				ec.Emit (OpCodes.Ldc_I4_0);
 				
 				opcode = OpCodes.Ceq;
 				break;
 
 			case Operator.LessThan
 				if (IsUnsigned (l))
 					opcode = OpCodes.Clt_Un;
 				else
 					opcode = OpCodes.Clt;
 				break;
 
 			case Operator.GreaterThan
 				if (IsUnsigned (l))
 					opcode = OpCodes.Cgt_Un;
 				else
 					opcode = OpCodes.Cgt;
 				break;
 
 			case Operator.LessThanOrEqual
 				if (IsUnsigned (l) || IsFloat (l))
 					ec.Emit (OpCodes.Cgt_Un);
 				else
 					ec.Emit (OpCodes.Cgt);
 				ec.Emit (OpCodes.Ldc_I4_0);
 				
 				opcode = OpCodes.Ceq;
 				break;
 
 			case Operator.GreaterThanOrEqual
 				if (IsUnsigned (l) || IsFloat (l))
 					ec.Emit (OpCodes.Clt_Un);
 				else
 					ec.Emit (OpCodes.Clt);
 				
 				ec.Emit (OpCodes.Ldc_I4_0);
 				
 				opcode = OpCodes.Ceq;
 				break;
 
 			case Operator.BitwiseOr
 				opcode = OpCodes.Or;
 				break;
 
 			case Operator.BitwiseAnd
 				opcode = OpCodes.And;
 				break;
 
 			case Operator.ExclusiveOr
 				opcode = OpCodes.Xor;
 				break;
 
 			default
 				throw new InternalErrorException (oper.ToString ());
 			}
 
 			ec.Emit (opcode);
 		}
 
 		static bool IsUnsigned (TypeSpec t)
 		{
 			if (t.IsPointer)
 				return true;
 
 			return (t == TypeManager.uint32_type || t == TypeManager.uint64_type ||
 				t == TypeManager.ushort_type || t == TypeManager.byte_type);
 		}
 
 		static bool IsFloat (TypeSpec t)
 		{
 			return t == TypeManager.float_type || t == TypeManager.double_type;
 		}
 
 		public static void Reset ()
 		{
 			equality_operators = pointer_operators = standard_operators = null;
 		}
 
 		Expression ResolveOperator (ResolveContext ec)
 		{
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Expression expr;
 			bool primitives_only = false;
 
 			if (standard_operators == null)
 				CreateStandardOperatorsTable ();
 
 			//
 			// Handles predefined primitive types
 			//
 			if (TypeManager.IsPrimitiveType (l) && TypeManager.IsPrimitiveType (r)) {
 				if ((oper & Operator.ShiftMask) == 0) {
 					if (l != TypeManager.bool_type && !DoBinaryOperatorPromotion (ec))
 						return null;
 
 					primitives_only = true;
 				}
 			} else {
 				// Pointers
 				if (l.IsPointer || r.IsPointer)
 					return ResolveOperatorPointer (ec, l, r);
 
 				// Enums
 				bool lenum = l.IsEnum;
 				bool renum = r.IsEnum;
 				if (lenum || renum) {
 					expr = ResolveOperatorEnum (ec, lenum, renum, l, r);
 
 					if (expr != null)
 						return expr;
 				}
 
 				// Delegates
 				if ((oper == Operator.Addition || oper == Operator.Subtraction) && (l.IsDelegate || r.IsDelegate)) {
 						
 					expr = ResolveOperatorDelegate (ec, l, r);
 
 					// TODO
 					if (expr != null)
 						return expr;
 				}
 
 				// User operators
 				expr = ResolveUserOperator (ec, left, right);
 				if (expr != null)
 					return expr;
 
 				// Predefined reference types equality
 				if ((oper & Operator.EqualityMask) != 0) {
 					expr = ResolveOperatorEquality (ec, l, r);
 					if (expr != null)
 						return expr;
 				}
 			}
 
 			return ResolveOperatorPredefined (ec, standard_operators, primitives_only, null);
 		}
 
 		// at least one of 'left' or 'right' is an enumeration constant (EnumConstant or SideEffectConstant or ...)
 		// if 'left' is not an enumeration constant, create one from the type of 'right'
 		Constant EnumLiftUp (ResolveContext ec, Constant left, Constant right, Location loc)
 		{
 			switch (oper) {
 			case Operator.BitwiseOr
 			case Operator.BitwiseAnd
 			case Operator.ExclusiveOr
 			case Operator.Equality
 			case Operator.Inequality
 			case Operator.LessThan
 			case Operator.LessThanOrEqual
 			case Operator.GreaterThan
 			case Operator.GreaterThanOrEqual
 				if (TypeManager.IsEnumType (left.Type))
 					return left;
 				
 				if (left.IsZeroInteger)
 					return left.TryReduce (ec, right.Type, loc);
 				
 				break;
 				
 			case Operator.Addition
 			case Operator.Subtraction
 				return left;
 				
 			case Operator.Multiply
 			case Operator.Division
 			case Operator.Modulus
 			case Operator.LeftShift
 			case Operator.RightShift
 				if (TypeManager.IsEnumType (right.Type) || TypeManager.IsEnumType (left.Type))
 					break;
 				return left;
 			}
 			Error_OperatorCannotBeApplied (ec, this.left, this.right);
 			return null;
 		}
 
 		//
 		// The `|' operator used on types which were extended is dangerous
 		//
 		void CheckBitwiseOrOnSignExtended (ResolveContext ec)
 		{
 			OpcodeCast lcast = left as OpcodeCast;
 			if (lcast != null) {
 				if (IsUnsigned (lcast.UnderlyingType))
 					lcast = null;
 			}
 
 			OpcodeCast rcast = right as OpcodeCast;
 			if (rcast != null) {
 				if (IsUnsigned (rcast.UnderlyingType))
 					rcast = null;
 			}
 
 			if (lcast == null && rcast == null)
 				return;
 
 			// FIXME
 
 			ec.Report.Warning (675, 3, loc,
 				"The operator `|' used on the sign-extended type `{0}'. Consider casting to a smaller unsigned type first",
 				TypeManager.CSharpName (lcast != null ? lcast.UnderlyingType 
 		}
 
 		static void CreatePointerOperatorsTable ()
 		{
 			var temp = new List<PredefinedPointerOperator> ();
 
 			//
 			// Pointer arithmetic
 			//
 			// T* operator + (T* x, int y);		T* operator - (T* x, int y);
 			// T* operator + (T* x, uint y);	T* operator - (T* x, uint y);
 			// T* operator + (T* x, long y);	T* operator - (T* x, long y);
 			// T* operator + (T* x, ulong y);	T* operator - (T* x, ulong y);
 			//
 			temp.Add (new PredefinedPointerOperator (null, TypeManager.int32_type, Operator.AdditionMask | Operator.SubtractionMask));
 			temp.Add (new PredefinedPointerOperator (null, TypeManager.uint32_type, Operator.AdditionMask | Operator.SubtractionMask));
 			temp.Add (new PredefinedPointerOperator (null, TypeManager.int64_type, Operator.AdditionMask | Operator.SubtractionMask));
 			temp.Add (new PredefinedPointerOperator (null, TypeManager.uint64_type, Operator.AdditionMask | Operator.SubtractionMask));
 
 			//
 			// T* operator + (int y,   T* x);
 			// T* operator + (uint y,  T *x);
 			// T* operator + (long y,  T *x);
 			// T* operator + (ulong y, T *x);
 			//
 			temp.Add (new PredefinedPointerOperator (TypeManager.int32_type, null, Operator.AdditionMask, null));
 			temp.Add (new PredefinedPointerOperator (TypeManager.uint32_type, null, Operator.AdditionMask, null));
 			temp.Add (new PredefinedPointerOperator (TypeManager.int64_type, null, Operator.AdditionMask, null));
 			temp.Add (new PredefinedPointerOperator (TypeManager.uint64_type, null, Operator.AdditionMask, null));
 
 			//
 			// long operator - (T* x, T *y)
 			//
 			temp.Add (new PredefinedPointerOperator (null, Operator.SubtractionMask, TypeManager.int64_type));
 
 			pointer_operators = temp.ToArray ();
 		}
 
 		static void CreateStandardOperatorsTable ()
 		{
 			var temp = new List<PredefinedOperator> ();
 			TypeSpec bool_type = TypeManager.bool_type;
 
 			temp.Add (new PredefinedOperator (TypeManager.int32_type, Operator.ArithmeticMask | Operator.BitwiseMask));
 			temp.Add (new PredefinedOperator (TypeManager.uint32_type, Operator.ArithmeticMask | Operator.BitwiseMask));
 			temp.Add (new PredefinedOperator (TypeManager.int64_type, Operator.ArithmeticMask | Operator.BitwiseMask));
 			temp.Add (new PredefinedOperator (TypeManager.uint64_type, Operator.ArithmeticMask | Operator.BitwiseMask));
 			temp.Add (new PredefinedOperator (TypeManager.float_type, Operator.ArithmeticMask));
 			temp.Add (new PredefinedOperator (TypeManager.double_type, Operator.ArithmeticMask));
 			temp.Add (new PredefinedOperator (TypeManager.decimal_type, Operator.ArithmeticMask));
 
 			temp.Add (new PredefinedOperator (TypeManager.int32_type, Operator.ComparisonMask, bool_type));
 			temp.Add (new PredefinedOperator (TypeManager.uint32_type, Operator.ComparisonMask, bool_type));
 			temp.Add (new PredefinedOperator (TypeManager.int64_type, Operator.ComparisonMask, bool_type));
 			temp.Add (new PredefinedOperator (TypeManager.uint64_type, Operator.ComparisonMask, bool_type));
 			temp.Add (new PredefinedOperator (TypeManager.float_type, Operator.ComparisonMask, bool_type));
 			temp.Add (new PredefinedOperator (TypeManager.double_type, Operator.ComparisonMask, bool_type));
 			temp.Add (new PredefinedOperator (TypeManager.decimal_type, Operator.ComparisonMask, bool_type));
 
 			temp.Add (new PredefinedStringOperator (TypeManager.string_type, Operator.AdditionMask));
 			temp.Add (new PredefinedStringOperator (TypeManager.string_type, TypeManager.object_type, Operator.AdditionMask));
 			temp.Add (new PredefinedStringOperator (TypeManager.object_type, TypeManager.string_type, Operator.AdditionMask));
 
 			temp.Add (new PredefinedOperator (bool_type,
 				Operator.BitwiseMask | Operator.LogicalMask | Operator.EqualityMask, bool_type));
 
 			temp.Add (new PredefinedShiftOperator (TypeManager.int32_type, Operator.ShiftMask));
 			temp.Add (new PredefinedShiftOperator (TypeManager.uint32_type, Operator.ShiftMask));
 			temp.Add (new PredefinedShiftOperator (TypeManager.int64_type, Operator.ShiftMask));
 			temp.Add (new PredefinedShiftOperator (TypeManager.uint64_type, Operator.ShiftMask));
 
 			standard_operators = temp.ToArray ();
 
 			var equality = new List<PredefinedOperator> () {
 				new PredefinedEqualityOperator (TypeManager.string_type, bool_type),
 				new PredefinedEqualityOperator (TypeManager.delegate_type, bool_type),
 				new PredefinedOperator (bool_type, Operator.EqualityMask, bool_type)
 			};
 
 			equality_operators = equality.ToArray ();
 		}
 
 		//
 		// Rules used during binary numeric promotion
 		//
 		static bool DoNumericPromotion (ResolveContext rc, ref Expression prim_expr, ref Expression second_expr, TypeSpec type)
 		{
 			Expression temp;
 			TypeSpec etype;
 
 			Constant c = prim_expr as Constant;
 			if (c != null) {
 				temp = c.ConvertImplicitly (rc, type);
 				if (temp != null) {
 					prim_expr = temp;
 					return true;
 				}
 			}
 
 			if (type == TypeManager.uint32_type) {
 				etype = prim_expr.Type;
 				if (etype == TypeManager.int32_type || etype == TypeManager.short_type || etype == TypeManager.sbyte_type) {
 					type = TypeManager.int64_type;
 
 					if (type != second_expr.Type) {
 						c = second_expr as Constant;
 						if (c != null)
 							temp = c.ConvertImplicitly (rc, type);
 						else
 							temp = Convert.ImplicitNumericConversion (second_expr, type);
 						if (temp == null)
 							return false;
 						second_expr = temp;
 					}
 				}
 			} else if (type == TypeManager.uint64_type) {
 				//
 				// A compile-time error occurs if the other operand is of type sbyte, short, int, or long
 				//
 				if (type == TypeManager.int32_type || type == TypeManager.int64_type ||
 					type == TypeManager.short_type || type == TypeManager.sbyte_type)
 					return false;
 			}
 
 			temp = Convert.ImplicitNumericConversion (prim_expr, type);
 			if (temp == null)
 				return false;
 
 			prim_expr = temp;
 			return true;
 		}
 
 		//
 		// 7.2.6.2 Binary numeric promotions
 		//
 		public bool DoBinaryOperatorPromotion (ResolveContext ec)
 		{
 			TypeSpec ltype = left.Type;
 			TypeSpec rtype = right.Type;
 			Expression temp;
 
 			foreach (TypeSpec t in ConstantFold.BinaryPromotionsTypes) {
 				if (t == ltype)
 					return t == rtype || DoNumericPromotion (ec, ref right, ref left, t);
 
 				if (t == rtype)
 					return t == ltype || DoNumericPromotion (ec, ref left, ref right, t);
 			}
 
 			TypeSpec int32 = TypeManager.int32_type;
 			if (ltype != int32) {
 				Constant c = left as Constant;
 				if (c != null)
 					temp = c.ConvertImplicitly (ec, int32);
 				else
 					temp = Convert.ImplicitNumericConversion (left, int32);
 
 				if (temp == null)
 					return false;
 				left = temp;
 			}
 
 			if (rtype != int32) {
 				Constant c = right as Constant;
 				if (c != null)
 					temp = c.ConvertImplicitly (ec, int32);
 				else
 					temp = Convert.ImplicitNumericConversion (right, int32);
 
 				if (temp == null)
 					return false;
 				right = temp;
 			}
 
 			return true;
 		}
 
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			if (left == null)
 				return null;
 
 			if ((oper == Operator.Subtraction) && (left is ParenthesizedExpression)) {
 				left = ((ParenthesizedExpression) left).Expr;
 				left = left.Resolve (ec, ResolveFlags.VariableOrValue | ResolveFlags.Type);
 				if (left == null)
 					return null;
 
 				if (left.eclass == ExprClass.Type) {
 					ec.Report.Error (75, loc, "To cast a negative value, you must enclose the value in parentheses");
 					return null;
 				}
 			} else
 				left = left.Resolve (ec);
 
 			if (left == null)
 				return null;
 
 			Constant lc = left as Constant;
 
 			if (lc != null && lc.Type == TypeManager.bool_type &&
 				((oper == Operator.LogicalAnd && lc.IsDefaultValue) ||
 				 (oper == Operator.LogicalOr && !lc.IsDefaultValue))) {
 
 				// FIXME
 				// right.Resolve (ec);
 
 				ec.Report.Warning (429, 4, loc, "Unreachable expression code detected");
 				return left;
 			}
 
 			right = right.Resolve (ec);
 			if (right == null)
 				return null;
 
 			eclass = ExprClass.Value;
 			Constant rc = right as Constant;
 
 			// The conversion rules are ignored in enum context but why
 			if (!ec.HasSet (ResolveContext.Options.EnumScope) && lc != null && rc != null && (TypeManager.IsEnumType (left.Type) || TypeManager.IsEnumType (right.Type))) {
 				lc = EnumLiftUp (ec, lc, rc, loc);
 				if (lc != null)
 					rc = EnumLiftUp (ec, rc, lc, loc);
 			}
 
 			if (rc != null && lc != null) {
 				int prev_e = ec.Report.Errors;
 				Expression e = ConstantFold.BinaryFold (ec, oper, lc, rc, loc);
 				if (e != null)
 					e = e.Resolve (ec);
 
 				if (e != null || ec.Report.Errors != prev_e)
 					return e;
 			}
 
 			// Comparison warnings
 			if ((oper & Operator.ComparisonMask) != 0) {
 				if (left.Equals (right)) {
 					ec.Report.Warning (1718, 3, loc, "A comparison made to same variable. Did you mean to compare something else?");
 				}
 				CheckUselessComparison (ec, lc, right.Type);
 				CheckUselessComparison (ec, rc, left.Type);
 			}
 
 			if (left.Type == InternalType.Dynamic || right.Type == InternalType.Dynamic) {
 				var lt = left.Type;
 				var rt = right.Type;
 				if (lt == TypeManager.void_type || lt == InternalType.MethodGroup || lt == InternalType.AnonymousMethod ||
 					rt == TypeManager.void_type || rt == InternalType.MethodGroup || rt == InternalType.AnonymousMethod) {
 					Error_OperatorCannotBeApplied (ec, left, right);
 					return null;
 				}
 
 				Arguments args;
 
 				//
 				// Special handling for logical boolean operators which require rhs not to be
 				// evaluated based on lhs value
 				//
 				if ((oper & Operator.LogicalMask) != 0) {
 					Expression cond_left, cond_right, expr;
 
 					args = new Arguments (2);
 
 					if (lt == InternalType.Dynamic) {
 						LocalVariable temp = LocalVariable.CreateCompilerGenerated (lt, ec.CurrentBlock, loc);
 
 						var cond_args = new Arguments (1);
 						cond_args.Add (new Argument (new SimpleAssign (temp.CreateReferenceExpression (ec, loc), left).Resolve (ec)));
 
 						//
 						// dynamic && bool => IsFalse (temp = left) ? temp 
 						// dynamic || bool => IsTrue (temp = left) ? temp 
 						//
 						left = temp.CreateReferenceExpression (ec, loc);
 						if (oper == Operator.LogicalAnd) {
 							expr = DynamicUnaryConversion.CreateIsFalse (cond_args, loc);
 							cond_left = left;
 						} else {
 							expr = DynamicUnaryConversion.CreateIsTrue (cond_args, loc);
 							cond_left = left;
 						}
 
 						args.Add (new Argument (left));
 						args.Add (new Argument (right));
 						cond_right = new DynamicExpressionStatement (this, args, loc);
 					} else {
 						LocalVariable temp = LocalVariable.CreateCompilerGenerated (TypeManager.bool_type, ec.CurrentBlock, loc);
 
 						args.Add (new Argument (temp.CreateReferenceExpression (ec, loc).Resolve (ec)));
 						args.Add (new Argument (right));
 						right = new DynamicExpressionStatement (this, args, loc);
 
 						//
 						// bool && dynamic => (temp = left) ? temp && right 
 						// bool || dynamic => (temp = left) ? temp 
 						//
 						if (oper == Operator.LogicalAnd) {
 							cond_left = right;
 							cond_right = temp.CreateReferenceExpression (ec, loc);
 						} else {
 							cond_left = temp.CreateReferenceExpression (ec, loc);
 							cond_right = right;
 						}
 
 						expr = new BooleanExpression (new SimpleAssign (temp.CreateReferenceExpression (ec, loc), left));
 					}
 
 					return new Conditional (expr, cond_left, cond_right, loc).Resolve (ec);
 				}
 
 				args = new Arguments (2);
 				args.Add (new Argument (left));
 				args.Add (new Argument (right));
 				return new DynamicExpressionStatement (this, args, loc).Resolve (ec);
 			}
 
 			if (RootContext.Version >= LanguageVersion.ISO_2 &&
 				((TypeManager.IsNullableType (left.Type) && (right is NullLiteral || TypeManager.IsNullableType (right.Type) || TypeManager.IsValueType (right.Type))) ||
 				(TypeManager.IsValueType (left.Type) && right is NullLiteral) ||
 				(TypeManager.IsNullableType (right.Type) && (left is NullLiteral || TypeManager.IsNullableType (left.Type) || TypeManager.IsValueType (left.Type))) ||
 				(TypeManager.IsValueType (right.Type) && left is NullLiteral))) {
 				var lifted = new Nullable.LiftedBinaryOperator (oper, left, right, loc);
 				lifted.state = state;
 				return lifted.Resolve (ec);
 			}
 
 			return DoResolveCore (ec, left, right);
 		}
 
 		protected Expression DoResolveCore (ResolveContext ec, Expression left_orig, Expression right_orig)
 		{
 			Expression expr = ResolveOperator (ec);
 			if (expr == null)
 				Error_OperatorCannotBeApplied (ec, left_orig, right_orig);
 
 			if (left == null || right == null)
 				throw new InternalErrorException ("Invalid conversion");
 
 			if (oper == Operator.BitwiseOr)
 				CheckBitwiseOrOnSignExtended (ec);
 
 			return expr;
 		}
 
 		public override SLE.Expression MakeExpression (BuilderContext ctx)
 		{
 			var le = left.MakeExpression (ctx);
 			var re = right.MakeExpression (ctx);
 			bool is_checked = ctx.HasSet (BuilderContext.Options.CheckedScope);
 
 			switch (oper) {
 			case Operator.Addition
 				return is_checked ? SLE.Expression.AddChecked (le, re) 
 			case Operator.BitwiseAnd
 				return SLE.Expression.And (le, re);
 			case Operator.BitwiseOr
 				return SLE.Expression.Or (le, re);
 			case Operator.Division
 				return SLE.Expression.Divide (le, re);
 			case Operator.Equality
 				return SLE.Expression.Equal (le, re);
 			case Operator.ExclusiveOr
 				return SLE.Expression.ExclusiveOr (le, re);
 			case Operator.GreaterThan
 				return SLE.Expression.GreaterThan (le, re);
 			case Operator.GreaterThanOrEqual
 				return SLE.Expression.GreaterThanOrEqual (le, re);
 			case Operator.Inequality
 				return SLE.Expression.NotEqual (le, re);
 			case Operator.LeftShift
 				return SLE.Expression.LeftShift (le, re);
 			case Operator.LessThan
 				return SLE.Expression.LessThan (le, re);
 			case Operator.LessThanOrEqual
 				return SLE.Expression.LessThanOrEqual (le, re);
 			case Operator.LogicalAnd
 				return SLE.Expression.AndAlso (le, re);
 			case Operator.LogicalOr
 				return SLE.Expression.OrElse (le, re);
 			case Operator.Modulus
 				return SLE.Expression.Modulo (le, re);
 			case Operator.Multiply
 				return is_checked ? SLE.Expression.MultiplyChecked (le, re) 
 			case Operator.RightShift
 				return SLE.Expression.RightShift (le, re);
 			case Operator.Subtraction
 				return is_checked ? SLE.Expression.SubtractChecked (le, re) 
 			default
 				throw new NotImplementedException (oper.ToString ());
 			}
 		}
 
 		//
 		// D operator + (D x, D y)
 		// D operator - (D x, D y)
 		//
 		Expression ResolveOperatorDelegate (ResolveContext ec, TypeSpec l, TypeSpec r)
 		{
 			if (l != r && !TypeSpecComparer.Variant.IsEqual (r, l)) {
 				Expression tmp;
 				if (right.eclass == ExprClass.MethodGroup || r == InternalType.AnonymousMethod || r == InternalType.Null) {
 					tmp = Convert.ImplicitConversionRequired (ec, right, l, loc);
 					if (tmp == null)
 						return null;
 					right = tmp;
 					r = right.Type;
 				} else if (left.eclass == ExprClass.MethodGroup || (l == InternalType.AnonymousMethod || l == InternalType.Null)) {
 					tmp = Convert.ImplicitConversionRequired (ec, left, r, loc);
 					if (tmp == null)
 						return null;
 					left = tmp;
 					l = left.Type;
 				} else {
 					return null;
 				}
 			}
 
 			MethodSpec method;
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (left));
 			args.Add (new Argument (right));
 
 			if (oper == Operator.Addition) {
 				if (TypeManager.delegate_combine_delegate_delegate == null) {
 					TypeManager.delegate_combine_delegate_delegate = TypeManager.GetPredefinedMethod (
 						TypeManager.delegate_type, "Combine", loc, TypeManager.delegate_type, TypeManager.delegate_type);
 				}
 
 				method = TypeManager.delegate_combine_delegate_delegate;
 			} else if (oper == Operator.Subtraction) {
 				if (TypeManager.delegate_remove_delegate_delegate == null) {
 					TypeManager.delegate_remove_delegate_delegate = TypeManager.GetPredefinedMethod (
 						TypeManager.delegate_type, "Remove", loc, TypeManager.delegate_type, TypeManager.delegate_type);
 				}
 
 				method = TypeManager.delegate_remove_delegate_delegate;
 			} else {
 				return new EmptyExpression (TypeManager.decimal_type);
 			}
 
 			MethodGroupExpr mg = MethodGroupExpr.CreatePredefined (method, TypeManager.delegate_type, loc);
 			Expression expr = new UserOperatorCall (mg.BestCandidate, args, CreateExpressionTree, loc);
 			return new ClassCast (expr, l);
 		}
 
 		//
 		// Enumeration operators
 		//
 		Expression ResolveOperatorEnum (ResolveContext ec, bool lenum, bool renum, TypeSpec ltype, TypeSpec rtype)
 		{
 			//
 			// bool operator == (E x, E y);
 			// bool operator != (E x, E y);
 			// bool operator < (E x, E y);
 			// bool operator > (E x, E y);
 			// bool operator <= (E x, E y);
 			// bool operator >= (E x, E y);
 			//
 			// E operator & (E x, E y);
 			// E operator | (E x, E y);
 			// E operator ^ (E x, E y);
 			//
 			// U operator - (E e, E f)
 			// E operator - (E e, U x)
 			// E operator - (U x, E e)	// LAMESPEC
 			//
 			// E operator + (E e, U x)
 			// E operator + (U x, E e)
 			//
 			Expression ltemp = left;
 			Expression rtemp = right;
 			TypeSpec underlying_type;
 			TypeSpec underlying_type_result;
 			TypeSpec res_type;
 			Expression expr;
 			
 			//
 			// LAMESPEC
 			// the one which contains more enum parameters always wins even if there
 			// is an implicit conversion involved
 			//
 			if ((oper & (Operator.ComparisonMask | Operator.BitwiseMask)) != 0) {
 				if (renum) {
 					underlying_type = EnumSpec.GetUnderlyingType (rtype);
 					expr = Convert.ImplicitConversion (ec, left, rtype, loc);
 					if (expr == null)
 						return null;
 
 					left = expr;
 					ltype = expr.Type;
 				} else if (lenum) {
 					underlying_type = EnumSpec.GetUnderlyingType (ltype);
 					expr = Convert.ImplicitConversion (ec, right, ltype, loc);
 					if (expr == null)
 						return null;
 
 					right = expr;
 					rtype = expr.Type;
 				} else {
 					return null;
 				}
 
 				if ((oper & Operator.BitwiseMask) != 0) {
 					res_type = ltype;
 					underlying_type_result = underlying_type;
 				} else {
 					res_type = null;
 					underlying_type_result = null;
 				}
 			} else if (oper == Operator.Subtraction) {
 				if (renum) {
 					underlying_type = EnumSpec.GetUnderlyingType (rtype);
 					if (ltype != rtype) {
 						expr = Convert.ImplicitConversion (ec, left, rtype, left.Location);
 						if (expr == null) {
 							expr = Convert.ImplicitConversion (ec, left, underlying_type, left.Location);
 							if (expr == null)
 								return null;
 
 							res_type = rtype;
 						} else {
 							res_type = underlying_type;
 						}
 
 						left = expr;
 					} else {
 						res_type = underlying_type;
 					}
 
 					underlying_type_result = underlying_type;
 				} else if (lenum) {
 					underlying_type = EnumSpec.GetUnderlyingType (ltype);
 					expr = Convert.ImplicitConversion (ec, right, ltype, right.Location);
 					if (expr == null || expr is EnumConstant) {
 						expr = Convert.ImplicitConversion (ec, right, underlying_type, right.Location);
 						if (expr == null)
 							return null;
 
 						res_type = ltype;
 					} else {
 						res_type = underlying_type;
 					}
 
 					right = expr;
 					underlying_type_result = underlying_type;
 				} else {
 					return null;
 				}
 			} else if (oper == Operator.Addition) {
 				if (lenum) {
 					underlying_type = EnumSpec.GetUnderlyingType (ltype);
 					res_type = ltype;
 
 					if (rtype != underlying_type && (state & (State.RightNullLifted | State.LeftNullLifted)) == 0) {
 						expr = Convert.ImplicitConversion (ec, right, underlying_type, right.Location);
 						if (expr == null)
 							return null;
 
 						right = expr;
 					}
 				} else {
 					underlying_type = EnumSpec.GetUnderlyingType (rtype);
 					res_type = rtype;
 					if (ltype != underlying_type) {
 						expr = Convert.ImplicitConversion (ec, left, underlying_type, left.Location);
 						if (expr == null)
 							return null;
 
 						left = expr;
 					}
 				}
 
 				underlying_type_result = underlying_type;
 			} else {
 				return null;
 			}
 
 			// Unwrap the constant correctly, so DoBinaryOperatorPromotion can do the magic
 			// with constants and expressions
 			if (left.Type != underlying_type) {
 				if (left is Constant)
 					left = ((Constant) left).ConvertExplicitly (false, underlying_type).Resolve (ec);
 				else
 					left = EmptyCast.Create (left, underlying_type);
 			}
 
 			if (right.Type != underlying_type) {
 				if (right is Constant)
 					right = ((Constant) right).ConvertExplicitly (false, underlying_type).Resolve (ec);
 				else
 					right = EmptyCast.Create (right, underlying_type);
 			}
 
 			//
 			// C# specification uses explicit cast syntax which means binary promotion
 			// should happen, however it seems that csc does not do that
 			//
 			if (!DoBinaryOperatorPromotion (ec)) {
 				left = ltemp;
 				right = rtemp;
 				return null;
 			}
 
 			if (underlying_type_result != null && left.Type != underlying_type_result) {
 				enum_conversion = Convert.ExplicitNumericConversion (new EmptyExpression (left.Type), underlying_type_result);
 			}
 
 			expr = ResolveOperatorPredefined (ec, standard_operators, true, res_type);
 			if (expr == null)
 				return null;
 
 			if (!IsCompound)
 				return expr;
 
 			//
 			// Section
 			//
 
 			//
 			// If the return type of the selected operator is implicitly convertible to the type of x
 			//
 			if (Convert.ImplicitConversionExists (ec, expr, ltype))
 				return expr;
 
 			//
 			// Otherwise, if the selected operator is a predefined operator, if the return type of the
 			// selected operator is explicitly convertible to the type of x, and if y is implicitly
 			// convertible to the type of x or the operator is a shift operator, then the operation
 			// is evaluated as x = (T)(x op y), where T is the type of x
 			//
 			expr = Convert.ExplicitConversion (ec, expr, ltype, loc);
 			if (expr == null)
 				return null;
 
 			if (Convert.ImplicitConversionExists (ec, ltemp, ltype))
 				return expr;
 
 			return null;
 		}
 
 		//
 		// 7.9.6 Reference type equality operators
 		//
 		Expression ResolveOperatorEquality (ResolveContext ec, TypeSpec l, TypeSpec r)
 		{
 			Expression result;
 			type = TypeManager.bool_type;
 
 			//
 			// a, Both operands are reference-type values or the value null
 			// b, One operand is a value of type T where T is a type-parameter and
 			// the other operand is the value null. Furthermore T does not have the
 			// value type constraint
 			//
 			// LAMESPEC
 			// reference like type-parameter is allowed
 			//
 			var tparam_l = l as TypeParameterSpec;
 			var tparam_r = r as TypeParameterSpec;
 			if (tparam_l != null) {
 				if (right is NullLiteral && !tparam_l.HasSpecialStruct) {
 					left = new BoxedCast (left, TypeManager.object_type);
 					return this;
 				}
 
 				if (!tparam_l.IsReferenceType)
 					return null;
 
 				l = tparam_l.GetEffectiveBase ();
 				left = new BoxedCast (left, l);
 			} else if (left is NullLiteral && tparam_r == null) {
 				if (!TypeManager.IsReferenceType (r) || r.Kind == MemberKind.InternalCompilerType)
 					return null;
 
 				return this;
 			}
 
 			if (tparam_r != null) {
 				if (left is NullLiteral && !tparam_r.HasSpecialStruct) {
 					right = new BoxedCast (right, TypeManager.object_type);
 					return this;
 				}
 
 				if (!tparam_r.IsReferenceType)
 					return null;
 
 				r = tparam_r.GetEffectiveBase ();
 				right = new BoxedCast (right, r);
 			} else if (right is NullLiteral) {
 				if (!TypeManager.IsReferenceType (l) || l.Kind == MemberKind.InternalCompilerType)
 					return null;
 
 				return this;
 			}
 
 			//
 			// LAMESPEC
 			//
 			if (l.IsDelegate) {
 				if (right.eclass == ExprClass.MethodGroup) {
 					result = Convert.ImplicitConversion (ec, right, l, loc);
 					if (result == null)
 						return null;
 
 					right = result;
 					r = l;
 				} else if (r.IsDelegate && l != r) {
 					return null;
 				}
 			} else if (left.eclass == ExprClass.MethodGroup && r.IsDelegate) {
 				result = Convert.ImplicitConversionRequired (ec, left, r, loc);
 				if (result == null)
 					return null;
 
 				left = result;
 				l = r;
 			}
 
 			//
 			// bool operator != (string a, string b)
 			// bool operator == (string a, string b)
 			//
 			// bool operator != (Delegate a, Delegate b)
 			// bool operator == (Delegate a, Delegate b)
 			//
 			// bool operator != (bool a, bool b)
 			// bool operator == (bool a, bool b)
 			//
 			// LAMESPEC
 			// they implement an implicit conversion to any of types above.
 			//
 			if (r != TypeManager.object_type && l != TypeManager.object_type) {
 				result = ResolveOperatorPredefined (ec, equality_operators, false, null);
 				if (result != null)
 					return result;
 			}
 
 			//
 			// bool operator != (object a, object b)
 			// bool operator == (object a, object b)
 			//
 			// An explicit reference conversion exists from the
 			// type of either operand to the type of the other operand.
 			//
 
 			// Optimize common path
 			if (l == r) {
 				return l.Kind == MemberKind.InternalCompilerType || l.Kind == MemberKind.Struct ? null 
 			}
 
 			if (!Convert.ExplicitReferenceConversionExists (l, r) &&
 				!Convert.ExplicitReferenceConversionExists (r, l))
 				return null;
 
 			// Reject allowed explicit conversions like int->object
 			if (!TypeManager.IsReferenceType (l) || !TypeManager.IsReferenceType (r))
 				return null;
 
 			if (l == TypeManager.string_type || l == TypeManager.delegate_type || MemberCache.GetUserOperator (l, CSharp.Operator.OpType.Equality, false) != null)
 				ec.Report.Warning (253, 2, loc,
 					"Possible unintended reference comparison. Consider casting the right side expression to type `{0}' to get value comparison",
 					l.GetSignatureForError ());
 
 			if (r == TypeManager.string_type || r == TypeManager.delegate_type || MemberCache.GetUserOperator (r, CSharp.Operator.OpType.Equality, false) != null)
 				ec.Report.Warning (252, 2, loc,
 					"Possible unintended reference comparison. Consider casting the left side expression to type `{0}' to get value comparison",
 					r.GetSignatureForError ());
 
 			return this;
 		}
 
 
 		Expression ResolveOperatorPointer (ResolveContext ec, TypeSpec l, TypeSpec r)
 		{
 			//
 			// bool operator == (void* x, void* y);
 			// bool operator != (void* x, void* y);
 			// bool operator < (void* x, void* y);
 			// bool operator > (void* x, void* y);
 			// bool operator <= (void* x, void* y);
 			// bool operator >= (void* x, void* y);
 			//
 			if ((oper & Operator.ComparisonMask) != 0) {
 				Expression temp;
 				if (!l.IsPointer) {
 					temp = Convert.ImplicitConversion (ec, left, r, left.Location);
 					if (temp == null)
 						return null;
 					left = temp;
 				}
 
 				if (!r.IsPointer) {
 					temp = Convert.ImplicitConversion (ec, right, l, right.Location);
 					if (temp == null)
 						return null;
 					right = temp;
 				}
 
 				type = TypeManager.bool_type;
 				return this;
 			}
 
 			if (pointer_operators == null)
 				CreatePointerOperatorsTable ();
 
 			return ResolveOperatorPredefined (ec, pointer_operators, false, null);
 		}
 
 		//
 		// Build-in operators method overloading
 		//
 		protected virtual Expression ResolveOperatorPredefined (ResolveContext ec, PredefinedOperator [] operators, bool primitives_only, TypeSpec enum_type)
 		{
 			PredefinedOperator best_operator = null;
 			TypeSpec l = left.Type;
 			TypeSpec r = right.Type;
 			Operator oper_mask = oper & ~Operator.ValuesOnlyMask;
 
 			foreach (PredefinedOperator po in operators) {
 				if ((po.OperatorsMask & oper_mask) == 0)
 					continue;
 
 				if (primitives_only) {
 					if (!po.IsPrimitiveApplicable (l, r))
 						continue;
 				} else {
 					if (!po.IsApplicable (ec, left, right))
 						continue;
 				}
 
 				if (best_operator == null) {
 					best_operator = po;
 					if (primitives_only)
 						break;
 
 					continue;
 				}
 
 				best_operator = po.ResolveBetterOperator (ec, best_operator);
 
 				if (best_operator == null) {
 					ec.Report.Error (34, loc, "Operator `{0}' is ambiguous on operands of type `{1}' and `{2}'",
 						OperName (oper), TypeManager.CSharpName (l), TypeManager.CSharpName (r));
 
 					best_operator = po;
 					break;
 				}
 			}
 
 			if (best_operator == null)
 				return null;
 
 			Expression expr = best_operator.ConvertResult (ec, this);
 
 			//
 			// Optimize &/&& constant expressions with 0 value
 			//
 			if (oper == Operator.BitwiseAnd || oper == Operator.LogicalAnd) {
 				Constant rc = right as Constant;
 				Constant lc = left as Constant;
 				if (((lc != null && lc.IsDefaultValue) || (rc != null && rc.IsDefaultValue)) && !(this is Nullable.LiftedBinaryOperator)) {
 					//
 					// The result is a constant with side-effect
 					//
 					Constant side_effect = rc == null ?
 						new SideEffectConstant (lc, right, loc) 
 						new SideEffectConstant (rc, left, loc);
 
 					return ReducedExpression.Create (side_effect.Resolve (ec), expr);
 				}
 			}
 
 			if (enum_type == null)
 				return expr;
 
 			//
 			// HACK
 			//
 			expr.Type = enum_type;
 			return EmptyCast.Create (expr, enum_type);
 		}
 
 		//
 		// Performs user-operator overloading
 		//
 		protected virtual Expression ResolveUserOperator (ResolveContext ec, Expression left, Expression right)
 		{
 			var op = ConvertBinaryToUserOperator (oper);
 			var l = left.Type;
 			if (TypeManager.IsNullableType (l))
 				l = Nullable.NullableInfo.GetUnderlyingType (l);
 			var r = right.Type;
 			if (TypeManager.IsNullableType (r))
 				r = Nullable.NullableInfo.GetUnderlyingType (r);
 
 			IList<MemberSpec> left_operators = MemberCache.GetUserOperator (l, op, false);
 			IList<MemberSpec> right_operators = null;
 
 			if (l != r) {
 				right_operators = MemberCache.GetUserOperator (r, op, false);
 				if (right_operators == null && left_operators == null)
 					return null;
 			} else if (left_operators == null) {
 				return null;
 			}
 
 			Arguments args = new Arguments (2);
 			Argument larg = new Argument (left);
 			args.Add (larg);
 			Argument rarg = new Argument (right);
 			args.Add (rarg);
 
 			//
 			// User-defined operator implementations always take precedence
 			// over predefined operator implementations
 			//
 			if (left_operators != null && right_operators != null) {
 				left_operators = CombineUserOperators (left_operators, right_operators);
 			} else if (right_operators != null) {
 				left_operators = right_operators;
 			}
 
 			var res = new OverloadResolver (left_operators, OverloadResolver.Restrictions.ProbingOnly | 
 				OverloadResolver.Restrictions.NoBaseMembers | OverloadResolver.Restrictions.BaseMembersIncluded, loc);
 
 			var oper_method = res.ResolveOperator (ec, ref args);
 			if (oper_method == null)
 				return null;
 
 			var llifted = (state & State.LeftNullLifted) != 0;
 			var rlifted = (state & State.RightNullLifted) != 0;
 			if ((Oper & Operator.EqualityMask) != 0) {
 				var parameters = oper_method.Parameters;
 				// LAMESPEC
 				if ((left is Nullable.Unwrap || right is Nullable.Unwrap) && parameters.Types [0] != parameters.Types [1])
 					return null;
 
 				// Binary operation was lifted but we have found a user operator
 				// which requires value-type argument, we downgrade ourself back to
 				// binary operation
 				// LAMESPEC
 				// but compilation succeeds
 				if ((llifted && !parameters.Types[0].IsStruct) || (rlifted && !parameters.Types[1].IsStruct)) {
 					state &= ~(State.LeftNullLifted | State.RightNullLifted);
 				}
 			}
 
 			Expression oper_expr;
 
 			// TODO
 			if ((oper & Operator.LogicalMask) != 0) {
 				oper_expr = new ConditionalLogicalOperator (oper_method, args, CreateExpressionTree,
 					oper == Operator.LogicalAnd, loc).Resolve (ec);
 			} else {
 				oper_expr = new UserOperatorCall (oper_method, args, CreateExpressionTree, loc);
 			}
 
 			if (!llifted)
 				this.left = larg.Expr;
 
 			if (!rlifted)
 				this.right = rarg.Expr;
 
 			return oper_expr;
 		}
 
 		//
 		// Merge two sets of user operators into one, they are mostly distinguish
 		// expect when they share base type and it contains an operator
 		//
 		static IList<MemberSpec> CombineUserOperators (IList<MemberSpec> left, IList<MemberSpec> right)
 		{
 			var combined = new List<MemberSpec> (left.Count + right.Count);
 			combined.AddRange (left);
 			foreach (var r in right) {
 				bool same = false;
 				foreach (var l in left) {
 					if (l.DeclaringType == r.DeclaringType) {
 						same = true;
 						break;
 					}
 				}
 
 				if (!same)
 					combined.Add (r);
 			}
 
 			return combined;
 		}
 
 		public override TypeExpr ResolveAsTypeTerminal (IMemberContext ec, bool silent)
 		{
 			return null;
 		}
 
 		private void CheckUselessComparison (ResolveContext ec, Constant c, TypeSpec type)
 		{
 			if (c == null || !IsTypeIntegral (type)
 				|| c is StringConstant
 				|| c is BoolConstant
 				|| c is FloatConstant
 				|| c is DoubleConstant
 				|| c is DecimalConstant
 				)
 				return;
 
 			long value = 0;
 
 			if (c is ULongConstant) {
 				ulong uvalue = ((ULongConstant) c).Value;
 				if (uvalue > long.MaxValue) {
 					if (type == TypeManager.byte_type ||
 					    type == TypeManager.sbyte_type ||
 					    type == TypeManager.short_type ||
 					    type == TypeManager.ushort_type ||
 					    type == TypeManager.int32_type ||
 					    type == TypeManager.uint32_type ||
 					    type == TypeManager.int64_type ||
 						type == TypeManager.char_type)
 						WarnUselessComparison (ec, type);
 					return;
 				}
 				value = (long) uvalue;
 			}
 			else if (c is ByteConstant)
 				value = ((ByteConstant) c).Value;
 			else if (c is SByteConstant)
 				value = ((SByteConstant) c).Value;
 			else if (c is ShortConstant)
 				value = ((ShortConstant) c).Value;
 			else if (c is UShortConstant)
 				value = ((UShortConstant) c).Value;
 			else if (c is IntConstant)
 				value = ((IntConstant) c).Value;
 			else if (c is UIntConstant)
 				value = ((UIntConstant) c).Value;
 			else if (c is LongConstant)
 				value = ((LongConstant) c).Value;
 			else if (c is CharConstant)
 				value = ((CharConstant)c).Value;
 
 			if (value == 0)
 				return;
 
 			if (IsValueOutOfRange (value, type))
 				WarnUselessComparison (ec, type);
 		}
 
 		static bool IsValueOutOfRange (long value, TypeSpec type)
 		{
 			if (IsTypeUnsigned (type) && value < 0)
 				return true;
 			return type == TypeManager.sbyte_type && (value >= 0x80 || value < -0x80) ||
 				type == TypeManager.byte_type && value >= 0x100 ||
 				type == TypeManager.short_type && (value >= 0x8000 || value < -0x8000) ||
 				type == TypeManager.ushort_type && value >= 0x10000 ||
 				type == TypeManager.int32_type && (value >= 0x80000000 || value < -0x80000000) ||
 				type == TypeManager.uint32_type && value >= 0x100000000;
 		}
 
 		private static bool IsTypeIntegral (TypeSpec type)
 		{
 			return type == TypeManager.uint64_type ||
 				type == TypeManager.int64_type ||
 				type == TypeManager.uint32_type ||
 				type == TypeManager.int32_type ||
 				type == TypeManager.ushort_type ||
 				type == TypeManager.short_type ||
 				type == TypeManager.sbyte_type ||
 				type == TypeManager.byte_type ||
 				type == TypeManager.char_type;
 		}
 
 		private static bool IsTypeUnsigned (TypeSpec type)
 		{
 			return type == TypeManager.uint64_type ||
 				type == TypeManager.uint32_type ||
 				type == TypeManager.ushort_type ||
 				type == TypeManager.byte_type ||
 				type == TypeManager.char_type;
 		}
 
 		private void WarnUselessComparison (ResolveContext ec, TypeSpec type)
 		{
 			ec.Report.Warning (652, 2, loc, "A comparison between a constant and a variable is useless. The constant is out of the range of the variable type `{0}'",
 				TypeManager.CSharpName (type));
 		}
 
 		/// <remarks>
 		///   EmitBranchable is called from Statement.EmitBoolExpression in the
 		///   context of a conditional bool expression.  This function will return
 		///   false if it is was possible to use EmitBranchable, or true if it was.
 		///
 		///   The expression's code is generated, and we will generate a branch to `target'
 		///   if the resulting expression value is equal to isTrue
 		/// </remarks>
 		public override void EmitBranchable (EmitContext ec, Label target, bool on_true)
 		{
 			//
 			// This is more complicated than it looks, but its just to avoid
 			// duplicated tests
 			// but on top of that we want for == and != to use a special path
 			// if we are comparing against null
 			//
 			if ((oper & Operator.EqualityMask) != 0 && (left is Constant || right is Constant)) {
 				bool my_on_true = oper == Operator.Inequality ? on_true 
 				
 				//
 				// put the constant on the rhs, for simplicity
 				//
 				if (left is Constant) {
 					Expression swap = right;
 					right = left;
 					left = swap;
 				}
 				
 				//
 				// brtrue/brfalse works with native int only
 				//
 				if (((Constant) right).IsZeroInteger && right.Type != TypeManager.int64_type && right.Type != TypeManager.uint64_type) {
 					left.EmitBranchable (ec, target, my_on_true);
 					return;
 				}
 				if (right.Type == TypeManager.bool_type) {
 					// right is a boolean, and it's not 'false' => it is 'true'
 					left.EmitBranchable (ec, target, !my_on_true);
 					return;
 				}
 
 			} else if (oper == Operator.LogicalAnd) {
 
 				if (on_true) {
 					Label tests_end = ec.DefineLabel ();
 					
 					left.EmitBranchable (ec, tests_end, false);
 					right.EmitBranchable (ec, target, true);
 					ec.MarkLabel (tests_end);					
 				} else {
 					//
 					// This optimizes code like this 
 					// if (true && i > 4)
 					//
 					if (!(left is Constant))
 						left.EmitBranchable (ec, target, false);
 
 					if (!(right is Constant)) 
 						right.EmitBranchable (ec, target, false);
 				}
 				
 				return;
 				
 			} else if (oper == Operator.LogicalOr){
 				if (on_true) {
 					left.EmitBranchable (ec, target, true);
 					right.EmitBranchable (ec, target, true);
 					
 				} else {
 					Label tests_end = ec.DefineLabel ();
 					left.EmitBranchable (ec, tests_end, true);
 					right.EmitBranchable (ec, target, false);
 					ec.MarkLabel (tests_end);
 				}
 				
 				return;
 
 			} else if ((oper & Operator.ComparisonMask) == 0) {
 				base.EmitBranchable (ec, target, on_true);
 				return;
 			}
 			
 			left.Emit (ec);
 			right.Emit (ec);
 
 			TypeSpec t = left.Type;
 			bool is_float = IsFloat (t);
 			bool is_unsigned = is_float || IsUnsigned (t);
 			
 			switch (oper){
 			case Operator.Equality
 				if (on_true)
 					ec.Emit (OpCodes.Beq, target);
 				else
 					ec.Emit (OpCodes.Bne_Un, target);
 				break;
 
 			case Operator.Inequality
 				if (on_true)
 					ec.Emit (OpCodes.Bne_Un, target);
 				else
 					ec.Emit (OpCodes.Beq, target);
 				break;
 
 			case Operator.LessThan
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Blt_Un, target);
 					else
 						ec.Emit (OpCodes.Blt, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Bge_Un, target);
 					else
 						ec.Emit (OpCodes.Bge, target);
 				break;
 
 			case Operator.GreaterThan
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Bgt_Un, target);
 					else
 						ec.Emit (OpCodes.Bgt, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Ble_Un, target);
 					else
 						ec.Emit (OpCodes.Ble, target);
 				break;
 
 			case Operator.LessThanOrEqual
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Ble_Un, target);
 					else
 						ec.Emit (OpCodes.Ble, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Bgt_Un, target);
 					else
 						ec.Emit (OpCodes.Bgt, target);
 				break;
 
 
 			case Operator.GreaterThanOrEqual
 				if (on_true)
 					if (is_unsigned && !is_float)
 						ec.Emit (OpCodes.Bge_Un, target);
 					else
 						ec.Emit (OpCodes.Bge, target);
 				else
 					if (is_unsigned)
 						ec.Emit (OpCodes.Blt_Un, target);
 					else
 						ec.Emit (OpCodes.Blt, target);
 				break;
 			default
 				throw new InternalErrorException (oper.ToString ());
 			}
 		}
 		
 		public override void Emit (EmitContext ec)
 		{
 			EmitOperator (ec, left.Type);
 		}
 
 		protected virtual void EmitOperator (EmitContext ec, TypeSpec l)
 		{
 			//
 			// Handle short-circuit operators differently
 			// than the rest
 			//
 			if ((oper & Operator.LogicalMask) != 0) {
 				Label load_result = ec.DefineLabel ();
 				Label end = ec.DefineLabel ();
 
 				bool is_or = oper == Operator.LogicalOr;
 				left.EmitBranchable (ec, load_result, is_or);
 				right.Emit (ec);
 				ec.Emit (OpCodes.Br_S, end);
 				
 				ec.MarkLabel (load_result);
 				ec.Emit (is_or ? OpCodes.Ldc_I4_1 
 				ec.MarkLabel (end);
 				return;
 			}
 
 			//
 			// Optimize zero-based operations which cannot be optimized at expression level
 			//
 			if (oper == Operator.Subtraction) {
 				var lc = left as IntegralConstant;
 				if (lc != null && lc.IsDefaultValue) {
 					right.Emit (ec);
 					ec.Emit (OpCodes.Neg);
 					return;
 				}
 			}
 
 			left.Emit (ec);
 			right.Emit (ec);
 			EmitOperatorOpcode (ec, oper, l);
 
 			//
 			// Nullable enum could require underlying type cast and we cannot simply wrap binary
 			// expression because that would wrap lifted binary operation
 			//
 			if (enum_conversion != null)
 				enum_conversion.Emit (ec);
 		}
 
 		public override void EmitSideEffect (EmitContext ec)
 		{
 			if ((oper & Operator.LogicalMask) != 0 ||
 				(ec.HasSet (EmitContext.Options.CheckedScope) && (oper == Operator.Multiply || oper == Operator.Addition || oper == Operator.Subtraction))) {
 				base.EmitSideEffect (ec);
 			} else {
 				left.EmitSideEffect (ec);
 				right.EmitSideEffect (ec);
 			}
 		}
 
 		protected override void CloneTo (CloneContext clonectx, Expression t)
 		{
 			Binary target = (Binary) t;
 
 			target.left = left.Clone (clonectx);
 			target.right = right.Clone (clonectx);
 		}
 
 		public Expression CreateCallSiteBinder (ResolveContext ec, Arguments args)
 		{
 			Arguments binder_args = new Arguments (4);
 
 			MemberAccess sle = new MemberAccess (new MemberAccess (
 				new QualifiedAliasMember (QualifiedAliasMember.GlobalAlias, "System", loc), "Linq", loc), "Expressions", loc);
 
 			CSharpBinderFlags flags = 0;
 			if (ec.HasSet (ResolveContext.Options.CheckedScope))
 				flags = CSharpBinderFlags.CheckedContext;
 
 			if ((oper & Operator.LogicalMask) != 0)
 				flags |= CSharpBinderFlags.BinaryOperationLogical;
 
 			binder_args.Add (new Argument (new EnumConstant (new IntLiteral ((int) flags, loc), ec.Module.PredefinedTypes.BinderFlags.Resolve (loc))));
 			binder_args.Add (new Argument (new MemberAccess (new MemberAccess (sle, "ExpressionType", loc), GetOperatorExpressionTypeName (), loc)));
 			binder_args.Add (new Argument (new TypeOf (new TypeExpression (ec.CurrentType, loc), loc)));									
 			binder_args.Add (new Argument (new ImplicitlyTypedArrayCreation (args.CreateDynamicBinderArguments (ec), loc)));
 
 			return new Invocation (new MemberAccess (new TypeExpression (ec.Module.PredefinedTypes.Binder.TypeSpec, loc), "BinaryOperation", loc), binder_args);
 		}
 		
 		public override Expression CreateExpressionTree (ResolveContext ec)
 		{
 			return CreateExpressionTree (ec, null);
 		}
 
 		Expression CreateExpressionTree (ResolveContext ec, Expression method)		
 		{
 			string method_name;
 			bool lift_arg = false;
 			
 			switch (oper) {
 			case Operator.Addition
 				if (method == null && ec.HasSet (ResolveContext.Options.CheckedScope) && !IsFloat (type))
 					method_name = "AddChecked";
 				else
 					method_name = "Add";
 				break;
 			case Operator.BitwiseAnd
 				method_name = "And";
 				break;
 			case Operator.BitwiseOr
 				method_name = "Or";
 				break;
 			case Operator.Division
 				method_name = "Divide";
 				break;
 			case Operator.Equality
 				method_name = "Equal";
 				lift_arg = true;
 				break;
 			case Operator.ExclusiveOr
 				method_name = "ExclusiveOr";
 				break;				
 			case Operator.GreaterThan
 				method_name = "GreaterThan";
 				lift_arg = true;
 				break;
 			case Operator.GreaterThanOrEqual
 				method_name = "GreaterThanOrEqual";
 				lift_arg = true;
 				break;
 			case Operator.Inequality
 				method_name = "NotEqual";
 				lift_arg = true;
 				break;
 			case Operator.LeftShift
 				method_name = "LeftShift";
 				break;
 			case Operator.LessThan
 				method_name = "LessThan";
 				lift_arg = true;
 				break;
 			case Operator.LessThanOrEqual
 				method_name = "LessThanOrEqual";
 				lift_arg = true;
 				break;
 			case Operator.LogicalAnd
 				method_name = "AndAlso";
 				break;
 			case Operator.LogicalOr
 				method_name = "OrElse";
 				break;
 			case Operator.Modulus
 				method_name = "Modulo";
 				break;
 			case Operator.Multiply
 				if (method == null && ec.HasSet (ResolveContext.Options.CheckedScope) && !IsFloat (type))
 					method_name = "MultiplyChecked";
 				else
 					method_name = "Multiply";
 				break;
 			case Operator.RightShift
 				method_name = "RightShift";
 				break;
 			case Operator.Subtraction
 				if (method == null && ec.HasSet (ResolveContext.Options.CheckedScope) && !IsFloat (type))
 					method_name = "SubtractChecked";
 				else
 					method_name = "Subtract";
 				break;
 
 			default
 				throw new InternalErrorException ("Unknown expression tree binary operator " + oper);
 			}
 
 			Arguments args = new Arguments (2);
 			args.Add (new Argument (left.CreateExpressionTree (ec)));
 			args.Add (new Argument (right.CreateExpressionTree (ec)));
 			if (method != null) {
 				if (lift_arg)
 					args.Add (new Argument (new BoolLiteral (false, loc)));
 
 				args.Add (new Argument (method));
 			}
 			
 			return CreateExpressionFactoryCall (ec, method_name, args);
 		}
 	}
 	
 	//
 	// Represents the operation a + b [+ c [+ d [+ ...]]], where a is a string
 	// b, c, d... may be strings or objects.
 	//
 	public class StringConcat 
 		Arguments arguments;
 		static IList<MemberSpec> concat_members;
 		
 		public StringConcat (Expression left, Expression right, Location loc)
 		{
 			this.loc = loc;
 			type = TypeManager.string_type;
 			eclass = ExprClass.Value;
 
 			arguments = new Arguments (2);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="743" endline="749">
<![CDATA[
 
 		public override void Error_AlreadyDeclared (string name, INamedBlockVariable variable, string reason)
 		{
 			TopBlock.Report.Error (1931, variable.Location,
 				"A range variable `{0}' conflicts with a previous declaration of `{0}'",
 				name);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="750" endline="756">
<![CDATA[
 
 		public override void Error_AlreadyDeclared (string name, INamedBlockVariable variable)
 		{
 			TopBlock.Report.Error (1930, variable.Location,
 				"A range variable `{0}' has already been declared in this scope",
 				name);		
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\decl.cs" startline="1342" endline="1354">
<![CDATA[
 		}
 
 		/// <remarks>
 		///  Should be overriten by the appropriate declaration space
 		/// </remarks>
 		public abstract void DefineType ();
 
 		protected void Error_MissingPartialModifier (MemberCore type)
 		{
 			Report.Error (260, type.Location,
 				"Missing partial modifier on declaration of type `{0}'. Another partial declaration of this type exists",
 				type.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="1172" endline="1186">
<![CDATA[
 	}
 
 	/// <summary>
 	/// 	This is an explicit numeric cast from a Decimal
 	/// </summary>
 	public class CastFromDecimal 
 	{
 		static Dictionary<TypeSpec, MethodSpec> operators;
 
 		public CastFromDecimal (Expression child, TypeSpec return_type)
 			
 		{
 			if (child.Type != TypeManager.decimal_type)
 				throw new ArgumentException ("Expected decimal child " + child.Type.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="165" endline="173">
<![CDATA[
 
 		internal static void SetMarshalAsAttribute(ModuleBuilder module, int token, CustomAttributeBuilder attribute)
 		{
 			attribute = attribute.DecodeBlob(module.Assembly);
 			FieldMarshalTable.Record rec = new FieldMarshalTable.Record();
 			rec.Parent = token;
 			rec.NativeType = WriteMarshallingDescriptor(module, attribute);
 			module.FieldMarshal.AddRecord(rec);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="912" endline="920">
<![CDATA[
 
 	/// <summary>
 	///   Check whether `type' and `parent' are both instantiations of the same
 	///   generic type.  Note that we do not check the type parameters here.
 	/// </summary>
 	public static bool IsInstantiationOfSameGenericType (TypeSpec type, TypeSpec parent)
 	{
 		return type == parent || type.MemberDefinition == parent.MemberDefinition;
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\linq.cs" startline="730" endline="736">
<![CDATA[
 		}
 
 		public QueryBlock (CompilerContext ctx, Block parent, Location start)
 			
 		{
 			flags |= Flags.CompilerGenerated;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="35" endline="503">
<![CDATA[
 
 #if !STATIC
 		// Reflection Emit hacking
 		static readonly Type TypeBuilder;
 		static readonly Type GenericTypeBuilder;
 
 		static TypeSpec ()
 		{
 			var assembly = typeof (object).Assembly;
 			TypeBuilder = assembly.GetType ("System.Reflection.Emit.TypeBuilder");
 			GenericTypeBuilder = assembly.GetType ("System.Reflection.MonoGenericClass");
 			if (GenericTypeBuilder == null)
 				GenericTypeBuilder = assembly.GetType ("System.Reflection.Emit.TypeBuilderInstantiation");
 		}
 #endif
 
 		public TypeSpec (MemberKind kind, TypeSpec declaringType, ITypeDefinition definition, MetaType info, Modifiers modifiers)
 			
 		{
 			this.declaringType = declaringType;
 			this.info = info;
 
 			if (definition != null && definition.TypeParametersCount > 0)
 				state |= StateFlags.IsGeneric;
 		}
 
 		#region Properties
 
 		public override int Arity {
 			get {
 				return MemberDefinition.TypeParametersCount;
 			}
 		}
 
 		public virtual TypeSpec BaseType {
 			get {
 				return base_type;
 			}
 			set {
 				base_type = value;
 			}
 		}
 
 		public virtual BuildinTypeSpec.Type BuildinType {
 			get {
 				return BuildinTypeSpec.Type.None;
 			}
 		}
 
 		public bool HasDynamicElement {
 			get {
 				return (state & StateFlags.HasDynamicElement) != 0;
 			}
 		}
 
 		public virtual IList<TypeSpec> Interfaces {
 			get {
 				return ifaces;
 			}
 			set {
 				ifaces = value;
 			}
 		}
 
 		public bool IsArray {
 			get {
 				return Kind == MemberKind.ArrayType;
 			}
 		}
 
 		public bool IsAttribute {
 			get {
 				if (!IsClass)
 					return false;
 
 				var type = this;
 				do {
 					if (type.IsGeneric)
 						return false;
 
 					if (type == TypeManager.attribute_type)
 						return true;
 					
 					type = type.base_type;
 				} while (type != null);
 
 				return false;
 			}
 		}
 
 		public bool IsInterface {
 			get {
 				return Kind == MemberKind.Interface;
 			}
 		}
 
 		public bool IsClass {
 			get {
 				return Kind == MemberKind.Class;
 			}
 		}
 
 		public bool IsConstantCompatible {
 			get {
 				if ((Kind & (MemberKind.Enum | MemberKind.Class | MemberKind.Interface | MemberKind.Delegate | MemberKind.ArrayType)) != 0)
 					return true;
 
 				return TypeManager.IsPrimitiveType (this) || this == TypeManager.decimal_type || this == InternalType.Dynamic;
 			}
 		}
 
 		public bool IsDelegate {
 			get {
 				return Kind == MemberKind.Delegate;
 			}
 		}
 
 		public bool IsEnum {
 			get { return Kind == MemberKind.Enum; }
 		}
 
 		// TODO
 		// IsGenericType -- recursive
 		// HasTypeParameter -- non-recursive
 		public bool IsGenericOrParentIsGeneric {
 			get {
 				var ts = this;
 				do {
 					if (ts.IsGeneric)
 						return true;
 					ts = ts.declaringType;
 				} while (ts != null);
 
 				return false;
 			}
 		}
 
 		public bool IsGenericParameter {
 			get { return Kind == MemberKind.TypeParameter; }
 		}
 
 		public bool IsNested {
 			get { return declaringType != null && Kind != MemberKind.TypeParameter; }
 		}
 
 		public bool IsPointer {
 			get {
 				return Kind == MemberKind.PointerType;
 			}
 		}
 
 		public bool IsSealed {
 			get { return (Modifiers & Modifiers.SEALED) != 0; }
 		}
 
 		public bool IsStruct {
 			get { 
 				return Kind == MemberKind.Struct;
 			}
 		}
 
 		public bool IsTypeBuilder {
 			get {
 #if STATIC
 				return true;
 #else
 				var meta = GetMetaInfo().GetType ();
 				return meta == TypeBuilder || meta == GenericTypeBuilder;
 #endif
 			}
 		}
 
 		public MemberCache MemberCache {
 			get {
 				if (cache == null || (state & StateFlags.PendingMemberCacheMembers) != 0)
 					InitializeMemberCache (false);
 
 				return cache;
 			}
 			set {
 				if (cache != null)
 					throw new InternalErrorException ("Membercache reset");
 
 				cache = value;
 			}
 		}
 
 		public MemberCache MemberCacheTypes {
 			get {
 				if (cache == null)
 					InitializeMemberCache (true);
 
 				return cache;
 			}
 		}	
 
 		public new ITypeDefinition MemberDefinition {
 			get {
 				return (ITypeDefinition) definition;
 			}
 		}
 
 		// TODO
 		// remove the property, YES IT WOULD !!!
 		public virtual TypeSpec[] TypeArguments {
 			get { return TypeSpec.EmptyTypes; }
 		}
 
 		#endregion
 
 		public bool AddInterface (TypeSpec iface)
 		{
 			if ((state & StateFlags.InterfacesExpanded) != 0)
 				throw new InternalErrorException ("Modifying expanded interface list");
 
 			if (ifaces == null) {
 				ifaces = new List<TypeSpec> () { iface };
 				return true;
 			}
 
 			if (!ifaces.Contains (iface)) {
 				ifaces.Add (iface);
 				return true;
 			}
 
 			return false;
 		}
 
 		public AttributeUsageAttribute GetAttributeUsage (PredefinedAttribute pa)
 		{
 			if (Kind != MemberKind.Class)
 				throw new InternalErrorException ();
 
 			if (!pa.IsDefined)
 				return Attribute.DefaultUsageAttribute;
 
 			AttributeUsageAttribute aua = null;
 			var type = this;
 			while (type != null) {
 				aua = type.MemberDefinition.GetAttributeUsage (pa);
 				if (aua != null)
 					break;
 
 				type = type.BaseType;
 			}
 
 			return aua;
 		}
 
 		public virtual MetaType GetMetaInfo ()
 		{
 			return info;
 		}
 
 		public virtual TypeSpec GetDefinition ()
 		{
 			return this;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			string s;
 
 			if (IsNested) {
 				s = DeclaringType.GetSignatureForError ();
 			} else if (MemberDefinition is AnonymousTypeClass) {
 				return ((AnonymousTypeClass) MemberDefinition).GetSignatureForError ();
 			} else {
 				s = MemberDefinition.Namespace;
 			}
 
 			if (!string.IsNullOrEmpty (s))
 				s += ".";
 
 			return s + Name + GetTypeNameSignature ();
 		}
 
 		protected virtual string GetTypeNameSignature ()
 		{
 			if (!IsGeneric)
 				return null;
 
 			return "<" + TypeManager.CSharpName (MemberDefinition.TypeParameters) + ">";
 		}
 
 		public bool ImplementsInterface (TypeSpec iface, bool variantly)
 		{
 			var t = this;
 			do {
 				if (t.Interfaces != null) {	// TODO
 					foreach (TypeSpec i in t.Interfaces) {
 						if (i == iface || TypeSpecComparer.IsEqual (i, iface))
 							return true;
 
 						if (variantly && TypeSpecComparer.Variant.IsEqual (i, iface))
 							return true;
 					}
 				}
 
 				t = t.BaseType;
 			} while (t != null);
 
 			return false;
 		}
 
 		protected virtual void InitializeMemberCache (bool onlyTypes)
 		{
 			MemberDefinition.LoadMembers (this, onlyTypes, ref cache);
 
 			if (onlyTypes)
 				state |= StateFlags.PendingMemberCacheMembers;
 			else
 				state &= ~StateFlags.PendingMemberCacheMembers;
 		}
 
 		//
 		// Is @baseClass base implementation of @type. With enabled @dynamicIsEqual the slower
 		// comparison is used to hide differences between `object' and `dynamic' for generic
 		// types. Should not be used for comparisons where G<object> != G<dynamic>
 		//
 		public static bool IsBaseClass (TypeSpec type, TypeSpec baseClass, bool dynamicIsObject)
 		{
 			if (dynamicIsObject && baseClass.IsGeneric) {
 				//
 				// Returns true for a hierarchies like this when passing baseClass of A<dynamic>
 				//
 				// class B 
 				//
 				while (type != null) {
 					type = type.BaseType;
 					if (TypeSpecComparer.IsEqual (type, baseClass))
 						return true;
 				}
 
 				return false;
 			}
 
 			while (type != null) {
 				type = type.BaseType;
 				if (type == baseClass)
 					return true;
 			}
 
 			return false;
 		}
 
 		public override MemberSpec InflateMember (TypeParameterInflator inflator)
 		{
 			var targs = IsGeneric ? MemberDefinition.TypeParameters 
 
 			//
 			// When inflating nested type from inside the type instance will be same
 			// because type parameters are same for all nested types
 			//
 			if (DeclaringType == inflator.TypeInstance) {
 				return MakeGenericType (targs);
 			}
 
 			return new InflatedTypeSpec (this, inflator.TypeInstance, targs);
 		}
 
 		public InflatedTypeSpec MakeGenericType (TypeSpec[] targs)
 		{
 			if (targs.Length == 0 && !IsNested)
 				throw new ArgumentException ("Empty type arguments for type " + GetSignatureForError ());
 
 			InflatedTypeSpec instance;
 
 			if (inflated_instances == null) {
 				inflated_instances = new Dictionary<TypeSpec[], InflatedTypeSpec> (TypeSpecComparer.Default);
 
 				if (IsNested) {
 					instance = this as InflatedTypeSpec;
 					if (instance != null) {
 						//
 						// Nested types could be inflated on already inflated instances
 						// Caching this type ensured we are using same instance for
 						// inside/outside inflation using local type parameters
 						//
 						inflated_instances.Add (TypeArguments, instance);
 					}
 				}
 			}
 
 			if (!inflated_instances.TryGetValue (targs, out instance)) {
 				if (GetDefinition () != this && !IsNested)
 					throw new InternalErrorException ("`{0}' must be type definition or nested non-inflated type to MakeGenericType",
 						GetSignatureForError ());
 
 				instance = new InflatedTypeSpec (this, declaringType, targs);
 				inflated_instances.Add (targs, instance);
 			}
 
 			return instance;
 		}
 
 		public virtual TypeSpec Mutate (TypeParameterMutator mutator)
 		{
 			return this;
 		}
 
 		public void SetMetaInfo (MetaType info)
 		{
 			if (this.info != null)
 				throw new InternalErrorException ("MetaInfo reset");
 
 			this.info = info;
 		}
 
 		public void SetExtensionMethodContainer ()
 		{
 			modifiers |= Modifiers.METHOD_EXTENSION;
 		}
 	}
 
 	public sealed class BuildinTypeSpec 
 	{
 		public enum Type
 		{
 			None = 0,
 
 			// TODO
 			Object,
 			ValueType,
 			Attribute,
 			Int,
 			UInt,
 			Long,
 			ULong,
 			Float,
 			Double,
 			Char,
 			Short,
 			Decimal,
 			Bool,
 			SByte,
 			Byte,
 			UShort,
 			String,
 			Enum,
 			Delegate,
 			MulticastDelegate,
 			Void,
 			Array,
 			Type,
 			IEnumerator,
 			IEnumerable,
 			IDisposable,
 			IntPtr,
 			UIntPtr,
 			RuntimeFieldHandle,
 			RuntimeTypeHandle,
 			Exception,
 
 			Null,
 			Dynamic
 		}
 
 		readonly Type type;
 		readonly string ns;
 		readonly string name;
 
 		public BuildinTypeSpec (MemberKind kind, string ns, string name, Type buildinKind)
 			
 		{
 			this.type = buildinKind;
 			this.ns = ns;
 			this.name = name;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="50" endline="83">
<![CDATA[
 		List<string> extra_information = new List<string> ();
 
 		// 
 		// IF YOU ADD A NEW WARNING YOU HAVE TO ADD ITS ID HERE
 		//
 		public static readonly int[] AllWarnings = new int[] {
 			28, 67, 78,
 			105, 108, 109, 114, 162, 164, 168, 169, 183, 184, 197,
 			219, 251, 252, 253, 278, 282,
 			402, 414, 419, 420, 429, 436, 440, 458, 464, 465, 467, 469, 472,
 			612, 618, 626, 628, 642, 649, 652, 658, 659, 660, 661, 665, 672, 675, 693,
 			728,
 			809,
 			1030, 1058, 1066,
 			1522, 1570, 1571, 1572, 1573, 1574, 1580, 1581, 1584, 1587, 1589, 1590, 1591, 1592,
 			1607, 1616, 1633, 1634, 1635, 1685, 1690, 1691, 1692, 1695, 1696, 1699, 1683,
 			1700, 1701, 1702, 1709, 1717, 1718, 1720,
 			1901, 1981,
 			2002, 2023, 2029,
 			3000, 3001, 3002, 3003, 3005, 3006, 3007, 3008, 3009,
 			3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019,
 			3021, 3022, 3023, 3024, 3026, 3027
 		};
 
 		static HashSet<int> AllWarningsHashSet;
 
 		public Report (ReportPrinter printer)
 		{
 			if (printer == null)
 				throw new ArgumentNullException ("printer");
 
 			this.printer = printer;
 			warning_level = 4;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="1116" endline="1215">
<![CDATA[
 
 			public const string AddPrefix = "add_";
 			public const string RemovePrefix = "remove_";
 
 			protected AEventAccessor (Event method, string prefix, Attributes attrs, Location loc)
 				
 			{
 				this.method = method;
 				this.ModFlags = method.ModFlags;
 				this.parameters = ParametersCompiled.CreateImplicitParameter (method.TypeExpression, loc);
 			}
 
 			public bool IsInterfaceImplementation {
 				get { return method_data.implementing != null; }
 			}
 
 			public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Type == pa.MethodImpl) {
 					method.is_external_implementation = a.IsInternalCall ();
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			protected override void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 			{
 				if (a.Target == AttributeTargets.Parameter) {
 					parameters[0].ApplyAttributeBuilder (a, ctor, cdata, pa);
 					return;
 				}
 
 				base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 			}
 
 			public override AttributeTargets AttributeTargets {
 				get {
 					return AttributeTargets.Method;
 				}
 			}
 
 			public override bool IsClsComplianceRequired ()
 			{
 				return method.IsClsComplianceRequired ();
 			}
 
 			public virtual MethodBuilder Define (DeclSpace parent)
 			{
 				parameters.Resolve (this);
 
 				method_data = new MethodData (method, method.ModFlags,
 					method.flags | MethodAttributes.HideBySig | MethodAttributes.SpecialName, this);
 
 				if (!method_data.Define (parent, method.GetFullName (MemberName), Report))
 					return null;
 
 				MethodBuilder mb = method_data.MethodBuilder;
 
 				Spec = new MethodSpec (MemberKind.Method, parent.PartialContainer.Definition, this, ReturnType, mb, ParameterInfo, method.ModFlags);
 				Spec.IsAccessor = true;
 
 				return mb;
 			}
 
 			public override TypeSpec ReturnType {
 				get {
 					return TypeManager.void_type;
 				}
 			}
 
 			public override ObsoleteAttribute GetAttributeObsolete ()
 			{
 				return method.GetAttributeObsolete ();
 			}
 
 			public override string[] ValidAttributeTargets {
 				get {
 					return attribute_targets;
 				}
 			}
 
 			public override ParametersCompiled ParameterInfo {
 				get {
 					return parameters;
 				}
 			}
 		}
 
 		AEventAccessor add, remove;
 		EventBuilder EventBuilder;
 		protected EventSpec spec;
 
 		protected Event (DeclSpace parent, FullNamedExpression type, Modifiers mod_flags, MemberName name, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs)
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="716" endline="726">
<![CDATA[
 		}
 
 		public Property (DeclSpace parent, FullNamedExpression type, Modifiers mod,
 				 MemberName name, Attributes attrs)
 			
 				parent.PartialContainer.Kind == MemberKind.Interface ? AllowedModifiersInterface 
 				parent.PartialContainer.Kind == MemberKind.Struct ? AllowedModifiersStruct 
 				AllowedModifiersClass,
 				name, attrs)
 		{
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1589" endline="1604">
<![CDATA[
 
 		void WriteCompressedValue (int value)
 		{
 			if (value < 0x80) {
 				Encode ((byte) value);
 				return;
 			}
 
 			if (value < 0x4000) {
 				Encode ((byte) (0x80 | (value >> 8)));
 				Encode ((byte) value);
 				return;
 			}
 
 			Encode (value);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="986" endline="996">
<![CDATA[
 
 		InternalType (string name)
 			
 		{
 			this.name = name;
 			this.definition = this;
 			cache = MemberCache.Empty;
 
 			// Make all internal types CLS-compliant, non-obsolete
 			state = (state & ~(StateFlags.CLSCompliant_Undetected | StateFlags.Obsolete_Undetected)) | StateFlags.CLSCompliant;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="419" endline="427">
<![CDATA[
 		}
 
 		public int CompilationUnitIndex {
 			get {
 				if (token == 0)
 					return 0;
 if (checkpoints.Length <= CheckpointIndex) throw new Exception (String.Format ("Should not happen. Token is {0
 				return checkpoints [CheckpointIndex].CompilationUnit;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="428" endline="436">
<![CDATA[
 		}
 
 		public int File {
 			get {
 				if (token == 0)
 					return 0;
 if (checkpoints.Length <= CheckpointIndex) throw new Exception (String.Format ("Should not happen. Token is {0
 				return checkpoints [CheckpointIndex].File;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\property.cs" startline="671" endline="682">
<![CDATA[
 		}
 
 		protected override void SetMemberName (MemberName new_name)
 		{
 			base.SetMemberName (new_name);
 
 			if (Get != null)
 				Get.UpdateName (this);
 
 			if (Set != null)
 				Set.UpdateName (this);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\membercache.cs" startline="75" endline="81">
<![CDATA[
 		{
 			Name = name;
 			Kind = kind;
 			Parameters = null;
 			MemberType = null;
 			arity = -1;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="638" endline="644">
<![CDATA[
 
 		protected void Error_ConditionalAttributeIsNotValid ()
 		{
 			Report.Error (577, Location,
 				"Conditional not valid on `{0}' because it is a constructor, destructor, operator or explicit interface implementation",
 				GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\MarshalSpec.cs" startline="291" endline="297">
<![CDATA[
 
 		private static void WriteString(ByteBuffer bb, string str)
 		{
 			byte[] buf = Encoding.UTF8.GetBytes(str);
 			bb.WriteCompressedInt(buf.Length);
 			bb.Write(buf);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="1" nfragments="8" Csharpe_files="7" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="832" endline="1349">
<![CDATA[
 #endif
 
 		//
 		// This parses the -arg and /arg options to the compiler, even if the strings
 		// in the following text use "/arg" on the strings.
 		//
 		bool CSCParseOption (string option, ref string [] args)
 		{
 			int idx = option.IndexOf ('
 			string arg, value;
 
 			if (idx == -1){
 				arg = option;
 				value = "";
 			} else {
 				arg = option.Substring (0, idx);
 
 				value = option.Substring (idx + 1);
 			}
 
 			switch (arg.ToLowerInvariant ()){
 			case "/nologo"
 				return true;
 
 			case "/t"
 			case "/target"
 				switch (value){
 				case "exe"
 					RootContext.Target = Target.Exe;
 					break;
 
 				case "winexe"
 					RootContext.Target = Target.WinExe;
 					break;
 
 				case "library"
 					RootContext.Target = Target.Library;
 					RootContext.TargetExt = ".dll";
 					break;
 
 				case "module"
 					RootContext.Target = Target.Module;
 					RootContext.TargetExt = ".netmodule";
 					break;
 
 				default
 					TargetUsage ();
 					break;
 				}
 				return true;
 
 			case "/out"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				RootContext.OutputFile = value;
 				return true;
 
 			case "/o"
 			case "/o+"
 			case "/optimize"
 			case "/optimize+"
 				RootContext.Optimize = true;
 				return true;
 
 			case "/o-"
 			case "/optimize-"
 				RootContext.Optimize = false;
 				return true;
 
 			// TODO
 			case "/incremental"
 			case "/incremental+"
 			case "/incremental-"
 				// nothing.
 				return true;
 
 			case "/d"
 			case "/define"
 				if (value.Length == 0){
 					Usage ();
 					Environment.Exit (1);
 				}
 
 				foreach (string d in value.Split (argument_value_separator)) {
 					string conditional = d.Trim ();
 					if (!Tokenizer.IsValidIdentifier (conditional)) {
 						Report.Warning (2029, 1, "Invalid conditional define symbol `{0}'", conditional);
 						continue;
 					}
 					RootContext.AddConditional (conditional);
 				}
 				foreach (string d in value.Split (argument_value_separator)) {
 					string conditional = d.Trim ();
 					if (!Tokenizer.IsValidIdentifier (conditional)) {
 						Report.Warning (2029, 1, "Invalid conditional define symbol `{0}'", conditional);
 						continue;
 					}
 					RootContext.AddConditional (conditional);
 				}
 				return true;
 			}
 
 			case "/bugreport"
 				//
 				// We should collect data, runtime, etc and store in the file specified
 				//
 				Console.WriteLine ("To file bug reports, please visit
 				return true;
 #if !SMCS_SOURCE
 			case "/pkg"
 				string packages;
 
 				if (value.Length == 0){
 					Usage ();
 					Environment.Exit (1);
 				}
 				packages = String.Join (" ", value.Split (new Char [] { ';', ',', '\n', '\r'}));
 				string pkgout = GetPackageFlags (packages, true, Report);
 				
 				if (pkgout != null){
 					string [] xargs = pkgout.Trim (new Char [] {' ', '\n', '\r', '\t'}).
 						Split (new Char [] { ' ', '\t'});
 					args = AddArgs (args, xargs);
 				}
 				
 				return true;
 			}
 #endif
 			case "/linkres"
 			case "/linkresource"
 			case "/res"
 			case "/resource"
 				AssemblyResource res = null;			
 				string[] s = value.Split (argument_value_separator, StringSplitOptions.RemoveEmptyEntries);
 				switch (s.Length) {
 				case 1
 					if (s[0].Length == 0)
 						goto default;
 					res = new AssemblyResource (s [0], Path.GetFileName (s[0]));
 					break;
 				case 2
 					res = new AssemblyResource (s [0], s [1]);
 					break;
 				case 3
 					if (s [2] != "public" && s [2] != "private") {
 						Report.Error (1906, "Invalid resource visibility option `{0}'. Use either `public' or `private' instead", s [2]);
 						return true;
 					}
 					res = new AssemblyResource (s[0], s[1], s[2] == "private");
 					break;
 				default
 					Report.Error (-2005, "Wrong number of arguments for option `{0}'", option);
 					break;
 				}
 
 				if (res != null) {
 					res.IsEmbeded = arg [1] == 'r' || arg [1] == 'R';
 					AddResource (res);
 				}
 
 				return true;
 				
 			case "/recurse"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				ProcessSourceFiles (value, true); 
 				return true;
 
 			case "/r"
 			case "/reference"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				string[] refs = value.Split (argument_value_separator);
 				foreach (string r in refs){
 					if (r.Length == 0)
 						continue;
 
 					string val = r;
 					int index = val.IndexOf ('=');
 					if (index > -1) {
 						string alias = r.Substring (0, index);
 						string assembly = r.Substring (index + 1);
 						AddAssemblyReference (alias, assembly);
 						if (refs.Length != 1) {
 							Report.Error (2034, "Cannot specify multiple aliases using single /reference option");
 							break;
 						}
 					} else {
 						AddAssemblyReference (val);
 					}
 				}
 				foreach (string r in refs){
 					if (r.Length == 0)
 						continue;
 
 					string val = r;
 					int index = val.IndexOf ('=');
 					if (index > -1) {
 						string alias = r.Substring (0, index);
 						string assembly = r.Substring (index + 1);
 						AddAssemblyReference (alias, assembly);
 						if (refs.Length != 1) {
 							Report.Error (2034, "Cannot specify multiple aliases using single /reference option");
 							break;
 						}
 					} else {
 						AddAssemblyReference (val);
 					}
 				}
 				return true;
 			}
 			case "/addmodule"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				string[] refs = value.Split (argument_value_separator);
 				foreach (string r in refs){
 					RootContext.Modules.Add (r);
 				}
 				foreach (string r in refs){
 					RootContext.Modules.Add (r);
 				}
 				return true;
 			}
 			case "/win32res"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 				
 				if (RootContext.Win32IconFile != null)
 					Report.Error (1565, "Cannot specify the `win32res' and the `win32ico' compiler option at the same time");
 
 				RootContext.Win32ResourceFile = value;
 				return true;
 			}
 			case "/win32icon"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				if (RootContext.Win32ResourceFile != null)
 					Report.Error (1565, "Cannot specify the `win32res' and the `win32ico' compiler option at the same time");
 
 				RootContext.Win32IconFile = value;
 				return true;
 			}
 			case "/doc"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				RootContext.Documentation = new Documentation (value);
 				return true;
 			}
 			case "/lib"
 				string [] libdirs;
 				
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				libdirs = value.Split (argument_value_separator);
 				foreach (string dir in libdirs)
 					RootContext.ReferencesLookupPaths.Add (dir);
 				foreach (string dir in libdirs)
 					RootContext.ReferencesLookupPaths.Add (dir);
 				return true;
 			}
 
 			case "/debug-"
 				RootContext.GenerateDebugInfo = false;
 				return true;
 				
 			case "/debug"
 				if (value == "full" || value == "")
 					RootContext.GenerateDebugInfo = true;
 
 				return true;
 				
 			case "/debug+"
 				RootContext.GenerateDebugInfo = true;
 				return true;
 
 			case "/checked"
 			case "/checked+"
 				RootContext.Checked = true;
 				return true;
 
 			case "/checked-"
 				RootContext.Checked = false;
 				return true;
 
 			case "/clscheck"
 			case "/clscheck+"
 				RootContext.VerifyClsCompliance = true;
 				return true;
 
 			case "/clscheck-"
 				RootContext.VerifyClsCompliance = false;
 				return true;
 
 			case "/unsafe"
 			case "/unsafe+"
 				RootContext.Unsafe = true;
 				return true;
 
 			case "/unsafe-"
 				RootContext.Unsafe = false;
 				return true;
 
 			case "/warnaserror"
 			case "/warnaserror+"
 				if (value.Length == 0) {
 					Report.WarningsAreErrors = true;
 				} else {
 					foreach (string wid in value.Split (argument_value_separator))
 						Report.AddWarningAsError (wid);
 					foreach (string wid in value.Split (argument_value_separator))
 						Report.AddWarningAsError (wid);
 				}
 				return true;
 
 			case "/warnaserror-"
 				if (value.Length == 0) {
 					Report.WarningsAreErrors = false;
 				} else {
 					foreach (string wid in value.Split (argument_value_separator))
 						Report.RemoveWarningAsError (wid);
 					foreach (string wid in value.Split (argument_value_separator))
 						Report.RemoveWarningAsError (wid);
 				}
 				return true;
 
 			case "/warn"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				SetWarningLevel (value);
 				return true;
 
 			case "/nowarn"
 				if (value.Length == 0){
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				var warns = value.Split (argument_value_separator);
 				foreach (string wc in warns){
 					try {
 						if (wc.Trim ().Length == 0)
 							continue;
 
 						int warn = Int32.Parse (wc);
 						if (warn < 1) {
 							throw new ArgumentOutOfRangeException("warn");
 						}
 						Report.SetIgnoreWarning (warn);
 					} catch {
 						Report.Error (1904, "`{0}' is not a valid warning number", wc);
 					}
 				}
 				foreach (string wc in warns){
 					try {
 						if (wc.Trim ().Length == 0)
 							continue;
 
 						int warn = Int32.Parse (wc);
 						if (warn < 1) {
 							throw new ArgumentOutOfRangeException("warn");
 						}
 						Report.SetIgnoreWarning (warn);
 					} catch {
 						Report.Error (1904, "`{0}' is not a valid warning number", wc);
 					}
 				}
 				return true;
 			}
 
 			case "/noconfig"
 				RootContext.LoadDefaultReferences = false;
 				return true;
 
 			case "/platform"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLower (CultureInfo.InvariantCulture)) {
 				case "anycpu"
 					RootContext.Platform = Platform.AnyCPU;
 					break;
 				case "x86"
 					RootContext.Platform = Platform.X86;
 					break;
 				case "x64"
 					RootContext.Platform = Platform.X64;
 					break;
 				case "itanium"
 					RootContext.Platform = Platform.IA64;
 					break;
 				default
 					Report.Error (1672, "Invalid platform type for -platform. Valid options are `anycpu', `x86', `x64' or `itanium'");
 					break;
 				}
 
 				return true;
 
 			case "/sdk"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLowerInvariant ()) {
 					case "2"
 						RootContext.SdkVersion = SdkVersion.v2;
 						break;
 					case "4"
 						RootContext.SdkVersion = SdkVersion.v4;
 						break;
 					default
 						Report.Error (-26, "Invalid sdk version name");
 						break;
 				}
 
 				return true;
 
 				// We just ignore this.
 			case "/errorreport"
 			case "/filealign"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				return true;
 				
 			case "/helpinternal"
 				OtherFlags ();
 				Environment.Exit(0);
 				return true;
 				
 			case "/help"
 			case "/?"
 				Usage ();
 				Environment.Exit (0);
 				return true;
 
 			case "/main"
 			case "/m"
 				if (value.Length == 0){
 					Error_RequiresArgument (option);
 					break;
 				}
 				RootContext.MainClass = value;
 				return true;
 
 			case "/nostdlib"
 			case "/nostdlib+"
 				RootContext.StdLib = false;
 				return true;
 
 			case "/nostdlib-"
 				RootContext.StdLib = true;
 				return true;
 
 			case "/fullpaths"
 				return true;
 
 			case "/keyfile"
 				if (value.Length == 0) {
 					Error_RequiresFileName (option);
 					break;
 				}
 
 				RootContext.StrongNameKeyFile = value;
 				return true;
 
 			case "/keycontainer"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				RootContext.StrongNameKeyContainer = value;
 				return true;
 			case "/delaysign+"
 			case "/delaysign"
 				RootContext.StrongNameDelaySign = true;
 				return true;
 			case "/delaysign-"
 				RootContext.StrongNameDelaySign = false;
 				return true;
 
 			case "/langversion"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value.ToLowerInvariant ()) {
 				case "iso-1"
 					RootContext.Version = LanguageVersion.ISO_1;
 					return true;	
 				case "default"
 					RootContext.Version = LanguageVersion.Default;
 					RootContext.AddConditional ("__V2__");
 					return true;
 				case "iso-2"
 					RootContext.Version = LanguageVersion.ISO_2;
 					return true;
 				case "3"
 					RootContext.Version = LanguageVersion.V_3;
 					return true;
 				case "future"
 					RootContext.Version = LanguageVersion.Future;
 					return true;
 				}
 
 				Report.Error (1617, "Invalid -langversion option `{0}'. It must be `ISO-1', `ISO-2', `3' or `Default'", value);
 				return true;
 
 			case "/codepage"
 				if (value.Length == 0) {
 					Error_RequiresArgument (option);
 					break;
 				}
 
 				switch (value) {
 				case "utf8"
 					RootContext.Encoding = new UTF8Encoding();
 					break;
 				case "reset"
 					RootContext.Encoding = Encoding.Default;
 					break;
 				default
 					try {
 						RootContext.Encoding = Encoding.GetEncoding (Int32.Parse (value));
 					} catch {
 						Report.Error (2016, "Code page `{0}' is invalid or not installed", value);
 					}
 					break;
 				}
 				return true;
 
 			default
 				return false;
 			}
 
 			return true;
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6108" endline="6119">
<![CDATA[
 
 string CheckAttributeTarget (string a, Location l)
 {
 	switch (a) {
 	case "assembly" 
 			return a;
 	}
 
 	Report.Warning (658, 1, l,
 		 "`{0}' is invalid attribute target. All attributes in this attribute section will be ignored", a);
 	return string.Empty;
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\doc.cs" startline="832" endline="855">
<![CDATA[
 
 		private static bool IsTypeName (string name)
 		{
 			switch (name) {
 			case "bool"
 			case "byte"
 			case "char"
 			case "decimal"
 			case "double"
 			case "float"
 			case "int"
 			case "long"
 			case "object"
 			case "sbyte"
 			case "short"
 			case "string"
 			case "uint"
 			case "ulong"
 			case "ushort"
 			case "void"
 				return true;
 			}
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="858" endline="883">
<![CDATA[
 
 		public int Fatal { get; set; }
 
 		static int NameToCode (string s)
 		{
 			switch (s) {
 			case "black"
 				return 0;
 			case "red"
 				return 1;
 			case "green"
 				return 2;
 			case "yellow"
 				return 3;
 			case "blue"
 				return 4;
 			case "magenta"
 				return 5;
 			case "cyan"
 				return 6;
 			case "grey"
 			case "white"
 				return 7;
 			}
 			return 7;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\namespace.cs" startline="1129" endline="1156">
<![CDATA[
 
 		public static void Error_NamespaceNotFound (Location loc, string name, Report Report)
 		{
 			Report.Error (246, loc, "The type or namespace name `{0}' could not be found. Are you missing a using directive or an assembly reference?",
 				name);
 
 			switch (name) {
 			case "Gtk"
 				MsgtryPkg ("gtk-sharp");
 				break;
 
 			case "Gdk"
 				MsgtryPkg ("gdk-sharp");
 				break;
 
 			case "Glade"
 				MsgtryPkg ("glade-sharp");
 				break;
 
 			case "System.Drawing"
 			case "System.Web.Services"
 			case "System.Web"
 			case "System.Data"
 			case "System.Windows.Forms"
 				MsgtryRef (name);
 				break;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="542" endline="571">
<![CDATA[
 		}
 
 		#endregion
 
 		public override string GetSignatureForError ()
 		{
 			switch (Name) {
 			case "Int32"
 			case "Int64"
 			case "String"
 			case "Boolean"
 			case "Void"
 			case "Object"
 			case "UInt32"
 			case "Int16"
 			case "UInt16"
 			case "UInt64"
 			case "Single"
 			case "Double"
 			case "Decimal"
 			case "Char"
 			case "Byte"
 			case "SByte"
 			}
 
 			if (ns.Length == 0)
 				return name;
 
 			return FullName;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Fusion.cs" startline="162" endline="217">
<![CDATA[
 
 		static bool IsFrameworkAssembly(ParsedAssemblyName name)
 		{
 			// A list of FX assemblies which require some form of remapping
 			// When 4.0 + 1 version  is release, assemblies introduced in v4.0
 			// will have to be added
 			switch (name.Name)
 			{
 				case "System"
 				case "System.Core"
 				case "System.Data"
 				case "System.Data.DataSetExtensions"
 				case "System.Data.Linq"
 				case "System.Data.OracleClient"
 				case "System.Data.Services"
 				case "System.Data.Services.Client"
 				case "System.IdentityModel"
 				case "System.IdentityModel.Selectors"
 				case "System.Runtime.Remoting"
 				case "System.Runtime.Serialization"
 				case "System.ServiceModel"
 				case "System.Transactions"
 				case "System.Windows.Forms"
 				case "System.Xml"
 				case "System.Xml.Linq"
 					return name.PublicKeyToken == "b77a5c561934e089";
 
 				case "System.Configuration"
 				case "System.Configuration.Install"
 				case "System.Design"
 				case "System.DirectoryServices"
 				case "System.Drawing"
 				case "System.Drawing.Design"
 				case "System.EnterpriseServices"
 				case "System.Management"
 				case "System.Messaging"
 				case "System.Runtime.Serialization.Formatters.Soap"
 				case "System.Security"
 				case "System.ServiceProcess"
 				case "System.Web"
 				case "System.Web.Mobile"
 				case "System.Web.Services"
 					return name.PublicKeyToken == "b03f5f7f11d50a3a";
 
 				case "System.ComponentModel.DataAnnotations"
 				case "System.ServiceModel.Web"
 				case "System.Web.Abstractions"
 				case "System.Web.Extensions"
 				case "System.Web.Extensions.Design"
 				case "System.Web.DynamicData"
 				case "System.Web.Routing"
 					return name.PublicKeyToken == "31bf3856ad364e35";
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="704" endline="792">
<![CDATA[
 
 #if NET_2_0
 	void WriteGenericConstraints (Type [] args)
 	{
 
 		foreach (Type t in args) {
 			bool first = true;
 			Type[] ifaces = TypeGetInterfaces (t, true);
 			
 			GenericParameterAttributes attrs = t.GenericParameterAttributes & GenericParameterAttributes.SpecialConstraintMask;
 			GenericParameterAttributes [] interesting = {
 				GenericParameterAttributes.ReferenceTypeConstraint,
 				GenericParameterAttributes.NotNullableValueTypeConstraint,
 				GenericParameterAttributes.DefaultConstructorConstraint
 			};
 			
 			if (t.BaseType != typeof (object) || ifaces.Length != 0 || attrs != 0) {
 				o.Write (" where ");
 				o.Write (FormatType (t));
 				o.Write (" 
 			}
 
 			if (t.BaseType != typeof (object)) {
 				o.Write (FormatType (t.BaseType));
 				first = false;
 			}
 
 			foreach (Type iface in ifaces) {
 				if (!first)
 					o.Write (", ");
 				first = false;
 				
 				o.Write (FormatType (iface));
 			}
 
 			foreach (GenericParameterAttributes a in interesting) {
 				if ((attrs & a) == 0)
 					continue;
 				
 				if (!first)
 					o.Write (", ");
 				first = false;
 				
 				switch (a) {
 				case GenericParameterAttributes.ReferenceTypeConstraint
 					o.Write ("class");
 					break;
 				case GenericParameterAttributes.NotNullableValueTypeConstraint
 					o.Write ("struct");
 					break;
 				case GenericParameterAttributes.DefaultConstructorConstraint
 					o.Write ("new ()");
 					break;
 				}
 			}
 		}
 	}
 #endif
  
 	string OperatorFromName (string name)
 	{
 		switch (name) {
 		case "op_UnaryPlus"
 		case "op_UnaryNegation"
 		case "op_LogicalNot"
 		case "op_OnesComplement"
 		case "op_Increment"
 		case "op_Decrement"
 		case "op_True"
 		case "op_False"
 		case "op_Addition"
 		case "op_Subtraction"
 		case "op_Multiply"
 		case "op_Division"
 		case "op_Modulus"
 		case "op_BitwiseAnd"
 		case "op_BitwiseOr"
 		case "op_ExclusiveOr"
 		case "op_LeftShift"
 		case "op_RightShift"
 		case "op_Equality"
 		case "op_Inequality"
 		case "op_GreaterThan"
 		case "op_LessThan"
 		case "op_GreaterThanOrEqual"
 		case "op_LessThanOrEqual"
 		default
 		}
 	}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="2" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="848" endline="855">
<![CDATA[
 		}
 
 #endregion
 
 		public override string GetSignatureForError()
 		{
 			return base.GetSignatureForError () + parameters.GetSignatureForError ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="5526" endline="5534">
<![CDATA[
 		}
 
 		//
 		// Returns true for resolved `new S()'
 		//
 		public bool IsDefaultStruct {
 			get {
 				return arguments == null && type.IsStruct && GetType () == typeof (New);
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="3" nfragments="17" Csharpe_files="17" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\flowanalysis.cs" startline="403" endline="411">
<![CDATA[
 
 		protected abstract void AddSibling (UsageVector uv);
 
 		protected abstract UsageVector Merge ();
 
 		public UsageVector MergeChild (FlowBranching child)
 		{
 			return CurrentUsageVector.MergeChild (child.Merge (), true);
  		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="602" endline="610">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="865" endline="873">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteHasConstant()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1188" endline="1196">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteHasDeclSecurity()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1461" endline="1469">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteTypeDefOrRef()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1539" endline="1547">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1588" endline="1596">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteMethodDef()
 				.WriteHasSemantics()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2103" endline="2111">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2209" endline="2217">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteImplementation()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2305" endline="2313">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteTypeOrMethodDef()
 				.WriteStringIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="645" endline="654">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.WriteParam()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1847" endline="1856">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteMemberForwarded()
 				.WriteStringIndex()
 				.WriteModuleRef()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="1979" endline="1988">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(16)
 				.WriteBlobIndex()
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2150" endline="2159">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(8)
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteImplementation()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="462" endline="472">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(2)
 				.WriteStringIndex()
 				.WriteGuidIndex()
 				.WriteGuidIndex()
 				.WriteGuidIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2060" endline="2070">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(12)
 				.WriteBlobIndex()
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteBlobIndex()
 				.Value;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="563" endline="574">
<![CDATA[
 
 		protected override int GetRowSize(RowSizeCalc rsc)
 		{
 			return rsc
 				.AddFixed(4)
 				.WriteStringIndex()
 				.WriteStringIndex()
 				.WriteTypeDefOrRef()
 				.WriteField()
 				.WriteMethodDef()
 				.Value;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="4" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\location.cs" startline="185" endline="208">
<![CDATA[
 		}
 
 		static List<SourceFile> source_list;
 		static List<CompilationUnit> compile_units;
 		static Dictionary<string, int> source_files;
 		static int checkpoint_bits;
 		static int source_count;
 		static int current_source;
 		static int current_compile_unit;
 		static int line_delta_bits;
 		static int line_delta_mask;
 		static int column_bits;
 		static int column_mask;
 		static Checkpoint [] checkpoints;
 		static int checkpoint_index;
 		
 		public readonly static Location Null = new Location (-1);
 		public static bool InEmacs;
 		
 		static Location ()
 		{
 			Reset ();
 			checkpoints = new Checkpoint [10];
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="108" endline="161">
<![CDATA[
 		public static readonly AttributeUsageAttribute DefaultUsageAttribute = new AttributeUsageAttribute (AttributeTargets.All);
 		static Assembly orig_sec_assembly;
 		public static readonly object[] EmptyObject = new object [0];
 
 		List<KeyValuePair<MemberExpr, NamedArgument>> named_values;
 
 		// Cache for parameter-less attributes
 		static Dictionary<TypeSpec, MethodSpec> att_cache;
 
 		public Attribute (string target, ATypeNameExpression expr, Arguments[] args, Location loc, bool nameEscaped)
 		{
 			this.expression = expr;
 			if (args != null) {
 				PosArguments = args [0];
 				NamedArguments = args [1];				
 			}
 			this.loc = loc;
 			ExplicitTarget = target;
 			this.nameEscaped = nameEscaped;
 		}
 
 		void AddModuleCharSet (ResolveContext rc)
 		{
 			const string dll_import_char_set = "CharSet";
 
 			//
 			// Only when not customized by user
 			//
 			if (HasField (dll_import_char_set))
 				return;
 
 			if (!rc.Module.PredefinedTypes.CharSet.IsDefined) {
 				return;
 			}
 
 			if (NamedArguments == null)
 				NamedArguments = new Arguments (1);
 
 			var value = Constant.CreateConstant (rc, rc.Module.PredefinedTypes.CharSet.TypeSpec, rc.Module.DefaultCharSet, Location);
 			NamedArguments.Add (new NamedArgument (dll_import_char_set, loc, value));
 		}
 
 		public Attribute Clone ()
 		{
 			Attribute a = new Attribute (ExplicitTarget, expression, null, loc, nameEscaped);
 			a.PosArguments = PosArguments;
 			a.NamedArguments = NamedArguments;
 			return a;
 		}
 
 		static Attribute ()
 		{
 			Reset ();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="5" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="267" endline="282">
<![CDATA[
 	}
 
 	[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
 	struct SingleConverter
 	{
 		[System.Runtime.InteropServices.FieldOffset(0)]
 		private int i;
 		[System.Runtime.InteropServices.FieldOffset(0)]
 		private float f;
 
 		internal static int SingleToInt32Bits(float v)
 		{
 			SingleConverter c = new SingleConverter();
 			c.f = v;
 			return c.i;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Util.cs" startline="283" endline="289">
<![CDATA[
 
 		internal static float Int32BitsToSingle(int v)
 		{
 			SingleConverter c = new SingleConverter();
 			c.i = v;
 			return c.f;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="6" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="432" endline="438">
<![CDATA[
 		
 		static void AddKeyword (string kw, int token)
 		{
 			keyword_strings.Add (kw, null);
 
 			AddKeyword (keywords, kw, token);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\parameter.cs" startline="168" endline="176">
<![CDATA[
 	}
 
 	public class ArglistParameter 
 		// Doesn't have proper type because it's never chosen for better conversion
 		public ArglistParameter (Location loc) 
 			base (null, String.Empty, Parameter.Modifier.NONE, null, loc)
 		{
 			parameter_type = InternalType.Arglist;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\roottypes.cs" startline="136" endline="566">
<![CDATA[
 
 		public ModuleContainer (CompilerContext context)
 			
 		{
 			this.context = context;
 
 			caching_flags &= ~(Flags.Obsolete_Undetected | Flags.Excluded_Undetected);
 
 			types = new List<TypeContainer> ();
 			anonymous_types = new Dictionary<int, List<AnonymousTypeClass>> ();
 			global_ns = new GlobalRootNamespace ();
 			alias_ns = new Dictionary<string, RootNamespace> ();
 		}
 
 		#region Properties
 
  		public override AttributeTargets AttributeTargets {
  			get {
  				return AttributeTargets.Assembly;
  			}
 		}
 
 		public ModuleBuilder Builder {
 			get {
 				return builder;
 			}
 		}
 
 		public override CompilerContext Compiler {
 			get {
 				return context;
 			}
 		}
 
 		public override AssemblyDefinition DeclaringAssembly {
 			get {
 				return assembly;
 			}
 		}
 
 		public bool HasDefaultCharSet {
 			get {
 				return has_default_charset;
 			}
 		}
 
 		public bool HasExtensionMethod {
 			get {
 				return has_extenstion_method;
 			}
 			set {
 				has_extenstion_method = value;
 			}
 		}
 
 		//
 		// Returns module global
 		//
 		public RootNamespace GlobalRootNamespace {
 		    get {
 		        return global_ns;
 		    }
 		}
 
 		public override ModuleContainer Module {
 			get {
 				return this;
 			}
 		}
 
 		internal PredefinedAttributes PredefinedAttributes {
 			get {
 				return predefined_attributes;
 			}
 		}
 
 		internal PredefinedTypes PredefinedTypes {
 			get {
 				return predefined_types;
 			}
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 
 		#endregion
 
 		public void AddAnonymousType (AnonymousTypeClass type)
 		{
 			List<AnonymousTypeClass> existing;
 			if (!anonymous_types.TryGetValue (type.Parameters.Count, out existing))
 			if (existing == null) {
 				existing = new List<AnonymousTypeClass> ();
 				anonymous_types.Add (type.Parameters.Count, existing);
 			}
 
 			existing.Add (type);
 		}
 
 		public void AddAttributes (List<Attribute> attrs)
 		{
 			AddAttributes (attrs, this);
 		}
 
 		public void AddAttributes (List<Attribute> attrs, IMemberContext context)
 		{
 			foreach (Attribute a in attrs)
 				a.AttachTo (this, context);
 
 			if (attributes == null) {
 				attributes = new Attributes (attrs);
 				return;
 			}
 			attributes.AddAttributes (attrs);
 		}
 
 		public override TypeContainer AddPartial (TypeContainer nextPart)
 		{
 			return AddPartial (nextPart, nextPart.Name);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Target == AttributeTargets.Assembly) {
 				assembly.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			if (a.Type == pa.CLSCompliant) {
 				Attribute cls = DeclaringAssembly.CLSCompliantAttribute;
 				if (cls == null) {
 					Report.Warning (3012, 1, a.Location,
 						"You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking");
 				} else if (DeclaringAssembly.IsCLSCompliant != a.GetBoolean ()) {
 					Report.SymbolRelatedToPreviousError (cls.Location, cls.GetSignatureForError ());
 					Report.Warning (3017, 1, a.Location,
 						"You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly");
 					return;
 				}
 			}
 
 			builder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 		}
 
 		public override void CloseType ()
 		{
 			HackCorlibEnums ();
 
 			foreach (TypeContainer tc in types) {
 				tc.CloseType ();
 			}
 
 			if (compiler_generated != null)
 				foreach (CompilerGeneratedClass c in compiler_generated)
 					c.CloseType ();
 		}
 
 		public TypeBuilder CreateBuilder (string name, TypeAttributes attr, int typeSize)
 		{
 			return builder.DefineType (name, attr, null, typeSize);
 		}
 
 		//
 		// Creates alias global namespace
 		//
 		public RootNamespace CreateRootNamespace (string alias)
 		{
 			if (alias == global_ns.Alias) {
 				NamespaceEntry.Error_GlobalNamespaceRedefined (Location.Null, Report);
 				return global_ns;
 			}
 
 			RootNamespace rn;
 			if (!alias_ns.TryGetValue (alias, out rn)) {
 				rn = new RootNamespace (alias);
 				alias_ns.Add (alias, rn);
 			}
 
 			return rn;
 		}
 
 		public new void Define ()
 		{
 			builder = assembly.CreateModuleBuilder ();
 
 			// FIXME
 			static_data = null;
 
 			// TODO
 			// but that require DefineType clean-up
 			ResolveGlobalAttributes ();
 
 			foreach (TypeContainer tc in types)
 				tc.CreateType ();
 
 			InitializePredefinedTypes ();
 
 			foreach (TypeContainer tc in types)
 				tc.DefineType ();
 
 			foreach (TypeContainer tc in types)
 				tc.ResolveTypeParameters ();
 
 			foreach (TypeContainer tc in types) {
 				try {
 					tc.Define ();
 				} catch (Exception e) {
 					throw new InternalErrorException (tc, e);
 				}
 			}
 		}
 
 		public override void Emit ()
 		{
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (RootContext.Unsafe) {
 				var pa = PredefinedAttributes.UnverifiableCode;
 				if (pa.IsDefined)
 					pa.EmitAttribute (builder);
 			}
 
 			foreach (var tc in types)
 				tc.DefineConstants ();
 
 			HackCorlib ();
 
 			foreach (TypeContainer tc in types)
 				tc.EmitType ();
 
 			if (Compiler.Report.Errors > 0)
 				return;
 
 			foreach (TypeContainer tc in types)
 				tc.VerifyMembers ();
 
 			if (compiler_generated != null)
 				foreach (var c in compiler_generated)
 					c.EmitType ();
 		}
 
 		public AnonymousTypeClass GetAnonymousType (IList<AnonymousTypeParameter> parameters)
 		{
 			List<AnonymousTypeClass> candidates;
 			if (!anonymous_types.TryGetValue (parameters.Count, out candidates))
 				return null;
 
 			int i;
 			foreach (AnonymousTypeClass at in candidates) {
 				for (i = 0; i < parameters.Count; ++i) {
 					if (!parameters [i].Equals (at.Parameters [i]))
 						break;
 				}
 
 				if (i == parameters.Count)
 					return at;
 			}
 
 			return null;
 		}
 
 		public RootNamespace GetRootNamespace (string name)
 		{
 			RootNamespace rn;
 			alias_ns.TryGetValue (name, out rn);
 			return rn;
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return "<module>";
 		}
 
 		void HackCorlib ()
 		{
 #if !STATIC
 			if (RootContext.StdLib)
 				return;
 
 			//
 			// HACK
 			// has different predefined types and this method sets mscorlib types
 			// to be same to avoid type check errors in CreateType.
 			//
 			var type = typeof (Type);
 			var system_4_type_arg = new[] { type, type, type, type };
 
 			MethodInfo set_corlib_type_builders =
 				typeof (System.Reflection.Emit.AssemblyBuilder).GetMethod (
 				"SetCorlibTypeBuilders", BindingFlags.NonPublic | BindingFlags.Instance, null,
 				system_4_type_arg, null);
 
 			if (set_corlib_type_builders == null) {
 				Compiler.Report.Warning (-26, 3,
 					"The compilation may fail due to missing `System.Reflection.Emit.AssemblyBuilder.SetCorlibTypeBuilders(...)' method");
 				return;
 			}
 
 			object[] args = new object[4];
 			args[0] = TypeManager.object_type.GetMetaInfo ();
 			args[1] = TypeManager.value_type.GetMetaInfo ();
 			args[2] = TypeManager.enum_type.GetMetaInfo ();
 			args[3] = TypeManager.void_type.GetMetaInfo ();
 			set_corlib_type_builders.Invoke (assembly.Builder, args);
 #endif
 		}
 
 		void HackCorlibEnums ()
 		{
 			if (RootContext.StdLib)
 				return;
 
 			// Another Mono corlib HACK
 			// mono_class_layout_fields requires to have enums created
 			// before creating a class which used the enum for any of its fields
 			foreach (var e in hack_corlib_enums)
 				e.CloseType ();
 		}
 
 		public void InitializePredefinedTypes ()
 		{
 			predefined_attributes = new PredefinedAttributes (this);
 			predefined_types = new PredefinedTypes (this);
 		}
 
 		public override bool IsClsComplianceRequired ()
 		{
 			return DeclaringAssembly.IsCLSCompliant;
 		}
 
 		//
 		// Makes const data field inside internal type container
 		//
 		public FieldSpec MakeStaticData (byte[] data, Location loc)
 		{
 			if (static_data == null) {
 				static_data = new StaticDataContainer (this);
 				static_data.CreateType ();
 				static_data.DefineType ();
 
 				AddCompilerGeneratedClass (static_data);
 			}
 
 			return static_data.DefineInitializedData (data, loc);
 		}
 
 		protected override bool AddMemberType (TypeContainer ds)
 		{
 			if (!AddToContainer (ds, ds.Name))
 				return false;
 			ds.NamespaceEntry.NS.AddType (ds.Definition);
 			return true;
 		}
 
 		protected override void RemoveMemberType (DeclSpace ds)
 		{
 			ds.NamespaceEntry.NS.RemoveDeclSpace (ds.Basename);
 			base.RemoveMemberType (ds);
 		}
 
 		/// <summary>
 		/// It is called very early therefore can resolve only predefined attributes
 		/// </summary>
 		void ResolveGlobalAttributes ()
 		{
 			if (OptAttributes == null)
 				return;
 
 			if (!OptAttributes.CheckTargets ())
 				return;
 
 			// FIXME
 			var DefaultCharSet_attr = new PredefinedAttribute (this, "System.Runtime.InteropServices", "DefaultCharSetAttribute");
 			DefaultCharSet_attr.Define ();
 			Attribute a = ResolveModuleAttribute (DefaultCharSet_attr);
 			if (a != null) {
 				has_default_charset = true;
 				DefaultCharSet = a.GetCharSetValue ();
 				switch (DefaultCharSet) {
 				case CharSet.Ansi
 				case CharSet.None
 					break;
 				case CharSet.Auto
 					DefaultCharSetType = TypeAttributes.AutoClass;
 					break;
 				case CharSet.Unicode
 					DefaultCharSetType = TypeAttributes.UnicodeClass;
 					break;
 				default
 					Report.Error (1724, a.Location, "Value specified for the argument to `{0}' is not valid", 
 						DefaultCharSet_attr.GetSignatureForError ());
 					break;
 				}
 			}
 		}
 
 		public Attribute ResolveAssemblyAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("assembly", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
 
 		Attribute ResolveModuleAttribute (PredefinedAttribute a_type)
 		{
 			Attribute a = OptAttributes.Search ("module", a_type);
 			if (a != null) {
 				a.Resolve ();
 			}
 			return a;
 		}
 
 		public void SetDeclaringAssembly (AssemblyDefinition assembly)
 		{
 			// TODO
 			this.assembly = assembly;
 		}
 	}
 
 	class RootDeclSpace 
 		public RootDeclSpace (NamespaceEntry ns)
 			
 		{
 			PartialContainer = RootContext.ToplevelTypes;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="7" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\class.cs" startline="3248" endline="3254">
<![CDATA[
 
 		protected void Error_StaticReturnType ()
 		{
 			Report.Error (722, Location,
 				"`{0}'
 				MemberType.GetSignatureForError ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\support.cs" startline="54" endline="61">
<![CDATA[
 
 		#region IEquatable<Tuple<T1,T2>> Members
 
 		public bool Equals (Tuple<T1, T2> other)
 		{
 			return EqualityComparer<T1>.Default.Equals (Item1, other.Item1) &&
 				EqualityComparer<T2>.Default.Equals (Item2, other.Item2);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="8" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="118" endline="125">
<![CDATA[
 		}
 
 		internal uint StrongNameSignatureRVA
 		{
 			get
 			{
 				return (ResourcesRVA + ResourcesLength + 3) & ~3U;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="134" endline="141">
<![CDATA[
 		}
 
 		private uint MetadataRVA
 		{
 			get
 			{
 				return (StrongNameSignatureRVA + StrongNameSignatureLength + 3) & ~3U;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="9" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="169" endline="175">
<![CDATA[
 		}
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed | base.TypeAttr;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\delegate.cs" startline="328" endline="334">
<![CDATA[
 
 		protected override TypeAttributes TypeAttr {
 			get {
 				return ModifiersExtensions.TypeAttr (ModFlags, IsTopLevel) |
 					TypeAttributes.Class | TypeAttributes.Sealed |
 					base.TypeAttr;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="10" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="326" endline="332">
<![CDATA[
 
 		public virtual TypeSpec ResolveType ()
 		{
 			if (Type == null && !resolve_error)
 				ResolveAttributeType ();
 			return Type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="8875" endline="8884">
<![CDATA[
 
 		public string GetSignatureForError ()
 		{
 			string s =
 				IsPointer ? "*" 
 				IsNullable ? "?" 
 				ArrayContainer.GetPostfixSignature (Dimension);
 
 			return Next != null ? s + Next.GetSignatureForError () 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typespec.cs" startline="311" endline="318">
<![CDATA[
 
 		protected virtual string GetTypeNameSignature ()
 		{
 			if (!IsGeneric)
 				return null;
 
 			return "<" + TypeManager.CSharpName (MemberDefinition.TypeParameters) + ">";
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="11" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\eval.cs" startline="165" endline="174">
<![CDATA[
 		
 		static void Reset ()
 		{
 			CompilerCallableEntryPoint.PartialReset ();
 			
 			Location.AddFile (null, "{interactive}");
 			Location.Initialize ();
 
 			current_debug_name = "interactive" + (count++) + ".dll";
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\report.cs" startline="1028" endline="1042">
<![CDATA[
 
 		[Conditional("TIMER")]
 		static public void ShowTimers ()
 		{
 			ShowTimer (TimerType.FindMembers, "- FindMembers timer");
 			ShowTimer (TimerType.TcFindMembers, "- TypeContainer.FindMembers timer");
 			ShowTimer (TimerType.MemberLookup, "- MemberLookup timer");
 			ShowTimer (TimerType.CachedLookup, "- CachedLookup timer");
 			ShowTimer (TimerType.CacheInit, "- Cache init");
 			ShowTimer (TimerType.MiscTimer, "- Misc timer");
 
 			ShowCounter (CounterType.FindMembers, "- Find members");
 			ShowCounter (CounterType.MemberCache, "- Member cache");
 			ShowCounter (CounterType.MiscCounter, "- Misc counter");
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="12" nfragments="5" Csharpe_files="5" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3625" endline="3633">
<![CDATA[
 
 		private static bool IsTypeUnsigned (TypeSpec type)
 		{
 			return type == TypeManager.uint64_type ||
 				type == TypeManager.uint32_type ||
 				type == TypeManager.ushort_type ||
 				type == TypeManager.byte_type ||
 				type == TypeManager.char_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="3612" endline="3624">
<![CDATA[
 
 		private static bool IsTypeIntegral (TypeSpec type)
 		{
 			return type == TypeManager.uint64_type ||
 				type == TypeManager.int64_type ||
 				type == TypeManager.uint32_type ||
 				type == TypeManager.int32_type ||
 				type == TypeManager.ushort_type ||
 				type == TypeManager.short_type ||
 				type == TypeManager.sbyte_type ||
 				type == TypeManager.byte_type ||
 				type == TypeManager.char_type;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\enum.cs" startline="46" endline="53">
<![CDATA[
 
 		static bool IsValidEnumType (TypeSpec t)
 		{
 			return (t == TypeManager.int32_type || t == TypeManager.uint32_type || t == TypeManager.int64_type ||
 				t == TypeManager.byte_type || t == TypeManager.sbyte_type || t == TypeManager.short_type ||
 				t == TypeManager.ushort_type || t == TypeManager.uint64_type || t == TypeManager.char_type ||
 				TypeManager.IsEnumType (t));
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="636" endline="647">
<![CDATA[
 
 	//
 	// This is like IsBuiltinType, but lacks decimal_type, we should also clean up
 	// the pieces in the code where we use IsBuiltinType and special case decimal_type.
 	// 
 	public static bool IsPrimitiveType (TypeSpec t)
 	{
 		return (t == int32_type || t == uint32_type ||
 		    t == int64_type || t == uint64_type || t == float_type || t == double_type ||
 		    t == char_type || t == short_type || t == bool_type ||
 		    t == sbyte_type || t == byte_type || t == ushort_type);
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="625" endline="635">
<![CDATA[
 
 	public static bool IsBuiltinType (TypeSpec t)
 	{
 		if (t == object_type || t == string_type || t == int32_type || t == uint32_type ||
 		    t == int64_type || t == uint64_type || t == float_type || t == double_type ||
 		    t == char_type || t == short_type || t == decimal_type || t == bool_type ||
 		    t == sbyte_type || t == byte_type || t == ushort_type || t == void_type)
 			return true;
 		else
 			return false;
 	}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="13" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\tools\monop\outline.cs" startline="534" endline="550">
<![CDATA[
 	
 	static string GetTypeVisibility (Type t)
 	{
                 switch (t.Attributes & TypeAttributes.VisibilityMask){
                 case TypeAttributes.Public
                 case TypeAttributes.NestedPublic
                         return "public";
 
                 case TypeAttributes.NestedFamily
                 case TypeAttributes.NestedFamANDAssem
                 case TypeAttributes.NestedFamORAssem
                         return "protected";
 
                 default
                         return "internal";
                 }
 	}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="569" endline="589">
<![CDATA[
 
 		//
 		// Returns a stringified representation of the Operator
 		//
 		public static string OperName (Operator oper)
 		{
 			switch (oper) {
 			case Operator.UnaryPlus
 				return "+";
 			case Operator.UnaryNegation
 				return "-";
 			case Operator.LogicalNot
 				return "!";
 			case Operator.OnesComplement
 				return "~";
 			case Operator.AddressOf
 				return "&";
 			}
 
 			throw new NotImplementedException (oper.ToString ());
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\ecore.cs" startline="719" endline="748">
<![CDATA[
 		
 		public virtual string ExprClassName
 		{
 			get {
 				switch (eclass){
 				case ExprClass.Unresolved
 					return "Unresolved";
 				case ExprClass.Value
 					return "value";
 				case ExprClass.Variable
 					return "variable";
 				case ExprClass.Namespace
 					return "namespace";
 				case ExprClass.Type
 					return "type";
 				case ExprClass.MethodGroup
 					return "method group";
 				case ExprClass.PropertyAccess
 					return "property access";
 				case ExprClass.EventAccess
 					return "event access";
 				case ExprClass.IndexerAccess
 					return "indexer access";
 				case ExprClass.Nothing
 					return "null";
 				case ExprClass.TypeParameter
 					return "type parameter";
 				}
 				throw new Exception ("Should not happen");
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="14" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\OpCodes.cs" startline="716" endline="747">
<![CDATA[
 
 		public static bool TakesSingleByteArgument(OpCode inst)
 		{
 			switch (inst.Value)
 			{
 				case 14
 				case 15
 				case 16
 				case 17
 				case 18
 				case 19
 				case 31
 				case 43
 				case 44
 				case 45
 				case 46
 				case 47
 				case 48
 				case 49
 				case 50
 				case 51
 				case 52
 				case 53
 				case 54
 				case 55
 				case 222
 				case -494
 					return true;
 				default
 					return false;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\ByteBuffer.cs" startline="225" endline="242">
<![CDATA[
 
 		internal void WriteTypeDefOrRefEncoded(int token)
 		{
 			switch (token >> 24)
 			{
 				case TypeDefTable.Index
 					WriteCompressedInt((token & 0xFFFFFF) << 2 | 0);
 					break;
 				case TypeRefTable.Index
 					WriteCompressedInt((token & 0xFFFFFF) << 2 | 1);
 					break;
 				case TypeSpecTable.Index
 					WriteCompressedInt((token & 0xFFFFFF) << 2 | 2);
 					break;
 				default
 					throw new InvalidOperationException();
 			}
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="15" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolTable.cs" startline="106" endline="116">
<![CDATA[
 		public int LineNumberTable_LineBase = LineNumberTable.Default_LineBase;
 		public int LineNumberTable_LineRange = LineNumberTable.Default_LineRange;
 		public int LineNumberTable_OpcodeBase = LineNumberTable.Default_OpcodeBase;
 		#endregion
 
 		internal OffsetTable ()
 		{
 			int platform = (int) Environment.OSVersion.Platform;
 			if ((platform != 4) && (platform != 128))
 				FileFlags |= Flags.WindowsFileNames;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="133" endline="152">
<![CDATA[
 	}
 
 	sealed class IMAGE_FILE_HEADER
 	{
 		public const WORD IMAGE_FILE_MACHINE_I386 = 0x014c;
 		public const WORD IMAGE_FILE_MACHINE_IA64 = 0x0200;
 		public const WORD IMAGE_FILE_MACHINE_AMD64 = 0x8664;
 
 		public const WORD IMAGE_FILE_32BIT_MACHINE = 0x0100;
 		public const WORD IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002;
 		public const WORD IMAGE_FILE_LARGE_ADDRESS_AWARE = 0x0020;
 		public const WORD IMAGE_FILE_DLL = 0x2000;
 
 		public WORD Machine;
 		public WORD NumberOfSections;
 		public DWORD TimeDateStamp = (uint)(DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds;
 		public DWORD PointerToSymbolTable = 0;
 		public DWORD NumberOfSymbols = 0;
 		public WORD SizeOfOptionalHeader = 0xE0;
 		public WORD Characteristics = IMAGE_FILE_EXECUTABLE_IMAGE;
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="16" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\TextSection.cs" startline="98" endline="112">
<![CDATA[
 		}
 
 		private uint ResourcesRVA
 		{
 			get
 			{
 				if (peWriter.Headers.FileHeader.Machine == IMAGE_FILE_HEADER.IMAGE_FILE_MACHINE_I386)
 				{
 					return (MethodBodiesRVA + MethodBodiesLength + 3) & ~3U;
 				}
 				else
 				{
 					return (MethodBodiesRVA + MethodBodiesLength + 15) & ~15U;
 				}
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Emit\ModuleBuilder.cs" startline="766" endline="796">
<![CDATA[
 
 		private int GetHeaderLength()
 		{
 			return
 				4 + // Signature
 				2 + // MajorVersion
 				2 + // MinorVersion
 				4 + // Reserved
 				4 + // ImageRuntimeVersion Length
 				StringToPaddedUTF8Length(asm.ImageRuntimeVersion) +
 				2 + // Flags
 				2 + // Streams
 				4 + // #~ Offset
 				4 + // #~ Size
 				4 + // StringToPaddedUTF8Length("#~")
 				4 + // #Strings Offset
 				4 + // #Strings Size
 				12 + // StringToPaddedUTF8Length("#Strings")
 				4 + // #US Offset
 				4 + // #US Size
 				4 + // StringToPaddedUTF8Length("#US")
 				4 + // #GUID Offset
 				4 + // #GUID Size
 				8 + // StringToPaddedUTF8Length("#GUID")
 				(Blobs.IsEmpty ? 0 
 				(
 				4 + // #Blob Offset
 				4 + // #Blob Size
 				8   // StringToPaddedUTF8Length("#Blob")
 				));
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="17" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="87" endline="95">
<![CDATA[
 
 		internal void Write(int value)
 		{
 			buffer[0] = (byte)value;
 			buffer[1] = (byte)(value >> 8);
 			buffer[2] = (byte)(value >> 16);
 			buffer[3] = (byte)(value >> 24);
 			stream.Write(buffer, 0, 4);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\MetadataWriter.cs" startline="101" endline="113">
<![CDATA[
 
 		internal void Write(long value)
 		{
 			buffer[0] = (byte)value;
 			buffer[1] = (byte)(value >> 8);
 			buffer[2] = (byte)(value >> 16);
 			buffer[3] = (byte)(value >> 24);
 			buffer[4] = (byte)(value >> 32);
 			buffer[5] = (byte)(value >> 40);
 			buffer[6] = (byte)(value >> 48);
 			buffer[7] = (byte)(value >> 56);
 			stream.Write(buffer, 0, 8);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="18" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="758" endline="766">
<![CDATA[
 
 		int IComparer<Record>.Compare(Record x, Record y)
 		{
 			if (x.Class == y.Class)
 			{
 				return x.Interface == y.Interface ? 0 
 			}
 			return x.Class > y.Class ? 1 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Metadata\Tables.cs" startline="2340" endline="2348">
<![CDATA[
 
 		int IComparer<Record>.Compare(Record x, Record y)
 		{
 			if (x.Owner == y.Owner)
 			{
 				return x.Number == y.Number ? 0 
 			}
 			return x.Owner > y.Owner ? 1 
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="19" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="502" endline="516">
<![CDATA[
 
 		void SetWarningLevel (string s)
 		{
 			int level = -1;
 
 			try {
 				level = Int32.Parse (s);
 			} catch {
 			}
 			if (level < 0 || level > 4){
 				Report.Error (1900, "Warning level must be in the range 0-4");
 				return;
 			}
 			Report.WarningLevel = level;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2553" endline="2588">
<![CDATA[
 
 		static void CreatePointerOperatorsTable ()
 		{
 			var temp = new List<PredefinedPointerOperator> ();
 
 			//
 			// Pointer arithmetic
 			//
 			// T* operator + (T* x, int y);		T* operator - (T* x, int y);
 			// T* operator + (T* x, uint y);	T* operator - (T* x, uint y);
 			// T* operator + (T* x, long y);	T* operator - (T* x, long y);
 			// T* operator + (T* x, ulong y);	T* operator - (T* x, ulong y);
 			//
 			temp.Add (new PredefinedPointerOperator (null, TypeManager.int32_type, Operator.AdditionMask | Operator.SubtractionMask));
 			temp.Add (new PredefinedPointerOperator (null, TypeManager.uint32_type, Operator.AdditionMask | Operator.SubtractionMask));
 			temp.Add (new PredefinedPointerOperator (null, TypeManager.int64_type, Operator.AdditionMask | Operator.SubtractionMask));
 			temp.Add (new PredefinedPointerOperator (null, TypeManager.uint64_type, Operator.AdditionMask | Operator.SubtractionMask));
 
 			//
 			// T* operator + (int y,   T* x);
 			// T* operator + (uint y,  T *x);
 			// T* operator + (long y,  T *x);
 			// T* operator + (ulong y, T *x);
 			//
 			temp.Add (new PredefinedPointerOperator (TypeManager.int32_type, null, Operator.AdditionMask, null));
 			temp.Add (new PredefinedPointerOperator (TypeManager.uint32_type, null, Operator.AdditionMask, null));
 			temp.Add (new PredefinedPointerOperator (TypeManager.int64_type, null, Operator.AdditionMask, null));
 			temp.Add (new PredefinedPointerOperator (TypeManager.uint64_type, null, Operator.AdditionMask, null));
 
 			//
 			// long operator - (T* x, T *y)
 			//
 			temp.Add (new PredefinedPointerOperator (null, Operator.SubtractionMask, TypeManager.int64_type));
 
 			pointer_operators = temp.ToArray ();
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="20" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="254" endline="599">
<![CDATA[
 		static readonly char[] simple_whitespaces = new char[] { ' ', '\t' };
 
 		public bool PropertyParsing {
 			get { return handle_get_set; }
 			set { handle_get_set = value; }
 		}
 
 		public bool EventParsing {
 			get { return handle_remove_add; }
 			set { handle_remove_add = value; }
 		}
 
 		public bool ConstraintsParsing {
 			get { return handle_where; }
 			set { handle_where = value; }
 		}
 
 		public bool TypeOfParsing {
 			get { return handle_typeof; }
 			set { handle_typeof = value; }
 		}
 
 		public int TabSize {
 			get { return tab_size; }
 			set { tab_size = value; }
 		}
 		
 		public XmlCommentState doc_state {
 			get { return xml_doc_state; }
 			set {
 				if (value == XmlCommentState.Allowed) {
 					check_incorrect_doc_comment ();
 					reset_doc_comment ();
 				}
 				xml_doc_state = value;
 			}
 		}
 
 		//
 		// This is used to trigger completion generation on the parser
 		public bool CompleteOnEOF;
 		
 		void AddEscapedIdentifier (Location loc)
 		{
 			if (escaped_identifiers == null)
 				escaped_identifiers = new List<Location> ();
 
 			escaped_identifiers.Add (loc);
 		}
 
 		public bool IsEscapedIdentifier (MemberName name)
 		{
 			return escaped_identifiers != null && escaped_identifiers.Contains (name.Location);
 		}
 
 		//
 		// Class variables
 		// 
 		static KeywordEntry<int>[][] keywords;
 		static KeywordEntry<PreprocessorDirective>[][] keywords_preprocessor;
 		static Dictionary<string, object> keyword_strings; 		// TODO
 		static NumberStyles styles;
 		static NumberFormatInfo csharp_format_info;
 
 		// Pragma arguments
 		static readonly char[] pragma_warning = "warning".ToCharArray ();
 		static readonly char[] pragma_warning_disable = "disable".ToCharArray ();
 		static readonly char[] pragma_warning_restore = "restore".ToCharArray ();
 		static readonly char[] pragma_checksum = "checksum".ToCharArray ();
 		
 		//
 		// Values for the associated token returned
 		//
 		internal int putback_char; 	// Used by repl only
 		object val;
 
 		//
 		// Pre-processor
 		//
 		const int TAKING        = 1;
 		const int ELSE_SEEN     = 4;
 		const int PARENT_TAKING = 8;
 		const int REGION        = 16;		
 
 		//
 		// pre-processor if stack state
 		//
 		Stack<int> ifstack;
 
 		static System.Text.StringBuilder string_builder;
 
 		const int max_id_size = 512;
 		static char [] id_builder = new char [max_id_size];
 
 		public static Dictionary<char[], string>[] identifiers = new Dictionary<char[], string>[max_id_size + 1];
 
 		const int max_number_size = 512;
 		static char [] number_builder = new char [max_number_size];
 		static int number_pos;
 
 		static StringBuilder static_cmd_arg = new System.Text.StringBuilder ();
 		
 		public int Line {
 			get {
 				return ref_line;
 			}
 		}
 
 		//
 		// This is used when the tokenizer needs to save
 		// the current position as it needs to do some parsing
 		// on its own to deamiguate a token in behalf of the
 		// parser.
 		//
 		Stack<Position> position_stack = new Stack<Position> (2);
 
 		class Position {
 			public int position;
 			public int line;
 			public int ref_line;
 			public int col;
 			public bool hidden;
 			public int putback_char;
 			public int previous_col;
 			public Stack<int> ifstack;
 			public int parsing_generic_less_than;
 			public int current_token;
 			public object val;
 
 			public Position (Tokenizer t)
 			{
 				position = t.reader.Position;
 				line = t.line;
 				ref_line = t.ref_line;
 				col = t.col;
 				hidden = t.hidden;
 				putback_char = t.putback_char;
 				previous_col = t.previous_col;
 				if (t.ifstack != null && t.ifstack.Count != 0) {
 					// There is no simple way to clone Stack<T> all
 					// methods reverse the order
 					var clone = t.ifstack.ToArray ();
 					Array.Reverse (clone);
 					ifstack = new Stack<int> (clone);
 				}
 				parsing_generic_less_than = t.parsing_generic_less_than;
 				current_token = t.current_token;
 				val = t.val;
 			}
 		}
 		
 		public void PushPosition ()
 		{
 			position_stack.Push (new Position (this));
 		}
 
 		public void PopPosition ()
 		{
 			Position p = position_stack.Pop ();
 
 			reader.Position = p.position;
 			ref_line = p.ref_line;
 			line = p.line;
 			col = p.col;
 			hidden = p.hidden;
 			putback_char = p.putback_char;
 			previous_col = p.previous_col;
 			ifstack = p.ifstack;
 			parsing_generic_less_than = p.parsing_generic_less_than;
 			current_token = p.current_token;
 			val = p.val;
 		}
 
 		// Do not reset the position, ignore it.
 		public void DiscardPosition ()
 		{
 			position_stack.Pop ();
 		}
 		
 		static void AddKeyword (string kw, int token)
 		{
 			keyword_strings.Add (kw, null);
 
 			AddKeyword (keywords, kw, token);
 		}
 
 		static void AddPreprocessorKeyword (string kw, PreprocessorDirective directive)
 		{
 			AddKeyword (keywords_preprocessor, kw, directive);
 		}
 
 		static void AddKeyword<T> (KeywordEntry<T>[][] keywords, string kw, T token)
 		{
 			int length = kw.Length;
 			if (keywords[length] == null) {
 				keywords[length] = new KeywordEntry<T>['z' - '_' + 1];
 			}
 
 			int char_index = kw[0] - '_';
 			var kwe = keywords[length][char_index];
 			if (kwe == null) {
 				keywords[length][char_index] = new KeywordEntry<T> (kw, token);
 				return;
 			}
 
 			while (kwe.Next != null) {
 				kwe = kwe.Next;
 			}
 
 			kwe.Next = new KeywordEntry<T> (kw, token);
 		}
 
 		static void InitTokens ()
 		{
 			keyword_strings = new Dictionary<string, object> ();
 
 			// 11 is the length of the longest keyword for now
 			keywords = new KeywordEntry<int> [11] [];
 
 			AddKeyword ("__arglist", Token.ARGLIST);
 			AddKeyword ("abstract", Token.ABSTRACT);
 			AddKeyword ("as", Token.AS);
 			AddKeyword ("add", Token.ADD);
 			AddKeyword ("base", Token.BASE);
 			AddKeyword ("bool", Token.BOOL);
 			AddKeyword ("break", Token.BREAK);
 			AddKeyword ("byte", Token.BYTE);
 			AddKeyword ("case", Token.CASE);
 			AddKeyword ("catch", Token.CATCH);
 			AddKeyword ("char", Token.CHAR);
 			AddKeyword ("checked", Token.CHECKED);
 			AddKeyword ("class", Token.CLASS);
 			AddKeyword ("const", Token.CONST);
 			AddKeyword ("continue", Token.CONTINUE);
 			AddKeyword ("decimal", Token.DECIMAL);
 			AddKeyword ("default", Token.DEFAULT);
 			AddKeyword ("delegate", Token.DELEGATE);
 			AddKeyword ("do", Token.DO);
 			AddKeyword ("double", Token.DOUBLE);
 			AddKeyword ("else", Token.ELSE);
 			AddKeyword ("enum", Token.ENUM);
 			AddKeyword ("event", Token.EVENT);
 			AddKeyword ("explicit", Token.EXPLICIT);
 			AddKeyword ("extern", Token.EXTERN);
 			AddKeyword ("false", Token.FALSE);
 			AddKeyword ("finally", Token.FINALLY);
 			AddKeyword ("fixed", Token.FIXED);
 			AddKeyword ("float", Token.FLOAT);
 			AddKeyword ("for", Token.FOR);
 			AddKeyword ("foreach", Token.FOREACH);
 			AddKeyword ("goto", Token.GOTO);
 			AddKeyword ("get", Token.GET);
 			AddKeyword ("if", Token.IF);
 			AddKeyword ("implicit", Token.IMPLICIT);
 			AddKeyword ("in", Token.IN);
 			AddKeyword ("int", Token.INT);
 			AddKeyword ("interface", Token.INTERFACE);
 			AddKeyword ("internal", Token.INTERNAL);
 			AddKeyword ("is", Token.IS);
 			AddKeyword ("lock", Token.LOCK);
 			AddKeyword ("long", Token.LONG);
 			AddKeyword ("namespace", Token.NAMESPACE);
 			AddKeyword ("new", Token.NEW);
 			AddKeyword ("null", Token.NULL);
 			AddKeyword ("object", Token.OBJECT);
 			AddKeyword ("operator", Token.OPERATOR);
 			AddKeyword ("out", Token.OUT);
 			AddKeyword ("override", Token.OVERRIDE);
 			AddKeyword ("params", Token.PARAMS);
 			AddKeyword ("private", Token.PRIVATE);
 			AddKeyword ("protected", Token.PROTECTED);
 			AddKeyword ("public", Token.PUBLIC);
 			AddKeyword ("readonly", Token.READONLY);
 			AddKeyword ("ref", Token.REF);
 			AddKeyword ("remove", Token.REMOVE);
 			AddKeyword ("return", Token.RETURN);
 			AddKeyword ("sbyte", Token.SBYTE);
 			AddKeyword ("sealed", Token.SEALED);
 			AddKeyword ("set", Token.SET);
 			AddKeyword ("short", Token.SHORT);
 			AddKeyword ("sizeof", Token.SIZEOF);
 			AddKeyword ("stackalloc", Token.STACKALLOC);
 			AddKeyword ("static", Token.STATIC);
 			AddKeyword ("string", Token.STRING);
 			AddKeyword ("struct", Token.STRUCT);
 			AddKeyword ("switch", Token.SWITCH);
 			AddKeyword ("this", Token.THIS);
 			AddKeyword ("throw", Token.THROW);
 			AddKeyword ("true", Token.TRUE);
 			AddKeyword ("try", Token.TRY);
 			AddKeyword ("typeof", Token.TYPEOF);
 			AddKeyword ("uint", Token.UINT);
 			AddKeyword ("ulong", Token.ULONG);
 			AddKeyword ("unchecked", Token.UNCHECKED);
 			AddKeyword ("unsafe", Token.UNSAFE);
 			AddKeyword ("ushort", Token.USHORT);
 			AddKeyword ("using", Token.USING);
 			AddKeyword ("virtual", Token.VIRTUAL);
 			AddKeyword ("void", Token.VOID);
 			AddKeyword ("volatile", Token.VOLATILE);
 			AddKeyword ("while", Token.WHILE);
 			AddKeyword ("partial", Token.PARTIAL);
 			AddKeyword ("where", Token.WHERE);
 			AddKeyword ("async", Token.ASYNC);
 
 			// LINQ keywords
 			AddKeyword ("from", Token.FROM);
 			AddKeyword ("join", Token.JOIN);
 			AddKeyword ("on", Token.ON);
 			AddKeyword ("equals", Token.EQUALS);
 			AddKeyword ("select", Token.SELECT);
 			AddKeyword ("group", Token.GROUP);
 			AddKeyword ("by", Token.BY);
 			AddKeyword ("let", Token.LET);
 			AddKeyword ("orderby", Token.ORDERBY);
 			AddKeyword ("ascending", Token.ASCENDING);
 			AddKeyword ("descending", Token.DESCENDING);
 			AddKeyword ("into", Token.INTO);
 
 			keywords_preprocessor = new KeywordEntry<PreprocessorDirective>[10][];
 
 			AddPreprocessorKeyword ("region", PreprocessorDirective.Region);
 			AddPreprocessorKeyword ("endregion", PreprocessorDirective.Endregion);
 			AddPreprocessorKeyword ("if", PreprocessorDirective.If);
 			AddPreprocessorKeyword ("endif", PreprocessorDirective.Endif);
 			AddPreprocessorKeyword ("elif", PreprocessorDirective.Elif);
 			AddPreprocessorKeyword ("else", PreprocessorDirective.Else);
 			AddPreprocessorKeyword ("define", PreprocessorDirective.Define);
 			AddPreprocessorKeyword ("undef", PreprocessorDirective.Undef);
 			AddPreprocessorKeyword ("error", PreprocessorDirective.Error);
 			AddPreprocessorKeyword ("warning", PreprocessorDirective.Warning);
 			AddPreprocessorKeyword ("pragma", PreprocessorDirective.Pragma);
 			AddPreprocessorKeyword ("line", PreprocessorDirective.Line);
 		}
 
 		//
 		// Class initializer
 		// 
 		static Tokenizer ()
 		{
 			InitTokens ();			
 			csharp_format_info = NumberFormatInfo.InvariantInfo;
 			styles = NumberStyles.Float;
 
 			string_builder = new System.Text.StringBuilder ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\rootcontext.cs" startline="200" endline="241">
<![CDATA[
 		
 		public static void Reset (bool full)
 		{
 			if (!full)
 				return;
 			
 			Checked = false;
 			Unsafe = false;
 			StdLib = true;
 			StrongNameKeyFile = null;
 			StrongNameKeyContainer = null;
 			StrongNameDelaySign = false;
 			MainClass = null;
 			OutputFile = null;
 			Target = Target.Exe;
 			SdkVersion = SdkVersion.v2;
 			TargetExt = ".exe";
 			Platform = Platform.AnyCPU;
 			Version = LanguageVersion.Default;
 			VerifyClsCompliance = true;
 			Optimize = true;
 			Encoding = Encoding.Default;
 			Documentation = null;
 			GenerateDebugInfo = false;
 			ParseOnly = false;
 			TokenizeOnly = false;
 			Win32IconFile = null;
 			Win32ResourceFile = null;
 			Resources = null;
 			LoadDefaultReferences = true;
 			AssemblyReferences = new List<string> ();
 			AssemblyReferencesAliases = new List<Tuple<string, string>> ();
 			Modules = new List<string> ();
 			ReferencesLookupPaths = new List<string> ();
 			StdLibRuntimeVersion = RuntimeVersion.v2;
 
 			//
 			// Setup default defines
 			//
 			AllDefines = new List<string> ();
 			AddConditional ("__MonoCS__");
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="498" endline="532">
<![CDATA[
 
 	static public void Reset ()
 	{
 //		object_type = null;
 	
 		// TODO
 		system_type_get_type_from_handle =
 		bool_movenext_void =
 		void_dispose_void =
 		void_monitor_enter_object =
 		void_monitor_exit_object =
 		void_initializearray_array_fieldhandle =
 		int_interlocked_compare_exchange =
 		gen_interlocked_compare_exchange =
 		methodbase_get_type_from_handle =
 		methodbase_get_type_from_handle_generic =
 		fieldinfo_get_field_from_handle =
 		fieldinfo_get_field_from_handle_generic =
 		activator_create_instance =
 		delegate_combine_delegate_delegate =
 		delegate_remove_delegate_delegate = null;
 
 		int_get_offset_to_string_data =
 		ienumerator_getcurrent = null;
 
 		void_decimal_ctor_five_args =
 		void_decimal_ctor_int_arg =
 		void_decimal_ctor_long_arg = null;
 
 		string_empty = null;
 
 		typed_reference_type = arg_iterator_type = mbr_type =
 		generic_ilist_type = generic_icollection_type = generic_ienumerator_type =
 		generic_ienumerable_type = generic_nullable_type = expression_type = null;
 	}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="21" nfragments="3" Csharpe_files="3" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\Mono.CompilerServices.SymbolWriter\MonoSymbolFile.cs" startline="151" endline="176">
<![CDATA[
 	}
 #endif
 
 	public class MonoSymbolFile 
 	{
 		List<MethodEntry> methods = new List<MethodEntry> ();
 		List<SourceFileEntry> sources = new List<SourceFileEntry> ();
 		List<CompileUnitEntry> comp_units = new List<CompileUnitEntry> ();
 		Dictionary<Type, int> type_hash = new Dictionary<Type, int> ();
 		Dictionary<int, AnonymousScopeEntry> anonymous_scopes;
 
 		OffsetTable ot;
 		int last_type_index;
 		int last_method_index;
 		int last_namespace_index;
 
 		public readonly string FileName = "<dynamic>";
 		public readonly int MajorVersion = OffsetTable.MajorVersion;
 		public readonly int MinorVersion = OffsetTable.MinorVersion;
 
 		public int NumLineNumbers;
 
 		internal MonoSymbolFile ()
 		{
 			ot = new OffsetTable ();
 		}
 
 		internal int AddSource (SourceFileEntry source)
 		{
 			sources.Add (source);
 			return sources.Count;
 		}
 
 		internal int AddCompileUnit (CompileUnitEntry entry)
 		{
 			comp_units.Add (entry);
 			return comp_units.Count;
 		}
 
 		internal int DefineType (Type type)
 		{
 			int index;
 			if (type_hash.TryGetValue (type, out index))
 				return index;
 
 			index = ++last_type_index;
 			type_hash.Add (type, index);
 			return index;
 		}
 
 		internal void AddMethod (MethodEntry entry)
 		{
 			methods.Add (entry);
 		}
 
 		public MethodEntry DefineMethod (CompileUnitEntry comp_unit, int token,
 						 ScopeVariable[] scope_vars, LocalVariableEntry[] locals,
 						 LineNumberEntry[] lines, CodeBlockEntry[] code_blocks,
 						 string real_name, MethodEntry.Flags flags,
 						 int namespace_id)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			MethodEntry method = new MethodEntry (
 				this, comp_unit, token, scope_vars, locals, lines, code_blocks, 
 				real_name, flags, namespace_id);
 			AddMethod (method);
 			return method;
 		}
 
 		internal void DefineAnonymousScope (int id)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			if (anonymous_scopes == null)
 				anonymous_scopes = new Dictionary<int, AnonymousScopeEntry>  ();
 
 			anonymous_scopes.Add (id, new AnonymousScopeEntry (id));
 		}
 
 		internal void DefineCapturedVariable (int scope_id, string name, string captured_name,
 						      CapturedVariable.CapturedKind kind)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedVariable (name, captured_name, kind);
 		}
 
 		internal void DefineCapturedScope (int scope_id, int id, string captured_name)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			AnonymousScopeEntry scope = anonymous_scopes [scope_id];
 			scope.AddCapturedScope (id, captured_name);
 		}
 
 		internal int GetNextTypeIndex ()
 		{
 			return ++last_type_index;
 		}
 
 		internal int GetNextMethodIndex ()
 		{
 			return ++last_method_index;
 		}
 
 		internal int GetNextNamespaceIndex ()
 		{
 			return ++last_namespace_index;
 		}
 		
 		void Write (MyBinaryWriter bw, Guid guid)
 		{
 			// Magic number and file version.
 			bw.Write (OffsetTable.Magic);
 			bw.Write (MajorVersion);
 			bw.Write (MinorVersion);
 
 			bw.Write (guid.ToByteArray ());
 
 			//
 			// Offsets of file sections; we must write this after we're done
 			// writing the whole file, so we just reserve the space for it here.
 			//
 			long offset_table_offset = bw.BaseStream.Position;
 			ot.Write (bw, MajorVersion, MinorVersion);
 
 			//
 			// Sort the methods according to their tokens and update their index.
 			//
 			methods.Sort ();
 			for (int i = 0; i < methods.Count; i++)
 				((MethodEntry) methods [i]).Index = i + 1;
 
 			//
 			// Write data sections.
 			//
 			ot.DataSectionOffset = (int) bw.BaseStream.Position;
 			foreach (SourceFileEntry source in sources)
 				source.WriteData (bw);
 			foreach (CompileUnitEntry comp_unit in comp_units)
 				comp_unit.WriteData (bw);
 			foreach (MethodEntry method in methods)
 				method.WriteData (this, bw);
 			ot.DataSectionSize = (int) bw.BaseStream.Position - ot.DataSectionOffset;
 
 			//
 			// Write the method index table.
 			//
 			ot.MethodTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < methods.Count; i++) {
 				MethodEntry entry = (MethodEntry) methods [i];
 				entry.Write (bw);
 			}
 			ot.MethodTableSize = (int) bw.BaseStream.Position - ot.MethodTableOffset;
 
 			//
 			// Write source table.
 			//
 			ot.SourceTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < sources.Count; i++) {
 				SourceFileEntry source = (SourceFileEntry) sources [i];
 				source.Write (bw);
 			}
 			ot.SourceTableSize = (int) bw.BaseStream.Position - ot.SourceTableOffset;
 
 			//
 			// Write compilation unit table.
 			//
 			ot.CompileUnitTableOffset = (int) bw.BaseStream.Position;
 			for (int i = 0; i < comp_units.Count; i++) {
 				CompileUnitEntry unit = (CompileUnitEntry) comp_units [i];
 				unit.Write (bw);
 			}
 			ot.CompileUnitTableSize = (int) bw.BaseStream.Position - ot.CompileUnitTableOffset;
 
 			//
 			// Write anonymous scope table.
 			//
 			ot.AnonymousScopeCount = anonymous_scopes != null ? anonymous_scopes.Count 
 			ot.AnonymousScopeTableOffset = (int) bw.BaseStream.Position;
 			if (anonymous_scopes != null) {
 				foreach (AnonymousScopeEntry scope in anonymous_scopes.Values)
 					scope.Write (bw);
 			}
 			ot.AnonymousScopeTableSize = (int) bw.BaseStream.Position - ot.AnonymousScopeTableOffset;
 
 			//
 			// Fixup offset table.
 			//
 			ot.TypeCount = last_type_index;
 			ot.MethodCount = methods.Count;
 			ot.SourceCount = sources.Count;
 			ot.CompileUnitCount = comp_units.Count;
 
 			//
 			// Write offset table.
 			//
 			ot.TotalFileSize = (int) bw.BaseStream.Position;
 			bw.Seek ((int) offset_table_offset, SeekOrigin.Begin);
 			ot.Write (bw, MajorVersion, MinorVersion);
 			bw.Seek (0, SeekOrigin.End);
 
 #if false
 			Console.WriteLine ("TOTAL
 					   "{3} methods.", NumLineNumbers, LineNumberSize,
 					   ExtendedLineNumberSize, methods.Count);
 #endif
 		}
 
 		public void CreateSymbolFile (Guid guid, FileStream fs)
 		{
 			if (reader != null)
 				throw new InvalidOperationException ();
 
 			Write (new MyBinaryWriter (fs), guid);
 		}
 
 		MyBinaryReader reader;
 		Dictionary<int, SourceFileEntry> source_file_hash;
 		Dictionary<int, CompileUnitEntry> compile_unit_hash;
 
 		List<MethodEntry> method_list;
 		Dictionary<int, MethodEntry> method_token_hash;
 		Dictionary<string, int> source_name_hash;
 
 		Guid guid;
 
 		MonoSymbolFile (string filename)
 		{
 			this.FileName = filename;
 			FileStream stream = new FileStream (filename, FileMode.Open, FileAccess.Read);
 			reader = new MyBinaryReader (stream);
 
 			try {
 				long magic = reader.ReadInt64 ();
 				int major_version = reader.ReadInt32 ();
 				int minor_version = reader.ReadInt32 ();
 
 				if (magic != OffsetTable.Magic)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' is not a valid " +
 						"Mono symbol file", filename);
 				if (major_version != OffsetTable.MajorVersion)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' has version {1}, " +
 						"but expected {2}", filename, major_version,
 						OffsetTable.MajorVersion);
 				if (minor_version != OffsetTable.MinorVersion)
 					throw new MonoSymbolFileException (
 						"Symbol file `{0}' has version {1}.{2}, " +
 						"but expected {3}.{4}", filename, major_version,
 						minor_version, OffsetTable.MajorVersion,
 						OffsetTable.MinorVersion);
 
 				MajorVersion = major_version;
 				MinorVersion = minor_version;
 				guid = new Guid (reader.ReadBytes (16));
 
 				ot = new OffsetTable (reader, major_version, minor_version);
 			} catch {
 				throw new MonoSymbolFileException (
 					"Cannot read symbol file `{0}'", filename);
 			}
 
 			source_file_hash = new Dictionary<int, SourceFileEntry> ();
 			compile_unit_hash = new Dictionary<int, CompileUnitEntry> ();
 		}
 
 		void CheckGuidMatch (Guid other, string filename, string assembly)
 		{
 			if (other == guid)
 				return;
 
 			throw new MonoSymbolFileException (
 				"Symbol file `{0}' does not match assembly `{1}'",
 				filename, assembly);
 		}
 
 #if CECIL
 		protected MonoSymbolFile (string filename, Mono.Cecil.ModuleDefinition module)
 			
 		{
 			CheckGuidMatch (module.Mvid, filename, module.FullyQualifiedName);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Mono.Cecil.ModuleDefinition module)
 		{
 			return ReadSymbolFile (module, module.FullyQualifiedName);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Mono.Cecil.ModuleDefinition module, string filename)
 		{
 			string name = filename + ".mdb";
 
 			return new MonoSymbolFile (name, module);
 		}
 #else
 		protected MonoSymbolFile (string filename, Assembly assembly) 
 		{
 			// Check that the MDB file matches the assembly, if we have been
 			// passed an assembly.
 			if (assembly == null)
 				return;
 			
 			Module[] modules = assembly.GetModules ();
 			Guid assembly_guid = MonoDebuggerSupport.GetGuid (modules [0]);
 
 			CheckGuidMatch (assembly_guid, filename, assembly.Location);
 		}
 
 		public static MonoSymbolFile ReadSymbolFile (Assembly assembly)
 		{
 			string filename = assembly.Location;
 			string name = filename + ".mdb";
 
 			return new MonoSymbolFile (name, assembly);
 		}
 #endif
 
 		public static MonoSymbolFile ReadSymbolFile (string mdbFilename)
 		{
 			return new MonoSymbolFile (mdbFilename, null);
 		}
 
 		public int CompileUnitCount {
 			get { return ot.CompileUnitCount; }
 		}
 
 		public int SourceCount {
 			get { return ot.SourceCount; }
 		}
 
 		public int MethodCount {
 			get { return ot.MethodCount; }
 		}
 
 		public int TypeCount {
 			get { return ot.TypeCount; }
 		}
 
 		public int AnonymousScopeCount {
 			get { return ot.AnonymousScopeCount; }
 		}
 
 		public int NamespaceCount {
 			get { return last_namespace_index; }
 		}
 
 		public Guid Guid {
 			get { return guid; }
 		}
 
 		public OffsetTable OffsetTable {
 			get { return ot; }
 		}
 
 		internal int LineNumberCount = 0;
 		internal int LocalCount = 0;
 		internal int StringSize = 0;
 
 		internal int LineNumberSize = 0;
 		internal int ExtendedLineNumberSize = 0;
 		internal MonoSymbolFile ()
 		{
 			ot = new OffsetTable ();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Writer\PEWriter.cs" startline="168" endline="198">
<![CDATA[
 		public WORD Magic = IMAGE_NT_OPTIONAL_HDR32_MAGIC;
 		public BYTE MajorLinkerVersion = 8;
 		public BYTE MinorLinkerVersion = 0;
 		public DWORD SizeOfCode;
 		public DWORD SizeOfInitializedData;
 		public DWORD SizeOfUninitializedData;
 		public DWORD AddressOfEntryPoint;
 		public DWORD BaseOfCode;
 		public DWORD BaseOfData;
 		public ULONGLONG ImageBase;
 		public DWORD SectionAlignment = 0x2000;
 		public DWORD FileAlignment = 0x200;
 		public WORD MajorOperatingSystemVersion = 4;
 		public WORD MinorOperatingSystemVersion = 0;
 		public WORD MajorImageVersion = 0;
 		public WORD MinorImageVersion = 0;
 		public WORD MajorSubsystemVersion = 4;
 		public WORD MinorSubsystemVersion = 0;
 		public DWORD Win32VersionValue = 0;
 		public DWORD SizeOfImage;
 		public DWORD SizeOfHeaders;
 		public DWORD CheckSum = 0;
 		public WORD Subsystem;
 		public WORD DllCharacteristics;
 		public ULONGLONG SizeOfStackReserve = 0x100000;
 		public ULONGLONG SizeOfStackCommit = 0x1000;
 		public ULONGLONG SizeOfHeapReserve = 0x100000;
 		public ULONGLONG SizeOfHeapCommit = 0x1000;
 		public DWORD LoaderFlags = 0;
 		public DWORD NumberOfRvaAndSizes = 16;
 		public IMAGE_DATA_DIRECTORY[] DataDirectory = new IMAGE_DATA_DIRECTORY[16];
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="169" endline="837">
<![CDATA[
 		bool hidden = false;
 		int ref_line = 1;
 		int line = 1;
 		int col = 0;
 		int previous_col;
 		int current_token;
 		int tab_size;
 		bool handle_get_set = false;
 		bool handle_remove_add = false;
 		bool handle_where = false;
 		bool handle_typeof = false;
 		bool lambda_arguments_parsing;
 		Location current_comment_location = Location.Null;
 		List<Location> escaped_identifiers;
 		int parsing_generic_less_than;
 		
 		//
 		// Used mainly for parser optimizations. Some expressions for instance
 		// can appear only in block (including initializer, base initializer)
 		// scope only
 		//
 		public int parsing_block;
 		internal bool query_parsing;
 		
 		// 
 		// When parsing type only, useful for ambiguous nullable types
 		//
 		public int parsing_type;
 		
 		//
 		// Set when parsing generic declaration (type or method header)
 		//
 		public bool parsing_generic_declaration;
 		
 		//
 		// The value indicates that we have not reach any declaration or
 		// namespace yet
 		//
 		public int parsing_declaration;
 
 		//
 		// The special character to inject on streams to trigger the EXPRESSION_PARSE
 		// token to be returned.   It just happens to be a Unicode character that
 		// would never be part of a program (can not be an identifier).
 		//
 		// This character is only tested just before the tokenizer is about to report
 		// an error;   So on the regular operation mode, this addition will have no
 		// impact on the tokenizer's performance.
 		//
 		
 		public const int EvalStatementParserCharacter = 0x2190;   // Unicode Left Arrow
 		public const int EvalCompilationUnitParserCharacter = 0x2191;  // Unicode Arrow
 		public const int EvalUsingDeclarationsParserCharacter = 0x2192;  // Unicode Arrow
 		
 		//
 		// XML documentation buffer. The save point is used to divide
 		// comments on types and comments on members.
 		//
 		StringBuilder xml_comment_buffer;
 
 		//
 		// See comment on XmlCommentState enumeration.
 		//
 		XmlCommentState xml_doc_state = XmlCommentState.Allowed;
 
 		//
 		// Whether tokens have been seen on this line
 		//
 		bool tokens_seen = false;
 
 		//
 		// Set to true once the GENERATE_COMPLETION token has bee
 		// returned.   This helps produce one GENERATE_COMPLETION,
 		// as many COMPLETE_COMPLETION as necessary to complete the
 		// AST tree and one final EOF.
 		//
 		bool generated;
 		
 		//
 		// Whether a token has been seen on the file
 		// This is needed because `define' is not allowed to be used
 		// after a token has been seen.
 		//
 		bool any_token_seen = false;
 
 		static readonly char[] simple_whitespaces = new char[] { ' ', '\t' };
 
 		public bool PropertyParsing {
 			get { return handle_get_set; }
 			set { handle_get_set = value; }
 		}
 
 		public bool EventParsing {
 			get { return handle_remove_add; }
 			set { handle_remove_add = value; }
 		}
 
 		public bool ConstraintsParsing {
 			get { return handle_where; }
 			set { handle_where = value; }
 		}
 
 		public bool TypeOfParsing {
 			get { return handle_typeof; }
 			set { handle_typeof = value; }
 		}
 
 		public int TabSize {
 			get { return tab_size; }
 			set { tab_size = value; }
 		}
 		
 		public XmlCommentState doc_state {
 			get { return xml_doc_state; }
 			set {
 				if (value == XmlCommentState.Allowed) {
 					check_incorrect_doc_comment ();
 					reset_doc_comment ();
 				}
 				xml_doc_state = value;
 			}
 		}
 
 		//
 		// This is used to trigger completion generation on the parser
 		public bool CompleteOnEOF;
 		
 		void AddEscapedIdentifier (Location loc)
 		{
 			if (escaped_identifiers == null)
 				escaped_identifiers = new List<Location> ();
 
 			escaped_identifiers.Add (loc);
 		}
 
 		public bool IsEscapedIdentifier (MemberName name)
 		{
 			return escaped_identifiers != null && escaped_identifiers.Contains (name.Location);
 		}
 
 		//
 		// Class variables
 		// 
 		static KeywordEntry<int>[][] keywords;
 		static KeywordEntry<PreprocessorDirective>[][] keywords_preprocessor;
 		static Dictionary<string, object> keyword_strings; 		// TODO
 		static NumberStyles styles;
 		static NumberFormatInfo csharp_format_info;
 
 		// Pragma arguments
 		static readonly char[] pragma_warning = "warning".ToCharArray ();
 		static readonly char[] pragma_warning_disable = "disable".ToCharArray ();
 		static readonly char[] pragma_warning_restore = "restore".ToCharArray ();
 		static readonly char[] pragma_checksum = "checksum".ToCharArray ();
 		
 		//
 		// Values for the associated token returned
 		//
 		internal int putback_char; 	// Used by repl only
 		object val;
 
 		//
 		// Pre-processor
 		//
 		const int TAKING        = 1;
 		const int ELSE_SEEN     = 4;
 		const int PARENT_TAKING = 8;
 		const int REGION        = 16;		
 
 		//
 		// pre-processor if stack state
 		//
 		Stack<int> ifstack;
 
 		static System.Text.StringBuilder string_builder;
 
 		const int max_id_size = 512;
 		static char [] id_builder = new char [max_id_size];
 
 		public static Dictionary<char[], string>[] identifiers = new Dictionary<char[], string>[max_id_size + 1];
 
 		const int max_number_size = 512;
 		static char [] number_builder = new char [max_number_size];
 		static int number_pos;
 
 		static StringBuilder static_cmd_arg = new System.Text.StringBuilder ();
 		
 		public int Line {
 			get {
 				return ref_line;
 			}
 		}
 
 		//
 		// This is used when the tokenizer needs to save
 		// the current position as it needs to do some parsing
 		// on its own to deamiguate a token in behalf of the
 		// parser.
 		//
 		Stack<Position> position_stack = new Stack<Position> (2);
 
 		class Position {
 			public int position;
 			public int line;
 			public int ref_line;
 			public int col;
 			public bool hidden;
 			public int putback_char;
 			public int previous_col;
 			public Stack<int> ifstack;
 			public int parsing_generic_less_than;
 			public int current_token;
 			public object val;
 
 			public Position (Tokenizer t)
 			{
 				position = t.reader.Position;
 				line = t.line;
 				ref_line = t.ref_line;
 				col = t.col;
 				hidden = t.hidden;
 				putback_char = t.putback_char;
 				previous_col = t.previous_col;
 				if (t.ifstack != null && t.ifstack.Count != 0) {
 					// There is no simple way to clone Stack<T> all
 					// methods reverse the order
 					var clone = t.ifstack.ToArray ();
 					Array.Reverse (clone);
 					ifstack = new Stack<int> (clone);
 				}
 				parsing_generic_less_than = t.parsing_generic_less_than;
 				current_token = t.current_token;
 				val = t.val;
 			}
 		}
 		
 		public void PushPosition ()
 		{
 			position_stack.Push (new Position (this));
 		}
 
 		public void PopPosition ()
 		{
 			Position p = position_stack.Pop ();
 
 			reader.Position = p.position;
 			ref_line = p.ref_line;
 			line = p.line;
 			col = p.col;
 			hidden = p.hidden;
 			putback_char = p.putback_char;
 			previous_col = p.previous_col;
 			ifstack = p.ifstack;
 			parsing_generic_less_than = p.parsing_generic_less_than;
 			current_token = p.current_token;
 			val = p.val;
 		}
 
 		// Do not reset the position, ignore it.
 		public void DiscardPosition ()
 		{
 			position_stack.Pop ();
 		}
 		
 		static void AddKeyword (string kw, int token)
 		{
 			keyword_strings.Add (kw, null);
 
 			AddKeyword (keywords, kw, token);
 		}
 
 		static void AddPreprocessorKeyword (string kw, PreprocessorDirective directive)
 		{
 			AddKeyword (keywords_preprocessor, kw, directive);
 		}
 
 		static void AddKeyword<T> (KeywordEntry<T>[][] keywords, string kw, T token)
 		{
 			int length = kw.Length;
 			if (keywords[length] == null) {
 				keywords[length] = new KeywordEntry<T>['z' - '_' + 1];
 			}
 
 			int char_index = kw[0] - '_';
 			var kwe = keywords[length][char_index];
 			if (kwe == null) {
 				keywords[length][char_index] = new KeywordEntry<T> (kw, token);
 				return;
 			}
 
 			while (kwe.Next != null) {
 				kwe = kwe.Next;
 			}
 
 			kwe.Next = new KeywordEntry<T> (kw, token);
 		}
 
 		static void InitTokens ()
 		{
 			keyword_strings = new Dictionary<string, object> ();
 
 			// 11 is the length of the longest keyword for now
 			keywords = new KeywordEntry<int> [11] [];
 
 			AddKeyword ("__arglist", Token.ARGLIST);
 			AddKeyword ("abstract", Token.ABSTRACT);
 			AddKeyword ("as", Token.AS);
 			AddKeyword ("add", Token.ADD);
 			AddKeyword ("base", Token.BASE);
 			AddKeyword ("bool", Token.BOOL);
 			AddKeyword ("break", Token.BREAK);
 			AddKeyword ("byte", Token.BYTE);
 			AddKeyword ("case", Token.CASE);
 			AddKeyword ("catch", Token.CATCH);
 			AddKeyword ("char", Token.CHAR);
 			AddKeyword ("checked", Token.CHECKED);
 			AddKeyword ("class", Token.CLASS);
 			AddKeyword ("const", Token.CONST);
 			AddKeyword ("continue", Token.CONTINUE);
 			AddKeyword ("decimal", Token.DECIMAL);
 			AddKeyword ("default", Token.DEFAULT);
 			AddKeyword ("delegate", Token.DELEGATE);
 			AddKeyword ("do", Token.DO);
 			AddKeyword ("double", Token.DOUBLE);
 			AddKeyword ("else", Token.ELSE);
 			AddKeyword ("enum", Token.ENUM);
 			AddKeyword ("event", Token.EVENT);
 			AddKeyword ("explicit", Token.EXPLICIT);
 			AddKeyword ("extern", Token.EXTERN);
 			AddKeyword ("false", Token.FALSE);
 			AddKeyword ("finally", Token.FINALLY);
 			AddKeyword ("fixed", Token.FIXED);
 			AddKeyword ("float", Token.FLOAT);
 			AddKeyword ("for", Token.FOR);
 			AddKeyword ("foreach", Token.FOREACH);
 			AddKeyword ("goto", Token.GOTO);
 			AddKeyword ("get", Token.GET);
 			AddKeyword ("if", Token.IF);
 			AddKeyword ("implicit", Token.IMPLICIT);
 			AddKeyword ("in", Token.IN);
 			AddKeyword ("int", Token.INT);
 			AddKeyword ("interface", Token.INTERFACE);
 			AddKeyword ("internal", Token.INTERNAL);
 			AddKeyword ("is", Token.IS);
 			AddKeyword ("lock", Token.LOCK);
 			AddKeyword ("long", Token.LONG);
 			AddKeyword ("namespace", Token.NAMESPACE);
 			AddKeyword ("new", Token.NEW);
 			AddKeyword ("null", Token.NULL);
 			AddKeyword ("object", Token.OBJECT);
 			AddKeyword ("operator", Token.OPERATOR);
 			AddKeyword ("out", Token.OUT);
 			AddKeyword ("override", Token.OVERRIDE);
 			AddKeyword ("params", Token.PARAMS);
 			AddKeyword ("private", Token.PRIVATE);
 			AddKeyword ("protected", Token.PROTECTED);
 			AddKeyword ("public", Token.PUBLIC);
 			AddKeyword ("readonly", Token.READONLY);
 			AddKeyword ("ref", Token.REF);
 			AddKeyword ("remove", Token.REMOVE);
 			AddKeyword ("return", Token.RETURN);
 			AddKeyword ("sbyte", Token.SBYTE);
 			AddKeyword ("sealed", Token.SEALED);
 			AddKeyword ("set", Token.SET);
 			AddKeyword ("short", Token.SHORT);
 			AddKeyword ("sizeof", Token.SIZEOF);
 			AddKeyword ("stackalloc", Token.STACKALLOC);
 			AddKeyword ("static", Token.STATIC);
 			AddKeyword ("string", Token.STRING);
 			AddKeyword ("struct", Token.STRUCT);
 			AddKeyword ("switch", Token.SWITCH);
 			AddKeyword ("this", Token.THIS);
 			AddKeyword ("throw", Token.THROW);
 			AddKeyword ("true", Token.TRUE);
 			AddKeyword ("try", Token.TRY);
 			AddKeyword ("typeof", Token.TYPEOF);
 			AddKeyword ("uint", Token.UINT);
 			AddKeyword ("ulong", Token.ULONG);
 			AddKeyword ("unchecked", Token.UNCHECKED);
 			AddKeyword ("unsafe", Token.UNSAFE);
 			AddKeyword ("ushort", Token.USHORT);
 			AddKeyword ("using", Token.USING);
 			AddKeyword ("virtual", Token.VIRTUAL);
 			AddKeyword ("void", Token.VOID);
 			AddKeyword ("volatile", Token.VOLATILE);
 			AddKeyword ("while", Token.WHILE);
 			AddKeyword ("partial", Token.PARTIAL);
 			AddKeyword ("where", Token.WHERE);
 			AddKeyword ("async", Token.ASYNC);
 
 			// LINQ keywords
 			AddKeyword ("from", Token.FROM);
 			AddKeyword ("join", Token.JOIN);
 			AddKeyword ("on", Token.ON);
 			AddKeyword ("equals", Token.EQUALS);
 			AddKeyword ("select", Token.SELECT);
 			AddKeyword ("group", Token.GROUP);
 			AddKeyword ("by", Token.BY);
 			AddKeyword ("let", Token.LET);
 			AddKeyword ("orderby", Token.ORDERBY);
 			AddKeyword ("ascending", Token.ASCENDING);
 			AddKeyword ("descending", Token.DESCENDING);
 			AddKeyword ("into", Token.INTO);
 
 			keywords_preprocessor = new KeywordEntry<PreprocessorDirective>[10][];
 
 			AddPreprocessorKeyword ("region", PreprocessorDirective.Region);
 			AddPreprocessorKeyword ("endregion", PreprocessorDirective.Endregion);
 			AddPreprocessorKeyword ("if", PreprocessorDirective.If);
 			AddPreprocessorKeyword ("endif", PreprocessorDirective.Endif);
 			AddPreprocessorKeyword ("elif", PreprocessorDirective.Elif);
 			AddPreprocessorKeyword ("else", PreprocessorDirective.Else);
 			AddPreprocessorKeyword ("define", PreprocessorDirective.Define);
 			AddPreprocessorKeyword ("undef", PreprocessorDirective.Undef);
 			AddPreprocessorKeyword ("error", PreprocessorDirective.Error);
 			AddPreprocessorKeyword ("warning", PreprocessorDirective.Warning);
 			AddPreprocessorKeyword ("pragma", PreprocessorDirective.Pragma);
 			AddPreprocessorKeyword ("line", PreprocessorDirective.Line);
 		}
 
 		//
 		// Class initializer
 		// 
 		static Tokenizer ()
 		{
 			InitTokens ();			
 			csharp_format_info = NumberFormatInfo.InvariantInfo;
 			styles = NumberStyles.Float;
 
 			string_builder = new System.Text.StringBuilder ();
 		}
 
 		int GetKeyword (char[] id, int id_len)
 		{
 			//
 			// Keywords are stored in an array of arrays grouped by their
 			// length and then by the first character
 			//
 			if (id_len >= keywords.Length || keywords [id_len] == null)
 				return -1;
 
 			int first_index = id [0] - '_';
 			if (first_index > 'z' - '_')
 				return -1;
 
 			var kwe = keywords [id_len] [first_index];
 			if (kwe == null)
 				return -1;
 
 			int res;
 			do {
 				res = kwe.Token;
 				for (int i = 1; i < id_len; ++i) {
 					if (id [i] != kwe.Value [i]) {
 						res = 0;
 						kwe = kwe.Next;
 						break;
 					}
 				}
 			} while (res == 0 && kwe != null);
 
 			if (res == 0)
 				return -1;
 
 			int next_token;
 			switch (res) {
 			case Token.GET
 			case Token.SET
 				if (!handle_get_set)
 					res = -1;
 				break;
 			case Token.REMOVE
 			case Token.ADD
 				if (!handle_remove_add)
 					res = -1;
 				break;
 			case Token.EXTERN
 				if (parsing_declaration == 0)
 					res = Token.EXTERN_ALIAS;
 				break;
 			case Token.DEFAULT
 				if (peek_token () == Token.COLON) {
 					token ();
 					res = Token.DEFAULT_COLON;
 				}
 				break;
 			case Token.WHERE
 				if (!handle_where && !query_parsing)
 					res = -1;
 				break;
 			case Token.FROM
 				//
 				// A query expression is any expression that starts with `from identifier'
 				// followed by any token except ; , =
 				// 
 				if (!query_parsing) {
 					if (lambda_arguments_parsing) {
 						res = -1;
 						break;
 					}
 
 					PushPosition ();
 					// HACK
 					// store identifiers array
 					parsing_generic_less_than = 1;
 					switch (xtoken ()) {
 					case Token.IDENTIFIER
 					case Token.INT
 					case Token.BOOL
 					case Token.BYTE
 					case Token.CHAR
 					case Token.DECIMAL
 					case Token.FLOAT
 					case Token.LONG
 					case Token.OBJECT
 					case Token.STRING
 					case Token.UINT
 					case Token.ULONG
 						next_token = xtoken ();
 						if (next_token == Token.SEMICOLON || next_token == Token.COMMA || next_token == Token.EQUALS)
 							goto default;
 						
 						res = Token.FROM_FIRST;
 						query_parsing = true;
 						if (RootContext.Version <= LanguageVersion.ISO_2)
 							Report.FeatureIsNotAvailable (Location, "query expressions");
 						break;
 					case Token.VOID
 						Expression.Error_VoidInvalidInTheContext (Location, Report);
 						break;
 					default
 						PopPosition ();
 						// HACK
 						// which has been overwritten before we grabbed the identifier
 						id_builder [0] = 'f'; id_builder [1] = 'r'; id_builder [2] = 'o'; id_builder [3] = 'm';
 						return -1;
 					}
 					PopPosition ();
 				}
 				break;
 			case Token.JOIN
 			case Token.ON
 			case Token.EQUALS
 			case Token.SELECT
 			case Token.GROUP
 			case Token.BY
 			case Token.LET
 			case Token.ORDERBY
 			case Token.ASCENDING
 			case Token.DESCENDING
 			case Token.INTO
 				if (!query_parsing)
 					res = -1;
 				break;
 				
 			case Token.USING
 			case Token.NAMESPACE
 				// TODO
 				check_incorrect_doc_comment ();
 				break;
 				
 			case Token.PARTIAL
 				if (parsing_block > 0) {
 					res = -1;
 					break;
 				}
 
 				// Save current position and parse next token.
 				PushPosition ();
 
 				next_token = token ();
 				bool ok = (next_token == Token.CLASS) ||
 					(next_token == Token.STRUCT) ||
 					(next_token == Token.INTERFACE) ||
 					(next_token == Token.VOID);
 
 				PopPosition ();
 
 				if (ok) {
 					if (next_token == Token.VOID) {
 						if (RootContext.Version == LanguageVersion.ISO_1 ||
 						    RootContext.Version == LanguageVersion.ISO_2)
 							Report.FeatureIsNotAvailable (Location, "partial methods");
 					} else if (RootContext.Version == LanguageVersion.ISO_1)
 						Report.FeatureIsNotAvailable (Location, "partial types");
 
 					return res;
 				}
 
 				if (next_token < Token.LAST_KEYWORD) {
 					Report.Error (267, Location,
 						"The `partial' modifier can be used only immediately before `class', `struct', `interface', or `void' keyword");
 					return token ();
 				}					
 
 				res = -1;
 				break;
 
 			case Token.ASYNC
 				if (parsing_block > 0 || RootContext.Version != LanguageVersion.Future) {
 					res = -1;
 					break;
 				}
 				break;
 			}
 
 			return res;
 		}
 
 		static PreprocessorDirective GetPreprocessorDirective (char[] id, int id_len)
 		{
 			//
 			// Keywords are stored in an array of arrays grouped by their
 			// length and then by the first character
 			//
 			if (id_len >= keywords_preprocessor.Length || keywords_preprocessor[id_len] == null)
 				return PreprocessorDirective.Invalid;
 
 			int first_index = id[0] - '_';
 			if (first_index > 'z' - '_')
 				return PreprocessorDirective.Invalid;
 
 			var kwe = keywords_preprocessor[id_len][first_index];
 			if (kwe == null)
 				return PreprocessorDirective.Invalid;
 
 			PreprocessorDirective res = PreprocessorDirective.Invalid;
 			do {
 				res = kwe.Token;
 				for (int i = 1; i < id_len; ++i) {
 					if (id[i] != kwe.Value[i]) {
 						res = 0;
 						kwe = kwe.Next;
 						break;
 					}
 				}
 			} while (res == PreprocessorDirective.Invalid && kwe != null);
 
 			return res;
 		}
 
 		public Location Location {
 			get {
 				return new Location (ref_line, hidden ? -1 
 			}
 		}
 
 		public Tokenizer (SeekableStreamReader input, CompilationUnit file, CompilerContext ctx)
 		{
 			this.ref_name = file;
 			this.file_name = file;
 			this.context = ctx;
 			reader = input;
 			
 			putback_char = -1;
 
 			xml_comment_buffer = new StringBuilder ();
 
 			if (Environment.OSVersion.Platform == PlatformID.Win32NT)
 				tab_size = 4;
 			else
 				tab_size = 8;
 
 			//
 			// FIXME
 			// find out why the MS compiler allows this
 			//
 			Mono.CSharp.Location.Push (file, file);
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="22" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\driver.cs" startline="524" endline="793">
<![CDATA[
 		
 		//
 		// Currently handles the Unix-like command line options, but will be
 		// deprecated in favor of the CSCParseOption, which will also handle the
 		// options that start with a dash in the future.
 		//
 		bool UnixParseOption (string arg, ref string [] args, ref int i)
 		{
 			switch (arg){
 			case "-v"
 				CSharpParser.yacc_verbose_flag++;
 				return true;
 
 			case "--version"
 				Version ();
 				return true;
 				
 			case "--parse"
 				RootContext.ParseOnly = true;
 				return true;
 				
 			case "--main"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.MainClass = args [++i];
 				return true;
 				
 			case "--unsafe"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.Unsafe = true;
 				return true;
 				
 			case "/?"
 			case "--help"
 				Usage ();
 				Environment.Exit (0);
 				return true;
 
 			case "--define"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.AddConditional (args [++i]);
 				return true;
 
 			case "--tokenize"
 				RootContext.TokenizeOnly = true;
 				return true;
 				
 			case "-o"
 			case "--output"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				RootContext.OutputFile = args [++i];
 				return true;
 
 			case "--checked"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.Checked = true;
 				return true;
 				
 			case "--stacktrace"
 				Report.Printer.Stacktrace = true;
 				return true;
 				
 			case "--linkresource"
 			case "--linkres"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Report.Error (5, "Missing argument to --linkres"); 
 					Environment.Exit (1);
 				}
 
 				AddResource (new AssemblyResource (args[++i], args[i]));
 				return true;
 				
 			case "--resource"
 			case "--res"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Report.Error (5, "Missing argument to --resource"); 
 					Environment.Exit (1);
 				}
 
 				AddResource (new AssemblyResource (args[++i], args[i], true));
 				return true;
 				
 			case "--target"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Environment.Exit (1);
 					return true;
 				}
 				
 				string type = args [++i];
 				switch (type){
 				case "library"
 					RootContext.Target = Target.Library;
 					RootContext.TargetExt = ".dll";
 					break;
 					
 				case "exe"
 					RootContext.Target = Target.Exe;
 					break;
 					
 				case "winexe"
 					RootContext.Target = Target.WinExe;
 					break;
 					
 				case "module"
 					RootContext.Target = Target.Module;
 					RootContext.TargetExt = ".dll";
 					break;
 				default
 					TargetUsage ();
 					break;
 				}
 				return true;
 				
 			case "-r"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				
 				string val = args [++i];
 				int idx = val.IndexOf ('=');
 				if (idx > -1) {
 					string alias = val.Substring (0, idx);
 					string assembly = val.Substring (idx + 1);
 					AddAssemblyReference (alias, assembly);
 					return true;
 				}
 
 				AddAssemblyReference (val);
 				return true;
 				
 			case "-L"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();	
 					Environment.Exit (1);
 				}
 				RootContext.ReferencesLookupPaths.Add (args [++i]);
 				return true;
 
 			case "--lint"
 				RootContext.EnhancedWarnings = true;
 				return true;
 				
 			case "--nostdlib"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.StdLib = false;
 				return true;
 				
 			case "--nowarn"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Usage ();
 					Environment.Exit (1);
 				}
 				int warn = 0;
 				
 				try {
 					warn = Int32.Parse (args [++i]);
 				} catch {
 					Usage ();
 					Environment.Exit (1);
 				}
 				Report.SetIgnoreWarning (warn);
 				return true;
 
 			case "--wlevel"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Report.Error (
 						1900,
 						"--wlevel requires a value from 0 to 4");
 					Environment.Exit (1);
 				}
 
 				SetWarningLevel (args [++i]);
 				return true;
 
 			case "--mcs-debug"
 				if ((i + 1) >= args.Length){
 					Report.Error (5, "--mcs-debug requires an argument");
 					Environment.Exit (1);
 				}
 
 				try {
 					Report.DebugFlags = Int32.Parse (args [++i]);
 				} catch {
 					Report.Error (5, "Invalid argument to --mcs-debug");
 					Environment.Exit (1);
 				}
 				return true;
 				
 			case "--about"
 				About ();
 				return true;
 				
 			case "--recurse"
 				Report.Warning (-29, 1, "Compatibility
 				if ((i + 1) >= args.Length){
 					Report.Error (5, "--recurse requires an argument");
 					Environment.Exit (1);
 				}
 				ProcessSourceFiles (args [++i], true); 
 				return true;
 				
 			case "--timestamp"
 				timestamps = true;
 				return true;
 
 			case "--debug"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.GenerateDebugInfo = true;
 				return true;
 				
 			case "--noconfig"
 				Report.Warning (-29, 1, "Compatibility
 				RootContext.LoadDefaultReferences = false;
 				return true;
 
 			default
 				if (arg.StartsWith ("--fatal")){
 					if (arg.StartsWith ("--fatal=")){
 						if (!Int32.TryParse (arg.Substring (8), out fatal_errors))
 							fatal_errors = 1;
 					} else
 						fatal_errors = 1;
 					return true;
 				}
 				if (arg.StartsWith ("--runtime
 					string version = arg.Substring (10);
 
 					switch (version) {
 					case "v1"
 					case "V1"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v1;
 						break;
 					case "v2"
 					case "V2"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v2;
 						return true;
 					case "v4"
 					case "V4"
 						RootContext.StdLibRuntimeVersion = RuntimeVersion.v4;
 						return true;
 					}
 					return true;
 				}
 
 				break;
 			}
 
 			return false;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-tokenizer.cs" startline="2757" endline="3230">
<![CDATA[
 		
 		public int xtoken ()
 		{
 			int d, c;
 
 			// Whether we have seen comments on the current line
 			bool comments_seen = false;
 			while ((c = get_char ()) != -1) {
 				switch (c) {
 				case '\t'
 					col = ((col - 1 + tab_size) / tab_size) * tab_size;
 					continue;
 
 				case ' '
 				case '\f'
 				case '\v'
 				case 0xa0
 				case 0
 				case 0xFEFF
 					continue;
 
 /*				This is required for compatibility with .NET
 				case 0xEF
 					if (peek_char () == 0xBB) {
 						PushPosition ();
 						get_char ();
 						if (get_char () == 0xBF)
 							continue;
 						PopPosition ();
 					}
 					break;
 */
 				case '\r'
 					if (peek_char () != '\n')
 						advance_line ();
 					else
 						get_char ();
 
 					any_token_seen |= tokens_seen;
 					tokens_seen = false;
 					comments_seen = false;
 					continue;
 
 				case '\\'
 					tokens_seen = true;
 					return consume_identifier (c);
 
 				case '{'
 					val = LocatedToken.Create (ref_line, col);
 					return Token.OPEN_BRACE;
 				case '}'
 					val = LocatedToken.Create (ref_line, col);
 					return Token.CLOSE_BRACE;
 				case '['
 					// To block doccomment inside attribute declaration.
 					if (doc_state == XmlCommentState.Allowed)
 						doc_state = XmlCommentState.NotAllowed;
 
 					val = LocatedToken.Create (ref_line, col);
 
 					if (parsing_block == 0 || lambda_arguments_parsing)
 						return Token.OPEN_BRACKET;
 
 					int next = peek_char ();
 					switch (next) {
 					case ']'
 					case ','
 						return Token.OPEN_BRACKET;
 
 					case ' '
 					case '\f'
 					case '\v'
 					case '\r'
 					case '\n'
 					case '/'
 						next = peek_token ();
 						if (next == Token.COMMA || next == Token.CLOSE_BRACKET)
 							return Token.OPEN_BRACKET;
 
 						return Token.OPEN_BRACKET_EXPR;
 					default
 						return Token.OPEN_BRACKET_EXPR;
 					}
 				case ']'
 					LocatedToken.CreateOptional (ref_line, col, ref val);
 					return Token.CLOSE_BRACKET;
 				case '('
 					val = LocatedToken.Create (ref_line, col);
 					//
 					// An expression versions of parens can appear in block context only
 					//
 					if (parsing_block != 0 && !lambda_arguments_parsing) {
 						
 						//
 						// Optmize most common case where we know that parens
 						// is not special
 						//
 						switch (current_token) {
 						case Token.IDENTIFIER
 						case Token.IF
 						case Token.FOR
 						case Token.FOREACH
 						case Token.TYPEOF
 						case Token.WHILE
 						case Token.USING
 						case Token.DEFAULT
 						case Token.DELEGATE
 						case Token.OP_GENERICS_GT
 							return Token.OPEN_PARENS;
 						}
 
 						// Optimize using peek
 						int xx = peek_char ();
 						switch (xx) {
 						case '('
 						case '\''
 						case '"'
 						case '0'
 						case '1'
 							return Token.OPEN_PARENS;
 						}
 
 						lambda_arguments_parsing = true;
 						PushPosition ();
 						d = TokenizeOpenParens ();
 						PopPosition ();
 						lambda_arguments_parsing = false;
 						return d;
 					}
 
 					return Token.OPEN_PARENS;
 				case ')'
 					LocatedToken.CreateOptional (ref_line, col, ref val);
 					return Token.CLOSE_PARENS;
 				case ','
 					LocatedToken.CreateOptional (ref_line, col, ref val);
 					return Token.COMMA;
 				case ';'
 					LocatedToken.CreateOptional (ref_line, col, ref val);
 					return Token.SEMICOLON;
 				case '~'
 					val = LocatedToken.Create (ref_line, col);
 					return Token.TILDE;
 				case '?'
 					val = LocatedToken.Create (ref_line, col);
 					return TokenizePossibleNullableType ();
 				case '<'
 					val = LocatedToken.Create (ref_line, col);
 					if (parsing_generic_less_than++ > 0)
 						return Token.OP_GENERICS_LT;
 
 					return TokenizeLessThan ();
 
 				case '>'
 					val = LocatedToken.Create (ref_line, col);
 					d = peek_char ();
 
 					if (d == '='){
 						get_char ();
 						return Token.OP_GE;
 					}
 
 					if (parsing_generic_less_than > 1 || (parsing_generic_less_than == 1 && d != '>')) {
 						parsing_generic_less_than--;
 						return Token.OP_GENERICS_GT;
 					}
 
 					if (d == '>') {
 						get_char ();
 						d = peek_char ();
 
 						if (d == '=') {
 							get_char ();
 							return Token.OP_SHIFT_RIGHT_ASSIGN;
 						}
 						return Token.OP_SHIFT_RIGHT;
 					}
 
 					return Token.OP_GT;
 
 				case '+'
 					val = LocatedToken.Create (ref_line, col);
 					d = peek_char ();
 					if (d == '+') {
 						d = Token.OP_INC;
 					} else if (d == '=') {
 						d = Token.OP_ADD_ASSIGN;
 					} else {
 						return Token.PLUS;
 					}
 					get_char ();
 					return d;
 
 				case '-'
 					val = LocatedToken.Create (ref_line, col);
 					d = peek_char ();
 					if (d == '-') {
 						d = Token.OP_DEC;
 					} else if (d == '=')
 						d = Token.OP_SUB_ASSIGN;
 					else if (d == '>')
 						d = Token.OP_PTR;
 					else {
 						return Token.MINUS;
 					}
 					get_char ();
 					return d;
 
 				case '!'
 					val = LocatedToken.Create (ref_line, col);
 					if (peek_char () == '='){
 						get_char ();
 						return Token.OP_NE;
 					}
 					return Token.BANG;
 
 				case '='
 					val = LocatedToken.Create (ref_line, col);
 					d = peek_char ();
 					if (d == '='){
 						get_char ();
 						return Token.OP_EQ;
 					}
 					if (d == '>'){
 						get_char ();
 						return Token.ARROW;
 					}
 
 					return Token.ASSIGN;
 
 				case '&'
 					val = LocatedToken.Create (ref_line, col);
 					d = peek_char ();
 					if (d == '&'){
 						get_char ();
 						return Token.OP_AND;
 					}
 					if (d == '='){
 						get_char ();
 						return Token.OP_AND_ASSIGN;
 					}
 					return Token.BITWISE_AND;
 
 				case '|'
 					val = LocatedToken.Create (ref_line, col);
 					d = peek_char ();
 					if (d == '|'){
 						get_char ();
 						return Token.OP_OR;
 					}
 					if (d == '='){
 						get_char ();
 						return Token.OP_OR_ASSIGN;
 					}
 					return Token.BITWISE_OR;
 
 				case '*'
 					val = LocatedToken.Create (ref_line, col);
 					if (peek_char () == '='){
 						get_char ();
 						return Token.OP_MULT_ASSIGN;
 					}
 					return Token.STAR;
 
 				case '/'
 					d = peek_char ();
 					if (d == '='){
 						val = LocatedToken.Create (ref_line, col);
 						get_char ();
 						return Token.OP_DIV_ASSIGN;
 					}
 
 					// Handle double-slash comments.
 					if (d == '/'){
 						get_char ();
 						if (RootContext.Documentation != null && peek_char () == '/') {
 							get_char ();
 							// Don't allow ////.
 							if ((d = peek_char ()) != '/') {
 								update_comment_location ();
 								if (doc_state == XmlCommentState.Allowed)
 									handle_one_line_xml_comment ();
 								else if (doc_state == XmlCommentState.NotAllowed)
 									warn_incorrect_doc_comment ();
 							}
 						}
 						while ((d = get_char ()) != -1 && (d != '\n') && d != '\r');
 
 						any_token_seen |= tokens_seen;
 						tokens_seen = false;
 						comments_seen = false;
 						continue;
 					} else if (d == '*'){
 						get_char ();
 						bool docAppend = false;
 						if (RootContext.Documentation != null && peek_char () == '*') {
 							get_char ();
 							update_comment_location ();
 							// But when it is /**/, just do nothing.
 							if (peek_char () == '/') {
 								get_char ();
 								continue;
 							}
 							if (doc_state == XmlCommentState.Allowed)
 								docAppend = true;
 							else if (doc_state == XmlCommentState.NotAllowed)
 								warn_incorrect_doc_comment ();
 						}
 
 						int current_comment_start = 0;
 						if (docAppend) {
 							current_comment_start = xml_comment_buffer.Length;
 							xml_comment_buffer.Append (Environment.NewLine);
 						}
 
 						while ((d = get_char ()) != -1){
 							if (d == '*' && peek_char () == '/'){
 								get_char ();
 								comments_seen = true;
 								break;
 							}
 							if (docAppend)
 								xml_comment_buffer.Append ((char) d);
 							
 							if (d == '\n'){
 								any_token_seen |= tokens_seen;
 								tokens_seen = false;
 								// 
 								// Reset 'comments_seen' just to be consistent.
 								// It doesn't matter either way, here.
 								//
 								comments_seen = false;
 							}
 						}
 						while ((d = get_char ()) != -1){
 							if (d == '*' && peek_char () == '/'){
 								get_char ();
 								comments_seen = true;
 								break;
 							}
 							if (docAppend)
 								xml_comment_buffer.Append ((char) d);
 							
 							if (d == '\n'){
 								any_token_seen |= tokens_seen;
 								tokens_seen = false;
 								// 
 								// Reset 'comments_seen' just to be consistent.
 								// It doesn't matter either way, here.
 								//
 								comments_seen = false;
 							}
 						}
 						if (!comments_seen)
 							Report.Error (1035, Location, "End-of-file found, '*/' expected");
 
 						if (docAppend)
 							update_formatted_doc_comment (current_comment_start);
 						continue;
 					}
 					val = LocatedToken.Create (ref_line, col);
 					return Token.DIV;
 
 				case '%'
 					val = LocatedToken.Create (ref_line, col);
 					if (peek_char () == '='){
 						get_char ();
 						return Token.OP_MOD_ASSIGN;
 					}
 					return Token.PERCENT;
 
 				case '^'
 					val = LocatedToken.Create (ref_line, col);
 					if (peek_char () == '='){
 						get_char ();
 						return Token.OP_XOR_ASSIGN;
 					}
 					return Token.CARRET;
 
 				case '
 					val = LocatedToken.Create (ref_line, col);
 					if (peek_char () == '
 						get_char ();
 						return Token.DOUBLE_COLON;
 					}
 					return Token.COLON;
 
 				case '0'
 				case '5'
 					tokens_seen = true;
 					return is_number (c);
 
 				case '\n'
 					any_token_seen |= tokens_seen;
 					tokens_seen = false;
 					comments_seen = false;
 					continue;
 
 				case '.'
 					tokens_seen = true;
 					d = peek_char ();
 					if (d >= '0' && d <= '9')
 						return is_number (c);
 
 					LocatedToken.CreateOptional (ref_line, col, ref val);
 					return Token.DOT;
 				
 				case '#'
 					if (tokens_seen || comments_seen) {
 						Eror_WrongPreprocessorLocation ();
 						return Token.ERROR;
 					}
 					
 					if (ParsePreprocessingDirective (true))
 						continue;
 
 					bool directive_expected = false;
 					while ((c = get_char ()) != -1) {
 						if (col == 1) {
 							directive_expected = true;
 						} else if (!directive_expected) {
 							// TODO
 //							if (c == '#') {
 //								Eror_WrongPreprocessorLocation ();
 //								return Token.ERROR;
 //							}
 							continue;
 						}
 
 						if (c == ' ' || c == '\t' || c == '\r' || c == '\n' || c == '\f' || c == '\v' )
 							continue;
 
 						if (c == '#') {
 							if (ParsePreprocessingDirective (false))
 								break;
 						}
 						directive_expected = false;
 					}
 					while ((c = get_char ()) != -1) {
 						if (col == 1) {
 							directive_expected = true;
 						} else if (!directive_expected) {
 							// TODO
 //							if (c == '#') {
 //								Eror_WrongPreprocessorLocation ();
 //								return Token.ERROR;
 //							}
 							continue;
 						}
 
 						if (c == ' ' || c == '\t' || c == '\r' || c == '\n' || c == '\f' || c == '\v' )
 							continue;
 
 						if (c == '#') {
 							if (ParsePreprocessingDirective (false))
 								break;
 						}
 						directive_expected = false;
 					}
 
 					if (c != -1) {
 						tokens_seen = false;
 						continue;
 					}
 
 					return Token.EOF;
 				
 				case '"'
 					return consume_string (false);
 
 				case '\''
 					return TokenizeBackslash ();
 				
 				case '@'
 					c = get_char ();
 					if (c == '"') {
 						tokens_seen = true;
 						return consume_string (true);
 					}
 
 					if (is_identifier_start_character (c)){
 						return consume_identifier (c, true);
 					}
 
 					Report.Error (1646, Location, "Keyword, identifier, or string expected after verbatim specifier
 					return Token.ERROR;
 
 				case EvalStatementParserCharacter
 					return Token.EVAL_STATEMENT_PARSER;
 				case EvalCompilationUnitParserCharacter
 					return Token.EVAL_COMPILATION_UNIT_PARSER;
 				case EvalUsingDeclarationsParserCharacter
 					return Token.EVAL_USING_DECLARATIONS_UNIT_PARSER;
 				}
 
 				if (is_identifier_start_character (c)) {
 					tokens_seen = true;
 					return consume_identifier (c);
 				}
 
 				Report.Error (1056, Location, "Unexpected character `{0}'", ((char) c).ToString ());
 			}
 			while ((c = get_char ()) != -1) {
 				switch (c) {
 				case '\t'
 					col = ((col - 1 + tab_size) / tab_size) * tab_size;
 					continue;
 
 				case ' '
 				case '\f'
 				case '\v'
 				case 0xa0
 				case 0
 				case 0xFEFF
 					continue;
 
 /*				This is required for compatibility with .NET
 				case 0xEF
 					if (peek_char () == 0xBB) {
 						PushPosition ();
 						get_char ();
 						if (get_char () == 0xBF)
 							continue;
 						PopPosition ();
 					}
 					break;
 */
 				case '\r'
 					if (peek_char () != '\n')
 						advance_line ();
 					else
 						get_char ();
 
 					any_token_seen |= tokens_seen;
 					tokens_seen = false;
 					comments_seen = false;
 					continue;
 
 				case '\\'
 					tokens_seen = true;
 					return consume_identifier (c);
 
 				case '{'
 					val = LocatedToken.Create (ref_line, col);
 					return Token.OPEN_BRACE;
 				case '}'
 					val = LocatedToken.Create (ref_line, col);
 					return Token.CLOSE_BRACE;
 				case '['
 					// To block doccomment inside attribute declaration.
 					if (doc_state == XmlCommentState.Allowed)
 						doc_state = XmlCommentState.NotAllowed;
 
 					val = LocatedToken.Create (ref_line, col);
 
 					if (parsing_block == 0 || lambda_arguments_parsing)
 						return Token.OPEN_BRACKET;
 
 					int next = peek_char ();
 					switch (next) {
 					case ']'
 					case ','
 						return Token.OPEN_BRACKET;
 
 					case ' '
 					case '\f'
 					case '\v'
 					case '\r'
 					case '\n'
 					case '/'
 						next = peek_token ();
 						if (next == Token.COMMA || next == Token.CLOSE_BRACKET)
 							return Token.OPEN_BRACKET;
 
 						return Token.OPEN_BRACKET_EXPR;
 					default
 						return Token.OPEN_BRACKET_EXPR;
 					}
 				case ']'
 					LocatedToken.CreateOptional (ref_line, col, ref val);
 					return Token.CLOSE_BRACKET;
 				case '('
 					val = LocatedToken.Create (ref_line, col);
 					//
 					// An expression versions of parens can appear in block context only
 					//
 					if (parsing_block != 0 && !lambda_arguments_parsing) {
 						
 						//
 						// Optmize most common case where we know that parens
 						// is not special
 						//
 						switch (current_token) {
 						case Token.IDENTIFIER
 						case Token.IF
 						case Token.FOR
 						case Token.FOREACH
 						case Token.TYPEOF
 						case Token.WHILE
 						case Token.USING
 						case Token.DEFAULT
 						case Token.DELEGATE
 						case Token.OP_GENERICS_GT
 							return Token.OPEN_PARENS;
 						}
 
 						// Optimize using peek
 						int xx = peek_char ();
 						switch (xx) {
 						case '('
 						case '\''
 						case '"'
 						case '0'
 						case '1'
 							return Token.OPEN_PARENS;
 						}
 
 						lambda_arguments_parsing = true;
 						PushPosition ();
 						d = TokenizeOpenParens ();
 						PopPosition ();
 						lambda_arguments_parsing = false;
 						return d;
 					}
 
 					return Token.OPEN_PARENS;
 				case ')'
 					LocatedToken.CreateOptional (ref_line, col, ref val);
 					return Token.CLOSE_PARENS;
 				case ','
 					LocatedToken.CreateOptional (ref_line, col, ref val);
 					return Token.COMMA;
 				case ';'
 					LocatedToken.CreateOptional (ref_line, col, ref val);
 					return Token.SEMICOLON;
 				case '~'
 					val = LocatedToken.Create (ref_line, col);
 					return Token.TILDE;
 				case '?'
 					val = LocatedToken.Create (ref_line, col);
 					return TokenizePossibleNullableType ();
 				case '<'
 					val = LocatedToken.Create (ref_line, col);
 					if (parsing_generic_less_than++ > 0)
 						return Token.OP_GENERICS_LT;
 
 					return TokenizeLessThan ();
 
 				case '>'
 					val = LocatedToken.Create (ref_line, col);
 					d = peek_char ();
 
 					if (d == '='){
 						get_char ();
 						return Token.OP_GE;
 					}
 
 					if (parsing_generic_less_than > 1 || (parsing_generic_less_than == 1 && d != '>')) {
 						parsing_generic_less_than--;
 						return Token.OP_GENERICS_GT;
 					}
 
 					if (d == '>') {
 						get_char ();
 						d = peek_char ();
 
 						if (d == '=') {
 							get_char ();
 							return Token.OP_SHIFT_RIGHT_ASSIGN;
 						}
 						return Token.OP_SHIFT_RIGHT;
 					}
 
 					return Token.OP_GT;
 
 				case '+'
 					val = LocatedToken.Create (ref_line, col);
 					d = peek_char ();
 					if (d == '+') {
 						d = Token.OP_INC;
 					} else if (d == '=') {
 						d = Token.OP_ADD_ASSIGN;
 					} else {
 						return Token.PLUS;
 					}
 					get_char ();
 					return d;
 
 				case '-'
 					val = LocatedToken.Create (ref_line, col);
 					d = peek_char ();
 					if (d == '-') {
 						d = Token.OP_DEC;
 					} else if (d == '=')
 						d = Token.OP_SUB_ASSIGN;
 					else if (d == '>')
 						d = Token.OP_PTR;
 					else {
 						return Token.MINUS;
 					}
 					get_char ();
 					return d;
 
 				case '!'
 					val = LocatedToken.Create (ref_line, col);
 					if (peek_char () == '='){
 						get_char ();
 						return Token.OP_NE;
 					}
 					return Token.BANG;
 
 				case '='
 					val = LocatedToken.Create (ref_line, col);
 					d = peek_char ();
 					if (d == '='){
 						get_char ();
 						return Token.OP_EQ;
 					}
 					if (d == '>'){
 						get_char ();
 						return Token.ARROW;
 					}
 
 					return Token.ASSIGN;
 
 				case '&'
 					val = LocatedToken.Create (ref_line, col);
 					d = peek_char ();
 					if (d == '&'){
 						get_char ();
 						return Token.OP_AND;
 					}
 					if (d == '='){
 						get_char ();
 						return Token.OP_AND_ASSIGN;
 					}
 					return Token.BITWISE_AND;
 
 				case '|'
 					val = LocatedToken.Create (ref_line, col);
 					d = peek_char ();
 					if (d == '|'){
 						get_char ();
 						return Token.OP_OR;
 					}
 					if (d == '='){
 						get_char ();
 						return Token.OP_OR_ASSIGN;
 					}
 					return Token.BITWISE_OR;
 
 				case '*'
 					val = LocatedToken.Create (ref_line, col);
 					if (peek_char () == '='){
 						get_char ();
 						return Token.OP_MULT_ASSIGN;
 					}
 					return Token.STAR;
 
 				case '/'
 					d = peek_char ();
 					if (d == '='){
 						val = LocatedToken.Create (ref_line, col);
 						get_char ();
 						return Token.OP_DIV_ASSIGN;
 					}
 
 					// Handle double-slash comments.
 					if (d == '/'){
 						get_char ();
 						if (RootContext.Documentation != null && peek_char () == '/') {
 							get_char ();
 							// Don't allow ////.
 							if ((d = peek_char ()) != '/') {
 								update_comment_location ();
 								if (doc_state == XmlCommentState.Allowed)
 									handle_one_line_xml_comment ();
 								else if (doc_state == XmlCommentState.NotAllowed)
 									warn_incorrect_doc_comment ();
 							}
 						}
 						while ((d = get_char ()) != -1 && (d != '\n') && d != '\r');
 
 						any_token_seen |= tokens_seen;
 						tokens_seen = false;
 						comments_seen = false;
 						continue;
 					} else if (d == '*'){
 						get_char ();
 						bool docAppend = false;
 						if (RootContext.Documentation != null && peek_char () == '*') {
 							get_char ();
 							update_comment_location ();
 							// But when it is /**/, just do nothing.
 							if (peek_char () == '/') {
 								get_char ();
 								continue;
 							}
 							if (doc_state == XmlCommentState.Allowed)
 								docAppend = true;
 							else if (doc_state == XmlCommentState.NotAllowed)
 								warn_incorrect_doc_comment ();
 						}
 
 						int current_comment_start = 0;
 						if (docAppend) {
 							current_comment_start = xml_comment_buffer.Length;
 							xml_comment_buffer.Append (Environment.NewLine);
 						}
 
 						while ((d = get_char ()) != -1){
 							if (d == '*' && peek_char () == '/'){
 								get_char ();
 								comments_seen = true;
 								break;
 							}
 							if (docAppend)
 								xml_comment_buffer.Append ((char) d);
 							
 							if (d == '\n'){
 								any_token_seen |= tokens_seen;
 								tokens_seen = false;
 								// 
 								// Reset 'comments_seen' just to be consistent.
 								// It doesn't matter either way, here.
 								//
 								comments_seen = false;
 							}
 						}
 						if (!comments_seen)
 							Report.Error (1035, Location, "End-of-file found, '*/' expected");
 
 						if (docAppend)
 							update_formatted_doc_comment (current_comment_start);
 						continue;
 					}
 					val = LocatedToken.Create (ref_line, col);
 					return Token.DIV;
 
 				case '%'
 					val = LocatedToken.Create (ref_line, col);
 					if (peek_char () == '='){
 						get_char ();
 						return Token.OP_MOD_ASSIGN;
 					}
 					return Token.PERCENT;
 
 				case '^'
 					val = LocatedToken.Create (ref_line, col);
 					if (peek_char () == '='){
 						get_char ();
 						return Token.OP_XOR_ASSIGN;
 					}
 					return Token.CARRET;
 
 				case '
 					val = LocatedToken.Create (ref_line, col);
 					if (peek_char () == '
 						get_char ();
 						return Token.DOUBLE_COLON;
 					}
 					return Token.COLON;
 
 				case '0'
 				case '5'
 					tokens_seen = true;
 					return is_number (c);
 
 				case '\n'
 					any_token_seen |= tokens_seen;
 					tokens_seen = false;
 					comments_seen = false;
 					continue;
 
 				case '.'
 					tokens_seen = true;
 					d = peek_char ();
 					if (d >= '0' && d <= '9')
 						return is_number (c);
 
 					LocatedToken.CreateOptional (ref_line, col, ref val);
 					return Token.DOT;
 				
 				case '#'
 					if (tokens_seen || comments_seen) {
 						Eror_WrongPreprocessorLocation ();
 						return Token.ERROR;
 					}
 					
 					if (ParsePreprocessingDirective (true))
 						continue;
 
 					bool directive_expected = false;
 					while ((c = get_char ()) != -1) {
 						if (col == 1) {
 							directive_expected = true;
 						} else if (!directive_expected) {
 							// TODO
 //							if (c == '#') {
 //								Eror_WrongPreprocessorLocation ();
 //								return Token.ERROR;
 //							}
 							continue;
 						}
 
 						if (c == ' ' || c == '\t' || c == '\r' || c == '\n' || c == '\f' || c == '\v' )
 							continue;
 
 						if (c == '#') {
 							if (ParsePreprocessingDirective (false))
 								break;
 						}
 						directive_expected = false;
 					}
 
 					if (c != -1) {
 						tokens_seen = false;
 						continue;
 					}
 
 					return Token.EOF;
 				
 				case '"'
 					return consume_string (false);
 
 				case '\''
 					return TokenizeBackslash ();
 				
 				case '@'
 					c = get_char ();
 					if (c == '"') {
 						tokens_seen = true;
 						return consume_string (true);
 					}
 
 					if (is_identifier_start_character (c)){
 						return consume_identifier (c, true);
 					}
 
 					Report.Error (1646, Location, "Keyword, identifier, or string expected after verbatim specifier
 					return Token.ERROR;
 
 				case EvalStatementParserCharacter
 					return Token.EVAL_STATEMENT_PARSER;
 				case EvalCompilationUnitParserCharacter
 					return Token.EVAL_COMPILATION_UNIT_PARSER;
 				case EvalUsingDeclarationsParserCharacter
 					return Token.EVAL_USING_DECLARATIONS_UNIT_PARSER;
 				}
 
 				if (is_identifier_start_character (c)) {
 					tokens_seen = true;
 					return consume_identifier (c);
 				}
 
 				Report.Error (1056, Location, "Unexpected character `{0}'", ((char) c).ToString ());
 			}
 
 			if (CompleteOnEOF){
 				if (generated)
 					return Token.COMPLETE_COMPLETION;
 				
 				generated = true;
 				return Token.GENERATE_COMPLETION;
 			}
 			
 
 			return Token.EOF;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="23" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="1515" endline="1536">
<![CDATA[
 		}
 
 		internal bool IsPseudoCustomAttribute
 		{
 			get
 			{
 				Universe u = this.Module.universe;
 				return this == u.System_NonSerializedAttribute
 					|| this == u.System_SerializableAttribute
 					|| this == u.System_Runtime_InteropServices_DllImportAttribute
 					|| this == u.System_Runtime_InteropServices_FieldOffsetAttribute
 					|| this == u.System_Runtime_InteropServices_InAttribute
 					|| this == u.System_Runtime_InteropServices_MarshalAsAttribute
 					|| this == u.System_Runtime_InteropServices_OutAttribute
 					|| this == u.System_Runtime_InteropServices_StructLayoutAttribute
 					|| this == u.System_Runtime_InteropServices_OptionalAttribute
 					|| this == u.System_Runtime_InteropServices_PreserveSigAttribute
 					|| this == u.System_Runtime_InteropServices_ComImportAttribute
 					|| this == u.System_Runtime_CompilerServices_SpecialNameAttribute
 					|| this == u.System_Runtime_CompilerServices_MethodImplAttribute
 					;
 			}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\class\IKVM.Reflection\Type.cs" startline="942" endline="964">
<![CDATA[
 		}
 
 		public bool IsPrimitive
 		{
 			get
 			{
 				Universe u = this.Module.universe;
 				return this == u.System_Boolean
 					|| this == u.System_Byte
 					|| this == u.System_SByte
 					|| this == u.System_Int16
 					|| this == u.System_UInt16
 					|| this == u.System_Int32
 					|| this == u.System_UInt32
 					|| this == u.System_Int64
 					|| this == u.System_UInt64
 					|| this == u.System_IntPtr
 					|| this == u.System_UIntPtr
 					|| this == u.System_Char
 					|| this == u.System_Double
 					|| this == u.System_Single
 					;
 			}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="24" nfragments="3" Csharpe_files="1" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\expression.cs" startline="2091" endline="2165">
<![CDATA[
 		}
 
 		#endregion
 
 		/// <summary>
 		///   Returns a stringified representation of the Operator
 		/// </summary>
 		string OperName (Operator oper)
 		{
 			string s;
 			switch (oper){
 			case Operator.Multiply
 				s = "*";
 				break;
 			case Operator.Division
 				s = "/";
 				break;
 			case Operator.Modulus
 				s = "%";
 				break;
 			case Operator.Addition
 				s = "+";
 				break;
 			case Operator.Subtraction
 				s = "-";
 				break;
 			case Operator.LeftShift
 				s = "<<";
 				break;
 			case Operator.RightShift
 				s = ">>";
 				break;
 			case Operator.LessThan
 				s = "<";
 				break;
 			case Operator.GreaterThan
 				s = ">";
 				break;
 			case Operator.LessThanOrEqual
 				s = "<=";
 				break;
 			case Operator.GreaterThanOrEqual
 				s = ">=";
 				break;
 			case Operator.Equality
 				s = "==";
 				break;
 			case Operator.Inequality
 				s = "!=";
 				break;
 			case Operator.BitwiseAnd
 				s = "&";
 				break;
 			case Operator.BitwiseOr
 				s = "|";
 				break;
 			case Operator.ExclusiveOr
 				s = "^";
 				break;
 			case Operator.LogicalOr
 				s = "||";
 				break;
 			case Operator.LogicalAnd
 				s = "&&";
 				break;
 			default
 				s = oper.ToString ();
 				break;
 			}
 
 			if (IsCompound)
 				return s + "=";
 
 			return s;
 		}
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6403" endline="6516">
<![CDATA[
 
 
 string GetSymbolName (int token)
 {
 	switch (token){
 	case Token.LITERAL
 		return ((Constant)lexer.Value).GetValue ().ToString ();
 	case Token.IDENTIFIER
 		return ((Tokenizer.LocatedToken)lexer.Value).Value;
 
 	case Token.BOOL
 		return "bool";
 	case Token.BYTE
 		return "byte";
 	case Token.CHAR
 		return "char";
 	case Token.VOID
 		return "void";
 	case Token.DECIMAL
 		return "decimal";
 	case Token.DOUBLE
 		return "double";
 	case Token.FLOAT
 		return "float";
 	case Token.INT
 		return "int";
 	case Token.LONG
 		return "long";
 	case Token.SBYTE
 		return "sbyte";
 	case Token.SHORT
 		return "short";
 	case Token.STRING
 		return "string";
 	case Token.UINT
 		return "uint";
 	case Token.ULONG
 		return "ulong";
 	case Token.USHORT
 		return "ushort";
 	case Token.OBJECT
 		return "object";
 		
 	case Token.PLUS
 		return "+";
 	case Token.UMINUS
 	case Token.MINUS
 		return "-";
 	case Token.BANG
 		return "!";
 	case Token.BITWISE_AND
 		return "&";
 	case Token.BITWISE_OR
 		return "|";
 	case Token.STAR
 		return "*";
 	case Token.PERCENT
 		return "%";
 	case Token.DIV
 		return "/";
 	case Token.CARRET
 		return "^";
 	case Token.OP_INC
 		return "++";
 	case Token.OP_DEC
 		return "--";
 	case Token.OP_SHIFT_LEFT
 		return "<<";
 	case Token.OP_SHIFT_RIGHT
 		return ">>";
 	case Token.OP_LT
 		return "<";
 	case Token.OP_GT
 		return ">";
 	case Token.OP_LE
 		return "<=";
 	case Token.OP_GE
 		return ">=";
 	case Token.OP_EQ
 		return "==";
 	case Token.OP_NE
 		return "!=";
 	case Token.OP_AND
 		return "&&";
 	case Token.OP_OR
 		return "||";
 	case Token.OP_PTR
 		return "->";
 	case Token.OP_COALESCING
 		return "??";
 	case Token.OP_MULT_ASSIGN
 		return "*=";
 	case Token.OP_DIV_ASSIGN
 		return "/=";
 	case Token.OP_MOD_ASSIGN
 		return "%=";
 	case Token.OP_ADD_ASSIGN
 		return "+=";
 	case Token.OP_SUB_ASSIGN
 		return "-=";
 	case Token.OP_SHIFT_LEFT_ASSIGN
 		return "<<=";
 	case Token.OP_SHIFT_RIGHT_ASSIGN
 		return ">>=";
 	case Token.OP_AND_ASSIGN
 		return "&=";
 	case Token.OP_XOR_ASSIGN
 		return "^=";
 	case Token.OP_OR_ASSIGN
 		return "|=";
 	}
 
 	return GetTokenName (token);
 }
]]>
</clone_fragment>
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="6517" endline="6804">
<![CDATA[
 
 static string GetTokenName (int token)
 {
 	switch (token){
 	case Token.ABSTRACT
 		return "abstract";
 	case Token.AS
 		return "as";
 	case Token.ADD
 		return "add";
 	case Token.ASYNC
 		return "async";
 	case Token.BASE
 		return "base";
 	case Token.BREAK
 		return "break";
 	case Token.CASE
 		return "case";
 	case Token.CATCH
 		return "catch";
 	case Token.CHECKED
 		return "checked";
 	case Token.CLASS
 		return "class";
 	case Token.CONST
 		return "const";
 	case Token.CONTINUE
 		return "continue";
 	case Token.DEFAULT
 		return "default";
 	case Token.DELEGATE
 		return "delegate";
 	case Token.DO
 		return "do";
 	case Token.ELSE
 		return "else";
 	case Token.ENUM
 		return "enum";
 	case Token.EVENT
 		return "event";
 	case Token.EXPLICIT
 		return "explicit";
 	case Token.EXTERN
 		return "extern";
 	case Token.FALSE
 		return "false";
 	case Token.FINALLY
 		return "finally";
 	case Token.FIXED
 		return "fixed";
 	case Token.FOR
 		return "for";
 	case Token.FOREACH
 		return "foreach";
 	case Token.GOTO
 		return "goto";
 	case Token.IF
 		return "if";
 	case Token.IMPLICIT
 		return "implicit";
 	case Token.IN
 		return "in";
 	case Token.INTERFACE
 		return "interface";
 	case Token.INTERNAL
 		return "internal";
 	case Token.IS
 		return "is";
 	case Token.LOCK
 		return "lock";
 	case Token.NAMESPACE
 		return "namespace";
 	case Token.NEW
 		return "new";
 	case Token.NULL
 		return "null";
 	case Token.OPERATOR
 		return "operator";
 	case Token.OUT
 		return "out";
 	case Token.OVERRIDE
 		return "override";
 	case Token.PARAMS
 		return "params";
 	case Token.PRIVATE
 		return "private";
 	case Token.PROTECTED
 		return "protected";
 	case Token.PUBLIC
 		return "public";
 	case Token.READONLY
 		return "readonly";
 	case Token.REF
 		return "ref";
 	case Token.RETURN
 		return "return";
 	case Token.REMOVE
 		return "remove";
 	case Token.SEALED
 		return "sealed";
 	case Token.SIZEOF
 		return "sizeof";
 	case Token.STACKALLOC
 		return "stackalloc";
 	case Token.STATIC
 		return "static";
 	case Token.STRUCT
 		return "struct";
 	case Token.SWITCH
 		return "switch";
 	case Token.THIS
 		return "this";
 	case Token.THROW
 		return "throw";
 	case Token.TRUE
 		return "true";
 	case Token.TRY
 		return "try";
 	case Token.TYPEOF
 		return "typeof";
 	case Token.UNCHECKED
 		return "unchecked";
 	case Token.UNSAFE
 		return "unsafe";
 	case Token.USING
 		return "using";
 	case Token.VIRTUAL
 		return "virtual";
 	case Token.VOLATILE
 		return "volatile";
 	case Token.WHERE
 		return "where";
 	case Token.WHILE
 		return "while";
 	case Token.ARGLIST
 		return "__arglist";
 	case Token.PARTIAL
 		return "partial";
 	case Token.ARROW
 		return "=>";
 	case Token.FROM
 	case Token.FROM_FIRST
 		return "from";
 	case Token.JOIN
 		return "join";
 	case Token.ON
 		return "on";
 	case Token.EQUALS
 		return "equals";
 	case Token.SELECT
 		return "select";
 	case Token.GROUP
 		return "group";
 	case Token.BY
 		return "by";
 	case Token.LET
 		return "let";
 	case Token.ORDERBY
 		return "orderby";
 	case Token.ASCENDING
 		return "ascending";
 	case Token.DESCENDING
 		return "descending";
 	case Token.INTO
 		return "into";
 	case Token.GET
 		return "get";
 	case Token.SET
 		return "set";
 	case Token.OPEN_BRACE
 		return "{";
 	case Token.CLOSE_BRACE
 		return "}";
 	case Token.OPEN_BRACKET
 	case Token.OPEN_BRACKET_EXPR
 		return "[";
 	case Token.CLOSE_BRACKET
 		return "]";
 	case Token.OPEN_PARENS_CAST
 	case Token.OPEN_PARENS_LAMBDA
 	case Token.OPEN_PARENS
 		return "(";
 	case Token.CLOSE_PARENS
 		return ")";
 	case Token.DOT
 		return ".";
 	case Token.COMMA
 		return ",";
 	case Token.DEFAULT_COLON
 		return "default
 	case Token.COLON
 		return "
 	case Token.SEMICOLON
 		return ";";
 	case Token.TILDE
 		return "~";
 		
 	case Token.PLUS
 	case Token.UMINUS
 	case Token.MINUS
 	case Token.BANG
 	case Token.OP_LT
 	case Token.OP_GT
 	case Token.BITWISE_AND
 	case Token.BITWISE_OR
 	case Token.STAR
 	case Token.PERCENT
 	case Token.DIV
 	case Token.CARRET
 	case Token.OP_INC
 	case Token.OP_DEC
 	case Token.OP_SHIFT_LEFT
 	case Token.OP_SHIFT_RIGHT
 	case Token.OP_LE
 	case Token.OP_GE
 	case Token.OP_EQ
 	case Token.OP_NE
 	case Token.OP_AND
 	case Token.OP_OR
 	case Token.OP_PTR
 	case Token.OP_COALESCING
 	case Token.OP_MULT_ASSIGN
 	case Token.OP_DIV_ASSIGN
 	case Token.OP_MOD_ASSIGN
 	case Token.OP_ADD_ASSIGN
 	case Token.OP_SUB_ASSIGN
 	case Token.OP_SHIFT_LEFT_ASSIGN
 	case Token.OP_SHIFT_RIGHT_ASSIGN
 	case Token.OP_AND_ASSIGN
 	case Token.OP_XOR_ASSIGN
 	case Token.OP_OR_ASSIGN
 		return "<operator>";
 
 	case Token.BOOL
 	case Token.BYTE
 	case Token.CHAR
 	case Token.VOID
 	case Token.DECIMAL
 	case Token.DOUBLE
 	case Token.FLOAT
 	case Token.INT
 	case Token.LONG
 	case Token.SBYTE
 	case Token.SHORT
 	case Token.STRING
 	case Token.UINT
 	case Token.ULONG
 	case Token.USHORT
 	case Token.OBJECT
 		return "type";
 	
 	case Token.ASSIGN
 		return "=";
 	case Token.OP_GENERICS_LT
 	case Token.GENERIC_DIMENSION
 		return "<";
 	case Token.OP_GENERICS_GT
 		return ">";
 	case Token.INTERR
 	case Token.INTERR_NULLABLE
 		return "?";
 	case Token.DOUBLE_COLON
 		return "
 	case Token.LITERAL
 		return "value";
 	case Token.IDENTIFIER
 		return "identifier";
 
 	case Token.EOF
 		return "end-of-file";
 
 		// All of these are internal.
 	case Token.NONE
 	case Token.ERROR
 	case Token.FIRST_KEYWORD
 	case Token.EVAL_COMPILATION_UNIT_PARSER
 	case Token.EVAL_USING_DECLARATIONS_UNIT_PARSER
 	case Token.EVAL_STATEMENT_PARSER
 	case Token.LAST_KEYWORD
 	case Token.GENERATE_COMPLETION
 	case Token.COMPLETE_COMPLETION
 		return "<internal>";
 
 		// A bit more robust.
 	default
 		return yyNames [token];
         }
 }
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="25" nfragments="2" Csharpe_files="1" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="c:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.jay" startline="45" endline="6154">
<![CDATA[
 		static readonly object ModifierNone = 0;
 	
 		NamespaceEntry  current_namespace;
 		TypeContainer   current_container;
 		DeclSpace	current_class;
 		PropertyBase current_property;
 		EventProperty current_event;
 		EventField current_event_field;
 		FieldBase current_field;
 	
 		/// <summary>
 		///   Current block is used to add statements as we find
 		///   them.  
 		/// </summary>
 		Block      current_block;
 		
 		BlockVariableDeclaration current_variable;
 
 		Delegate   current_delegate;
 		
 		AnonymousMethodExpression current_anonymous_method;
 
 		/// <summary>
 		///   This is used by the unary_expression code to resolve
 		///   a name against a parameter.  
 		/// </summary>
 		
 		// FIXME
 		// on all places, especially when some parameters are autogenerated.
 		ParametersCompiled current_local_parameters;
 
 		bool parsing_anonymous_method;
 
 		///
 		/// An out-of-band stack.
 		///
 		static Stack<object> oob_stack;
 
 		///
 		/// Controls the verbosity of the errors produced by the parser
 		///
 		static public int yacc_verbose_flag;
 
 		/// 
 		/// Used by the interactive shell, flags whether EOF was reached
 		/// and an error was produced
 		///
 		public bool UnexpectedEOF;
 
 		///
 		/// The current file.
 		///
 		CompilationUnit file;
 
 		///
 		/// Temporary Xml documentation cache.
 		/// For enum types, we need one more temporary store.
 		///
 		string tmpComment;
 		string enumTypeComment;
 	       		
 		/// Current attribute target
 		string current_attr_target;
 		
 		/// assembly and module attribute definitions are enabled
 		bool global_attrs_enabled = true;
 		
 		ParameterModifierType valid_param_mod;
 		
 		bool default_parameter_used;
 
 		/// When using the interactive parser, this holds the
 		/// resulting expression
 		public object InteractiveResult;
 
 		//
 		// Keeps track of global data changes to undo on parser error
 		//
 		public Undo undo;
 		
 		Stack<Linq.QueryBlock> linq_clause_blocks;
 
 		// A counter to create new class names in interactive mode
 		static int class_count;
 		
 		ModuleContainer module;
 		
 		CompilerContext compiler;
 		
 		//
 		// Instead of allocating carrier array everytime we
 		// share the bucket for very common constructs which can never
 		// be recursive
 		//
 		static List<Parameter> parameters_bucket = new List<Parameter> (6);
   protected static  int yyFinal = 9;
  // Put this array into a separate class so it is only initialized if debugging is actually used
  // Use MarshalByRefObject to disable inlining
  class YYRules 
   public static  string [] yyRule = {
     "$accept 
     "compilation_unit 
     "compilation_unit 
     "compilation_unit 
     "compilation_unit 
     "$$1 
     "compilation_unit 
     "opt_EOF 
     "opt_EOF 
     "outer_declarations 
     "outer_declarations 
     "outer_declaration 
     "outer_declaration 
     "outer_declaration 
     "extern_alias_directives 
     "extern_alias_directives 
     "extern_alias_directive 
     "extern_alias_directive 
     "using_directives 
     "using_directives 
     "using_directive 
     "using_directive 
     "using_alias_directive 
     "using_alias_directive 
     "using_namespace_directive 
     "$$2 
     "namespace_declaration 
     "qualified_identifier 
     "qualified_identifier 
     "qualified_identifier 
     "opt_semicolon 
     "opt_semicolon 
     "opt_comma 
     "opt_comma 
     "namespace_name 
     "$$3 
     "namespace_body 
     "opt_using_directives 
     "opt_using_directives 
     "opt_extern_alias_directives 
     "opt_extern_alias_directives 
     "opt_namespace_member_declarations 
     "opt_namespace_member_declarations 
     "namespace_member_declarations 
     "namespace_member_declarations 
     "namespace_member_declaration 
     "namespace_member_declaration 
     "namespace_member_declaration 
     "type_declaration 
     "type_declaration 
     "type_declaration 
     "type_declaration 
     "type_declaration 
     "global_attributes 
     "opt_attributes 
     "opt_attributes 
     "attribute_sections 
     "attribute_sections 
     "attribute_section 
     "attribute_section 
     "attribute_target_specifier 
     "attribute_target 
     "attribute_target 
     "attribute_target 
     "attribute_target 
     "attribute_list 
     "attribute_list 
     "$$4 
     "attribute 
     "attribute_name 
     "opt_attribute_arguments 
     "opt_attribute_arguments 
     "attribute_arguments 
     "attribute_arguments 
     "attribute_arguments 
     "attribute_arguments 
     "attribute_arguments 
     "positional_or_named_argument 
     "positional_or_named_argument 
     "$$5 
     "named_attribute_argument 
     "named_argument 
     "opt_named_modifier 
     "opt_named_modifier 
     "opt_named_modifier 
     "opt_class_member_declarations 
     "opt_class_member_declarations 
     "class_member_declarations 
     "class_member_declarations 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "class_member_declaration 
     "$$6 
     "$$7 
     "$$8 
     "$$9 
     "struct_declaration 
     "struct_declaration 
     "$$10 
     "struct_body 
     "opt_struct_member_declarations 
     "opt_struct_member_declarations 
     "struct_member_declarations 
     "struct_member_declarations 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "struct_member_declaration 
     "$$11 
     "constant_declaration 
     "opt_constant_declarators 
     "opt_constant_declarators 
     "constant_declarators 
     "constant_declarators 
     "constant_declarator 
     "$$12 
     "constant_initializer 
     "constant_initializer 
     "constant_initializer_expr 
     "constant_initializer_expr 
     "$$13 
     "field_declaration 
     "$$14 
     "field_declaration 
     "field_declaration 
     "opt_field_initializer 
     "$$15 
     "opt_field_initializer 
     "opt_field_declarators 
     "opt_field_declarators 
     "field_declarators 
     "field_declarators 
     "field_declarator 
     "$$16 
     "field_declarator 
     "opt_fixed_field_declarators 
     "opt_fixed_field_declarators 
     "fixed_field_declarators 
     "fixed_field_declarators 
     "fixed_field_declarator 
     "$$17 
     "fixed_field_size 
     "fixed_field_size 
     "variable_initializer 
     "variable_initializer 
     "variable_initializer 
     "$$18 
     "method_declaration 
     "$$19 
     "$$20 
     "method_header 
     "$$21 
     "$$22 
     "method_header 
     "method_header 
     "method_body 
     "method_body 
     "opt_formal_parameter_list 
     "opt_formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "formal_parameter_list 
     "fixed_parameters 
     "fixed_parameters 
     "fixed_parameter 
     "fixed_parameter 
     "fixed_parameter 
     "$$23 
     "fixed_parameter 
     "opt_parameter_modifier 
     "opt_parameter_modifier 
     "parameter_modifiers 
     "parameter_modifiers 
     "parameter_modifier 
     "parameter_modifier 
     "parameter_modifier 
     "parameter_array 
     "parameter_array 
     "parameter_array 
     "params_modifier 
     "params_modifier 
     "params_modifier 
     "arglist_modifier 
     "$$24 
     "$$25 
     "$$26 
     "property_declaration 
     "$$27 
     "$$28 
     "$$29 
     "indexer_declaration 
     "accessor_declarations 
     "accessor_declarations 
     "accessor_declarations 
     "accessor_declarations 
     "accessor_declarations 
     "$$30 
     "get_accessor_declaration 
     "$$31 
     "set_accessor_declaration 
     "accessor_body 
     "accessor_body 
     "accessor_body 
     "$$32 
     "$$33 
     "$$34 
     "$$35 
     "interface_declaration 
     "interface_declaration 
     "opt_interface_member_declarations 
     "opt_interface_member_declarations 
     "interface_member_declarations 
     "interface_member_declarations 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "interface_member_declaration 
     "$$36 
     "operator_declaration 
     "operator_body 
     "operator_body 
     "operator_type 
     "operator_type 
     "$$37 
     "operator_declarator 
     "operator_declarator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "overloadable_operator 
     "$$38 
     "conversion_operator_declarator 
     "$$39 
     "conversion_operator_declarator 
     "conversion_operator_declarator 
     "conversion_operator_declarator 
     "constructor_declaration 
     "$$40 
     "$$41 
     "constructor_declarator 
     "constructor_body 
     "constructor_body 
     "opt_constructor_initializer 
     "opt_constructor_initializer 
     "$$42 
     "constructor_initializer 
     "$$43 
     "constructor_initializer 
     "constructor_initializer 
     "$$44 
     "destructor_declaration 
     "$$45 
     "event_declaration 
     "$$46 
     "$$47 
     "event_declaration 
     "opt_event_initializer 
     "$$48 
     "opt_event_initializer 
     "opt_event_declarators 
     "opt_event_declarators 
     "event_declarators 
     "event_declarators 
     "event_declarator 
     "$$49 
     "event_declarator 
     "$$50 
     "event_variable_initializer 
     "event_accessor_declarations 
     "event_accessor_declarations 
     "event_accessor_declarations 
     "event_accessor_declarations 
     "event_accessor_declarations 
     "$$51 
     "add_accessor_declaration 
     "$$52 
     "remove_accessor_declaration 
     "event_accessor_block 
     "event_accessor_block 
     "$$53 
     "$$54 
     "$$55 
     "enum_declaration 
     "opt_enum_base 
     "opt_enum_base 
     "opt_enum_base 
     "opt_enum_member_declarations 
     "opt_enum_member_declarations 
     "opt_enum_member_declarations 
     "enum_member_declarations 
     "enum_member_declarations 
     "enum_member_declaration 
     "$$56 
     "enum_member_declaration 
     "$$57 
     "$$58 
     "$$59 
     "delegate_declaration 
     "opt_nullable 
     "opt_nullable 
     "namespace_or_type_name 
     "namespace_or_type_name 
     "member_name 
     "member_name 
     "type_name 
     "opt_type_argument_list 
     "opt_type_argument_list 
     "opt_type_argument_list 
     "type_arguments 
     "type_arguments 
     "$$60 
     "type_declaration_name 
     "member_declaration_name 
     "method_declaration_name 
     "method_declaration_name 
     "indexer_declaration_name 
     "indexer_declaration_name 
     "explicit_interface 
     "explicit_interface 
     "explicit_interface 
     "opt_type_parameter_list 
     "opt_type_parameter_list 
     "type_parameters 
     "type_parameters 
     "type_parameter 
     "type_parameter 
     "type_and_void 
     "type_and_void 
     "member_type 
     "type 
     "type 
     "simple_type 
     "simple_type 
     "parameter_type 
     "parameter_type 
     "type_expression_or_array 
     "type_expression_or_array 
     "type_expression 
     "type_expression 
     "type_expression 
     "type_expression 
     "type_expression 
     "type_list 
     "type_list 
     "base_type_name 
     "base_type_name 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "builtin_types 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "integral_type 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression 
     "primary_expression_or_type 
     "primary_expression_or_type 
     "primary_expression_or_type 
     "literal 
     "literal 
     "literal 
     "boolean_literal 
     "boolean_literal 
     "open_parens_any 
     "open_parens_any 
     "close_parens 
     "close_parens 
     "parenthesized_expression 
     "parenthesized_expression 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "member_access 
     "invocation_expression 
     "opt_object_or_collection_initializer 
     "opt_object_or_collection_initializer 
     "object_or_collection_initializer 
     "object_or_collection_initializer 
     "opt_member_initializer_list 
     "opt_member_initializer_list 
     "member_initializer_list 
     "member_initializer_list 
     "member_initializer_list 
     "member_initializer 
     "member_initializer 
     "member_initializer 
     "member_initializer 
     "member_initializer 
     "initializer_value 
     "initializer_value 
     "opt_argument_list 
     "opt_argument_list 
     "argument_list 
     "argument_list 
     "argument_list 
     "argument_list 
     "argument_list 
     "argument 
     "argument 
     "argument_or_named_argument 
     "argument_or_named_argument 
     "non_simple_argument 
     "non_simple_argument 
     "non_simple_argument 
     "non_simple_argument 
     "variable_reference 
     "element_access 
     "expression_list 
     "expression_list 
     "expression_list 
     "expression_list_arguments 
     "expression_list_arguments 
     "expression_list_argument 
     "expression_list_argument 
     "this_access 
     "base_access 
     "base_access 
     "post_increment_expression 
     "post_decrement_expression 
     "object_or_delegate_creation_expression 
     "object_or_delegate_creation_expression 
     "array_creation_expression 
     "array_creation_expression 
     "array_creation_expression 
     "array_creation_expression 
     "array_creation_expression 
     "$$61 
     "new_expr_type 
     "anonymous_type_expression 
     "anonymous_type_parameters_opt_comma 
     "anonymous_type_parameters_opt_comma 
     "anonymous_type_parameters_opt 
     "anonymous_type_parameters_opt 
     "anonymous_type_parameters 
     "anonymous_type_parameters 
     "anonymous_type_parameter 
     "anonymous_type_parameter 
     "anonymous_type_parameter 
     "anonymous_type_parameter 
     "opt_rank_specifier 
     "opt_rank_specifier 
     "rank_specifiers 
     "rank_specifiers 
     "rank_specifier 
     "rank_specifier 
     "dim_separators 
     "dim_separators 
     "opt_array_initializer 
     "opt_array_initializer 
     "array_initializer 
     "array_initializer 
     "variable_initializer_list 
     "variable_initializer_list 
     "$$62 
     "typeof_expression 
     "typeof_type_expression 
     "typeof_type_expression 
     "typeof_type_expression 
     "unbound_type_name 
     "unbound_type_name 
     "unbound_type_name 
     "unbound_type_name 
     "unbound_type_name 
     "generic_dimension 
     "qualified_alias_member 
     "sizeof_expression 
     "checked_expression 
     "unchecked_expression 
     "pointer_member_access 
     "$$63 
     "anonymous_method_expression 
     "opt_anonymous_method_signature 
     "opt_anonymous_method_signature 
     "$$64 
     "anonymous_method_signature 
     "default_value_expression 
     "unary_expression 
     "unary_expression 
     "unary_expression 
     "unary_expression 
     "cast_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "prefixed_unary_expression 
     "multiplicative_expression 
     "multiplicative_expression 
     "multiplicative_expression 
     "multiplicative_expression 
     "additive_expression 
     "additive_expression 
     "additive_expression 
     "additive_expression 
     "additive_expression 
     "additive_expression 
     "shift_expression 
     "shift_expression 
     "shift_expression 
     "relational_expression 
     "relational_expression 
     "relational_expression 
     "relational_expression 
     "relational_expression 
     "equality_expression 
     "equality_expression 
     "equality_expression 
     "and_expression 
     "and_expression 
     "exclusive_or_expression 
     "exclusive_or_expression 
     "inclusive_or_expression 
     "inclusive_or_expression 
     "conditional_and_expression 
     "conditional_and_expression 
     "conditional_or_expression 
     "conditional_or_expression 
     "null_coalescing_expression 
     "null_coalescing_expression 
     "conditional_expression 
     "conditional_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "assignment_expression 
     "lambda_parameter_list 
     "lambda_parameter_list 
     "lambda_parameter 
     "lambda_parameter 
     "lambda_parameter 
     "opt_lambda_parameter_list 
     "opt_lambda_parameter_list 
     "lambda_expression_body 
     "lambda_expression_body 
     "$$65 
     "lambda_expression_body_simple 
     "expression_or_error 
     "expression_or_error 
     "$$66 
     "lambda_expression 
     "$$67 
     "$$68 
     "lambda_expression 
     "expression 
     "expression 
     "non_assignment_expression 
     "non_assignment_expression 
     "non_assignment_expression 
     "non_assignment_expression 
     "constant_expression 
     "boolean_expression 
     "$$69 
     "$$70 
     "$$71 
     "$$72 
     "class_declaration 
     "opt_partial 
     "opt_partial 
     "opt_modifiers 
     "opt_modifiers 
     "modifiers 
     "modifiers 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "modifier 
     "opt_class_base 
     "opt_class_base 
     "opt_type_parameter_constraints_clauses 
     "opt_type_parameter_constraints_clauses 
     "opt_type_parameter_constraints_clauses 
     "type_parameter_constraints_clauses 
     "type_parameter_constraints_clauses 
     "type_parameter_constraints_clause 
     "type_parameter_constraints 
     "type_parameter_constraints 
     "type_parameter_constraint 
     "type_parameter_constraint 
     "type_parameter_constraint 
     "type_parameter_constraint 
     "opt_type_parameter_variance 
     "opt_type_parameter_variance 
     "type_parameter_variance 
     "type_parameter_variance 
     "$$73 
     "block 
     "block_end 
     "block_end 
     "$$74 
     "block_prepared 
     "opt_statement_list 
     "opt_statement_list 
     "statement_list 
     "statement_list 
     "statement 
     "statement 
     "statement 
     "statement 
     "interactive_statement_list 
     "interactive_statement_list 
     "interactive_statement 
     "interactive_statement 
     "interactive_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "interactive_valid_declaration_statement 
     "embedded_statement 
     "embedded_statement 
     "embedded_statement 
     "embedded_statement 
     "empty_statement 
     "$$75 
     "labeled_statement 
     "variable_type 
     "variable_type 
     "variable_type_simple 
     "variable_type_simple 
     "variable_type_simple 
     "variable_type_simple 
     "variable_type_simple 
     "variable_type_simple 
     "pointer_stars 
     "pointer_stars 
     "pointer_star 
     "$$76 
     "block_variable_declaration 
     "$$77 
     "block_variable_declaration 
     "opt_local_variable_initializer 
     "opt_local_variable_initializer 
     "opt_local_variable_initializer 
     "opt_variable_declarators 
     "opt_variable_declarators 
     "variable_declarators 
     "variable_declarators 
     "variable_declarator 
     "variable_declarator 
     "const_variable_initializer 
     "const_variable_initializer 
     "opt_const_declarators 
     "opt_const_declarators 
     "const_declarators 
     "const_declarators 
     "const_declarator 
     "block_variable_initializer 
     "block_variable_initializer 
     "block_variable_initializer 
     "expression_statement 
     "expression_statement 
     "interactive_expression_statement 
     "interactive_expression_statement 
     "statement_expression 
     "interactive_statement_expression 
     "interactive_statement_expression 
     "selection_statement 
     "selection_statement 
     "if_statement 
     "if_statement 
     "$$78 
     "switch_statement 
     "opt_switch_sections 
     "opt_switch_sections 
     "switch_sections 
     "switch_sections 
     "switch_sections 
     "$$79 
     "switch_section 
     "switch_labels 
     "switch_labels 
     "switch_label 
     "switch_label 
     "iteration_statement 
     "iteration_statement 
     "iteration_statement 
     "iteration_statement 
     "while_statement 
     "do_statement 
     "$$80 
     "for_statement 
     "for_statement_cont 
     "for_statement_cont 
     "opt_for_initializer 
     "opt_for_initializer 
     "$$81 
     "for_initializer 
     "for_initializer 
     "opt_for_condition 
     "opt_for_condition 
     "opt_for_iterator 
     "opt_for_iterator 
     "for_iterator 
     "statement_expression_list 
     "statement_expression_list 
     "foreach_statement 
     "$$82 
     "foreach_statement 
     "jump_statement 
     "jump_statement 
     "jump_statement 
     "jump_statement 
     "jump_statement 
     "jump_statement 
     "break_statement 
     "continue_statement 
     "goto_statement 
     "goto_statement 
     "goto_statement 
     "return_statement 
     "throw_statement 
     "yield_statement 
     "yield_statement 
     "opt_expression 
     "opt_expression 
     "try_statement 
     "try_statement 
     "try_statement 
     "try_statement 
     "catch_clauses 
     "catch_clauses 
     "opt_identifier 
     "opt_identifier 
     "catch_clause 
     "$$83 
     "catch_clause 
     "catch_clause 
     "checked_statement 
     "unchecked_statement 
     "$$84 
     "unsafe_statement 
     "lock_statement 
     "$$85 
     "$$86 
     "fixed_statement 
     "$$87 
     "$$88 
     "using_statement 
     "using_statement 
     "using_or_fixed_variable_initializer 
     "using_or_fixed_variable_initializer 
     "query_expression 
     "query_expression 
     "query_expression 
     "query_expression 
     "first_from_clause 
     "first_from_clause 
     "nested_from_clause 
     "nested_from_clause 
     "$$89 
     "from_clause 
     "$$90 
     "from_clause 
     "query_body 
     "query_body 
     "query_body 
     "$$91 
     "select_or_group_clause 
     "$$92 
     "$$93 
     "select_or_group_clause 
     "opt_query_body_clauses 
     "opt_query_body_clauses 
     "query_body_clauses 
     "query_body_clauses 
     "query_body_clause 
     "query_body_clause 
     "query_body_clause 
     "query_body_clause 
     "query_body_clause 
     "$$94 
     "let_clause 
     "$$95 
     "where_clause 
     "$$96 
     "$$97 
     "$$98 
     "join_clause 
     "$$99 
     "$$100 
     "$$101 
     "join_clause 
     "opt_join_into 
     "opt_join_into 
     "$$102 
     "orderby_clause 
     "orderings 
     "$$103 
     "orderings 
     "orderings_then_by 
     "$$104 
     "orderings_then_by 
     "order_by 
     "order_by 
     "order_by 
     "then_by 
     "then_by 
     "then_by 
     "opt_query_continuation 
     "$$105 
     "opt_query_continuation 
     "interactive_parsing 
     "interactive_parsing 
     "$$106 
     "interactive_parsing 
     "$$107 
     "interactive_parsing 
     "interactive_compilation_unit 
     "interactive_compilation_unit 
     "interactive_compilation_unit 
     "interactive_compilation_unit 
     "opt_COMPLETE_COMPLETION 
     "opt_COMPLETE_COMPLETION 
     "close_brace_or_complete_completion 
     "close_brace_or_complete_completion 
   };
  public static string getRule (int index) {
     return yyRule [index];
  }
 }
   protected static  string [] yyNames = {    
     "end-of-file",null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,null,null,null,null,null,null,null,
     null,null,null,null,null,null,null,"EOF","NONE","ERROR",
     "FIRST_KEYWORD","ABSTRACT","AS","ADD","BASE","BOOL","BREAK","BYTE",
     "CASE","CATCH","CHAR","CHECKED","CLASS","CONST","CONTINUE","DECIMAL",
     "DEFAULT","DELEGATE","DO","DOUBLE","ELSE","ENUM","EVENT","EXPLICIT",
     "EXTERN","FALSE","FINALLY","FIXED","FLOAT","FOR","FOREACH","GOTO",
     "IF","IMPLICIT","IN","INT","INTERFACE","INTERNAL","IS","LOCK","LONG",
     "NAMESPACE","NEW","NULL","OBJECT","OPERATOR","OUT","OVERRIDE",
     "PARAMS","PRIVATE","PROTECTED","PUBLIC","READONLY","REF","RETURN",
     "REMOVE","SBYTE","SEALED","SHORT","SIZEOF","STACKALLOC","STATIC",
     "STRING","STRUCT","SWITCH","THIS","THROW","TRUE","TRY","TYPEOF",
     "UINT","ULONG","UNCHECKED","UNSAFE","USHORT","USING","VIRTUAL","VOID",
     "VOLATILE","WHERE","WHILE","ARGLIST","PARTIAL","ARROW","FROM",
     "FROM_FIRST","JOIN","ON","EQUALS","SELECT","GROUP","BY","LET",
     "ORDERBY","ASCENDING","DESCENDING","INTO","INTERR_NULLABLE",
     "EXTERN_ALIAS","ASYNC","GET","SET","LAST_KEYWORD","OPEN_BRACE",
     "CLOSE_BRACE","OPEN_BRACKET","CLOSE_BRACKET","OPEN_PARENS",
     "CLOSE_PARENS","DOT","COMMA","COLON","SEMICOLON","TILDE","PLUS",
     "MINUS","BANG","ASSIGN","OP_LT","OP_GT","BITWISE_AND","BITWISE_OR",
     "STAR","PERCENT","DIV","CARRET","INTERR","DOUBLE_COLON","OP_INC",
     "OP_DEC","OP_SHIFT_LEFT","OP_SHIFT_RIGHT","OP_LE","OP_GE","OP_EQ",
     "OP_NE","OP_AND","OP_OR","OP_MULT_ASSIGN","OP_DIV_ASSIGN",
     "OP_MOD_ASSIGN","OP_ADD_ASSIGN","OP_SUB_ASSIGN",
     "OP_SHIFT_LEFT_ASSIGN","OP_SHIFT_RIGHT_ASSIGN","OP_AND_ASSIGN",
     "OP_XOR_ASSIGN","OP_OR_ASSIGN","OP_PTR","OP_COALESCING",
     "OP_GENERICS_LT","OP_GENERICS_LT_DECL","OP_GENERICS_GT","LITERAL",
     "IDENTIFIER","OPEN_PARENS_LAMBDA","OPEN_PARENS_CAST",
     "GENERIC_DIMENSION","DEFAULT_COLON","OPEN_BRACKET_EXPR",
     "EVAL_STATEMENT_PARSER","EVAL_COMPILATION_UNIT_PARSER",
     "EVAL_USING_DECLARATIONS_UNIT_PARSER","GENERATE_COMPLETION",
     "COMPLETE_COMPLETION","UMINUS",
   };
 
   /** index-checked interface to yyNames[].
       @param token single character or %token value.
       @return token name or [illegal] or [unknown].
     */
   public static string yyname (int token) {
     if ((token < 0) || (token > yyNames.Length)) return "[illegal]";
     string name;
     if ((name = yyNames[token]) != null) return name;
     return "[unknown]";
   }
 
   int yyExpectingState;
   /** computes list of expected tokens on error by tracing the tables.
       @param state for which to compute the list.
       @return list of token names.
     */
   protected int [] yyExpectingTokens (int state){
     int token, n, len = 0;
     bool[] ok = new bool[yyNames.Length];
     if ((n = yySindex[state]) != 0)
       for (token = n < 0 ? -n 
            (token < yyNames.Length) && (n+token < yyTable.Length); ++ token)
         if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
           ++ len;
           ok[token] = true;
         }
     if ((n = yyRindex[state]) != 0)
       for (token = n < 0 ? -n 
            (token < yyNames.Length) && (n+token < yyTable.Length); ++ token)
         if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
           ++ len;
           ok[token] = true;
         }
     int [] result = new int [len];
     for (n = token = 0; n < len;  ++ token)
       if (ok[token]) result[n++] = token;
     return result;
   }
   protected string[] yyExpecting (int state) {
     int [] tokens = yyExpectingTokens (state);
     string [] result = new string[tokens.Length];
     for (int n = 0; n < tokens.Length;  n++)
       result[n++] = yyNames[tokens [n]];
     return result;
   }
 
   /** the generated parser, with debugging messages.
       Maintains a state and a value stack, currently with fixed maximum size.
       @param yyLex scanner.
       @param yydebug debug message writer implementing yyDebug, or null.
       @return result of the last reduction, if any.
       @throws yyException on irrecoverable parse error.
     */
   internal Object yyparse (yyParser.yyInput yyLex, Object yyd)
 				 {
     this.debug = (yydebug.yyDebug)yyd;
     return yyparse(yyLex);
   }
 
   /** initial size and increment of the state/value stack [default 256].
       This is not final so that it can be overwritten outside of invocations
       of yyparse().
     */
   protected int yyMax;
 
   /** executed at the beginning of a reduce action.
       Used as $$ = yyDefault($1), prior to the user-specified action, if any.
       Can be overwritten to provide deep copy, etc.
       @param first value for $1, or null.
       @return first.
     */
   protected Object yyDefault (Object first) {
     return first;
   }
 
 	static int[] global_yyStates;
 	static object[] global_yyVals;
 	protected bool use_global_stacks;
 	object[] yyVals;					// value stack
 	object yyVal;						// value stack ptr
 	int yyToken;						// current input
 	int yyTop;
 
   /** the generated parser.
       Maintains a state and a value stack, currently with fixed maximum size.
       @param yyLex scanner.
       @return result of the last reduction, if any.
       @throws yyException on irrecoverable parse error.
     */
   internal Object yyparse (yyParser.yyInput yyLex)
   {
     if (yyMax <= 0) yyMax = 256;		// initial size
     int yyState = 0;                   // state stack ptr
     int [] yyStates;               	// state stack 
     yyVal = null;
     yyToken = -1;
     int yyErrorFlag = 0;				// #tks to shift
 	if (use_global_stacks && global_yyStates != null) {
 		yyVals = global_yyVals;
 		yyStates = global_yyStates;
    } else {
 		yyVals = new object [yyMax];
 		yyStates = new int [yyMax];
 		if (use_global_stacks) {
 			global_yyVals = yyVals;
 			global_yyStates = yyStates;
 		}
 	}
 
     /*yyLoop
       if (yyTop >= yyStates.Length) {			// dynamically increase
         global
         global
       }
       yyStates[yyTop] = yyState;
       yyVals[yyTop] = yyVal;
       if (debug != null) debug.push(yyState, yyVal);
 
       /*yyDiscarded
         int yyN;
         if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
               debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
           }
           if ((yyN = yySindex[yyState]) != 0 && ((yyN += yyToken) >= 0)
               && (yyN < yyTable.Length) && (yyCheck[yyN] == yyToken)) {
             if (debug != null)
               debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
             yyState = yyTable[yyN];		// shift to yyN
             yyVal = yyLex.value();
             yyToken = -1;
             if (yyErrorFlag > 0) -- yyErrorFlag;
             goto continue_yyLoop;
           }
           if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
               && yyN < yyTable.Length && yyCheck[yyN] == yyToken)
             yyN = yyTable[yyN];			// reduce (yyN)
           else
             switch (yyErrorFlag) {
   
             case 0
               yyExpectingState = yyState;
               // yyerror(String.Format ("syntax error, got token `{0}'", yyname (yyToken)), yyExpecting(yyState));
               if (debug != null) debug.error("syntax error");
               if (yyToken == 0 /*eof*/ || yyToken == eof_token) throw new yyParser.yyUnexpectedEof ();
               goto case 1;
             case 1
               yyErrorFlag = 3;
               do {
                 if ((yyN = yySindex[yyStates[yyTop]]) != 0
                     && (yyN += Token.yyErrorCode) >= 0 && yyN < yyTable.Length
                     && yyCheck[yyN] == Token.yyErrorCode) {
                   if (debug != null)
                     debug.shift(yyStates[yyTop], yyTable[yyN], 3);
                   yyState = yyTable[yyN];
                   yyVal = yyLex.value();
                   goto continue_yyLoop;
                 }
                 if (debug != null) debug.pop(yyStates[yyTop]);
               } while (-- yyTop >= 0);
               if (debug != null) debug.reject();
               throw new yyParser.yyException("irrecoverable syntax error");
   
             case 3
               if (yyToken == 0) {
                 if (debug != null) debug.reject();
                 throw new yyParser.yyException("irrecoverable syntax error at end-of-file");
               }
               if (debug != null)
                 debug.discard(yyState, yyToken, yyname(yyToken),
   							yyLex.value());
               yyToken = -1;
               goto continue_yyDiscarded;		// leave stack alone
             }
         }
         int yyV = yyTop + 1-yyLen[yyN];
         if (debug != null)
           debug.reduce(yyState, yyStates[yyV-1], yyN, YYRules.getRule (yyN), yyLen[yyN]);
         yyVal = yyV > yyTop ? null 
         switch (yyN) {
 case 5
 #line 375 "cs-parser.jay"
   { Lexer.CompleteOnEOF = false; }
   break;
 case 7
 #line 380 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 8
 #line 384 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 16
 #line 407 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "alias"){
 			syntax_error (lt.Location, "`alias' expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (lt.Location, "external alias");
 		} else {
 			lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop]; 
 			current_namespace.AddUsingExternalAlias (lt.Value, lt.Location, Report);
 		}
 	  }
   break;
 case 17
 #line 420 "cs-parser.jay"
   {
 	  	syntax_error (GetLocation (yyVals[-1+yyTop]), "`alias' expected");   /* TODO
 	  }
   break;
 case 20
 #line 432 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 21
 #line 437 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 22
 #line 445 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		current_namespace.AddUsingAlias (lt.Value, (MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 23
 #line 450 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 24
 #line 458 "cs-parser.jay"
   {
 		current_namespace.AddUsing ((MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 25
 #line 470 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (yyVals[-2+yyTop] != null) {
 			Report.Error(1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
 		}
 
 		current_namespace = new NamespaceEntry (module,
 			current_namespace, file, name.GetName ());
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 26
 #line 483 "cs-parser.jay"
   { 
 		current_namespace = current_namespace.Parent;
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 27
 #line 492 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName (lt.Value, lt.Location);
 	  }
   break;
 case 28
 #line 497 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 29
 #line 502 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new MemberName ("<invalid>", lexer.Location);
 	  }
   break;
 case 34
 #line 520 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (name.TypeArguments != null)
 			syntax_error (lexer.Location, "namespace name expected");
 
 		yyVal = name;
 	  }
   break;
 case 35
 #line 532 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 45
 #line 564 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			DeclSpace ds = (DeclSpace)yyVals[0+yyTop];
 
 			if ((ds.ModFlags & (Modifiers.PRIVATE|Modifiers.PROTECTED)) != 0){
 				Report.Error (1527, ds.Location, 
 				"Namespace elements cannot be explicitly declared as private, protected or protected internal");
 			}
 		}
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 46
 #line 576 "cs-parser.jay"
   {
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 47
 #line 580 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	 }
   break;
 case 53
 #line 606 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			Attributes attrs = (Attributes)yyVals[0+yyTop];
 			if (global_attrs_enabled) {
 				module.AddAttributes (attrs.Attrs, current_namespace);
 			} else {
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 			}
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 54
 #line 623 "cs-parser.jay"
   {
 		global_attrs_enabled = false;
 		yyVal = null;
       }
   break;
 case 55
 #line 628 "cs-parser.jay"
   { 
 		global_attrs_enabled = false;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 56
 #line 637 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect, current_namespace);
 					yyVal = null;
 				} else {
 					yyVal = new Attributes (sect);
 				}
 				if (yyVal == null) {
 					if (RootContext.Documentation != null) {
 						Lexer.check_incorrect_doc_comment ();
 						Lexer.doc_state =
 							XmlCommentState.Allowed;
 					}
 				}
 			} else {
 				yyVal = new Attributes (sect);
 			}		
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 57
 #line 664 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			Attributes attrs = yyVals[-1+yyTop] as Attributes;
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect);
 					yyVal = null;
 				} else {
 					if (attrs == null)
 						attrs = new Attributes (sect);
 					else
 						attrs.AddAttributes (sect);			
 				}
 			} else {
 				if (attrs == null)
 					attrs = new Attributes (sect);
 				else
 					attrs.AddAttributes (sect);
 			}		
 			yyVal = attrs;
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 58
 #line 695 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
  	  }
   break;
 case 59
 #line 699 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 60
 #line 706 "cs-parser.jay"
   {
 		current_attr_target = (string)yyVals[-1+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 61
 #line 714 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = CheckAttributeTarget (lt.Value, lt.Location);
 	  }
   break;
 case 62
 #line 718 "cs-parser.jay"
   { yyVal = "event"; }
   break;
 case 63
 #line 719 "cs-parser.jay"
   { yyVal = "return"; }
   break;
 case 64
 #line 721 "cs-parser.jay"
   {
 		string name = GetTokenName (yyToken);
 		yyVal = CheckAttributeTarget (name, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 65
 #line 729 "cs-parser.jay"
   {
 		yyVal = new List<Attribute> (4) { (Attribute) yyVals[0+yyTop] };
 	  }
   break;
 case 66
 #line 733 "cs-parser.jay"
   {
 		var attrs = (List<Attribute>) yyVals[-2+yyTop];
 		attrs.Add ((Attribute) yyVals[0+yyTop]);
 
 		yyVal = attrs;
 	  }
   break;
 case 67
 #line 743 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 68
 #line 747 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		MemberName mname = (MemberName) yyVals[-2+yyTop];
 		if (mname.IsGeneric) {
 			Report.Error (404, lexer.Location,
 				      "'<' unexpected
 		}
 
 		Arguments [] arguments = (Arguments []) yyVals[0+yyTop];
 		ATypeNameExpression expr = mname.GetTypeExpression ();
 
 		if (current_attr_target == String.Empty)
 			yyVal = null;
 		else if (global_attrs_enabled && (current_attr_target == "assembly" || current_attr_target == "module"))
 			/* FIXME
 			yyVal = new GlobalAttribute (current_namespace, current_attr_target,
 						  expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 		else
 			yyVal = new Attribute (current_attr_target, expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 	  }
   break;
 case 69
 #line 770 "cs-parser.jay"
   { /* reserved attribute name or identifier
   break;
 case 70
 #line 774 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 71
 #line 776 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 72
 #line 783 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 73
 #line 785 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = new Arguments [] { a, null };
 	  }
   break;
 case 74
 #line 791 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);  
 		yyVal = new Arguments [] { null, a };
 	  }
   break;
 case 75
 #line 797 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] != null) {
 			Report.Error (1016, ((Argument) yyVals[0+yyTop]).Expr.Location, "Named attribute arguments must appear after the positional arguments");
 			o [0] = new Arguments (4);
 		}
 		
 		Arguments args = ((Arguments) o [0]);
 		if (args.Count > 0 && !(yyVals[0+yyTop] is NamedArgument) && args [args.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 		
 		args.Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 76
 #line 811 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] == null) {
 			o [1] = new Arguments (4);
 		}
 
 		((Arguments) o [1]).Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 77
 #line 823 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 79
 #line 831 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 80
 #line 835 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop]);	  
 	  }
   break;
 case 81
 #line 844 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "named argument");
 			
 		/* Avoid boxing in common case (no modifier)*/
 		var arg_mod = yyVals[-1+yyTop] == null ? Argument.AType.None 
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop], arg_mod);
 	  }
   break;
 case 82
 #line 857 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 83
 #line 859 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Ref;
 	  }
   break;
 case 84
 #line 863 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Out;
 	  }
   break;
 case 99
 #line 891 "cs-parser.jay"
   {
 		Report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
 			GetSymbolName (yyToken));
 		yyVal = null;
 		lexer.parsing_generic_declaration = false;
 	  }
   break;
 case 100
 #line 904 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 101
 #line 908 "cs-parser.jay"
   { 
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Struct (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 102
 #line 914 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null)
 			current_container.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 103
 #line 925 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 104
 #line 931 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 105
 #line 936 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	  }
   break;
 case 106
 #line 943 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 107
 #line 948 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 122
 #line 985 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var mod = (Modifiers) yyVals[-3+yyTop];
 		current_field = new Const (current_class, (FullNamedExpression) yyVals[-1+yyTop], mod, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 		current_container.AddConstant ((Const) current_field);
 		
 		if ((mod & Modifiers.STATIC) != 0) {
 			Report.Error (504, current_field.Location, "The constant `{0}' cannot be marked static", current_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_field;
 	  }
   break;
 case 123
 #line 998 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_field = null;
 	  }
   break;
 case 126
 #line 1017 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 127
 #line 1021 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 128
 #line 1028 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 129
 #line 1037 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 130
 #line 1041 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 131
 #line 1046 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 		yyVal = null;
 	  }
   break;
 case 134
 #line 1061 "cs-parser.jay"
   {
 	  	lexer.parsing_generic_declaration = false;
 
 		FullNamedExpression type = (FullNamedExpression) yyVals[-1+yyTop];
 		if (type.Type == TypeManager.void_type)
 			Report.Error (670, GetLocation (yyVals[-1+yyTop]), "Fields cannot have void type");
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new Field (current_class, type, (Modifiers) yyVals[-2+yyTop], new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-3+yyTop]);
 		current_container.AddField (current_field);
 		yyVal = current_field;
 	  }
   break;
 case 135
 #line 1076 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 			
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 		current_field = null;
 	  }
   break;
 case 136
 #line 1089 "cs-parser.jay"
   { 
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "fixed size buffers");
 
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new FixedField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop],
 			new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 			
 		current_container.AddField (current_field);
 	  }
   break;
 case 137
 #line 1100 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 	    }
 
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];	    
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 	    current_field = null;
 	  }
   break;
 case 138
 #line 1115 "cs-parser.jay"
   {
 		Report.Error (1641, GetLocation (yyVals[-1+yyTop]), "A fixed size buffer field must have the array size specifier after the field name");
 	  }
   break;
 case 140
 #line 1123 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 141
 #line 1129 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_field.Initializer = (Expression) yyVals[0+yyTop];
 		end_block (lexer.Location);
 		current_local_parameters = null;
 	  }
   break;
 case 144
 #line 1144 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 145
 #line 1148 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 146
 #line 1155 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 147
 #line 1161 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 148
 #line 1165 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 151
 #line 1180 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 152
 #line 1184 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 153
 #line 1191 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];	  
 		yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 154
 #line 1200 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 155
 #line 1204 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 156
 #line 1210 "cs-parser.jay"
   {
 		Report.Error (443, lexer.Location, "Value or constant expected");
 		yyVal = null;
 	  }
   break;
 case 159
 #line 1220 "cs-parser.jay"
   {
 		/* It has to be here for the parent to safely restore artificial block*/
 	  	Error_SyntaxError (yyToken);
 	  	yyVal = null;
 	  }
   break;
 case 160
 #line 1228 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 161
 #line 1233 "cs-parser.jay"
   {
 		Method method = (Method) yyVals[-2+yyTop];
 		method.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (method);
 		
 		if (current_container.Kind == MemberKind.Interface && method.Block != null) {
 			Report.Error (531, method.Location, "`{0}'
 		}
 
 		current_local_parameters = null;
 
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 162
 #line 1254 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 163
 #line 1258 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 164
 #line 1262 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 						     (FullNamedExpression) yyVals[-7+yyTop], current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		} else if (yyVals[0+yyTop] != null) {
 			Report.Error (80, GetLocation (yyVals[0+yyTop]),
 				"Constraints are not allowed on non-generic declarations");
 		}
 
 		Method method = new Method (current_class, generic, (FullNamedExpression) yyVals[-7+yyTop], (Modifiers) yyVals[-8+yyTop],
 				     name, current_local_parameters, (Attributes) yyVals[-9+yyTop]);
 				     
 		if (yyVals[0+yyTop] != null && ((method.ModFlags & Modifiers.OVERRIDE) != 0 || method.IsExplicitImpl)) {
 			Report.Error (460, method.Location,
 				"`{0}'
 				method.GetSignatureForError ());
 		}
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 165
 #line 1299 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 166
 #line 1303 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 167
 #line 1307 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		if (yyVals[-1+yyTop] != null && name.TypeArguments == null)
 			Report.Error (80, lexer.Location,
 				      "Constraints are not allowed on non-generic declarations");
 
 		Method method;
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 				new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		}
 
 		var modifiers = (Modifiers) yyVals[-9+yyTop];
 
 
 		const Modifiers invalid_partial_mod = Modifiers.AccessibilityMask | Modifiers.ABSTRACT | Modifiers.EXTERN |
 			Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.SEALED | Modifiers.VIRTUAL;
 
 		if ((modifiers & invalid_partial_mod) != 0) {
 			Report.Error (750, name.Location, "A partial method cannot define access modifier or " +
        			"any of abstract, extern, new, override, sealed, or virtual modifiers");
 			modifiers &= ~invalid_partial_mod;
 		}
 
 		if ((current_class.ModFlags & Modifiers.PARTIAL) == 0) {
 			Report.Error (751, name.Location, "A partial method must be declared within a " +
        			"partial class or partial struct");
 		}
 		
 		modifiers |= Modifiers.PARTIAL | Modifiers.PRIVATE;
 		
 		method = new Method (current_class, generic, new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				     modifiers, name, current_local_parameters, (Attributes) yyVals[-10+yyTop]);
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		/* TODO
 		StoreModifierLocation (Modifiers.PARTIAL, GetLocation (yyVals[-8+yyTop]));
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 168
 #line 1362 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		Report.Error (1585, name.Location, 
 			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) yyVals[-4+yyTop]));
 
 		Method method = new Method (current_class, null, (FullNamedExpression) yyVals[-5+yyTop],
 					    0, name, (ParametersCompiled) yyVals[-1+yyTop], (Attributes) yyVals[-7+yyTop]);
 
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		yyVal = method;
 	  }
   break;
 case 170
 #line 1381 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 171
 #line 1385 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 173
 #line 1391 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 	  	yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 174
 #line 1396 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = new ParametersCompiled (pars_list.ToArray ()); 
 	  }
   break;
 case 175
 #line 1403 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[0+yyTop])));
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 176
 #line 1409 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[-2+yyTop] } );			
 	  }
   break;
 case 177
 #line 1416 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 178
 #line 1426 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[-2+yyTop])) }, true);
 	  }
   break;
 case 179
 #line 1432 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 180
 #line 1441 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[0+yyTop] } );
 	  }
   break;
 case 181
 #line 1445 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[0+yyTop])) }, true);
 	  }
   break;
 case 182
 #line 1449 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 183
 #line 1457 "cs-parser.jay"
   {
 		parameters_bucket.Clear ();
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		parameters_bucket.Add (p);
 		
 		default_parameter_used = p.HasDefaultValue;
 		yyVal = parameters_bucket;
 	  }
   break;
 case 184
 #line 1466 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		if (p != null) {
 			if (p.HasExtensionMethodModifier)
 				Report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
 			else if (!p.HasDefaultValue && default_parameter_used)
 				Report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");
 
 			default_parameter_used |= p.HasDefaultValue;
 			pars.Add (p);
 			
 			lbag.AddLocation (p, GetLocation (yyVals[-1+yyTop]));
 		}
 		
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 185
 #line 1490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 186
 #line 1498 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		Report.Error (1552, lt.Location, "Array type specifier, [], must appear before parameter name");
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Parameter.Modifier) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop], lt.Location);
 	  }
   break;
 case 187
 #line 1507 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  	Location l = GetLocation (yyVals[0+yyTop]);
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], "NeedSomeGeneratorHere", (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], l);
 	  }
   break;
 case 188
 #line 1517 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 189
 #line 1521 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		if (RootContext.Version <= LanguageVersion.V_3) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "optional parameter");
 		}
 		
 		Parameter.Modifier mod = (Parameter.Modifier) yyVals[-5+yyTop];
 		if (mod != Parameter.Modifier.NONE) {
 			switch (mod) {
 			case Parameter.Modifier.REF
 			case Parameter.Modifier.OUT
 				Report.Error (1741, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 				
 			case Parameter.Modifier.This
 				Report.Error (1743, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 			default
 				throw new NotImplementedException (mod.ToString ());
 			}
 				
 			mod = Parameter.Modifier.NONE;
 		}
 		
 		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
 			Report.Error (1065, GetLocation (yyVals[-2+yyTop]), "Optional parameter is not valid in this context");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-4+yyTop], lt.Value, mod, (Attributes) yyVals[-6+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 		
 		if (yyVals[0+yyTop] != null)
 			((Parameter) yyVal).DefaultValue = new DefaultParameterValueExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 190
 #line 1560 "cs-parser.jay"
   { yyVal = Parameter.Modifier.NONE; }
   break;
 case 192
 #line 1566 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 193
 #line 1570 "cs-parser.jay"
   {
 		Parameter.Modifier p2 = (Parameter.Modifier)yyVals[0+yyTop];
   		Parameter.Modifier mod = (Parameter.Modifier)yyVals[-1+yyTop] | p2;
   		if (((Parameter.Modifier)yyVals[-1+yyTop] & p2) == p2) {
   			Error_DuplicateParameterModifier (lexer.Location, p2);
   		} else {
 	  		switch (mod & ~Parameter.Modifier.This) {
   				case Parameter.Modifier.REF
 					Report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
   					break;
    				case Parameter.Modifier.OUT
 					Report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
   					break;
   				default
  					Report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
  					break;
  			}
   		}
   		yyVal = mod;
 	  }
   break;
 case 194
 #line 1594 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
 	  		Error_ParameterModifierNotValid ("ref", GetLocation (yyVals[0+yyTop]));
 	  		
 	  	yyVal = Parameter.Modifier.REF;
 	  }
   break;
 case 195
 #line 1601 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
 	  		Error_ParameterModifierNotValid ("out", GetLocation (yyVals[0+yyTop]));
 	  
 	  	yyVal = Parameter.Modifier.OUT;
 	  }
   break;
 case 196
 #line 1608 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.This) == 0)
 	  		Error_ParameterModifierNotValid ("this", GetLocation (yyVals[0+yyTop]));
 
 	  	if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "extension methods");
 	  			
 		yyVal = Parameter.Modifier.This;
 	  }
   break;
 case 197
 #line 1621 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 198
 #line 1626 "cs-parser.jay"
   {
 		Report.Error (1751, GetLocation (yyVals[-4+yyTop]), "Cannot specify a default value for a parameter array");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Attributes) yyVals[-5+yyTop], lt.Location);		
 	  }
   break;
 case 199
 #line 1633 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 200
 #line 1641 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.Params) == 0)
 			Report.Error (1670, (GetLocation (yyVals[0+yyTop])), "The `params' modifier is not allowed in current context");
 	  }
   break;
 case 201
 #line 1646 "cs-parser.jay"
   {
 		Parameter.Modifier mod = (Parameter.Modifier)yyVals[0+yyTop];
 		if ((mod & Parameter.Modifier.This) != 0) {
 			Report.Error (1104, GetLocation (yyVals[-1+yyTop]), "The parameter modifiers `this' and `params' cannot be used altogether");
 		} else {
 			Report.Error (1611, GetLocation (yyVals[-1+yyTop]), "The params parameter cannot be declared as ref or out");
 		}	  
 	  }
   break;
 case 202
 #line 1655 "cs-parser.jay"
   {
 		Error_DuplicateParameterModifier (GetLocation (yyVals[-1+yyTop]), Parameter.Modifier.PARAMS);
 	  }
   break;
 case 203
 #line 1662 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Arglist) == 0)
 	  		Report.Error (1669, GetLocation (yyVals[0+yyTop]), "__arglist is not valid in this context");
 	  }
   break;
 case 204
 #line 1673 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			tmpComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 205
 #line 1678 "cs-parser.jay"
   {
 		current_property = new Property (current_class, (FullNamedExpression) yyVals[-3+yyTop], (Modifiers) yyVals[-4+yyTop],
 			(MemberName) yyVals[-2+yyTop], (Attributes) yyVals[-5+yyTop]);
 			
 		if (current_property.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (547, GetLocation (yyVals[-3+yyTop]), "`{0}'
 			
 		current_container.AddProperty ((Property)current_property);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[0+yyTop]));
 		
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 206
 #line 1691 "cs-parser.jay"
   {
 		lexer.PropertyParsing = false;
 		
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();				
 	  }
   break;
 case 207
 #line 1698 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_property, GetLocation (yyVals[0+yyTop]));
 		current_property = null;
 	  }
   break;
 case 208
 #line 1708 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 209
 #line 1712 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  
 		Indexer indexer = new Indexer (current_class, (FullNamedExpression) yyVals[-6+yyTop],
 			(MemberName)yyVals[-5+yyTop], (Modifiers) yyVals[-7+yyTop], (ParametersCompiled) yyVals[-2+yyTop], (Attributes) yyVals[-8+yyTop]);
 			
 		current_property = indexer;
 
   		current_container.AddIndexer (indexer);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
   		
 		if (indexer.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (620, GetLocation (yyVals[-6+yyTop]), "`{0}'
 
 		if (indexer.Parameters.IsEmpty) {
 			Report.Error (1551, GetLocation (yyVals[-4+yyTop]), "Indexers must have at least one parameter");
 		}
 
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 210
 #line 1738 "cs-parser.jay"
   {
 		  lexer.PropertyParsing = false;
 	  }
   break;
 case 211
 #line 1742 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();
 			
 		lbag.AppendToMember (current_property, GetLocation (yyVals[-1+yyTop]));
 		current_property = null;		
 	  }
   break;
 case 216
 #line 1758 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_BRACE) {
 	  		Report.Error (548, lexer.Location, "`{0}'
 		} else {
 			if (yyToken == Token.SEMICOLON)
 				Report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
 			else
 				Report.Error (1014, GetLocation (yyVals[0+yyTop]), "A get or set accessor expected");
 		}
 	  }
   break;
 case 217
 #line 1772 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 	  
 		if (current_property.Get != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 		
 		if (current_property is Indexer) {
 			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop], ((Indexer)current_property).ParameterInfo.Clone (),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Get = new Property.GetMethod (current_property,
 				(Modifiers) yyVals[-1+yyTop], (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}	
 	  
 		current_local_parameters = current_property.Get.ParameterInfo;	  
 		lbag.AddMember (current_property.Get, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 218
 #line 1794 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] != null) {
 	  		current_property.Get.Block = (ToplevelBlock) yyVals[0+yyTop];			
 	  	
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Get.Block.StartLocation,
 					"`{0}'
 			}		
 		}
 	  
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null)
 			if (Lexer.doc_state == XmlCommentState.Error)
 				Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 219
 #line 1815 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 		
 		if (current_property.Set != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 	  
 		if (current_property is Indexer) {
 			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop],
 				ParametersCompiled.MergeGenerated (compiler,
 				((Indexer)current_property).ParameterInfo, true, new Parameter (
 					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation (yyVals[0+yyTop])),
 					null),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Set = new Property.SetMethod (current_property, (Modifiers) yyVals[-1+yyTop], 
 				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation (yyVals[0+yyTop])),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}
 		
 		current_local_parameters = current_property.Set.ParameterInfo;	
 		lbag.AddMember (current_property.Set, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 220
 #line 1842 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {		
 			current_property.Set.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Set.Block.StartLocation,
 					"`{0}'
 			}
 		}
 		
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null
 			&& Lexer.doc_state == XmlCommentState.Error)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 222
 #line 1864 "cs-parser.jay"
   {
 		/* TODO
 	  	yyVal = null;
 	  }
   break;
 case 223
 #line 1869 "cs-parser.jay"
   {
 	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
 	  	yyVal = null;
 	  }
   break;
 case 224
 #line 1880 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 225
 #line 1884 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Interface (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 226
 #line 1891 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 227
 #line 1902 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 228
 #line 1908 "cs-parser.jay"
   {
 	    lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 229
 #line 1913 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  }
   break;
 case 234
 #line 1930 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 235
 #line 1934 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 240
 #line 1942 "cs-parser.jay"
   {
 	  	Report.Error (567, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain operators");
 	  }
   break;
 case 241
 #line 1946 "cs-parser.jay"
   {
 	  	Report.Error (526, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain contructors");
 	  }
   break;
 case 242
 #line 1950 "cs-parser.jay"
   {
 	  	Report.Error (524, GetLocation (yyVals[0+yyTop]), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
 	  }
   break;
 case 243
 #line 1957 "cs-parser.jay"
   {
 	  }
   break;
 case 244
 #line 1960 "cs-parser.jay"
   {
 		OperatorDeclaration decl = (OperatorDeclaration) yyVals[-2+yyTop];
 		if (decl != null) {
 			Operator op = new Operator (
 				current_class, decl.optype, decl.ret_type, (Modifiers) yyVals[-3+yyTop], 
 				current_local_parameters,
 				(ToplevelBlock) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop], decl.location);
 
 			if (RootContext.Documentation != null) {
 				op.DocComment = tmpComment;
 				Lexer.doc_state = XmlCommentState.Allowed;
 			}
 
 			/* Note again, checking is done in semantic analysis*/
 			current_container.AddOperator (op);
 
 			lbag.AddMember (op, mod_locations, lbag.GetLocations (decl));
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 246
 #line 1985 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 248
 #line 1991 "cs-parser.jay"
   {
 		Report.Error (590, GetLocation (yyVals[0+yyTop]), "User-defined operators cannot return void");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 249
 #line 1999 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 250
 #line 2003 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		Operator.OpType op = (Operator.OpType) yyVals[-4+yyTop];
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];
 		
 		int p_count = current_local_parameters.Count;
 		if (p_count == 1) {
 			if (op == Operator.OpType.Addition)
 				op = Operator.OpType.UnaryPlus;
 			else if (op == Operator.OpType.Subtraction)
 				op = Operator.OpType.UnaryNegation;
 		}
 		
 		if (IsUnaryOperator (op)) {
 			if (p_count == 2) {
 				Report.Error (1020, loc, "Overloadable binary operator expected");
 			} else if (p_count != 1) {
 				Report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
 					Operator.GetName (op));
 			}
 		} else {
 			if (p_count > 2) {
 				Report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
 					Operator.GetName (op));
 			} else if (p_count != 2) {
 				Report.Error (1019, loc, "Overloadable unary operator expected");
 			}
 		}
 		
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (op, (FullNamedExpression) yyVals[-6+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 252
 #line 2047 "cs-parser.jay"
   { yyVal = Operator.OpType.LogicalNot; }
   break;
 case 253
 #line 2048 "cs-parser.jay"
   { yyVal = Operator.OpType.OnesComplement; }
   break;
 case 254
 #line 2049 "cs-parser.jay"
   { yyVal = Operator.OpType.Increment; }
   break;
 case 255
 #line 2050 "cs-parser.jay"
   { yyVal = Operator.OpType.Decrement; }
   break;
 case 256
 #line 2051 "cs-parser.jay"
   { yyVal = Operator.OpType.True; }
   break;
 case 257
 #line 2052 "cs-parser.jay"
   { yyVal = Operator.OpType.False; }
   break;
 case 258
 #line 2054 "cs-parser.jay"
   { yyVal = Operator.OpType.Addition; }
   break;
 case 259
 #line 2055 "cs-parser.jay"
   { yyVal = Operator.OpType.Subtraction; }
   break;
 case 260
 #line 2057 "cs-parser.jay"
   { yyVal = Operator.OpType.Multiply; }
   break;
 case 261
 #line 2058 "cs-parser.jay"
   {  yyVal = Operator.OpType.Division; }
   break;
 case 262
 #line 2059 "cs-parser.jay"
   { yyVal = Operator.OpType.Modulus; }
   break;
 case 263
 #line 2060 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseAnd; }
   break;
 case 264
 #line 2061 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseOr; }
   break;
 case 265
 #line 2062 "cs-parser.jay"
   { yyVal = Operator.OpType.ExclusiveOr; }
   break;
 case 266
 #line 2063 "cs-parser.jay"
   { yyVal = Operator.OpType.LeftShift; }
   break;
 case 267
 #line 2064 "cs-parser.jay"
   { yyVal = Operator.OpType.RightShift; }
   break;
 case 268
 #line 2065 "cs-parser.jay"
   { yyVal = Operator.OpType.Equality; }
   break;
 case 269
 #line 2066 "cs-parser.jay"
   { yyVal = Operator.OpType.Inequality; }
   break;
 case 270
 #line 2067 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThan; }
   break;
 case 271
 #line 2068 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThan; }
   break;
 case 272
 #line 2069 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThanOrEqual; }
   break;
 case 273
 #line 2070 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThanOrEqual; }
   break;
 case 274
 #line 2075 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 275
 #line 2079 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 276
 #line 2094 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 277
 #line 2098 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 278
 #line 2113 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 279
 #line 2119 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	yyVal = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 280
 #line 2129 "cs-parser.jay"
   { 
 		Constructor c = (Constructor) yyVals[-1+yyTop];
 		c.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (RootContext.Documentation != null)
 			c.DocComment = ConsumeStoredComment ();
 
 		current_container.AddConstructor (c);
 
 		current_local_parameters = null;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 281
 #line 2148 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 282
 #line 2157 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];  
 		
 		/**/
 		/* start block here, so possible anonymous methods inside*/
 		/* constructor initializer can get correct parent block*/
 		/**/
 	  	start_block (lexer.Location);
 	  }
   break;
 case 283
 #line 2168 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-6+yyTop];
 		var mods = (Modifiers) yyVals[-7+yyTop];
 		ConstructorInitializer ci = (ConstructorInitializer) yyVals[0+yyTop];
 
 		Constructor c = new Constructor (current_class, lt.Value, mods,
 			(Attributes) yyVals[-8+yyTop], current_local_parameters, ci, lt.Location);
 		
 		if (lt.Value != current_container.MemberName.Name) {
 			Report.Error (1520, c.Location, "Class, struct, or interface method must have a return type");
 		} else if ((mods & Modifiers.STATIC) != 0) {
 			if ((mods & Modifiers.AccessibilityMask) != 0){
 				Report.Error (515, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			}
 			if (ci != null) {
 				Report.Error (514, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			
 			}
 		}
 		
 		lbag.AddMember (c, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 285
 #line 2199 "cs-parser.jay"
   { current_block = null; yyVal = null; }
   break;
 case 288
 #line 2209 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 289
 #line 2213 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorBaseInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 290
 #line 2219 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 291
 #line 2223 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorThisInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 292
 #line 2229 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 293
 #line 2237 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 		
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 294
 #line 2246 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		if (lt.Value != current_container.MemberName.Name){
 			Report.Error (574, lt.Location, "Name of destructor must match name of class");
 		} else if (current_container.Kind != MemberKind.Class){
 			Report.Error (575, lt.Location, "Only class types can contain destructor");
 		}
 		
 		Destructor d = new Destructor (current_class, (Modifiers) yyVals[-6+yyTop],
 			ParametersCompiled.EmptyReadOnlyParameters, (Attributes) yyVals[-7+yyTop], lt.Location);
 		if (RootContext.Documentation != null)
 			d.DocComment = ConsumeStoredComment ();
 		  
 		d.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (d);
 		lbag.AddMember (d, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		current_local_parameters = null;
 	  }
   break;
 case 295
 #line 2271 "cs-parser.jay"
   {
 		current_event_field = new EventField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop], (MemberName) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop]);
 		current_container.AddEvent (current_event_field);
 		
 		if (current_event_field.MemberName.Left != null) {
 			Report.Error (71, current_event_field.Location, "`{0}'
 			current_event_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_event_field;
 	  }
   break;
 case 296
 #line 2285 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AddMember (current_event_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_event_field = null;
 	  }
   break;
 case 297
 #line 2298 "cs-parser.jay"
   {
 		current_event = new EventProperty (current_class, (FullNamedExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-4+yyTop], (MemberName) yyVals[-1+yyTop], (Attributes) yyVals[-5+yyTop]);
 		current_container.AddEvent (current_event);
 		lbag.AddMember (current_event, mod_locations, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		
 		lexer.EventParsing = true;
 	  }
   break;
 case 298
 #line 2306 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface)
 			Report.Error (69, GetLocation (yyVals[-2+yyTop]), "Event in interface cannot have add or remove accessors");
 	  
 		lexer.EventParsing = false;
 	  }
   break;
 case 299
 #line 2313 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AppendToMember (current_event, GetLocation (yyVals[-1+yyTop]));
 	  	current_event = null;	
 		current_local_parameters = null;
 	  }
   break;
 case 301
 #line 2328 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 302
 #line 2332 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_event_field.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 305
 #line 2345 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 306
 #line 2349 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 307
 #line 2356 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 308
 #line 2362 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 309
 #line 2366 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 310
 #line 2375 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (68, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 		}
 		
 	  	if ((current_event_field.ModFlags & Modifiers.ABSTRACT) != 0) {
 			Report.Error (74, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 	  	}		
 	  }
   break;
 case 311
 #line 2387 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 314
 #line 2396 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 315
 #line 2401 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 316
 #line 2406 "cs-parser.jay"
   { 
 		Report.Error (1055, GetLocation (yyVals[0+yyTop]), "An add or remove accessor expected");
 		yyVal = null;
 	  }
   break;
 case 317
 #line 2414 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Add = new EventProperty.AddDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Add.ParameterInfo;
 		
 		lbag.AddMember (current_event.Add, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 318
 #line 2426 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Add.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Add.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 319
 #line 2442 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Remove = new EventProperty.RemoveDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Remove.ParameterInfo;
 
 		lbag.AddMember (current_event.Remove, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 320
 #line 2454 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Remove.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Remove.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 321
 #line 2470 "cs-parser.jay"
   {
 		Report.Error (73, lexer.Location, "An add or remove accessor must have a body");
 		yyVal = null;
 	  }
   break;
 case 323
 #line 2482 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			enumTypeComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 324
 #line 2487 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		if (name.IsGeneric) {
 			Report.Error (1675, name.Location, "Enums cannot have type parameters");
 		}
 		
 		push_current_class (new Enum (current_namespace, current_class, (TypeExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-5+yyTop], MakeName (name), (Attributes) yyVals[-6+yyTop]), null);
 	  }
   break;
 case 325
 #line 2499 "cs-parser.jay"
   {
 	  	/* here will be evaluated after CLOSE_BLACE is consumed.*/
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 326
 #line 2505 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			current_class.DocComment = enumTypeComment;
 			
 		--lexer.parsing_declaration;
 
 /*			if (RootContext.Documentation != null)*/
 /*				em.DocComment = ev.DocComment;*/
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-9+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 328
 #line 2522 "cs-parser.jay"
   {
 	 	var te = yyVals[0+yyTop] as TypeExpression;
 		if (te == null ||
 			(te.Type != TypeManager.int32_type && te.Type != TypeManager.uint32_type &&
 			te.Type != TypeManager.int64_type && te.Type != TypeManager.uint64_type &&
 			te.Type != TypeManager.short_type && te.Type != TypeManager.ushort_type &&
 			te.Type != TypeManager.byte_type && te.Type != TypeManager.sbyte_type)) {
 			Enum.Error_1008 (GetLocation (yyVals[0+yyTop]), Report);
 			yyVal = null;
 		} else {
 			yyVal = yyVals[0+yyTop];
 		}
 	 }
   break;
 case 329
 #line 2536 "cs-parser.jay"
   {
 	 	Error_TypeExpected (GetLocation (yyVals[-1+yyTop]));
 		yyVal = null;
 	 }
   break;
 case 332
 #line 2546 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 334
 #line 2554 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 335
 #line 2562 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-1+yyTop]);
 	  	((Enum) current_class).AddEnumMember (em);
 
 		if (RootContext.Documentation != null) {
 			em.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		yyVal = em;
 	  }
   break;
 case 336
 #line 2575 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 	  }
   break;
 case 337
 #line 2583 "cs-parser.jay"
   { 
 		--lexer.parsing_block;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 	  	em.Initializer = new ConstInitializer (em, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	((Enum) current_class).AddEnumMember (em);
 		
 		if (RootContext.Documentation != null)
 			em.DocComment = ConsumeStoredComment ();
 
 		yyVal = em;
 	  }
   break;
 case 338
 #line 2604 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out | ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 339
 #line 2608 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		MemberName name = MakeName ((MemberName) yyVals[-4+yyTop]);
 		ParametersCompiled p = (ParametersCompiled) yyVals[-1+yyTop];
 
 		Delegate del = new Delegate (current_namespace, current_class, (FullNamedExpression) yyVals[-5+yyTop],
 					     (Modifiers) yyVals[-7+yyTop], name, p, (Attributes) yyVals[-8+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			del.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		current_container.AddDelegate (del);
 		current_delegate = del;
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 340
 #line 2627 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 	  }
   break;
 case 341
 #line 2631 "cs-parser.jay"
   {
 		current_delegate.SetParameterInfo ((List<Constraints>) yyVals[-2+yyTop]);
 		lbag.AddMember (current_delegate, mod_locations, GetLocation (yyVals[-10+yyTop]), GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[0+yyTop]));
 
 		yyVal = current_delegate;
 
 		current_delegate = null;
 	  }
   break;
 case 343
 #line 2644 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "nullable types");
 	  
 	  	yyVal = ComposedTypeSpecifier.CreateNullable (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 345
 #line 2655 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 347
 #line 2666 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 348
 #line 2675 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 350
 #line 2687 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");	  
 	  
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 351
 #line 2694 "cs-parser.jay"
   {
 		Error_TypeExpected (lexer.Location);
 		yyVal = new TypeArguments ();
 	  }
   break;
 case 352
 #line 2702 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 353
 #line 2708 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 354
 #line 2720 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 355
 #line 2724 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 356
 #line 2733 "cs-parser.jay"
   {
 	  	MemberName mn = (MemberName)yyVals[0+yyTop];
 	  	if (mn.TypeArguments != null)
 	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
 	  			mn.GetSignatureForError ()));
 	  }
   break;
 case 358
 #line 2744 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 359
 #line 2753 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		yyVal = new MemberName (TypeContainer.DefaultIndexerName, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 360
 #line 2758 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		yyVal = new MemberName ((MemberName) yyVals[-1+yyTop], TypeContainer.DefaultIndexerName, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 361
 #line 2766 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 362
 #line 2772 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[-1+yyTop], lt1.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 363
 #line 2780 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 365
 #line 2790 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");
 	  
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 366
 #line 2801 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 367
 #line 2807 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 		lbag.AddLocation (yyVals[0+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 368
 #line 2817 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 		yyVal = new TypeParameterName (lt.Value, (Attributes)yyVals[-2+yyTop], (Variance) yyVals[-1+yyTop], lt.Location);
   	  }
   break;
 case 369
 #line 2822 "cs-parser.jay"
   {
   	  	if (GetTokenName (yyToken) == "type")
 			Report.Error (81, GetLocation (yyVals[0+yyTop]), "Type parameter declaration must be an identifier not a type");
 		else
 			Error_SyntaxError (yyToken);
 			
   	  	yyVal = new TypeParameterName ("", null, lexer.Location);
   	  }
   break;
 case 371
 #line 2838 "cs-parser.jay"
   {
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 372
 #line 2845 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 374
 #line 2856 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 376
 #line 2865 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 378
 #line 2874 "cs-parser.jay"
   {
 	  	Report.Error (1536, GetLocation (yyVals[0+yyTop]), "Invalid parameter type `void'");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 380
 #line 2883 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 381
 #line 2890 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-1+yyTop];
 
 		if (yyVals[0+yyTop] != null) {
 			yyVal = new ComposedCast (name.GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			if (name.Left == null && name.Name == "var")
 				yyVal = new VarExpr (name.Location);
 			else
 				yyVal = name.GetTypeExpression ();
 		}
 	  }
   break;
 case 382
 #line 2903 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (((MemberName) yyVals[-1+yyTop]).GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 383
 #line 2907 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null)
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 384
 #line 2912 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 385
 #line 2916 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 386
 #line 2923 "cs-parser.jay"
   {
 		var types = new List<FullNamedExpression> (2);
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 387
 #line 2929 "cs-parser.jay"
   {
 		var types = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 388
 #line 2938 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast) {
 			Report.Error (1521, GetLocation (yyVals[0+yyTop]), "Invalid base type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 389
 #line 2945 "cs-parser.jay"
   {
 	  	Error_TypeExpected (lexer.Location);
 		yyVal = null;
 	  }
   break;
 case 390
 #line 2956 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.object_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 391
 #line 2957 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.string_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 392
 #line 2958 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.bool_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 393
 #line 2959 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.decimal_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 394
 #line 2960 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.float_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 395
 #line 2961 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.double_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 397
 #line 2966 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.sbyte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 398
 #line 2967 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.byte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 399
 #line 2968 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.short_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 400
 #line 2969 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.ushort_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 401
 #line 2970 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 402
 #line 2971 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 403
 #line 2972 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 404
 #line 2973 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 405
 #line 2974 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.char_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 425
 #line 3006 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new SimpleName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 426
 #line 3010 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	       yyVal = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
 	  }
   break;
 case 430
 #line 3020 "cs-parser.jay"
   { yyVal = new NullLiteral (GetLocation (yyVals[0+yyTop])); }
   break;
 case 431
 #line 3024 "cs-parser.jay"
   { yyVal = new BoolLiteral (true, GetLocation (yyVals[0+yyTop])); }
   break;
 case 432
 #line 3025 "cs-parser.jay"
   { yyVal = new BoolLiteral (false, GetLocation (yyVals[0+yyTop])); }
   break;
 case 437
 #line 3051 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 438
 #line 3056 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 	  }
   break;
 case 439
 #line 3063 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 440
 #line 3069 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 441
 #line 3075 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 442
 #line 3081 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 443
 #line 3087 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null,GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 444
 #line 3090 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
 	  }
   break;
 case 445
 #line 3095 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null, lexer.Location);
 	  }
   break;
 case 446
 #line 3098 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
  	  }
   break;
 case 447
 #line 3106 "cs-parser.jay"
   {
 		yyVal = new Invocation ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 448
 #line 3113 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 450
 #line 3119 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] == null) {
 	  		yyVal = CollectionOrObjectInitializers.Empty;
 	  		/* TODO
 	  	} else {
 	  		yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  	}
 	  }
   break;
 case 451
 #line 3129 "cs-parser.jay"
   {
 	  	yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 452
 #line 3136 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 453
 #line 3138 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	}
   break;
 case 454
 #line 3145 "cs-parser.jay"
   {
 	  	var a = new List<Expression> ();
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 455
 #line 3151 "cs-parser.jay"
   {
 	  	var a = (List<Expression>)yyVals[-2+yyTop];
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 456
 #line 3156 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 457
 #line 3164 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 	  	yyVal = new ElementInitializer (lt.Value, (Expression)yyVals[0+yyTop], lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 458
 #line 3170 "cs-parser.jay"
   {
 		yyVal = new CompletionElementInitializer (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 459
 #line 3173 "cs-parser.jay"
   {
 		CompletionSimpleName csn = yyVals[-1+yyTop] as CompletionSimpleName;
 		if (csn == null)
 			yyVal = new CollectionElementInitializer ((Expression)yyVals[-1+yyTop]);
 		else
 			yyVal = new CompletionElementInitializer (csn.Prefix, csn.Location);
 	  }
   break;
 case 460
 #line 3181 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] == null)
 			yyVal = null;
 		else
 	  		yyVal = new CollectionElementInitializer ((List<Expression>)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 461
 #line 3188 "cs-parser.jay"
   {
 	  	Report.Error (1920, GetLocation (yyVals[-1+yyTop]), "An element initializer cannot be empty");
 		yyVal = null;
 	  }
   break;
 case 464
 #line 3200 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 466
 #line 3206 "cs-parser.jay"
   { 
 		Arguments list = new Arguments (4);
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 467
 #line 3212 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		if (list [list.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
 		
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 468
 #line 3221 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		NamedArgument a = (NamedArgument) yyVals[0+yyTop];
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		
 		list.Add (a);
 		yyVal = list;
 	  }
   break;
 case 469
 #line 3235 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[0+yyTop]), "An argument is missing");
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 470
 #line 3240 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[-1+yyTop]), "An argument is missing");
 	  	yyVal = null;
 	  }
   break;
 case 471
 #line 3248 "cs-parser.jay"
   {
 		yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 475
 #line 3261 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Ref);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 476
 #line 3266 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Out);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 477
 #line 3271 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 478
 #line 3276 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist (GetLocation (yyVals[-2+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 480
 #line 3288 "cs-parser.jay"
   {
 		yyVal = new ElementAccess ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 481
 #line 3296 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 482
 #line 3302 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 483
 #line 3307 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 484
 #line 3315 "cs-parser.jay"
   {
 		Arguments args = new Arguments (4);
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;
 	  }
   break;
 case 485
 #line 3321 "cs-parser.jay"
   {
 		Arguments args = (Arguments) yyVals[-2+yyTop];
 		if (args [args.Count - 1] is NamedArgument && !(yyVals[0+yyTop] is NamedArgument))
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 	  
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;	  
 	  }
   break;
 case 486
 #line 3333 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 488
 #line 3341 "cs-parser.jay"
   {
 		yyVal = new This (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 489
 #line 3348 "cs-parser.jay"
   {
 	  	yyVal = new ElementAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 490
 #line 3353 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = new ElementAccess (null, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 491
 #line 3361 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 492
 #line 3368 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 493
 #line 3375 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			if (RootContext.Version <= LanguageVersion.ISO_2)
 				Report.FeatureIsNotAvailable (GetLocation (yyVals[-5+yyTop]), "object initializers");
 				
 			yyVal = new NewInitialize ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		} else {
 			yyVal = new New ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], GetLocation (yyVals[-5+yyTop]));
 		}
 		
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 494
 #line 3388 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "collection initializers");
 	  
 		yyVal = new NewInitialize ((FullNamedExpression) yyVals[-1+yyTop], null, (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 495
 #line 3400 "cs-parser.jay"
   {
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], (List<Expression>) yyVals[-3+yyTop],
 				new ComposedTypeSpecifier (((List<Expression>) yyVals[-3+yyTop]).Count, GetLocation (yyVals[-4+yyTop])) {
 	  				Next = (ComposedTypeSpecifier) yyVals[-1+yyTop]
 			  	}, (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 496
 #line 3408 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] == null)
 	  		Report.Error (1586, GetLocation (yyVals[-3+yyTop]), "Array creation must have array size or array initializer");
 
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-2+yyTop], (ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 497
 #line 3415 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "implicitly typed arrays");
 	  
 		yyVal = new ImplicitlyTypedArrayCreation ((ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 498
 #line 3422 "cs-parser.jay"
   {
 		Report.Error (178, GetLocation (yyVals[-1+yyTop]), "Invalid rank specifier, expecting `,' or `]'");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], null, GetLocation (yyVals[-6+yyTop]));
 	  }
   break;
 case 499
 #line 3427 "cs-parser.jay"
   {
 		Error_SyntaxError (1526, yyToken, "Unexpected symbol");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-1+yyTop], null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 500
 #line 3434 "cs-parser.jay"
   {
 		++lexer.parsing_type;
 	  }
   break;
 case 501
 #line 3438 "cs-parser.jay"
   {
 		--lexer.parsing_type;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 502
 #line 3446 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "anonymous types");
 
 		yyVal = new NewAnonymousType ((List<AnonymousTypeParameter>) yyVals[-1+yyTop], current_container, GetLocation (yyVals[-3+yyTop]));
 		
 		/* TODO
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 505
 #line 3463 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 507
 #line 3469 "cs-parser.jay"
   {
 	  	var a = new List<AnonymousTypeParameter> (4);
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 508
 #line 3475 "cs-parser.jay"
   {
 	  	var a = (List<AnonymousTypeParameter>) yyVals[-2+yyTop];
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 509
 #line 3484 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[-2+yyTop];
 	  	yyVal = new AnonymousTypeParameter ((Expression)yyVals[0+yyTop], lt.Value, lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 510
 #line 3490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (new SimpleName (lt.Value, lt.Location),
 	  		lt.Value, lt.Location);
 	  }
   break;
 case 511
 #line 3496 "cs-parser.jay"
   {
 	  	MemberAccess ma = (MemberAccess) yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (ma, ma.Name, ma.Location);
 	  }
   break;
 case 512
 #line 3501 "cs-parser.jay"
   {
 		Report.Error (746, lexer.Location,
 			"Invalid anonymous type member declarator. Anonymous type members must be a member assignment, simple name or member access expression");
 		yyVal = null;
 	  }
   break;
 case 516
 #line 3516 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 517
 #line 3524 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 518
 #line 3528 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension ((int)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 519
 #line 3535 "cs-parser.jay"
   {
 		yyVal = 2;
 	  }
   break;
 case 520
 #line 3539 "cs-parser.jay"
   {
 		yyVal = ((int) yyVals[-1+yyTop]) + 1;
 	  }
   break;
 case 521
 #line 3546 "cs-parser.jay"
   {
 		yyVal = null;
 	  }
   break;
 case 522
 #line 3550 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 523
 #line 3557 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer (0, GetLocation (yyVals[-1+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[0+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 524
 #line 3564 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[-1+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 525
 #line 3574 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 526
 #line 3580 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 527
 #line 3589 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = true;
 	  }
   break;
 case 528
 #line 3593 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = false;
 		yyVal = new TypeOf ((FullNamedExpression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 531
 #line 3604 "cs-parser.jay"
   {
 	 	Error_TypeExpected (lexer.Location);
 	 	yyVal = null;
 	 }
   break;
 case 532
 #line 3612 "cs-parser.jay"
   {  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new SimpleName (lt.Value, (int) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 533
 #line 3618 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (int) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 534
 #line 3625 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 535
 #line 3631 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 536
 #line 3637 "cs-parser.jay"
   {
 		var te = ((MemberName) yyVals[-3+yyTop]).GetTypeExpression ();
 		if (te.HasTypeArguments)
 			Error_TypeExpected (GetLocation (yyVals[0+yyTop]));
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (te, lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 537
 #line 3649 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "generics");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 538
 #line 3659 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		if (RootContext.Version == LanguageVersion.ISO_1)
 			Report.FeatureIsNotAvailable (lt.Location, "namespace alias qualifier");
 
 		yyVal = lt;		
 	  }
   break;
 case 539
 #line 3670 "cs-parser.jay"
   { 
 		yyVal = new SizeOf ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 540
 #line 3678 "cs-parser.jay"
   {
 		yyVal = new CheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 541
 #line 3686 "cs-parser.jay"
   {
 		yyVal = new UnCheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 542
 #line 3694 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberAccess (new Indirection ((Expression) yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop])), lt.Value, lt.Location);
 	  }
   break;
 case 543
 #line 3702 "cs-parser.jay"
   {
 		start_anonymous (false, (ParametersCompiled) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 544
 #line 3706 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 	  }
   break;
 case 545
 #line 3713 "cs-parser.jay"
   {
 		yyVal = ParametersCompiled.Undefined;
 	  }
   break;
 case 547
 #line 3721 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 548
 #line 3725 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 549
 #line 3733 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "default value expression");
 
 		yyVal = new DefaultValueExpression ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 551
 #line 3745 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.LogicalNot, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 552
 #line 3749 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.OnesComplement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 554
 #line 3757 "cs-parser.jay"
   {
 		yyVal = new Cast ((FullNamedExpression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 556
 #line 3770 "cs-parser.jay"
   { 
 	  	yyVal = new Unary (Unary.Operator.UnaryPlus, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 557
 #line 3774 "cs-parser.jay"
   { 
 		yyVal = new Unary (Unary.Operator.UnaryNegation, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 558
 #line 3778 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 559
 #line 3782 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 560
 #line 3786 "cs-parser.jay"
   {
 		yyVal = new Indirection ((Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 561
 #line 3790 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.AddressOf, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 563
 #line 3798 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Multiply, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 564
 #line 3803 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Division, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 565
 #line 3808 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Modulus, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 567
 #line 3817 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Addition, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 568
 #line 3822 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 569
 #line 3826 "cs-parser.jay"
   {
 	  	/* Shift/Reduce conflict*/
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
   	  }
   break;
 case 570
 #line 3831 "cs-parser.jay"
   {
 		yyVal = new As ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 571
 #line 3835 "cs-parser.jay"
   {
 		yyVal = new Is ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 573
 #line 3843 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LeftShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 574
 #line 3848 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.RightShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 576
 #line 3857 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 577
 #line 3862 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 578
 #line 3867 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 579
 #line 3872 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 581
 #line 3881 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Equality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 582
 #line 3886 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Inequality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 584
 #line 3895 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 586
 #line 3904 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.ExclusiveOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 588
 #line 3913 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 590
 #line 3922 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 592
 #line 3931 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 594
 #line 3940 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "null coalescing operator");
 			
 		yyVal = new Nullable.NullCoalescingOperator ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 596
 #line 3951 "cs-parser.jay"
   {
 		yyVal = new Conditional (new BooleanExpression ((Expression) yyVals[-4+yyTop]), (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 597
 #line 3959 "cs-parser.jay"
   {
 		yyVal = new SimpleAssign ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 598
 #line 3963 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Multiply, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 599
 #line 3968 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Division, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 600
 #line 3973 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Modulus, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 601
 #line 3978 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Addition, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 602
 #line 3983 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 603
 #line 3988 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.LeftShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 604
 #line 3993 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.RightShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 605
 #line 3998 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseAnd, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 606
 #line 4003 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 607
 #line 4008 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.ExclusiveOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 608
 #line 4016 "cs-parser.jay"
   {
 		var pars = new List<Parameter> (4);
 		pars.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = pars;
 	  }
   break;
 case 609
 #line 4023 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter)yyVals[0+yyTop];
 		if (pars[0].GetType () != p.GetType ()) {
 			Report.Error (748, p.Location, "All lambda parameters must be typed either explicitly or implicitly");
 		}
 		
 		pars.Add (p);
 		yyVal = pars;
 	  }
   break;
 case 610
 #line 4037 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], null, lt.Location);
 	  }
   break;
 case 611
 #line 4043 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, Parameter.Modifier.NONE, null, lt.Location);
 	  }
   break;
 case 612
 #line 4049 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ImplicitLambdaParameter (lt.Value, lt.Location);
 	  }
   break;
 case 613
 #line 4056 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 614
 #line 4057 "cs-parser.jay"
   { 
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 		yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 617
 #line 4069 "cs-parser.jay"
   {
 		start_block (lexer.Location);
 	  }
   break;
 case 618
 #line 4073 "cs-parser.jay"
   {
 		Block b = end_block (lexer.Location);
 		b.AddStatement (new ContextualReturn ((Expression) yyVals[0+yyTop]));
 		yyVal = b;
 	  }
   break;
 case 620
 #line 4083 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	
 		yyVal = EmptyExpression.Null;
 	  }
   break;
 case 621
 #line 4091 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
 		start_anonymous (true, new ParametersCompiled (p), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 622
 #line 4097 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 623
 #line 4102 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "lambda expressions");
 	  
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 624
 #line 4109 "cs-parser.jay"
   {
 	  	valid_param_mod = 0;
 		start_anonymous (true, (ParametersCompiled) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 625
 #line 4114 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 631
 #line 4130 "cs-parser.jay"
   {
 		yyVal = new ArglistAccess (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 633
 #line 4141 "cs-parser.jay"
   {
 		yyVal = new BooleanExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 634
 #line 4154 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 635
 #line 4158 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Class (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 636
 #line 4164 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 637
 #line 4176 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 638
 #line 4182 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 639
 #line 4190 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 640
 #line 4192 "cs-parser.jay"
   { yyVal = yyVals[0+yyTop]; }
   break;
 case 641
 #line 4197 "cs-parser.jay"
   {
 	    mod_locations = null;
 		yyVal = ModifierNone;
 	  }
   break;
 case 644
 #line 4207 "cs-parser.jay"
   { 
 		var m1 = (Modifiers) yyVals[-1+yyTop];
 		var m2 = (Modifiers) yyVals[0+yyTop];
 
 		if ((m1 & m2) != 0) {
 			Report.Error (1004, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"Duplicate `{0}' modifier", ModifiersExtensions.Name (m2));
 		} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
 			((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
 			Report.Error (107, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"More than one protection modifier specified");
 		}
 		
 		yyVal = m1 | m2;
 	  }
   break;
 case 645
 #line 4226 "cs-parser.jay"
   {
 		yyVal = Modifiers.NEW;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		
 		if (current_container == RootContext.ToplevelTypes)
 			Report.Error (1530, GetLocation (yyVals[0+yyTop]), "Keyword `new' is not allowed on namespace elements");
 	  }
   break;
 case 646
 #line 4234 "cs-parser.jay"
   {
 		yyVal = Modifiers.PUBLIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 647
 #line 4239 "cs-parser.jay"
   {
 		yyVal = Modifiers.PROTECTED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 648
 #line 4244 "cs-parser.jay"
   {
 		yyVal = Modifiers.INTERNAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 649
 #line 4249 "cs-parser.jay"
   {
 		yyVal = Modifiers.PRIVATE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 650
 #line 4254 "cs-parser.jay"
   {
 		yyVal = Modifiers.ABSTRACT;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 651
 #line 4259 "cs-parser.jay"
   {
 		yyVal = Modifiers.SEALED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 652
 #line 4264 "cs-parser.jay"
   {
 		yyVal = Modifiers.STATIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 653
 #line 4269 "cs-parser.jay"
   {
 		yyVal = Modifiers.READONLY;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 654
 #line 4274 "cs-parser.jay"
   {
 		yyVal = Modifiers.VIRTUAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 655
 #line 4279 "cs-parser.jay"
   {
 		yyVal = Modifiers.OVERRIDE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 656
 #line 4284 "cs-parser.jay"
   {
 		yyVal = Modifiers.EXTERN;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 657
 #line 4289 "cs-parser.jay"
   {
 		yyVal = Modifiers.VOLATILE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 658
 #line 4294 "cs-parser.jay"
   {
 		yyVal = Modifiers.UNSAFE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 659
 #line 4301 "cs-parser.jay"
   {
 		yyVal = Modifiers.ASYNC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 661
 #line 4310 "cs-parser.jay"
   {
 		current_container.AddBasesForPart (current_class, (List<FullNamedExpression>) yyVals[0+yyTop]);
 	 }
   break;
 case 663
 #line 4318 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 664
 #line 4322 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	 }
   break;
 case 665
 #line 4330 "cs-parser.jay"
   {
 		var constraints = new List<Constraints> (1);
 		constraints.Add ((Constraints) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 666
 #line 4336 "cs-parser.jay"
   {
 		var constraints = (List<Constraints>) yyVals[-1+yyTop];
 		Constraints new_constraint = (Constraints)yyVals[0+yyTop];
 
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 
 		constraints.Add (new_constraint);
 		yyVal = constraints;
 	  }
   break;
 case 667
 #line 4355 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 668
 #line 4363 "cs-parser.jay"
   {
 		var constraints = new List<FullNamedExpression> (1);
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 669
 #line 4369 "cs-parser.jay"
   {
 		var constraints = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
 		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
 			Report.Error (401, GetLocation (yyVals[-1+yyTop]), "The `new()' constraint must be the last constraint specified");
 		}
 		
 		prev = yyVals[0+yyTop] as SpecialContraintExpr;
 		if (prev != null) {
 			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
 				Report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
 			} else {
 			 	prev = constraints [0] as SpecialContraintExpr;
 			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
 					Report.Error (451, GetLocation (yyVals[0+yyTop]), "The `new()' constraint cannot be used with the `struct' constraint");
 				}
 			}
 		}
 
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 670
 #line 4395 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast)
 			Report.Error (706, GetLocation (yyVals[0+yyTop]), "Invalid constraint type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 	  
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 671
 #line 4402 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 672
 #line 4407 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 673
 #line 4411 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 674
 #line 4418 "cs-parser.jay"
   {
 		yyVal = Variance.None;
 	  }
   break;
 case 675
 #line 4422 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (lexer.Location, "generic type variance");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 676
 #line 4432 "cs-parser.jay"
   {
 		yyVal = Variance.Covariant;
 	  }
   break;
 case 677
 #line 4436 "cs-parser.jay"
   {
 		yyVal = Variance.Contravariant;
 	  }
   break;
 case 678
 #line 4456 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 679
 #line 4461 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 680
 #line 4468 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 681
 #line 4473 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (lexer.Location);
 	  }
   break;
 case 682
 #line 4482 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		current_block.StartLocation = GetLocation (yyVals[0+yyTop]);
 	  }
   break;
 case 683
 #line 4487 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 688
 #line 4505 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 689
 #line 4509 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 691
 #line 4514 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 694
 #line 4533 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 695
 #line 4537 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 724
 #line 4578 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 725
 #line 4583 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 726
 #line 4588 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 727
 #line 4596 "cs-parser.jay"
   {
 		/* Uses lexer.Location because semicolon location is not kept in quick mode*/
 		yyVal = new EmptyStatement (lexer.Location);
 	  }
   break;
 case 728
 #line 4604 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
 
 		current_block.AddLabel (labeled);
 		current_block.AddStatement (labeled);
 	  }
   break;
 case 731
 #line 4617 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] is VarExpr)
 			yyVals[-1+yyTop] = new SimpleName ("var", ((VarExpr) yyVals[-1+yyTop]).Location);
 	  
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 732
 #line 4633 "cs-parser.jay"
   { 
 		/* Ok, the above "primary_expression" is there to get rid of*/
 		/* both reduce/reduce and shift/reduces in the grammar, it should*/
 		/* really just be "type_name".  If you use type_name, a reduce/reduce*/
 		/* creeps up.  If you use namespace_or_type_name (which is all we need*/
 		/* really) two shift/reduces appear.*/
 		/* */
 
 		/* So the super-trick is that primary_expression*/
 		/* can only be either a SimpleName or a MemberAccess. */
 		/* The MemberAccess case arises when you have a fully qualified type-name like 
 		/* Foo.Bar.Blah i;*/
 		/* SimpleName is when you have*/
 		/* Blah i;*/
 		
 		Expression expr = (Expression) yyVals[-1+yyTop];
 		if (yyVals[0+yyTop] == null) {
 			SimpleName sn = expr as SimpleName;
 			if (sn != null && sn.Name == "var")
 				yyVal = new VarExpr (sn.Location);
 			else
 				yyVal = yyVals[-1+yyTop];
 		} else if (expr is ATypeNameExpression) {
 			yyVal = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName (expr);
 			yyVal = null;
 		}
 	  }
   break;
 case 733
 #line 4663 "cs-parser.jay"
   {
 		ATypeNameExpression expr = yyVals[-1+yyTop] as ATypeNameExpression;
 
 		if (expr != null) {
 			yyVal = new ComposedCast (expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName ((Expression)yyVals[-1+yyTop]);
 			yyVal = expr;
 		}
 	  }
   break;
 case 734
 #line 4674 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] == null)
 			yyVal = yyVals[-1+yyTop];
 		else
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 735
 #line 4681 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 736
 #line 4685 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 737
 #line 4689 "cs-parser.jay"
   {
 		Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 739
 #line 4698 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 740
 #line 4706 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreatePointer (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 741
 #line 4713 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 742
 #line 4720 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 743
 #line 4726 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockConstantDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 744
 #line 4733 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 746
 #line 4743 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		/* TODO
 	  }
   break;
 case 747
 #line 4748 "cs-parser.jay"
   {
 	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
 			Report.Error (650, lexer.Location,
 				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 	  }
   break;
 case 752
 #line 4770 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, null);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 753
 #line 4779 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 754
 #line 4791 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 	  }
   break;
 case 755
 #line 4795 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 760
 #line 4812 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 762
 #line 4825 "cs-parser.jay"
   {
 		yyVal = new StackAlloc ((Expression) yyVals[-3+yyTop], (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 763
 #line 4830 "cs-parser.jay"
   {
 		Report.Error (1575, GetLocation (yyVals[-1+yyTop]), "A stackalloc expression requires [] after type");
 		yyVal = new StackAlloc ((Expression) yyVals[0+yyTop], null, GetLocation (yyVals[-1+yyTop]));		
 	  }
   break;
 case 764
 #line 4838 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 765
 #line 4842 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 766
 #line 4846 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 767
 #line 4847 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 768
 #line 4856 "cs-parser.jay"
   {
 		ExpressionStatement s = yyVals[0+yyTop] as ExpressionStatement;
 		if (s == null) {
 			Expression.Error_InvalidExpressionStatement (Report, GetLocation (yyVals[0+yyTop]));
 			s = EmptyExpressionStatement.Instance;
 		}
 
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 769
 #line 4869 "cs-parser.jay"
   {
 		Expression expr = (Expression) yyVals[0+yyTop];
 		ExpressionStatement s;
 
 	        s = new OptionalAssign (new SimpleName ("$retval", lexer.Location), expr, lexer.Location);
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 770
 #line 4877 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 773
 #line 4891 "cs-parser.jay"
   { 
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 		
 		yyVal = new If ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 774
 #line 4900 "cs-parser.jay"
   {
 		yyVal = new If ((BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		
 		if (yyVals[-2+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[-2+yyTop]));
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 775
 #line 4913 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 776
 #line 4917 "cs-parser.jay"
   {
 		yyVal = new Switch ((Expression) yyVals[-5+yyTop], (ExplicitBlock) current_block.Explicit, (List<SwitchSection>) yyVals[-1+yyTop], GetLocation (yyVals[-7+yyTop]));	
 		end_block (GetLocation (yyVals[0+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 777
 #line 4926 "cs-parser.jay"
   {
 		Report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 779
 #line 4935 "cs-parser.jay"
   {
 		var sections = new List<SwitchSection> (4);
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 780
 #line 4942 "cs-parser.jay"
   {
 		var sections = (List<SwitchSection>) yyVals[-1+yyTop];
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 781
 #line 4949 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 782
 #line 4957 "cs-parser.jay"
   {
 		current_block = current_block.CreateSwitchBlock (lexer.Location);
 	  }
   break;
 case 783
 #line 4961 "cs-parser.jay"
   {
 		yyVal = new SwitchSection ((List<SwitchLabel>) yyVals[-2+yyTop], current_block);
 	  }
   break;
 case 784
 #line 4968 "cs-parser.jay"
   {
 		var labels = new List<SwitchLabel> (4);
 
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 		yyVal = labels;
 	  }
   break;
 case 785
 #line 4975 "cs-parser.jay"
   {
 		var labels = (List<SwitchLabel>) (yyVals[-1+yyTop]);
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 
 		yyVal = labels;
 	  }
   break;
 case 786
 #line 4985 "cs-parser.jay"
   {
 	 	yyVal = new SwitchLabel ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	 	lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	 }
   break;
 case 787
 #line 4990 "cs-parser.jay"
   {
 		yyVal = new SwitchLabel (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 792
 #line 5004 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new While ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 793
 #line 5016 "cs-parser.jay"
   {
 		yyVal = new Do ((Statement) yyVals[-5+yyTop], (BooleanExpression) yyVals[-2+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 794
 #line 5024 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 		current_block.IsCompilerGenerated = true;
 	  }
   break;
 case 795
 #line 5029 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 796
 #line 5040 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		For f = new For ((Statement) yyVals[-6+yyTop], (BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, current_block.StartLocation, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		yyVal = end_block (GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 797
 #line 5052 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = end_block (current_block.StartLocation);
 	  }
   break;
 case 798
 #line 5059 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 800
 #line 5065 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 801
 #line 5072 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 803
 #line 5080 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 805
 #line 5085 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 809
 #line 5096 "cs-parser.jay"
   {
 	  	var sl = yyVals[-2+yyTop] as StatementList;
 	  	if (sl == null) {
 	  		sl = new StatementList ((Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop]);
 			lbag.AddStatement (sl, GetLocation (yyVals[-1+yyTop]));
 	  	} else {
 	  		sl.Add ((Statement) yyVals[0+yyTop]);
 	  		lbag.AppendTo (sl, GetLocation (yyVals[-1+yyTop]));
 	  	}
 	  		
 		yyVal = sl;
 	  }
   break;
 case 810
 #line 5112 "cs-parser.jay"
   {
 		Report.Error (230, GetLocation (yyVals[-5+yyTop]), "Type and identifier are both required in a foreach statement");
 		yyVal = null;
 	  }
   break;
 case 811
 #line 5117 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-5+yyTop]));
 		current_block.IsCompilerGenerated = true;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.ForeachVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		yyVal = li;
 	  }
   break;
 case 812
 #line 5127 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Foreach f = new Foreach ((Expression) yyVals[-6+yyTop], (LocalVariable) yyVals[-1+yyTop], (Expression) yyVals[-3+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-8+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 819
 #line 5150 "cs-parser.jay"
   {
 		yyVal = new Break (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 820
 #line 5158 "cs-parser.jay"
   {
 		yyVal = new Continue (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 821
 #line 5166 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new Goto (lt.Value, lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 822
 #line 5172 "cs-parser.jay"
   {
 		yyVal = new GotoCase ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 823
 #line 5177 "cs-parser.jay"
   {
 		yyVal = new GotoDefault (GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 824
 #line 5185 "cs-parser.jay"
   {
 		yyVal = new Return ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 825
 #line 5193 "cs-parser.jay"
   {
 		yyVal = new Throw ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 826
 #line 5201 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (yyVals[-1+yyTop] == null) {
 			Report.Error (1627, GetLocation (yyVals[0+yyTop]), "Expression expected after yield return");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new Yield ((Expression) yyVals[-1+yyTop], lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 827
 #line 5217 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new YieldBreak (lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 830
 #line 5239 "cs-parser.jay"
   {
 		yyVal = new TryCatch ((Block) yyVals[-1+yyTop], (List<Catch>) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]), false);
 	  }
   break;
 case 831
 #line 5243 "cs-parser.jay"
   {
 		yyVal = new TryFinally ((Statement) yyVals[-2+yyTop], (Block) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 832
 #line 5248 "cs-parser.jay"
   {
 		yyVal = new TryFinally (new TryCatch ((Block) yyVals[-3+yyTop], (List<Catch>) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]), true), (Block) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 833
 #line 5253 "cs-parser.jay"
   {
 		Report.Error (1524, GetLocation (yyVals[-2+yyTop]), "Expected catch or finally");
 		yyVal = null;
 	  }
   break;
 case 834
 #line 5261 "cs-parser.jay"
   {
 		var l = new List<Catch> (2);
 
 		l.Add ((Catch) yyVals[0+yyTop]);
 		yyVal = l;
 	  }
   break;
 case 835
 #line 5268 "cs-parser.jay"
   {
 		var l = (List<Catch>) yyVals[-1+yyTop];
 		
 		Catch c = (Catch) yyVals[0+yyTop];
 		if (l [0].IsGeneral) {
 			Report.Error (1017, c.loc, "Try statement already has an empty catch block");
 		} else {
 			if (c.IsGeneral)
 				l.Insert (0, c);
 			else
 				l.Add (c);
 		}
 		
 		yyVal = l;
 	  }
   break;
 case 838
 #line 5292 "cs-parser.jay"
   {
 		yyVal = new Catch ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 839
 #line 5296 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-3+yyTop]));
 		var c = new Catch (current_block, GetLocation (yyVals[-4+yyTop]));
 		c.TypeExpression = (FullNamedExpression) yyVals[-2+yyTop];
 
 		if (yyVals[-1+yyTop] != null) {
 			var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
 			current_block.AddLocalName (c.Variable);
 		}
 		
 		lbag.AddLocation (c, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 840
 #line 5311 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 841
 #line 5315 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_PARENS) {
 			Report.Error (1015, lexer.Location,
 				"A type that derives from `System.Exception', `object', or `string' expected");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 		
 		yyVal = new Catch (null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 842
 #line 5329 "cs-parser.jay"
   {
 		yyVal = new Checked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 843
 #line 5336 "cs-parser.jay"
   {
 		yyVal = new Unchecked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 844
 #line 5343 "cs-parser.jay"
   {
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 845
 #line 5346 "cs-parser.jay"
   {
 		yyVal = new Unsafe ((Block) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 846
 #line 5353 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new Lock ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 847
 #line 5364 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.FixedVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Fixed.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 848
 #line 5373 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 849
 #line 5378 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Fixed f = new Fixed ((Fixed.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 850
 #line 5390 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.UsingVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Using.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 851
 #line 5399 "cs-parser.jay"
   {
 		yyVal = current_variable;	  
 		current_variable = null;
 	  }
   break;
 case 852
 #line 5404 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Using.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (u);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 853
 #line 5413 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (u, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = u;
 	  }
   break;
 case 854
 #line 5425 "cs-parser.jay"
   {
 		Report.Error (210, lexer.Location, "You must provide an initializer in a fixed or using statement declaration");
 	  }
   break;
 case 855
 #line 5429 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		yyVal = current_variable;
 	  }
   break;
 case 856
 #line 5440 "cs-parser.jay"
   {
 		lexer.query_parsing = false;
 			
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 857
 #line 5452 "cs-parser.jay"
   {
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 858
 #line 5463 "cs-parser.jay"
   {
 	        lexer.query_parsing = false;
 		yyVal = yyVals[-1+yyTop];
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 859
 #line 5470 "cs-parser.jay"
   {
 	        yyVal = yyVals[-1+yyTop];
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 860
 #line 5479 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 861
 #line 5487 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 862
 #line 5502 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 863
 #line 5510 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 864
 #line 5525 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 865
 #line 5529 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 866
 #line 5540 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 867
 #line 5544 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop])) {
 			IdentifierType = (FullNamedExpression)yyVals[-4+yyTop]
 		};
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 868
 #line 5561 "cs-parser.jay"
   {
 	  	Linq.AQueryClause head = (Linq.AQueryClause)yyVals[-1+yyTop];
 		
 		if (yyVals[0+yyTop] != null)
 			head.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 				
 		if (yyVals[-2+yyTop] != null) {
 			Linq.AQueryClause clause = (Linq.AQueryClause)yyVals[-2+yyTop];
 			clause.Tail.Next = head;
 			head = clause;
 		}
 		
 		yyVal = head;
 	  }
   break;
 case 870
 #line 5577 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 871
 #line 5585 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 872
 #line 5589 "cs-parser.jay"
   {
 		yyVal = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 873
 #line 5596 "cs-parser.jay"
   {
 	  	if (linq_clause_blocks == null)
 	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
 	  }
   break;
 case 874
 #line 5604 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 875
 #line 5611 "cs-parser.jay"
   {
 		yyVal = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)yyVals[-3+yyTop], linq_clause_blocks.Pop (), (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 879
 #line 5627 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-1+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 885
 #line 5643 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 886
 #line 5647 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 	  	yyVal = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  	
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 887
 #line 5661 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 888
 #line 5665 "cs-parser.jay"
   {
 		yyVal = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 889
 #line 5675 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 890
 #line 5683 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 891
 #line 5691 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 892
 #line 5699 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];	
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-11+yyTop]));
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 			
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location);
 
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-11+yyTop]));	
 		}
 
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);
 	  }
   break;
 case 893
 #line 5735 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 894
 #line 5743 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 895
 #line 5751 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 896
 #line 5759 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;		
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 		
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location); /* TODO
 			
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};			
 		}
 		
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
 	  }
   break;
 case 898
 #line 5803 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 899
 #line 5810 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 900
 #line 5814 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 902
 #line 5825 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 903
 #line 5832 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	  }
   break;
 case 905
 #line 5841 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, (Linq.QueryBlock) current_block, lexer.Location);	 
 	 }
   break;
 case 906
 #line 5848 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	 }
   break;
 case 907
 #line 5856 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 908
 #line 5860 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 909
 #line 5864 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 910
 #line 5871 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 911
 #line 5875 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 912
 #line 5879 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 914
 #line 5888 "cs-parser.jay"
   {
 		/* query continuation block is not linked with query block but with block*/
 		/* before. This means each query can use same range variable names for*/
 		/* different identifiers.*/
 
 		current_block.SetEndLocation (GetLocation (yyVals[-1+yyTop]));
 		current_block = current_block.Parent;
 	
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
 	  }
   break;
 case 915
 #line 5904 "cs-parser.jay"
   {
 		var current_block = linq_clause_blocks.Pop ();	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
   		yyVal = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation (yyVals[-3+yyTop])) {
   			next = (Linq.AQueryClause)yyVals[0+yyTop]
   		};
 	  }
   break;
 case 918
 #line 5930 "cs-parser.jay"
   { 
 	        Evaluator.LoadAliases (current_namespace);
 
 		push_current_class (new Class (current_namespace, current_class, new MemberName ("Class" + class_count++),
 			Modifiers.PUBLIC, null), null);
 
 		var baseclass_list = new List<FullNamedExpression> ();
 		baseclass_list.Add (new TypeExpression (Evaluator.InteractiveBaseClass, lexer.Location));
 		current_container.AddBasesForPart (current_class, baseclass_list);
 
 		/* (ref object retval)*/
 		Parameter [] mpar = new Parameter [1];
 		mpar [0] = new Parameter (new TypeExpression (TypeManager.object_type, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);
 
 		ParametersCompiled pars = new ParametersCompiled (mpar);
 		current_local_parameters = pars;
 		Method method = new Method (
 			current_class,
 			null, /* generic*/
 			new TypeExpression (TypeManager.void_type, Location.Null),
 			Modifiers.PUBLIC | Modifiers.STATIC,
 			new MemberName ("Host"),
 			pars,
 			null /* attributes */);
 
 		oob_stack.Push (method);
 	        ++lexer.parsing_block;
 		start_block (lexer.Location);
 	  }
   break;
 case 919
 #line 5960 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		Method method = (Method) oob_stack.Pop ();
 
 		method.Block = (ToplevelBlock) end_block(lexer.Location);
 		current_container.AddMethod (method);
 
 		--lexer.parsing_declaration;
 		InteractiveResult = pop_current_class ();
 		current_local_parameters = null;
 	  }
   break;
 case 920
 #line 5971 "cs-parser.jay"
   {
 	        Evaluator.LoadAliases (current_namespace);
 	  }
   break;
 #line default
         }
         yyTop -= yyLen[yyN];
         yyState = yyStates[yyTop];
         int yyM = yyLhs[yyN];
         if (yyState == 0 && yyM == 0) {
           if (debug != null) debug.shift(0, yyFinal);
           yyState = yyFinal;
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
                debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
           }
           if (yyToken == 0) {
             if (debug != null) debug.accept(yyVal);
             return yyVal;
           }
           goto continue_yyLoop;
         }
         if (((yyN = yyGindex[yyM]) != 0) && ((yyN += yyState) >= 0)
             && (yyN < yyTable.Length) && (yyCheck[yyN] == yyState))
           yyState = yyTable[yyN];
         else
           yyState = yyDgoto[yyM];
         if (debug != null) debug.shift(yyStates[yyTop], yyState);
 	 goto continue_yyLoop;
       continue_yyDiscarded
       }
     continue_yyLoop
     }
   }
 
    static  short [] yyLhs  = {              -1,
     0,    0,    0,    0,    5,    0,    2,    2,    1,    1,
     6,    6,    6,   10,   10,    7,    7,   11,   11,    8,
     8,   12,   12,   13,   20,   16,   18,   18,   18,   21,
    21,   22,   22,   15,   24,   19,   25,   25,   23,   23,
    26,   26,   27,   27,    9,    9,    9,   28,   28,   28,
    28,   28,    3,   17,   17,   34,   34,   35,   35,   36,
    38,   38,   38,   38,   37,   37,   42,   39,   40,   41,
    41,   43,   43,   43,   43,   43,   44,   44,   48,   45,
    47,   49,   49,   49,   50,   50,   51,   51,   52,   52,
    52,   52,   52,   52,   52,   52,   52,   52,   52,   65,
    67,   70,   71,   30,   30,   73,   69,   72,   72,   74,
    74,   75,   75,   75,   75,   75,   75,   75,   75,   75,
    75,   78,   53,   79,   79,   80,   80,   81,   83,   77,
    77,   82,   82,   88,   54,   92,   54,   54,   87,   95,
    87,   89,   89,   96,   96,   97,   98,   97,   93,   93,
    99,   99,  100,  101,   91,   91,   94,   94,   94,  104,
    55,  107,  108,  102,  109,  110,  102,  102,  103,  103,
   106,  106,  113,  113,  113,  113,  113,  113,  113,  113,
   113,  113,  114,  114,  117,  117,  117,  120,  117,  118,
   118,  121,  121,  122,  122,  122,  115,  115,  115,  123,
   123,  123,  116,  125,  127,  128,   56,  130,  131,  132,
    58,  126,  126,  126,  126,  126,  136,  133,  137,  134,
   135,  135,  135,  138,  139,  140,  142,   31,   31,  141,
   141,  143,  143,  144,  144,  144,  144,  144,  144,  144,
   144,  144,  147,   59,  146,  146,  148,  148,  151,  145,
   145,  150,  150,  150,  150,  150,  150,  150,  150,  150,
   150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
   150,  150,  150,  153,  152,  154,  152,  152,  152,   60,
   157,  159,  155,  156,  156,  158,  158,  163,  161,  164,
   161,  161,  165,   61,  167,   57,  170,  171,   57,  166,
   173,  166,  168,  168,  174,  174,  175,  176,  175,  177,
   172,  169,  169,  169,  169,  169,  181,  178,  182,  179,
   180,  180,  184,  186,  187,   32,  183,  183,  183,  185,
   185,  185,  188,  188,  189,  190,  189,  191,  192,  193,
    33,  194,  194,   14,   14,  195,  195,  198,  197,  197,
   197,  199,  199,  201,   64,  124,  105,  105,  129,  129,
   202,  202,  202,  200,  200,  203,  203,  204,  204,  206,
   206,   86,   76,   76,   90,   90,  119,  119,  149,  149,
   207,  207,  207,  207,  207,  211,  211,  212,  212,  210,
   210,  210,  210,  210,  210,  210,  213,  213,  213,  213,
   213,  213,  213,  213,  213,  214,  214,  214,  214,  214,
   214,  214,  214,  214,  214,  214,  214,  214,  214,  214,
   214,  214,  214,  214,  215,  215,  215,  216,  216,  216,
   235,  235,  236,  236,  237,  237,  218,  218,  234,  234,
   234,  234,  234,  234,  234,  234,  220,  238,  238,  239,
   239,  240,  240,  242,  242,  242,  243,  243,  243,  243,
   243,  244,  244,  162,  162,  248,  248,  248,  248,  248,
   250,  250,  249,  249,  251,  251,  251,  251,  252,  221,
   247,  247,  247,  253,  253,  254,  254,  222,  223,  223,
   224,  225,  226,  226,  217,  217,  217,  217,  217,  258,
   255,  227,  259,  259,  260,  260,  261,  261,  262,  262,
   262,  262,  256,  256,  208,  208,  263,  263,  264,  264,
   257,  257,   85,   85,  265,  265,  266,  228,  267,  267,
   267,  268,  268,  268,  268,  268,  269,  196,  229,  230,
   231,  232,  271,  233,  270,  270,  273,  272,  219,  274,
   274,  274,  274,  276,  275,  275,  275,  275,  275,  275,
   275,  277,  277,  277,  277,  278,  278,  278,  278,  278,
   278,  279,  279,  279,  280,  280,  280,  280,  280,  281,
   281,  281,  282,  282,  283,  283,  284,  284,  285,  285,
   286,  286,  287,  287,  288,  288,  289,  289,  289,  289,
   289,  289,  289,  289,  289,  289,  289,  290,  290,  291,
   291,  291,  292,  292,  293,  293,  296,  294,  295,  295,
   298,  297,  299,  300,  297,   46,   46,  245,  245,  245,
   245,   84,  302,  303,  304,  305,  306,   29,   63,   63,
    62,   62,  111,  111,  307,  307,  307,  307,  307,  307,
   307,  307,  307,  307,  307,  307,  307,  307,  307,   66,
    66,   68,   68,   68,  308,  308,  309,  310,  310,  311,
   311,  311,  311,  205,  205,  312,  312,  314,  112,  315,
   315,  316,  160,  313,  313,  317,  317,  318,  318,  318,
   318,  322,  322,  323,  323,  323,  320,  320,  320,  320,
   320,  320,  320,  320,  320,  320,  320,  320,  320,  324,
   324,  324,  324,  324,  324,  324,  324,  324,  324,  324,
   324,  324,  338,  338,  338,  338,  325,  339,  321,  340,
   340,  341,  341,  341,  341,  341,  341,  209,  209,  342,
   344,  319,  347,  319,  343,  343,  343,  345,  345,  350,
   350,  351,  351,  346,  346,  348,  348,  352,  352,  353,
   349,  349,  349,  326,  326,  337,  337,  354,  355,  355,
   327,  327,  356,  356,  359,  357,  358,  358,  360,  360,
   360,  363,  361,  362,  362,  364,  364,  328,  328,  328,
   328,  365,  366,  370,  367,  369,  369,  371,  371,  375,
   374,  374,  372,  372,  373,  373,  377,  376,  376,  368,
   378,  368,  329,  329,  329,  329,  329,  329,  379,  380,
   381,  381,  381,  382,  383,  384,  384,  385,  385,  330,
   330,  330,  330,  386,  386,  388,  388,  387,  389,  387,
   387,  331,  332,  390,  335,  333,  392,  393,  336,  394,
   395,  334,  334,  391,  391,  301,  301,  301,  301,  396,
   396,  398,  398,  400,  399,  401,  399,  397,  397,  397,
   405,  403,  406,  407,  403,  402,  402,  408,  408,  409,
   409,  409,  409,  409,  414,  410,  415,  411,  416,  417,
   418,  412,  420,  421,  422,  412,  419,  419,  424,  413,
   423,  427,  423,  426,  429,  426,  425,  425,  425,  428,
   428,  428,  404,  430,  404,    4,    4,  431,    4,  433,
     4,  432,  432,  432,  432,  246,  246,  241,  241,
   };
    static  short [] yyLen = {           2,
     2,    3,    2,    1,    0,    3,    0,    1,    1,    2,
     1,    1,    1,    1,    2,    4,    2,    1,    2,    1,
     1,    5,    2,    3,    0,    6,    1,    3,    1,    0,
     1,    0,    1,    1,    0,    6,    0,    1,    0,    1,
     0,    1,    1,    2,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    0,    1,    1,    2,    5,    4,    2,
     1,    1,    1,    1,    1,    3,    0,    3,    1,    0,
     3,    0,    1,    1,    3,    3,    1,    1,    0,    4,
     4,    0,    1,    1,    0,    1,    1,    2,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    0,
     0,    0,    0,   13,    5,    0,    4,    0,    1,    1,
     2,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    0,    9,    0,    1,    1,    2,    3,    0,    3,
     1,    1,    1,    0,    8,    0,    9,    6,    0,    0,
     3,    0,    1,    1,    2,    2,    0,    5,    0,    1,
     1,    2,    3,    0,    4,    2,    1,    1,    1,    0,
     3,    0,    0,   10,    0,    0,   11,    8,    1,    1,
     0,    1,    1,    3,    3,    3,    5,    3,    5,    1,
     1,    1,    1,    3,    4,    6,    4,    0,    7,    0,
     1,    1,    2,    1,    1,    1,    4,    6,    4,    1,
     2,    2,    1,    0,    0,    0,   10,    0,    0,    0,
    13,    1,    2,    1,    2,    1,    0,    5,    0,    5,
     1,    1,    1,    0,    0,    0,    0,   15,    5,    0,
     1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    0,    5,    1,    1,    1,    1,    0,    7,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    0,    7,    0,    7,    2,    2,    2,
     0,    0,    9,    1,    1,    0,    1,    0,    6,    0,
     6,    1,    0,    8,    0,    9,    0,    0,   10,    0,
     0,    3,    0,    1,    1,    2,    2,    0,    5,    0,
     2,    2,    2,    1,    1,    1,    0,    5,    0,    5,
     1,    1,    0,    0,    0,   12,    0,    2,    2,    0,
     1,    2,    1,    3,    2,    0,    5,    0,    0,    0,
    13,    0,    1,    1,    3,    1,    4,    2,    0,    3,
     2,    1,    3,    0,    3,    1,    1,    3,    1,    2,
     3,    4,    4,    0,    3,    1,    3,    3,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
     2,    2,    2,    2,    2,    1,    3,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    2,    2,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    3,    3,    4,    4,
     4,    3,    3,    4,    3,    4,    4,    0,    1,    3,
     4,    0,    1,    1,    3,    2,    3,    1,    2,    3,
     2,    1,    1,    0,    1,    1,    3,    3,    2,    2,
     1,    1,    1,    1,    2,    2,    4,    3,    1,    4,
     1,    3,    2,    1,    3,    1,    1,    1,    4,    3,
     2,    2,    6,    3,    7,    4,    3,    7,    3,    0,
     2,    4,    1,    2,    0,    1,    1,    3,    3,    1,
     1,    1,    0,    1,    1,    2,    2,    3,    1,    2,
     0,    1,    2,    4,    1,    3,    0,    5,    1,    1,
     1,    2,    3,    3,    4,    4,    1,    2,    4,    4,
     4,    3,    0,    4,    0,    1,    0,    4,    4,    1,
     2,    2,    1,    4,    1,    2,    2,    2,    2,    2,
     2,    1,    3,    3,    3,    1,    3,    3,    3,    3,
     3,    1,    3,    3,    1,    3,    3,    3,    3,    1,
     3,    3,    1,    3,    1,    3,    1,    3,    1,    3,
     1,    3,    1,    3,    1,    5,    3,    3,    3,    3,
     3,    3,    3,    3,    3,    3,    3,    1,    3,    3,
     2,    1,    0,    1,    1,    1,    0,    2,    1,    1,
     0,    4,    0,    0,    7,    1,    1,    1,    1,    1,
     1,    1,    1,    0,    0,    0,    0,   15,    0,    1,
     0,    1,    1,    2,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    0,
     2,    0,    1,    1,    1,    2,    4,    1,    3,    1,
     3,    1,    1,    0,    1,    1,    1,    0,    4,    1,
     1,    0,    4,    0,    1,    1,    2,    1,    1,    1,
     1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
     1,    1,    1,    1,    1,    1,    1,    0,    4,    1,
     2,    2,    2,    2,    2,    2,    1,    1,    2,    1,
     0,    6,    0,    7,    0,    2,    1,    0,    1,    1,
     2,    2,    4,    0,    2,    0,    1,    1,    2,    4,
     1,    5,    2,    2,    2,    2,    2,    1,    1,    1,
     1,    1,    5,    7,    0,    8,    0,    1,    1,    2,
     1,    0,    3,    1,    2,    3,    1,    1,    1,    1,
     1,    5,    7,    0,    4,    7,    1,    0,    1,    0,
     5,    1,    0,    1,    0,    1,    1,    1,    3,    6,
     0,    9,    1,    1,    1,    1,    1,    1,    2,    2,
     3,    4,    3,    3,    3,    4,    3,    0,    1,    3,
     4,    5,    3,    1,    2,    0,    1,    2,    0,    7,
     3,    2,    2,    0,    3,    5,    0,    0,   10,    0,
     0,   10,    5,    0,    2,    2,    2,    2,    2,    4,
     5,    4,    5,    0,    5,    0,    6,    3,    2,    1,
     0,    3,    0,    0,    6,    0,    1,    1,    2,    1,
     1,    1,    1,    1,    0,    5,    0,    3,    0,    0,
     0,   12,    0,    0,    0,   13,    0,    2,    0,    3,
     1,    0,    4,    1,    0,    4,    1,    2,    2,    1,
     2,    2,    0,    0,    4,    2,    3,    0,    4,    0,
     3,    1,    2,    1,    0,    0,    1,    1,    1,
   };
    static  short [] yyDefRed = {            0,
    47,    8,    0,    0,    0,    0,  920,    0,    0,    0,
     4,    0,    5,    9,   11,   12,   13,   20,   21,   46,
     0,   45,   48,   49,   50,   51,   52,    0,   56,   23,
     0,    0,    0,  344,    0,  346,   17,    0,   64,   62,
    63,    0,    0,    0,    0,    0,   65,   67,  916,    0,
     0,   18,    0,    1,    0,   10,    3,    0,  650,  656,
   648,    0,  645,  655,  649,  647,  646,  653,  651,  652,
   658,  654,  657,  659,    0,    0,  643,   57,    0,  538,
     0,  348,    0,   24,    0,    0,    0,    0,    0,    0,
    60,    0,  770,    0,  392,    0,  398,  405,    0,    0,
     0,  393,    0,    0,    0,  395,  432,    0,  394,    0,
     0,    0,    0,  401,    0,  403,    0,  430,  390,    0,
   397,  399,    0,  391,    0,  488,    0,  431,    0,  527,
   402,  404,    0,  844,  400,    0,    0,    0,  631,    0,
     0,  678,    0,  727,    0,    0,    0,    0,    0,    0,
     0,    0,  429,    0,  623,    0,  769,  710,    0,    0,
   396,    0,    0,  407,  408,    0,  410,  411,  412,  413,
   414,  415,  416,  417,  418,  419,  420,  421,  422,  423,
   424,  427,  428,  627,  555,    0,  553,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  628,  626,
   629,  630,  694,  696,    0,  692,  695,  711,  713,  714,
   715,  716,  717,  718,  719,  720,  721,  722,  712,    0,
     0,    0,  771,  772,  788,  789,  790,  791,  813,  814,
   815,  816,  817,  818,    0,    0,    0,  924,  921,  927,
    19,  917,    2,    6,   29,   27,    0,    0,    0,  640,
     0,  644,    0,  351,    0,    0,  352,  373,    0,    0,
     0,    0,  345,   16,    0,   66,   59,    0,   68,    0,
     0,    0,  819,  433,  434,  842,    0,    0,    0,    0,
     0,  409,    0,  820,    0,  547,  543,  546,  726,  768,
   697,  724,  723,  725,  698,  699,  700,  701,  702,  703,
   704,  705,  706,  707,  708,  709,    0,    0,    0,  794,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  829,    0,  406,    0,    0,    0,    0,
     0,    0,  843,    0,    0,    0,  740,  736,    0,    0,
     0,    0,    0,    0,    0,    0,  552,  556,  557,  551,
   561,  560,  558,  559,    0,    0,  621,  728,  426,  425,
     0,    0,    0,  343,    0,  734,  735,    0,  491,  492,
     0,    0,    0,  732,  733,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  919,
   693,  741,  731,  766,  767,  870,  887,    0,    0,    0,
   899,  858,  856,  880,    0,    0,  878,  881,  882,  883,
   884,  859,  857,  923,    0,    0,    0,    0,  370,  372,
   354,    0,  634,    0,    0,   22,  385,  381,  382,    0,
   350,  380,  383,  384,  347,   58,    0,    0,   73,   74,
    77,   78,  490,    0,    0,  486,  487,    0,  484,    0,
   743,    0,    0,    0,    0,  764,  765,    0,    0,    0,
   632,    0,  823,  821,  633,    0,    0,  512,    0,    0,
     0,  503,    0,  507,  517,  519,    0,    0,  497,  499,
     0,    0,    0,    0,    0,  494,    0,  501,  375,  516,
   824,    0,    0,  825,  833,    0,    0,    0,  834,    0,
     0,  845,    0,    0,  739,    0,    0,    0,    0,    0,
   691,    0,    0,  686,  688,  689,  690,  437,  438,  827,
     0,    0,    0,  195,  194,  196,    0,    0,    0,    0,
   377,    0,  608,    0,    0,  442,    0,  445,    0,  443,
   542,    0,    0,    0,    0,    0,  471,  474,    0,    0,
   466,  473,  472,  562,    0,  597,  598,  599,  600,  601,
   602,  603,  604,  605,  607,  606,  563,  565,  564,  570,
   571,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  594,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  871,  873,  869,    0,
   879,   28,   35,    0,    0,    0,    0,  323,    0,  229,
     0,  105,    0,  353,    0,   79,   71,    0,  441,  489,
     0,  540,    0,  549,  182,  203,    0,    0,    0,  172,
     0,    0,    0,  183,  544,    0,  847,  797,    0,  808,
   795,    0,  799,    0,    0,    0,  822,    0,    0,    0,
   502,    0,  518,  520,  159,  523,  157,  158,  525,    0,
     0,    0,  458,    0,    0,  454,    0,    0,  481,    0,
   522,  496,    0,  539,    0,  838,    0,  831,    0,  835,
   531,    0,    0,    0,  529,    0,    0,  541,    0,  850,
     0,  862,    0,  860,    0,  680,  681,  679,  687,  826,
   616,  622,  615,    0,  729,  611,    0,    0,    0,  554,
   446,  440,  444,  439,  480,  479,  476,  475,    0,  470,
   435,  436,  447,    0,    0,  747,    0,    0,  888,  864,
     0,  889,    0,  885,    0,  900,    0,    0,    0,    0,
   868,    0,   31,   26,  338,    0,  355,  329,  328,    0,
   635,  225,  101,   84,   83,    0,    0,   75,   76,  485,
     0,    0,    0,    0,    0,  192,    0,  548,    0,    0,
     0,    0,    0,  800,    0,    0,    0,    0,    0,  846,
   509,  508,    0,    0,  461,    0,    0,  928,  929,  450,
   456,    0,  459,    0,  483,    0,    0,    0,  775,  841,
     0,  832,  537,  532,    0,    0,  528,    0,  853,    0,
   792,  863,  861,  620,  619,  618,  610,  609,  624,  478,
     0,  468,  467,  596,    0,  761,  746,    0,    0,    0,
   750,    0,  866,    0,  893,    0,  908,  909,  902,  872,
   874,  914,   14,    0,    0,    0,  369,    0,    0,  366,
   324,    0,    0,    0,   81,   80,  755,  132,  133,    0,
     0,    0,  758,  201,  202,    0,  193,    0,    0,    0,
   175,  184,  176,  178,    0,    0,    0,    0,  804,    0,
   809,  810,    0,    0,  526,  524,  460,  462,  463,  457,
   451,  455,    0,  514,    0,  482,  493,  449,    0,  837,
     0,    0,  533,    0,    0,    0,  477,    0,    0,  742,
   751,  865,    0,    0,    0,  886,    0,    0,    0,   15,
     0,    0,    0,  677,  676,    0,  675,    0,  365,    0,
     0,    0,    0,    0,    0,  744,  759,  187,    0,  199,
     0,    0,    0,  793,  855,    0,    0,    0,  811,  774,
   498,  495,  781,    0,  787,    0,    0,  779,    0,  784,
   839,  536,  535,    0,  625,    0,    0,  867,  890,    0,
     0,    0,  904,    0,  915,   43,    0,    0,  339,  368,
   367,    0,  325,    0,  333,  389,  388,    0,  386,  664,
     0,  636,    0,  665,  226,  102,    0,    0,  188,    0,
   179,  177,  848,  801,    0,    0,  806,    0,    0,  776,
   780,    0,  785,    0,  851,    0,  753,    0,  894,  911,
   912,  905,  875,   36,   44,    0,    0,    0,    0,    0,
     0,    0,  666,    0,    0,  760,  186,    0,  198,    0,
     0,  812,  786,    0,  682,  840,    0,  762,    0,    0,
     0,  340,    0,    0,  334,  387,    0,    0,    0,  106,
   103,  189,  849,  796,    0,  852,  891,    0,  906,    0,
     0,  326,  672,    0,  673,  670,    0,  668,   99,    0,
    98,    0,    0,   87,   89,   90,   91,   92,   93,   94,
    95,   96,   97,  160,    0,    0,  242,  234,  235,  236,
   237,  238,  239,  240,  241,    0,    0,  232,    0,    0,
     0,    0,  895,  341,  337,    0,    0,    0,  637,   88,
     0,  285,  280,  284,    0,  227,  233,  120,  112,  113,
   114,  115,  116,  117,  118,  119,  121,    0,    0,  110,
   104,  683,    0,    0,  671,  669,    0,    0,    0,    0,
     0,    0,    0,  293,    0,    0,  243,    0,    0,  251,
     0,  170,  161,  169,    0,  107,  111,    0,  892,    0,
     0,    0,  279,    0,    0,  278,    0,    0,    0,    0,
   359,    0,  357,    0,    0,  204,    0,    0,    0,    0,
     0,  638,  228,  898,  896,  122,    0,  356,    0,    0,
     0,    0,  136,    0,    0,    0,    0,    0,    0,  162,
     0,    0,  208,    0,  360,    0,  246,  245,  244,  257,
   256,  253,  258,  259,  252,  271,  270,  263,  264,  260,
   262,  261,  265,  254,  255,  266,  267,  273,  272,  268,
   269,    0,    0,  297,    0,  276,  138,    0,  274,  165,
     0,    0,  140,    0,  361,    0,    0,  205,    0,    0,
     0,  358,  249,  131,  129,    0,    0,  301,    0,    0,
     0,    0,    0,    0,    0,  282,    0,    0,    0,    0,
   144,    0,    0,    0,    0,  362,  363,    0,    0,    0,
     0,    0,  126,  316,    0,  298,    0,    0,  310,    0,
     0,    0,  305,    0,  156,    0,    0,    0,    0,  151,
     0,    0,  294,    0,  141,    0,  135,  145,  163,  168,
   216,    0,  206,    0,    0,    0,    0,  130,    0,  123,
   127,    0,    0,    0,  312,    0,  313,  302,    0,    0,
   296,  306,  277,    0,    0,  137,  152,  275,  166,  292,
     0,  283,  287,  147,    0,    0,    0,  213,  215,  209,
   250,  128,  317,  319,  299,    0,    0,  311,  308,  155,
   153,    0,    0,    0,    0,  164,  217,  219,  207,    0,
     0,    0,  310,  167,  288,  290,  148,    0,    0,  210,
   321,  322,  318,  320,  309,    0,    0,  223,  222,  221,
   218,  220,    0,    0,    0,  211,  289,  291,
   };
   protected static  short [] yyDgoto  = {             9,
    10,   11,   12,   13,   58,   14,   15,   16,   17,  864,
    53,   18,   19,  256,   33,   20,  647,  247,  624,  436,
  1411,   90,  865,  762,  942,  997,  998,   22,   23,   24,
    25,   26,   27,  648,   29,   44,   45,   46,   47,   48,
   269,   92,  458,  459,  460,  290,  568,  777,  776, 1102,
  1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112,
  1113,   75,  251, 1203,  633,  952,  874, 1012, 1081, 1055,
  1130, 1158, 1129, 1159, 1160, 1007, 1286, 1263, 1311, 1312,
  1313,  877, 1309,  878,  678, 1176, 1274, 1228, 1299,  508,
  1292, 1268, 1328,  846, 1297, 1300, 1301, 1395, 1329, 1330,
  1326, 1114, 1183, 1141, 1204,  649, 1276, 1375, 1294, 1392,
    76,  291,  650,  651,  652,  653,  654,  784,  549, 1058,
   785,  550,  787, 1206, 1232, 1343, 1304, 1377, 1207, 1279,
  1400, 1423, 1344, 1345, 1421, 1408, 1409,  631,  873, 1054,
  1126, 1185, 1127, 1128, 1177, 1239, 1210, 1178,  258, 1262,
  1308, 1180, 1293, 1290, 1115, 1143, 1200, 1372, 1334, 1066,
  1373,  569, 1416, 1417, 1199, 1289, 1265, 1321, 1316, 1287,
  1353, 1358, 1319, 1322, 1323, 1403, 1359, 1317, 1318, 1413,
  1401, 1402,  628,  770, 1003,  950, 1048, 1004, 1005, 1073,
   866, 1046, 1090,  448,   34,  159,   82,   36,  259,  767,
   626, 1220,  869,  870,  946,  440,  260,  319,  447,  325,
  1008, 1009,  161,  162,  326,  164,  165,  166,  167,  168,
   169,  170,  171,  172,  173,  174,  175,  176,  177,  178,
   179,  180,  181,  182,  183,  277,  743,  917,  506,  684,
   810,  685,  686,  910,  184,  242,  690,  570,  571,  572,
   573,  737,  468,  469,  320,  915,  692,  321,  491,  492,
   493,  494,  322,  497,  680,  332,  706,  707,  824,  287,
   474,  288,  473,  185,  186,  187,  188,  189,  190,  191,
   192,  193,  194,  195,  196,  197,  198,  199,  200,  552,
   553,  554,  722,  723,  836,  724,  201,  542,  361,  926,
   202,  486,  629,  872, 1052, 1181,   77, 1013, 1014, 1097,
  1098,  947,  532,  345,  718, 1085,  533,  534,  292,  293,
   294,  205,  206,  207,  295,  296,  297,  298,  299,  300,
   301,  302,  303,  304,  305,  306,  219,  307,  543,  220,
   221,  339,  748,  609,  849,  782,  643,  881,  847,  850,
   851,  882,  883,  308,  222,  223,  224,  976,  919,  977,
   978,  979, 1032,  980,  225,  226,  227,  228,  661,  479,
   662,  900, 1025,  663,  898,  664, 1027, 1028,  229,  230,
   231,  232,  233,  234,  327,  518,  519,  921, 1034,  335,
   897,  793, 1060,  830, 1067,  235,  423,  236,  424,  852,
   933,  425,  620,  761,  758,  759,  938,  426,  427,  428,
   429,  430,  431,  856,  610,  854, 1038, 1132, 1189,  935,
  1070, 1164,  756,  616,  757,  992,  937,  993, 1071,  939,
    50,  239,   51,
   };
   protected static  short [] yySindex = {         -105,
     0,    0, -211, -200, -208,   37,    0,   30,    0,   96,
     0,  131,    0,    0,    0,    0,    0,    0,    0,    0,
 11915,    0,    0,    0,    0,    0,    0,   63,    0,    0,
   336,   54,  130,    0,   94,    0,    0,  169,    0,    0,
     0,  339,   54,  177,  235,   93,    0,    0,    0, 6023,
   112,    0, -248,    0,  131,    0,    0,  131,    0,    0,
     0, -197,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,   90, 9038,    0,    0,  177,    0,
   959,    0,  281,    0,  209,  340,  339,  235,  177,  382,
     0,  404,    0,  306,    0,  413,    0,    0,  208,10545,
   488,    0, -245,  527, 6176,    0,    0, -245,    0, -245,
  -245, -102, -245,    0, -245,    0, -210,    0,    0, 9672,
     0,    0, -245,    0, -245,    0, 9672,    0,  509,    0,
     0,    0,  208,    0,    0, -245,  519, -245,    0, 6805,
  7264,    0, 9672,    0,10332,10332,10332,10332,10332,10332,
 10332,10332,    0, -139,    0, 7417,    0,    0,  494,  352,
     0,  391, -219,    0,    0,  544,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  781,    0,  694,   66,  260,
   539,  489,  568,  540,  572,  586, -250,  633,    0,    0,
     0,    0,    0,    0, 2339,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  621,
   688,  -32,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0, -203, -174,  112,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  689, 7570,  647,    0,
  -156,    0,  467,    0,  519,  394,    0,    0,   99,  688,
  -219,  209,    0,    0,  705,    0,    0, 9804,    0,  830,
   677, 9936,    0,    0,    0,    0, 9672, -245, -245,  100,
   391,    0,  684,    0, 7417,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  768,  173,10545,    0,
  7417, 9672,  739,  759, 9672, 9672, 7971,  398,  780,   44,
 11061,  688,  236,    0,  793,    0,  802, 7417, 9672,  806,
   436, -245,    0, 9672,  509, 9144,    0,    0,  519, 9672,
  -205,  782,  -29,  790, 6329, -251,    0,    0,    0,    0,
     0,    0,    0,    0,  839, 9672,    0,    0,    0,    0,
 10990,  850,  209,    0,  493,    0,    0,  501,    0,    0,
   811, 9936, 8880,    0,    0,10332, 9672, 9672, 9672, 9672,
  9672, 9672, 9672, 9672, 9672, 9672, 9672,10332,10332,10332,
  7417, 7417,10332,10332,10332,10332,10332,10332,10332,10332,
 10332,10332,10332,10332,10332,10332,10332,10332, 9672,    0,
     0,    0,    0,    0,    0,    0,    0,11115,11132,  823,
     0,    0,    0,    0,    6,  771,    0,    0,    0,    0,
     0,    0,    0,    0,  826,  860,  519,  647,    0,    0,
     0,  868,    0,  985,  988,    0,    0,    0,    0, 7417,
     0,    0,    0,    0,    0,    0,  317,  590,    0,    0,
     0,    0,    0,  209,  297,    0,    0,  435,    0,  878,
     0,  880, -152,  509, -245,    0,    0,  841, 7094, -229,
     0,  881,    0,    0,    0,  884,  888,    0,  469,    0,
   893,    0,  890,    0,    0,    0,  445, 6788,    0,    0,
  7817,  487, 9672,  780, 8880,    0,  519,    0,    0,    0,
     0,  894,  896,    0,    0,  208,  509,  384,    0, 3051,
   897,    0,  898,  854,    0,  902, 9672,  964, 9672,  977,
     0,   13, 6329,    0,    0,    0,    0,    0,    0,    0,
   904,  509, 6329,    0,    0,    0,  519,  339,  865,11186,
     0,  912,    0,  906,10332,    0,  -25,    0,  377,    0,
     0,  648, 9672, 9672,  917, 1029,    0,    0,  -46,  916,
     0,    0,    0,    0,  694,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  694,  694,   66,   66,  260,  260,  260,  260,  539,
   539,  489,  568,  540,  572,  586,    0,  920, -190, 9672,
    17,  873,   32,  883,  915, 9672,    0,    0,    0,  938,
     0,    0,    0,  923,  931,  889, 3206,    0,  647,    0,
   647,    0,  647,    0,   74,    0,    0, 9804,    0,    0,
  9936,    0,  922,    0,    0,    0,  565,   63,  933,    0,
   932,  934,  936,    0,    0, 9672,    0,    0,  895,    0,
     0,  935,    0,  940, 9672, 1009,    0, 6176, 6176, 7247,
     0, 7971,    0,    0,    0,    0,    0,    0,    0,  942,
  9276,  321,    0,   25, -170,    0,  891,  901,    0,  -22,
     0,    0,  945,    0,  951,    0, 3361,    0,  509,    0,
     0,  365,  495,  903,    0,  948,  939,    0, 6176,    0,
  6176,    0, 9672,    0, 9672,    0,    0,    0,    0,    0,
     0,    0,    0, 7400,    0,    0,  907,10990,  979,    0,
     0,    0,    0,    0,    0,    0,    0,    0, 8748,    0,
     0,    0,    0, 9012, 9672,    0, 6941,  953,    0,    0,
  1032,    0, 1033,    0,  -34,    0,  958, 9672, 9672,  918,
     0,  971,    0,    0,    0, -128,    0,    0,    0,  967,
     0,    0,    0,    0,    0, 9672, 9672,    0,    0,    0,
  9408,  961,  565,11186,  464,    0, 7417,    0,  244, 1077,
  1078,  968,  960,    0, 9672, 9672,  970, 9672, 1055,    0,
     0,    0, 7247,  975,    0, -145, 9540,    0,    0,    0,
     0, 7685,    0, 1084,    0,  688, 9672,  978,    0,    0,
   928,    0,    0,    0,  929,  120,    0,  930,    0,  960,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   676,    0,    0,    0,11061,    0,    0,  937,  976,  953,
     0, 9672,    0, 9672,    0, 9672,    0,    0,    0,    0,
     0,    0,    0,  971,   30, -152,    0,  515,  226,    0,
     0,  981,  981,  981,    0,    0,    0,    0,    0,  941,
   986,  961,    0,    0,    0, -187,    0, -186,  980,  989,
     0,    0,    0,    0,  990, 7247,  953, -190,    0,  994,
     0,    0,  992, 6176,    0,    0,    0,    0,    0,    0,
     0,    0,  983,    0,  780,    0,    0,    0, -192,    0,
   993,  120,    0,  954,  953,  509,    0,  955,  995,    0,
     0,    0, 9672, 1023, 9672,    0, 9672, 1024,  303,    0,
    30, -125, 1008,    0,    0,  963,    0, -128,    0,   63,
  3516, -162, -162, -162, 1001,    0,    0,    0,  505,    0,
  1002, 1124, 1125,    0,    0, 1014,  953, 9672,    0,    0,
     0,    0,    0, 9672,    0, 1019, -155,    0, -155,    0,
     0,    0,    0, 1017,    0, 9672, 6941,    0,    0, 1039,
   641, 1018,    0, 9672,    0,    0, 1025, -125,    0,    0,
     0,  973,    0, 1020,    0,    0,    0, 1022,    0,    0,
   982,    0, 1052,    0,    0,    0, 9408, 1027,    0, 9672,
     0,    0,    0,    0, 1026,  940,    0, 6176, 1028,    0,
     0, 6329,    0, 1035,    0, 1034,    0, 9672,    0,    0,
     0,    0,    0,    0,    0, -162,    0, 1031,   63, 3516,
  1036, 1040,    0, 1041, 1042,    0,    0, 9672,    0, 6176,
  6176,    0,    0, 6329,    0,    0, 6176,    0, 1054, 9672,
  9672,    0, 1053,  923,    0,    0,11044,   35,   63,    0,
     0,    0,    0,    0, 6329,    0,    0, 1058,    0, 1059,
  9672,    0,    0, 1045,    0,    0, 1038,    0,    0, 9038,
     0, 1049,   35,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  601, 9038,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1068,   63,    0,   63,  923,
  1069, 9672,    0,    0,    0, 1066,11044,10763,    0,    0,
   631,    0,    0,    0,10795,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0, 1071,   63,    0,
     0,    0, 1080, 9672,    0,    0, 7417, 7417, -121,11061,
   -87,  519, 1100,    0,  339, 6967,    0, 1133,    0,    0,
   923,    0,    0,    0,  923,    0,    0, 1030,    0, 1080,
  1037, 1043,    0, 7417, -181,    0, 7417, 1043, 1044, 1072,
     0,  339,    0, 1074,  481,    0, 1081, 1046,  -19,  634,
 10294,    0,    0,    0,    0,    0,  339,    0, 1079, 1050,
  1082, 1073,    0, 1085, 1086, 1087, -152, 1070, 1090,    0,
  1088, 1093,    0,  209,    0,  602,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0, 1096, -179,    0, 1089,    0,    0, 1083,    0,    0,
  1097, 1099,    0, 1098,    0, -152, -152,    0, -152, 1105,
  1108,    0,    0,    0,    0, 1116,   48,    0, 1117, -152,
  1232, 1119, -152, -152,  631,    0, 7247, 1092, 1126, 1098,
     0, 1123, 1131,   57, 1136,    0,    0, -152, 9408, 1101,
  1138, 1116,    0,    0, 9038,    0,   63,   63,    0, 1102,
  1139, 1117,    0, 1135,    0, 9672, 1103, 1140, 1119,    0,
  1145, 1146,    0, -163,    0, 1141,    0,    0,    0,    0,
     0, 9038,    0,   57,   57, 1157, 1158,    0, -179,    0,
     0,  313, 1161, 9038,    0, 9038,    0,    0, 7247, 1151,
     0,    0,    0, 1175, 1083,    0,    0,    0,    0,    0,
    85,    0,    0,    0, -162,  766, 1179,    0,    0,    0,
     0,    0,    0,    0,    0, 1229, 1284,    0,    0,    0,
     0, -162, 1181, 1184, 7247,    0,    0,    0,    0,   57,
   637,  637,    0,    0,    0,    0,    0,  -54,  -54,    0,
     0,    0,    0,    0,    0, 8880, 8880,    0,    0,    0,
     0,    0, 1188, 1185, 1186,    0,    0,    0,
   };
   protected static  short [] yyRindex = {         1956,
     0,    0,    0,    0,    0, 6482,    0,    0,    0, 1956,
     0, 1555,    0,    0,    0,    0,    0,    0,    0,    0,
   663,    0,    0,    0,    0,    0,    0, 1450,    0,    0,
   658, 1187,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  685,  609,    0, 1190,    0,    0,    0,    0,    0,
  1844,    0,   42,    0, 1555,    0,    0, 1555,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  443,10477,    0,    0,    0,    0,
     0,    0,    0,    0, 2178,    0, 3822, 1190, 1191,    0,
     0,  679,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, 1195,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,11203,    0,    0, 1189,
     0,    0,    0,    0,    0,    0, 1189,    0,    0,    0,
     0,    0,    0,    0,    0,    0,   -8,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, 5700,    0,    0,    0,    0,    0,  247,
     0, 3670, 5753,    0,    0, 3515,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 4004,    0, 4068, 4354, 4546,
  4920, 5112, 5240, 5368, 5496,  479, 3757, 3634,    0,    0,
     0,    0,    0,    0,   42,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  1148,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  797,  797, 1913,    0,    0,    0,
     0,    0,    0,    0,    0,    0, 1200,    0,    0,    0,
     0,    0,    0,    0, 3901, 2439,    0,    0,    0, 2816,
  2439, 2178,    0,    0,    0,    0,    0,  735,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0, 2660,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0, 1201,    0,    0,    0,
     0, 2019, 2660,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0, 2581,    0,
   212,    0,  212,    0,   27,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1189,    0,    0,    0,    0,
  1196,    0, 2660,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  146,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,   24,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,   -9,    0,    0,    0,
     0, 1203,    0, 1153, 1156,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0, 7951,    0,    0,    0,
     0,    0,    0, 2660, 5867,    0,    0,    0,    0,    0,
     0,    0,10845,    0,    0,    0,    0,    0, 1199,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  693,  725,
     0,    0, 1209,    0,    0,    0,    0,    0,    0,    0,
   137,    0,    0, 3205, 1206,    0,  188,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0, 1205,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  139,    0,    0,    0,    0,    0,    0,    0,
     0, 7553,    0,    0,    0,    0, -173,  498,    0,    0,
     0, 1207,    0,    0,    0,    0, 2660,    0, 2660,    0,
     0,    0,    0,    0, -256,    0,    0,    0,    0,  205,
     0,    0,    0,    0, 4147,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0, 4211, 4290, 4418, 4482, 4610, 4674, 4738, 4802, 4984,
  5048, 5176, 5304, 5432, 5560, 5624,    0,    0,  750,    0,
   212,    0,  212,    0,    0,    0,    0,    0,    0, 5688,
     0,    0,    0, 1354,    0,  264,    0,    0,    0,    0,
     0,    0,    0,    0,10068,    0,    0,    0,    0,    0,
     0,    0,  762,    0,    0,    0,11257, 8116,    0,    0,
   783,  795,  809,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, 1210,    0,    0,    0,    0,    0,    0,
     0, 1219,    0,    0,    0,    0,    0,    0,    0, 1220,
     0, 4839,    0,    0,  142,    0,    2, 2895,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  545,  702,    0,    0,    0, 1218,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, -244,    0,    0,    0, 1216,    0,    0,
     0,    0,    0,    0,  197,    0,  182,    0,    0,    0,
     0,11380,    0,    0,    0, -169,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0, 1217,11274,    0,11328,    0,    0,    0,10958,    0,
     0,    0,  769,    0, 1223,    0,    0,    0, 1590,    0,
     0,    0, 1227,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 3050,    0, 3360,    0,    0,
  1224,    0,    0,    0,    0,  545,    0,    0,    0,  769,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  696,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,11451,11522,10845,    0, 1182,    0,    0,
     0,  123,  123,  123,    0,    0,    0,    0,    0,    0,
     0, 1225,    0,    0,    0,    0,    0,    0,  825,  829,
     0,    0,    0,    0,    0,    0, 1230,  750,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0, 3205,    0,    0,    0, 1235,    0,
     0,  545,    0,  853, 1230, 7553,    0,  668,  715,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  133,    0,
 11593,11717,    0,    0,    0,    0,    0, -169,    0, -268,
     0, 1237, 1237, 1237,    0,    0,    0,    0,  772,    0,
   824,    0,    0,    0,    0,    0, 1216, 1233,    0,    0,
     0,    0,    0,    0,    0,    0, 1238,    0, 6635,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   333,  547,    0,    0,    0,    0,    0,11786,    0,    0,
     0,    0,    0, 1239,    0,    0,    0,  141,    0,    0,
     0,    0,  639,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1236,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1234,  610,    0,   11,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, -206,    0,    0,    0,    0,    0,    0,
     0,    0,    0, 1754,    0,    0,    0, 8225, 8521,    0,
     0,    0,    0,    0, 1241,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  318,    0,    0,10613,
     0,    0, 8299,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,10695,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0, 8595,    0, 8373, 1754,
     0,    0,    0,    0,    0,    0,    0,  443,    0,    0,
     0,    0,    0,    0,  443,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0, 8447,    0,
     0,    0,  584,    0,    0,    0,    0,    0,    0,    0,
     0,  645,  458,    0, 8639,    0,    0,    0, 2786,    0,
  1754,    0,    0,    0, 1754,    0,    0,    0,    0,  584,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  662,    0, 1245,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  787,    0,  591,    0,
     0,    0,    0,    0,    0,    0,10845,  837,    0,    0,
     0,    0,    0, 1240,    0,  730,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  838,    0,    0,    0,    0,    0,
     0,    0,    0, 1242,    0,10845,10845,    0,10885,    0,
     0,    0,    0,    0,    0, 1244,11875,    0, 1250,10845,
 10200, 1252,10845,10845,    0,    0,    0,    0,    0, 1253,
     0,    0,    0, 8669,    0,    0,    0,10845,    0,    0,
     0, 1255,    0,    0,  329,    0,11845, 8906,    0,    0,
     0, 1256,    0,    0,    0,    0,    0,    0, 1258,    0,
     0,    0,    0,  644,    0,  844,    0,    0,    0,    0,
     0,  867,    0, 5879, 8774,    0,    0,    0,    0,    0,
     0,    0,    0, 1297,    0, 1350,    0,    0,    0,  847,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  652,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  652,    0,    0,    0,    0,    0,    0,    0, 8669,
 11652, 7843,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0, 1206, 1206,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,
   };
   protected static  short [] yyGindex = {            0,
  1566,  608,   58,    0,    0,   40, -681,    4, -355,    0,
   767,    0,    0,   19,    0,    0,    1,    0,    0,    0,
  -601,  -70,    0,    0,    0,    0,    0, -514,    0,    0,
     0,    0,    0,   39,  -11,    0, 1589,    0, 1545,    0,
     0,    0,    0,  998,  999,  -48, -239,    0,    0,    0,
     0,  536, -605, -587, -497, -440, -386, -343, -305, -285,
  -735,-1049,    0, -215,    0,  357,    0, -917,    0,    0,
     0,    0,    0,    0,  482,  -49,  291,    0,    0,    0,
   330, -982,    0, -296, -316, 1395,    0,    0,    0, -807,
   279,    0,    0, -484,    0,    0,  345,    0,    0,  319,
     0,    0,  351,    0, -207, -781,    0,    0,    0,    0,
   471,  -45,    0,    0,  863,  864,  869,    0, -509,    0,
     0, -576,  866,  462,    0, -826,    0,    0,    0,    0,
     0,    0,    0,    0,  248,    0,    0,    0,    0,    0,
     0,    0,    0,  532,    0,    0,    0,    0, -240,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  552,
     0, -495,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  257,    0,    0,  346,    0,    0,  344,  353,  267,
     0,    0,    0,    0,    0,    0,    0,    0,  623,    0,
     0,    0,    0,  230,    0,   75,  -81,    0,    0,  437,
     0,  500,    0,  726,    0, 1159, -312, -202, -117,  656,
     0,  628,    0,  -74,    5,    0,    0,   45,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0, -290,    0,  136,    0,    0, -138,    0,
     0,    0,  870,    0, -461, -180, 1000,  944,    0,  947,
     0, 1121, 1308, 1056,    0,    0,  778,    0,    0,    0,
     0, 1057,    0,    0,    0,    0,    0,    0, -479,    0,
     0,    0,    0,    0, 1021,    0,  444,  840,  803,  831,
  1283, 1290, 1293, 1289, 1292,    0, 1294,    0,    0,    0,
   972,    0,  775,    0,    0,    0,    0,    0,    0,    0,
     0, -310,    0,    0,    0,    0,  -76,    0,  690,    0,
   567,    0,  620,    0,    0,    0,  678, -512,  -44, -332,
   -43,    0, 1503,    0,   47,    0,   49,   50,   52,   65,
    73,   80,   82,   84,   92,   98,    0, -608,    0,  -53,
     0,    0,  816,    0, -309,    0,    0,    0,  722,    0,
   871,    0,  833, -451,    0,    0,    0,    0,    0,    0,
   747,    0,    0,  746,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  758,    0,    0,    0,    0,
     0,    0,    0,    0,  -83,    0, 1212,    0,    0,    0,
   905,    0,    0,    0,    0,    0, -221,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0, 1302,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  542,    0,
     0,    0,    0,    0,    0,    0,    0,  665,    0,    0,
     0,    0,    0,
   };
   protected static  short [] yyTable = {           252,
    21,  157,  499,  263,  158,  203,  204,  439,  509,  693,
    21,   52,  536,  679,  433,  482,   78,  265,  413,  338,
   719,   32,  764,   43,  410,  281,  490,  660,  462,  526,
   725,  257,  467,  442, 1056, 1015, 1016,  928,   28,  687,
   727,  926,  367,  330,   30,  375,  283,   39,   28,   56,
  1138,   21,  416,  276,  163,   37,  241,  452,  245,  799,
   800,  783,   43,  973,  665,  746, 1145,   55,  958,  960,
   786,  324,  360,   40, 1222,  974, 1284,   35,  324,   35,
   863,  416,  378,  331,  943,  811,    3,  333,  527,   28,
   342,  344, 1370, 1010,  346,  330,  208,  253,  209,  210,
   829,  211,  831,  645,  163,   41,  362,   43,  238,  163,
   815,  631,  974,  631,  212,  443,  538,  504,   35,  510,
   551,  274,  213,  469,   54,  469,  355,  867, 1072,  214,
     1,  215,  467,  216, 1193,  417,   54,  364,  449,  444,
   418,  217,  419,  454,  282,   54,  407,  218,  420,  421,
     1,    2,  317,   35,  318,   35,  157,  783,  408,  158,
   203,  204,  337,   35,  417,  312,  445,  631, 1196,  418,
   275,  419,  539,  313,  356,  240, 1011,  420,  421,  469,
   455,   80,  940, 1194,  666,  801,  747,  691,  646,  282,
   282,  282,  282,  282,  282,  282,  282, 1285,  360,  812,
   536, 1418,   31,  357,   81,   42,  884, 1371,  887,  163,
   536,  783,    5,   38,   35,   35,  246, 1197,  907,  461,
   422,  525,  625,  466,  817,  975,  959,  961,  470,    3,
    35,  358, 1223,  815,  281,  472,    5,   21,  285,    5,
   378,  360,  281,  309,   54,  310,  311,   80,  315,  432,
   316,  208,    4,  209,  210,  478,  211,  926,  328,    5,
   329,  480,  975,  481,  529, 1352,  485,  487,  334,  212,
    81,  336,  541,  340,  886,   28,   56,  213,  512,  439,
   513,  556,  524,  359,  214,  521,  215,  523,  216,  522,
  1099,  485, 1376,   49,  434,  970,  217,  373,  926,  500,
   535,  537,  218, 1314, 1386, 1235, 1387,  324,  142,  551,
   750,  314, 1341,  163,    6,    7,    8, 1419,  905,  857,
   858,  741,   35,  466,  567,  752, 1348,  391,  576,  577,
   578,  579,  580,  581,  582,  583,  584,  585,  586,  414,
   163,  590,  591,  816,  901,  792,  923,  817, 1393,  163,
   687,    1,    2,  282,  617,  618,  737,   80,  371,   35,
   608,  282, 1195,  392,    3,  926,  248,    1,  612,  614,
   249,  926,  877,  877,  332,  360,  716,  742,  660,  774,
    81,  490,  639,  360,   81,   35,  775,    2,  808,  366,
   684,  415,  374, 1157, 1236,   35,  661,  731,  462,    5,
   634,  467,   35,   80,  371,  737,  501,  360,  502, 1394,
   274,  965,    5,  771,  334,  772,  373,  773,   80, 1062,
   282,    5,   83, 1157,   54,  659,   81,    5,  655,  619,
     3,  250,  282,  282,  282,   35,  717,  282,  282,  393,
   394,   81,  982,  376,  983, 1272,    3,  877,  809,  677,
   684, 1083, 1084,    4,  689,  505,  567, 1396, 1086,  275,
     5,  660,  503,   91,  879,   35,   35,  520,  450,    4,
   696,  698, 1092, 1118, 1404,  732,    5,  734,  712,  661,
   714,  876,  876,  163,  899,  660,   80,  551,  535,  537,
   453, 1119,   35,   35, 1302, 1303,  721, 1305,  535,  537,
   452,   84,  685,  661,  842,  453,  813,   85, 1324,   81,
   451, 1331, 1332,  464,  736,  736,  660, 1378, 1379,  364,
   901, 1118,  359, 1149,   35,  901, 1347,  901, 1161,   81,
   901,  901,  509,  901,  901,  907,  823,  163,  703, 1119,
   907, 1150,  907,  551,  476,  907,  907,  163,  907,  907,
   376,  719,  376, 1149,  376,  376,  876,  376,  416,  376,
   452,  749,  685, 1101, 1117,  453,  907,  755,  349,  464,
   142, 1150,  465, 1410,  274, 1383,  349,  769,  357, 1212,
   349, 1120,   86, 1213,  889,  449,  996,  966, 1101,  461,
    87,  641,  466,  349,  704,  948,  477,  281,  691,  282,
   360,  376,  364,  376,   89,  901,  376,  485,    5,  804,
   656,  342, 1117,  914, 1148,  984,  797,   54,   81,   57,
   907,  677,   80,  275,   35,  349,  364, 1384,  465, 1120,
   364, 1151,  689,  364,  364,  364,   78,  949, 1121,  357,
   364,  417, 1045,  641, 1148,   81,  418,  821,  419,  395,
   396,  697,  516,  822,  420,  421,  667, 1024,  359,  357,
   342, 1151,  243,  357,  832,  244,  833,  635,  909,  699,
   270,  910,  163,  163,  271,  835,  910, 1029,  910,  918,
   667,  910,  910,   80,  910,  910, 1121,  635, 1152,  667,
   567,  515, 1122,  636,  262,  567,  844,  807,  677,  536,
   879,   35,  910,   80,  516,  160,   81,   80,  364,  860,
   861,  264,   79,  163,  639,  163,  282,  995, 1152,  359,
   365,  517,   80, 1059,  272,   80,   81,  875,  876,  640,
    81,  536,  481,  337,  591, 1123,  261,  888,  639,  359,
  1122,   59, 1153,  359,  263,   81,  485,  267,   81,  903,
   364,   80,  536,  640,  677,  160,  910,  274,  908,  368,
   160, 1082,   83,  495,   60,  639,  868,  496,  916,  544,
   268,   35, 1153, 1124,   81,  337,  545,   61,  369,  370,
   640,  823,   63, 1123,  273, 1154,   81,   64,  546,   65,
    66,   67,   68, 1125, 1135,  261,  261,   69,  371,  733,
   640,   70,   35,  932,  641,  934,  275,  936,  944,  372,
   673,  261, 1335,   71,  674, 1154,   72,  591,   73,  575,
   945, 1124,  591, 1155,  591,  591,  591,  591,  591,  591,
   591,  591,  591,  591,  591,   83,  592,  593,  446,   74,
   455, 1125,  591, 1156,  591,  670,  591,  677,  591,  591,
   591,  364,  688, 1155,  349,   80,  496,  509,   35,  284,
   160,   35,  349,  825,  591,  612,  349,  612,   52, 1018,
   544,  142,  783, 1156, 1388,  591,  337,  545,   81,  349,
   721, 1019,  401,  402,  988,  903,  990,  591,  991,  546,
   903,  359,  903,  286, 1217,  903,  903, 1179,  903,  903,
   337,  349,  591,  261, 1179,  371,  557,  363,  163,  349,
  1407,  349,  349,  349,  559,  558,  397,  398,  376,   35,
  1424, 1425,  897,  560,  404,  481,  349,  897,  371,  897,
   399,  400,  897,  897,  641,  897,  897, 1036,  677,  641,
   261,  371,   21,  641,  241, 1043,  371,  403,  868,  248,
  1002,  371,  405,  371,  371,  371,  371,  637,  641,  638,
   295,  371,  295, 1065,  160,  371,  261,  295,  481,  371,
   903,  481, 1142,  335,   69,   69,  261,  371,   69,  335,
   371,  406,  371,  261, 1218,  641,  336,  535,  537, 1069,
  1225,  160,  879,  142, 1040, 1041,  142, 1231,   21,  142,
   160,  663, 1182,  371,  641, 1237,  286,  897,  763,  481,
   663,   81,  766,  735,  662,  286,  261,  641,  409,  535,
   537, 1088,  991,  662,  354,   35,  349, 1096,  354,  349,
   349,  134,  163,  134,  412,  763,  163,  763,  134,  763,
   535,  537,  481,  927,   70,  744,  261,  261,   70, 1002,
   349,  349,  318,  349,  349,   61,  510,  435,  371,  349,
   441,  349,  510,  749,  163,  163,  342,  749,  163,  342,
   456,  163,  354,  261,  261,  388,  389,  390, 1100, 1116,
   349,  349,  752, 1163,  752,  463,  752, 1096,  511,  163,
   464,  427,  364,  427,  511, 1184,  364,  471,  349,  364,
   349,  364,   72, 1100,   72,  261,  364,  475,  349,  417,
   483,  349,  427,  427,  418, 1190,  419, 1191, 1192,  745,
  1229,  745,  420,  421,   35, 1397, 1398, 1116,  252, 1100,
   484,  754,  427,  754,  160, 1229,  854,  185,  854,  185,
   427,  185,  498,  427, 1221,  876,  876, 1224,  173,  354,
   173,   35, 1280,  354, 1281,  349,  354,  377,  354, 1100,
   180,  365,  180,  354, 1238,  347,  348,  349,  350,  351,
   352,  353,  354,  511,  181,  261,  181,  514,  378,  379,
   380,  381,  382,  383,  384,  385,  386,  387,  160,  197,
   203,  197,  203,  197,  174,  528,  174,  354,  160,  596,
   597,  598,  599,  530,  830,  261,  139,  300,  139,  300,
   540,   35,   35,  146,  254,  146,  307,  555,  307,   35,
   534,  534,  623,   95,  561,   97,  641,  641,   98,  953,
   954,  600,  601,  102,  594,  595,  615,  106,  627,  622,
   630,   35,   35,  632,   35,  642,  109,  644,  677, 1184,
  1208,  668,  667,  114,  657,  669,  671,  713,  116,  672,
   481,  694,  119,  695,  708,  709, 1208,  710,   35,  711,
   715,   35, 1208,  729,  121,  720,  122, 1364,  726, 1208,
   124,  728,  261,  739,  740,  744,  751, 1315,  131,  132,
   745,  754,  135,  760,  763,  255,  753,  765,  781,  766,
   788,  789,  798,  790, 1342,  791,  795,  828,  794,  796,
   677,  803,  818,  819,  240,  827,  826, 1354, 1356,  814,
   837,  839,  848,  160,  160,  853,  855,  859,    4,  871,
   880,  862,  893,  894,  904,  895,  896,  902,  906,  913,
   501,  920,  922,  924, 1342, 1342,  677,  930,  971,  962,
   929,  951,  261,   30,  955, 1412, 1412,  956,  963,  969,
   981,  964, 1420, 1420,  160,  968,  160,  567,  567,  989,
   823,  987,   87,  986,  994,  999, 1000, 1017, 1020, 1021,
  1022, 1023, 1030,  261, 1035, 1039, 1047, 1042, 1044, 1049,
  1011, 1050, 1057, 1061, 1074, 1051,  574, 1065, 1063, 1068,
  1342, 1087, 1078, 1079, 1080, 1133, 1077, 1137,  587,  588,
   589, 1136, 1139,  574,  574,  574,  574,  574,  574,  574,
   574,  574,  574,  574,  574,  574,  574,  574,  574, 1091,
  1134, 1146, 1162, 1165, 1186, 1188, 1198, 1211, 1227,  261,
  1230, 1264,  261, 1214, 1267, 1233, 1273, 1291, 1266,   53,
  1216, 1269, 1270, 1271, 1277, 1278, 1217, 1226, 1275, 1234,
   830,  830, 1283, 1236, 1295, 1288, 1296, 1298,  830,  830,
   830,  830,  830, 1306,  830,  830, 1307,  830,  830,  830,
   830,  830,  830,  830,  830, 1310, 1320, 1325, 1327,  830,
  1339,  830,  830,  830,  830,  830,  830, 1337, 1340,  830,
   261, 1346, 1363,  830,  830, 1336,  830,  830,  830, 1350,
  1361, 1366, 1368, 1369, 1349, 1360, 1365, 1374,  830, 1380,
   830,  574,  830,  830, 1385, 1381,  830, 1389,  830,  830,
   830,  830,  830,  830,  830,  830,  830,  830,  830,  830,
  1390,  830, 1399, 1384,  830,  830, 1383, 1405,  830,  830,
  1406, 1426, 1427, 1428,    7,   32,   33,  545,   34,  160,
   828,  730,   25,  613,  505,  327,  224,  830,  830,  100,
   798,  830,  506,  464,  614,  730,  830,  830,  830,  830,
   830,  802,  504,   32,  830,  530,  830,  748,  756,  773,
    33,  836,  830,  830,  803,  674,  757,  748,  777,  662,
   805,  778,  331,  807,  684,  662,  261,  356,  349,   30,
    30,  641,  641,  142,   30,  124,  237,  830,  830,  830,
   830,  303,  830,  149,  143,   30,  125,  304,  830,  150,
    30,  941,   88,  266,   30,  778,  779,   30, 1140, 1382,
  1187, 1351,  438, 1391, 1338, 1333, 1205, 1367,  885,   30,
    30,  890,  891, 1219,   30,   30, 1422,  892, 1147, 1415,
    30, 1357,   30,   30,   30,   30, 1144, 1362, 1414, 1355,
    30, 1075, 1282, 1001,   30, 1209,   30, 1076,  705,  562,
   806,  912,  841,  160,  738,  602,   30,  160,   30,   30,
   843,   30,  972,  603,  605,   30,  780,  604,  606,  838,
   985,  607, 1053, 1166, 1131,  261,   53,  411, 1037, 1064,
    55,   30,   30,  967,  957,  160,  160,   30,   30,  160,
   931,   55,  160, 1031, 1033, 1026,   55,  621,  802,  700,
    55, 1215,  261,   55,  925, 1089,    0,    0,    0,    0,
   160,    0,    0,    0,    0,   55,   55,    0,    0,    0,
    55,   55,    0,   30,    0,    0,   55,    0,   55,   55,
    55,   55,    0,    0,    0,    0,   55,    0,    0,    0,
    55,    0,   55,    0,    0,    0,    0,    0,    0,    0,
     0,    0,   55,    0,    0,   55,    0,   55,    0,    0,
     0,   55,  261,  261,    0,    0,    0,    0,    0,    0,
   261,    0,    0,    0,    0,    0,    0,    0,   55,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  261,  261,    0,  261,    0,    0,    0,    0,
     0,    0,  574,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  925,    0,  773,  773,    0,    0,  261,
     0,    0,  261,  773,  773,  773,  773,  773,    0,  773,
   773,    0,  773,  773,  773,  773,  773,  773,  773,    0,
     0,    0,    0,    0,  773,    0,  773,  773,  773,  773,
   773,  773,    0,    0,  773,    0,    0,    0,  773,  773,
     0,  773,  773,  773,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  773,    0,  773,    0,  773,  773,    0,
     0,  773,  922,  773,  773,  773,  773,  773,  773,  773,
   773,  773,  773,  773,  773,    0,  773,    0,    0,  773,
   773,    0,    0,  773,  773,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  773,  773,    0,    7,  773,    0,    0,    0,
     0,  773,  773,  773,  773,  773,    0,    0,    0,  773,
     0,  773,    0,    0,    0,    0,    0,  773,  773,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  773,  773,  773,  773,    0,  773,    0,   30,
    30,    0,    0,  773,   30,    0,    0,    0,   30,    0,
    30,    0,    0,   30,    0,   30,   30,    0,   30,    0,
    30,    0,   30,    0,   30,   30,   30,   30,    0,    0,
    30,   30,    0,    0,    0,    0,   30,    0,   30,   30,
    30,    0,    0,   30,   30,   30,    0,   30,    0,    0,
    30,    0,   30,   30,   30,   30,    0,    0,    0,   30,
    30,   30,    0,    0,   30,   30,   30,    0,    0,    0,
     0,    0,    0,   30,   30,    0,   30,   30,   30,   30,
    30,   30,    0,    0,    0,   30,    0,    0,    0,    0,
   925,    0,    0,    0,   54,    0,    0,    0,    0,    0,
     0,   30,   30,    0,    0,   54,    0,   30,   30,    0,
    54,    0,    0,    0,   54,    0,   30,   54,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,   54,
    54,    0,    0,    0,   54,   54,    0,    0,    0,    0,
    54,    0,   54,   54,   54,   54,    0,    0,    0,    0,
    54,    0,    0,    0,   54,    0,   54,   30,    0,  922,
     0,    0,    0,   54,    0,    0,   54,    0,    0,   54,
     0,   54,    0,    0,   54,   54,    0,    0,    0,   54,
     0,    0,    0,   54,    0,    0,   54,    0,    0,    0,
     0,    0,   54,    0,    0,    0,    0,    0,   54,   54,
     0,    0,    0,   54,   54,    0,   54,    0,    0,   54,
     0,   54,   54,   54,   54,    0,    0,   54,    0,   54,
     0,    0,   54,   54,    0,   54,   54,    0,    0,   54,
     0,    0,    0,    0,    0,   54,    0,    0,   54,    0,
    54,   54,   54,    0,   54,    0,   54,   54,    0,    0,
     0,    0,   54,    0,   54,   54,   54,   54,    0,    0,
     0,   54,   54,    0,  515,    0,   54,    0,   54,  515,
   515,    0,    0,    0,    0,    0,    0,    0,   54,    0,
     0,   54,    0,   54,    0,    0,    0,   54,    0,    0,
     0,    0,  515,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  515,    0,   54,  515,  515,    0,    0,    0,
   515,    0,    0,  515,    0,  515,    0,  515,  515,  515,
   515,    0,    0,    0,    0,  515,    0,    0,    0,  515,
     0,    0,    0,  515,    0,    0,    0,    0,    0,    0,
     0,  515,    0,    0,  515,    0,  515,  515,    0,    0,
     0,    0,  515,    0,  515,  515,  515,  515,  515,  515,
   515,  515,  515,  515,  515,    0,    0,  515,    0,    0,
     0,  515,  515,    0,  515,  515,  515,  515,  515,  515,
   515,    0,  515,  515,    0,  515,  515,  515,  515,  515,
   515,  515,  515,  515,  515,    0,  515,  515,  515,  515,
   515,  515,  515,  515,  515,  515,  515,  515,  515,  515,
   515,  515,  515,  515,  515,  515,  515,  515,    0,    0,
   515,    0,  515,  349,  515,    0,    0,  515,  349,  349,
     0,    0,  515,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  349,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  349,    0,    0,  349,  349,    0,    0,    0,  349,
     0,    0,  349,    0,  349,    0,  349,  349,  349,  349,
     0,    0,    0,    0,  349,    0,    0,    0,  349,    0,
     0,    0,  349,    0,    0,    0,    0,    0,    0,    0,
   349,    0,    0,  349,    0,  349,  349,    0,    0,    0,
     0,  349,    0,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,    0,  349,    0,    0,    0,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
     0,  349,  349,    0,    0,  349,  349,  349,  349,  349,
     0,    0,  349,  349,    0,    0,    0,  349,  349,  349,
   349,  349,  349,  349,  349,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  349,    0,    0,  349,
     0,  349,    0,  349,   93,    0,  349,    0,    0,    0,
     0,  349,   94,   95,   96,   97,    0,    0,   98,   99,
     0,  100,  101,  102,  103,  104,  105,  106,    0,    0,
     0,    0,    0,  107,    0,  108,  109,  110,  111,  112,
   113,    0,    0,  114,    0,    0,    0,  115,  116,    0,
   117,  118,  119,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  120,    0,  121,    0,  122,  123,    0,    0,
   124,    0,  125,  126,  127,  128,  129,  130,  131,  132,
   133,  134,  135,  136,    0,  137,    0,    0,  138,  139,
     0,    0,  140,  141,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  342,    0,    0,    0,    0,  342,
   342,  142,    0,    0,    0,  143,    0,    0,    0,    0,
   144,  145,  146,  147,  148,    0,    0,    0,  149,    0,
   150,    0,  342,    0,    0,    0,  151,  152,    0,    0,
     0,    0,  342,    0,    0,  342,  342,    0,    0,    0,
   342,    0,    0,  342,    0,  342,    0,  342,  342,  342,
   342,  153,  154,  155,  156,  342,    0,    0,    0,  342,
     0,    0,  240,  342,    0,    0,    0,    0,    0,    0,
     0,  342,    0,    0,  342,    0,  342,  342,    0,    0,
     0,    0,  342,    0,  342,  342,  342,  342,  342,  342,
   342,  342,  342,  342,  342,    0,    0,  342,    0,    0,
     0,  342,  342,  342,  342,  342,  342,    0,  342,  342,
   342,    0,  342,  342,    0,    0,  342,  342,  342,  342,
     0,    0,    0,  342,  342,    0,    0,    0,  342,  342,
   342,  342,  342,  342,  342,  342,  738,    0,    0,    0,
     0,  738,  738,    0,    0,    0,    0,  342,    0,    0,
   342,    0,  342,    0,  342,    0,    0,  342,    0,    0,
     0,    0,  342,    0,  738,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  738,    0,    0,  738,  738,    0,
     0,    0,  738,    0,    0,  738,    0,  738,    0,  738,
   738,  738,  738,    0,    0,    0,    0,  738,    0,    0,
     0,  738,    0,    0,    0,  738,    0,    0,    0,    0,
     0,    0,    0,  738,    0,  349,  738,    0,  738,  738,
     0,  349,    0,    0,  738,    0,  738,  738,  738,  738,
   738,  738,  738,  738,  738,  738,  738,    0,    0,  738,
     0,    0,    0,  738,  738,  738,  738,  738,  738,    0,
   738,  738,  738,    0,  738,  738,    0,  349,  738,  738,
   738,  738,    0,    0,    0,  738,  738,    0,    0,    0,
   738,  738,  738,  738,  738,  738,  738,  738,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  738,
     0,    0,  738,    0,  738,    0,  738,    0,  349,  738,
     0,    0,    0,  349,  738,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,    0,    0,    0,
     0,    0,    0,  349,  349,  349,  349,  349,  349,  349,
   349,  349,    0,  349,  349,    0,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  370,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  370,
     0,  379,    0,  349,    0,  349,  379,  379,  349,    0,
     0,    0,  370,  349,    0,    0,    0,  370,    0,    0,
   247,    0,  370,    0,  370,  370,  370,  370,    0,  379,
     0,    0,  370,    0,    0,    0,  370,    0,    0,  379,
   370,    0,  379,  379,    0,    0,    0,  379,  370,    0,
   379,  370,  379,  370,  379,  379,  379,  379,    0,    0,
     0,    0,  379,    0,    0,    0,  379,    0,    0,    0,
   379,    0,    0,    0,  370,    0,    0,    0,  379,    0,
   517,  379,    0,  379,  379,    0,  517,    0,    0,  379,
     0,  379,  379,  379,  379,  379,  379,  379,  379,  379,
   379,  379,    0,    0,  379,    0,    0,    0,  379,  379,
     0,  379,  379,  379,    0,  379,  379,  379,    0,  379,
   379,    0,  517,  379,  379,  379,  379,    0,    0,  370,
   379,  379,    0,    0,    0,  379,  379,  379,  379,  379,
   379,  379,  379,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  379,    0,    0,  379,    0,  379,
     0,    0,    0,  517,    0,    0,    0,    0,  517,  379,
   517,  517,  517,  517,  517,  517,  517,  517,  517,  517,
   517,    0,    0,    0,    0,    0,    0,  517,  517,  517,
   517,  517,  517,  517,  517,  517,  517,    0,  517,  517,
     0,  517,  517,  517,  517,  517,  517,  517,  517,  517,
   517,    0,  517,  517,  517,  517,  517,  517,  517,  517,
   517,  517,  517,  517,  517,  517,  517,  517,  517,  517,
   517,  517,  517,  517,    0,  513,  701,    0,    0,    0,
   517,  513,    0,    0,    0,   95,    0,   97,  517,    0,
    98,    0,    0,    0,    0,  102,    0,    0,    0,  106,
     0,    0,    0,    0,    0,    0,    0,    0,  109,    0,
     0,    0,    0,    0,    0,  114,    0,  513,    0,    0,
   116,    0,    0,    0,  119,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  121,    0,  122,    0,
     0,    0,  124,    0,    0,    0,    0,    0,    0,    0,
   131,  132,    0,    0,  135,    0,    0,  437,  513,    0,
     0,    0,    0,  513,    0,  513,  513,  513,  513,  513,
   513,  513,  513,  513,  513,  513,    0,    0,    0,    0,
     0,    0,  513,  513,    0,  513,  513,  513,  513,  513,
   513,  513,    0,  513,  513,    0,  513,  513,  513,  513,
   513,  513,  513,  513,  513,  513,    0,  513,  513,  513,
   513,  513,  513,  513,  513,  513,  513,  513,  513,  513,
   513,  513,  513,  513,  513,  513,  513,  513,  513,    0,
   521,  768,    0,    0,  702,  513,  521,    0,  513,    0,
    95,    0,   97,  513,    0,   98,    0,    0,    0,    0,
   102,    0,    0,    0,  106,    0,    0,    0,    0,    0,
     0,    0,    0,  109,    0,    0,    0,    0,    0,    0,
   114,    0,  521,    0,    0,  116,    0,    0,    0,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  121,    0,  122,    0,    0,    0,  124,    0,    0,
     0,    0,    0,    0,    0,  131,  132,    0,    0,  135,
     0,    0,  255,  521,    0,    0,    0,    0,  521,    0,
   521,  521,  521,  521,  521,  521,  521,  521,  521,  521,
   521,    0,    0,    0,    0,    0,    0,    0,  521,    0,
   521,  521,  521,  521,  521,  521,  521,    0,  521,  521,
     0,  521,  521,  521,  521,  521,  521,  521,  521,  521,
   521,    0,  521,  521,  521,  521,  521,  521,  521,  521,
   521,  521,  521,  521,  521,  521,  521,  521,  521,  521,
   521,  521,  521,  521,    0,  448,  820,    0,    0,   87,
   521,  448,    0,  521,    0,   95,    0,   97,  521,    0,
    98,    0,    0,    0,    0,  102,    0,    0,    0,  106,
     0,    0,    0,    0,    0,    0,    0,    0,  109,    0,
     0,    0,    0,    0,    0,  114,    0,  448,    0,    0,
   116,    0,    0,    0,  119,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  121,    0,  122,    0,
     0,    0,  124,    0,    0,    0,    0,    0,    0,    0,
   131,  132,    0,    0,  135,    0,    0,  255,  448,    0,
     0,    0,    0,  448,    0,  448,  448,  448,  448,  448,
   448,  448,  448,  448,  448,  448,    0,    0,    0,    0,
     0,    0,    0,  448,    0,  448,  448,  448,  448,  448,
   448,  448,    0,  448,  448,    0,  448,  448,  448,  448,
   448,  448,  448,  448,  448,  448,    0,  448,  448,  448,
   448,  448,  448,  448,  448,  448,  448,  448,  448,  448,
   448,  448,  448,  448,  448,  448,  448,  448,  448,    0,
   409, 1006,    0,    0,   87,  448,  409,    0,  448,    0,
    95,    0,   97,  448,    0,   98,    0,    0,    0,    0,
   102,    0,    0,    0,  106,    0,    0,    0,    0,    0,
     0,    0,    0,  109,    0,    0,    0,    0,    0,    0,
   114,    0,  409,    0,    0,  116,    0,    0,    0,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  121,    0,  122,    0,    0,    0,  124,    0,    0,
     0,    0,    0,    0,    0,  131,  132,    0,    0,  135,
     0,    0,  255,  409,    0,    0,    0,    0,  409,    0,
   409,  409,  409,  409,  409,  409,  409,  409,  409,  409,
   409,    0,    0,    0,    0,    0,    0,    0,  409,    0,
   409,  409,  409,  409,  409,  409,  409,    0,  409,  595,
     0,  409,  409,  409,  409,  409,  409,  409,  409,  409,
   409,    0,  409,  409,  409,  409,  409,  409,  409,  409,
   409,  409,  409,  409,  409,  409,  409,  409,  409,  409,
   409,  409,  409,  409,    0,  550,    0,    0,    0,   87,
   409,  550,    0,  409,    0,    0,    0,    0,  409,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  550,    0,    0,
     0,    0,  595,    0,    0,    0,    0,  595,    0,  595,
   595,  595,  595,  595,  595,  595,  595,  595,  595,  595,
     0,    0,    0,    0,    0,    0,    0,  595,    0,  595,
     0,  595,    0,  595,  595,  595,    0,    0,  550,    0,
     0,    0,  593,  550,    0,  550,  550,  550,  550,  550,
   550,  550,  550,  550,  550,  550,    0,    0,    0,    0,
     0,    0,    0,  550,    0,  550,    0,  550,    0,  550,
   550,  550,    0,  550,  550,    0,  550,  550,  550,  550,
   550,  550,  550,  550,  550,  550,    0,  595,    0,  550,
   550,  550,  550,  550,  550,  550,  550,  550,  550,  550,
   550,  550,  550,  550,  550,  550,  550,  349,  550,    0,
     0,    0,    0,  349,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  550,    0,  593,    0,    0,    0,    0,
   593,    0,  593,  593,  593,  593,  593,  593,  593,  593,
   593,  593,  593,    0,    0,  349,    0,    0,    0,  349,
   593,    0,  593,    0,  593,    0,  593,  593,  593,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  593,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  374,    0,    0,    0,
   349,    0,  374,    0,    0,  349,    0,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,    0,
   593,    0,    0,    0,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  374,  349,  349,    0,  374,  349,
   349,  349,  349,  349,    0,    0,  349,  349,    0,    0,
     0,  349,  349,  349,  349,  349,  349,  349,  349,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   349,    0,    0,  349,    0,  349,    0,  349,    0,  374,
   349,    0,    0,    0,  374,  349,  374,  374,  374,  374,
   374,  374,  374,  374,  374,  374,  374,    0,    0,  562,
     0,    0,    0,  374,  374,  562,  374,  374,  374,    0,
   374,  374,  374,    0,  374,  374,    0,    0,  374,  374,
   374,  374,    0,    0,    0,  374,  374,    0,    0,    0,
   374,  374,  374,  374,  374,  374,  374,  374,    0,    0,
     0,  562,    0,    0,    0,    0,    0,    0,    0,  374,
     0,    0,  374,    0,  374,    0,    0,    0,    0,    0,
     0,    0,    0,  566,  374,    0,    0,    0,    0,  566,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  562,    0,    0,    0,    0,  562,    0,  562,
   562,  562,  562,  562,  562,  562,  562,  562,  562,  562,
     0,    0,    0,    0,    0,  566,    0,  562,    0,  562,
     0,  562,    0,  562,  562,  562,    0,  562,  562,    0,
     0,  562,  562,  562,  562,  562,  562,  562,  562,  562,
     0,    0,    0,  562,  562,  562,  562,  562,  562,  562,
   562,    0,  569,    0,    0,    0,  566,    0,  569,    0,
     0,  566,  562,  566,  566,  566,  566,  566,  566,  566,
   566,  566,  566,  566,    0,    0,    0,  562,    0,    0,
     0,  566,    0,  566,    0,  566,    0,  566,  566,  566,
     0,  566,  566,    0,  569,  566,  566,  566,  566,    0,
     0,    0,  566,  566,    0,    0,    0,  566,  566,  566,
   566,  566,  566,  566,  566,    0,  567,    0,    0,    0,
     0,    0,  567,    0,    0,    0,  566,    0,    0,    0,
     0,    0,    0,    0,    0,  569,    0,    0,    0,    0,
   569,  566,  569,  569,  569,  569,  569,  569,  569,  569,
   569,  569,  569,    0,    0,    0,    0,    0,  567,    0,
   569,    0,  569,    0,  569,    0,  569,  569,  569,    0,
   569,  569,    0,    0,  569,  569,  569,  569,    0,    0,
     0,  569,  569,    0,    0,    0,  569,  569,  569,  569,
   569,  569,  569,  569,    0,  568,    0,    0,    0,  567,
     0,  568,    0,    0,  567,  569,  567,  567,  567,  567,
   567,  567,  567,  567,  567,  567,  567,    0,    0,    0,
   569,    0,    0,    0,  567,    0,  567,    0,  567,    0,
   567,  567,  567,    0,  567,  567,    0,  568,  567,  567,
   567,  567,    0,    0,    0,  567,  567,    0,    0,    0,
   567,  567,  567,  567,  567,  567,  567,  567,    0,  572,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  567,
     0,    0,    0,    0,    0,    0,    0,    0,  568,    0,
     0,    0,    0,  568,  567,  568,  568,  568,  568,  568,
   568,  568,  568,  568,  568,  568,    0,    0,    0,    0,
     0,    0,    0,  568,    0,  568,    0,  568,    0,  568,
   568,  568,    0,  568,  568,    0,    0,  568,  568,  568,
   568,    0,    0,  573,  568,  568,    0,    0,    0,  568,
   568,  568,  568,  568,  568,  568,  568,    0,    0,    0,
     0,    0,  572,    0,    0,    0,    0,  572,  568,  572,
   572,  572,  572,  572,  572,  572,  572,  572,  572,  572,
     0,    0,    0,  568,    0,    0,    0,  572,    0,  572,
     0,  572,    0,  572,  572,  572,    0,    0,    0,    0,
     0,  572,  572,  572,  572,    0,    0,  574,  572,  572,
     0,    0,    0,  572,  572,  572,  572,  572,  572,  572,
   572,    0,    0,    0,    0,    0,  573,    0,    0,    0,
     0,  573,  572,  573,  573,  573,  573,  573,  573,  573,
   573,  573,  573,  573,    0,    0,    0,  572,    0,    0,
     0,  573,    0,  573,    0,  573,    0,  573,  573,  573,
     0,    0,    0,    0,    0,  573,  573,  573,  573,    0,
     0,  575,  573,  573,    0,    0,    0,  573,  573,  573,
   573,  573,  573,  573,  573,    0,    0,    0,    0,    0,
   574,    0,    0,    0,    0,  574,  573,  574,  574,  574,
   574,  574,  574,  574,  574,  574,  574,  574,    0,    0,
     0,  573,    0,    0,    0,  574,    0,  574,    0,  574,
     0,  574,  574,  574,    0,    0,    0,    0,    0,  574,
   574,  574,  574,    0,    0,  576,  574,  574,    0,    0,
     0,  574,  574,  574,  574,  574,  574,  574,  574,    0,
     0,    0,    0,    0,  575,    0,    0,    0,    0,  575,
   574,  575,  575,  575,  575,  575,  575,  575,  575,  575,
   575,  575,    0,    0,    0,  574,    0,    0,    0,  575,
     0,  575,    0,  575,    0,  575,  575,  575,    0,    0,
     0,    0,    0,  575,  575,  575,  575,    0,    0,  577,
   575,  575,    0,    0,    0,    0,    0,  575,  575,  575,
   575,  575,  575,    0,    0,    0,    0,    0,  576,    0,
     0,    0,    0,  576,  575,  576,  576,  576,  576,  576,
   576,  576,  576,  576,  576,  576,    0,    0,    0,  575,
     0,    0,    0,  576,    0,  576,    0,  576,    0,  576,
   576,  576,    0,    0,    0,    0,    0,  576,  576,  576,
   576,    0,    0,  578,  576,  576,    0,    0,    0,    0,
     0,  576,  576,  576,  576,  576,  576,    0,    0,    0,
     0,    0,  577,    0,    0,    0,    0,  577,  576,  577,
   577,  577,  577,  577,  577,  577,  577,  577,  577,  577,
     0,    0,    0,  576,    0,    0,    0,  577,    0,  577,
     0,  577,    0,  577,  577,  577,    0,    0,    0,    0,
     0,  577,  577,  577,  577,    0,    0,  579,  577,  577,
     0,    0,    0,    0,    0,  577,  577,  577,  577,  577,
   577,    0,    0,    0,    0,    0,  578,    0,    0,    0,
     0,  578,  577,  578,  578,  578,  578,  578,  578,  578,
   578,  578,  578,  578,  349,    0,    0,  577,    0,    0,
   349,  578,    0,  578,    0,  578,    0,  578,  578,  578,
     0,    0,    0,    0,    0,  578,  578,  578,  578,    0,
     0,    0,  578,  578,    0,    0,    0,    0,    0,  578,
   578,  578,  578,  578,  578,    0,  349,    0,    0,    0,
   579,    0,    0,    0,    0,  579,  578,  579,  579,  579,
   579,  579,  579,  579,  579,  579,  579,  579,    0,    0,
     0,  578,    0,    0,    0,  579,    0,  579,    0,  579,
     0,  579,  579,  579,    0,  580,    0,    0,    0,  579,
   579,  579,  579,    0,    0,    0,  579,  579,    0,    0,
     0,    0,    0,  579,  579,  579,  579,  579,  579,    0,
     0,    0,  349,    0,    0,  349,    0,  349,  349,    0,
   579,    0,  349,  349,    0,    0,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  579,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,    0,    0,    0,  581,
     0,    0,    0,    0,    0,    0,  349,  349,    0,    0,
     0,    0,    0,    0,  349,    0,    0,  349,  580,    0,
     0,    0,  349,  580,    0,  580,  580,  580,  580,  580,
   580,  580,  580,  580,  580,  580,    0,    0,    0,    0,
     0,    0,    0,  580,    0,  580,    0,  580,    0,  580,
   580,  580,    0,    0,    0,    0,    0,    0,    0,  580,
   580,    0,    0,  582,  580,  580,    0,    0,    0,    0,
     0,    0,    0,  580,  580,  580,  580,    0,    0,    0,
     0,    0,  581,    0,    0,    0,    0,  581,  580,  581,
   581,  581,  581,  581,  581,  581,  581,  581,  581,  581,
     0,    0,    0,  580,    0,    0,    0,  581,    0,  581,
     0,  581,    0,  581,  581,  581,    0,    0,    0,    0,
     0,    0,    0,  581,  581,    0,    0,  583,  581,  581,
     0,    0,    0,    0,    0,    0,    0,  581,  581,  581,
   581,    0,    0,    0,    0,    0,  582,    0,    0,    0,
     0,  582,  581,  582,  582,  582,  582,  582,  582,  582,
   582,  582,  582,  582,    0,    0,    0,  581,    0,    0,
     0,  582,    0,  582,    0,  582,    0,  582,  582,  582,
     0,    0,    0,    0,    0,    0,    0,  582,  582,    0,
     0,  584,  582,  582,    0,    0,    0,    0,    0,    0,
     0,  582,  582,  582,  582,    0,    0,    0,    0,    0,
   583,    0,    0,    0,    0,  583,  582,  583,  583,  583,
   583,  583,  583,  583,  583,  583,  583,  583,    0,    0,
     0,  582,    0,    0,    0,  583,    0,  583,    0,  583,
     0,  583,  583,  583,    0,    0,    0,    0,    0,    0,
     0,  583,  583,    0,    0,  585,  583,  583,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  583,  583,    0,
     0,    0,    0,    0,  584,    0,    0,    0,    0,  584,
   583,  584,  584,  584,  584,  584,  584,  584,  584,  584,
   584,  584,    0,    0,    0,  583,    0,    0,    0,  584,
     0,  584,    0,  584,    0,  584,  584,  584,    0,    0,
     0,    0,    0,    0,    0,  584,  584,    0,    0,  586,
   584,  584,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  584,  584,    0,    0,    0,    0,    0,  585,    0,
     0,    0,    0,  585,  584,  585,  585,  585,  585,  585,
   585,  585,  585,  585,  585,  585,    0,    0,    0,  584,
     0,    0,    0,  585,    0,  585,    0,  585,    0,  585,
   585,  585,    0,    0,    0,    0,    0,    0,    0,    0,
   585,    0,    0,  587,  585,  585,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  585,  585,    0,    0,    0,
     0,    0,  586,    0,    0,    0,    0,  586,  585,  586,
   586,  586,  586,  586,  586,  586,  586,  586,  586,  586,
     0,    0,    0,  585,    0,    0,    0,  586,    0,  586,
     0,  586,    0,  586,  586,  586,    0,    0,    0,    0,
     0,    0,    0,    0,  586,    0,    0,  588,  586,  586,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  586,
   586,    0,    0,    0,    0,    0,  587,    0,    0,    0,
     0,  587,  586,  587,  587,  587,  587,  587,  587,  587,
   587,  587,  587,  587,    0,    0,    0,  586,    0,    0,
     0,  587,    0,  587,    0,  587,    0,  587,  587,  587,
     0,    0,    0,    0,    0,    0,    0,    0,  587,    0,
     0,  589,    0,  587,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  587,  587,    0,    0,    0,    0,    0,
   588,    0,    0,    0,    0,  588,  587,  588,  588,  588,
   588,  588,  588,  588,  588,  588,  588,  588,    0,    0,
     0,  587,    0,    0,    0,  588,    0,  588,    0,  588,
     0,  588,  588,  588,    0,    0,    0,    0,    0,    0,
     0,    0,  588,    0,    0,  590,    0,  588,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  588,  588,    0,
     0,    0,    0,    0,  589,    0,    0,    0,    0,  589,
   588,  589,  589,  589,  589,  589,  589,  589,  589,  589,
   589,  589,    0,    0,    0,  588,    0,    0,    0,  589,
     0,  589,    0,  589,    0,  589,  589,  589,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  592,
     0,  589,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  589,  589,    0,    0,    0,    0,    0,  590,    0,
     0,    0,    0,  590,  589,  590,  590,  590,  590,  590,
   590,  590,  590,  590,  590,  590,    0,    0,    0,  589,
     0,    0,    0,  590,    0,  590,    0,  590,    0,  590,
   590,  590,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  913,    0,  590,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  590,  590,    0,    0,    0,
     0,  349,  592,    0,    0,    0,    0,  592,  590,  592,
   592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
     0,    0,    0,  590,    0,    0,    0,  592,    0,  592,
     0,  592,    0,  592,  592,  592,    0,  349,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  592,
     0,    0,    0,    0,  406,    0,    0,    0,    0,    0,
   592,    0,    0,    0,    0,    0,  913,    0,    0,    0,
     0,  913,  592,  913,  913,  913,  913,  913,  913,  913,
   913,  913,  913,    0,    0,    0,    0,  592,    0,    0,
   406,  913,    0,  913,    0,  913,  349,  913,  913,  913,
     0,    0,    0,    0,  349,    0,  349,    0,  349,    0,
     0,  349,    0,  349,  349,    0,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,    0,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,    0,
     0,  913,    0,  349,    0,  349,    0,  342,  349,  406,
   406,  406,  406,  349,  406,    0,  406,  406,  349,  406,
   406,  406,  406,  406,    0,  406,  406,  406,  406,   54,
   406,  406,  406,  406,  406,  406,  406,  406,  406,  406,
   406,  406,  406,  406,  406,  406,  406,  406,  406,  406,
   406,  406,   54,    0,  349,    0,  342,    0,  406,    0,
     0,  406,    0,    0,    0,   54,  406,    0,    0,    0,
    54,    0,    0,    0,    0,   54,    0,   54,   54,   54,
    54,    0,    0,    0,    0,   54,    0,    0,    0,   54,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,   54,    0,    0,   54,    0,   54,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  349,  349,  349,  349,  349,   54,   54,   54,
   349,  349,  212,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,    0,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,    0,    0,   93,    0,
     0,    0,  349,    0,    0,  349,   94,   95,   96,   97,
   349,    0,   98,   99,    0,  100,  101,  102,  103,  104,
   105,  106,    0,    0,    0,    0,    0,  107,    0,  108,
   109,  110,  111,  112,  113,    0,    0,  114,    0,    0,
     0,  115,  116,    0,  117,  118,  119,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  120,    0,  121,    0,
   122,  123,    0,    0,  124,    0,  125,  126,  127,  128,
   129,  130,  131,  132,  133,  134,  135,  136,    0,  137,
     0,    0,  138,  139,    0,    0,  140,  141,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  142,    0,    0,    0,  143,
     0,    0,    0,    0,  144,  145,  146,  147,  148,    0,
     0,    0,  149,    0,  150,    0,    0,    0,    0,    0,
   151,  152,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  289,    0,    0,    0,  153,  154,  155,  156,   94,
    95,   96,   97,    0,    0,   98,   99,    0,  100,  101,
   102,  103,  104,  105,  106,    0,    0,    0,    0,    0,
   107,    0,  108,  109,  110,  111,  112,  113,    0,    0,
   114,    0,    0,    0,  115,  116,    0,  117,  118,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  120,
     0,  121,    0,  122,  123,    0,    0,  124,    0,  125,
   126,  127,  128,  129,  130,  131,  132,  133,  134,  135,
   136,    0,  137,    0,    0,  138,  139,    0,    0,  140,
   141,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  142,    0,
     0,    0,  143,    0,    0,    0,    0,  144,  145,  146,
   147,  148,    0,    0,    0,  149,    0,  150,    0,    0,
     0,    0,    0,  151,  152,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  531,    0,    0,    0,  153,  154,
   155,  156,   94,   95,   96,   97,    0,    0,   98,   99,
     0,  100,  101,  102,  103,  104,  105,  106,    0,    0,
     0,    0,    0,  107,    0,  108,  109,  110,  111,  112,
   113,    0,    0,  114,    0,    0,    0,  115,  116,    0,
   117,  118,  119,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  120,    0,  121,    0,  122,  123,    0,    0,
   124,    0,  125,  126,  127,  128,  129,  130,  131,  132,
   133,  134,  135,  136,    0,  137,    0,    0,  138,  139,
     0,    0,  140,  141,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  142,    0,    0,    0,  143,    0,    0,    0,    0,
   144,  145,  146,  147,  148,    0,    0,    0,  149,    0,
   150,    0,    0,    0,    0,    0,  151,  152,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  918,    0,    0,
     0,  153,  154,  155,  156,  918,  918,  918,  918,    0,
     0,  918,  918,    0,  918,  918,  918,  918,  918,  918,
   918,    0,    0,    0,    0,    0,  918,    0,  918,  918,
   918,  918,  918,  918,    0,    0,  918,    0,    0,    0,
   918,  918,    0,  918,  918,  918,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  918,    0,  918,    0,  918,
   918,    0,    0,  918,    0,  918,  918,  918,  918,  918,
   918,  918,  918,  918,  918,  918,  918,    0,  918,    0,
     0,  918,  918,    0,    0,  918,  918,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,  918,    0,    0,    0,  918,    0,
     0,    0,    0,  918,  918,  918,  918,  918,    0,    0,
     0,  918,    0,  918,    0,    0,    0,    0,    0,  918,
   918,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   782,    0,    0,    0,  918,  918,  918,  918,  782,  782,
   782,  782,    0,    0,  782,  782,    0,  782,  782,  782,
   782,  782,  782,  782,    0,    0,    0,    0,    0,  782,
     0,  782,  782,  782,  782,  782,  782,    0,    0,  782,
     0,    0,    0,  782,  782,    0,  782,  782,  782,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  782,    0,
   782,    0,  782,  782,    0,    0,  782,    0,  782,  782,
   782,  782,  782,  782,  782,  782,  782,  782,  782,  782,
     0,  782,    0,    0,  782,  782,    0,    0,  782,  782,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  782,    0,    0,
     0,  782,    0,    0,    0,    0,  782,  782,  782,  782,
   782,    0,    0,    0,  782,    0,  782,    0,    0,    0,
     0,    0,  782,  782,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  675,    0,    0,    0,  782,  782,  782,
   782,   94,   95,    0,   97,    0,    0,   98,  278,    0,
     0,    0,  102,  103,  104,    0,  106,    0,    0,   95,
     0,   97,  107,    0,   98,  109,    0,    0,    0,  102,
     0,    0,  114,  106,    0,    0,    0,  116,    0,  117,
   118,  119,  109,    0,    0,    0,    0,    0,    0,  114,
     0,    0,    0,  121,  116,  122,  123,    0,  119,  124,
     0,    0,  126,    0,  128,    0,  130,  131,  132,  279,
   121,  135,  122,    0,    0,    0,  124,    0,  139,    0,
     0,  140,  141,    0,  131,  132,    0,    0,  135,    0,
     0,  255,    0,    0,    0,    0,    0,    0,    0,    0,
   498,  676,    0,    0,  143,    0,    0,    0,    0,    0,
   145,  146,  147,  148,    0,    0,    0,  149,    0,  150,
     0,    0,    0,    0,    0,  151,  152,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  675,    0,    0,    0,
   153,  323,  155,  156,   94,   95,    0,   97,    0,    0,
    98,  278,    0,    0,    0,  102,  103,  104,  341,  106,
     0,    0,    0,    0,    0,  107,    0,   59,  109,    0,
     0,    0,    0,    0,    0,  114,    0,    0,    0,    0,
   116,    0,  117,  118,  119,    0,    0,    0,    0,    0,
    60,    0,    0,    0,    0,    0,  121,    0,  122,  123,
   845,    0,  124,   61,    0,  126,    0,  128,   63,  130,
   131,  132,  279,   64,  135,   65,   66,   67,   68,    0,
     0,  139,    0,   69,  140,  141,    0,   70,    0,    0,
     0, 1201,    0,    0,    0,    0,    0,    0,    0,   71,
     0,    0,   72,  498,   73,    0,    0,  143,    0,    0,
     0,    0,    0,  145,  146,  147,  148,    0,    0,    0,
   149,    0,  150,    0,    0,   74,    0,    0,  151,  152,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  658,
     0,    0,    0,  153,  323,  155,  156,   94,   95,    0,
    97,    0,    0,   98,  278,    0,    0,    0,  102,  103,
   104,    0,  106,    0,    0,    0,    0,    0,  107,    0,
  1202,  109,    0,    0,    0,    0,    0,    0,  114,    0,
     0,    0,    0,  116,    0,  117,  118,  119,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  121,
     0,  122,  123,    0,    0,  124,    0,    0,  126,    0,
   128,    0,  130,  131,  132,  279,    0,  135,    0,    0,
   137,    0,    0,    0,  139,    0,    0,  140,  141,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   143,    0,    0,    0,    0,    0,  145,  146,  147,  148,
     0,    0,    0,  149,    0,  150,    0,    0,    0,    0,
     0,  151,  152,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  675,    0,    0,    0,  153,  323,  155,  156,
    94,   95,    0,   97,    0,    0,   98,  278,    0,    0,
     0,  102,  103,  104,    0,  106,    0,    0,   95,    0,
    97,  107,    0,   98,  109,    0,    0,    0,  102,    0,
     0,  114,  106,    0,    0,    0,  116,    0,  117,  118,
   119,  109,    0,    0,    0,    0,    0,    0,  114,    0,
     0,    0,  121,  116,  122,  123,    0,  119,  124,    0,
     0,  126,    0,  128,    0,  130,  131,  132,  279,  121,
   135,  122,    0,    0,    0,  124,    0,  139,    0,    0,
   140,  141,    0,  131,  132,    0,    0,  135,    0,    0,
   255,    0,    0,    0,    0,    0,    0,    0,    0,  498,
     0,    0,    0,  143,    0,    0,    0,    0,    0,  145,
   146,  147,  148,    0,    0,    0,  149,    0,  150,    0,
     0,    0,    0,    0,  151,  152,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  834,    0,    0,    0,  153,
   323,  155,  156,   94,   95,    0,   97,    0,    0,   98,
   278,    0,    0,    0,  102,  103,  104,  343,  106,    0,
     0,   95,    0,   97,  107,    0,   98,  109,    0,    0,
     0,  102,    0,    0,  114,  106,    0,    0,    0,  116,
     0,  117,  118,  119,  109,    0,    0,    0,    0,    0,
     0,  114,    0,    0,    0,  121,  116,  122,  123,    0,
   119,  124,    0,    0,  126,    0,  128,    0,  130,  131,
   132,  279,  121,  135,  122,    0,    0,    0,  124,    0,
   139,    0,    0,  140,  141,    0,  131,  132,    0,    0,
   135,    0,    0,  255,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  143,    0,    0,    0,
     0,    0,  145,  146,  147,  148,    0,    0,    0,  149,
     0,  150,    0,    0,    0,    0,    0,  151,  152,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  617,    0,
     0,    0,  153,  323,  155,  156,  617,  617,    0,  617,
     0,    0,  617,  617,    0,    0,    0,  617,  617,  617,
    87,  617,    0,    0,   95,    0,   97,  617,    0,   98,
   617,    0,    0,    0,  102,    0,    0,  617,  106,    0,
     0,    0,  617,    0,  617,  617,  617,  109,    0,    0,
     0,    0,    0,    0,  114,    0,    0,    0,  617,  116,
   617,  617,    0,  119,  617,    0,    0,  617,    0,  617,
     0,  617,  617,  617,  617,  121,  617,  122,    0,    0,
     0,  124,    0,  617,    0,    0,  617,  617,    0,  131,
   132,    0,    0,  135,    0,    0,  437,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  617,
     0,    0,    0,    0,    0,  617,  617,  617,  617,    0,
     0,    0,  617,    0,  617,    0,    0,    0,    0,    0,
   617,  617,    0,    0,    0,    0,    0,    0,   94,   95,
     0,   97,    0,    0,   98,  278,    0,    0,    0,  102,
   103,  104,    0,  106,    0,  617,  617,  617,  617,  107,
     0,    0,  109,    0,    0,    0,    0,    0,    0,  114,
     0,    0,    0,   87,  116,    0,  117,  118,  119,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   121,    0,  122,  123,    0,    0,  124,    0,    0,  126,
     0,  128,    0,  130,  131,  132,  279,    0,  135,    0,
     0,    0,    0,    0,    0,  139,    0,    0,  140,  141,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  681,  911,    0,
     0,  143,    0,    0,    0,    0,    0,  145,  146,  147,
   148,    0,    0,    0,  149,    0,  150,    0,    0,    0,
     0,    0,  151,  152,    0,    0,    0,    0,    0,    0,
    94,   95,    0,   97,    0,    0,   98,  278,    0,    0,
     0,  102,  103,  104,    0,  106,    0,  153,  682,  155,
   156,  107,    0,   30,  109,   30,    0,  683,    0,    0,
     0,  114,    0,    0,    0,    0,  116,    0,  117,  118,
   119,    0,    0,    0,    0,    0,   30,    0,    0,    0,
     0,    0,  121,    0,  122,  123,    0,    0,  124,   30,
     0,  126,    0,  128,   30,  130,  131,  132,  279,   30,
   135,   30,   30,   30,   30,    0,    0,  139,    0,   30,
   140,  141,    0,   30,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,   30,    0,    0,   30,  681,
    30,    0,    0,  143,    0,    0,    0,    0,    0,  145,
   146,  147,  148,    0,    0,    0,  149,    0,  150,    0,
     0,   30,    0,    0,  151,  152,   30,   30,    0,    0,
     0,    0,  349,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  488,    0,    0,  153,
   682,  155,  156,    0,   94,   95,    0,   97,    0,  683,
    98,  278,    0,    0,    0,  102,  103,  104,  349,  106,
     0,    0,    0,    0,    0,  107,    0,    0,  109,    0,
     0,    0,    0,    0,    0,  114,    0,    0,    0,    0,
   116,    0,  117,  118,  119,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  121,    0,  122,  123,
     0,    0,  124,    0,    0,  126,    0,  128,    0,  130,
   131,  132,  279,    0,  135,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  349,  349,  349,
   349,    0,    0,    0,  349,  349,    0,    0,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  143,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
   349,  349,  349,  349,  349,  349,  349,  349,  349,  349,
     0,    0,    0,    0,    0,    0,  349,    0,    0,  349,
     0,    0,    0,    0,    0,    0,   55,    0,   55,    0,
    55,    0,   55,  153,  489,   55,    0,   55,   55,    0,
    55,    0,   55,    0,   55,    0,   55,   55,   55,   55,
     0,    0,   55,   55,    0,    0,    0,    0,   55,   55,
    55,   55,   55,    0,    0,   55,   55,   55,    0,   55,
     0,   55,   55,   55,   55,   55,   55,   55,   55,    0,
    55,   55,   55,   55,    0,    0,   55,   55,   55,    0,
    55,    0,    0,    0,    0,   55,   55,    0,   55,   55,
     0,   55,   55,   55,    0,    0,    0,   55,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,   55,   55,   55,    0,    0,    0,
     0,    0,    0,    0,    0,   54,    0,    0,   55,   54,
     0,   54,    0,    0,   54,    0,   54,   54,    0,   54,
     0,   54,    0,   54,    0,   54,   54,   54,   54,    0,
     0,   54,   54,    0,    0,    0,    0,   54,    0,   54,
    54,   54,    0,    0,   54,    0,   54,    0,   54,   55,
     0,   54,    0,   54,   54,   54,   54,    0,    0,    0,
    54,   54,   54,    0,    0,   54,   54,   54,    0,    0,
     0,    0,    0,    0,   54,   54,    0,   54,   54,   54,
    54,   54,   54,   54,    0,   54,   54,    0,   54,    0,
    54,   54,    0,   54,    0,   54,    0,   54,    0,   54,
    54,   54,   54,   54,    0,   54,   54,    0,   85,    0,
     0,   54,    0,   54,   54,   54,    0,   54,   54,    0,
    54,    0,   54,    0,    0,   54,    0,   54,   54,   54,
    54,    0,    0,    0,   54,   54,   54,    0,    0,   54,
    54,   54,    0,    0,    0,    0,    0,    0,   54,   54,
     0,   54,   54,   54,   54,   54,   54,   54,   54,   54,
    54,    0,   54,    0,   54,   54,    0,   54,    0,   54,
     0,   54,    0,   54,   54,   54,   54,   54,    0,   54,
    54,    0,   86,    0,    0,   54,    0,   54,   54,   54,
     0,   54,   54,    0,   54,    0,   54,    0,    0,   54,
     0,   54,   54,   54,   54,    0,    0,    0,   54,   54,
    54,    0,    0,   54,   54,   54,    0,    0,    0,    0,
     0,    0,   54,   54,    0,   54,   54,   54,   54,   54,
    54,   54,   54,   54,   54,    0,   54,    0,   54,   54,
     0,   54,    0,   54,    0,   54,    0,   54,   54,   54,
    54,   54,    0,   54,   54,    0,  108,    0,    0,   54,
     0,   54,   54,   54,    0,   54,   54,    0,   54,    0,
    54,    0,    0,   54,    0,   54,   54,   54,   54,    0,
     0,    0,   54,   54,   54,    0,    0,   54,   54,   54,
     0,    0,    0,    0,    0,    0,   54,   54,    0,   54,
    54,   54,   54,   54,   54,   54,   54,   54,   54,    0,
    54,    0,   54,   54,    0,   54,    0,   54,    0,   54,
     0,   54,   54,   54,   54,   54,    0,   54,   54,    0,
   109,    0,    0,   54,    0,   54,   54,   54,    0,   54,
    54,    0,   54,    0,   54,    0,    0,   54,    0,   54,
    54,   54,   54,    0,    0,    0,   54,   54,   54,    0,
     0,   54,   54,   54,    0,    0,    0,    0,    0,    0,
    54,   54,    0,   54,   54,   54,   54,   54,   54,   54,
    54,   54,   54,    0,   54,    0,   54,   54,    0,   54,
     0,   54,    0,   54,    0,   54,   54,   54,   54,   54,
     0,   54,   54,    0,  230,    0,    0,   54,    0,   54,
    54,   54,    0,    0,   54,    0,   54,    0,   54,  349,
     0,   54,    0,   54,   54,   54,   54,    0,    0,    0,
    54,   54,   54,    0,    0,   54,   54,   54,    0,    0,
     0,    0,  349,    0,   54,   54,    0,   54,   54,   54,
    54,   54,   54,    0,   54,  349,   54,    0,    0,    0,
   349,    0,    0,  349,    0,  349,    0,  349,  349,  349,
   349,    0,   54,   54,    0,  349,    0,    0,  231,  349,
     0,    0,    0,  349,    0,   54,    0,    0,    0,    0,
    54,  349,    0,    0,  349,   54,  349,   54,   54,   54,
    54,    0,    0,    0,    0,   54,    0,    0,    0,   54,
     0,    0,    0,    0,    0,  349,    0,  349,    0,    0,
     0,   54,    0,  349,   54,  281,   54,  349,   54,    0,
     0,   94,   95,    0,   97,    0,    0,   98,  278,    0,
   349,    0,  102,  103,  104,    0,  106,   54,   54,   54,
     0,    0,  107,    0,   54,  109,    0,    0,    0,    0,
     0,    0,  114,    0,    0,    0,    0,  116,    0,  117,
   118,  119,  349,  563,    0,    0,    0,   54,    0,    0,
   564,    0,    0,  121,    0,  122,  123,    0,    0,  124,
    54,    0,  126,    0,  128,   54,  130,  131,  132,  279,
    54,  135,   54,   54,   54,   54,    0,    0,  565,    0,
    54,  140,  141,    0,   54,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,   54,    0,    0,   54,
     0,   54,    0,    0,  143,  840,    0,  566,    0,    0,
   145,  146,  147,  148,    0,    0,    0,  149,    0,  150,
     0,    0,   54,   54,   54,  151,  152,  214,    0,    0,
     0,    0,    0,   94,   95,    0,   97,    0,    0,   98,
   278,    0,    0,    0,  102,  103,  104,    0,  106,    0,
   153,  465,  155,  156,  107,    0,   54,  109,   54,    0,
     0,    0,    0,    0,  114,    0,    0,    0,    0,  116,
     0,  117,  118,  119,    0,  563,    0,    0,    0,   54,
     0,    0,  564,    0,    0,  121,    0,  122,  123,    0,
     0,  124,   54,    0,  126,    0,  128,   54,  130,  131,
   132,  279,   54,  135,   54,   54,   54,   54,    0,    0,
   565,    0,   54,  140,  141,    0,   54,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,   54,    0,
     0,   54,    0,   54,    0,    0,  143,    0,    0,  566,
     0,    0,  145,  146,  147,  148,    0,    0,    0,  149,
     0,  150,    0,    0,   54,    0,    0,  151,  152,  315,
     0,    0,    0,    0,    0,   94,   95,    0,   97,    0,
     0,   98,  278,    0,    0,    0,  102,  103,  104,    0,
   106,    0,  153,  465,  155,  156,  107,    0,   59,  109,
     0,    0,    0,    0,    0,    0,  114,    0,    0,    0,
     0,  116,    0,  117,  118,  119,    0,  563,    0,    0,
     0,   60,    0,    0,  564,    0,    0,  121,    0,  122,
   123,    0,    0,  124,   61,    0,  126,    0,  128,   63,
   130,  131,  132,  279,   64,  135,   65,   66,   67,   68,
     0,    0,  565,    0,   69,  140,  141,    0,   70,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    71,    0,    0,   72,    0,   73,    0,    0,  143,    0,
     0,    0,    0,    0,  145,  146,  147,  148,    0,    0,
     0,  149,    0,  150,    0,    0,   74,    0,    0,  151,
   152,    0,    0,    0,    0,    0,    0,   94,   95,    0,
    97,    0,    0,   98,  278,    0,    0,    0,  102,  103,
   104,    0,  106,    0,  153,  465,  155,  156,  107,    0,
     0,  109,    0,    0,    0,    0,    0,    0,  114,    0,
     0,    0,    0,  116,    0,  117,  118,  119,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  121,
     0,  122,  123,    0,    0,  124,    0,    0,  126,    0,
   128,    0,  130,  131,  132,  279,    0,  135,    0,    0,
   137,    0,    0,    0,  139,    0,    0,  140,  141,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   143,    0,    0,    0,    0,    0,  145,  146,  147,  148,
     0,    0,    0,  149,    0,  150,    0,    0,    0,    0,
     0,  151,  152,    0,    0,    0,    0,    0,    0,   94,
    95,    0,   97,    0,    0,   98,  278,    0,    0,    0,
   102,  103,  104,    0,  106,    0,  153,  323,  155,  156,
   107,    0,    0,  109,    0,    0,    0,    0,    0,    0,
   114,    0,    0,    0,    0,  116,    0,  117,  118,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  121,    0,  122,  123,    0,    0,  124,    0,    0,
   126,    0,  128,    0,  130,  131,  132,  279,    0,  135,
     0,    0,    0,    0,    0,    0,  139,    0,    0,  140,
   141,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  805,
     0,    0,  143,    0,    0,    0,    0,    0,  145,  146,
   147,  148,    0,    0,    0,  149,    0,  150,    0,    0,
     0,    0,    0,  151,  152,    0,    0,    0,    0,    0,
     0,   94,   95,    0,   97,    0,    0,   98,  278,    0,
     0,    0,  102,  103,  104,    0,  106,    0,  153,  323,
   155,  156,  107,    0,    0,  109,    0,    0,    0,    0,
     0,    0,  114,    0,    0,    0,    0,  116,    0,  117,
   118,  119,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,  121,    0,  122,  123,    0,    0,  124,
     0,    0,  126,    0,  128,    0,  130,  131,  132,  279,
     0,  135,    0,    0,    0,    0,    0,    0,  139,    0,
     0,  140,  141,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   498,    0,    0,    0,  143,    0,    0,    0,    0,    0,
   145,  146,  147,  148,    0,    0,    0,  149,    0,  150,
     0,    0,    0,    0,    0,  151,  152,    0,    0,    0,
     0,    0,    0,   94,   95,    0,   97,    0,    0,   98,
   278,    0,    0,    0,  102,  103,  104,    0,  106,    0,
   153,  323,  155,  156,  107,    0,    0,  109,    0,    0,
     0,    0,    0,    0,  114,    0,    0,    0,    0,  116,
     0,  117,  118,  119,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  121,    0,  122,  123,    0,
     0,  124,    0,    0,  126,    0,  128,    0,  130,  131,
   132,  279,    0,  135,    0,    0,    0,    0,    0,    0,
   139,    0,    0,  140,  141,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  501,    0,    0,    0,  143,    0,    0,    0,
     0,    0,  145,  146,  147,  148,    0,    0,    0,  149,
     0,  150,    0,    0,    0,    0,    0,  151,  152,    0,
     0,    0,    0,    0,    0,   94,   95,    0,   97,    0,
     0,   98,  278,    0,    0,    0,  102,  103,  104,    0,
   106,    0,  153,  323,  155,  156,  107,    0,    0,  109,
     0,    0,    0,    0,    0,    0,  114,    0,    0,    0,
     0,  116,    0,  117,  118,  119,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  121,    0,  122,
   123,    0,    0,  124,    0,    0,  126,    0,  128,    0,
   130,  131,  132,  279,    0,  135,    0,    0,    0,    0,
     0,    0,  139,    0,    0,  140,  141,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  143,    0,
     0,    0,    0,    0,  145,  146,  147,  148,    0,    0,
     0,  149,    0,  150,    0,    0,    0,    0,    0,  151,
   152,    0,    0,    0,    0,    0,    0,   94,   95,    0,
    97,    0,    0,   98,  278,    0,    0,    0,  102,  103,
   104,    0,  106,    0,  153,  323,  155,  156,  107,    0,
     0,  109,    0,    0,    0,    0,    0,    0,  114,    0,
     0,    0,    0,  116,    0,  117,  118,  119,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  121,
     0,  122,  123,    0,    0,  124,    0,    0,  126,    0,
   128,    0,  130,  131,  132,  279,    0,  135,    0,    0,
     0,    0,    0,    0,  139,    0,    0,  140,  141,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   143,    0,    0,    0,    0,    0,  145,  146,  147,  148,
     0,    0,    0,  149,    0,  150,    0,    0,    0,    0,
     0,  151,  152,    0,    0,    0,    0,    0,    0,   94,
    95,    0,   97,    0,    0,   98,  278,    0,    0,    0,
   102,  103,  104,    0,  106,    0,  153,  457,  155,  156,
   107,    0,    0,  109,    0,    0,    0,    0,    0,    0,
   114,    0,    0,    0,    0,  116,    0,  117,  118,  119,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  121,    0,  122,  123,    0,    0,  124,    0,    0,
   126,    0,  128,    0,  130,  131,  132,  279,    0,  135,
     0,    0,    0,    0,    0,    0,  139,    0,    0,  140,
   141,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,  143,    0,    0,    0,    0,    0,  145,  146,
   147,  148,    0,    0,    0,  149,    0,  150,    0,    0,
     0,    0,    0,  151,  152,    0,    0,    0,    0,    0,
     0,   82,   82,    0,   82,    0,    0,   82,   82,    0,
     0,    0,   82,   82,   82,    0,   82,    0,  153,  465,
   155,  156,   82,    0,    0,   82,    0,    0,    0,    0,
     0,    0,   82,    0,    0,    0,    0,   82,    0,   82,
    82,   82,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,   82,    0,   82,   82,    0,    0,   82,
     0,    0,   82,    0,   82,    0,   82,   82,   82,   82,
     0,   82,    0,    0,    0,    0,    0,    0,   82,    0,
     0,   82,   82,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,   82,    0,    0,    0,    0,    0,
    82,   82,   82,   82,    0,    0,    0,   82,    0,   82,
     0,    0,    0,    0,    0,   82,   82,    0,    0,    0,
     0,    0,    0,  154,  154,    0,  154,    0,    0,  154,
   154,    0,    0,    0,  154,  154,  154,    0,  154,    0,
    82,   82,   82,   82,  154,    0,    0,  154,    0,    0,
     0,    0,    0,    0,  154,    0,    0,    0,    0,  154,
     0,  154,  154,  154,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,  154,    0,  154,  154,    0,
     0,  154,    0,    0,  154,    0,  154,    0,  154,  154,
   154,  154,    0,  154,    0,    0,    0,    0,    0,    0,
   154,    0,    0,  154,  154,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,  154,    0,    0,    0,
     0,    0,  154,  154,  154,  154,    0,    0, 1240,  154,
     0,  154,    0,    0,    0,    0,    0,  154,  154,    0,
     0,    0,    0,    0,    0,   94,   95,    0,   97,    0,
     0,   98,  278,    0,    0,    0,  102,  103,  104,    0,
   106,    0,  154,  154,  154,  154,  107,    0,    0,  109,
  1241,    0,    0,    0,    0,    0,  114,    0,    0,    0,
     0,  116,    0,  117,  118,  119,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,  121,    0,  122,
   123,    0,    0,  124,    0,    0,  126,    0,  128,    0,
   130,  131,  132,  279,    0,  135, 1242, 1243, 1244, 1245,
     0, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253,    0,
     0, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  143,    0,
     0,    0,    0,    0,  145,  146,  147,  148,    0,    0,
     0,  149,    0,  150,    0,    0,    0,    0,    0,  151,
   152,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,  642,
     0,  642,    0,  642,  153,  280,  642,  156,  642,  642,
     0,  642,    0,  642,    0,  642,    0,  642,  642,  642,
     0,    0,    0,  642,  642,    0,    0,    0,    0,  642,
     0,  642,  642,    0,    0,    0,  642,    0,    0,    0,
   642,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,  642,  642,    0,  642,    0,    0,    0,  642,  642,
     0,    0,    0,    0,    0,    0,  642,  642,   94,   95,
   642,   97,    0,  642,   98,  278,    0,    0,  642,  102,
   103,  104,    0,  106,    0,    0,    0,    0,    0,  107,
     0,    0,  109,    0,    0,    0,  642,  642,    0,  114,
     0,    0,    0,    0,  116,    0,  117,  118,  119,  642,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   121,    0,  122,  123,    0,    0,  124,    0,    0,  126,
     0,  128,    0,  130,  131,  132,  279,  641,  135,  641,
     0,  137,  641,    0,  641,  641,    0,  641,    0,  641,
   642,  641,    0,  641,  641,  641,    0,    0,    0,  641,
   641,    0,    0,    0,    0,  641,    0,  641,  641,    0,
     0,  143,  641,    0,    0,    0,  641,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,  641,    0,
   641,    0,    0,    0,  641,  641,    0,    0,    0,    0,
     0,    0,  641,  641,    0,    0,  641,    0,    0,  641,
     0,    0,    0,    0,  641,    0,    0,  153,  280,  641,
     0,  641,    0,    0,  641,    0,  641,  641,    0,  641,
     0,  641,    0,  641,    0,  641,  641,  641,    0,    0,
     0,  641,  641,    0,    0,  641,    0,  641,    0,  641,
   641,    0,    0,    0,  641,    0,    0,    0,  641,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   641,    0,  641,    0,    0,    0,  641,  641,    0,    0,
     0,    0,    0,    0,  641,  641,  641,   95,  641,   97,
     0,  641,   98,    0,    0, 1167,  641,  102,    0,  248,
     0,  106,    0,  249, 1168, 1169,    0,    0,    0, 1170,
   109,    0,    0,    0,    0, 1171,    0,  114,    0,   95,
     0,   97,  116,    0,   98,    0,  119, 1167,    0,  102,
     0,  248,    0,  106,    0,  249, 1168, 1169,  121,    0,
   122, 1170,  109,    0,  124,    0,    0, 1171,    0,  114,
     0,    0,  131,  132,  116,    0,  135,    0,  119, 1172,
     0,    0,    0,    0, 1173,    0,    0,    0,  641,   54,
   121,   54,  122,    0,   54,    0,  124,    0,    0,   54,
     0,    0,    0,   54,  131,  132,    0,    0,  135,    0,
     0, 1172,   54,    0,    0, 1174, 1173,    0,    0,   54,
     0,    0,    0,    0,   54,    0,    0,    0,   54,   54,
    54,   54,   54,    0,   54,    0,    0,   54,    0,   54,
    54,    0,   54,   54,    0,    0,   54,    0,    0,   54,
     0,    0,   54,    0,   54,   54, 1175,    0,   54,   54,
     0,   54,    0,    0,   54,    0,    0,    0,   54,    0,
    54,    0,   54,    0,    0,    0,    0,   54,    0,    0,
    54,    0,   54,    0,    0,    0,   54,    0, 1175,   54,
     0,    0,  171,    0,   54,   54,    0,    0,   54,    0,
     0,   54,   54,    0,   54,    0,    0,   54,    0,    0,
     0,    0,   54,    0,    0,    0,   54,    0,    0,    0,
     0,    0,    0,    0,    0,   54,    0,    0,    0,    0,
   171,    0,   54,    0,   95,    0,   97,   54,   54,   98,
     0,   54,    0,   54,  102,   54,    0,    0,  106,    0,
    54,    0,    0,   54,    0,   54,    0,  109,    0,   54,
     0,    0,   54,    0,  114,    0,    0,   54,   54,  116,
     0,   54,    0,  119,   54,  544,    0,    0,   54,    0,
     0,    0,  545,    0,    0,  121,    0,  122,   95,    0,
    97,  124,    0,   98,  546, 1093,    0,    0,  102,  131,
   132,    0,  106,  135,    0,   95,  547,   97,    0,    0,
    98,  109,    0,    0,    0,  102,    0,    0,  114,  106,
     0,    0,    0,  116,    0, 1094,    0,  119,  109,    0,
     0,    0,    0,    0,    0,  114,    0,    0,    0,  121,
   116,  122,    0,    0,  119,  124, 1095,    0,    0,    0,
     0,   54,    0,  131,  132,    0,  121,  135,  122,   95,
   255,   97,  124,    0,   98,    0,    0,    0,    0,  102,
   131,  132,    0,  106,  135,    0,   95,  507,   97,    0,
     0,   98,  109,  548,    0,    0,  102,    0,    0,  114,
   106,    0,    0,    0,  116,    0,    0,    0,  119,  109,
     0,    0,    0,    0,    0,    0,  114,    0,    0,    0,
   121,  116,  122,    0,    0,  119,  124,    0,    0,    0,
     0,    0,    0,    0,  131,  132,    0,  121,  135,  122,
    95,  255,   97,  124,    0,   98,    0,   87,    0,    0,
   102,  131,  132,    0,  106,  135,    0,  500,  255,  500,
     0,    0,  500,  109,   87,    0,    0,  500,    0,    0,
   114,  500,    0,    0,    0,  116,    0,    0,    0,  119,
   500,    0,    0,    0,    0,    0,    0,  500,    0,    0,
     0,  121,  500,  122,    0,    0,  500,  124,    0,    0,
     0,    0,    0,    0,    0,  131,  132,    0,  500,  135,
   500,  190,  547,  190,  500,    0,  190,    0,  611,    0,
     0,  190,  500,  500,    0,  190,  500,    0,  200,  500,
   200,    0,    0,  200,  190,  613,    0,    0,  200,    0,
     0,  190,  200,    0,    0,    0,  190,    0,    0,    0,
   190,  200,    0,    0,    0,    0,    0,    0,  200,    0,
     0,    0,  190,  200,  190,    0,    0,  200,  190,    0,
     0,    0,    0,    0,    0,    0,  190,  190,    0,  200,
   190,  200,  191,  190,  191,  200,    0,  191,    0,   87,
     0,    0,  191,  200,  200,    0,  191,  200,    0,    0,
   200,    0,    0,    0,    0,  191,  500,    0,    0,    0,
     0,    0,  191,    0,    0,    0,    0,  191,    0,    0,
     0,  191,    0,    0,    0,   39,    0,    0,    0,    0,
    39,    0,    0,  191,    0,  191,    0,    0,    0,  191,
     0,   39,    0,    0,    0,    0,   39,  191,  191,    0,
    39,  191,    0,   39,  191,    0,    0,    0,    0,    0,
   190,    0,    0,    0,    0,   39,   39,    0,    0,    0,
    39,   39,    0,    0,    0,    0,   39,  200,   39,   39,
    39,   39,    0,    0,    0,    0,   39,    0,    0,    0,
    39,    0,   39,    0,    0,    0,   40,    0,    0,    0,
     0,   40,   39,    0,   39,   39,    0,   39,    0,    0,
     0,   39,   40,    0,    0,    0,    0,   40,    0,    0,
     0,   40,    0,    0,   40,    0,    0,    0,   39,    0,
     0,  191,    0,   39,   39,    0,   40,   40,    0,    0,
     0,   40,   40,    0,    0,    0,    0,   40,    0,   40,
    40,   40,   40,    0,    0,    0,    0,   40,    0,    0,
     0,   40,    0,   40,    0,    0,    0,   37,    0,    0,
     0,    0,   37,   40,    0,   40,   40,    0,   40,    0,
     0,    0,   40,   37,    0,    0,    0,    0,   37,    0,
     0,    0,   37,    0,    0,   37,    0,    0,    0,   40,
     0,    0,    0,    0,   40,   40,    0,   37,   37,    0,
     0,    0,   37,   37,    0,    0,    0,    0,   37,    0,
    37,   37,   37,   37,    0,    0,    0,    0,   37,    0,
     0,    0,   37,    0,   37,    0,    0,    0,   38,    0,
     0,    0,    0,   38,   37,    0,    0,   37,    0,   37,
     0,    0,    0,   37,   38,    0,    0,    0,    0,   38,
     0,    0,    0,   38,    0,    0,   38,    0,    0,    0,
    37,    0,    0,    0,    0,   37,   37,    0,   38,   38,
     0,    0,    0,   38,   38,    0,    0,    0,    0,   38,
     0,   38,   38,   38,   38,    0,    0,    0,    0,   38,
     0,    0,   30,   38,    0,   38,    0,    0,    0,    0,
     0,    0,    0,    0,    0,   38,    0,    0,   38,    0,
    38,    0,    0,    0,   38,   30,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,   30,    0,
     0,   38,    0,   30,    0,    0,   38,   38,   30,    0,
    30,   30,   30,   30,    0,    0,   30,    0,   30,    0,
     0,    0,   30,    0,    0,    0,    0,   54,    0,    0,
     0,    0,    0,    0,   30,    0,    0,   30,   54,   30,
     0,    0,    0,   54,    0,    0,    0,   54,    0,    0,
    54,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    30,    0,   54,   54,    0,   30,   30,   54,   54,    0,
     0,    0,    0,   54,    0,   54,   54,   54,   54,    0,
     0,    0,    0,   54,    0,    0,    0,   54,    0,   54,
     0,    0,    0,    0,    0,    0,   54,    0,    0,   54,
     0,    0,   54,    0,   54,    0,    0,   54,   54,    0,
     0,    0,   54,    0,    0,    0,   54,    0,    0,   54,
     0,    0,    0,    0,    0,   54,    0,    0,    0,    0,
    41,   54,   54,    0,    0,    0,   54,   54,    0,    0,
     0,    0,   54,    0,   54,   54,   54,   54,    0,    0,
     0,    0,   54,    0,    0,   54,   54,    0,   54,    0,
     0,    0,    0,    0,    0,    0,    0,    0,   54,    0,
     0,   54,    0,   54,    0,    0,    0,   54,   54,    0,
     0,    0,    0,    0,    0,   54,    0,   54,    0,    0,
     0,   54,    0,    0,   54,    0,   54,    0,    0,   42,
     0,   54,    0,   54,   54,   54,   54,    0,   54,   54,
     0,   54,    0,    0,    0,   54,    0,    0,    0,    0,
     0,   54,    0,    0,    0,   59,   54,   54,    0,    0,
    54,   54,   54,   54,   54,   54,   54,    0,    0,   54,
     0,   54,    0,    0,    0,   54,    0,    0,   60,    0,
     0,    0,    0,   54,    0,    0,    0,   54,  314,    0,
    54,   61,   54,    0,    0,   62,   63,    0,    0,    0,
     0,   64,    0,   65,   66,   67,   68,    0,    0,    0,
     0,   69,    0,   54,    0,   70,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,   71,    0,    0,
    72,    0,   73,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
     0,    0,    0,   74,
   };
   protected static  short [] yyCheck = {            76,
 {
 	oob_stack = new Stack<object> ();
 }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\method.cs" startline="1985" endline="2325">
<![CDATA[
 
 		public Destructor (DeclSpace parent, Modifiers mod, ParametersCompiled parameters, Attributes attrs, Location l)
 			
 				new MemberName (MetadataName, l), attrs, parameters)
 		{
 			ModFlags &= ~Modifiers.PRIVATE;
 			ModFlags |= Modifiers.PROTECTED | Modifiers.OVERRIDE;
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.Conditional) {
 				Error_ConditionalAttributeIsNotValid ();
 				return;
 			}
 
 			base.ApplyAttributeBuilder (a, ctor, cdata, pa);
 		}
 
 		protected override bool CheckBase ()
 		{
 			// Don't check base, destructors have special syntax
 			return true;
 		}
 
 		public override void Emit()
 		{
 			var base_type = Parent.PartialContainer.BaseType;
 			if (base_type != null && Block != null) {
 				var base_dtor = MemberCache.FindMember (base_type,
 					new MemberFilter (MetadataName, 0, MemberKind.Destructor, null, null), BindingRestriction.InstanceOnly) as MethodSpec;
 
 				if (base_dtor == null)
 					throw new NotImplementedException ();
 
 				MethodGroupExpr method_expr = MethodGroupExpr.CreatePredefined (base_dtor, base_type, Location);
 				method_expr.InstanceExpression = new BaseThis (base_type, Location);
 
 				var try_block = new ExplicitBlock (block, block.StartLocation, block.EndLocation);
 				var finaly_block = new ExplicitBlock (block, Location, Location);
 
 				//
 				// 0-size arguments to avoid CS0250 error
 				// TODO
 				// debugger scope
 				//
 				finaly_block.AddStatement (new StatementExpression (new Invocation (method_expr, new Arguments (0))));
 
 				var tf = new TryFinally (try_block, finaly_block, Location);
 				block.WrapIntoDestructor (tf, try_block);
 			}
 
 			base.Emit ();
 		}
 
 		public override string GetSignatureForError ()
 		{
 			return Parent.GetSignatureForError () + ".~" + Parent.MemberName.Name + "()";
 		}
 
 		protected override bool ResolveMemberType ()
 		{
 			member_type = TypeManager.void_type;
 			return true;
 		}
 
 		public override string[] ValidAttributeTargets {
 			get {
 				return attribute_targets;
 			}
 		}
 	}
 
 	// Ooouh Martin, templates are missing here.
 	// When it will be possible move here a lot of child code and template method type.
 	public abstract class AbstractPropertyEventMethod 
 		protected MethodData method_data;
 		protected ToplevelBlock block;
 		protected SecurityType declarative_security;
 
 		protected readonly string prefix;
 
 		ReturnParameter return_attributes;
 
 		public AbstractPropertyEventMethod (InterfaceMemberBase member, string prefix, Attributes attrs, Location loc)
 			
 		{
 			this.prefix = prefix;
 		}
 
 		static MemberName SetupName (string prefix, InterfaceMemberBase member, Location loc)
 		{
 			return new MemberName (member.MemberName.Left, prefix + member.ShortName, loc);
 		}
 
 		public void UpdateName (InterfaceMemberBase member)
 		{
 			SetMemberName (SetupName (prefix, member, Location));
 		}
 
 		#region IMethodData Members
 
 		public ToplevelBlock Block {
 			get {
 				return block;
 			}
 
 			set {
 				block = value;
 			}
 		}
 
 		public CallingConventions CallingConventions {
 			get {
 				return CallingConventions.Standard;
 			}
 		}
 
 		public EmitContext CreateEmitContext (ILGenerator ig)
 		{
 			return new EmitContext (this, ig, ReturnType);
 		}
 
 		public bool IsExcluded ()
 		{
 			return false;
 		}
 
 		GenericMethod IMethodData.GenericMethod {
 			get {
 				return null;
 			}
 		}
 
 		public MemberName MethodName {
 			get {
 				return MemberName;
 			}
 		}
 
 		public TypeSpec[] ParameterTypes { 
 			get {
 				return ParameterInfo.Types;
 			}
 		}
 
 		public abstract ParametersCompiled ParameterInfo { get ; }
 		public abstract TypeSpec ReturnType { get; }
 
 		#endregion
 
 		public override void ApplyAttributeBuilder (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			if (a.Type == pa.CLSCompliant || a.Type == pa.Obsolete || a.Type == pa.Conditional) {
 				Report.Error (1667, a.Location,
 					"Attribute `{0}' is not valid on property or event accessors. It is valid on `{1}' declarations only",
 					TypeManager.CSharpName (a.Type), a.GetValidTargets ());
 				return;
 			}
 
 			if (a.IsValidSecurityAttribute ()) {
 				a.ExtractSecurityPermissionSet (ctor, ref declarative_security);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.Method) {
 				method_data.MethodBuilder.SetCustomAttribute ((ConstructorInfo) ctor.GetMetaInfo (), cdata);
 				return;
 			}
 
 			if (a.Target == AttributeTargets.ReturnValue) {
 				if (return_attributes == null)
 					return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 
 				return_attributes.ApplyAttributeBuilder (a, ctor, cdata, pa);
 				return;
 			}
 
 			ApplyToExtraTarget (a, ctor, cdata, pa);
 		}
 
 		protected virtual void ApplyToExtraTarget (Attribute a, MethodSpec ctor, byte[] cdata, PredefinedAttributes pa)
 		{
 			throw new NotSupportedException ("You forgot to define special attribute target handling");
 		}
 
 		// It is not supported for the accessors
 		public sealed override bool Define()
 		{
 			throw new NotSupportedException ();
 		}
 
 		public virtual void Emit (DeclSpace parent)
 		{
 			method_data.Emit (parent);
 
 			if ((ModFlags & Modifiers.COMPILER_GENERATED) != 0 && !Parent.IsCompilerGenerated)
 				Module.PredefinedAttributes.CompilerGenerated.EmitAttribute (method_data.MethodBuilder);
 			if (((ModFlags & Modifiers.DEBUGGER_HIDDEN) != 0))
 				Module.PredefinedAttributes.DebuggerHidden.EmitAttribute (method_data.MethodBuilder);
 
 			if (ReturnType == InternalType.Dynamic) {
 				return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder);
 			} else if (ReturnType.HasDynamicElement) {
 				return_attributes = new ReturnParameter (this, method_data.MethodBuilder, Location);
 				Module.PredefinedAttributes.Dynamic.EmitAttribute (return_attributes.Builder, ReturnType, Location);
 			}
 
 			if (OptAttributes != null)
 				OptAttributes.Emit ();
 
 			if (declarative_security != null) {
 				foreach (var de in declarative_security) {
 #if STATIC
 					method_data.MethodBuilder.__AddDeclarativeSecurity (de);
 #else
 					method_data.MethodBuilder.AddDeclarativeSecurity (de.Key, de.Value);
 #endif
 				}
 			}
 
 			block = null;
 		}
 
 		public override bool EnableOverloadChecks (MemberCore overload)
 		{
 			if (overload is MethodCore) {
 				caching_flags |= Flags.MethodOverloadsExist;
 				return true;
 			}
 
 			// This can only happen with indexers and it will
 			// be catched as indexer difference
 			if (overload is AbstractPropertyEventMethod)
 				return true;
 
 			return false;
 		}
 
 		public override bool IsClsComplianceRequired()
 		{
 			return false;
 		}
 
 		public MethodSpec Spec { get; protected set; }
 
 		//
 		//   Represents header string for documentation comment.
 		//
 		public override string DocCommentHeader {
 			get { throw new InvalidOperationException ("Unexpected attempt to get doc comment from " + this.GetType () + "."); }
 		}
 
 		void IMethodData.EmitExtraSymbolInfo (SourceMethod source)
 		{ }
 	}
 
 	public class Operator 
 
 		const Modifiers AllowedModifiers =
 			Modifiers.PUBLIC |
 			Modifiers.UNSAFE |
 			Modifiers.EXTERN |
 			Modifiers.STATIC;
 
 		public enum OpType 
 
 			// Unary operators
 			LogicalNot,
 			OnesComplement,
 			Increment,
 			Decrement,
 			True,
 			False,
 
 			// Unary and Binary operators
 			Addition,
 			Subtraction,
 
 			UnaryPlus,
 			UnaryNegation,
 			
 			// Binary operators
 			Multiply,
 			Division,
 			Modulus,
 			BitwiseAnd,
 			BitwiseOr,
 			ExclusiveOr,
 			LeftShift,
 			RightShift,
 			Equality,
 			Inequality,
 			GreaterThan,
 			LessThan,
 			GreaterThanOrEqual,
 			LessThanOrEqual,
 
 			// Implicit and Explicit
 			Implicit,
 			Explicit,
 
 			// Just because of enum
 			TOP
 		};
 
 		public readonly OpType OperatorType;
 
 		static readonly string [] [] names;
 
 		static Operator ()
 		{
 			names = new string[(int)OpType.TOP][];
 			names [(int) OpType.LogicalNot] = new string [] { "!", "op_LogicalNot" };
 			names [(int) OpType.OnesComplement] = new string [] { "~", "op_OnesComplement" };
 			names [(int) OpType.Increment] = new string [] { "++", "op_Increment" };
 			names [(int) OpType.Decrement] = new string [] { "--", "op_Decrement" };
 			names [(int) OpType.True] = new string [] { "true", "op_True" };
 			names [(int) OpType.False] = new string [] { "false", "op_False" };
 			names [(int) OpType.Addition] = new string [] { "+", "op_Addition" };
 			names [(int) OpType.Subtraction] = new string [] { "-", "op_Subtraction" };
 			names [(int) OpType.UnaryPlus] = new string [] { "+", "op_UnaryPlus" };
 			names [(int) OpType.UnaryNegation] = new string [] { "-", "op_UnaryNegation" };
 			names [(int) OpType.Multiply] = new string [] { "*", "op_Multiply" };
 			names [(int) OpType.Division] = new string [] { "/", "op_Division" };
 			names [(int) OpType.Modulus] = new string [] { "%", "op_Modulus" };
 			names [(int) OpType.BitwiseAnd] = new string [] { "&", "op_BitwiseAnd" };
 			names [(int) OpType.BitwiseOr] = new string [] { "|", "op_BitwiseOr" };
 			names [(int) OpType.ExclusiveOr] = new string [] { "^", "op_ExclusiveOr" };
 			names [(int) OpType.LeftShift] = new string [] { "<<", "op_LeftShift" };
 			names [(int) OpType.RightShift] = new string [] { ">>", "op_RightShift" };
 			names [(int) OpType.Equality] = new string [] { "==", "op_Equality" };
 			names [(int) OpType.Inequality] = new string [] { "!=", "op_Inequality" };
 			names [(int) OpType.GreaterThan] = new string [] { ">", "op_GreaterThan" };
 			names [(int) OpType.LessThan] = new string [] { "<", "op_LessThan" };
 			names [(int) OpType.GreaterThanOrEqual] = new string [] { ">=", "op_GreaterThanOrEqual" };
 			names [(int) OpType.LessThanOrEqual] = new string [] { "<=", "op_LessThanOrEqual" };
 			names [(int) OpType.Implicit] = new string [] { "implicit", "op_Implicit" };
 			names [(int) OpType.Explicit] = new string [] { "explicit", "op_Explicit" };
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="26" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\cs-parser.cs" startline="1250" endline="6926">
<![CDATA[
 
 	static int[] global_yyStates;
 	static object[] global_yyVals;
 	protected bool use_global_stacks;
 	object[] yyVals;					// value stack
 	object yyVal;						// value stack ptr
 	int yyToken;						// current input
 	int yyTop;
 
   /** the generated parser.
       Maintains a state and a value stack, currently with fixed maximum size.
       @param yyLex scanner.
       @return result of the last reduction, if any.
       @throws yyException on irrecoverable parse error.
     */
   internal Object yyparse (yyParser.yyInput yyLex)
   {
     if (yyMax <= 0) yyMax = 256;		// initial size
     int yyState = 0;                   // state stack ptr
     int [] yyStates;               	// state stack 
     yyVal = null;
     yyToken = -1;
     int yyErrorFlag = 0;				// #tks to shift
 	if (use_global_stacks && global_yyStates != null) {
 		yyVals = global_yyVals;
 		yyStates = global_yyStates;
    } else {
 		yyVals = new object [yyMax];
 		yyStates = new int [yyMax];
 		if (use_global_stacks) {
 			global_yyVals = yyVals;
 			global_yyStates = yyStates;
 		}
 	}
 
     /*yyLoop
       if (yyTop >= yyStates.Length) {			// dynamically increase
         global
         global
       }
       yyStates[yyTop] = yyState;
       yyVals[yyTop] = yyVal;
       if (debug != null) debug.push(yyState, yyVal);
 
       /*yyDiscarded
         int yyN;
         if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
               debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
           }
           if ((yyN = yySindex[yyState]) != 0 && ((yyN += yyToken) >= 0)
               && (yyN < yyTable.Length) && (yyCheck[yyN] == yyToken)) {
             if (debug != null)
               debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
             yyState = yyTable[yyN];		// shift to yyN
             yyVal = yyLex.value();
             yyToken = -1;
             if (yyErrorFlag > 0) -- yyErrorFlag;
             goto continue_yyLoop;
           }
           if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
               && yyN < yyTable.Length && yyCheck[yyN] == yyToken)
             yyN = yyTable[yyN];			// reduce (yyN)
           else
             switch (yyErrorFlag) {
   
             case 0
               yyExpectingState = yyState;
               // yyerror(String.Format ("syntax error, got token `{0}'", yyname (yyToken)), yyExpecting(yyState));
               if (debug != null) debug.error("syntax error");
               if (yyToken == 0 /*eof*/ || yyToken == eof_token) throw new yyParser.yyUnexpectedEof ();
               goto case 1;
             case 1
               yyErrorFlag = 3;
               do {
                 if ((yyN = yySindex[yyStates[yyTop]]) != 0
                     && (yyN += Token.yyErrorCode) >= 0 && yyN < yyTable.Length
                     && yyCheck[yyN] == Token.yyErrorCode) {
                   if (debug != null)
                     debug.shift(yyStates[yyTop], yyTable[yyN], 3);
                   yyState = yyTable[yyN];
                   yyVal = yyLex.value();
                   goto continue_yyLoop;
                 }
                 if (debug != null) debug.pop(yyStates[yyTop]);
               } while (-- yyTop >= 0);
               if (debug != null) debug.reject();
               throw new yyParser.yyException("irrecoverable syntax error");
   
             case 3
               if (yyToken == 0) {
                 if (debug != null) debug.reject();
                 throw new yyParser.yyException("irrecoverable syntax error at end-of-file");
               }
               if (debug != null)
                 debug.discard(yyState, yyToken, yyname(yyToken),
   							yyLex.value());
               yyToken = -1;
               goto continue_yyDiscarded;		// leave stack alone
             }
         }
         int yyV = yyTop + 1-yyLen[yyN];
         if (debug != null)
           debug.reduce(yyState, yyStates[yyV-1], yyN, YYRules.getRule (yyN), yyLen[yyN]);
         yyVal = yyV > yyTop ? null 
         switch (yyN) {
 	| interactive_parsing  { Lexer.CompleteOnEOF = false; } opt_EOF
 	;
 
 opt_EOF
 	
 	  {
 		Lexer.check_incorrect_doc_comment ();
 	  }
 	| EOF
 	  {
 		Lexer.check_incorrect_doc_comment ();
 	  }
 	;
 
 outer_declarations
 	
 	| outer_declarations outer_declaration
 	;
  
 outer_declaration
 	
 	| using_directive 
 	| namespace_member_declaration
 	;
 
 extern_alias_directives
 	
 	| extern_alias_directives extern_alias_directive
 	;
 
 extern_alias_directive
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		string s = lt.Value;
 		if (s != "alias"){
 			syntax_error (lt.Location, "`alias' expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (lt.Location, "external alias");
 		} else {
 			lt = (Tokenizer.LocatedToken) $3; 
 			current_namespace.AddUsingExternalAlias (lt.Value, lt.Location, Report);
 		}
 	  }
 	| EXTERN_ALIAS error
 	  {
 	  	syntax_error (GetLocation ($1), "`alias' expected");   // TODO
 	  }
 	;
  
 using_directives
 	
 	| using_directives using_directive
 	;
 
 using_directive
 	
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	| using_namespace_directive
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	;
 
 using_alias_directive
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		current_namespace.AddUsingAlias (lt.Value, (MemberName) $4, GetLocation ($1));
 	  }
 	| USING error
 	 {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 
 using_namespace_directive
 	
 	  {
 		current_namespace.AddUsing ((MemberName) $2, GetLocation ($1));
 	  }
 	;
 
 //
 // Strictly speaking, namespaces don't have attributes but
 // we parse global attributes along with namespace declarations and then
 // detach them
 // 
 namespace_declaration
 	
 	  {
 		MemberName name = (MemberName) $3;
 
 		if ($1 != null) {
 			Report.Error(1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
 		}
 
 		current_namespace = new NamespaceEntry (module,
 			current_namespace, file, name.GetName ());
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  } 
 	  namespace_body opt_semicolon
 	  { 
 		current_namespace = current_namespace.Parent;
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
 	;
 
 qualified_identifier
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new MemberName (lt.Value, lt.Location);
 	  }
 	| qualified_identifier DOT IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberName ((MemberName) $1, lt.Value, lt.Location);		
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = new MemberName ("<invalid>", lexer.Location);
 	  }
 	;
 
 opt_semicolon
 	
 	| SEMICOLON
 	;
 
 opt_comma
 	
 	| COMMA
 	;
 
 namespace_name
 	
 	 {
 		MemberName name = (MemberName) $1;
 
 		if (name.TypeArguments != null)
 			syntax_error (lexer.Location, "namespace name expected");
 
 		$$ = name;
 	  }
 	;
 
 namespace_body
 	
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_extern_alias_directives
 	  opt_using_directives
 	  opt_namespace_member_declarations
 	  CLOSE_BRACE
 	;
 
 opt_using_directives
 	
 	| using_directives
 	;
 
 opt_extern_alias_directives
 	
 	| extern_alias_directives
 	;
 
 opt_namespace_member_declarations
 	
 	| namespace_member_declarations
 	;
 
 namespace_member_declarations
 	
 	| namespace_member_declarations namespace_member_declaration
 	;
 
 namespace_member_declaration
 	
 	  {
 		if ($1 != null) {
 			DeclSpace ds = (DeclSpace)$1;
 
 			if ((ds.ModFlags & (Modifiers.PRIVATE|Modifiers.PROTECTED)) != 0){
 				Report.Error (1527, ds.Location, 
 				"Namespace elements cannot be explicitly declared as private, protected or protected internal");
 			}
 		}
 		current_namespace.DeclarationFound = true;
 	  }
 	| namespace_declaration
 	  {
 		current_namespace.DeclarationFound = true;
 	  }
 	| error
 	 {
 		Error_SyntaxError (yyToken);
 	 }
 	;
 
 type_declaration
 	
 	| struct_declaration
 	| interface_declaration
 	| enum_declaration		
 	| delegate_declaration
 //
 // Enable this when we have handled all errors, because this acts as a generic fallback
 //
 //	| error {
 //		Console.WriteLine ("Token=" + yyToken);
 //		Report.Error (1518, GetLocation ($1), "Expected class, struct, interface, enum or delegate");
 //	  }
 	;
 
 //
 // Attributes 17.2
 //
 
 global_attributes
 	
 	  {
 		if ($1 != null) {
 			Attributes attrs = (Attributes)$1;
 			if (global_attrs_enabled) {
 				module.AddAttributes (attrs.Attrs, current_namespace);
 			} else {
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 			}
 		}
 		$$ = $1;
 	  }
 	;
 
 opt_attributes
 	
 	  {
 		global_attrs_enabled = false;
 		$$ = null;
       }
 	| attribute_sections
 	  { 
 		global_attrs_enabled = false;
 		$$ = $1;
 	  }
     ;
  
 
 attribute_sections
 	
 	  {
 		if (current_attr_target != String.Empty) {
 			var sect = (List<Attribute>) $1;
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect, current_namespace);
 					$$ = null;
 				} else {
 					$$ = new Attributes (sect);
 				}
 				if ($$ == null) {
 					if (RootContext.Documentation != null) {
 						Lexer.check_incorrect_doc_comment ();
 						Lexer.doc_state =
 							XmlCommentState.Allowed;
 					}
 				}
 			} else {
 				$$ = new Attributes (sect);
 			}		
 		}
 		else
 			$$ = null;
 		current_attr_target = null;
 	  }
 	| attribute_sections attribute_section
 	  {
 		if (current_attr_target != String.Empty) {
 			Attributes attrs = $1 as Attributes;
 			var sect = (List<Attribute>) $2;
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect);
 					$$ = null;
 				} else {
 					if (attrs == null)
 						attrs = new Attributes (sect);
 					else
 						attrs.AddAttributes (sect);			
 				}
 			} else {
 				if (attrs == null)
 					attrs = new Attributes (sect);
 				else
 					attrs.AddAttributes (sect);
 			}		
 			$$ = attrs;
 		}
 		else
 			$$ = null;
 		current_attr_target = null;
 	  }
 	;
 
 attribute_section
 	
 	  {
 		$$ = $3;
  	  }
 	| OPEN_BRACKET attribute_list opt_comma CLOSE_BRACKET
 	  {
 		$$ = $2;
 	  }
 	;
  
 attribute_target_specifier
 	
 	  {
 		current_attr_target = (string)$1;
 		$$ = $1;
 	  }
 	;
 
 attribute_target
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = CheckAttributeTarget (lt.Value, lt.Location);
 	  }
 	| EVENT  { $$ = "event"; }
 	| RETURN { $$ = "return"; }
 	| error
 	  {
 		string name = GetTokenName (yyToken);
 		$$ = CheckAttributeTarget (name, GetLocation ($1));
 	  }
 	;
 
 attribute_list
 	
 	  {
 		$$ = new List<Attribute> (4) { (Attribute) $1 };
 	  }
 	| attribute_list COMMA attribute
 	  {
 		var attrs = (List<Attribute>) $1;
 		attrs.Add ((Attribute) $3);
 
 		$$ = attrs;
 	  }
 	;
 
 attribute
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  opt_attribute_arguments
 	  {
 		--lexer.parsing_block;
 		MemberName mname = (MemberName) $1;
 		if (mname.IsGeneric) {
 			Report.Error (404, lexer.Location,
 				      "'<' unexpected
 		}
 
 		Arguments [] arguments = (Arguments []) $3;
 		ATypeNameExpression expr = mname.GetTypeExpression ();
 
 		if (current_attr_target == String.Empty)
 			$$ = null;
 		else if (global_attrs_enabled && (current_attr_target == "assembly" || current_attr_target == "module"))
 			// FIXME
 			$$ = new GlobalAttribute (current_namespace, current_attr_target,
 						  expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 		else
 			$$ = new Attribute (current_attr_target, expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 	  }
 	;
 
 attribute_name
 	
 	;
 
 opt_attribute_arguments
 	
 	| OPEN_PARENS attribute_arguments CLOSE_PARENS
 	  {
 		$$ = $2;
 	  }
 	;
 
 
 attribute_arguments
 	
 	| positional_or_named_argument
 	  {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) $1);
 		$$ = new Arguments [] { a, null };
 	  }
 	| named_attribute_argument
 	  {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) $1);  
 		$$ = new Arguments [] { null, a };
 	  }
     | attribute_arguments COMMA positional_or_named_argument
 	  {
 		Arguments[] o = (Arguments[]) $1;
 		if (o [1] != null) {
 			Report.Error (1016, ((Argument) $3).Expr.Location, "Named attribute arguments must appear after the positional arguments");
 			o [0] = new Arguments (4);
 		}
 		
 		Arguments args = ((Arguments) o [0]);
 		if (args.Count > 0 && !($3 is NamedArgument) && args [args.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 		
 		args.Add ((Argument) $3);
 	  }
     | attribute_arguments COMMA named_attribute_argument
 	  {
 		Arguments[] o = (Arguments[]) $1;
 		if (o [1] == null) {
 			o [1] = new Arguments (4);
 		}
 
 		((Arguments) o [1]).Add ((Argument) $3);
 	  }
     ;
 
 positional_or_named_argument
 	
 	  {
 	  	$$ = new Argument ((Expression) $1);
 	  }
 	| named_argument
 	;
 
 named_attribute_argument
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  expression
 	  {
 	  	--lexer.parsing_block;
 	  	var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new NamedArgument (lt.Value, lt.Location, (Expression) $4);	  
 	  }
 	;
 	
 named_argument
 	
 	  {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "named argument");
 			
 		// Avoid boxing in common case (no modifier)
 		var arg_mod = $3 == null ? Argument.AType.None 
 			
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new NamedArgument (lt.Value, lt.Location, (Expression) $4, arg_mod);
 	  }
 	;
 	
 opt_named_modifier
 	
 	| REF
 	  { 
 		$$ = Argument.AType.Ref;
 	  }
 	| OUT
 	  { 
 		$$ = Argument.AType.Out;
 	  }
 	;
 		  
 opt_class_member_declarations
 	
 	| class_member_declarations
 	;
 
 class_member_declarations
 	
 	| class_member_declarations 
 	  class_member_declaration
 	;
 
 class_member_declaration
 	
 	| field_declaration			// done
 	| method_declaration			// done
 	| property_declaration			// done
 	| event_declaration			// done
 	| indexer_declaration			// done
 	| operator_declaration			// done
 	| constructor_declaration		// done
 	| destructor_declaration		// done
 	| type_declaration
 	| error
 	  {
 		Report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
 			GetSymbolName (yyToken));
 		$$ = null;
 		lexer.parsing_generic_declaration = false;
 	  }
 	;
 
 struct_declaration
 	
 	  opt_modifiers
 	  opt_partial
 	  STRUCT
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  type_declaration_name
 	  { 
 		MemberName name = MakeName ((MemberName) $6);
 		push_current_class (new Struct (current_namespace, current_class, name, (Modifiers) $2, (Attributes) $1), $3);
 	  }
 	  opt_class_base
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) $9);
 
 		if (RootContext.Documentation != null)
 			current_container.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (current_class, mod_locations, GetLocation ($4));
 	  }
 	  struct_body
 	  {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_semicolon
 	  {
 		lbag.AppendToMember (current_class, GetLocation ($13));
 		$$ = pop_current_class ();
 	  }
 	| opt_attributes opt_modifiers opt_partial STRUCT error
 	  {
 		Error_SyntaxError (yyToken);
 	  }
 	;
 
 struct_body
 	
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_struct_member_declarations CLOSE_BRACE
 	  {
 		lbag.AppendToMember (current_class, GetLocation ($1), GetLocation ($4));
 	  }
 	;
 
 opt_struct_member_declarations
 	
 	| struct_member_declarations
 	;
 
 struct_member_declarations
 	
 	| struct_member_declarations struct_member_declaration
 	;
 
 struct_member_declaration
 	
 	| field_declaration
 	| method_declaration
 	| property_declaration
 	| event_declaration
 	| indexer_declaration
 	| operator_declaration
 	| constructor_declaration
 	| type_declaration
 
 	/*
 	 * This is only included so we can flag error 575
 	 * destructors only allowed on class types
 	 */
 	| destructor_declaration 
 	;
 	
 constant_declaration
 	
 	  opt_modifiers
 	  CONST type IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $5;
 		var mod = (Modifiers) $2;
 		current_field = new Const (current_class, (FullNamedExpression) $4, mod, new MemberName (lt.Value, lt.Location), (Attributes) $1);
 		current_container.AddConstant ((Const) current_field);
 		
 		if ((mod & Modifiers.STATIC) != 0) {
 			Report.Error (504, current_field.Location, "The constant `{0}' cannot be marked static", current_field.GetSignatureForError ());
 		}
 		
 		$$ = current_field;
 	  }
 	  constant_initializer opt_constant_declarators SEMICOLON
 	  {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		current_field.Initializer = (ConstInitializer) $7;
 		lbag.AddMember (current_field, mod_locations, GetLocation ($3), GetLocation ($9));
 		current_field = null;
 	  }
 	;
 	
 opt_constant_declarators
 	
 	| constant_declarators
 	;
 	
 constant_declarators
 	
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $1);
 	  }
 	| constant_declarators constant_declarator
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $2);
 	  }
 	;
 	
 constant_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) $3);
 	  	lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	;		
 
 constant_initializer
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  constant_initializer_expr
 	  {
 		--lexer.parsing_block;
 		$$ = new ConstInitializer (current_field, (Expression) $3, GetLocation ($1));
 	  }
 	| error
 	  {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 		$$ = null;
 	  }	  
 	;
 	
 constant_initializer_expr
 	
 	| array_initializer
 	;
 
 field_declaration
 	
 	  opt_modifiers
 	  member_type IDENTIFIER
 	  {
 	  	lexer.parsing_generic_declaration = false;
 
 		FullNamedExpression type = (FullNamedExpression) $3;
 		if (type.Type == TypeManager.void_type)
 			Report.Error (670, GetLocation ($3), "Fields cannot have void type");
 			
 		var lt = (Tokenizer.LocatedToken) $4;
 		current_field = new Field (current_class, type, (Modifiers) $2, new MemberName (lt.Value, lt.Location), (Attributes) $1);
 		current_container.AddField (current_field);
 		$$ = current_field;
 	  }
 	  opt_field_initializer
 	  opt_field_declarators
 	  SEMICOLON
 	  { 
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 			
 		lbag.AddMember (current_field, mod_locations, GetLocation ($8));
 		$$ = current_field;
 		current_field = null;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  FIXED simple_type IDENTIFIER
 	  { 
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($3), "fixed size buffers");
 
 		var lt = (Tokenizer.LocatedToken) $5;
 		current_field = new FixedField (current_class, (FullNamedExpression) $4, (Modifiers) $2,
 			new MemberName (lt.Value, lt.Location), (Attributes) $1);
 			
 		current_container.AddField (current_field);
 	  }
 	  fixed_field_size opt_fixed_field_declarators SEMICOLON
 	  {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 	    }
 
 		current_field.Initializer = (ConstInitializer) $7;	    
 		lbag.AddMember (current_field, mod_locations, GetLocation ($9));
 		$$ = current_field;
 	    current_field = null;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  FIXED simple_type error
 	  SEMICOLON
 	  {
 		Report.Error (1641, GetLocation ($5), "A fixed size buffer field must have the array size specifier after the field name");
 	  }
 	;
 	
 opt_field_initializer
 	
 	| ASSIGN
 	  {
 	  	++lexer.parsing_block;
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	start_block (GetLocation ($1));
 	  }
 	  variable_initializer
 	  {
 	  	--lexer.parsing_block;
 		current_field.Initializer = (Expression) $3;
 		end_block (lexer.Location);
 		current_local_parameters = null;
 	  }
 	;
 	
 opt_field_declarators
 	
 	| field_declarators
 	;
 	
 field_declarators
 	
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $1);
 	  }
 	| field_declarators field_declarator
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $2);
 	  }
 	;
 	
 field_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	| COMMA IDENTIFIER ASSIGN
 	  {
 		++lexer.parsing_block;
 	  }
 	  variable_initializer
 	  {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) $2;	  
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) $5);
 	  	lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	;	
 
 opt_fixed_field_declarators
 	
 	| fixed_field_declarators
 	;
 	
 fixed_field_declarators
 	
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $1);
 	  }
 	| fixed_field_declarators fixed_field_declarator
 	  {
 		current_field.AddDeclarator ((FieldDeclarator) $2);
 	  }
 	;
 	
 fixed_field_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;	  
 		$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) $3);
 		lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	;
 
 fixed_field_size
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  expression CLOSE_BRACKET
 	  {
 		--lexer.parsing_block;
 		$$ = new ConstInitializer (current_field, (Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	| OPEN_BRACKET error
 	  {
 		Report.Error (443, lexer.Location, "Value or constant expected");
 		$$ = null;
 	  }	  
 	;
 
 variable_initializer
 	
 	| array_initializer
 	| error
 	  {
 		// It has to be here for the parent to safely restore artificial block
 	  	Error_SyntaxError (yyToken);
 	  	$$ = null;
 	  }
 	;
 
 method_declaration
 	
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
 	  method_body
 	  {
 		Method method = (Method) $1;
 		method.Block = (ToplevelBlock) $3;
 		current_container.AddMethod (method);
 		
 		if (current_container.Kind == MemberKind.Interface && method.Block != null) {
 			Report.Error (531, method.Location, "`{0}'
 		}
 
 		current_local_parameters = null;
 
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	;
 
 method_header
 	
 	  opt_modifiers
 	  member_type
 	  method_declaration_name OPEN_PARENS
 	  {
 		valid_param_mod = ParameterModifierType.All;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 		MemberName name = (MemberName) $4;
 		current_local_parameters = (ParametersCompiled) $7;
 
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 						     (FullNamedExpression) $3, current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) $10);
 		} else if ($10 != null) {
 			Report.Error (80, GetLocation ($10),
 				"Constraints are not allowed on non-generic declarations");
 		}
 
 		Method method = new Method (current_class, generic, (FullNamedExpression) $3, (Modifiers) $2,
 				     name, current_local_parameters, (Attributes) $1);
 				     
 		if ($10 != null && ((method.ModFlags & Modifiers.OVERRIDE) != 0 || method.IsExplicitImpl)) {
 			Report.Error (460, method.Location,
 				"`{0}'
 				method.GetSignatureForError ());
 		}
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (method, mod_locations, GetLocation ($5), GetLocation ($8));
 		$$ = method;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  PARTIAL
 	  VOID method_declaration_name
 	  OPEN_PARENS
 	  {
 	  	valid_param_mod = ParameterModifierType.All;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS 
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 
 		MemberName name = (MemberName) $5;
 		current_local_parameters = (ParametersCompiled) $8;
 
 		if ($10 != null && name.TypeArguments == null)
 			Report.Error (80, lexer.Location,
 				      "Constraints are not allowed on non-generic declarations");
 
 		Method method;
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 				new TypeExpression (TypeManager.void_type, GetLocation ($4)),
 				current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) $11);
 		}
 
 		var modifiers = (Modifiers) $2;
 
 
 		const Modifiers invalid_partial_mod = Modifiers.AccessibilityMask | Modifiers.ABSTRACT | Modifiers.EXTERN |
 			Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.SEALED | Modifiers.VIRTUAL;
 
 		if ((modifiers & invalid_partial_mod) != 0) {
 			Report.Error (750, name.Location, "A partial method cannot define access modifier or " +
        			"any of abstract, extern, new, override, sealed, or virtual modifiers");
 			modifiers &= ~invalid_partial_mod;
 		}
 
 		if ((current_class.ModFlags & Modifiers.PARTIAL) == 0) {
 			Report.Error (751, name.Location, "A partial method must be declared within a " +
        			"partial class or partial struct");
 		}
 		
 		modifiers |= Modifiers.PARTIAL | Modifiers.PRIVATE;
 		
 		method = new Method (current_class, generic, new TypeExpression (TypeManager.void_type, GetLocation ($4)),
 				     modifiers, name, current_local_parameters, (Attributes) $1);
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		// TODO
 		StoreModifierLocation (Modifiers.PARTIAL, GetLocation ($3));
 		lbag.AddMember (method, mod_locations, GetLocation ($6), GetLocation ($9));
 		$$ = method;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  member_type
 	  modifiers method_declaration_name OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS
 	  {
 		MemberName name = (MemberName) $5;
 		Report.Error (1585, name.Location, 
 			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) $4));
 
 		Method method = new Method (current_class, null, (FullNamedExpression) $3,
 					    0, name, (ParametersCompiled) $7, (Attributes) $1);
 
 		current_local_parameters = (ParametersCompiled) $7;
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		$$ = method;
 	  }
 	;
 
 method_body
 	
 	| SEMICOLON		{ $$ = null; }
 	;
 
 opt_formal_parameter_list
 	
 	| formal_parameter_list
 	;
 	
 formal_parameter_list
 	
 	  {
 		var pars_list = (List<Parameter>) $1;
 	  	$$ = new ParametersCompiled (pars_list.ToArray ());
 	  } 
 	| fixed_parameters COMMA parameter_array
 	  {
 		var pars_list = (List<Parameter>) $1;
 		pars_list.Add ((Parameter) $3);
 
 		$$ = new ParametersCompiled (pars_list.ToArray ()); 
 	  }
 	| fixed_parameters COMMA arglist_modifier
 	  {
 		var pars_list = (List<Parameter>) $1;
 		pars_list.Add (new ArglistParameter (GetLocation ($3)));
 		$$ = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
 	| parameter_array COMMA error
 	  {
 		if ($1 != null)
 			Report.Error (231, ((Parameter) $1).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		$$ = new ParametersCompiled (new Parameter[] { (Parameter) $1 } );			
 	  }
 	| fixed_parameters COMMA parameter_array COMMA error
 	  {
 		if ($3 != null)
 			Report.Error (231, ((Parameter) $3).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) $1;
 		pars_list.Add (new ArglistParameter (GetLocation ($3)));
 
 		$$ = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
 	| arglist_modifier COMMA error
 	  {
 		Report.Error (257, GetLocation ($1), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		$$ = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation ($1)) }, true);
 	  }
 	| fixed_parameters COMMA ARGLIST COMMA error 
 	  {
 		Report.Error (257, GetLocation ($3), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) $1;
 		pars_list.Add (new ArglistParameter (GetLocation ($3)));
 
 		$$ = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
 	| parameter_array 
 	  {
 		$$ = new ParametersCompiled (new Parameter[] { (Parameter) $1 } );
 	  }
 	| arglist_modifier
 	  {
 		$$ = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation ($1)) }, true);
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
 	;
 
 fixed_parameters
 	
 	  {
 		parameters_bucket.Clear ();
 		Parameter p = (Parameter) $1;
 		parameters_bucket.Add (p);
 		
 		default_parameter_used = p.HasDefaultValue;
 		$$ = parameters_bucket;
 	  }
 	| fixed_parameters COMMA fixed_parameter
 	  {
 		var pars = (List<Parameter>) $1;
 		Parameter p = (Parameter) $3;
 		if (p != null) {
 			if (p.HasExtensionMethodModifier)
 				Report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
 			else if (!p.HasDefaultValue && default_parameter_used)
 				Report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");
 
 			default_parameter_used |= p.HasDefaultValue;
 			pars.Add (p);
 			
 			lbag.AddLocation (p, GetLocation ($2));
 		}
 		
 		$$ = $1;
 	  }
 	;
 
 fixed_parameter
 	
 	  opt_parameter_modifier
 	  parameter_type
 	  IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $4;
 		$$ = new Parameter ((FullNamedExpression) $3, lt.Value, (Parameter.Modifier) $2, (Attributes) $1, lt.Location);
 	  }
 	| opt_attributes
 	  opt_parameter_modifier
 	  parameter_type
 	  IDENTIFIER OPEN_BRACKET CLOSE_BRACKET
 	  {
 		var lt = (Tokenizer.LocatedToken) $4;
 		Report.Error (1552, lt.Location, "Array type specifier, [], must appear before parameter name");
 		$$ = new Parameter ((FullNamedExpression) $3, lt.Value, (Parameter.Modifier) $2, (Attributes) $1, lt.Location);
 	  }
 	| opt_attributes
 	  opt_parameter_modifier
 	  parameter_type
 	  error
 	  {
 		Error_SyntaxError (yyToken);	  
 	  	Location l = GetLocation ($4);
 		$$ = new Parameter ((FullNamedExpression) $3, "NeedSomeGeneratorHere", (Parameter.Modifier) $2, (Attributes) $1, l);
 	  }
 	| opt_attributes
 	  opt_parameter_modifier
 	  parameter_type
 	  IDENTIFIER
 	  ASSIGN
 	  {
 	  	++lexer.parsing_block;
 	  }
 	  constant_expression
 	  {
 	  	--lexer.parsing_block;
 		if (RootContext.Version <= LanguageVersion.V_3) {
 			Report.FeatureIsNotAvailable (GetLocation ($5), "optional parameter");
 		}
 		
 		Parameter.Modifier mod = (Parameter.Modifier) $2;
 		if (mod != Parameter.Modifier.NONE) {
 			switch (mod) {
 			case Parameter.Modifier.REF
 			case Parameter.Modifier.OUT
 				Report.Error (1741, GetLocation ($2), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 				
 			case Parameter.Modifier.This
 				Report.Error (1743, GetLocation ($2), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 			default
 				throw new NotImplementedException (mod.ToString ());
 			}
 				
 			mod = Parameter.Modifier.NONE;
 		}
 		
 		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
 			Report.Error (1065, GetLocation ($5), "Optional parameter is not valid in this context");
 		
 		var lt = (Tokenizer.LocatedToken) $4;
 		$$ = new Parameter ((FullNamedExpression) $3, lt.Value, mod, (Attributes) $1, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($5));
 		
 		if ($7 != null)
 			((Parameter) $$).DefaultValue = new DefaultParameterValueExpression ((Expression) $7);
 	  }
 	;
 
 opt_parameter_modifier
 	
 	| parameter_modifiers
 	;
 
 parameter_modifiers
 	
 	  {
 		$$ = $1;
 	  }
 	| parameter_modifiers parameter_modifier
 	  {
 		Parameter.Modifier p2 = (Parameter.Modifier)$2;
   		Parameter.Modifier mod = (Parameter.Modifier)$1 | p2;
   		if (((Parameter.Modifier)$1 & p2) == p2) {
   			Error_DuplicateParameterModifier (lexer.Location, p2);
   		} else {
 	  		switch (mod & ~Parameter.Modifier.This) {
   				case Parameter.Modifier.REF
 					Report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
   					break;
    				case Parameter.Modifier.OUT
 					Report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
   					break;
   				default
  					Report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
  					break;
  			}
   		}
   		$$ = mod;
 	  }
 	;
 
 parameter_modifier
 	
 	  {
 	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
 	  		Error_ParameterModifierNotValid ("ref", GetLocation ($1));
 	  		
 	  	$$ = Parameter.Modifier.REF;
 	  }
 	| OUT
 	  {
 	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
 	  		Error_ParameterModifierNotValid ("out", GetLocation ($1));
 	  
 	  	$$ = Parameter.Modifier.OUT;
 	  }
 	| THIS
 	  {
 		if ((valid_param_mod & ParameterModifierType.This) == 0)
 	  		Error_ParameterModifierNotValid ("this", GetLocation ($1));
 
 	  	if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation ($1), "extension methods");
 	  			
 		$$ = Parameter.Modifier.This;
 	  }
 	;
 
 parameter_array
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $4;
 		$$ = new ParamsParameter ((FullNamedExpression) $3, lt.Value, (Attributes) $1, lt.Location);
 	  }
 	| opt_attributes params_modifier type IDENTIFIER ASSIGN constant_expression
 	  {
 		Report.Error (1751, GetLocation ($2), "Cannot specify a default value for a parameter array");
 		
 		var lt = (Tokenizer.LocatedToken) $4;
 		$$ = new ParamsParameter ((FullNamedExpression) $3, lt.Value, (Attributes) $1, lt.Location);		
 	  }
 	| opt_attributes params_modifier type error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 	
 params_modifier
 	
 	  {
 		if ((valid_param_mod & ParameterModifierType.Params) == 0)
 			Report.Error (1670, (GetLocation ($1)), "The `params' modifier is not allowed in current context");
 	  }
 	| PARAMS parameter_modifier
 	  {
 		Parameter.Modifier mod = (Parameter.Modifier)$2;
 		if ((mod & Parameter.Modifier.This) != 0) {
 			Report.Error (1104, GetLocation ($1), "The parameter modifiers `this' and `params' cannot be used altogether");
 		} else {
 			Report.Error (1611, GetLocation ($1), "The params parameter cannot be declared as ref or out");
 		}	  
 	  }
 	| PARAMS params_modifier
 	  {
 		Error_DuplicateParameterModifier (GetLocation ($1), Parameter.Modifier.PARAMS);
 	  }
 	;
 	
 arglist_modifier
 	
 	  {
 	  	if ((valid_param_mod & ParameterModifierType.Arglist) == 0)
 	  		Report.Error (1669, GetLocation ($1), "__arglist is not valid in this context");
 	  }
 	;
 	
 property_declaration
 	
 	  opt_modifiers
 	  member_type
 	  member_declaration_name
 	  {
 		if (RootContext.Documentation != null)
 			tmpComment = Lexer.consume_doc_comment ();
 	  }
 	  OPEN_BRACE
 	  {
 		current_property = new Property (current_class, (FullNamedExpression) $3, (Modifiers) $2,
 			(MemberName) $4, (Attributes) $1);
 			
 		if (current_property.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (547, GetLocation ($3), "`{0}'
 			
 		current_container.AddProperty ((Property)current_property);
 		lbag.AddMember (current_property, mod_locations, GetLocation ($6));
 		
 		lexer.PropertyParsing = true;
 	  }
 	  accessor_declarations 
 	  {
 		lexer.PropertyParsing = false;
 		
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();				
 	  }
 	  CLOSE_BRACE
 	  {
 		lbag.AppendToMember (current_property, GetLocation ($10));
 		current_property = null;
 	  }
 	;
 
 
 indexer_declaration
 	
 	  member_type indexer_declaration_name OPEN_BRACKET
 	  {
 	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_BRACKET OPEN_BRACE
 	  {
 		valid_param_mod = 0;
 	  
 		Indexer indexer = new Indexer (current_class, (FullNamedExpression) $3,
 			(MemberName)$4, (Modifiers) $2, (ParametersCompiled) $7, (Attributes) $1);
 			
 		current_property = indexer;
 
   		current_container.AddIndexer (indexer);
 		lbag.AddMember (current_property, mod_locations, GetLocation ($5), GetLocation ($8), GetLocation ($9));
   		
 		if (indexer.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (620, GetLocation ($3), "`{0}'
 
 		if (indexer.Parameters.IsEmpty) {
 			Report.Error (1551, GetLocation ($5), "Indexers must have at least one parameter");
 		}
 
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		lexer.PropertyParsing = true;
 	  }
 	  accessor_declarations 
 	  {
 		  lexer.PropertyParsing = false;
 	  }
 	  CLOSE_BRACE
 	  { 
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();
 			
 		lbag.AppendToMember (current_property, GetLocation ($12));
 		current_property = null;		
 	  }
 	;
 
 
 accessor_declarations
 	
 	| get_accessor_declaration accessor_declarations
 	| set_accessor_declaration
 	| set_accessor_declaration accessor_declarations
 	| error
 	  {
 	  	if (yyToken == Token.CLOSE_BRACE) {
 	  		Report.Error (548, lexer.Location, "`{0}'
 		} else {
 			if (yyToken == Token.SEMICOLON)
 				Report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
 			else
 				Report.Error (1014, GetLocation ($1), "A get or set accessor expected");
 		}
 	  }
 	;
 
 get_accessor_declaration
 	
 	  {
 		if ($2 != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation ($2), "access modifiers on properties");
 		}
 	  
 		if (current_property.Get != null) {
 			Report.Error (1007, GetLocation ($3), "Property accessor already defined");
 		}
 		
 		if (current_property is Indexer) {
 			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) $2, ((Indexer)current_property).ParameterInfo.Clone (),
 				(Attributes) $1, GetLocation ($3));
 		} else {
 			current_property.Get = new Property.GetMethod (current_property,
 				(Modifiers) $2, (Attributes) $1, GetLocation ($3));
 		}	
 	  
 		current_local_parameters = current_property.Get.ParameterInfo;	  
 		lbag.AddMember (current_property.Get, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
 	  accessor_body
 	  {
 	  	if ($5 != null) {
 	  		current_property.Get.Block = (ToplevelBlock) $5;			
 	  	
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Get.Block.StartLocation,
 					"`{0}'
 			}		
 		}
 	  
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null)
 			if (Lexer.doc_state == XmlCommentState.Error)
 				Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
 	;
 
 set_accessor_declaration
 	
 	  {
 		if ($2 != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation ($2), "access modifiers on properties");
 		}
 		
 		if (current_property.Set != null) {
 			Report.Error (1007, GetLocation ($3), "Property accessor already defined");
 		}
 	  
 		if (current_property is Indexer) {
 			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) $2,
 				ParametersCompiled.MergeGenerated (compiler,
 				((Indexer)current_property).ParameterInfo, true, new Parameter (
 					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation ($3)),
 					null),
 				(Attributes) $1, GetLocation ($3));
 		} else {
 			current_property.Set = new Property.SetMethod (current_property, (Modifiers) $2, 
 				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation ($3)),
 				(Attributes) $1, GetLocation ($3));
 		}
 		
 		current_local_parameters = current_property.Set.ParameterInfo;	
 		lbag.AddMember (current_property.Set, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
 	  accessor_body
 	  {
 		if ($5 != null) {		
 			current_property.Set.Block = (ToplevelBlock) $5;
 		
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Set.Block.StartLocation,
 					"`{0}'
 			}
 		}
 		
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null
 			&& Lexer.doc_state == XmlCommentState.Error)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
 	;
 
 accessor_body
 	
 	| SEMICOLON
 	  {
 		// TODO
 	  	$$ = null;
 	  }
 	| error
 	  {
 	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
 	  	$$ = null;
 	  }
 	;
 
 interface_declaration
 	
 	  opt_modifiers
 	  opt_partial
 	  INTERFACE
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  type_declaration_name
 	  {
 		MemberName name = MakeName ((MemberName) $6);
 		push_current_class (new Interface (current_namespace, current_class, name, (Modifiers) $2, (Attributes) $1), $3);
 		lbag.AddMember (current_class, mod_locations, GetLocation ($4));		
 	  }
 	  opt_class_base
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) $9);
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
 	  OPEN_BRACE opt_interface_member_declarations CLOSE_BRACE
 	  {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_semicolon 
 	  {
 	    lbag.AppendToMember (current_class, GetLocation ($11), GetLocation ($13));
 		$$ = pop_current_class ();
 	  }
 	| opt_attributes opt_modifiers opt_partial INTERFACE error
 	  {
 		Error_SyntaxError (yyToken);	  
 	  }
 	;
 
 opt_interface_member_declarations
 	
 	| interface_member_declarations
 	;
 
 interface_member_declarations
 	
 	| interface_member_declarations interface_member_declaration
 	;
 
 interface_member_declaration
 	
 	  {
 		Report.Error (525, GetLocation ($1), "Interfaces cannot contain fields or constants");
 	  }
 	| field_declaration
 	  {
 		Report.Error (525, GetLocation ($1), "Interfaces cannot contain fields or constants");
 	  }
 	| method_declaration
 	| property_declaration
 	| event_declaration
 	| indexer_declaration
 	| operator_declaration
 	  {
 	  	Report.Error (567, GetLocation ($1), "Interfaces cannot contain operators");
 	  }
 	| constructor_declaration
 	  {
 	  	Report.Error (526, GetLocation ($1), "Interfaces cannot contain contructors");
 	  }
 	| type_declaration
 	  {
 	  	Report.Error (524, GetLocation ($1), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
 	  }
 	;
 
 operator_declaration
 	
 	  {
 	  }
 	  operator_body
 	  {
 		OperatorDeclaration decl = (OperatorDeclaration) $3;
 		if (decl != null) {
 			Operator op = new Operator (
 				current_class, decl.optype, decl.ret_type, (Modifiers) $2, 
 				current_local_parameters,
 				(ToplevelBlock) $5, (Attributes) $1, decl.location);
 
 			if (RootContext.Documentation != null) {
 				op.DocComment = tmpComment;
 				Lexer.doc_state = XmlCommentState.Allowed;
 			}
 
 			// Note again, checking is done in semantic analysis
 			current_container.AddOperator (op);
 
 			lbag.AddMember (op, mod_locations, lbag.GetLocations (decl));
 		}
 		
 		current_local_parameters = null;
 	  }
 	;
 
 operator_body 
 	
 	| SEMICOLON { $$ = null; }
 	; 
 
 operator_type
 	
 	| VOID
 	  {
 		Report.Error (590, GetLocation ($1), "User-defined operators cannot return void");
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }
 	;
 
 operator_declarator
 	
 	  {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation ($2);
 		Operator.OpType op = (Operator.OpType) $3;
 		current_local_parameters = (ParametersCompiled)$6;
 		
 		int p_count = current_local_parameters.Count;
 		if (p_count == 1) {
 			if (op == Operator.OpType.Addition)
 				op = Operator.OpType.UnaryPlus;
 			else if (op == Operator.OpType.Subtraction)
 				op = Operator.OpType.UnaryNegation;
 		}
 		
 		if (IsUnaryOperator (op)) {
 			if (p_count == 2) {
 				Report.Error (1020, loc, "Overloadable binary operator expected");
 			} else if (p_count != 1) {
 				Report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
 					Operator.GetName (op));
 			}
 		} else {
 			if (p_count > 2) {
 				Report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
 					Operator.GetName (op));
 			} else if (p_count != 2) {
 				Report.Error (1019, loc, "Overloadable unary operator expected");
 			}
 		}
 		
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		$$ = new OperatorDeclaration (op, (FullNamedExpression) $1, loc);
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($3), GetLocation ($4), GetLocation ($7));
 	  }
 	| conversion_operator_declarator
 	;
 
 overloadable_operator
 // Unary operators
 	
         | TILDE  { $$ = Operator.OpType.OnesComplement; }  
         | OP_INC { $$ = Operator.OpType.Increment; }
         | OP_DEC { $$ = Operator.OpType.Decrement; }
         | TRUE   { $$ = Operator.OpType.True; }
         | FALSE  { $$ = Operator.OpType.False; }
 // Unary and binary
         | PLUS { $$ = Operator.OpType.Addition; }
         | MINUS { $$ = Operator.OpType.Subtraction; }
 // Binary
         | STAR { $$ = Operator.OpType.Multiply; }
         | DIV {  $$ = Operator.OpType.Division; }
         | PERCENT { $$ = Operator.OpType.Modulus; }
         | BITWISE_AND { $$ = Operator.OpType.BitwiseAnd; }
         | BITWISE_OR { $$ = Operator.OpType.BitwiseOr; }
         | CARRET { $$ = Operator.OpType.ExclusiveOr; }
         | OP_SHIFT_LEFT { $$ = Operator.OpType.LeftShift; }
         | OP_SHIFT_RIGHT { $$ = Operator.OpType.RightShift; }
         | OP_EQ { $$ = Operator.OpType.Equality; }
         | OP_NE { $$ = Operator.OpType.Inequality; }
         | OP_GT { $$ = Operator.OpType.GreaterThan; }
         | OP_LT { $$ = Operator.OpType.LessThan; }
         | OP_GE { $$ = Operator.OpType.GreaterThanOrEqual; }
         | OP_LE { $$ = Operator.OpType.LessThanOrEqual; }
 	;
 
 conversion_operator_declarator
 	
 	  {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation ($2);
 		current_local_parameters = (ParametersCompiled)$6;  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		$$ = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) $3, loc);
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($2), GetLocation ($4), GetLocation ($7));
 	  }
 	| EXPLICIT OPERATOR type OPEN_PARENS
 	  {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 		
 		Location loc = GetLocation ($2);
 		current_local_parameters = (ParametersCompiled)$6;  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		$$ = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) $3, loc);
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($2), GetLocation ($4), GetLocation ($7));
 	  }
 	| IMPLICIT error 
 	  {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 		$$ = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation ($1));
 	  }
 	| EXPLICIT error 
 	  {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	$$ = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation ($1));
 	  }
 	;
 
 constructor_declaration
 	
 	  constructor_body
 	  { 
 		Constructor c = (Constructor) $1;
 		c.Block = (ToplevelBlock) $2;
 		
 		if (RootContext.Documentation != null)
 			c.DocComment = ConsumeStoredComment ();
 
 		current_container.AddConstructor (c);
 
 		current_local_parameters = null;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	;
 
 constructor_declarator
 	
 	  opt_modifiers
 	  IDENTIFIER
 	  {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		valid_param_mod = ParameterModifierType.All;
 	  }
 	  OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 		current_local_parameters = (ParametersCompiled) $6;  
 		
 		//
 		// start block here, so possible anonymous methods inside
 		// constructor initializer can get correct parent block
 		//
 	  	start_block (lexer.Location);
 	  }
 	  opt_constructor_initializer
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		var mods = (Modifiers) $2;
 		ConstructorInitializer ci = (ConstructorInitializer) $9;
 
 		Constructor c = new Constructor (current_class, lt.Value, mods,
 			(Attributes) $1, current_local_parameters, ci, lt.Location);
 		
 		if (lt.Value != current_container.MemberName.Name) {
 			Report.Error (1520, c.Location, "Class, struct, or interface method must have a return type");
 		} else if ((mods & Modifiers.STATIC) != 0) {
 			if ((mods & Modifiers.AccessibilityMask) != 0){
 				Report.Error (515, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			}
 			if (ci != null) {
 				Report.Error (514, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			
 			}
 		}
 		
 		lbag.AddMember (c, mod_locations, GetLocation ($5), GetLocation ($7));
 		$$ = c;
 	  }
 	;
 
 constructor_body
 	
 	| SEMICOLON 		{ current_block = null; $$ = null; }
 	;
 
 opt_constructor_initializer
 	
 	| constructor_initializer
 	;
 
 constructor_initializer
 	
 	  {
 		++lexer.parsing_block;
 	  }
 	  opt_argument_list CLOSE_PARENS
 	  {
 	  	--lexer.parsing_block;
 		$$ = new ConstructorBaseInitializer ((Arguments) $5, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3), GetLocation ($6));
 	  }
 	| COLON THIS OPEN_PARENS
 	  {
 		++lexer.parsing_block;
 	  }
 	  opt_argument_list CLOSE_PARENS
 	  {
 	  	--lexer.parsing_block;
 		$$ = new ConstructorThisInitializer ((Arguments) $5, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3), GetLocation ($6));
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 
 destructor_declaration
 	
 	  {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 		
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
 	  IDENTIFIER OPEN_PARENS CLOSE_PARENS method_body
 	  {
 		var lt = (Tokenizer.LocatedToken) $5;
 		if (lt.Value != current_container.MemberName.Name){
 			Report.Error (574, lt.Location, "Name of destructor must match name of class");
 		} else if (current_container.Kind != MemberKind.Class){
 			Report.Error (575, lt.Location, "Only class types can contain destructor");
 		}
 		
 		Destructor d = new Destructor (current_class, (Modifiers) $2,
 			ParametersCompiled.EmptyReadOnlyParameters, (Attributes) $1, lt.Location);
 		if (RootContext.Documentation != null)
 			d.DocComment = ConsumeStoredComment ();
 		  
 		d.Block = (ToplevelBlock) $8;
 		current_container.AddMethod (d);
 		lbag.AddMember (d, mod_locations, GetLocation ($3), GetLocation ($6), GetLocation ($7));
 
 		current_local_parameters = null;
 	  }
 	;
 
 event_declaration
 	
 	  opt_modifiers
 	  EVENT type member_declaration_name
 	  {
 		current_event_field = new EventField (current_class, (FullNamedExpression) $4, (Modifiers) $2, (MemberName) $5, (Attributes) $1);
 		current_container.AddEvent (current_event_field);
 		
 		if (current_event_field.MemberName.Left != null) {
 			Report.Error (71, current_event_field.Location, "`{0}'
 			current_event_field.GetSignatureForError ());
 		}
 		
 		$$ = current_event_field;
 	  }
 	  opt_event_initializer
 	  opt_event_declarators
 	  SEMICOLON
 	  {
 		if (RootContext.Documentation != null) {
 			current_event_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AddMember (current_event_field, mod_locations, GetLocation ($3), GetLocation ($9));
 		current_event_field = null;
 	  }
 	| opt_attributes
 	  opt_modifiers
 	  EVENT type member_declaration_name
 	  OPEN_BRACE
 	  {
 		current_event = new EventProperty (current_class, (FullNamedExpression) $4, (Modifiers) $2, (MemberName) $5, (Attributes) $1);
 		current_container.AddEvent (current_event);
 		lbag.AddMember (current_event, mod_locations, GetLocation ($3), GetLocation ($6));
 		
 		lexer.EventParsing = true;
 	  }
 	  event_accessor_declarations
 	  {
 		if (current_container.Kind == MemberKind.Interface)
 			Report.Error (69, GetLocation ($6), "Event in interface cannot have add or remove accessors");
 	  
 		lexer.EventParsing = false;
 	  }
 	  CLOSE_BRACE
 	  {
 		if (RootContext.Documentation != null) {
 			current_event.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AppendToMember (current_event, GetLocation ($9));
 	  	current_event = null;	
 		current_local_parameters = null;
 	  }
 	;
 	
 opt_event_initializer
 	
 	| ASSIGN
 	  {
 	  	++lexer.parsing_block;
 	  }
 	  event_variable_initializer
 	  {
 	  	--lexer.parsing_block;
 		current_event_field.Initializer = (Expression) $3;
 	  }
 	;
 	
 opt_event_declarators
 	
 	| event_declarators
 	;
 	
 event_declarators
 	
 	  {
 		current_event_field.AddDeclarator ((FieldDeclarator) $1);
 	  }
 	| event_declarators event_declarator
 	  {
 		current_event_field.AddDeclarator ((FieldDeclarator) $2);
 	  }
 	;
 	
 event_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	| COMMA IDENTIFIER ASSIGN
 	  {
 		++lexer.parsing_block;
 	  }
 	  event_variable_initializer
 	  {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) $2;	  
 	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) $5);
 	  	lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	;
 	
 event_variable_initializer
 	
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (68, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 		}
 		
 	  	if ((current_event_field.ModFlags & Modifiers.ABSTRACT) != 0) {
 			Report.Error (74, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 	  	}		
 	  }
 	  variable_initializer
 	  {
 		$$ = $2;
 	  }
 	;
 	
 event_accessor_declarations
 	
 	| remove_accessor_declaration add_accessor_declaration
 	| add_accessor_declaration
 	  {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  } 
 	| remove_accessor_declaration
 	  {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }	
 	| error
 	  { 
 		Report.Error (1055, GetLocation ($1), "An add or remove accessor expected");
 		$$ = null;
 	  }
 	;
 
 add_accessor_declaration
 	
 	  {
 	  	if ($2 != ModifierNone) {
 			Report.Error (1609, GetLocation ($2), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Add = new EventProperty.AddDelegateMethod (current_event, (Attributes) $1, GetLocation ($3));
 		current_local_parameters = current_event.Add.ParameterInfo;
 		
 		lbag.AddMember (current_event.Add, mod_locations);
 		lexer.EventParsing = false;		
 	  }
 	  event_accessor_block
 	  {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Add.Block = (ToplevelBlock) $5;
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Add.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
 	;
 	
 remove_accessor_declaration
 	
 	  {
 	  	if ($2 != ModifierNone) {
 			Report.Error (1609, GetLocation ($2), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Remove = new EventProperty.RemoveDelegateMethod (current_event, (Attributes) $1, GetLocation ($3));
 		current_local_parameters = current_event.Remove.ParameterInfo;
 
 		lbag.AddMember (current_event.Remove, mod_locations);
 		lexer.EventParsing = false;		
 	  }
 	  event_accessor_block
 	  {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Remove.Block = (ToplevelBlock) $5;
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Remove.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
 	;
 
 event_accessor_block
 	
 	  {
 		Report.Error (73, lexer.Location, "An add or remove accessor must have a body");
 		$$ = null;
 	  }
 	| block;
 	;
 
 enum_declaration
 	
 	  opt_modifiers
 	  ENUM type_declaration_name
 	  opt_enum_base
 	  {
 		if (RootContext.Documentation != null)
 			enumTypeComment = Lexer.consume_doc_comment ();
 	  }
 	  OPEN_BRACE
 	  {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 
 		MemberName name = (MemberName) $4;
 		if (name.IsGeneric) {
 			Report.Error (1675, name.Location, "Enums cannot have type parameters");
 		}
 		
 		push_current_class (new Enum (current_namespace, current_class, (TypeExpression) $5, (Modifiers) $2, MakeName (name), (Attributes) $1), null);
 	  }
 	  opt_enum_member_declarations
 	  {
 	  	// here will be evaluated after CLOSE_BLACE is consumed.
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  CLOSE_BRACE opt_semicolon
 	  {
 		if (RootContext.Documentation != null)
 			current_class.DocComment = enumTypeComment;
 			
 		--lexer.parsing_declaration;
 
 //			if (RootContext.Documentation != null)
 //				em.DocComment = ev.DocComment;
 
 		lbag.AddMember (current_class, mod_locations, GetLocation ($3), GetLocation ($7), GetLocation ($11));
 		$$ = pop_current_class ();
 	  }
 	;
 
 opt_enum_base
 	
 	| COLON type
 	 {
 	 	var te = $2 as TypeExpression;
 		if (te == null ||
 			(te.Type != TypeManager.int32_type && te.Type != TypeManager.uint32_type &&
 			te.Type != TypeManager.int64_type && te.Type != TypeManager.uint64_type &&
 			te.Type != TypeManager.short_type && te.Type != TypeManager.ushort_type &&
 			te.Type != TypeManager.byte_type && te.Type != TypeManager.sbyte_type)) {
 			Enum.Error_1008 (GetLocation ($2), Report);
 			$$ = null;
 		} else {
 			$$ = $2;
 		}
 	 }
 	| COLON error
 	 {
 	 	Error_TypeExpected (GetLocation ($1));
 		$$ = null;
 	 }
 	;
 
 opt_enum_member_declarations
 	
 	| enum_member_declarations
 	| enum_member_declarations COMMA
 	  {
 	  	lbag.AddLocation ($1, GetLocation ($2));
 	  }
 	;
 
 enum_member_declarations
 	
 	| enum_member_declarations COMMA enum_member_declaration
 	  {
 	  	lbag.AddLocation ($1, GetLocation ($2));
 	  	$$ = $3;
 	  }
 	;
 
 enum_member_declaration
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) $1);
 	  	((Enum) current_class).AddEnumMember (em);
 
 		if (RootContext.Documentation != null) {
 			em.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		$$ = em;
 	  }
 	| opt_attributes IDENTIFIER
 	  {
 	  	++lexer.parsing_block;
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 	  }
 	  ASSIGN constant_expression
 	  { 
 		--lexer.parsing_block;
 		
 		var lt = (Tokenizer.LocatedToken) $2;
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) $1);
 	  	em.Initializer = new ConstInitializer (em, (Expression) $5, GetLocation ($4));
 	  	((Enum) current_class).AddEnumMember (em);
 		
 		if (RootContext.Documentation != null)
 			em.DocComment = ConsumeStoredComment ();
 
 		$$ = em;
 	  }
 	;
 
 delegate_declaration
 	
 	  opt_modifiers
 	  DELEGATE
 	  member_type type_declaration_name
 	  OPEN_PARENS
 	  {
 		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out | ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 
 		MemberName name = MakeName ((MemberName) $5);
 		ParametersCompiled p = (ParametersCompiled) $8;
 
 		Delegate del = new Delegate (current_namespace, current_class, (FullNamedExpression) $4,
 					     (Modifiers) $2, name, p, (Attributes) $1);
 
 		if (RootContext.Documentation != null) {
 			del.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		current_container.AddDelegate (del);
 		current_delegate = del;
 		lexer.ConstraintsParsing = true;
 	  }
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 	  }
 	  SEMICOLON
 	  {
 		current_delegate.SetParameterInfo ((List<Constraints>) $11);
 		lbag.AddMember (current_delegate, mod_locations, GetLocation ($3), GetLocation ($6), GetLocation ($9), GetLocation ($13));
 
 		$$ = current_delegate;
 
 		current_delegate = null;
 	  }
 	;
 
 opt_nullable
 	
 	| INTERR_NULLABLE
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "nullable types");
 	  
 	  	$$ = ComposedTypeSpecifier.CreateNullable (GetLocation ($1));
 	  }
 	;
 
 namespace_or_type_name
 	
 	| qualified_alias_member IDENTIFIER opt_type_argument_list
 	  {
 		var lt1 = (Tokenizer.LocatedToken) $1;
 		var lt2 = (Tokenizer.LocatedToken) $2;
 		
 		$$ = new MemberName (lt1.Value, lt2.Value, (TypeArguments) $3, lt1.Location);
 	  }
 	;
 
 member_name
 	
 	| namespace_or_type_name DOT IDENTIFIER opt_type_argument_list
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberName ((MemberName) $1, lt.Value, (TypeArguments) $4, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($2));		
 	  }
 	;
 
 type_name
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new MemberName (lt.Value, (TypeArguments)$2, lt.Location);	  
 	  }
 	;
 	
 //
 // Generics arguments  (any type, without attributes)
 //
 opt_type_argument_list
 	
 	| OP_GENERICS_LT type_arguments OP_GENERICS_GT
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "generics");	  
 	  
 		$$ = $2;
 	  }
 	| OP_GENERICS_LT error
 	  {
 		Error_TypeExpected (lexer.Location);
 		$$ = new TypeArguments ();
 	  }
 	;
 
 type_arguments
 	
 	  {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression) $1);
 		$$ = type_args;
 	  }
 	| type_arguments COMMA type
 	  {
 		TypeArguments type_args = (TypeArguments) $1;
 		type_args.Add ((FullNamedExpression) $3);
 		$$ = type_args;
 	  }	  
 	;
 
 //
 // Generics parameters (identifiers only, with attributes), used in type or method declarations
 //
 type_declaration_name
 	
 	  {
 		lexer.parsing_generic_declaration = true;
 	  }
 	  opt_type_parameter_list
 	  {
 		lexer.parsing_generic_declaration = false;
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new MemberName (lt.Value, (TypeArguments)$3, lt.Location);
 	  }
 	;
 
 member_declaration_name
 	
 	  {
 	  	MemberName mn = (MemberName)$1;
 	  	if (mn.TypeArguments != null)
 	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
 	  			mn.GetSignatureForError ()));
 	  }
 	;
 
 method_declaration_name
 	
 	| explicit_interface IDENTIFIER opt_type_parameter_list
 	  {
 		lexer.parsing_generic_declaration = false;	  
 		var lt = (Tokenizer.LocatedToken) $2;
 		$$ = new MemberName ((MemberName) $1, lt.Value, (TypeArguments) $3, lt.Location);
 	  }
 	;
 	
 indexer_declaration_name
 	
 	  {
 		lexer.parsing_generic_declaration = false;	  
 		$$ = new MemberName (TypeContainer.DefaultIndexerName, GetLocation ($1));
 	  }
 	| explicit_interface THIS
 	  {
 		lexer.parsing_generic_declaration = false;
 		$$ = new MemberName ((MemberName) $1, TypeContainer.DefaultIndexerName, null, GetLocation ($1));
 	  }
 	;
 
 explicit_interface
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new MemberName (lt.Value, (TypeArguments) $2, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($3));
 	  }
 	| qualified_alias_member IDENTIFIER opt_type_argument_list DOT
 	  {
 		var lt1 = (Tokenizer.LocatedToken) $1;
 		var lt2 = (Tokenizer.LocatedToken) $2;
 		
 		$$ = new MemberName (lt1.Value, lt2.Value, (TypeArguments) $3, lt1.Location);
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	| explicit_interface IDENTIFIER opt_type_argument_list DOT
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		$$ = new MemberName ((MemberName) $1, lt.Value, (TypeArguments) $3, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	;
 	
 opt_type_parameter_list
 	
 	| OP_GENERICS_LT_DECL type_parameters OP_GENERICS_GT
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "generics");
 	  
 		$$ = $2;
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	;
 
 type_parameters
 	
 	  {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression)$1);
 		$$ = type_args;
 	  }
 	| type_parameters COMMA type_parameter
 	  {
 		TypeArguments type_args = (TypeArguments) $1;
 		type_args.Add ((FullNamedExpression)$3);
 		$$ = type_args;
 		lbag.AddLocation ($3, GetLocation ($3));
 	  }	  
 	;
 
 type_parameter
 	
 	  {
 		var lt = (Tokenizer.LocatedToken)$3;
 		$$ = new TypeParameterName (lt.Value, (Attributes)$1, (Variance) $2, lt.Location);
   	  }
   	| error
   	  {
   	  	if (GetTokenName (yyToken) == "type")
 			Report.Error (81, GetLocation ($1), "Type parameter declaration must be an identifier not a type");
 		else
 			Error_SyntaxError (yyToken);
 			
   	  	$$ = new TypeParameterName ("", null, lexer.Location);
   	  }
  	;
 
 //
 // All types where void is allowed
 //
 type_and_void
 	
 	| VOID
 	  {
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }
 	;
 	
 member_type
 	
 	  {
 		lexer.parsing_generic_declaration = true;
 	  }
 	;
 	
 //
 // A type which does not allow `void' to be used
 //
 type
 	
 	| VOID
 	  {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation ($1), Report);
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }	
 	;
 	
 simple_type
 	
 	| VOID
 	  {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation ($1), Report);
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }	
 	;
 	
 parameter_type
 	
 	| VOID
 	  {
 	  	Report.Error (1536, GetLocation ($1), "Invalid parameter type `void'");
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }	
 	;
 
 type_expression_or_array
 	
 	| type_expression rank_specifiers
 	  {
 		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	;
 	
 type_expression
 	
 	  {
 		MemberName name = (MemberName) $1;
 
 		if ($2 != null) {
 			$$ = new ComposedCast (name.GetTypeExpression (), (ComposedTypeSpecifier) $2);
 		} else {
 			if (name.Left == null && name.Name == "var")
 				$$ = new VarExpr (name.Location);
 			else
 				$$ = name.GetTypeExpression ();
 		}
 	  }
 	| namespace_or_type_name pointer_stars
 	  {
 		$$ = new ComposedCast (((MemberName) $1).GetTypeExpression (), (ComposedTypeSpecifier) $2);
 	  }
 	| builtin_types opt_nullable
 	  {
 		if ($2 != null)
 			$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	| builtin_types pointer_stars
 	  {
 		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	| VOID pointer_stars
 	  {
 		$$ = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation ($1)), (ComposedTypeSpecifier) $2);
 	  }
 	;
 
 type_list
 	
 	  {
 		var types = new List<FullNamedExpression> (2);
 		types.Add ((FullNamedExpression) $1);
 		$$ = types;
 	  }
 	| type_list COMMA base_type_name
 	  {
 		var types = (List<FullNamedExpression>) $1;
 		types.Add ((FullNamedExpression) $3);
 		$$ = types;
 	  }
 	;
 
 base_type_name
 	
 	  {
 		if ($1 is ComposedCast) {
 			Report.Error (1521, GetLocation ($1), "Invalid base type `{0}'", ((ComposedCast)$1).GetSignatureForError ());
 		}
 		$$ = $1;
 	  }
 	| error
 	  {
 	  	Error_TypeExpected (lexer.Location);
 		$$ = null;
 	  }
 	;
 	
 /*
  * replaces all the productions for isolating the various
  * simple types, but we need this to reuse it easily in variable_type
  */
 builtin_types
 	
 	| STRING	{ $$ = new TypeExpression (TypeManager.string_type, GetLocation ($1)); }
 	| BOOL		{ $$ = new TypeExpression (TypeManager.bool_type, GetLocation ($1)); }
 	| DECIMAL	{ $$ = new TypeExpression (TypeManager.decimal_type, GetLocation ($1)); }
 	| FLOAT		{ $$ = new TypeExpression (TypeManager.float_type, GetLocation ($1)); }
 	| DOUBLE	{ $$ = new TypeExpression (TypeManager.double_type, GetLocation ($1)); }
 	| integral_type
 	;
 
 integral_type
 	
 	| BYTE		{ $$ = new TypeExpression (TypeManager.byte_type, GetLocation ($1)); }
 	| SHORT		{ $$ = new TypeExpression (TypeManager.short_type, GetLocation ($1)); }
 	| USHORT	{ $$ = new TypeExpression (TypeManager.ushort_type, GetLocation ($1)); }
 	| INT		{ $$ = new TypeExpression (TypeManager.int32_type, GetLocation ($1)); }
 	| UINT		{ $$ = new TypeExpression (TypeManager.uint32_type, GetLocation ($1)); }
 	| LONG		{ $$ = new TypeExpression (TypeManager.int64_type, GetLocation ($1)); }
 	| ULONG		{ $$ = new TypeExpression (TypeManager.uint64_type, GetLocation ($1)); }
 	| CHAR		{ $$ = new TypeExpression (TypeManager.char_type, GetLocation ($1)); }
 	;
 
 //
 // Expressions, section 7.5
 //
 
 
 primary_expression
 	
 	| literal
 	| array_creation_expression
 	| parenthesized_expression
 	| default_value_expression
 	| invocation_expression
 	| element_access
 	| this_access
 	| base_access
 	| post_increment_expression
 	| post_decrement_expression
 	| object_or_delegate_creation_expression
 	| anonymous_type_expression
 	| typeof_expression
 	| sizeof_expression
 	| checked_expression
 	| unchecked_expression
 	| pointer_member_access
 	| anonymous_method_expression
 	;
 
 primary_expression_or_type
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new SimpleName (lt.Value, (TypeArguments)$2, lt.Location);	  
 	  }
 	| IDENTIFIER GENERATE_COMPLETION {
 		var lt = (Tokenizer.LocatedToken) $1;
 	       $$ = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
 	  }
 	| member_access
 	;
 
 literal
 	
 	| LITERAL
 	| NULL			{ $$ = new NullLiteral (GetLocation ($1)); }
 	;
 
 boolean_literal
 	
 	| FALSE			{ $$ = new BoolLiteral (false, GetLocation ($1)); }
 	;
 
 
 //
 // Here is the trick, tokenizer may think that parens is a special but
 // parser is interested in open parens only, so we merge them.
 // Consider
 //
 open_parens_any
 	
 	| OPEN_PARENS_CAST
 	;
 
 // 
 // Use this production to accept closing parenthesis or 
 // performing completion
 //
 close_parens
 	
 	| COMPLETE_COMPLETION
 	;
 
 
 parenthesized_expression
 	
 	  {
 		$$ = new ParenthesizedExpression ((Expression) $2);
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	| OPEN_PARENS expression COMPLETE_COMPLETION
 	  {
 		$$ = new ParenthesizedExpression ((Expression) $2);
 	  }
 	;
 	
 member_access
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess ((Expression) $1, lt.Value, (TypeArguments) $4, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| builtin_types DOT IDENTIFIER opt_type_argument_list
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess ((Expression) $1, lt.Value, (TypeArguments) $4, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| BASE DOT IDENTIFIER opt_type_argument_list
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess (new BaseThis (GetLocation ($1)), lt.Value, (TypeArguments) $4, lt.Location);
 		lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| qualified_alias_member IDENTIFIER opt_type_argument_list
 	  {
 		var lt1 = (Tokenizer.LocatedToken) $1;
 		var lt2 = (Tokenizer.LocatedToken) $2;
 
 		$$ = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) $3, lt1.Location);
 	  }
 	| primary_expression DOT GENERATE_COMPLETION {
 		$$ = new CompletionMemberAccess ((Expression) $1, null,GetLocation ($3));
 	  }
 	| primary_expression DOT IDENTIFIER GENERATE_COMPLETION {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new CompletionMemberAccess ((Expression) $1, lt.Value, lt.Location);
 	  }
 	| builtin_types DOT GENERATE_COMPLETION
 	  {
 		$$ = new CompletionMemberAccess ((Expression) $1, null, lexer.Location);
 	  }
 	| builtin_types DOT IDENTIFIER GENERATE_COMPLETION {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new CompletionMemberAccess ((Expression) $1, lt.Value, lt.Location);
  	  }
 	;
 
 invocation_expression
 	
 	  {
 		$$ = new Invocation ((Expression) $1, (Arguments) $3);
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 opt_object_or_collection_initializer
 	
 	| object_or_collection_initializer
 	;
 
 object_or_collection_initializer
 	
 	  {
 	  	if ($2 == null) {
 	  		$$ = CollectionOrObjectInitializers.Empty;
 	  		// TODO
 	  	} else {
 	  		$$ = new CollectionOrObjectInitializers ((List<Expression>) $2, GetLocation ($1));
 	  		lbag.AddLocation ($$, GetLocation ($3));
 	  	}
 	  }
 	| OPEN_BRACE member_initializer_list COMMA CLOSE_BRACE
 	  {
 	  	$$ = new CollectionOrObjectInitializers ((List<Expression>) $2, GetLocation ($1));
 	  	lbag.AddLocation ($$, GetLocation ($3), GetLocation ($4));
 	  }
 	;
 
 opt_member_initializer_list
 	
 	| member_initializer_list
 	{
 		$$ = $1;
 	}
 	;
 
 member_initializer_list
 	
 	  {
 	  	var a = new List<Expression> ();
 	  	a.Add ((Expression) $1);
 	  	$$ = a;
 	  }
 	| member_initializer_list COMMA member_initializer
 	  {
 	  	var a = (List<Expression>)$1;
 	  	a.Add ((Expression) $3);
 	  	$$ = a;
 	  }
 	| member_initializer_list error {
 	  	Error_SyntaxError (yyToken);
 		$$ = $1;
 	  }
 	;
 
 member_initializer
 	
 	  {
 	  	var lt = (Tokenizer.LocatedToken) $1;
 	  	$$ = new ElementInitializer (lt.Value, (Expression)$3, lt.Location);
 	  	lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| GENERATE_COMPLETION 
 	  {
 		$$ = new CompletionElementInitializer (null, GetLocation ($1));
 	  }
 	| non_assignment_expression opt_COMPLETE_COMPLETION  {
 		CompletionSimpleName csn = $1 as CompletionSimpleName;
 		if (csn == null)
 			$$ = new CollectionElementInitializer ((Expression)$1);
 		else
 			$$ = new CompletionElementInitializer (csn.Prefix, csn.Location);
 	  }
 	| OPEN_BRACE expression_list CLOSE_BRACE
 	  {
 		if ($2 == null)
 			$$ = null;
 		else
 	  		$$ = new CollectionElementInitializer ((List<Expression>)$2, GetLocation ($1));
 	  }
 	| OPEN_BRACE CLOSE_BRACE
 	  {
 	  	Report.Error (1920, GetLocation ($1), "An element initializer cannot be empty");
 		$$ = null;
 	  }	  
 	;
 
 initializer_value
 	
 	| object_or_collection_initializer
 	;
 
 opt_argument_list
 	
 	| argument_list
 	;
 
 argument_list
 	
 	  { 
 		Arguments list = new Arguments (4);
 		list.Add ((Argument) $1);
 		$$ = list;
 	  }
 	| argument_list COMMA argument
 	  {
 		Arguments list = (Arguments) $1;
 		if (list [list.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
 		
 		list.Add ((Argument) $3);
 		$$ = list;
 	  }
 	| argument_list COMMA named_argument
 	  {
 		Arguments list = (Arguments) $1;
 		NamedArgument a = (NamedArgument) $3;
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		
 		list.Add (a);
 		$$ = list;
 	  }
 	| argument_list COMMA
 	  {
 	  	Report.Error (839, GetLocation ($2), "An argument is missing");
 	  	$$ = $1;
 	  }
 	| COMMA error
 	  {
 	  	Report.Error (839, GetLocation ($1), "An argument is missing");
 	  	$$ = null;
 	  }
 	;
 
 argument
 	
 	  {
 		$$ = new Argument ((Expression) $1);
 	  }
 	| non_simple_argument
 	;
 
 argument_or_named_argument
 	
 	| named_argument
 	;
 
 non_simple_argument
 	
 	  { 
 		$$ = new Argument ((Expression) $2, Argument.AType.Ref);
 		lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	| OUT variable_reference 
 	  { 
 		$$ = new Argument ((Expression) $2, Argument.AType.Out);
 		lbag.AddLocation ($$, GetLocation ($1));
 	  }
 	| ARGLIST OPEN_PARENS argument_list CLOSE_PARENS
 	  {
 		$$ = new Argument (new Arglist ((Arguments) $3, GetLocation ($1)));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	| ARGLIST OPEN_PARENS CLOSE_PARENS
 	  {
 		$$ = new Argument (new Arglist (GetLocation ($1)));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($3));
 	  }	  
 	;
 
 variable_reference
 	
 	;
 
 element_access
 	
 	  {
 		$$ = new ElementAccess ((Expression) $1, (Arguments) $3, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	;
 
 expression_list
 	
 	  {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) $1);
 		$$ = list;
 	  }
 	| expression_list COMMA expression
 	  {
 		var list = (List<Expression>) $1;
 		list.Add ((Expression) $3);
 		$$ = list;
 	  }
 	| expression_list error {
 	  	Error_SyntaxError (yyToken);
 		$$ = $1;
 	  }
 	;
 	
 expression_list_arguments
 	
 	  {
 		Arguments args = new Arguments (4);
 		args.Add ((Argument) $1);
 		$$ = args;
 	  }
 	| expression_list_arguments COMMA expression_list_argument
 	  {
 		Arguments args = (Arguments) $1;
 		if (args [args.Count - 1] is NamedArgument && !($3 is NamedArgument))
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 	  
 		args.Add ((Argument) $3);
 		$$ = args;	  
 	  }
 	;
 	
 expression_list_argument
 	
 	  {
 	  	$$ = new Argument ((Expression) $1);
 	  }
 	| named_argument
 	;
 
 this_access
 	
 	  {
 		$$ = new This (GetLocation ($1));
 	  }
 	;
 
 base_access
 	
 	  {
 	  	$$ = new ElementAccess (new BaseThis (GetLocation ($1)), (Arguments) $3, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	| BASE OPEN_BRACKET error
 	  {
 	  	Error_SyntaxError (yyToken);
 		$$ = new ElementAccess (null, null, GetLocation ($2));
 	  }
 	;
 
 post_increment_expression
 	
 	  {
 		$$ = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) $1, GetLocation ($2));
 	  }
 	;
 
 post_decrement_expression
 	
 	  {
 		$$ = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) $1, GetLocation ($2));
 	  }
 	;
 	
 object_or_delegate_creation_expression
 	
 	  {
 		if ($6 != null) {
 			if (RootContext.Version <= LanguageVersion.ISO_2)
 				Report.FeatureIsNotAvailable (GetLocation ($1), "object initializers");
 				
 			$$ = new NewInitialize ((FullNamedExpression) $2, (Arguments) $4, (CollectionOrObjectInitializers) $6, GetLocation ($1));
 		} else {
 			$$ = new New ((FullNamedExpression) $2, (Arguments) $4, GetLocation ($1));
 		}
 		
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
 	  }
 	| NEW new_expr_type object_or_collection_initializer
 	  {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "collection initializers");
 	  
 		$$ = new NewInitialize ((FullNamedExpression) $2, null, (CollectionOrObjectInitializers) $3, GetLocation ($1));
 	  }
 	;
 
 array_creation_expression
 	
 	  opt_rank_specifier
 	  opt_array_initializer
 	  {
 		$$ = new ArrayCreation ((FullNamedExpression) $2, (List<Expression>) $4,
 				new ComposedTypeSpecifier (((List<Expression>) $4).Count, GetLocation ($3)) {
 	  				Next = (ComposedTypeSpecifier) $6
 			  	}, (ArrayInitializer) $7, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
 	  }
 	| NEW new_expr_type rank_specifiers opt_array_initializer
 	  {
 	  	if ($4 == null)
 	  		Report.Error (1586, GetLocation ($1), "Array creation must have array size or array initializer");
 
 		$$ = new ArrayCreation ((FullNamedExpression) $2, (ComposedTypeSpecifier) $3, (ArrayInitializer) $4, GetLocation ($1));
 	  }
 	| NEW rank_specifiers array_initializer
 	  {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "implicitly typed arrays");
 	  
 		$$ = new ImplicitlyTypedArrayCreation ((ComposedTypeSpecifier) $2, (ArrayInitializer) $3, GetLocation ($1));
 	  }
 	| NEW new_expr_type OPEN_BRACKET CLOSE_BRACKET OPEN_BRACKET_EXPR error CLOSE_BRACKET
 	  {
 		Report.Error (178, GetLocation ($6), "Invalid rank specifier, expecting `,' or `]'");
 		$$ = new ArrayCreation ((FullNamedExpression) $2, null, GetLocation ($1));
 	  }
 	| NEW new_expr_type error
 	  {
 		Error_SyntaxError (1526, yyToken, "Unexpected symbol");
 		$$ = new ArrayCreation ((FullNamedExpression) $2, null, GetLocation ($1));
 	  }
 	;
 
 new_expr_type
 	
 		++lexer.parsing_type;
 	  }
 	  simple_type
 	  {
 		--lexer.parsing_type;
 		$$ = $2;
 	  }
 	;
 
 anonymous_type_expression
 	
 	  {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation ($1), "anonymous types");
 
 		$$ = new NewAnonymousType ((List<AnonymousTypeParameter>) $3, current_container, GetLocation ($1));
 		
 		// TODO
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 anonymous_type_parameters_opt_comma
 	
 	| anonymous_type_parameters COMMA
 	;
 
 anonymous_type_parameters_opt
 	
 	| anonymous_type_parameters
 	;
 
 anonymous_type_parameters
 	
 	  {
 	  	var a = new List<AnonymousTypeParameter> (4);
 	  	a.Add ((AnonymousTypeParameter) $1);
 	  	$$ = a;
 	  }
 	| anonymous_type_parameters COMMA anonymous_type_parameter
 	  {
 	  	var a = (List<AnonymousTypeParameter>) $1;
 	  	a.Add ((AnonymousTypeParameter) $3);
 	  	$$ = a;
 	  }
 	;
 
 anonymous_type_parameter
 	
 	  {
 		var lt = (Tokenizer.LocatedToken)$1;
 	  	$$ = new AnonymousTypeParameter ((Expression)$3, lt.Value, lt.Location);
 	  	lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken)$1;
 	  	$$ = new AnonymousTypeParameter (new SimpleName (lt.Value, lt.Location),
 	  		lt.Value, lt.Location);
 	  }
 	| member_access
 	  {
 	  	MemberAccess ma = (MemberAccess) $1;
 	  	$$ = new AnonymousTypeParameter (ma, ma.Name, ma.Location);
 	  }
 	| error
 	  {
 		Report.Error (746, lexer.Location,
 			"Invalid anonymous type member declarator. Anonymous type members must be a member assignment, simple name or member access expression");
 		$$ = null;
 	  }
 	;
 
 opt_rank_specifier
 	
 	| rank_specifiers
 	;
 
 rank_specifiers
 	
 	| rank_specifier rank_specifiers
 	  {
 	  	((ComposedTypeSpecifier) $1).Next = (ComposedTypeSpecifier) $2;
 	  	$$ = $1;
 	  }
 	;
 
 rank_specifier
 	
 	  {
 		$$ = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation ($1));
 	  }
 	| OPEN_BRACKET dim_separators CLOSE_BRACKET
 	  {
 		$$ = ComposedTypeSpecifier.CreateArrayDimension ((int)$2, GetLocation ($1));
 	  }
 	;
 
 dim_separators
 	
 	  {
 		$$ = 2;
 	  }
 	| dim_separators COMMA
 	  {
 		$$ = ((int) $1) + 1;
 	  }
 	;
 
 opt_array_initializer
 	
 	  {
 		$$ = null;
 	  }
 	| array_initializer
 	  {
 		$$ = $1;
 	  }
 	;
 
 array_initializer
 	
 	  {
 		var ai = new ArrayInitializer (0, GetLocation ($1));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation ($2));
 		$$ = ai;
 	  }
 	| OPEN_BRACE variable_initializer_list opt_comma CLOSE_BRACE
 	  {
 		var ai = new ArrayInitializer ((List<Expression>) $2, GetLocation ($1));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation ($3));
 		$$ = ai;
 	  }
 	;
 
 variable_initializer_list
 	
 	  {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) $1);
 		$$ = list;
 	  }
 	| variable_initializer_list COMMA variable_initializer
 	  {
 		var list = (List<Expression>) $1;
 		list.Add ((Expression) $3);
 		$$ = list;
 	  }
 	;
 
 typeof_expression
 	
       {
 	  	lexer.TypeOfParsing = true;
 	  }
 	  open_parens_any typeof_type_expression CLOSE_PARENS
 	  {
 	  	lexer.TypeOfParsing = false;
 		$$ = new TypeOf ((FullNamedExpression) $4, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
 	  }
 	;
 	
 typeof_type_expression
 	
 	| unbound_type_name
 	| error
 	 {
 	 	Error_TypeExpected (lexer.Location);
 	 	$$ = null;
 	 }
 	;
 	
 unbound_type_name
 	
 	  {  
 		var lt = (Tokenizer.LocatedToken) $1;
 
 		$$ = new SimpleName (lt.Value, (int) $2, lt.Location);
 	  }
 	| qualified_alias_member IDENTIFIER generic_dimension
 	  {
 		var lt1 = (Tokenizer.LocatedToken) $1;
 		var lt2 = (Tokenizer.LocatedToken) $2;
 
 		$$ = new QualifiedAliasMember (lt1.Value, lt2.Value, (int) $3, lt1.Location);
 	  }
 	| unbound_type_name DOT IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		
 		$$ = new MemberAccess ((Expression) $1, lt.Value, lt.Location);		
 	  }
 	| unbound_type_name DOT IDENTIFIER generic_dimension
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		
 		$$ = new MemberAccess ((Expression) $1, lt.Value, (int) $4, lt.Location);		
 	  }
 	| namespace_or_type_name DOT IDENTIFIER generic_dimension
 	  {
 		var te = ((MemberName) $1).GetTypeExpression ();
 		if (te.HasTypeArguments)
 			Error_TypeExpected (GetLocation ($4));
 
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess (te, lt.Value, (int) $4, lt.Location);		
 	  }
 	;
 
 generic_dimension
 	
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "generics");
 
 		$$ = $1;
 	  }
 	;
 	
 qualified_alias_member
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		if (RootContext.Version == LanguageVersion.ISO_1)
 			Report.FeatureIsNotAvailable (lt.Location, "namespace alias qualifier");
 
 		$$ = lt;		
 	  }
 	;
 
 sizeof_expression
 	
 	  { 
 		$$ = new SizeOf ((Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 checked_expression
 	
 	  {
 		$$ = new CheckedExpr ((Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 unchecked_expression
 	
 	  {
 		$$ = new UnCheckedExpr ((Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 pointer_member_access 
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		$$ = new MemberAccess (new Indirection ((Expression) $1, GetLocation ($2)), lt.Value, lt.Location);
 	  }
 	;
 
 anonymous_method_expression
 	
 	  {
 		start_anonymous (false, (ParametersCompiled) $2, GetLocation ($1));
 	  }
 	  block
 	  {
 		$$ = end_anonymous ((ParametersBlock) $4);
 	  }
 	;
 
 opt_anonymous_method_signature
 	
 	  {
 		$$ = ParametersCompiled.Undefined;
 	  } 
 	| anonymous_method_signature
 	;
 
 anonymous_method_signature
 	
 	  {
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
 	  opt_formal_parameter_list CLOSE_PARENS
 	  {
 		valid_param_mod = 0;
 	  	$$ = $3;
 	  }
 	;
 
 default_value_expression
 	
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "default value expression");
 
 		$$ = new DefaultValueExpression ((Expression) $3, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 unary_expression
 	
 	| BANG prefixed_unary_expression
 	  {
 		$$ = new Unary (Unary.Operator.LogicalNot, (Expression) $2, GetLocation ($1));
 	  }
 	| TILDE prefixed_unary_expression
 	  {
 		$$ = new Unary (Unary.Operator.OnesComplement, (Expression) $2, GetLocation ($1));
 	  }
 	| cast_expression
 	;
 
 cast_expression
 	
 	  {
 		$$ = new Cast ((FullNamedExpression) $2, (Expression) $4, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($3));
 	  }
 	;
 
 	//
 	// The idea to split this out is from Rhys' grammar
 	// to solve the problem with casts.
 	//
 prefixed_unary_expression
 	
 	| PLUS prefixed_unary_expression
 	  { 
 	  	$$ = new Unary (Unary.Operator.UnaryPlus, (Expression) $2, GetLocation ($1));
 	  } 
 	| MINUS prefixed_unary_expression 
 	  { 
 		$$ = new Unary (Unary.Operator.UnaryNegation, (Expression) $2, GetLocation ($1));
 	  }
 	| OP_INC prefixed_unary_expression 
 	  {
 		$$ = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) $2, GetLocation ($1));
 	  }
 	| OP_DEC prefixed_unary_expression 
 	  {
 		$$ = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) $2, GetLocation ($1));
 	  }
 	| STAR prefixed_unary_expression
 	  {
 		$$ = new Indirection ((Expression) $2, GetLocation ($1));
 	  }
 	| BITWISE_AND prefixed_unary_expression
 	  {
 		$$ = new Unary (Unary.Operator.AddressOf, (Expression) $2, GetLocation ($1));
 	  }
 	;
 
 multiplicative_expression
 	
 	| multiplicative_expression STAR prefixed_unary_expression
 	  {
 		$$ = new Binary (Binary.Operator.Multiply, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| multiplicative_expression DIV prefixed_unary_expression
 	  {
 		$$ = new Binary (Binary.Operator.Division, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| multiplicative_expression PERCENT prefixed_unary_expression 
 	  {
 		$$ = new Binary (Binary.Operator.Modulus, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 additive_expression
 	
 	| additive_expression PLUS multiplicative_expression 
 	  {
 		$$ = new Binary (Binary.Operator.Addition, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| additive_expression MINUS multiplicative_expression
 	  {
 		$$ = new Binary (Binary.Operator.Subtraction, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
   	| parenthesized_expression MINUS multiplicative_expression
 	  {
 	  	// Shift/Reduce conflict
 		$$ = new Binary (Binary.Operator.Subtraction, (Expression) $1, (Expression) $3, GetLocation ($2));
   	  }
 	| additive_expression AS type
 	  {
 		$$ = new As ((Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| additive_expression IS type
 	  {
 		$$ = new Is ((Expression) $1, (Expression) $3, GetLocation ($2));
 	  }	  
 	;
 
 shift_expression
 	
 	| shift_expression OP_SHIFT_LEFT additive_expression
 	  {
 		$$ = new Binary (Binary.Operator.LeftShift, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| shift_expression OP_SHIFT_RIGHT additive_expression
 	  {
 		$$ = new Binary (Binary.Operator.RightShift, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	; 
 
 relational_expression
 	
 	| relational_expression OP_LT shift_expression
 	  {
 		$$ = new Binary (Binary.Operator.LessThan, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| relational_expression OP_GT shift_expression
 	  {
 		$$ = new Binary (Binary.Operator.GreaterThan, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| relational_expression OP_LE shift_expression
 	  {
 		$$ = new Binary (Binary.Operator.LessThanOrEqual, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| relational_expression OP_GE shift_expression
 	  {
 		$$ = new Binary (Binary.Operator.GreaterThanOrEqual, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 equality_expression
 	
 	| equality_expression OP_EQ relational_expression
 	  {
 		$$ = new Binary (Binary.Operator.Equality, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| equality_expression OP_NE relational_expression
 	  {
 		$$ = new Binary (Binary.Operator.Inequality, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	; 
 
 and_expression
 	
 	| and_expression BITWISE_AND equality_expression
 	  {
 		$$ = new Binary (Binary.Operator.BitwiseAnd, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 exclusive_or_expression
 	
 	| exclusive_or_expression CARRET and_expression
 	  {
 		$$ = new Binary (Binary.Operator.ExclusiveOr, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 inclusive_or_expression
 	
 	| inclusive_or_expression BITWISE_OR exclusive_or_expression
 	  {
 		$$ = new Binary (Binary.Operator.BitwiseOr, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 conditional_and_expression
 	
 	| conditional_and_expression OP_AND inclusive_or_expression
 	  {
 		$$ = new Binary (Binary.Operator.LogicalAnd, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 conditional_or_expression
 	
 	| conditional_or_expression OP_OR conditional_and_expression
 	  {
 		$$ = new Binary (Binary.Operator.LogicalOr, 
 			         (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 	
 null_coalescing_expression
 	
 	| conditional_or_expression OP_COALESCING null_coalescing_expression
 	  {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($2), "null coalescing operator");
 			
 		$$ = new Nullable.NullCoalescingOperator ((Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 conditional_expression
 	
 	| null_coalescing_expression INTERR expression COLON expression 
 	  {
 		$$ = new Conditional (new BooleanExpression ((Expression) $1), (Expression) $3, (Expression) $5, GetLocation ($2));
 		lbag.AddLocation ($$, GetLocation ($4));
 	  }
 	;
 
 assignment_expression
 	
 	  {
 		$$ = new SimpleAssign ((Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_MULT_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Multiply, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_DIV_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Division, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_MOD_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Modulus, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_ADD_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Addition, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_SUB_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.Subtraction, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_SHIFT_LEFT_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.LeftShift, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_SHIFT_RIGHT_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.RightShift, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_AND_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.BitwiseAnd, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_OR_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.BitwiseOr, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	| prefixed_unary_expression OP_XOR_ASSIGN expression
 	  {
 		$$ = new CompoundAssign (
 			Binary.Operator.ExclusiveOr, (Expression) $1, (Expression) $3, GetLocation ($2));
 	  }
 	;
 
 lambda_parameter_list
 	
 	  {
 		var pars = new List<Parameter> (4);
 		pars.Add ((Parameter) $1);
 
 		$$ = pars;
 	  }
 	| lambda_parameter_list COMMA lambda_parameter
 	  {
 		var pars = (List<Parameter>) $1;
 		Parameter p = (Parameter)$3;
 		if (pars[0].GetType () != p.GetType ()) {
 			Report.Error (748, p.Location, "All lambda parameters must be typed either explicitly or implicitly");
 		}
 		
 		pars.Add (p);
 		$$ = pars;
 	  }
 	;
 
 lambda_parameter
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 
 		$$ = new Parameter ((FullNamedExpression) $2, lt.Value, (Parameter.Modifier) $1, null, lt.Location);
 	  }
 	| parameter_type IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 
 		$$ = new Parameter ((FullNamedExpression) $1, lt.Value, Parameter.Modifier.NONE, null, lt.Location);
 	  }
 	| IDENTIFIER
 	  {
 	  	var lt = (Tokenizer.LocatedToken) $1;
 		$$ = new ImplicitLambdaParameter (lt.Value, lt.Location);
 	  }
 	;
 
 opt_lambda_parameter_list
 	
 	| lambda_parameter_list		{ 
 		var pars_list = (List<Parameter>) $1;
 		$$ = new ParametersCompiled (pars_list.ToArray ());
 	  }
 	;
 
 lambda_expression_body
 	
 	| block
 	;
 	
 lambda_expression_body_simple
 	
 		start_block (lexer.Location);
 	  }
 	  expression_or_error	// Have to close block when error occurs
 	  {
 		Block b = end_block (lexer.Location);
 		b.AddStatement (new ContextualReturn ((Expression) $2));
 		$$ = b;
 	  } 
 	;
 	
 expression_or_error
 	
 	| error
 	  {
 		Error_SyntaxError (yyToken);	
 		$$ = EmptyExpression.Null;
 	  }
 	;
 
 lambda_expression
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
 		start_anonymous (true, new ParametersCompiled (p), GetLocation ($1));
 	  }
 	  lambda_expression_body
 	  {
 		$$ = end_anonymous ((ParametersBlock) $4);
 		lbag.AddLocation ($$, GetLocation ($2));
 	  }
 	| OPEN_PARENS_LAMBDA
 	  {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation ($1), "lambda expressions");
 	  
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
 	  opt_lambda_parameter_list CLOSE_PARENS ARROW 
 	  {
 	  	valid_param_mod = 0;
 		start_anonymous (true, (ParametersCompiled) $3, GetLocation ($1));
 	  }
 	  lambda_expression_body 
 	  {
 		$$ = end_anonymous ((ParametersBlock) $7);
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($4));
 	  }
 	;
 
 expression
 	
 	| non_assignment_expression
 	;
 	
 non_assignment_expression
 	
 	| lambda_expression
 	| query_expression
 	| ARGLIST
 	  {
 		$$ = new ArglistAccess (GetLocation ($1));
 	  }	
 	;
 
 constant_expression
 	
 	;
 
 boolean_expression
 	
 	  {
 		$$ = new BooleanExpression ((Expression) $1);
 	  }
 	;
 
 //
 // 10 classes
 //
 class_declaration
 	
 	  opt_modifiers
 	  opt_partial
 	  CLASS
 	  {
 		lexer.ConstraintsParsing = true;
 	  }
 	  type_declaration_name
 	  {
 		MemberName name = MakeName ((MemberName) $6);
 		push_current_class (new Class (current_namespace, current_class, name, (Modifiers) $2, (Attributes) $1), $3);
 	  }
 	  opt_class_base
 	  opt_type_parameter_constraints_clauses
 	  {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) $9);
 		lbag.AddMember (current_class, mod_locations, GetLocation ($4));
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
 	  OPEN_BRACE opt_class_member_declarations CLOSE_BRACE
 	  {
 		--lexer.parsing_declaration;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
 	  opt_semicolon 
 	  {
 		lbag.AppendToMember (current_class, GetLocation ($11), GetLocation ($13), GetLocation ($15));
 		$$ = pop_current_class ();
 	  }
 	;	
 
 opt_partial
 	
 	  { $$ = null; }
 	| PARTIAL
 	  { $$ = $1; } // location
 	;
 
 opt_modifiers
 	
 	  {
 	    mod_locations = null;
 		$$ = ModifierNone;
 	  }
 	| modifiers
 	;
 
 modifiers
 	
 	| modifiers modifier
 	  { 
 		var m1 = (Modifiers) $1;
 		var m2 = (Modifiers) $2;
 
 		if ((m1 & m2) != 0) {
 			Report.Error (1004, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"Duplicate `{0}' modifier", ModifiersExtensions.Name (m2));
 		} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
 			((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
 			Report.Error (107, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"More than one protection modifier specified");
 		}
 		
 		$$ = m1 | m2;
 	  }
 	;
 
 modifier
 	
 	  {
 		$$ = Modifiers.NEW;
 		StoreModifierLocation ($$, GetLocation ($1));
 		
 		if (current_container == RootContext.ToplevelTypes)
 			Report.Error (1530, GetLocation ($1), "Keyword `new' is not allowed on namespace elements");
 	  }
 	| PUBLIC
 	  {
 		$$ = Modifiers.PUBLIC;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| PROTECTED
 	  {
 		$$ = Modifiers.PROTECTED;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| INTERNAL
 	  {
 		$$ = Modifiers.INTERNAL;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| PRIVATE
 	  {
 		$$ = Modifiers.PRIVATE;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| ABSTRACT
 	  {
 		$$ = Modifiers.ABSTRACT;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| SEALED
 	  {
 		$$ = Modifiers.SEALED;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| STATIC
 	  {
 		$$ = Modifiers.STATIC;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| READONLY
 	  {
 		$$ = Modifiers.READONLY;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| VIRTUAL
 	  {
 		$$ = Modifiers.VIRTUAL;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| OVERRIDE
 	  {
 		$$ = Modifiers.OVERRIDE;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| EXTERN
 	  {
 		$$ = Modifiers.EXTERN;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| VOLATILE
 	  {
 		$$ = Modifiers.VOLATILE;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	| UNSAFE
 	  {
 		$$ = Modifiers.UNSAFE;
 		StoreModifierLocation ($$, GetLocation ($1));
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation ($1));
 	  }
 	| ASYNC
 	  {
 		$$ = Modifiers.ASYNC;
 		StoreModifierLocation ($$, GetLocation ($1));
 	  }
 	;
 
 opt_class_base
 	
 	| COLON type_list
 	 {
 		current_container.AddBasesForPart (current_class, (List<FullNamedExpression>) $2);
 	 }
 	;
 
 opt_type_parameter_constraints_clauses
 	
 	| type_parameter_constraints_clauses 
 	  {
 		$$ = $1;
 	  }
 	| error
 	 {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	 }
 	;
 
 type_parameter_constraints_clauses
 	
 	  {
 		var constraints = new List<Constraints> (1);
 		constraints.Add ((Constraints) $1);
 		$$ = constraints;
 	  }
 	| type_parameter_constraints_clauses type_parameter_constraints_clause
 	  {
 		var constraints = (List<Constraints>) $1;
 		Constraints new_constraint = (Constraints)$2;
 
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 
 		constraints.Add (new_constraint);
 		$$ = constraints;
 	  }
 	; 
 
 type_parameter_constraints_clause
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		$$ = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) $4, GetLocation ($1));
 	  }
 	; 
 
 type_parameter_constraints
 	
 	  {
 		var constraints = new List<FullNamedExpression> (1);
 		constraints.Add ((FullNamedExpression) $1);
 		$$ = constraints;
 	  }
 	| type_parameter_constraints COMMA type_parameter_constraint
 	  {
 		var constraints = (List<FullNamedExpression>) $1;
 		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
 		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
 			Report.Error (401, GetLocation ($2), "The `new()' constraint must be the last constraint specified");
 		}
 		
 		prev = $3 as SpecialContraintExpr;
 		if (prev != null) {
 			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
 				Report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
 			} else {
 			 	prev = constraints [0] as SpecialContraintExpr;
 			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
 					Report.Error (451, GetLocation ($3), "The `new()' constraint cannot be used with the `struct' constraint");
 				}
 			}
 		}
 
 		constraints.Add ((FullNamedExpression) $3);
 		$$ = constraints;
 	  }
 	;
 
 type_parameter_constraint
 	
 	  {
 		if ($1 is ComposedCast)
 			Report.Error (706, GetLocation ($1), "Invalid constraint type `{0}'", ((ComposedCast)$1).GetSignatureForError ());
 	  
 	  	$$ = $1;
 	  }
 	| NEW OPEN_PARENS CLOSE_PARENS
 	  {
 		$$ = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($3));
 	  }
 	| CLASS
 	  {
 		$$ = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation ($1));
 	  }
 	| STRUCT
 	  {
 		$$ = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation ($1));
 	  }
 	;
 
 opt_type_parameter_variance
 	
 	  {
 		$$ = Variance.None;
 	  }
 	| type_parameter_variance
 	  {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (lexer.Location, "generic type variance");
 
 		$$ = $1;
 	  }
 	;
 
 type_parameter_variance
 	
 	  {
 		$$ = Variance.Covariant;
 	  }
 	| IN
 	  {
 		$$ = Variance.Contravariant;
 	  }
 	;
 
 //
 // Statements (8.2)
 //
 
 //
 // A block is "contained" on the following places
 //	method_body
 //	property_declaration as part of the accessor body (get/set)
 //      operator_declaration
 //	constructor_declaration
 //	destructor_declaration
 //	event_declaration as part of add_accessor_declaration or remove_accessor_declaration
 //      
 block
 	
 	  {
 		++lexer.parsing_block;
 		start_block (GetLocation ($1));
 	  } 
 	  opt_statement_list block_end
 	  {
 		$$ = $4;
 	  }
 	;
 
 block_end 
 	
 	  {
 	 	--lexer.parsing_block;
 		$$ = end_block (GetLocation ($1));
 	  }
 	| COMPLETE_COMPLETION
 	  {
 	 	--lexer.parsing_block;
 		$$ = end_block (lexer.Location);
 	  }
 	;
 
 
 block_prepared
 	
 	  {
 		++lexer.parsing_block;
 		current_block.StartLocation = GetLocation ($1);
 	  }
 	  opt_statement_list CLOSE_BRACE 
 	  {
 		--lexer.parsing_block;
 		$$ = end_block (GetLocation ($4));
 	  }
 	;
 
 opt_statement_list
 	
 	| statement_list 
 	;
 
 statement_list
 	
 	| statement_list statement
 	;
 
 statement
 	
 	  {
 		current_block.AddStatement ((Statement) $1);
 	  }
 	| valid_declaration_statement
 	  {
 		current_block.AddStatement ((Statement) $1);
 	  }
 	| labeled_statement
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 
 //
 // The interactive_statement and its derivatives are only 
 // used to provide a special version of `expression_statement'
 // that has a side effect of assigning the expression to
 // $retval
 //
 interactive_statement_list
 	
 	| interactive_statement_list interactive_statement
 	;
 
 interactive_statement
 	
 	  {
 		current_block.AddStatement ((Statement) $1);
 	  }
 	| interactive_valid_declaration_statement
 	  {
 		current_block.AddStatement ((Statement) $1);
 	  }
 	| labeled_statement
 	;
 
 valid_declaration_statement
 	
 	| empty_statement
 	| expression_statement
 	| selection_statement
 	| iteration_statement
 	| jump_statement		  
 	| try_statement
 	| checked_statement
 	| unchecked_statement
 	| lock_statement
 	| using_statement
 	| unsafe_statement
 	| fixed_statement
 	;
 
 interactive_valid_declaration_statement
 	
 	| empty_statement
         | interactive_expression_statement
 	| selection_statement
 	| iteration_statement
 	| jump_statement		  
 	| try_statement
 	| checked_statement
 	| unchecked_statement
 	| lock_statement
 	| using_statement
 	| unsafe_statement
 	| fixed_statement
 	;
 
 embedded_statement
 	
 	| block_variable_declaration
 	  {
 		  Report.Error (1023, GetLocation ($1), "An embedded statement may not be a declaration or labeled statement");
 		  $$ = null;
 	  }
 	| labeled_statement
 	  {
 		  Report.Error (1023, GetLocation ($1), "An embedded statement may not be a declaration or labeled statement");
 		  $$ = null;
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = new EmptyStatement (GetLocation ($1));
 	  }
 	;
 
 empty_statement
 	
 	  {
 		// Uses lexer.Location because semicolon location is not kept in quick mode
 		$$ = new EmptyStatement (lexer.Location);
 	  }
 	;
 
 labeled_statement
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
 
 		current_block.AddLabel (labeled);
 		current_block.AddStatement (labeled);
 	  }
 	  statement
 	;
 
 variable_type
 	
 	| variable_type_simple rank_specifiers
 	  {
 		if ($1 is VarExpr)
 			$1 = new SimpleName ("var", ((VarExpr) $1).Location);
 	  
 		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	;
 
 /* 
  * The following is from Rhys' grammar
  * > Types in local variable declarations must be recognized as 
  * > expressions to prevent reduce/reduce errors in the grammar.
  * > The expressions are converted into types during semantic analysis.
  */
 variable_type_simple
 	
 	  { 
 		// Ok, the above "primary_expression" is there to get rid of
 		// both reduce/reduce and shift/reduces in the grammar, it should
 		// really just be "type_name".  If you use type_name, a reduce/reduce
 		// creeps up.  If you use namespace_or_type_name (which is all we need
 		// really) two shift/reduces appear.
 		// 
 
 		// So the super-trick is that primary_expression
 		// can only be either a SimpleName or a MemberAccess. 
 		// The MemberAccess case arises when you have a fully qualified type-name like 
 		// Foo.Bar.Blah i;
 		// SimpleName is when you have
 		// Blah i;
 		
 		Expression expr = (Expression) $1;
 		if ($2 == null) {
 			SimpleName sn = expr as SimpleName;
 			if (sn != null && sn.Name == "var")
 				$$ = new VarExpr (sn.Location);
 			else
 				$$ = $1;
 		} else if (expr is ATypeNameExpression) {
 			$$ = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) $2);
 		} else {
 			Error_ExpectingTypeName (expr);
 			$$ = null;
 		}
 	  }
 	| primary_expression_or_type pointer_stars
 	  {
 		ATypeNameExpression expr = $1 as ATypeNameExpression;
 
 		if (expr != null) {
 			$$ = new ComposedCast (expr, (ComposedTypeSpecifier) $2);
 		} else {
 			Error_ExpectingTypeName ((Expression)$1);
 			$$ = expr;
 		}
 	  }
 	| builtin_types opt_nullable
 	  {
 		if ($2 == null)
 			$$ = $1;
 		else
 			$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	| builtin_types pointer_stars
 	  {
 		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
 	  }
 	| VOID pointer_stars
 	  {
 		$$ = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation ($1)), (ComposedTypeSpecifier) $2);
 	  }	  
 	| VOID
 	  {
 		Expression.Error_VoidInvalidInTheContext (GetLocation ($1), Report);
 		$$ = new TypeExpression (TypeManager.void_type, GetLocation ($1));
 	  }
 	;
 	
 pointer_stars
 	
 	| pointer_star pointer_stars
 	  {
 	  	((ComposedTypeSpecifier) $1).Next = (ComposedTypeSpecifier) $2;
 	  	$$ = $1;
 	  }	  
 	;
 
 pointer_star
 	
 	  {
 		$$ = ComposedTypeSpecifier.CreatePointer (GetLocation ($1));
 	  }
 	;
 
 block_variable_declaration
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) $1, li);
 	  }
 	  opt_local_variable_initializer opt_variable_declarators SEMICOLON
 	  {
 		$$ = current_variable;
 		current_variable = null;
 		lbag.AddLocation ($$, GetLocation ($6));
 	  }
 	| CONST variable_type IDENTIFIER
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockConstantDeclaration ((FullNamedExpression) $2, li);
 	  }
 	  const_variable_initializer opt_const_declarators SEMICOLON
 	  {
 		$$ = current_variable;
 		current_variable = null;
 		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($7));
 	  }
 	;
 
 opt_local_variable_initializer
 	
 	| ASSIGN block_variable_initializer
 	  {
 		current_variable.Initializer = (Expression) $2;
 		// TODO
 	  }
 	| error
 	  {
 	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
 			Report.Error (650, lexer.Location,
 				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 	  }
 	;
 
 opt_variable_declarators
 	
 	| variable_declarators
 	;
 	
 variable_declarators
 	
 	| variable_declarators variable_declarator
 	;
 	
 variable_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, null);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation ($1));
 	  }
 	| COMMA IDENTIFIER ASSIGN block_variable_initializer
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) $4);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation ($1), GetLocation ($3));
 	  }
 	;
 	
 const_variable_initializer
 	
 	  {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 	  }
 	| ASSIGN constant_initializer_expr 
 	  {
 		current_variable.Initializer = (Expression) $2;
 	  }
 	;
 	
 opt_const_declarators
 	
 	| const_declarators
 	;
 	
 const_declarators
 	
 	| const_declarators const_declarator
 	;
 	
 const_declarator
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;	  
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) $4);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation ($1), GetLocation ($3));
 	  }
 	;
 	
 block_variable_initializer
 	
 	| STACKALLOC simple_type OPEN_BRACKET_EXPR expression CLOSE_BRACKET
 	  {
 		$$ = new StackAlloc ((Expression) $2, (Expression) $4, GetLocation ($1));
 		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
 	  }
 	| STACKALLOC simple_type
 	  {
 		Report.Error (1575, GetLocation ($1), "A stackalloc expression requires [] after type");
 		$$ = new StackAlloc ((Expression) $2, null, GetLocation ($1));		
 	  }
 	;
 
 expression_statement
 	
 	  {
 		$$ = $1;
 		lbag.AddStatement ($$, GetLocation ($2));
 	  }
 	| statement_expression COMPLETE_COMPLETION { $$ = $1; }
 	;
 
 interactive_expression_statement
 	
 	| interactive_statement_expression COMPLETE_COMPLETION { $$ = $1; }
 	;
 
 	//
 	// We have to do the wrapping here and not in the case above,
 	// because statement_expression is used for example in for_statement
 	//
 statement_expression
 	
 	  {
 		ExpressionStatement s = $1 as ExpressionStatement;
 		if (s == null) {
 			Expression.Error_InvalidExpressionStatement (Report, GetLocation ($1));
 			s = EmptyExpressionStatement.Instance;
 		}
 
 		$$ = new StatementExpression (s);
 	  }
 	;
 
 interactive_statement_expression
 	
 	  {
 		Expression expr = (Expression) $1;
 		ExpressionStatement s;
 
 	        s = new OptionalAssign (new SimpleName ("$retval", lexer.Location), expr, lexer.Location);
 		$$ = new StatementExpression (s);
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = new EmptyStatement (GetLocation ($1));
 	  }
 	;
 	
 selection_statement
 	
 	| switch_statement
 	; 
 
 if_statement
 	
 	  embedded_statement
 	  { 
 		if ($5 is EmptyStatement)
 			Warning_EmptyStatement (GetLocation ($5));
 		
 		$$ = new If ((BooleanExpression) $3, (Statement) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	| IF open_parens_any boolean_expression CLOSE_PARENS
 	  embedded_statement ELSE embedded_statement
 	  {
 		$$ = new If ((BooleanExpression) $3, (Statement) $5, (Statement) $7, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4), GetLocation ($6));
 		
 		if ($5 is EmptyStatement)
 			Warning_EmptyStatement (GetLocation ($5));
 		if ($7 is EmptyStatement)
 			Warning_EmptyStatement (GetLocation ($7));
 	  }
 	;
 
 switch_statement
 	
 	  {
 		start_block (GetLocation ($5));
 	  }
 	  opt_switch_sections CLOSE_BRACE
 	  {
 		$$ = new Switch ((Expression) $3, (ExplicitBlock) current_block.Explicit, (List<SwitchSection>) $7, GetLocation ($1));	
 		end_block (GetLocation ($8));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 opt_switch_sections
 	
       {
 		Report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
 		$$ = new List<SwitchSection> ();
 	  }
 	| switch_sections
 	;
 
 switch_sections
 	
 	  {
 		var sections = new List<SwitchSection> (4);
 
 		sections.Add ((SwitchSection) $1);
 		$$ = sections;
 	  }
 	| switch_sections switch_section
 	  {
 		var sections = (List<SwitchSection>) $1;
 
 		sections.Add ((SwitchSection) $2);
 		$$ = sections;
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);	  
 		$$ = new List<SwitchSection> ();
 	  } 
 	;
 
 switch_section
 	
 	  {
 		current_block = current_block.CreateSwitchBlock (lexer.Location);
 	  }
  	  statement_list 
 	  {
 		$$ = new SwitchSection ((List<SwitchLabel>) $1, current_block);
 	  }
 	;
 
 switch_labels
 	
 	  {
 		var labels = new List<SwitchLabel> (4);
 
 		labels.Add ((SwitchLabel) $1);
 		$$ = labels;
 	  }
 	| switch_labels switch_label 
 	  {
 		var labels = (List<SwitchLabel>) ($1);
 		labels.Add ((SwitchLabel) $2);
 
 		$$ = labels;
 	  }
 	;
 
 switch_label
 	
 	 {
 	 	$$ = new SwitchLabel ((Expression) $2, GetLocation ($1));
 	 	lbag.AddLocation ($$, GetLocation ($3));
 	 }
 	| DEFAULT_COLON
 	  {
 		$$ = new SwitchLabel (null, GetLocation ($1));
 	  }
 	;
 
 iteration_statement
 	
 	| do_statement
 	| for_statement
 	| foreach_statement
 	;
 
 while_statement
 	
 	  {
 		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($5));
 	  
 		$$ = new While ((BooleanExpression) $3, (Statement) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 do_statement
 	
 	  WHILE open_parens_any boolean_expression CLOSE_PARENS SEMICOLON
 	  {
 		$$ = new Do ((Statement) $2, (BooleanExpression) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($3), GetLocation ($4), GetLocation ($6), GetLocation ($7));
 	  }
 	;
 
 for_statement
 	
 	  {
 		start_block (GetLocation ($2));
 		current_block.IsCompilerGenerated = true;
 	  }
 	  for_statement_cont
 	  {
 		$$ = $4;
 	  }
 	;
 	
 // Has to use be extra rule to recover started block
 for_statement_cont
 	
 	  opt_for_condition SEMICOLON
 	  opt_for_iterator CLOSE_PARENS
 	  embedded_statement
 	  {
 		if ($7 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($7));
 	  
 		For f = new For ((Statement) $1, (BooleanExpression) $3, (Statement) $5, (Statement) $7, GetLocation ($-2));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, current_block.StartLocation, GetLocation ($2), GetLocation ($4), GetLocation ($6));
 
 		$$ = end_block (GetLocation ($2));
 	  }
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = end_block (current_block.StartLocation);
 	  }
 	;
 
 opt_for_initializer
 	
 	| for_initializer	
 	;
 
 for_initializer
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) $1, li);
 	  }
 	  opt_local_variable_initializer opt_variable_declarators
 	  {
 		$$ = current_variable;
 		current_variable = null;
 	  }
 	| statement_expression_list
 	;
 
 opt_for_condition
 	
 	| boolean_expression
 	;
 
 opt_for_iterator
 	
 	| for_iterator
 	;
 
 for_iterator
 	
 	;
 
 statement_expression_list
 	
 	| statement_expression_list COMMA statement_expression
 	  {
 	  	var sl = $1 as StatementList;
 	  	if (sl == null) {
 	  		sl = new StatementList ((Statement) $1, (Statement) $3);
 			lbag.AddStatement (sl, GetLocation ($2));
 	  	} else {
 	  		sl.Add ((Statement) $3);
 	  		lbag.AppendTo (sl, GetLocation ($2));
 	  	}
 	  		
 		$$ = sl;
 	  }
 	;
 
 foreach_statement
 	
 	  {
 		Report.Error (230, GetLocation ($1), "Type and identifier are both required in a foreach statement");
 		$$ = null;
 	  }
 	| FOREACH open_parens_any type IDENTIFIER IN expression CLOSE_PARENS 
 	  {
 		start_block (GetLocation ($2));
 		current_block.IsCompilerGenerated = true;
 		
 		var lt = (Tokenizer.LocatedToken) $4;
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.ForeachVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		$$ = li;
 	  } 
 	  embedded_statement
 	  {
 		if ($9 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($9));
 	  
 		Foreach f = new Foreach ((Expression) $3, (LocalVariable) $8, (Expression) $6, (Statement) $9, GetLocation ($1));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, GetLocation ($2), GetLocation ($5), GetLocation ($7));
 		$$ = end_block (GetLocation ($7));
 	  }
 	;
 
 jump_statement
 	
 	| continue_statement
 	| goto_statement
 	| return_statement
 	| throw_statement
 	| yield_statement
 	;
 
 break_statement
 	
 	  {
 		$$ = new Break (GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2));
 	  }
 	;
 
 continue_statement
 	
 	  {
 		$$ = new Continue (GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2));
 	  }
 	;
 
 goto_statement
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		$$ = new Goto (lt.Value, lt.Location);
 		lbag.AddStatement ($$, GetLocation ($1), GetLocation ($3));
 	  }
 	| GOTO CASE constant_expression SEMICOLON
 	  {
 		$$ = new GotoCase ((Expression) $3, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	| GOTO DEFAULT SEMICOLON 
 	  {
 		$$ = new GotoDefault (GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($3));
 	  }
 	; 
 
 return_statement
 	
 	  {
 		$$ = new Return ((Expression) $2, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($3));
 	  }
 	;
 
 throw_statement
 	
 	  {
 		$$ = new Throw ((Expression) $2, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($3));
 	  }
 	;
 
 yield_statement 
 	
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if ($3 == null) {
 			Report.Error (1627, GetLocation ($4), "Expression expected after yield return");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		$$ = new Yield ((Expression) $3, lt.Location);
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	| IDENTIFIER BREAK SEMICOLON
 	  {
 		var lt = (Tokenizer.LocatedToken) $1;
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		$$ = new YieldBreak (lt.Location);
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($3));
 	  }
 	;
 
 opt_expression
 	
 	| expression
 	;
 
 try_statement
 	
 	  {
 		$$ = new TryCatch ((Block) $2, (List<Catch>) $3, GetLocation ($1), false);
 	  }
 	| TRY block FINALLY block
 	  {
 		$$ = new TryFinally ((Statement) $2, (Block) $4, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($3));
 	  }
 	| TRY block catch_clauses FINALLY block
 	  {
 		$$ = new TryFinally (new TryCatch ((Block) $2, (List<Catch>) $3, GetLocation ($1), true), (Block) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($4));
 	  }
 	| TRY block error 
 	  {
 		Report.Error (1524, GetLocation ($1), "Expected catch or finally");
 		$$ = null;
 	  }
 	;
 
 catch_clauses
 	
 	  {
 		var l = new List<Catch> (2);
 
 		l.Add ((Catch) $1);
 		$$ = l;
 	  }
 	| catch_clauses catch_clause
 	  {
 		var l = (List<Catch>) $1;
 		
 		Catch c = (Catch) $2;
 		if (l [0].IsGeneral) {
 			Report.Error (1017, c.loc, "Try statement already has an empty catch block");
 		} else {
 			if (c.IsGeneral)
 				l.Insert (0, c);
 			else
 				l.Add (c);
 		}
 		
 		$$ = l;
 	  }
 	;
 
 opt_identifier
 	
 	| IDENTIFIER
 	;
 
 catch_clause 
 	
 	  {
 		$$ = new Catch ((Block) $2, GetLocation ($1));
 	  }
 	| CATCH open_parens_any type opt_identifier CLOSE_PARENS
 	  {
 		start_block (GetLocation ($2));
 		var c = new Catch (current_block, GetLocation ($1));
 		c.TypeExpression = (FullNamedExpression) $3;
 
 		if ($4 != null) {
 			var lt = (Tokenizer.LocatedToken) $4;
 			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
 			current_block.AddLocalName (c.Variable);
 		}
 		
 		lbag.AddLocation (c, GetLocation ($2), GetLocation ($5));
 		$$ = c;
 	  }
 	  block_prepared
 	  {
 		$$ = $6;
 	  }
 	| CATCH open_parens_any error
 	  {
 	  	if (yyToken == Token.CLOSE_PARENS) {
 			Report.Error (1015, lexer.Location,
 				"A type that derives from `System.Exception', `object', or `string' expected");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 		
 		$$ = new Catch (null, GetLocation ($1));
 	  }
 	;
 
 checked_statement
 	
 	  {
 		$$ = new Checked ((Block) $2, GetLocation ($1));
 	  }
 	;
 
 unchecked_statement
 	
 	  {
 		$$ = new Unchecked ((Block) $2, GetLocation ($1));
 	  }
 	;
 
 unsafe_statement
 	
 	  {
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation ($1));
 	  } block {
 		$$ = new Unsafe ((Block) $3, GetLocation ($1));
 	  } block {
 		$$ = new Unsafe ((Block) $3, GetLocation ($1));
 	  }
 	;
 
 lock_statement
 	
 	  {
 		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($5));
 	  
 		$$ = new Lock ((Expression) $3, (Statement) $5, GetLocation ($1));
 		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
 	  }
 	;
 
 fixed_statement
 	
 	  {
 	    start_block (GetLocation ($2));
 	    
 		var lt = (Tokenizer.LocatedToken) $4;
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.FixedVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Fixed.VariableDeclaration ((FullNamedExpression) $3, li);
 	  }
 	  using_or_fixed_variable_initializer opt_variable_declarators CLOSE_PARENS
 	  {
 		$$ = current_variable;
 		current_variable = null;
 	  }
 	  embedded_statement
 	  {
 		if ($10 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($10));
 	  
 		Fixed f = new Fixed ((Fixed.VariableDeclaration) $9, (Statement) $10, GetLocation ($1));
 		current_block.AddStatement (f);
 		$$ = end_block (GetLocation ($8));
 	  }
 	;
 
 using_statement
 	
 	  {
 	    start_block (GetLocation ($2));
 	    
 		var lt = (Tokenizer.LocatedToken) $4;
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.UsingVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Using.VariableDeclaration ((FullNamedExpression) $3, li);
 	  }
 	  using_or_fixed_variable_initializer opt_variable_declarators CLOSE_PARENS
 	  {
 		$$ = current_variable;	  
 		current_variable = null;
 	  }
 	  embedded_statement
 	  {
 		if ($10 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($10));
 	  
 		Using u = new Using ((Using.VariableDeclaration) $9, (Statement) $10, GetLocation ($1));
 		current_block.AddStatement (u);
 		$$ = end_block (GetLocation ($8));
 	  }
 	| USING open_parens_any expression CLOSE_PARENS embedded_statement
 	  {
 		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation ($5));
 	  
 		Using u = new Using ((Expression) $3, (Statement) $5, GetLocation ($1));
 		lbag.AddStatement (u, GetLocation ($2), GetLocation ($4));
 		$$ = u;
 	  }
 	;
 	
 using_or_fixed_variable_initializer
 	
 	  {
 		Report.Error (210, lexer.Location, "You must provide an initializer in a fixed or using statement declaration");
 	  }
 	| ASSIGN variable_initializer
 	  {
 		current_variable.Initializer = (Expression) $2;
 		$$ = current_variable;
 	  }
 	;
 
 
 // LINQ
 
 query_expression
 	
 	  {
 		lexer.query_parsing = false;
 			
 		Linq.AQueryClause from = $1 as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)$2;
 		$$ = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	| nested_from_clause query_body
 	  {
 		Linq.AQueryClause from = $1 as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)$2;
 		$$ = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }	
 
 	// Bubble up COMPLETE_COMPLETION productions
 	| first_from_clause COMPLETE_COMPLETION {
 	        lexer.query_parsing = false;
 		$$ = $1;
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	| nested_from_clause COMPLETE_COMPLETION {
 	        $$ = $1;
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	;
 	
 first_from_clause
 	
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) $2;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$4, rv, GetLocation ($1)));
 	  }
 	| FROM_FIRST type IDENTIFIER IN expression
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) $3;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$5, rv, GetLocation ($1)) {
 				IdentifierType = (FullNamedExpression)$2
 			}
 		);
 	  }
 	;
 
 nested_from_clause
 	
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) $2;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$4, rv, GetLocation ($1)));
 	  }
 	| FROM type IDENTIFIER IN expression
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) $3;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$5, rv, GetLocation ($1)) {
 				IdentifierType = (FullNamedExpression)$2
 			}
 		);
 	  }
 	;
 	
 from_clause
 	
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		$$ = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)$5, GetLocation ($1));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }	  
 	| FROM type IDENTIFIER IN
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		var lt = (Tokenizer.LocatedToken) $3;
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 
 		$$ = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)$6, GetLocation ($1)) {
 			IdentifierType = (FullNamedExpression)$2
 		};
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
 	;	
 
 query_body
 	
 	  {
 	  	Linq.AQueryClause head = (Linq.AQueryClause)$2;
 		
 		if ($3 != null)
 			head.Next = (Linq.AQueryClause)$3;
 				
 		if ($1 != null) {
 			Linq.AQueryClause clause = (Linq.AQueryClause)$1;
 			clause.Tail.Next = head;
 			head = clause;
 		}
 		
 		$$ = head;
 	  }
 	| opt_query_body_clauses COMPLETE_COMPLETION
 	| error
 	  {
 		Error_SyntaxError (yyToken);
 		$$ = null;
 	  }
 	;
 	
 select_or_group_clause
 	
 	  {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		$$ = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)$3, GetLocation ($1));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	| GROUP
 	  {
 	  	if (linq_clause_blocks == null)
 	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
 	  }
 	  expression
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  BY expression
 	  {
 		$$ = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)$3, linq_clause_blocks.Pop (), (Expression)$6, GetLocation ($1));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	;
 	
 opt_query_body_clauses
 	
 	| query_body_clauses
 	;
 	
 query_body_clauses
 	
 	| query_body_clauses query_body_clause
 	  {
 		((Linq.AQueryClause)$1).Tail.Next = (Linq.AQueryClause)$2;
 		$$ = $1;
 	  }
 	;
 	
 query_body_clause
 	
 	| let_clause 
 	| where_clause
 	| join_clause
 	| orderby_clause
 	;
 	
 let_clause
 	
 	  {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		var lt = (Tokenizer.LocatedToken) $2;
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 	  	$$ = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)$5, GetLocation ($1));
 	  	
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
 	;
 
 where_clause
 	
 	  {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression
 	  {
 		$$ = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)$3, GetLocation ($1));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
 	;
 	
 join_clause
 	
 	  {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
 	  expression ON
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
 	  expression EQUALS
 	  {
 		current_block.AddStatement (new ContextualReturn ((Expression) $8));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression opt_join_into
 	  {
 		current_block.AddStatement (new ContextualReturn ((Expression) $11));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 
 		var lt = (Tokenizer.LocatedToken) $2;	
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if ($12 == null) {
 			into = sn;
 	  		$$ = new Linq.Join (block, sn, (Expression)$5, outer_selector, (Linq.QueryBlock) current_block, GetLocation ($1));
 		} else {
 			//
 			// Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions
 			//
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 			
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) $12;
 			into = new Linq.RangeVariable (lt.Value, lt.Location);
 
 			$$ = new Linq.GroupJoin (block, sn, (Expression)$5, outer_selector, (Linq.QueryBlock) current_block, into, GetLocation ($1));	
 		}
 
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);
 	  }
 	| JOIN type IDENTIFIER IN
 	  {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
 	  expression ON
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
 	  expression EQUALS
 	  {
 		current_block.AddStatement (new ContextualReturn ((Expression) $9));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  expression opt_join_into
 	  {
 		current_block.AddStatement (new ContextualReturn ((Expression) $12));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 		
 		var lt = (Tokenizer.LocatedToken) $3;
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if ($13 == null) {
 			into = sn;		
 	  		$$ = new Linq.Join (block, sn, (Expression)$6, outer_selector, (Linq.QueryBlock) current_block, GetLocation ($1)) {
 	  			IdentifierType = (FullNamedExpression)$2
 	  		};
 		} else {
 			//
 			// Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions
 			//
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 		
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) $13;
 			into = new Linq.RangeVariable (lt.Value, lt.Location); // TODO
 			
 			$$ = new Linq.GroupJoin (block, sn, (Expression)$6, outer_selector, (Linq.QueryBlock) current_block, into, GetLocation ($1)) {
 	  			IdentifierType = (FullNamedExpression)$2
 	  		};			
 		}
 		
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
 	  }
 	;
 	
 opt_join_into
 	
 	| INTO IDENTIFIER
 	  {
 		$$ = $2;
 	  }
 	;
 	
 orderby_clause
 	
 	  {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  orderings
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		$$ = $3;
 	  }
 	;
 	
 orderings
 	
 	| order_by COMMA
 	  {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
 	  orderings_then_by
 	  {
 		((Linq.AQueryClause)$1).Next = (Linq.AQueryClause)$4;
 		$$ = $1;
 	  }
 	;
 	
 orderings_then_by
 	
 	| orderings_then_by COMMA
 	 {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, (Linq.QueryBlock) current_block, lexer.Location);	 
 	 }
 	 then_by
 	 {
 		((Linq.AQueryClause)$1).Tail.Next = (Linq.AQueryClause)$4;
 		$$ = $1;
 	 }
 	;	
 	
 order_by
 	
 	  {
 		$$ = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	| expression ASCENDING
 	  {
 		$$ = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	| expression DESCENDING
 	  {
 		$$ = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	;
 
 then_by
 	
 	  {
 		$$ = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	| expression ASCENDING
 	  {
 		$$ = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }
 	| expression DESCENDING
 	  {
 		$$ = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)$1);	
 	  }	
 	;
 
 
 opt_query_continuation
 	
 	| INTO IDENTIFIER
 	  {
 		// query continuation block is not linked with query block but with block
 		// before. This means each query can use same range variable names for
 		// different identifiers.
 
 		current_block.SetEndLocation (GetLocation ($1));
 		current_block = current_block.Parent;
 	
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
 	  }
 	  query_body
 	  {
 		var current_block = linq_clause_blocks.Pop ();	  
 		var lt = (Tokenizer.LocatedToken) $2;
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
   		$$ = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation ($1)) {
   			next = (Linq.AQueryClause)$4
   		};
 	  }
 	;
 	
 //
 // Support for using the compiler as an interactive parser
 //
 // The INTERACTIVE_PARSER token is first sent to parse our
 // productions;  If the result is a Statement, the parsing
 // is repeated, this time with INTERACTIVE_PARSE_WITH_BLOCK
 // to setup the blocks in advance.
 //
 // This setup is here so that in the future we can add 
 // support for other constructs (type parsing, namespaces, etc)
 // that do not require a block to be setup in advance
 //
 
 interactive_parsing
 	
 	| EVAL_USING_DECLARATIONS_UNIT_PARSER using_directives opt_COMPLETE_COMPLETION
 	| EVAL_STATEMENT_PARSER { 
 	        Evaluator.LoadAliases (current_namespace);
 
 		push_current_class (new Class (current_namespace, current_class, new MemberName ("Class" + class_count++),
 			Modifiers.PUBLIC, null), null);
 
 		var baseclass_list = new List<FullNamedExpression> ();
 		baseclass_list.Add (new TypeExpression (Evaluator.InteractiveBaseClass, lexer.Location));
 		current_container.AddBasesForPart (current_class, baseclass_list);
 
 		// (ref object retval)
 		Parameter [] mpar = new Parameter [1];
 		mpar [0] = new Parameter (new TypeExpression (TypeManager.object_type, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);
 
 		ParametersCompiled pars = new ParametersCompiled (mpar);
 		current_local_parameters = pars;
 		Method method = new Method (
 			current_class,
 			null, // generic
 			new TypeExpression (TypeManager.void_type, Location.Null),
 			Modifiers.PUBLIC | Modifiers.STATIC,
 			new MemberName ("Host"),
 			pars,
 			null /* attributes */);
 
 		oob_stack.Push (method);
 	        ++lexer.parsing_block;
 		start_block (lexer.Location);
 	  }		
 	  interactive_statement_list opt_COMPLETE_COMPLETION
 	  {
 		--lexer.parsing_block;
 		Method method = (Method) oob_stack.Pop ();
 
 		method.Block = (ToplevelBlock) end_block(lexer.Location);
 		current_container.AddMethod (method);
 
 		--lexer.parsing_declaration;
 		InteractiveResult = pop_current_class ();
 		current_local_parameters = null;
 	  } 
 	| EVAL_COMPILATION_UNIT_PARSER {
 	        Evaluator.LoadAliases (current_namespace);
 	  }
 	  interactive_compilation_unit
         yyTop -= yyLen[yyN];
         yyState = yyStates[yyTop];
         int yyM = yyLhs[yyN];
         if (yyState == 0 && yyM == 0) {
           if (debug != null) debug.shift(0, yyFinal);
           yyState = yyFinal;
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
                debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
           }
           if (yyToken == 0) {
             if (debug != null) debug.accept(yyVal);
             return yyVal;
           }
           goto continue_yyLoop;
         }
         if (((yyN = yyGindex[yyM]) != 0) && ((yyN += yyState) >= 0)
             && (yyN < yyTable.Length) && (yyCheck[yyN] == yyState))
           yyState = yyTable[yyN];
         else
           yyState = yyDgoto[yyM];
         if (debug != null) debug.shift(yyStates[yyTop], yyState);
 	 goto continue_yyLoop;
       continue_yyDiscarded
       }
       /*yyDiscarded
         int yyN;
         if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
               debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
           }
           if ((yyN = yySindex[yyState]) != 0 && ((yyN += yyToken) >= 0)
               && (yyN < yyTable.Length) && (yyCheck[yyN] == yyToken)) {
             if (debug != null)
               debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
             yyState = yyTable[yyN];		// shift to yyN
             yyVal = yyLex.value();
             yyToken = -1;
             if (yyErrorFlag > 0) -- yyErrorFlag;
             goto continue_yyLoop;
           }
           if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
               && yyN < yyTable.Length && yyCheck[yyN] == yyToken)
             yyN = yyTable[yyN];			// reduce (yyN)
           else
             switch (yyErrorFlag) {
   
             case 0
               yyExpectingState = yyState;
               // yyerror(String.Format ("syntax error, got token `{0}'", yyname (yyToken)), yyExpecting(yyState));
               if (debug != null) debug.error("syntax error");
               if (yyToken == 0 /*eof*/ || yyToken == eof_token) throw new yyParser.yyUnexpectedEof ();
               goto case 1;
             case 1
               yyErrorFlag = 3;
               do {
                 if ((yyN = yySindex[yyStates[yyTop]]) != 0
                     && (yyN += Token.yyErrorCode) >= 0 && yyN < yyTable.Length
                     && yyCheck[yyN] == Token.yyErrorCode) {
                   if (debug != null)
                     debug.shift(yyStates[yyTop], yyTable[yyN], 3);
                   yyState = yyTable[yyN];
                   yyVal = yyLex.value();
                   goto continue_yyLoop;
                 }
                 if (debug != null) debug.pop(yyStates[yyTop]);
               } while (-- yyTop >= 0);
               if (debug != null) debug.reject();
               throw new yyParser.yyException("irrecoverable syntax error");
   
             case 3
               if (yyToken == 0) {
                 if (debug != null) debug.reject();
                 throw new yyParser.yyException("irrecoverable syntax error at end-of-file");
               }
               if (debug != null)
                 debug.discard(yyState, yyToken, yyname(yyToken),
   							yyLex.value());
               yyToken = -1;
               goto continue_yyDiscarded;		// leave stack alone
             }
         }
         int yyV = yyTop + 1-yyLen[yyN];
         if (debug != null)
           debug.reduce(yyState, yyStates[yyV-1], yyN, YYRules.getRule (yyN), yyLen[yyN]);
         yyVal = yyV > yyTop ? null 
         switch (yyN) {
 case 5
 #line 375 "cs-parser.jay"
   { Lexer.CompleteOnEOF = false; }
   break;
 case 7
 #line 380 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 8
 #line 384 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 16
 #line 407 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "alias"){
 			syntax_error (lt.Location, "`alias' expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (lt.Location, "external alias");
 		} else {
 			lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop]; 
 			current_namespace.AddUsingExternalAlias (lt.Value, lt.Location, Report);
 		}
 	  }
   break;
 case 17
 #line 420 "cs-parser.jay"
   {
 	  	syntax_error (GetLocation (yyVals[-1+yyTop]), "`alias' expected");   /* TODO
 	  }
   break;
 case 20
 #line 432 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 21
 #line 437 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 22
 #line 445 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		current_namespace.AddUsingAlias (lt.Value, (MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 23
 #line 450 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 24
 #line 458 "cs-parser.jay"
   {
 		current_namespace.AddUsing ((MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 25
 #line 470 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (yyVals[-2+yyTop] != null) {
 			Report.Error(1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
 		}
 
 		current_namespace = new NamespaceEntry (module,
 			current_namespace, file, name.GetName ());
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 26
 #line 483 "cs-parser.jay"
   { 
 		current_namespace = current_namespace.Parent;
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 27
 #line 492 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName (lt.Value, lt.Location);
 	  }
   break;
 case 28
 #line 497 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 29
 #line 502 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new MemberName ("<invalid>", lexer.Location);
 	  }
   break;
 case 34
 #line 520 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (name.TypeArguments != null)
 			syntax_error (lexer.Location, "namespace name expected");
 
 		yyVal = name;
 	  }
   break;
 case 35
 #line 532 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 45
 #line 564 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			DeclSpace ds = (DeclSpace)yyVals[0+yyTop];
 
 			if ((ds.ModFlags & (Modifiers.PRIVATE|Modifiers.PROTECTED)) != 0){
 				Report.Error (1527, ds.Location, 
 				"Namespace elements cannot be explicitly declared as private, protected or protected internal");
 			}
 		}
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 46
 #line 576 "cs-parser.jay"
   {
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 47
 #line 580 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	 }
   break;
 case 53
 #line 606 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			Attributes attrs = (Attributes)yyVals[0+yyTop];
 			if (global_attrs_enabled) {
 				module.AddAttributes (attrs.Attrs, current_namespace);
 			} else {
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 			}
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 54
 #line 623 "cs-parser.jay"
   {
 		global_attrs_enabled = false;
 		yyVal = null;
       }
   break;
 case 55
 #line 628 "cs-parser.jay"
   { 
 		global_attrs_enabled = false;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 56
 #line 637 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect, current_namespace);
 					yyVal = null;
 				} else {
 					yyVal = new Attributes (sect);
 				}
 				if (yyVal == null) {
 					if (RootContext.Documentation != null) {
 						Lexer.check_incorrect_doc_comment ();
 						Lexer.doc_state =
 							XmlCommentState.Allowed;
 					}
 				}
 			} else {
 				yyVal = new Attributes (sect);
 			}		
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 57
 #line 664 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			Attributes attrs = yyVals[-1+yyTop] as Attributes;
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect);
 					yyVal = null;
 				} else {
 					if (attrs == null)
 						attrs = new Attributes (sect);
 					else
 						attrs.AddAttributes (sect);			
 				}
 			} else {
 				if (attrs == null)
 					attrs = new Attributes (sect);
 				else
 					attrs.AddAttributes (sect);
 			}		
 			yyVal = attrs;
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 58
 #line 695 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
  	  }
   break;
 case 59
 #line 699 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 60
 #line 706 "cs-parser.jay"
   {
 		current_attr_target = (string)yyVals[-1+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 61
 #line 714 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = CheckAttributeTarget (lt.Value, lt.Location);
 	  }
   break;
 case 62
 #line 718 "cs-parser.jay"
   { yyVal = "event"; }
   break;
 case 63
 #line 719 "cs-parser.jay"
   { yyVal = "return"; }
   break;
 case 64
 #line 721 "cs-parser.jay"
   {
 		string name = GetTokenName (yyToken);
 		yyVal = CheckAttributeTarget (name, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 65
 #line 729 "cs-parser.jay"
   {
 		yyVal = new List<Attribute> (4) { (Attribute) yyVals[0+yyTop] };
 	  }
   break;
 case 66
 #line 733 "cs-parser.jay"
   {
 		var attrs = (List<Attribute>) yyVals[-2+yyTop];
 		attrs.Add ((Attribute) yyVals[0+yyTop]);
 
 		yyVal = attrs;
 	  }
   break;
 case 67
 #line 743 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 68
 #line 747 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		MemberName mname = (MemberName) yyVals[-2+yyTop];
 		if (mname.IsGeneric) {
 			Report.Error (404, lexer.Location,
 				      "'<' unexpected
 		}
 
 		Arguments [] arguments = (Arguments []) yyVals[0+yyTop];
 		ATypeNameExpression expr = mname.GetTypeExpression ();
 
 		if (current_attr_target == String.Empty)
 			yyVal = null;
 		else if (global_attrs_enabled && (current_attr_target == "assembly" || current_attr_target == "module"))
 			/* FIXME
 			yyVal = new GlobalAttribute (current_namespace, current_attr_target,
 						  expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 		else
 			yyVal = new Attribute (current_attr_target, expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 	  }
   break;
 case 69
 #line 770 "cs-parser.jay"
   { /* reserved attribute name or identifier
   break;
 case 70
 #line 774 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 71
 #line 776 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 72
 #line 783 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 73
 #line 785 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = new Arguments [] { a, null };
 	  }
   break;
 case 74
 #line 791 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);  
 		yyVal = new Arguments [] { null, a };
 	  }
   break;
 case 75
 #line 797 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] != null) {
 			Report.Error (1016, ((Argument) yyVals[0+yyTop]).Expr.Location, "Named attribute arguments must appear after the positional arguments");
 			o [0] = new Arguments (4);
 		}
 		
 		Arguments args = ((Arguments) o [0]);
 		if (args.Count > 0 && !(yyVals[0+yyTop] is NamedArgument) && args [args.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 		
 		args.Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 76
 #line 811 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] == null) {
 			o [1] = new Arguments (4);
 		}
 
 		((Arguments) o [1]).Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 77
 #line 823 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 79
 #line 831 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 80
 #line 835 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop]);	  
 	  }
   break;
 case 81
 #line 844 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "named argument");
 			
 		/* Avoid boxing in common case (no modifier)*/
 		var arg_mod = yyVals[-1+yyTop] == null ? Argument.AType.None 
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop], arg_mod);
 	  }
   break;
 case 82
 #line 857 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 83
 #line 859 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Ref;
 	  }
   break;
 case 84
 #line 863 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Out;
 	  }
   break;
 case 99
 #line 891 "cs-parser.jay"
   {
 		Report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
 			GetSymbolName (yyToken));
 		yyVal = null;
 		lexer.parsing_generic_declaration = false;
 	  }
   break;
 case 100
 #line 904 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 101
 #line 908 "cs-parser.jay"
   { 
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Struct (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 102
 #line 914 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null)
 			current_container.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 103
 #line 925 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 104
 #line 931 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 105
 #line 936 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	  }
   break;
 case 106
 #line 943 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 107
 #line 948 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 122
 #line 985 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var mod = (Modifiers) yyVals[-3+yyTop];
 		current_field = new Const (current_class, (FullNamedExpression) yyVals[-1+yyTop], mod, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 		current_container.AddConstant ((Const) current_field);
 		
 		if ((mod & Modifiers.STATIC) != 0) {
 			Report.Error (504, current_field.Location, "The constant `{0}' cannot be marked static", current_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_field;
 	  }
   break;
 case 123
 #line 998 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_field = null;
 	  }
   break;
 case 126
 #line 1017 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 127
 #line 1021 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 128
 #line 1028 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 129
 #line 1037 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 130
 #line 1041 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 131
 #line 1046 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 		yyVal = null;
 	  }
   break;
 case 134
 #line 1061 "cs-parser.jay"
   {
 	  	lexer.parsing_generic_declaration = false;
 
 		FullNamedExpression type = (FullNamedExpression) yyVals[-1+yyTop];
 		if (type.Type == TypeManager.void_type)
 			Report.Error (670, GetLocation (yyVals[-1+yyTop]), "Fields cannot have void type");
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new Field (current_class, type, (Modifiers) yyVals[-2+yyTop], new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-3+yyTop]);
 		current_container.AddField (current_field);
 		yyVal = current_field;
 	  }
   break;
 case 135
 #line 1076 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 			
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 		current_field = null;
 	  }
   break;
 case 136
 #line 1089 "cs-parser.jay"
   { 
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "fixed size buffers");
 
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new FixedField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop],
 			new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 			
 		current_container.AddField (current_field);
 	  }
   break;
 case 137
 #line 1100 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 	    }
 
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];	    
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 	    current_field = null;
 	  }
   break;
 case 138
 #line 1115 "cs-parser.jay"
   {
 		Report.Error (1641, GetLocation (yyVals[-1+yyTop]), "A fixed size buffer field must have the array size specifier after the field name");
 	  }
   break;
 case 140
 #line 1123 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 141
 #line 1129 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_field.Initializer = (Expression) yyVals[0+yyTop];
 		end_block (lexer.Location);
 		current_local_parameters = null;
 	  }
   break;
 case 144
 #line 1144 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 145
 #line 1148 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 146
 #line 1155 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 147
 #line 1161 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 148
 #line 1165 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 151
 #line 1180 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 152
 #line 1184 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 153
 #line 1191 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];	  
 		yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 154
 #line 1200 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 155
 #line 1204 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 156
 #line 1210 "cs-parser.jay"
   {
 		Report.Error (443, lexer.Location, "Value or constant expected");
 		yyVal = null;
 	  }
   break;
 case 159
 #line 1220 "cs-parser.jay"
   {
 		/* It has to be here for the parent to safely restore artificial block*/
 	  	Error_SyntaxError (yyToken);
 	  	yyVal = null;
 	  }
   break;
 case 160
 #line 1228 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 161
 #line 1233 "cs-parser.jay"
   {
 		Method method = (Method) yyVals[-2+yyTop];
 		method.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (method);
 		
 		if (current_container.Kind == MemberKind.Interface && method.Block != null) {
 			Report.Error (531, method.Location, "`{0}'
 		}
 
 		current_local_parameters = null;
 
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 162
 #line 1254 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 163
 #line 1258 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 164
 #line 1262 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 						     (FullNamedExpression) yyVals[-7+yyTop], current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		} else if (yyVals[0+yyTop] != null) {
 			Report.Error (80, GetLocation (yyVals[0+yyTop]),
 				"Constraints are not allowed on non-generic declarations");
 		}
 
 		Method method = new Method (current_class, generic, (FullNamedExpression) yyVals[-7+yyTop], (Modifiers) yyVals[-8+yyTop],
 				     name, current_local_parameters, (Attributes) yyVals[-9+yyTop]);
 				     
 		if (yyVals[0+yyTop] != null && ((method.ModFlags & Modifiers.OVERRIDE) != 0 || method.IsExplicitImpl)) {
 			Report.Error (460, method.Location,
 				"`{0}'
 				method.GetSignatureForError ());
 		}
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 165
 #line 1299 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 166
 #line 1303 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 167
 #line 1307 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		if (yyVals[-1+yyTop] != null && name.TypeArguments == null)
 			Report.Error (80, lexer.Location,
 				      "Constraints are not allowed on non-generic declarations");
 
 		Method method;
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 				new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		}
 
 		var modifiers = (Modifiers) yyVals[-9+yyTop];
 
 
 		const Modifiers invalid_partial_mod = Modifiers.AccessibilityMask | Modifiers.ABSTRACT | Modifiers.EXTERN |
 			Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.SEALED | Modifiers.VIRTUAL;
 
 		if ((modifiers & invalid_partial_mod) != 0) {
 			Report.Error (750, name.Location, "A partial method cannot define access modifier or " +
        			"any of abstract, extern, new, override, sealed, or virtual modifiers");
 			modifiers &= ~invalid_partial_mod;
 		}
 
 		if ((current_class.ModFlags & Modifiers.PARTIAL) == 0) {
 			Report.Error (751, name.Location, "A partial method must be declared within a " +
        			"partial class or partial struct");
 		}
 		
 		modifiers |= Modifiers.PARTIAL | Modifiers.PRIVATE;
 		
 		method = new Method (current_class, generic, new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				     modifiers, name, current_local_parameters, (Attributes) yyVals[-10+yyTop]);
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		/* TODO
 		StoreModifierLocation (Modifiers.PARTIAL, GetLocation (yyVals[-8+yyTop]));
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 168
 #line 1362 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		Report.Error (1585, name.Location, 
 			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) yyVals[-4+yyTop]));
 
 		Method method = new Method (current_class, null, (FullNamedExpression) yyVals[-5+yyTop],
 					    0, name, (ParametersCompiled) yyVals[-1+yyTop], (Attributes) yyVals[-7+yyTop]);
 
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		yyVal = method;
 	  }
   break;
 case 170
 #line 1381 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 171
 #line 1385 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 173
 #line 1391 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 	  	yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 174
 #line 1396 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = new ParametersCompiled (pars_list.ToArray ()); 
 	  }
   break;
 case 175
 #line 1403 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[0+yyTop])));
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 176
 #line 1409 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[-2+yyTop] } );			
 	  }
   break;
 case 177
 #line 1416 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 178
 #line 1426 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[-2+yyTop])) }, true);
 	  }
   break;
 case 179
 #line 1432 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 180
 #line 1441 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[0+yyTop] } );
 	  }
   break;
 case 181
 #line 1445 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[0+yyTop])) }, true);
 	  }
   break;
 case 182
 #line 1449 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 183
 #line 1457 "cs-parser.jay"
   {
 		parameters_bucket.Clear ();
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		parameters_bucket.Add (p);
 		
 		default_parameter_used = p.HasDefaultValue;
 		yyVal = parameters_bucket;
 	  }
   break;
 case 184
 #line 1466 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		if (p != null) {
 			if (p.HasExtensionMethodModifier)
 				Report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
 			else if (!p.HasDefaultValue && default_parameter_used)
 				Report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");
 
 			default_parameter_used |= p.HasDefaultValue;
 			pars.Add (p);
 			
 			lbag.AddLocation (p, GetLocation (yyVals[-1+yyTop]));
 		}
 		
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 185
 #line 1490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 186
 #line 1498 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		Report.Error (1552, lt.Location, "Array type specifier, [], must appear before parameter name");
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Parameter.Modifier) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop], lt.Location);
 	  }
   break;
 case 187
 #line 1507 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  	Location l = GetLocation (yyVals[0+yyTop]);
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], "NeedSomeGeneratorHere", (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], l);
 	  }
   break;
 case 188
 #line 1517 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 189
 #line 1521 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		if (RootContext.Version <= LanguageVersion.V_3) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "optional parameter");
 		}
 		
 		Parameter.Modifier mod = (Parameter.Modifier) yyVals[-5+yyTop];
 		if (mod != Parameter.Modifier.NONE) {
 			switch (mod) {
 			case Parameter.Modifier.REF
 			case Parameter.Modifier.OUT
 				Report.Error (1741, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 				
 			case Parameter.Modifier.This
 				Report.Error (1743, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 			default
 				throw new NotImplementedException (mod.ToString ());
 			}
 				
 			mod = Parameter.Modifier.NONE;
 		}
 		
 		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
 			Report.Error (1065, GetLocation (yyVals[-2+yyTop]), "Optional parameter is not valid in this context");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-4+yyTop], lt.Value, mod, (Attributes) yyVals[-6+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 		
 		if (yyVals[0+yyTop] != null)
 			((Parameter) yyVal).DefaultValue = new DefaultParameterValueExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 190
 #line 1560 "cs-parser.jay"
   { yyVal = Parameter.Modifier.NONE; }
   break;
 case 192
 #line 1566 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 193
 #line 1570 "cs-parser.jay"
   {
 		Parameter.Modifier p2 = (Parameter.Modifier)yyVals[0+yyTop];
   		Parameter.Modifier mod = (Parameter.Modifier)yyVals[-1+yyTop] | p2;
   		if (((Parameter.Modifier)yyVals[-1+yyTop] & p2) == p2) {
   			Error_DuplicateParameterModifier (lexer.Location, p2);
   		} else {
 	  		switch (mod & ~Parameter.Modifier.This) {
   				case Parameter.Modifier.REF
 					Report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
   					break;
    				case Parameter.Modifier.OUT
 					Report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
   					break;
   				default
  					Report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
  					break;
  			}
   		}
   		yyVal = mod;
 	  }
   break;
 case 194
 #line 1594 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
 	  		Error_ParameterModifierNotValid ("ref", GetLocation (yyVals[0+yyTop]));
 	  		
 	  	yyVal = Parameter.Modifier.REF;
 	  }
   break;
 case 195
 #line 1601 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
 	  		Error_ParameterModifierNotValid ("out", GetLocation (yyVals[0+yyTop]));
 	  
 	  	yyVal = Parameter.Modifier.OUT;
 	  }
   break;
 case 196
 #line 1608 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.This) == 0)
 	  		Error_ParameterModifierNotValid ("this", GetLocation (yyVals[0+yyTop]));
 
 	  	if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "extension methods");
 	  			
 		yyVal = Parameter.Modifier.This;
 	  }
   break;
 case 197
 #line 1621 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 198
 #line 1626 "cs-parser.jay"
   {
 		Report.Error (1751, GetLocation (yyVals[-4+yyTop]), "Cannot specify a default value for a parameter array");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Attributes) yyVals[-5+yyTop], lt.Location);		
 	  }
   break;
 case 199
 #line 1633 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 200
 #line 1641 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.Params) == 0)
 			Report.Error (1670, (GetLocation (yyVals[0+yyTop])), "The `params' modifier is not allowed in current context");
 	  }
   break;
 case 201
 #line 1646 "cs-parser.jay"
   {
 		Parameter.Modifier mod = (Parameter.Modifier)yyVals[0+yyTop];
 		if ((mod & Parameter.Modifier.This) != 0) {
 			Report.Error (1104, GetLocation (yyVals[-1+yyTop]), "The parameter modifiers `this' and `params' cannot be used altogether");
 		} else {
 			Report.Error (1611, GetLocation (yyVals[-1+yyTop]), "The params parameter cannot be declared as ref or out");
 		}	  
 	  }
   break;
 case 202
 #line 1655 "cs-parser.jay"
   {
 		Error_DuplicateParameterModifier (GetLocation (yyVals[-1+yyTop]), Parameter.Modifier.PARAMS);
 	  }
   break;
 case 203
 #line 1662 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Arglist) == 0)
 	  		Report.Error (1669, GetLocation (yyVals[0+yyTop]), "__arglist is not valid in this context");
 	  }
   break;
 case 204
 #line 1673 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			tmpComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 205
 #line 1678 "cs-parser.jay"
   {
 		current_property = new Property (current_class, (FullNamedExpression) yyVals[-3+yyTop], (Modifiers) yyVals[-4+yyTop],
 			(MemberName) yyVals[-2+yyTop], (Attributes) yyVals[-5+yyTop]);
 			
 		if (current_property.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (547, GetLocation (yyVals[-3+yyTop]), "`{0}'
 			
 		current_container.AddProperty ((Property)current_property);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[0+yyTop]));
 		
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 206
 #line 1691 "cs-parser.jay"
   {
 		lexer.PropertyParsing = false;
 		
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();				
 	  }
   break;
 case 207
 #line 1698 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_property, GetLocation (yyVals[0+yyTop]));
 		current_property = null;
 	  }
   break;
 case 208
 #line 1708 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 209
 #line 1712 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  
 		Indexer indexer = new Indexer (current_class, (FullNamedExpression) yyVals[-6+yyTop],
 			(MemberName)yyVals[-5+yyTop], (Modifiers) yyVals[-7+yyTop], (ParametersCompiled) yyVals[-2+yyTop], (Attributes) yyVals[-8+yyTop]);
 			
 		current_property = indexer;
 
   		current_container.AddIndexer (indexer);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
   		
 		if (indexer.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (620, GetLocation (yyVals[-6+yyTop]), "`{0}'
 
 		if (indexer.Parameters.IsEmpty) {
 			Report.Error (1551, GetLocation (yyVals[-4+yyTop]), "Indexers must have at least one parameter");
 		}
 
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 210
 #line 1738 "cs-parser.jay"
   {
 		  lexer.PropertyParsing = false;
 	  }
   break;
 case 211
 #line 1742 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();
 			
 		lbag.AppendToMember (current_property, GetLocation (yyVals[-1+yyTop]));
 		current_property = null;		
 	  }
   break;
 case 216
 #line 1758 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_BRACE) {
 	  		Report.Error (548, lexer.Location, "`{0}'
 		} else {
 			if (yyToken == Token.SEMICOLON)
 				Report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
 			else
 				Report.Error (1014, GetLocation (yyVals[0+yyTop]), "A get or set accessor expected");
 		}
 	  }
   break;
 case 217
 #line 1772 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 	  
 		if (current_property.Get != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 		
 		if (current_property is Indexer) {
 			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop], ((Indexer)current_property).ParameterInfo.Clone (),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Get = new Property.GetMethod (current_property,
 				(Modifiers) yyVals[-1+yyTop], (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}	
 	  
 		current_local_parameters = current_property.Get.ParameterInfo;	  
 		lbag.AddMember (current_property.Get, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 218
 #line 1794 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] != null) {
 	  		current_property.Get.Block = (ToplevelBlock) yyVals[0+yyTop];			
 	  	
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Get.Block.StartLocation,
 					"`{0}'
 			}		
 		}
 	  
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null)
 			if (Lexer.doc_state == XmlCommentState.Error)
 				Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 219
 #line 1815 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 		
 		if (current_property.Set != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 	  
 		if (current_property is Indexer) {
 			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop],
 				ParametersCompiled.MergeGenerated (compiler,
 				((Indexer)current_property).ParameterInfo, true, new Parameter (
 					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation (yyVals[0+yyTop])),
 					null),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Set = new Property.SetMethod (current_property, (Modifiers) yyVals[-1+yyTop], 
 				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation (yyVals[0+yyTop])),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}
 		
 		current_local_parameters = current_property.Set.ParameterInfo;	
 		lbag.AddMember (current_property.Set, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 220
 #line 1842 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {		
 			current_property.Set.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Set.Block.StartLocation,
 					"`{0}'
 			}
 		}
 		
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null
 			&& Lexer.doc_state == XmlCommentState.Error)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 222
 #line 1864 "cs-parser.jay"
   {
 		/* TODO
 	  	yyVal = null;
 	  }
   break;
 case 223
 #line 1869 "cs-parser.jay"
   {
 	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
 	  	yyVal = null;
 	  }
   break;
 case 224
 #line 1880 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 225
 #line 1884 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Interface (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 226
 #line 1891 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 227
 #line 1902 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 228
 #line 1908 "cs-parser.jay"
   {
 	    lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 229
 #line 1913 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  }
   break;
 case 234
 #line 1930 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 235
 #line 1934 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 240
 #line 1942 "cs-parser.jay"
   {
 	  	Report.Error (567, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain operators");
 	  }
   break;
 case 241
 #line 1946 "cs-parser.jay"
   {
 	  	Report.Error (526, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain contructors");
 	  }
   break;
 case 242
 #line 1950 "cs-parser.jay"
   {
 	  	Report.Error (524, GetLocation (yyVals[0+yyTop]), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
 	  }
   break;
 case 243
 #line 1957 "cs-parser.jay"
   {
 	  }
   break;
 case 244
 #line 1960 "cs-parser.jay"
   {
 		OperatorDeclaration decl = (OperatorDeclaration) yyVals[-2+yyTop];
 		if (decl != null) {
 			Operator op = new Operator (
 				current_class, decl.optype, decl.ret_type, (Modifiers) yyVals[-3+yyTop], 
 				current_local_parameters,
 				(ToplevelBlock) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop], decl.location);
 
 			if (RootContext.Documentation != null) {
 				op.DocComment = tmpComment;
 				Lexer.doc_state = XmlCommentState.Allowed;
 			}
 
 			/* Note again, checking is done in semantic analysis*/
 			current_container.AddOperator (op);
 
 			lbag.AddMember (op, mod_locations, lbag.GetLocations (decl));
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 246
 #line 1985 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 248
 #line 1991 "cs-parser.jay"
   {
 		Report.Error (590, GetLocation (yyVals[0+yyTop]), "User-defined operators cannot return void");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 249
 #line 1999 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 250
 #line 2003 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		Operator.OpType op = (Operator.OpType) yyVals[-4+yyTop];
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];
 		
 		int p_count = current_local_parameters.Count;
 		if (p_count == 1) {
 			if (op == Operator.OpType.Addition)
 				op = Operator.OpType.UnaryPlus;
 			else if (op == Operator.OpType.Subtraction)
 				op = Operator.OpType.UnaryNegation;
 		}
 		
 		if (IsUnaryOperator (op)) {
 			if (p_count == 2) {
 				Report.Error (1020, loc, "Overloadable binary operator expected");
 			} else if (p_count != 1) {
 				Report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
 					Operator.GetName (op));
 			}
 		} else {
 			if (p_count > 2) {
 				Report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
 					Operator.GetName (op));
 			} else if (p_count != 2) {
 				Report.Error (1019, loc, "Overloadable unary operator expected");
 			}
 		}
 		
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (op, (FullNamedExpression) yyVals[-6+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 252
 #line 2047 "cs-parser.jay"
   { yyVal = Operator.OpType.LogicalNot; }
   break;
 case 253
 #line 2048 "cs-parser.jay"
   { yyVal = Operator.OpType.OnesComplement; }
   break;
 case 254
 #line 2049 "cs-parser.jay"
   { yyVal = Operator.OpType.Increment; }
   break;
 case 255
 #line 2050 "cs-parser.jay"
   { yyVal = Operator.OpType.Decrement; }
   break;
 case 256
 #line 2051 "cs-parser.jay"
   { yyVal = Operator.OpType.True; }
   break;
 case 257
 #line 2052 "cs-parser.jay"
   { yyVal = Operator.OpType.False; }
   break;
 case 258
 #line 2054 "cs-parser.jay"
   { yyVal = Operator.OpType.Addition; }
   break;
 case 259
 #line 2055 "cs-parser.jay"
   { yyVal = Operator.OpType.Subtraction; }
   break;
 case 260
 #line 2057 "cs-parser.jay"
   { yyVal = Operator.OpType.Multiply; }
   break;
 case 261
 #line 2058 "cs-parser.jay"
   {  yyVal = Operator.OpType.Division; }
   break;
 case 262
 #line 2059 "cs-parser.jay"
   { yyVal = Operator.OpType.Modulus; }
   break;
 case 263
 #line 2060 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseAnd; }
   break;
 case 264
 #line 2061 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseOr; }
   break;
 case 265
 #line 2062 "cs-parser.jay"
   { yyVal = Operator.OpType.ExclusiveOr; }
   break;
 case 266
 #line 2063 "cs-parser.jay"
   { yyVal = Operator.OpType.LeftShift; }
   break;
 case 267
 #line 2064 "cs-parser.jay"
   { yyVal = Operator.OpType.RightShift; }
   break;
 case 268
 #line 2065 "cs-parser.jay"
   { yyVal = Operator.OpType.Equality; }
   break;
 case 269
 #line 2066 "cs-parser.jay"
   { yyVal = Operator.OpType.Inequality; }
   break;
 case 270
 #line 2067 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThan; }
   break;
 case 271
 #line 2068 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThan; }
   break;
 case 272
 #line 2069 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThanOrEqual; }
   break;
 case 273
 #line 2070 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThanOrEqual; }
   break;
 case 274
 #line 2075 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 275
 #line 2079 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 276
 #line 2094 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 277
 #line 2098 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 278
 #line 2113 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 279
 #line 2119 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	yyVal = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 280
 #line 2129 "cs-parser.jay"
   { 
 		Constructor c = (Constructor) yyVals[-1+yyTop];
 		c.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (RootContext.Documentation != null)
 			c.DocComment = ConsumeStoredComment ();
 
 		current_container.AddConstructor (c);
 
 		current_local_parameters = null;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 281
 #line 2148 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 282
 #line 2157 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];  
 		
 		/**/
 		/* start block here, so possible anonymous methods inside*/
 		/* constructor initializer can get correct parent block*/
 		/**/
 	  	start_block (lexer.Location);
 	  }
   break;
 case 283
 #line 2168 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-6+yyTop];
 		var mods = (Modifiers) yyVals[-7+yyTop];
 		ConstructorInitializer ci = (ConstructorInitializer) yyVals[0+yyTop];
 
 		Constructor c = new Constructor (current_class, lt.Value, mods,
 			(Attributes) yyVals[-8+yyTop], current_local_parameters, ci, lt.Location);
 		
 		if (lt.Value != current_container.MemberName.Name) {
 			Report.Error (1520, c.Location, "Class, struct, or interface method must have a return type");
 		} else if ((mods & Modifiers.STATIC) != 0) {
 			if ((mods & Modifiers.AccessibilityMask) != 0){
 				Report.Error (515, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			}
 			if (ci != null) {
 				Report.Error (514, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			
 			}
 		}
 		
 		lbag.AddMember (c, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 285
 #line 2199 "cs-parser.jay"
   { current_block = null; yyVal = null; }
   break;
 case 288
 #line 2209 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 289
 #line 2213 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorBaseInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 290
 #line 2219 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 291
 #line 2223 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorThisInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 292
 #line 2229 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 293
 #line 2237 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 		
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 294
 #line 2246 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		if (lt.Value != current_container.MemberName.Name){
 			Report.Error (574, lt.Location, "Name of destructor must match name of class");
 		} else if (current_container.Kind != MemberKind.Class){
 			Report.Error (575, lt.Location, "Only class types can contain destructor");
 		}
 		
 		Destructor d = new Destructor (current_class, (Modifiers) yyVals[-6+yyTop],
 			ParametersCompiled.EmptyReadOnlyParameters, (Attributes) yyVals[-7+yyTop], lt.Location);
 		if (RootContext.Documentation != null)
 			d.DocComment = ConsumeStoredComment ();
 		  
 		d.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (d);
 		lbag.AddMember (d, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		current_local_parameters = null;
 	  }
   break;
 case 295
 #line 2271 "cs-parser.jay"
   {
 		current_event_field = new EventField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop], (MemberName) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop]);
 		current_container.AddEvent (current_event_field);
 		
 		if (current_event_field.MemberName.Left != null) {
 			Report.Error (71, current_event_field.Location, "`{0}'
 			current_event_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_event_field;
 	  }
   break;
 case 296
 #line 2285 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AddMember (current_event_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_event_field = null;
 	  }
   break;
 case 297
 #line 2298 "cs-parser.jay"
   {
 		current_event = new EventProperty (current_class, (FullNamedExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-4+yyTop], (MemberName) yyVals[-1+yyTop], (Attributes) yyVals[-5+yyTop]);
 		current_container.AddEvent (current_event);
 		lbag.AddMember (current_event, mod_locations, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		
 		lexer.EventParsing = true;
 	  }
   break;
 case 298
 #line 2306 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface)
 			Report.Error (69, GetLocation (yyVals[-2+yyTop]), "Event in interface cannot have add or remove accessors");
 	  
 		lexer.EventParsing = false;
 	  }
   break;
 case 299
 #line 2313 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AppendToMember (current_event, GetLocation (yyVals[-1+yyTop]));
 	  	current_event = null;	
 		current_local_parameters = null;
 	  }
   break;
 case 301
 #line 2328 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 302
 #line 2332 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_event_field.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 305
 #line 2345 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 306
 #line 2349 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 307
 #line 2356 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 308
 #line 2362 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 309
 #line 2366 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 310
 #line 2375 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (68, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 		}
 		
 	  	if ((current_event_field.ModFlags & Modifiers.ABSTRACT) != 0) {
 			Report.Error (74, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 	  	}		
 	  }
   break;
 case 311
 #line 2387 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 314
 #line 2396 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 315
 #line 2401 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 316
 #line 2406 "cs-parser.jay"
   { 
 		Report.Error (1055, GetLocation (yyVals[0+yyTop]), "An add or remove accessor expected");
 		yyVal = null;
 	  }
   break;
 case 317
 #line 2414 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Add = new EventProperty.AddDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Add.ParameterInfo;
 		
 		lbag.AddMember (current_event.Add, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 318
 #line 2426 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Add.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Add.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 319
 #line 2442 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Remove = new EventProperty.RemoveDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Remove.ParameterInfo;
 
 		lbag.AddMember (current_event.Remove, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 320
 #line 2454 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Remove.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Remove.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 321
 #line 2470 "cs-parser.jay"
   {
 		Report.Error (73, lexer.Location, "An add or remove accessor must have a body");
 		yyVal = null;
 	  }
   break;
 case 323
 #line 2482 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			enumTypeComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 324
 #line 2487 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		if (name.IsGeneric) {
 			Report.Error (1675, name.Location, "Enums cannot have type parameters");
 		}
 		
 		push_current_class (new Enum (current_namespace, current_class, (TypeExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-5+yyTop], MakeName (name), (Attributes) yyVals[-6+yyTop]), null);
 	  }
   break;
 case 325
 #line 2499 "cs-parser.jay"
   {
 	  	/* here will be evaluated after CLOSE_BLACE is consumed.*/
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 326
 #line 2505 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			current_class.DocComment = enumTypeComment;
 			
 		--lexer.parsing_declaration;
 
 /*			if (RootContext.Documentation != null)*/
 /*				em.DocComment = ev.DocComment;*/
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-9+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 328
 #line 2522 "cs-parser.jay"
   {
 	 	var te = yyVals[0+yyTop] as TypeExpression;
 		if (te == null ||
 			(te.Type != TypeManager.int32_type && te.Type != TypeManager.uint32_type &&
 			te.Type != TypeManager.int64_type && te.Type != TypeManager.uint64_type &&
 			te.Type != TypeManager.short_type && te.Type != TypeManager.ushort_type &&
 			te.Type != TypeManager.byte_type && te.Type != TypeManager.sbyte_type)) {
 			Enum.Error_1008 (GetLocation (yyVals[0+yyTop]), Report);
 			yyVal = null;
 		} else {
 			yyVal = yyVals[0+yyTop];
 		}
 	 }
   break;
 case 329
 #line 2536 "cs-parser.jay"
   {
 	 	Error_TypeExpected (GetLocation (yyVals[-1+yyTop]));
 		yyVal = null;
 	 }
   break;
 case 332
 #line 2546 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 334
 #line 2554 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 335
 #line 2562 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-1+yyTop]);
 	  	((Enum) current_class).AddEnumMember (em);
 
 		if (RootContext.Documentation != null) {
 			em.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		yyVal = em;
 	  }
   break;
 case 336
 #line 2575 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 	  }
   break;
 case 337
 #line 2583 "cs-parser.jay"
   { 
 		--lexer.parsing_block;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 	  	em.Initializer = new ConstInitializer (em, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	((Enum) current_class).AddEnumMember (em);
 		
 		if (RootContext.Documentation != null)
 			em.DocComment = ConsumeStoredComment ();
 
 		yyVal = em;
 	  }
   break;
 case 338
 #line 2604 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out | ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 339
 #line 2608 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		MemberName name = MakeName ((MemberName) yyVals[-4+yyTop]);
 		ParametersCompiled p = (ParametersCompiled) yyVals[-1+yyTop];
 
 		Delegate del = new Delegate (current_namespace, current_class, (FullNamedExpression) yyVals[-5+yyTop],
 					     (Modifiers) yyVals[-7+yyTop], name, p, (Attributes) yyVals[-8+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			del.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		current_container.AddDelegate (del);
 		current_delegate = del;
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 340
 #line 2627 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 	  }
   break;
 case 341
 #line 2631 "cs-parser.jay"
   {
 		current_delegate.SetParameterInfo ((List<Constraints>) yyVals[-2+yyTop]);
 		lbag.AddMember (current_delegate, mod_locations, GetLocation (yyVals[-10+yyTop]), GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[0+yyTop]));
 
 		yyVal = current_delegate;
 
 		current_delegate = null;
 	  }
   break;
 case 343
 #line 2644 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "nullable types");
 	  
 	  	yyVal = ComposedTypeSpecifier.CreateNullable (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 345
 #line 2655 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 347
 #line 2666 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 348
 #line 2675 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 350
 #line 2687 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");	  
 	  
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 351
 #line 2694 "cs-parser.jay"
   {
 		Error_TypeExpected (lexer.Location);
 		yyVal = new TypeArguments ();
 	  }
   break;
 case 352
 #line 2702 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 353
 #line 2708 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 354
 #line 2720 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 355
 #line 2724 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 356
 #line 2733 "cs-parser.jay"
   {
 	  	MemberName mn = (MemberName)yyVals[0+yyTop];
 	  	if (mn.TypeArguments != null)
 	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
 	  			mn.GetSignatureForError ()));
 	  }
   break;
 case 358
 #line 2744 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 359
 #line 2753 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		yyVal = new MemberName (TypeContainer.DefaultIndexerName, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 360
 #line 2758 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		yyVal = new MemberName ((MemberName) yyVals[-1+yyTop], TypeContainer.DefaultIndexerName, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 361
 #line 2766 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 362
 #line 2772 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[-1+yyTop], lt1.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 363
 #line 2780 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 365
 #line 2790 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");
 	  
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 366
 #line 2801 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 367
 #line 2807 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 		lbag.AddLocation (yyVals[0+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 368
 #line 2817 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 		yyVal = new TypeParameterName (lt.Value, (Attributes)yyVals[-2+yyTop], (Variance) yyVals[-1+yyTop], lt.Location);
   	  }
   break;
 case 369
 #line 2822 "cs-parser.jay"
   {
   	  	if (GetTokenName (yyToken) == "type")
 			Report.Error (81, GetLocation (yyVals[0+yyTop]), "Type parameter declaration must be an identifier not a type");
 		else
 			Error_SyntaxError (yyToken);
 			
   	  	yyVal = new TypeParameterName ("", null, lexer.Location);
   	  }
   break;
 case 371
 #line 2838 "cs-parser.jay"
   {
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 372
 #line 2845 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 374
 #line 2856 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 376
 #line 2865 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 378
 #line 2874 "cs-parser.jay"
   {
 	  	Report.Error (1536, GetLocation (yyVals[0+yyTop]), "Invalid parameter type `void'");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 380
 #line 2883 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 381
 #line 2890 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-1+yyTop];
 
 		if (yyVals[0+yyTop] != null) {
 			yyVal = new ComposedCast (name.GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			if (name.Left == null && name.Name == "var")
 				yyVal = new VarExpr (name.Location);
 			else
 				yyVal = name.GetTypeExpression ();
 		}
 	  }
   break;
 case 382
 #line 2903 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (((MemberName) yyVals[-1+yyTop]).GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 383
 #line 2907 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null)
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 384
 #line 2912 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 385
 #line 2916 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 386
 #line 2923 "cs-parser.jay"
   {
 		var types = new List<FullNamedExpression> (2);
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 387
 #line 2929 "cs-parser.jay"
   {
 		var types = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 388
 #line 2938 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast) {
 			Report.Error (1521, GetLocation (yyVals[0+yyTop]), "Invalid base type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 389
 #line 2945 "cs-parser.jay"
   {
 	  	Error_TypeExpected (lexer.Location);
 		yyVal = null;
 	  }
   break;
 case 390
 #line 2956 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.object_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 391
 #line 2957 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.string_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 392
 #line 2958 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.bool_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 393
 #line 2959 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.decimal_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 394
 #line 2960 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.float_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 395
 #line 2961 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.double_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 397
 #line 2966 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.sbyte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 398
 #line 2967 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.byte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 399
 #line 2968 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.short_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 400
 #line 2969 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.ushort_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 401
 #line 2970 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 402
 #line 2971 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 403
 #line 2972 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 404
 #line 2973 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 405
 #line 2974 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.char_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 425
 #line 3006 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new SimpleName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 426
 #line 3010 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	       yyVal = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
 	  }
   break;
 case 430
 #line 3020 "cs-parser.jay"
   { yyVal = new NullLiteral (GetLocation (yyVals[0+yyTop])); }
   break;
 case 431
 #line 3024 "cs-parser.jay"
   { yyVal = new BoolLiteral (true, GetLocation (yyVals[0+yyTop])); }
   break;
 case 432
 #line 3025 "cs-parser.jay"
   { yyVal = new BoolLiteral (false, GetLocation (yyVals[0+yyTop])); }
   break;
 case 437
 #line 3051 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 438
 #line 3056 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 	  }
   break;
 case 439
 #line 3063 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 440
 #line 3069 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 441
 #line 3075 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 442
 #line 3081 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 443
 #line 3087 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null,GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 444
 #line 3090 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
 	  }
   break;
 case 445
 #line 3095 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null, lexer.Location);
 	  }
   break;
 case 446
 #line 3098 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
  	  }
   break;
 case 447
 #line 3106 "cs-parser.jay"
   {
 		yyVal = new Invocation ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 448
 #line 3113 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 450
 #line 3119 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] == null) {
 	  		yyVal = CollectionOrObjectInitializers.Empty;
 	  		/* TODO
 	  	} else {
 	  		yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  	}
 	  }
   break;
 case 451
 #line 3129 "cs-parser.jay"
   {
 	  	yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 452
 #line 3136 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 453
 #line 3138 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	}
   break;
 case 454
 #line 3145 "cs-parser.jay"
   {
 	  	var a = new List<Expression> ();
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 455
 #line 3151 "cs-parser.jay"
   {
 	  	var a = (List<Expression>)yyVals[-2+yyTop];
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 456
 #line 3156 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 457
 #line 3164 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 	  	yyVal = new ElementInitializer (lt.Value, (Expression)yyVals[0+yyTop], lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 458
 #line 3170 "cs-parser.jay"
   {
 		yyVal = new CompletionElementInitializer (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 459
 #line 3173 "cs-parser.jay"
   {
 		CompletionSimpleName csn = yyVals[-1+yyTop] as CompletionSimpleName;
 		if (csn == null)
 			yyVal = new CollectionElementInitializer ((Expression)yyVals[-1+yyTop]);
 		else
 			yyVal = new CompletionElementInitializer (csn.Prefix, csn.Location);
 	  }
   break;
 case 460
 #line 3181 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] == null)
 			yyVal = null;
 		else
 	  		yyVal = new CollectionElementInitializer ((List<Expression>)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 461
 #line 3188 "cs-parser.jay"
   {
 	  	Report.Error (1920, GetLocation (yyVals[-1+yyTop]), "An element initializer cannot be empty");
 		yyVal = null;
 	  }
   break;
 case 464
 #line 3200 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 466
 #line 3206 "cs-parser.jay"
   { 
 		Arguments list = new Arguments (4);
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 467
 #line 3212 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		if (list [list.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
 		
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 468
 #line 3221 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		NamedArgument a = (NamedArgument) yyVals[0+yyTop];
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		
 		list.Add (a);
 		yyVal = list;
 	  }
   break;
 case 469
 #line 3235 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[0+yyTop]), "An argument is missing");
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 470
 #line 3240 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[-1+yyTop]), "An argument is missing");
 	  	yyVal = null;
 	  }
   break;
 case 471
 #line 3248 "cs-parser.jay"
   {
 		yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 475
 #line 3261 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Ref);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 476
 #line 3266 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Out);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 477
 #line 3271 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 478
 #line 3276 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist (GetLocation (yyVals[-2+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 480
 #line 3288 "cs-parser.jay"
   {
 		yyVal = new ElementAccess ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 481
 #line 3296 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 482
 #line 3302 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 483
 #line 3307 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 484
 #line 3315 "cs-parser.jay"
   {
 		Arguments args = new Arguments (4);
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;
 	  }
   break;
 case 485
 #line 3321 "cs-parser.jay"
   {
 		Arguments args = (Arguments) yyVals[-2+yyTop];
 		if (args [args.Count - 1] is NamedArgument && !(yyVals[0+yyTop] is NamedArgument))
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 	  
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;	  
 	  }
   break;
 case 486
 #line 3333 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 488
 #line 3341 "cs-parser.jay"
   {
 		yyVal = new This (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 489
 #line 3348 "cs-parser.jay"
   {
 	  	yyVal = new ElementAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 490
 #line 3353 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = new ElementAccess (null, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 491
 #line 3361 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 492
 #line 3368 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 493
 #line 3375 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			if (RootContext.Version <= LanguageVersion.ISO_2)
 				Report.FeatureIsNotAvailable (GetLocation (yyVals[-5+yyTop]), "object initializers");
 				
 			yyVal = new NewInitialize ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		} else {
 			yyVal = new New ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], GetLocation (yyVals[-5+yyTop]));
 		}
 		
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 494
 #line 3388 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "collection initializers");
 	  
 		yyVal = new NewInitialize ((FullNamedExpression) yyVals[-1+yyTop], null, (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 495
 #line 3400 "cs-parser.jay"
   {
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], (List<Expression>) yyVals[-3+yyTop],
 				new ComposedTypeSpecifier (((List<Expression>) yyVals[-3+yyTop]).Count, GetLocation (yyVals[-4+yyTop])) {
 	  				Next = (ComposedTypeSpecifier) yyVals[-1+yyTop]
 			  	}, (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 496
 #line 3408 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] == null)
 	  		Report.Error (1586, GetLocation (yyVals[-3+yyTop]), "Array creation must have array size or array initializer");
 
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-2+yyTop], (ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 497
 #line 3415 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "implicitly typed arrays");
 	  
 		yyVal = new ImplicitlyTypedArrayCreation ((ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 498
 #line 3422 "cs-parser.jay"
   {
 		Report.Error (178, GetLocation (yyVals[-1+yyTop]), "Invalid rank specifier, expecting `,' or `]'");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], null, GetLocation (yyVals[-6+yyTop]));
 	  }
   break;
 case 499
 #line 3427 "cs-parser.jay"
   {
 		Error_SyntaxError (1526, yyToken, "Unexpected symbol");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-1+yyTop], null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 500
 #line 3434 "cs-parser.jay"
   {
 		++lexer.parsing_type;
 	  }
   break;
 case 501
 #line 3438 "cs-parser.jay"
   {
 		--lexer.parsing_type;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 502
 #line 3446 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "anonymous types");
 
 		yyVal = new NewAnonymousType ((List<AnonymousTypeParameter>) yyVals[-1+yyTop], current_container, GetLocation (yyVals[-3+yyTop]));
 		
 		/* TODO
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 505
 #line 3463 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 507
 #line 3469 "cs-parser.jay"
   {
 	  	var a = new List<AnonymousTypeParameter> (4);
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 508
 #line 3475 "cs-parser.jay"
   {
 	  	var a = (List<AnonymousTypeParameter>) yyVals[-2+yyTop];
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 509
 #line 3484 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[-2+yyTop];
 	  	yyVal = new AnonymousTypeParameter ((Expression)yyVals[0+yyTop], lt.Value, lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 510
 #line 3490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (new SimpleName (lt.Value, lt.Location),
 	  		lt.Value, lt.Location);
 	  }
   break;
 case 511
 #line 3496 "cs-parser.jay"
   {
 	  	MemberAccess ma = (MemberAccess) yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (ma, ma.Name, ma.Location);
 	  }
   break;
 case 512
 #line 3501 "cs-parser.jay"
   {
 		Report.Error (746, lexer.Location,
 			"Invalid anonymous type member declarator. Anonymous type members must be a member assignment, simple name or member access expression");
 		yyVal = null;
 	  }
   break;
 case 516
 #line 3516 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 517
 #line 3524 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 518
 #line 3528 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension ((int)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 519
 #line 3535 "cs-parser.jay"
   {
 		yyVal = 2;
 	  }
   break;
 case 520
 #line 3539 "cs-parser.jay"
   {
 		yyVal = ((int) yyVals[-1+yyTop]) + 1;
 	  }
   break;
 case 521
 #line 3546 "cs-parser.jay"
   {
 		yyVal = null;
 	  }
   break;
 case 522
 #line 3550 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 523
 #line 3557 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer (0, GetLocation (yyVals[-1+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[0+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 524
 #line 3564 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[-1+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 525
 #line 3574 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 526
 #line 3580 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 527
 #line 3589 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = true;
 	  }
   break;
 case 528
 #line 3593 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = false;
 		yyVal = new TypeOf ((FullNamedExpression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 531
 #line 3604 "cs-parser.jay"
   {
 	 	Error_TypeExpected (lexer.Location);
 	 	yyVal = null;
 	 }
   break;
 case 532
 #line 3612 "cs-parser.jay"
   {  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new SimpleName (lt.Value, (int) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 533
 #line 3618 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (int) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 534
 #line 3625 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 535
 #line 3631 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 536
 #line 3637 "cs-parser.jay"
   {
 		var te = ((MemberName) yyVals[-3+yyTop]).GetTypeExpression ();
 		if (te.HasTypeArguments)
 			Error_TypeExpected (GetLocation (yyVals[0+yyTop]));
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (te, lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 537
 #line 3649 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "generics");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 538
 #line 3659 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		if (RootContext.Version == LanguageVersion.ISO_1)
 			Report.FeatureIsNotAvailable (lt.Location, "namespace alias qualifier");
 
 		yyVal = lt;		
 	  }
   break;
 case 539
 #line 3670 "cs-parser.jay"
   { 
 		yyVal = new SizeOf ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 540
 #line 3678 "cs-parser.jay"
   {
 		yyVal = new CheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 541
 #line 3686 "cs-parser.jay"
   {
 		yyVal = new UnCheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 542
 #line 3694 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberAccess (new Indirection ((Expression) yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop])), lt.Value, lt.Location);
 	  }
   break;
 case 543
 #line 3702 "cs-parser.jay"
   {
 		start_anonymous (false, (ParametersCompiled) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 544
 #line 3706 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 	  }
   break;
 case 545
 #line 3713 "cs-parser.jay"
   {
 		yyVal = ParametersCompiled.Undefined;
 	  }
   break;
 case 547
 #line 3721 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 548
 #line 3725 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 549
 #line 3733 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "default value expression");
 
 		yyVal = new DefaultValueExpression ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 551
 #line 3745 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.LogicalNot, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 552
 #line 3749 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.OnesComplement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 554
 #line 3757 "cs-parser.jay"
   {
 		yyVal = new Cast ((FullNamedExpression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 556
 #line 3770 "cs-parser.jay"
   { 
 	  	yyVal = new Unary (Unary.Operator.UnaryPlus, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 557
 #line 3774 "cs-parser.jay"
   { 
 		yyVal = new Unary (Unary.Operator.UnaryNegation, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 558
 #line 3778 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 559
 #line 3782 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 560
 #line 3786 "cs-parser.jay"
   {
 		yyVal = new Indirection ((Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 561
 #line 3790 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.AddressOf, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 563
 #line 3798 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Multiply, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 564
 #line 3803 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Division, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 565
 #line 3808 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Modulus, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 567
 #line 3817 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Addition, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 568
 #line 3822 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 569
 #line 3826 "cs-parser.jay"
   {
 	  	/* Shift/Reduce conflict*/
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
   	  }
   break;
 case 570
 #line 3831 "cs-parser.jay"
   {
 		yyVal = new As ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 571
 #line 3835 "cs-parser.jay"
   {
 		yyVal = new Is ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 573
 #line 3843 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LeftShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 574
 #line 3848 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.RightShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 576
 #line 3857 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 577
 #line 3862 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 578
 #line 3867 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 579
 #line 3872 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 581
 #line 3881 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Equality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 582
 #line 3886 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Inequality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 584
 #line 3895 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 586
 #line 3904 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.ExclusiveOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 588
 #line 3913 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 590
 #line 3922 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 592
 #line 3931 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 594
 #line 3940 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "null coalescing operator");
 			
 		yyVal = new Nullable.NullCoalescingOperator ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 596
 #line 3951 "cs-parser.jay"
   {
 		yyVal = new Conditional (new BooleanExpression ((Expression) yyVals[-4+yyTop]), (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 597
 #line 3959 "cs-parser.jay"
   {
 		yyVal = new SimpleAssign ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 598
 #line 3963 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Multiply, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 599
 #line 3968 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Division, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 600
 #line 3973 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Modulus, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 601
 #line 3978 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Addition, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 602
 #line 3983 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 603
 #line 3988 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.LeftShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 604
 #line 3993 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.RightShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 605
 #line 3998 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseAnd, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 606
 #line 4003 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 607
 #line 4008 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.ExclusiveOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 608
 #line 4016 "cs-parser.jay"
   {
 		var pars = new List<Parameter> (4);
 		pars.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = pars;
 	  }
   break;
 case 609
 #line 4023 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter)yyVals[0+yyTop];
 		if (pars[0].GetType () != p.GetType ()) {
 			Report.Error (748, p.Location, "All lambda parameters must be typed either explicitly or implicitly");
 		}
 		
 		pars.Add (p);
 		yyVal = pars;
 	  }
   break;
 case 610
 #line 4037 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], null, lt.Location);
 	  }
   break;
 case 611
 #line 4043 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, Parameter.Modifier.NONE, null, lt.Location);
 	  }
   break;
 case 612
 #line 4049 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ImplicitLambdaParameter (lt.Value, lt.Location);
 	  }
   break;
 case 613
 #line 4056 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 614
 #line 4057 "cs-parser.jay"
   { 
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 		yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 617
 #line 4069 "cs-parser.jay"
   {
 		start_block (lexer.Location);
 	  }
   break;
 case 618
 #line 4073 "cs-parser.jay"
   {
 		Block b = end_block (lexer.Location);
 		b.AddStatement (new ContextualReturn ((Expression) yyVals[0+yyTop]));
 		yyVal = b;
 	  }
   break;
 case 620
 #line 4083 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	
 		yyVal = EmptyExpression.Null;
 	  }
   break;
 case 621
 #line 4091 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
 		start_anonymous (true, new ParametersCompiled (p), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 622
 #line 4097 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 623
 #line 4102 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "lambda expressions");
 	  
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 624
 #line 4109 "cs-parser.jay"
   {
 	  	valid_param_mod = 0;
 		start_anonymous (true, (ParametersCompiled) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 625
 #line 4114 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 631
 #line 4130 "cs-parser.jay"
   {
 		yyVal = new ArglistAccess (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 633
 #line 4141 "cs-parser.jay"
   {
 		yyVal = new BooleanExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 634
 #line 4154 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 635
 #line 4158 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Class (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 636
 #line 4164 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 637
 #line 4176 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 638
 #line 4182 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 639
 #line 4190 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 640
 #line 4192 "cs-parser.jay"
   { yyVal = yyVals[0+yyTop]; }
   break;
 case 641
 #line 4197 "cs-parser.jay"
   {
 	    mod_locations = null;
 		yyVal = ModifierNone;
 	  }
   break;
 case 644
 #line 4207 "cs-parser.jay"
   { 
 		var m1 = (Modifiers) yyVals[-1+yyTop];
 		var m2 = (Modifiers) yyVals[0+yyTop];
 
 		if ((m1 & m2) != 0) {
 			Report.Error (1004, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"Duplicate `{0}' modifier", ModifiersExtensions.Name (m2));
 		} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
 			((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
 			Report.Error (107, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"More than one protection modifier specified");
 		}
 		
 		yyVal = m1 | m2;
 	  }
   break;
 case 645
 #line 4226 "cs-parser.jay"
   {
 		yyVal = Modifiers.NEW;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		
 		if (current_container == RootContext.ToplevelTypes)
 			Report.Error (1530, GetLocation (yyVals[0+yyTop]), "Keyword `new' is not allowed on namespace elements");
 	  }
   break;
 case 646
 #line 4234 "cs-parser.jay"
   {
 		yyVal = Modifiers.PUBLIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 647
 #line 4239 "cs-parser.jay"
   {
 		yyVal = Modifiers.PROTECTED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 648
 #line 4244 "cs-parser.jay"
   {
 		yyVal = Modifiers.INTERNAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 649
 #line 4249 "cs-parser.jay"
   {
 		yyVal = Modifiers.PRIVATE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 650
 #line 4254 "cs-parser.jay"
   {
 		yyVal = Modifiers.ABSTRACT;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 651
 #line 4259 "cs-parser.jay"
   {
 		yyVal = Modifiers.SEALED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 652
 #line 4264 "cs-parser.jay"
   {
 		yyVal = Modifiers.STATIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 653
 #line 4269 "cs-parser.jay"
   {
 		yyVal = Modifiers.READONLY;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 654
 #line 4274 "cs-parser.jay"
   {
 		yyVal = Modifiers.VIRTUAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 655
 #line 4279 "cs-parser.jay"
   {
 		yyVal = Modifiers.OVERRIDE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 656
 #line 4284 "cs-parser.jay"
   {
 		yyVal = Modifiers.EXTERN;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 657
 #line 4289 "cs-parser.jay"
   {
 		yyVal = Modifiers.VOLATILE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 658
 #line 4294 "cs-parser.jay"
   {
 		yyVal = Modifiers.UNSAFE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 659
 #line 4301 "cs-parser.jay"
   {
 		yyVal = Modifiers.ASYNC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 661
 #line 4310 "cs-parser.jay"
   {
 		current_container.AddBasesForPart (current_class, (List<FullNamedExpression>) yyVals[0+yyTop]);
 	 }
   break;
 case 663
 #line 4318 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 664
 #line 4322 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	 }
   break;
 case 665
 #line 4330 "cs-parser.jay"
   {
 		var constraints = new List<Constraints> (1);
 		constraints.Add ((Constraints) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 666
 #line 4336 "cs-parser.jay"
   {
 		var constraints = (List<Constraints>) yyVals[-1+yyTop];
 		Constraints new_constraint = (Constraints)yyVals[0+yyTop];
 
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 
 		constraints.Add (new_constraint);
 		yyVal = constraints;
 	  }
   break;
 case 667
 #line 4355 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 668
 #line 4363 "cs-parser.jay"
   {
 		var constraints = new List<FullNamedExpression> (1);
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 669
 #line 4369 "cs-parser.jay"
   {
 		var constraints = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
 		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
 			Report.Error (401, GetLocation (yyVals[-1+yyTop]), "The `new()' constraint must be the last constraint specified");
 		}
 		
 		prev = yyVals[0+yyTop] as SpecialContraintExpr;
 		if (prev != null) {
 			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
 				Report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
 			} else {
 			 	prev = constraints [0] as SpecialContraintExpr;
 			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
 					Report.Error (451, GetLocation (yyVals[0+yyTop]), "The `new()' constraint cannot be used with the `struct' constraint");
 				}
 			}
 		}
 
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 670
 #line 4395 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast)
 			Report.Error (706, GetLocation (yyVals[0+yyTop]), "Invalid constraint type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 	  
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 671
 #line 4402 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 672
 #line 4407 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 673
 #line 4411 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 674
 #line 4418 "cs-parser.jay"
   {
 		yyVal = Variance.None;
 	  }
   break;
 case 675
 #line 4422 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (lexer.Location, "generic type variance");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 676
 #line 4432 "cs-parser.jay"
   {
 		yyVal = Variance.Covariant;
 	  }
   break;
 case 677
 #line 4436 "cs-parser.jay"
   {
 		yyVal = Variance.Contravariant;
 	  }
   break;
 case 678
 #line 4456 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 679
 #line 4461 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 680
 #line 4468 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 681
 #line 4473 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (lexer.Location);
 	  }
   break;
 case 682
 #line 4482 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		current_block.StartLocation = GetLocation (yyVals[0+yyTop]);
 	  }
   break;
 case 683
 #line 4487 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 688
 #line 4505 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 689
 #line 4509 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 691
 #line 4514 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 694
 #line 4533 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 695
 #line 4537 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 724
 #line 4578 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 725
 #line 4583 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 726
 #line 4588 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 727
 #line 4596 "cs-parser.jay"
   {
 		/* Uses lexer.Location because semicolon location is not kept in quick mode*/
 		yyVal = new EmptyStatement (lexer.Location);
 	  }
   break;
 case 728
 #line 4604 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
 
 		current_block.AddLabel (labeled);
 		current_block.AddStatement (labeled);
 	  }
   break;
 case 731
 #line 4617 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] is VarExpr)
 			yyVals[-1+yyTop] = new SimpleName ("var", ((VarExpr) yyVals[-1+yyTop]).Location);
 	  
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 732
 #line 4633 "cs-parser.jay"
   { 
 		/* Ok, the above "primary_expression" is there to get rid of*/
 		/* both reduce/reduce and shift/reduces in the grammar, it should*/
 		/* really just be "type_name".  If you use type_name, a reduce/reduce*/
 		/* creeps up.  If you use namespace_or_type_name (which is all we need*/
 		/* really) two shift/reduces appear.*/
 		/* */
 
 		/* So the super-trick is that primary_expression*/
 		/* can only be either a SimpleName or a MemberAccess. */
 		/* The MemberAccess case arises when you have a fully qualified type-name like 
 		/* Foo.Bar.Blah i;*/
 		/* SimpleName is when you have*/
 		/* Blah i;*/
 		
 		Expression expr = (Expression) yyVals[-1+yyTop];
 		if (yyVals[0+yyTop] == null) {
 			SimpleName sn = expr as SimpleName;
 			if (sn != null && sn.Name == "var")
 				yyVal = new VarExpr (sn.Location);
 			else
 				yyVal = yyVals[-1+yyTop];
 		} else if (expr is ATypeNameExpression) {
 			yyVal = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName (expr);
 			yyVal = null;
 		}
 	  }
   break;
 case 733
 #line 4663 "cs-parser.jay"
   {
 		ATypeNameExpression expr = yyVals[-1+yyTop] as ATypeNameExpression;
 
 		if (expr != null) {
 			yyVal = new ComposedCast (expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName ((Expression)yyVals[-1+yyTop]);
 			yyVal = expr;
 		}
 	  }
   break;
 case 734
 #line 4674 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] == null)
 			yyVal = yyVals[-1+yyTop];
 		else
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 735
 #line 4681 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 736
 #line 4685 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 737
 #line 4689 "cs-parser.jay"
   {
 		Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 739
 #line 4698 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 740
 #line 4706 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreatePointer (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 741
 #line 4713 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 742
 #line 4720 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 743
 #line 4726 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockConstantDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 744
 #line 4733 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 746
 #line 4743 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		/* TODO
 	  }
   break;
 case 747
 #line 4748 "cs-parser.jay"
   {
 	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
 			Report.Error (650, lexer.Location,
 				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 	  }
   break;
 case 752
 #line 4770 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, null);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 753
 #line 4779 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 754
 #line 4791 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 	  }
   break;
 case 755
 #line 4795 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 760
 #line 4812 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 762
 #line 4825 "cs-parser.jay"
   {
 		yyVal = new StackAlloc ((Expression) yyVals[-3+yyTop], (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 763
 #line 4830 "cs-parser.jay"
   {
 		Report.Error (1575, GetLocation (yyVals[-1+yyTop]), "A stackalloc expression requires [] after type");
 		yyVal = new StackAlloc ((Expression) yyVals[0+yyTop], null, GetLocation (yyVals[-1+yyTop]));		
 	  }
   break;
 case 764
 #line 4838 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 765
 #line 4842 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 766
 #line 4846 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 767
 #line 4847 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 768
 #line 4856 "cs-parser.jay"
   {
 		ExpressionStatement s = yyVals[0+yyTop] as ExpressionStatement;
 		if (s == null) {
 			Expression.Error_InvalidExpressionStatement (Report, GetLocation (yyVals[0+yyTop]));
 			s = EmptyExpressionStatement.Instance;
 		}
 
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 769
 #line 4869 "cs-parser.jay"
   {
 		Expression expr = (Expression) yyVals[0+yyTop];
 		ExpressionStatement s;
 
 	        s = new OptionalAssign (new SimpleName ("$retval", lexer.Location), expr, lexer.Location);
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 770
 #line 4877 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 773
 #line 4891 "cs-parser.jay"
   { 
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 		
 		yyVal = new If ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 774
 #line 4900 "cs-parser.jay"
   {
 		yyVal = new If ((BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		
 		if (yyVals[-2+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[-2+yyTop]));
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 775
 #line 4913 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 776
 #line 4917 "cs-parser.jay"
   {
 		yyVal = new Switch ((Expression) yyVals[-5+yyTop], (ExplicitBlock) current_block.Explicit, (List<SwitchSection>) yyVals[-1+yyTop], GetLocation (yyVals[-7+yyTop]));	
 		end_block (GetLocation (yyVals[0+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 777
 #line 4926 "cs-parser.jay"
   {
 		Report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 779
 #line 4935 "cs-parser.jay"
   {
 		var sections = new List<SwitchSection> (4);
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 780
 #line 4942 "cs-parser.jay"
   {
 		var sections = (List<SwitchSection>) yyVals[-1+yyTop];
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 781
 #line 4949 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 782
 #line 4957 "cs-parser.jay"
   {
 		current_block = current_block.CreateSwitchBlock (lexer.Location);
 	  }
   break;
 case 783
 #line 4961 "cs-parser.jay"
   {
 		yyVal = new SwitchSection ((List<SwitchLabel>) yyVals[-2+yyTop], current_block);
 	  }
   break;
 case 784
 #line 4968 "cs-parser.jay"
   {
 		var labels = new List<SwitchLabel> (4);
 
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 		yyVal = labels;
 	  }
   break;
 case 785
 #line 4975 "cs-parser.jay"
   {
 		var labels = (List<SwitchLabel>) (yyVals[-1+yyTop]);
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 
 		yyVal = labels;
 	  }
   break;
 case 786
 #line 4985 "cs-parser.jay"
   {
 	 	yyVal = new SwitchLabel ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	 	lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	 }
   break;
 case 787
 #line 4990 "cs-parser.jay"
   {
 		yyVal = new SwitchLabel (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 792
 #line 5004 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new While ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 793
 #line 5016 "cs-parser.jay"
   {
 		yyVal = new Do ((Statement) yyVals[-5+yyTop], (BooleanExpression) yyVals[-2+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 794
 #line 5024 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 		current_block.IsCompilerGenerated = true;
 	  }
   break;
 case 795
 #line 5029 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 796
 #line 5040 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		For f = new For ((Statement) yyVals[-6+yyTop], (BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, current_block.StartLocation, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		yyVal = end_block (GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 797
 #line 5052 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = end_block (current_block.StartLocation);
 	  }
   break;
 case 798
 #line 5059 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 800
 #line 5065 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 801
 #line 5072 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 803
 #line 5080 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 805
 #line 5085 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 809
 #line 5096 "cs-parser.jay"
   {
 	  	var sl = yyVals[-2+yyTop] as StatementList;
 	  	if (sl == null) {
 	  		sl = new StatementList ((Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop]);
 			lbag.AddStatement (sl, GetLocation (yyVals[-1+yyTop]));
 	  	} else {
 	  		sl.Add ((Statement) yyVals[0+yyTop]);
 	  		lbag.AppendTo (sl, GetLocation (yyVals[-1+yyTop]));
 	  	}
 	  		
 		yyVal = sl;
 	  }
   break;
 case 810
 #line 5112 "cs-parser.jay"
   {
 		Report.Error (230, GetLocation (yyVals[-5+yyTop]), "Type and identifier are both required in a foreach statement");
 		yyVal = null;
 	  }
   break;
 case 811
 #line 5117 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-5+yyTop]));
 		current_block.IsCompilerGenerated = true;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.ForeachVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		yyVal = li;
 	  }
   break;
 case 812
 #line 5127 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Foreach f = new Foreach ((Expression) yyVals[-6+yyTop], (LocalVariable) yyVals[-1+yyTop], (Expression) yyVals[-3+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-8+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 819
 #line 5150 "cs-parser.jay"
   {
 		yyVal = new Break (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 820
 #line 5158 "cs-parser.jay"
   {
 		yyVal = new Continue (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 821
 #line 5166 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new Goto (lt.Value, lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 822
 #line 5172 "cs-parser.jay"
   {
 		yyVal = new GotoCase ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 823
 #line 5177 "cs-parser.jay"
   {
 		yyVal = new GotoDefault (GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 824
 #line 5185 "cs-parser.jay"
   {
 		yyVal = new Return ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 825
 #line 5193 "cs-parser.jay"
   {
 		yyVal = new Throw ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 826
 #line 5201 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (yyVals[-1+yyTop] == null) {
 			Report.Error (1627, GetLocation (yyVals[0+yyTop]), "Expression expected after yield return");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new Yield ((Expression) yyVals[-1+yyTop], lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 827
 #line 5217 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new YieldBreak (lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 830
 #line 5239 "cs-parser.jay"
   {
 		yyVal = new TryCatch ((Block) yyVals[-1+yyTop], (List<Catch>) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]), false);
 	  }
   break;
 case 831
 #line 5243 "cs-parser.jay"
   {
 		yyVal = new TryFinally ((Statement) yyVals[-2+yyTop], (Block) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 832
 #line 5248 "cs-parser.jay"
   {
 		yyVal = new TryFinally (new TryCatch ((Block) yyVals[-3+yyTop], (List<Catch>) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]), true), (Block) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 833
 #line 5253 "cs-parser.jay"
   {
 		Report.Error (1524, GetLocation (yyVals[-2+yyTop]), "Expected catch or finally");
 		yyVal = null;
 	  }
   break;
 case 834
 #line 5261 "cs-parser.jay"
   {
 		var l = new List<Catch> (2);
 
 		l.Add ((Catch) yyVals[0+yyTop]);
 		yyVal = l;
 	  }
   break;
 case 835
 #line 5268 "cs-parser.jay"
   {
 		var l = (List<Catch>) yyVals[-1+yyTop];
 		
 		Catch c = (Catch) yyVals[0+yyTop];
 		if (l [0].IsGeneral) {
 			Report.Error (1017, c.loc, "Try statement already has an empty catch block");
 		} else {
 			if (c.IsGeneral)
 				l.Insert (0, c);
 			else
 				l.Add (c);
 		}
 		
 		yyVal = l;
 	  }
   break;
 case 838
 #line 5292 "cs-parser.jay"
   {
 		yyVal = new Catch ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 839
 #line 5296 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-3+yyTop]));
 		var c = new Catch (current_block, GetLocation (yyVals[-4+yyTop]));
 		c.TypeExpression = (FullNamedExpression) yyVals[-2+yyTop];
 
 		if (yyVals[-1+yyTop] != null) {
 			var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
 			current_block.AddLocalName (c.Variable);
 		}
 		
 		lbag.AddLocation (c, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 840
 #line 5311 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 841
 #line 5315 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_PARENS) {
 			Report.Error (1015, lexer.Location,
 				"A type that derives from `System.Exception', `object', or `string' expected");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 		
 		yyVal = new Catch (null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 842
 #line 5329 "cs-parser.jay"
   {
 		yyVal = new Checked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 843
 #line 5336 "cs-parser.jay"
   {
 		yyVal = new Unchecked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 844
 #line 5343 "cs-parser.jay"
   {
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 845
 #line 5346 "cs-parser.jay"
   {
 		yyVal = new Unsafe ((Block) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 846
 #line 5353 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new Lock ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 847
 #line 5364 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.FixedVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Fixed.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 848
 #line 5373 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 849
 #line 5378 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Fixed f = new Fixed ((Fixed.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 850
 #line 5390 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.UsingVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Using.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 851
 #line 5399 "cs-parser.jay"
   {
 		yyVal = current_variable;	  
 		current_variable = null;
 	  }
   break;
 case 852
 #line 5404 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Using.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (u);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 853
 #line 5413 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (u, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = u;
 	  }
   break;
 case 854
 #line 5425 "cs-parser.jay"
   {
 		Report.Error (210, lexer.Location, "You must provide an initializer in a fixed or using statement declaration");
 	  }
   break;
 case 855
 #line 5429 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		yyVal = current_variable;
 	  }
   break;
 case 856
 #line 5440 "cs-parser.jay"
   {
 		lexer.query_parsing = false;
 			
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 857
 #line 5452 "cs-parser.jay"
   {
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 858
 #line 5463 "cs-parser.jay"
   {
 	        lexer.query_parsing = false;
 		yyVal = yyVals[-1+yyTop];
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 859
 #line 5470 "cs-parser.jay"
   {
 	        yyVal = yyVals[-1+yyTop];
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 860
 #line 5479 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 861
 #line 5487 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 862
 #line 5502 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 863
 #line 5510 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 864
 #line 5525 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 865
 #line 5529 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 866
 #line 5540 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 867
 #line 5544 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop])) {
 			IdentifierType = (FullNamedExpression)yyVals[-4+yyTop]
 		};
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 868
 #line 5561 "cs-parser.jay"
   {
 	  	Linq.AQueryClause head = (Linq.AQueryClause)yyVals[-1+yyTop];
 		
 		if (yyVals[0+yyTop] != null)
 			head.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 				
 		if (yyVals[-2+yyTop] != null) {
 			Linq.AQueryClause clause = (Linq.AQueryClause)yyVals[-2+yyTop];
 			clause.Tail.Next = head;
 			head = clause;
 		}
 		
 		yyVal = head;
 	  }
   break;
 case 870
 #line 5577 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 871
 #line 5585 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 872
 #line 5589 "cs-parser.jay"
   {
 		yyVal = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 873
 #line 5596 "cs-parser.jay"
   {
 	  	if (linq_clause_blocks == null)
 	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
 	  }
   break;
 case 874
 #line 5604 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 875
 #line 5611 "cs-parser.jay"
   {
 		yyVal = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)yyVals[-3+yyTop], linq_clause_blocks.Pop (), (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 879
 #line 5627 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-1+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 885
 #line 5643 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 886
 #line 5647 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 	  	yyVal = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  	
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 887
 #line 5661 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 888
 #line 5665 "cs-parser.jay"
   {
 		yyVal = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 889
 #line 5675 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 890
 #line 5683 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 891
 #line 5691 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 892
 #line 5699 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];	
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-11+yyTop]));
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 			
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location);
 
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-11+yyTop]));	
 		}
 
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);
 	  }
   break;
 case 893
 #line 5735 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 894
 #line 5743 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 895
 #line 5751 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 896
 #line 5759 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;		
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 		
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location); /* TODO
 			
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};			
 		}
 		
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
 	  }
   break;
 case 898
 #line 5803 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 899
 #line 5810 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 900
 #line 5814 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 902
 #line 5825 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 903
 #line 5832 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	  }
   break;
 case 905
 #line 5841 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, (Linq.QueryBlock) current_block, lexer.Location);	 
 	 }
   break;
 case 906
 #line 5848 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	 }
   break;
 case 907
 #line 5856 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 908
 #line 5860 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 909
 #line 5864 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 910
 #line 5871 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 911
 #line 5875 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 912
 #line 5879 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 914
 #line 5888 "cs-parser.jay"
   {
 		/* query continuation block is not linked with query block but with block*/
 		/* before. This means each query can use same range variable names for*/
 		/* different identifiers.*/
 
 		current_block.SetEndLocation (GetLocation (yyVals[-1+yyTop]));
 		current_block = current_block.Parent;
 	
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
 	  }
   break;
 case 915
 #line 5904 "cs-parser.jay"
   {
 		var current_block = linq_clause_blocks.Pop ();	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
   		yyVal = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation (yyVals[-3+yyTop])) {
   			next = (Linq.AQueryClause)yyVals[0+yyTop]
   		};
 	  }
   break;
 case 918
 #line 5930 "cs-parser.jay"
   { 
 	        Evaluator.LoadAliases (current_namespace);
 
 		push_current_class (new Class (current_namespace, current_class, new MemberName ("Class" + class_count++),
 			Modifiers.PUBLIC, null), null);
 
 		var baseclass_list = new List<FullNamedExpression> ();
 		baseclass_list.Add (new TypeExpression (Evaluator.InteractiveBaseClass, lexer.Location));
 		current_container.AddBasesForPart (current_class, baseclass_list);
 
 		/* (ref object retval)*/
 		Parameter [] mpar = new Parameter [1];
 		mpar [0] = new Parameter (new TypeExpression (TypeManager.object_type, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);
 
 		ParametersCompiled pars = new ParametersCompiled (mpar);
 		current_local_parameters = pars;
 		Method method = new Method (
 			current_class,
 			null, /* generic*/
 			new TypeExpression (TypeManager.void_type, Location.Null),
 			Modifiers.PUBLIC | Modifiers.STATIC,
 			new MemberName ("Host"),
 			pars,
 			null /* attributes */);
 
 		oob_stack.Push (method);
 	        ++lexer.parsing_block;
 		start_block (lexer.Location);
 	  }
   break;
 case 919
 #line 5960 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		Method method = (Method) oob_stack.Pop ();
 
 		method.Block = (ToplevelBlock) end_block(lexer.Location);
 		current_container.AddMethod (method);
 
 		--lexer.parsing_declaration;
 		InteractiveResult = pop_current_class ();
 		current_local_parameters = null;
 	  }
   break;
 case 920
 #line 5971 "cs-parser.jay"
   {
 	        Evaluator.LoadAliases (current_namespace);
 	  }
   break;
 #line default
         }
         yyTop -= yyLen[yyN];
         yyState = yyStates[yyTop];
         int yyM = yyLhs[yyN];
         if (yyState == 0 && yyM == 0) {
           if (debug != null) debug.shift(0, yyFinal);
           yyState = yyFinal;
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
                debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
           }
           if (yyToken == 0) {
             if (debug != null) debug.accept(yyVal);
             return yyVal;
           }
           goto continue_yyLoop;
         }
         if (((yyN = yyGindex[yyM]) != 0) && ((yyN += yyState) >= 0)
             && (yyN < yyTable.Length) && (yyCheck[yyN] == yyState))
           yyState = yyTable[yyN];
         else
           yyState = yyDgoto[yyM];
         if (debug != null) debug.shift(yyStates[yyTop], yyState);
 	 goto continue_yyLoop;
       continue_yyDiscarded
       }
     continue_yyLoop
     }
     /*yyLoop
       if (yyTop >= yyStates.Length) {			// dynamically increase
         global
         global
       }
       yyStates[yyTop] = yyState;
       yyVals[yyTop] = yyVal;
       if (debug != null) debug.push(yyState, yyVal);
 
       /*yyDiscarded
         int yyN;
         if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
               debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
           }
           if ((yyN = yySindex[yyState]) != 0 && ((yyN += yyToken) >= 0)
               && (yyN < yyTable.Length) && (yyCheck[yyN] == yyToken)) {
             if (debug != null)
               debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
             yyState = yyTable[yyN];		// shift to yyN
             yyVal = yyLex.value();
             yyToken = -1;
             if (yyErrorFlag > 0) -- yyErrorFlag;
             goto continue_yyLoop;
           }
           if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
               && yyN < yyTable.Length && yyCheck[yyN] == yyToken)
             yyN = yyTable[yyN];			// reduce (yyN)
           else
             switch (yyErrorFlag) {
   
             case 0
               yyExpectingState = yyState;
               // yyerror(String.Format ("syntax error, got token `{0}'", yyname (yyToken)), yyExpecting(yyState));
               if (debug != null) debug.error("syntax error");
               if (yyToken == 0 /*eof*/ || yyToken == eof_token) throw new yyParser.yyUnexpectedEof ();
               goto case 1;
             case 1
               yyErrorFlag = 3;
               do {
                 if ((yyN = yySindex[yyStates[yyTop]]) != 0
                     && (yyN += Token.yyErrorCode) >= 0 && yyN < yyTable.Length
                     && yyCheck[yyN] == Token.yyErrorCode) {
                   if (debug != null)
                     debug.shift(yyStates[yyTop], yyTable[yyN], 3);
                   yyState = yyTable[yyN];
                   yyVal = yyLex.value();
                   goto continue_yyLoop;
                 }
                 if (debug != null) debug.pop(yyStates[yyTop]);
               } while (-- yyTop >= 0);
               if (debug != null) debug.reject();
               throw new yyParser.yyException("irrecoverable syntax error");
   
             case 3
               if (yyToken == 0) {
                 if (debug != null) debug.reject();
                 throw new yyParser.yyException("irrecoverable syntax error at end-of-file");
               }
               if (debug != null)
                 debug.discard(yyState, yyToken, yyname(yyToken),
   							yyLex.value());
               yyToken = -1;
               goto continue_yyDiscarded;		// leave stack alone
             }
         }
         int yyV = yyTop + 1-yyLen[yyN];
         if (debug != null)
           debug.reduce(yyState, yyStates[yyV-1], yyN, YYRules.getRule (yyN), yyLen[yyN]);
         yyVal = yyV > yyTop ? null 
         switch (yyN) {
 case 5
 #line 375 "cs-parser.jay"
   { Lexer.CompleteOnEOF = false; }
   break;
 case 7
 #line 380 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 8
 #line 384 "cs-parser.jay"
   {
 		Lexer.check_incorrect_doc_comment ();
 	  }
   break;
 case 16
 #line 407 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "alias"){
 			syntax_error (lt.Location, "`alias' expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (lt.Location, "external alias");
 		} else {
 			lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop]; 
 			current_namespace.AddUsingExternalAlias (lt.Value, lt.Location, Report);
 		}
 	  }
   break;
 case 17
 #line 420 "cs-parser.jay"
   {
 	  	syntax_error (GetLocation (yyVals[-1+yyTop]), "`alias' expected");   /* TODO
 	  }
   break;
 case 20
 #line 432 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 21
 #line 437 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 22
 #line 445 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		current_namespace.AddUsingAlias (lt.Value, (MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 23
 #line 450 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 24
 #line 458 "cs-parser.jay"
   {
 		current_namespace.AddUsing ((MemberName) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 25
 #line 470 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (yyVals[-2+yyTop] != null) {
 			Report.Error(1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
 		}
 
 		current_namespace = new NamespaceEntry (module,
 			current_namespace, file, name.GetName ());
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 26
 #line 483 "cs-parser.jay"
   { 
 		current_namespace = current_namespace.Parent;
 		current_class = current_namespace.SlaveDeclSpace;
 		current_container = current_class.PartialContainer;
 	  }
   break;
 case 27
 #line 492 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName (lt.Value, lt.Location);
 	  }
   break;
 case 28
 #line 497 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 29
 #line 502 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new MemberName ("<invalid>", lexer.Location);
 	  }
   break;
 case 34
 #line 520 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[0+yyTop];
 
 		if (name.TypeArguments != null)
 			syntax_error (lexer.Location, "namespace name expected");
 
 		yyVal = name;
 	  }
   break;
 case 35
 #line 532 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 45
 #line 564 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			DeclSpace ds = (DeclSpace)yyVals[0+yyTop];
 
 			if ((ds.ModFlags & (Modifiers.PRIVATE|Modifiers.PROTECTED)) != 0){
 				Report.Error (1527, ds.Location, 
 				"Namespace elements cannot be explicitly declared as private, protected or protected internal");
 			}
 		}
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 46
 #line 576 "cs-parser.jay"
   {
 		current_namespace.DeclarationFound = true;
 	  }
   break;
 case 47
 #line 580 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	 }
   break;
 case 53
 #line 606 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			Attributes attrs = (Attributes)yyVals[0+yyTop];
 			if (global_attrs_enabled) {
 				module.AddAttributes (attrs.Attrs, current_namespace);
 			} else {
 				foreach (Attribute a in attrs.Attrs) {
 					Report.Error (1730, a.Location, "Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
 				}
 			}
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 54
 #line 623 "cs-parser.jay"
   {
 		global_attrs_enabled = false;
 		yyVal = null;
       }
   break;
 case 55
 #line 628 "cs-parser.jay"
   { 
 		global_attrs_enabled = false;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 56
 #line 637 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect, current_namespace);
 					yyVal = null;
 				} else {
 					yyVal = new Attributes (sect);
 				}
 				if (yyVal == null) {
 					if (RootContext.Documentation != null) {
 						Lexer.check_incorrect_doc_comment ();
 						Lexer.doc_state =
 							XmlCommentState.Allowed;
 					}
 				}
 			} else {
 				yyVal = new Attributes (sect);
 			}		
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 57
 #line 664 "cs-parser.jay"
   {
 		if (current_attr_target != String.Empty) {
 			Attributes attrs = yyVals[-1+yyTop] as Attributes;
 			var sect = (List<Attribute>) yyVals[0+yyTop];
 
 			if (global_attrs_enabled) {
 				if (!string.IsNullOrEmpty (current_attr_target)) {
 					module.AddAttributes (sect);
 					yyVal = null;
 				} else {
 					if (attrs == null)
 						attrs = new Attributes (sect);
 					else
 						attrs.AddAttributes (sect);			
 				}
 			} else {
 				if (attrs == null)
 					attrs = new Attributes (sect);
 				else
 					attrs.AddAttributes (sect);
 			}		
 			yyVal = attrs;
 		}
 		else
 			yyVal = null;
 		current_attr_target = null;
 	  }
   break;
 case 58
 #line 695 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
  	  }
   break;
 case 59
 #line 699 "cs-parser.jay"
   {
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 60
 #line 706 "cs-parser.jay"
   {
 		current_attr_target = (string)yyVals[-1+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 61
 #line 714 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = CheckAttributeTarget (lt.Value, lt.Location);
 	  }
   break;
 case 62
 #line 718 "cs-parser.jay"
   { yyVal = "event"; }
   break;
 case 63
 #line 719 "cs-parser.jay"
   { yyVal = "return"; }
   break;
 case 64
 #line 721 "cs-parser.jay"
   {
 		string name = GetTokenName (yyToken);
 		yyVal = CheckAttributeTarget (name, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 65
 #line 729 "cs-parser.jay"
   {
 		yyVal = new List<Attribute> (4) { (Attribute) yyVals[0+yyTop] };
 	  }
   break;
 case 66
 #line 733 "cs-parser.jay"
   {
 		var attrs = (List<Attribute>) yyVals[-2+yyTop];
 		attrs.Add ((Attribute) yyVals[0+yyTop]);
 
 		yyVal = attrs;
 	  }
   break;
 case 67
 #line 743 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 68
 #line 747 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		MemberName mname = (MemberName) yyVals[-2+yyTop];
 		if (mname.IsGeneric) {
 			Report.Error (404, lexer.Location,
 				      "'<' unexpected
 		}
 
 		Arguments [] arguments = (Arguments []) yyVals[0+yyTop];
 		ATypeNameExpression expr = mname.GetTypeExpression ();
 
 		if (current_attr_target == String.Empty)
 			yyVal = null;
 		else if (global_attrs_enabled && (current_attr_target == "assembly" || current_attr_target == "module"))
 			/* FIXME
 			yyVal = new GlobalAttribute (current_namespace, current_attr_target,
 						  expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 		else
 			yyVal = new Attribute (current_attr_target, expr, arguments, mname.Location, lexer.IsEscapedIdentifier (mname));
 	  }
   break;
 case 69
 #line 770 "cs-parser.jay"
   { /* reserved attribute name or identifier
   break;
 case 70
 #line 774 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 71
 #line 776 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 72
 #line 783 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 73
 #line 785 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = new Arguments [] { a, null };
 	  }
   break;
 case 74
 #line 791 "cs-parser.jay"
   {
 	  	Arguments a = new Arguments (4);
 		a.Add ((Argument) yyVals[0+yyTop]);  
 		yyVal = new Arguments [] { null, a };
 	  }
   break;
 case 75
 #line 797 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] != null) {
 			Report.Error (1016, ((Argument) yyVals[0+yyTop]).Expr.Location, "Named attribute arguments must appear after the positional arguments");
 			o [0] = new Arguments (4);
 		}
 		
 		Arguments args = ((Arguments) o [0]);
 		if (args.Count > 0 && !(yyVals[0+yyTop] is NamedArgument) && args [args.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 		
 		args.Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 76
 #line 811 "cs-parser.jay"
   {
 		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
 		if (o [1] == null) {
 			o [1] = new Arguments (4);
 		}
 
 		((Arguments) o [1]).Add ((Argument) yyVals[0+yyTop]);
 	  }
   break;
 case 77
 #line 823 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 79
 #line 831 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 80
 #line 835 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop]);	  
 	  }
   break;
 case 81
 #line 844 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "named argument");
 			
 		/* Avoid boxing in common case (no modifier)*/
 		var arg_mod = yyVals[-1+yyTop] == null ? Argument.AType.None 
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop], arg_mod);
 	  }
   break;
 case 82
 #line 857 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 83
 #line 859 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Ref;
 	  }
   break;
 case 84
 #line 863 "cs-parser.jay"
   { 
 		yyVal = Argument.AType.Out;
 	  }
   break;
 case 99
 #line 891 "cs-parser.jay"
   {
 		Report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
 			GetSymbolName (yyToken));
 		yyVal = null;
 		lexer.parsing_generic_declaration = false;
 	  }
   break;
 case 100
 #line 904 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 101
 #line 908 "cs-parser.jay"
   { 
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Struct (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 102
 #line 914 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null)
 			current_container.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 103
 #line 925 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 104
 #line 931 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 105
 #line 936 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 	  }
   break;
 case 106
 #line 943 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 107
 #line 948 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 122
 #line 985 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var mod = (Modifiers) yyVals[-3+yyTop];
 		current_field = new Const (current_class, (FullNamedExpression) yyVals[-1+yyTop], mod, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 		current_container.AddConstant ((Const) current_field);
 		
 		if ((mod & Modifiers.STATIC) != 0) {
 			Report.Error (504, current_field.Location, "The constant `{0}' cannot be marked static", current_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_field;
 	  }
   break;
 case 123
 #line 998 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_field = null;
 	  }
   break;
 case 126
 #line 1017 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 127
 #line 1021 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 128
 #line 1028 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 129
 #line 1037 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 130
 #line 1041 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 131
 #line 1046 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 		yyVal = null;
 	  }
   break;
 case 134
 #line 1061 "cs-parser.jay"
   {
 	  	lexer.parsing_generic_declaration = false;
 
 		FullNamedExpression type = (FullNamedExpression) yyVals[-1+yyTop];
 		if (type.Type == TypeManager.void_type)
 			Report.Error (670, GetLocation (yyVals[-1+yyTop]), "Fields cannot have void type");
 			
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new Field (current_class, type, (Modifiers) yyVals[-2+yyTop], new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-3+yyTop]);
 		current_container.AddField (current_field);
 		yyVal = current_field;
 	  }
   break;
 case 135
 #line 1076 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 			
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 		current_field = null;
 	  }
   break;
 case 136
 #line 1089 "cs-parser.jay"
   { 
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "fixed size buffers");
 
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		current_field = new FixedField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop],
 			new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 			
 		current_container.AddField (current_field);
 	  }
   break;
 case 137
 #line 1100 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 	    }
 
 		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];	    
 		lbag.AddMember (current_field, mod_locations, GetLocation (yyVals[0+yyTop]));
 		yyVal = current_field;
 	    current_field = null;
 	  }
   break;
 case 138
 #line 1115 "cs-parser.jay"
   {
 		Report.Error (1641, GetLocation (yyVals[-1+yyTop]), "A fixed size buffer field must have the array size specifier after the field name");
 	  }
   break;
 case 140
 #line 1123 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 141
 #line 1129 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_field.Initializer = (Expression) yyVals[0+yyTop];
 		end_block (lexer.Location);
 		current_local_parameters = null;
 	  }
   break;
 case 144
 #line 1144 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 145
 #line 1148 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 146
 #line 1155 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 147
 #line 1161 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 148
 #line 1165 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 151
 #line 1180 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 152
 #line 1184 "cs-parser.jay"
   {
 		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 153
 #line 1191 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];	  
 		yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 154
 #line 1200 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 155
 #line 1204 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = new ConstInitializer (current_field, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 156
 #line 1210 "cs-parser.jay"
   {
 		Report.Error (443, lexer.Location, "Value or constant expected");
 		yyVal = null;
 	  }
   break;
 case 159
 #line 1220 "cs-parser.jay"
   {
 		/* It has to be here for the parent to safely restore artificial block*/
 	  	Error_SyntaxError (yyToken);
 	  	yyVal = null;
 	  }
   break;
 case 160
 #line 1228 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 161
 #line 1233 "cs-parser.jay"
   {
 		Method method = (Method) yyVals[-2+yyTop];
 		method.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (method);
 		
 		if (current_container.Kind == MemberKind.Interface && method.Block != null) {
 			Report.Error (531, method.Location, "`{0}'
 		}
 
 		current_local_parameters = null;
 
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 162
 #line 1254 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 163
 #line 1258 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 164
 #line 1262 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 						     (FullNamedExpression) yyVals[-7+yyTop], current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		} else if (yyVals[0+yyTop] != null) {
 			Report.Error (80, GetLocation (yyVals[0+yyTop]),
 				"Constraints are not allowed on non-generic declarations");
 		}
 
 		Method method = new Method (current_class, generic, (FullNamedExpression) yyVals[-7+yyTop], (Modifiers) yyVals[-8+yyTop],
 				     name, current_local_parameters, (Attributes) yyVals[-9+yyTop]);
 				     
 		if (yyVals[0+yyTop] != null && ((method.ModFlags & Modifiers.OVERRIDE) != 0 || method.IsExplicitImpl)) {
 			Report.Error (460, method.Location,
 				"`{0}'
 				method.GetSignatureForError ());
 		}
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 165
 #line 1299 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 166
 #line 1303 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 167
 #line 1307 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 		valid_param_mod = 0;
 
 		MemberName name = (MemberName) yyVals[-6+yyTop];
 		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
 
 		if (yyVals[-1+yyTop] != null && name.TypeArguments == null)
 			Report.Error (80, lexer.Location,
 				      "Constraints are not allowed on non-generic declarations");
 
 		Method method;
 		GenericMethod generic = null;
 		if (name.TypeArguments != null) {
 			generic = new GenericMethod (current_namespace, current_class, name,
 				new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				current_local_parameters);
 
 			generic.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		}
 
 		var modifiers = (Modifiers) yyVals[-9+yyTop];
 
 
 		const Modifiers invalid_partial_mod = Modifiers.AccessibilityMask | Modifiers.ABSTRACT | Modifiers.EXTERN |
 			Modifiers.NEW | Modifiers.OVERRIDE | Modifiers.SEALED | Modifiers.VIRTUAL;
 
 		if ((modifiers & invalid_partial_mod) != 0) {
 			Report.Error (750, name.Location, "A partial method cannot define access modifier or " +
        			"any of abstract, extern, new, override, sealed, or virtual modifiers");
 			modifiers &= ~invalid_partial_mod;
 		}
 
 		if ((current_class.ModFlags & Modifiers.PARTIAL) == 0) {
 			Report.Error (751, name.Location, "A partial method must be declared within a " +
        			"partial class or partial struct");
 		}
 		
 		modifiers |= Modifiers.PARTIAL | Modifiers.PRIVATE;
 		
 		method = new Method (current_class, generic, new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-7+yyTop])),
 				     modifiers, name, current_local_parameters, (Attributes) yyVals[-10+yyTop]);
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		/* TODO
 		StoreModifierLocation (Modifiers.PARTIAL, GetLocation (yyVals[-8+yyTop]));
 		lbag.AddMember (method, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = method;
 	  }
   break;
 case 168
 #line 1362 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		Report.Error (1585, name.Location, 
 			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) yyVals[-4+yyTop]));
 
 		Method method = new Method (current_class, null, (FullNamedExpression) yyVals[-5+yyTop],
 					    0, name, (ParametersCompiled) yyVals[-1+yyTop], (Attributes) yyVals[-7+yyTop]);
 
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
 
 		yyVal = method;
 	  }
   break;
 case 170
 #line 1381 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 171
 #line 1385 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 173
 #line 1391 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 	  	yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 174
 #line 1396 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = new ParametersCompiled (pars_list.ToArray ()); 
 	  }
   break;
 case 175
 #line 1403 "cs-parser.jay"
   {
 		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[0+yyTop])));
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 176
 #line 1409 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[-2+yyTop] } );			
 	  }
   break;
 case 177
 #line 1416 "cs-parser.jay"
   {
 		if (yyVals[-2+yyTop] != null)
 			Report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 178
 #line 1426 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[-2+yyTop])) }, true);
 	  }
   break;
 case 179
 #line 1432 "cs-parser.jay"
   {
 		Report.Error (257, GetLocation (yyVals[-2+yyTop]), "An __arglist parameter must be the last parameter in a formal parameter list");
 
 		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
 		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
 
 		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
 	  }
   break;
 case 180
 #line 1441 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[0+yyTop] } );
 	  }
   break;
 case 181
 #line 1445 "cs-parser.jay"
   {
 		yyVal = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation (yyVals[0+yyTop])) }, true);
 	  }
   break;
 case 182
 #line 1449 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 183
 #line 1457 "cs-parser.jay"
   {
 		parameters_bucket.Clear ();
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		parameters_bucket.Add (p);
 		
 		default_parameter_used = p.HasDefaultValue;
 		yyVal = parameters_bucket;
 	  }
   break;
 case 184
 #line 1466 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter) yyVals[0+yyTop];
 		if (p != null) {
 			if (p.HasExtensionMethodModifier)
 				Report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
 			else if (!p.HasDefaultValue && default_parameter_used)
 				Report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");
 
 			default_parameter_used |= p.HasDefaultValue;
 			pars.Add (p);
 			
 			lbag.AddLocation (p, GetLocation (yyVals[-1+yyTop]));
 		}
 		
 		yyVal = yyVals[-2+yyTop];
 	  }
   break;
 case 185
 #line 1490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 186
 #line 1498 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		Report.Error (1552, lt.Location, "Array type specifier, [], must appear before parameter name");
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Parameter.Modifier) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop], lt.Location);
 	  }
   break;
 case 187
 #line 1507 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  	Location l = GetLocation (yyVals[0+yyTop]);
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], "NeedSomeGeneratorHere", (Parameter.Modifier) yyVals[-2+yyTop], (Attributes) yyVals[-3+yyTop], l);
 	  }
   break;
 case 188
 #line 1517 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 189
 #line 1521 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		if (RootContext.Version <= LanguageVersion.V_3) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "optional parameter");
 		}
 		
 		Parameter.Modifier mod = (Parameter.Modifier) yyVals[-5+yyTop];
 		if (mod != Parameter.Modifier.NONE) {
 			switch (mod) {
 			case Parameter.Modifier.REF
 			case Parameter.Modifier.OUT
 				Report.Error (1741, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 				
 			case Parameter.Modifier.This
 				Report.Error (1743, GetLocation (yyVals[-5+yyTop]), "Cannot specify a default value for the `{0}' parameter",
 					Parameter.GetModifierSignature (mod));
 				break;
 			default
 				throw new NotImplementedException (mod.ToString ());
 			}
 				
 			mod = Parameter.Modifier.NONE;
 		}
 		
 		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
 			Report.Error (1065, GetLocation (yyVals[-2+yyTop]), "Optional parameter is not valid in this context");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-4+yyTop], lt.Value, mod, (Attributes) yyVals[-6+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 		
 		if (yyVals[0+yyTop] != null)
 			((Parameter) yyVal).DefaultValue = new DefaultParameterValueExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 190
 #line 1560 "cs-parser.jay"
   { yyVal = Parameter.Modifier.NONE; }
   break;
 case 192
 #line 1566 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 193
 #line 1570 "cs-parser.jay"
   {
 		Parameter.Modifier p2 = (Parameter.Modifier)yyVals[0+yyTop];
   		Parameter.Modifier mod = (Parameter.Modifier)yyVals[-1+yyTop] | p2;
   		if (((Parameter.Modifier)yyVals[-1+yyTop] & p2) == p2) {
   			Error_DuplicateParameterModifier (lexer.Location, p2);
   		} else {
 	  		switch (mod & ~Parameter.Modifier.This) {
   				case Parameter.Modifier.REF
 					Report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
   					break;
    				case Parameter.Modifier.OUT
 					Report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
   					break;
   				default
  					Report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
  					break;
  			}
   		}
   		yyVal = mod;
 	  }
   break;
 case 194
 #line 1594 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
 	  		Error_ParameterModifierNotValid ("ref", GetLocation (yyVals[0+yyTop]));
 	  		
 	  	yyVal = Parameter.Modifier.REF;
 	  }
   break;
 case 195
 #line 1601 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
 	  		Error_ParameterModifierNotValid ("out", GetLocation (yyVals[0+yyTop]));
 	  
 	  	yyVal = Parameter.Modifier.OUT;
 	  }
   break;
 case 196
 #line 1608 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.This) == 0)
 	  		Error_ParameterModifierNotValid ("this", GetLocation (yyVals[0+yyTop]));
 
 	  	if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "extension methods");
 	  			
 		yyVal = Parameter.Modifier.This;
 	  }
   break;
 case 197
 #line 1621 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Attributes) yyVals[-3+yyTop], lt.Location);
 	  }
   break;
 case 198
 #line 1626 "cs-parser.jay"
   {
 		Report.Error (1751, GetLocation (yyVals[-4+yyTop]), "Cannot specify a default value for a parameter array");
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, (Attributes) yyVals[-5+yyTop], lt.Location);		
 	  }
   break;
 case 199
 #line 1633 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 200
 #line 1641 "cs-parser.jay"
   {
 		if ((valid_param_mod & ParameterModifierType.Params) == 0)
 			Report.Error (1670, (GetLocation (yyVals[0+yyTop])), "The `params' modifier is not allowed in current context");
 	  }
   break;
 case 201
 #line 1646 "cs-parser.jay"
   {
 		Parameter.Modifier mod = (Parameter.Modifier)yyVals[0+yyTop];
 		if ((mod & Parameter.Modifier.This) != 0) {
 			Report.Error (1104, GetLocation (yyVals[-1+yyTop]), "The parameter modifiers `this' and `params' cannot be used altogether");
 		} else {
 			Report.Error (1611, GetLocation (yyVals[-1+yyTop]), "The params parameter cannot be declared as ref or out");
 		}	  
 	  }
   break;
 case 202
 #line 1655 "cs-parser.jay"
   {
 		Error_DuplicateParameterModifier (GetLocation (yyVals[-1+yyTop]), Parameter.Modifier.PARAMS);
 	  }
   break;
 case 203
 #line 1662 "cs-parser.jay"
   {
 	  	if ((valid_param_mod & ParameterModifierType.Arglist) == 0)
 	  		Report.Error (1669, GetLocation (yyVals[0+yyTop]), "__arglist is not valid in this context");
 	  }
   break;
 case 204
 #line 1673 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			tmpComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 205
 #line 1678 "cs-parser.jay"
   {
 		current_property = new Property (current_class, (FullNamedExpression) yyVals[-3+yyTop], (Modifiers) yyVals[-4+yyTop],
 			(MemberName) yyVals[-2+yyTop], (Attributes) yyVals[-5+yyTop]);
 			
 		if (current_property.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (547, GetLocation (yyVals[-3+yyTop]), "`{0}'
 			
 		current_container.AddProperty ((Property)current_property);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[0+yyTop]));
 		
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 206
 #line 1691 "cs-parser.jay"
   {
 		lexer.PropertyParsing = false;
 		
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();				
 	  }
   break;
 case 207
 #line 1698 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_property, GetLocation (yyVals[0+yyTop]));
 		current_property = null;
 	  }
   break;
 case 208
 #line 1708 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 209
 #line 1712 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  
 		Indexer indexer = new Indexer (current_class, (FullNamedExpression) yyVals[-6+yyTop],
 			(MemberName)yyVals[-5+yyTop], (Modifiers) yyVals[-7+yyTop], (ParametersCompiled) yyVals[-2+yyTop], (Attributes) yyVals[-8+yyTop]);
 			
 		current_property = indexer;
 
   		current_container.AddIndexer (indexer);
 		lbag.AddMember (current_property, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
   		
 		if (indexer.TypeExpression.Type == TypeManager.void_type)
 			Report.Error (620, GetLocation (yyVals[-6+yyTop]), "`{0}'
 
 		if (indexer.Parameters.IsEmpty) {
 			Report.Error (1551, GetLocation (yyVals[-4+yyTop]), "Indexers must have at least one parameter");
 		}
 
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		lexer.PropertyParsing = true;
 	  }
   break;
 case 210
 #line 1738 "cs-parser.jay"
   {
 		  lexer.PropertyParsing = false;
 	  }
   break;
 case 211
 #line 1742 "cs-parser.jay"
   { 
 		if (RootContext.Documentation != null)
 			current_property.DocComment = ConsumeStoredComment ();
 			
 		lbag.AppendToMember (current_property, GetLocation (yyVals[-1+yyTop]));
 		current_property = null;		
 	  }
   break;
 case 216
 #line 1758 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_BRACE) {
 	  		Report.Error (548, lexer.Location, "`{0}'
 		} else {
 			if (yyToken == Token.SEMICOLON)
 				Report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
 			else
 				Report.Error (1014, GetLocation (yyVals[0+yyTop]), "A get or set accessor expected");
 		}
 	  }
   break;
 case 217
 #line 1772 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 	  
 		if (current_property.Get != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 		
 		if (current_property is Indexer) {
 			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop], ((Indexer)current_property).ParameterInfo.Clone (),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Get = new Property.GetMethod (current_property,
 				(Modifiers) yyVals[-1+yyTop], (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}	
 	  
 		current_local_parameters = current_property.Get.ParameterInfo;	  
 		lbag.AddMember (current_property.Get, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 218
 #line 1794 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] != null) {
 	  		current_property.Get.Block = (ToplevelBlock) yyVals[0+yyTop];			
 	  	
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Get.Block.StartLocation,
 					"`{0}'
 			}		
 		}
 	  
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null)
 			if (Lexer.doc_state == XmlCommentState.Error)
 				Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 219
 #line 1815 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] != ModifierNone && RootContext.Version == LanguageVersion.ISO_1) {
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
 		}
 		
 		if (current_property.Set != null) {
 			Report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
 		}
 	  
 		if (current_property is Indexer) {
 			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop],
 				ParametersCompiled.MergeGenerated (compiler,
 				((Indexer)current_property).ParameterInfo, true, new Parameter (
 					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation (yyVals[0+yyTop])),
 					null),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		} else {
 			current_property.Set = new Property.SetMethod (current_property, (Modifiers) yyVals[-1+yyTop], 
 				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation (yyVals[0+yyTop])),
 				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		}
 		
 		current_local_parameters = current_property.Set.ParameterInfo;	
 		lbag.AddMember (current_property.Set, mod_locations);
 		lexer.PropertyParsing = false;
 	  }
   break;
 case 220
 #line 1842 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {		
 			current_property.Set.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 			if (current_container.Kind == MemberKind.Interface) {
 				Report.Error (531, current_property.Set.Block.StartLocation,
 					"`{0}'
 			}
 		}
 		
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 
 		if (RootContext.Documentation != null
 			&& Lexer.doc_state == XmlCommentState.Error)
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 	  }
   break;
 case 222
 #line 1864 "cs-parser.jay"
   {
 		/* TODO
 	  	yyVal = null;
 	  }
   break;
 case 223
 #line 1869 "cs-parser.jay"
   {
 	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
 	  	yyVal = null;
 	  }
   break;
 case 224
 #line 1880 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 225
 #line 1884 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Interface (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 226
 #line 1891 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 227
 #line 1902 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;	  
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 228
 #line 1908 "cs-parser.jay"
   {
 	    lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 229
 #line 1913 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 	  }
   break;
 case 234
 #line 1930 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 235
 #line 1934 "cs-parser.jay"
   {
 		Report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
 	  }
   break;
 case 240
 #line 1942 "cs-parser.jay"
   {
 	  	Report.Error (567, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain operators");
 	  }
   break;
 case 241
 #line 1946 "cs-parser.jay"
   {
 	  	Report.Error (526, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain contructors");
 	  }
   break;
 case 242
 #line 1950 "cs-parser.jay"
   {
 	  	Report.Error (524, GetLocation (yyVals[0+yyTop]), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
 	  }
   break;
 case 243
 #line 1957 "cs-parser.jay"
   {
 	  }
   break;
 case 244
 #line 1960 "cs-parser.jay"
   {
 		OperatorDeclaration decl = (OperatorDeclaration) yyVals[-2+yyTop];
 		if (decl != null) {
 			Operator op = new Operator (
 				current_class, decl.optype, decl.ret_type, (Modifiers) yyVals[-3+yyTop], 
 				current_local_parameters,
 				(ToplevelBlock) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop], decl.location);
 
 			if (RootContext.Documentation != null) {
 				op.DocComment = tmpComment;
 				Lexer.doc_state = XmlCommentState.Allowed;
 			}
 
 			/* Note again, checking is done in semantic analysis*/
 			current_container.AddOperator (op);
 
 			lbag.AddMember (op, mod_locations, lbag.GetLocations (decl));
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 246
 #line 1985 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 248
 #line 1991 "cs-parser.jay"
   {
 		Report.Error (590, GetLocation (yyVals[0+yyTop]), "User-defined operators cannot return void");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 249
 #line 1999 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 250
 #line 2003 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		Operator.OpType op = (Operator.OpType) yyVals[-4+yyTop];
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];
 		
 		int p_count = current_local_parameters.Count;
 		if (p_count == 1) {
 			if (op == Operator.OpType.Addition)
 				op = Operator.OpType.UnaryPlus;
 			else if (op == Operator.OpType.Subtraction)
 				op = Operator.OpType.UnaryNegation;
 		}
 		
 		if (IsUnaryOperator (op)) {
 			if (p_count == 2) {
 				Report.Error (1020, loc, "Overloadable binary operator expected");
 			} else if (p_count != 1) {
 				Report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
 					Operator.GetName (op));
 			}
 		} else {
 			if (p_count > 2) {
 				Report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
 					Operator.GetName (op));
 			} else if (p_count != 2) {
 				Report.Error (1019, loc, "Overloadable unary operator expected");
 			}
 		}
 		
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (op, (FullNamedExpression) yyVals[-6+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 252
 #line 2047 "cs-parser.jay"
   { yyVal = Operator.OpType.LogicalNot; }
   break;
 case 253
 #line 2048 "cs-parser.jay"
   { yyVal = Operator.OpType.OnesComplement; }
   break;
 case 254
 #line 2049 "cs-parser.jay"
   { yyVal = Operator.OpType.Increment; }
   break;
 case 255
 #line 2050 "cs-parser.jay"
   { yyVal = Operator.OpType.Decrement; }
   break;
 case 256
 #line 2051 "cs-parser.jay"
   { yyVal = Operator.OpType.True; }
   break;
 case 257
 #line 2052 "cs-parser.jay"
   { yyVal = Operator.OpType.False; }
   break;
 case 258
 #line 2054 "cs-parser.jay"
   { yyVal = Operator.OpType.Addition; }
   break;
 case 259
 #line 2055 "cs-parser.jay"
   { yyVal = Operator.OpType.Subtraction; }
   break;
 case 260
 #line 2057 "cs-parser.jay"
   { yyVal = Operator.OpType.Multiply; }
   break;
 case 261
 #line 2058 "cs-parser.jay"
   {  yyVal = Operator.OpType.Division; }
   break;
 case 262
 #line 2059 "cs-parser.jay"
   { yyVal = Operator.OpType.Modulus; }
   break;
 case 263
 #line 2060 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseAnd; }
   break;
 case 264
 #line 2061 "cs-parser.jay"
   { yyVal = Operator.OpType.BitwiseOr; }
   break;
 case 265
 #line 2062 "cs-parser.jay"
   { yyVal = Operator.OpType.ExclusiveOr; }
   break;
 case 266
 #line 2063 "cs-parser.jay"
   { yyVal = Operator.OpType.LeftShift; }
   break;
 case 267
 #line 2064 "cs-parser.jay"
   { yyVal = Operator.OpType.RightShift; }
   break;
 case 268
 #line 2065 "cs-parser.jay"
   { yyVal = Operator.OpType.Equality; }
   break;
 case 269
 #line 2066 "cs-parser.jay"
   { yyVal = Operator.OpType.Inequality; }
   break;
 case 270
 #line 2067 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThan; }
   break;
 case 271
 #line 2068 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThan; }
   break;
 case 272
 #line 2069 "cs-parser.jay"
   { yyVal = Operator.OpType.GreaterThanOrEqual; }
   break;
 case 273
 #line 2070 "cs-parser.jay"
   { yyVal = Operator.OpType.LessThanOrEqual; }
   break;
 case 274
 #line 2075 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 275
 #line 2079 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 276
 #line 2094 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.DefaultValue;
 	  }
   break;
 case 277
 #line 2098 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		
 		Location loc = GetLocation (yyVals[-5+yyTop]);
 		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
 		  
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 
 		yyVal = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 278
 #line 2113 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 279
 #line 2119 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  	yyVal = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 280
 #line 2129 "cs-parser.jay"
   { 
 		Constructor c = (Constructor) yyVals[-1+yyTop];
 		c.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (RootContext.Documentation != null)
 			c.DocComment = ConsumeStoredComment ();
 
 		current_container.AddConstructor (c);
 
 		current_local_parameters = null;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 281
 #line 2148 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		valid_param_mod = ParameterModifierType.All;
 	  }
   break;
 case 282
 #line 2157 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 		current_local_parameters = (ParametersCompiled) yyVals[-1+yyTop];  
 		
 		/**/
 		/* start block here, so possible anonymous methods inside*/
 		/* constructor initializer can get correct parent block*/
 		/**/
 	  	start_block (lexer.Location);
 	  }
   break;
 case 283
 #line 2168 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-6+yyTop];
 		var mods = (Modifiers) yyVals[-7+yyTop];
 		ConstructorInitializer ci = (ConstructorInitializer) yyVals[0+yyTop];
 
 		Constructor c = new Constructor (current_class, lt.Value, mods,
 			(Attributes) yyVals[-8+yyTop], current_local_parameters, ci, lt.Location);
 		
 		if (lt.Value != current_container.MemberName.Name) {
 			Report.Error (1520, c.Location, "Class, struct, or interface method must have a return type");
 		} else if ((mods & Modifiers.STATIC) != 0) {
 			if ((mods & Modifiers.AccessibilityMask) != 0){
 				Report.Error (515, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			}
 			if (ci != null) {
 				Report.Error (514, c.Location,
 					"`{0}'
 					c.GetSignatureForError ());
 			
 			}
 		}
 		
 		lbag.AddMember (c, mod_locations, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 285
 #line 2199 "cs-parser.jay"
   { current_block = null; yyVal = null; }
   break;
 case 288
 #line 2209 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 289
 #line 2213 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorBaseInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 290
 #line 2219 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 291
 #line 2223 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		yyVal = new ConstructorThisInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 292
 #line 2229 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 293
 #line 2237 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 		
 		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
 	  }
   break;
 case 294
 #line 2246 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		if (lt.Value != current_container.MemberName.Name){
 			Report.Error (574, lt.Location, "Name of destructor must match name of class");
 		} else if (current_container.Kind != MemberKind.Class){
 			Report.Error (575, lt.Location, "Only class types can contain destructor");
 		}
 		
 		Destructor d = new Destructor (current_class, (Modifiers) yyVals[-6+yyTop],
 			ParametersCompiled.EmptyReadOnlyParameters, (Attributes) yyVals[-7+yyTop], lt.Location);
 		if (RootContext.Documentation != null)
 			d.DocComment = ConsumeStoredComment ();
 		  
 		d.Block = (ToplevelBlock) yyVals[0+yyTop];
 		current_container.AddMethod (d);
 		lbag.AddMember (d, mod_locations, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		current_local_parameters = null;
 	  }
   break;
 case 295
 #line 2271 "cs-parser.jay"
   {
 		current_event_field = new EventField (current_class, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-3+yyTop], (MemberName) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop]);
 		current_container.AddEvent (current_event_field);
 		
 		if (current_event_field.MemberName.Left != null) {
 			Report.Error (71, current_event_field.Location, "`{0}'
 			current_event_field.GetSignatureForError ());
 		}
 		
 		yyVal = current_event_field;
 	  }
   break;
 case 296
 #line 2285 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event_field.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AddMember (current_event_field, mod_locations, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 		current_event_field = null;
 	  }
   break;
 case 297
 #line 2298 "cs-parser.jay"
   {
 		current_event = new EventProperty (current_class, (FullNamedExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-4+yyTop], (MemberName) yyVals[-1+yyTop], (Attributes) yyVals[-5+yyTop]);
 		current_container.AddEvent (current_event);
 		lbag.AddMember (current_event, mod_locations, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		
 		lexer.EventParsing = true;
 	  }
   break;
 case 298
 #line 2306 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface)
 			Report.Error (69, GetLocation (yyVals[-2+yyTop]), "Event in interface cannot have add or remove accessors");
 	  
 		lexer.EventParsing = false;
 	  }
   break;
 case 299
 #line 2313 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null) {
 			current_event.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 		
 		lbag.AppendToMember (current_event, GetLocation (yyVals[-1+yyTop]));
 	  	current_event = null;	
 		current_local_parameters = null;
 	  }
   break;
 case 301
 #line 2328 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 	  }
   break;
 case 302
 #line 2332 "cs-parser.jay"
   {
 	  	--lexer.parsing_block;
 		current_event_field.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 305
 #line 2345 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 306
 #line 2349 "cs-parser.jay"
   {
 		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
 	  }
   break;
 case 307
 #line 2356 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 308
 #line 2362 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 	  }
   break;
 case 309
 #line 2366 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
 	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop]);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 310
 #line 2375 "cs-parser.jay"
   {
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (68, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 		}
 		
 	  	if ((current_event_field.ModFlags & Modifiers.ABSTRACT) != 0) {
 			Report.Error (74, lexer.Location, "`{0}'
 				current_event_field.GetSignatureForError ());
 	  	}		
 	  }
   break;
 case 311
 #line 2387 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 314
 #line 2396 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 315
 #line 2401 "cs-parser.jay"
   {
 		Report.Error (65, lexer.Location, "`{0}'
 			current_event.GetSignatureForError ());
 	  }
   break;
 case 316
 #line 2406 "cs-parser.jay"
   { 
 		Report.Error (1055, GetLocation (yyVals[0+yyTop]), "An add or remove accessor expected");
 		yyVal = null;
 	  }
   break;
 case 317
 #line 2414 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Add = new EventProperty.AddDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Add.ParameterInfo;
 		
 		lbag.AddMember (current_event.Add, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 318
 #line 2426 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Add.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Add.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 319
 #line 2442 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] != ModifierNone) {
 			Report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
 	  	}
 	  	
 	  	current_event.Remove = new EventProperty.RemoveDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
 		current_local_parameters = current_event.Remove.ParameterInfo;
 
 		lbag.AddMember (current_event.Remove, mod_locations);
 		lexer.EventParsing = false;		
 	  }
   break;
 case 320
 #line 2454 "cs-parser.jay"
   {
 		lexer.EventParsing = true;
 	  
 	  	current_event.Remove.Block = (ToplevelBlock) yyVals[0+yyTop];
 		
 		if (current_container.Kind == MemberKind.Interface) {
 			Report.Error (531, current_event.Remove.Block.StartLocation,
 				"`{0}'
 		}
 		
 		current_local_parameters = null;
 	  }
   break;
 case 321
 #line 2470 "cs-parser.jay"
   {
 		Report.Error (73, lexer.Location, "An add or remove accessor must have a body");
 		yyVal = null;
 	  }
   break;
 case 323
 #line 2482 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			enumTypeComment = Lexer.consume_doc_comment ();
 	  }
   break;
 case 324
 #line 2487 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 
 		MemberName name = (MemberName) yyVals[-3+yyTop];
 		if (name.IsGeneric) {
 			Report.Error (1675, name.Location, "Enums cannot have type parameters");
 		}
 		
 		push_current_class (new Enum (current_namespace, current_class, (TypeExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-5+yyTop], MakeName (name), (Attributes) yyVals[-6+yyTop]), null);
 	  }
   break;
 case 325
 #line 2499 "cs-parser.jay"
   {
 	  	/* here will be evaluated after CLOSE_BLACE is consumed.*/
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 326
 #line 2505 "cs-parser.jay"
   {
 		if (RootContext.Documentation != null)
 			current_class.DocComment = enumTypeComment;
 			
 		--lexer.parsing_declaration;
 
 /*			if (RootContext.Documentation != null)*/
 /*				em.DocComment = ev.DocComment;*/
 
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-9+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 328
 #line 2522 "cs-parser.jay"
   {
 	 	var te = yyVals[0+yyTop] as TypeExpression;
 		if (te == null ||
 			(te.Type != TypeManager.int32_type && te.Type != TypeManager.uint32_type &&
 			te.Type != TypeManager.int64_type && te.Type != TypeManager.uint64_type &&
 			te.Type != TypeManager.short_type && te.Type != TypeManager.ushort_type &&
 			te.Type != TypeManager.byte_type && te.Type != TypeManager.sbyte_type)) {
 			Enum.Error_1008 (GetLocation (yyVals[0+yyTop]), Report);
 			yyVal = null;
 		} else {
 			yyVal = yyVals[0+yyTop];
 		}
 	 }
   break;
 case 329
 #line 2536 "cs-parser.jay"
   {
 	 	Error_TypeExpected (GetLocation (yyVals[-1+yyTop]));
 		yyVal = null;
 	 }
   break;
 case 332
 #line 2546 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 334
 #line 2554 "cs-parser.jay"
   {
 	  	lbag.AddLocation (yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 335
 #line 2562 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-1+yyTop]);
 	  	((Enum) current_class).AddEnumMember (em);
 
 		if (RootContext.Documentation != null) {
 			em.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		yyVal = em;
 	  }
   break;
 case 336
 #line 2575 "cs-parser.jay"
   {
 	  	++lexer.parsing_block;
 		if (RootContext.Documentation != null) {
 			tmpComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.NotAllowed;
 		}
 	  }
   break;
 case 337
 #line 2583 "cs-parser.jay"
   { 
 		--lexer.parsing_block;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 	  	var em = new EnumMember ((Enum) current_class, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
 	  	em.Initializer = new ConstInitializer (em, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  	((Enum) current_class).AddEnumMember (em);
 		
 		if (RootContext.Documentation != null)
 			em.DocComment = ConsumeStoredComment ();
 
 		yyVal = em;
 	  }
   break;
 case 338
 #line 2604 "cs-parser.jay"
   {
 		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out | ParameterModifierType.Params | ParameterModifierType.DefaultValue;
 	  }
   break;
 case 339
 #line 2608 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 
 		MemberName name = MakeName ((MemberName) yyVals[-4+yyTop]);
 		ParametersCompiled p = (ParametersCompiled) yyVals[-1+yyTop];
 
 		Delegate del = new Delegate (current_namespace, current_class, (FullNamedExpression) yyVals[-5+yyTop],
 					     (Modifiers) yyVals[-7+yyTop], name, p, (Attributes) yyVals[-8+yyTop]);
 
 		if (RootContext.Documentation != null) {
 			del.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 
 		current_container.AddDelegate (del);
 		current_delegate = del;
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 340
 #line 2627 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 	  }
   break;
 case 341
 #line 2631 "cs-parser.jay"
   {
 		current_delegate.SetParameterInfo ((List<Constraints>) yyVals[-2+yyTop]);
 		lbag.AddMember (current_delegate, mod_locations, GetLocation (yyVals[-10+yyTop]), GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[0+yyTop]));
 
 		yyVal = current_delegate;
 
 		current_delegate = null;
 	  }
   break;
 case 343
 #line 2644 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "nullable types");
 	  
 	  	yyVal = ComposedTypeSpecifier.CreateNullable (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 345
 #line 2655 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 347
 #line 2666 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));		
 	  }
   break;
 case 348
 #line 2675 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 350
 #line 2687 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");	  
 	  
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 351
 #line 2694 "cs-parser.jay"
   {
 		Error_TypeExpected (lexer.Location);
 		yyVal = new TypeArguments ();
 	  }
   break;
 case 352
 #line 2702 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 353
 #line 2708 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 354
 #line 2720 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 355
 #line 2724 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 356
 #line 2733 "cs-parser.jay"
   {
 	  	MemberName mn = (MemberName)yyVals[0+yyTop];
 	  	if (mn.TypeArguments != null)
 	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
 	  			mn.GetSignatureForError ()));
 	  }
   break;
 case 358
 #line 2744 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 359
 #line 2753 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;	  
 		yyVal = new MemberName (TypeContainer.DefaultIndexerName, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 360
 #line 2758 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = false;
 		yyVal = new MemberName ((MemberName) yyVals[-1+yyTop], TypeContainer.DefaultIndexerName, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 361
 #line 2766 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName (lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 362
 #line 2772 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		
 		yyVal = new MemberName (lt1.Value, lt2.Value, (TypeArguments) yyVals[-1+yyTop], lt1.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 363
 #line 2780 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new MemberName ((MemberName) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 365
 #line 2790 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");
 	  
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 366
 #line 2801 "cs-parser.jay"
   {
 		TypeArguments type_args = new TypeArguments ();
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 	  }
   break;
 case 367
 #line 2807 "cs-parser.jay"
   {
 		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
 		type_args.Add ((FullNamedExpression)yyVals[0+yyTop]);
 		yyVal = type_args;
 		lbag.AddLocation (yyVals[0+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 368
 #line 2817 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 		yyVal = new TypeParameterName (lt.Value, (Attributes)yyVals[-2+yyTop], (Variance) yyVals[-1+yyTop], lt.Location);
   	  }
   break;
 case 369
 #line 2822 "cs-parser.jay"
   {
   	  	if (GetTokenName (yyToken) == "type")
 			Report.Error (81, GetLocation (yyVals[0+yyTop]), "Type parameter declaration must be an identifier not a type");
 		else
 			Error_SyntaxError (yyToken);
 			
   	  	yyVal = new TypeParameterName ("", null, lexer.Location);
   	  }
   break;
 case 371
 #line 2838 "cs-parser.jay"
   {
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 372
 #line 2845 "cs-parser.jay"
   {
 		lexer.parsing_generic_declaration = true;
 	  }
   break;
 case 374
 #line 2856 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 376
 #line 2865 "cs-parser.jay"
   {
 	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 378
 #line 2874 "cs-parser.jay"
   {
 	  	Report.Error (1536, GetLocation (yyVals[0+yyTop]), "Invalid parameter type `void'");
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 380
 #line 2883 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 381
 #line 2890 "cs-parser.jay"
   {
 		MemberName name = (MemberName) yyVals[-1+yyTop];
 
 		if (yyVals[0+yyTop] != null) {
 			yyVal = new ComposedCast (name.GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			if (name.Left == null && name.Name == "var")
 				yyVal = new VarExpr (name.Location);
 			else
 				yyVal = name.GetTypeExpression ();
 		}
 	  }
   break;
 case 382
 #line 2903 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (((MemberName) yyVals[-1+yyTop]).GetTypeExpression (), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 383
 #line 2907 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null)
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 384
 #line 2912 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 385
 #line 2916 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 386
 #line 2923 "cs-parser.jay"
   {
 		var types = new List<FullNamedExpression> (2);
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 387
 #line 2929 "cs-parser.jay"
   {
 		var types = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = types;
 	  }
   break;
 case 388
 #line 2938 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast) {
 			Report.Error (1521, GetLocation (yyVals[0+yyTop]), "Invalid base type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 		}
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 389
 #line 2945 "cs-parser.jay"
   {
 	  	Error_TypeExpected (lexer.Location);
 		yyVal = null;
 	  }
   break;
 case 390
 #line 2956 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.object_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 391
 #line 2957 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.string_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 392
 #line 2958 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.bool_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 393
 #line 2959 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.decimal_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 394
 #line 2960 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.float_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 395
 #line 2961 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.double_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 397
 #line 2966 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.sbyte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 398
 #line 2967 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.byte_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 399
 #line 2968 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.short_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 400
 #line 2969 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.ushort_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 401
 #line 2970 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 402
 #line 2971 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint32_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 403
 #line 2972 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.int64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 404
 #line 2973 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.uint64_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 405
 #line 2974 "cs-parser.jay"
   { yyVal = new TypeExpression (TypeManager.char_type, GetLocation (yyVals[0+yyTop])); }
   break;
 case 425
 #line 3006 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new SimpleName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
 	  }
   break;
 case 426
 #line 3010 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 	       yyVal = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
 	  }
   break;
 case 430
 #line 3020 "cs-parser.jay"
   { yyVal = new NullLiteral (GetLocation (yyVals[0+yyTop])); }
   break;
 case 431
 #line 3024 "cs-parser.jay"
   { yyVal = new BoolLiteral (true, GetLocation (yyVals[0+yyTop])); }
   break;
 case 432
 #line 3025 "cs-parser.jay"
   { yyVal = new BoolLiteral (false, GetLocation (yyVals[0+yyTop])); }
   break;
 case 437
 #line 3051 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 438
 #line 3056 "cs-parser.jay"
   {
 		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop]);
 	  }
   break;
 case 439
 #line 3063 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 440
 #line 3069 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 441
 #line 3075 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 442
 #line 3081 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 443
 #line 3087 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null,GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 444
 #line 3090 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
 	  }
   break;
 case 445
 #line 3095 "cs-parser.jay"
   {
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null, lexer.Location);
 	  }
   break;
 case 446
 #line 3098 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
  	  }
   break;
 case 447
 #line 3106 "cs-parser.jay"
   {
 		yyVal = new Invocation ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 448
 #line 3113 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 450
 #line 3119 "cs-parser.jay"
   {
 	  	if (yyVals[-1+yyTop] == null) {
 	  		yyVal = CollectionOrObjectInitializers.Empty;
 	  		/* TODO
 	  	} else {
 	  		yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  	}
 	  }
   break;
 case 451
 #line 3129 "cs-parser.jay"
   {
 	  	yyVal = new CollectionOrObjectInitializers ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 452
 #line 3136 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 453
 #line 3138 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	}
   break;
 case 454
 #line 3145 "cs-parser.jay"
   {
 	  	var a = new List<Expression> ();
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 455
 #line 3151 "cs-parser.jay"
   {
 	  	var a = (List<Expression>)yyVals[-2+yyTop];
 	  	a.Add ((Expression) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 456
 #line 3156 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 457
 #line 3164 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 	  	yyVal = new ElementInitializer (lt.Value, (Expression)yyVals[0+yyTop], lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 458
 #line 3170 "cs-parser.jay"
   {
 		yyVal = new CompletionElementInitializer (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 459
 #line 3173 "cs-parser.jay"
   {
 		CompletionSimpleName csn = yyVals[-1+yyTop] as CompletionSimpleName;
 		if (csn == null)
 			yyVal = new CollectionElementInitializer ((Expression)yyVals[-1+yyTop]);
 		else
 			yyVal = new CompletionElementInitializer (csn.Prefix, csn.Location);
 	  }
   break;
 case 460
 #line 3181 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] == null)
 			yyVal = null;
 		else
 	  		yyVal = new CollectionElementInitializer ((List<Expression>)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 461
 #line 3188 "cs-parser.jay"
   {
 	  	Report.Error (1920, GetLocation (yyVals[-1+yyTop]), "An element initializer cannot be empty");
 		yyVal = null;
 	  }
   break;
 case 464
 #line 3200 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 466
 #line 3206 "cs-parser.jay"
   { 
 		Arguments list = new Arguments (4);
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 467
 #line 3212 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		if (list [list.Count - 1] is NamedArgument)
 			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
 		
 		list.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 468
 #line 3221 "cs-parser.jay"
   {
 		Arguments list = (Arguments) yyVals[-2+yyTop];
 		NamedArgument a = (NamedArgument) yyVals[0+yyTop];
 		for (int i = 0; i < list.Count; ++i) {
 			NamedArgument na = list [i] as NamedArgument;
 			if (na != null && na.Name == a.Name)
 				Report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
 					na.Name);
 		}
 		
 		list.Add (a);
 		yyVal = list;
 	  }
   break;
 case 469
 #line 3235 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[0+yyTop]), "An argument is missing");
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 470
 #line 3240 "cs-parser.jay"
   {
 	  	Report.Error (839, GetLocation (yyVals[-1+yyTop]), "An argument is missing");
 	  	yyVal = null;
 	  }
   break;
 case 471
 #line 3248 "cs-parser.jay"
   {
 		yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 475
 #line 3261 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Ref);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 476
 #line 3266 "cs-parser.jay"
   { 
 		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Out);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 477
 #line 3271 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 478
 #line 3276 "cs-parser.jay"
   {
 		yyVal = new Argument (new Arglist (GetLocation (yyVals[-2+yyTop])));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 480
 #line 3288 "cs-parser.jay"
   {
 		yyVal = new ElementAccess ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 481
 #line 3296 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 482
 #line 3302 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 483
 #line 3307 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 484
 #line 3315 "cs-parser.jay"
   {
 		Arguments args = new Arguments (4);
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;
 	  }
   break;
 case 485
 #line 3321 "cs-parser.jay"
   {
 		Arguments args = (Arguments) yyVals[-2+yyTop];
 		if (args [args.Count - 1] is NamedArgument && !(yyVals[0+yyTop] is NamedArgument))
 			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
 	  
 		args.Add ((Argument) yyVals[0+yyTop]);
 		yyVal = args;	  
 	  }
   break;
 case 486
 #line 3333 "cs-parser.jay"
   {
 	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 488
 #line 3341 "cs-parser.jay"
   {
 		yyVal = new This (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 489
 #line 3348 "cs-parser.jay"
   {
 	  	yyVal = new ElementAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 490
 #line 3353 "cs-parser.jay"
   {
 	  	Error_SyntaxError (yyToken);
 		yyVal = new ElementAccess (null, null, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 491
 #line 3361 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 492
 #line 3368 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 493
 #line 3375 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] != null) {
 			if (RootContext.Version <= LanguageVersion.ISO_2)
 				Report.FeatureIsNotAvailable (GetLocation (yyVals[-5+yyTop]), "object initializers");
 				
 			yyVal = new NewInitialize ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		} else {
 			yyVal = new New ((FullNamedExpression) yyVals[-4+yyTop], (Arguments) yyVals[-2+yyTop], GetLocation (yyVals[-5+yyTop]));
 		}
 		
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 494
 #line 3388 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "collection initializers");
 	  
 		yyVal = new NewInitialize ((FullNamedExpression) yyVals[-1+yyTop], null, (CollectionOrObjectInitializers) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 495
 #line 3400 "cs-parser.jay"
   {
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], (List<Expression>) yyVals[-3+yyTop],
 				new ComposedTypeSpecifier (((List<Expression>) yyVals[-3+yyTop]).Count, GetLocation (yyVals[-4+yyTop])) {
 	  				Next = (ComposedTypeSpecifier) yyVals[-1+yyTop]
 			  	}, (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 496
 #line 3408 "cs-parser.jay"
   {
 	  	if (yyVals[0+yyTop] == null)
 	  		Report.Error (1586, GetLocation (yyVals[-3+yyTop]), "Array creation must have array size or array initializer");
 
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-2+yyTop], (ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 497
 #line 3415 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "implicitly typed arrays");
 	  
 		yyVal = new ImplicitlyTypedArrayCreation ((ComposedTypeSpecifier) yyVals[-1+yyTop], (ArrayInitializer) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 498
 #line 3422 "cs-parser.jay"
   {
 		Report.Error (178, GetLocation (yyVals[-1+yyTop]), "Invalid rank specifier, expecting `,' or `]'");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-5+yyTop], null, GetLocation (yyVals[-6+yyTop]));
 	  }
   break;
 case 499
 #line 3427 "cs-parser.jay"
   {
 		Error_SyntaxError (1526, yyToken, "Unexpected symbol");
 		yyVal = new ArrayCreation ((FullNamedExpression) yyVals[-1+yyTop], null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 500
 #line 3434 "cs-parser.jay"
   {
 		++lexer.parsing_type;
 	  }
   break;
 case 501
 #line 3438 "cs-parser.jay"
   {
 		--lexer.parsing_type;
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 502
 #line 3446 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 	  		Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "anonymous types");
 
 		yyVal = new NewAnonymousType ((List<AnonymousTypeParameter>) yyVals[-1+yyTop], current_container, GetLocation (yyVals[-3+yyTop]));
 		
 		/* TODO
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 505
 #line 3463 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 507
 #line 3469 "cs-parser.jay"
   {
 	  	var a = new List<AnonymousTypeParameter> (4);
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 508
 #line 3475 "cs-parser.jay"
   {
 	  	var a = (List<AnonymousTypeParameter>) yyVals[-2+yyTop];
 	  	a.Add ((AnonymousTypeParameter) yyVals[0+yyTop]);
 	  	yyVal = a;
 	  }
   break;
 case 509
 #line 3484 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[-2+yyTop];
 	  	yyVal = new AnonymousTypeParameter ((Expression)yyVals[0+yyTop], lt.Value, lt.Location);
 	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 510
 #line 3490 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (new SimpleName (lt.Value, lt.Location),
 	  		lt.Value, lt.Location);
 	  }
   break;
 case 511
 #line 3496 "cs-parser.jay"
   {
 	  	MemberAccess ma = (MemberAccess) yyVals[0+yyTop];
 	  	yyVal = new AnonymousTypeParameter (ma, ma.Name, ma.Location);
 	  }
   break;
 case 512
 #line 3501 "cs-parser.jay"
   {
 		Report.Error (746, lexer.Location,
 			"Invalid anonymous type member declarator. Anonymous type members must be a member assignment, simple name or member access expression");
 		yyVal = null;
 	  }
   break;
 case 516
 #line 3516 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 517
 #line 3524 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 518
 #line 3528 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreateArrayDimension ((int)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 519
 #line 3535 "cs-parser.jay"
   {
 		yyVal = 2;
 	  }
   break;
 case 520
 #line 3539 "cs-parser.jay"
   {
 		yyVal = ((int) yyVals[-1+yyTop]) + 1;
 	  }
   break;
 case 521
 #line 3546 "cs-parser.jay"
   {
 		yyVal = null;
 	  }
   break;
 case 522
 #line 3550 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 523
 #line 3557 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer (0, GetLocation (yyVals[-1+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[0+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 524
 #line 3564 "cs-parser.jay"
   {
 		var ai = new ArrayInitializer ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
 		ai.VariableDeclaration = current_variable;
 		lbag.AddLocation (ai, GetLocation (yyVals[-1+yyTop]));
 		yyVal = ai;
 	  }
   break;
 case 525
 #line 3574 "cs-parser.jay"
   {
 		var list = new List<Expression> (4);
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 526
 #line 3580 "cs-parser.jay"
   {
 		var list = (List<Expression>) yyVals[-2+yyTop];
 		list.Add ((Expression) yyVals[0+yyTop]);
 		yyVal = list;
 	  }
   break;
 case 527
 #line 3589 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = true;
 	  }
   break;
 case 528
 #line 3593 "cs-parser.jay"
   {
 	  	lexer.TypeOfParsing = false;
 		yyVal = new TypeOf ((FullNamedExpression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 531
 #line 3604 "cs-parser.jay"
   {
 	 	Error_TypeExpected (lexer.Location);
 	 	yyVal = null;
 	 }
   break;
 case 532
 #line 3612 "cs-parser.jay"
   {  
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new SimpleName (lt.Value, (int) yyVals[0+yyTop], lt.Location);
 	  }
   break;
 case 533
 #line 3618 "cs-parser.jay"
   {
 		var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var lt2 = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 
 		yyVal = new QualifiedAliasMember (lt1.Value, lt2.Value, (int) yyVals[0+yyTop], lt1.Location);
 	  }
   break;
 case 534
 #line 3625 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-2+yyTop], lt.Value, lt.Location);		
 	  }
   break;
 case 535
 #line 3631 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		
 		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 536
 #line 3637 "cs-parser.jay"
   {
 		var te = ((MemberName) yyVals[-3+yyTop]).GetTypeExpression ();
 		if (te.HasTypeArguments)
 			Error_TypeExpected (GetLocation (yyVals[0+yyTop]));
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new MemberAccess (te, lt.Value, (int) yyVals[0+yyTop], lt.Location);		
 	  }
   break;
 case 537
 #line 3649 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "generics");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 538
 #line 3659 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		if (RootContext.Version == LanguageVersion.ISO_1)
 			Report.FeatureIsNotAvailable (lt.Location, "namespace alias qualifier");
 
 		yyVal = lt;		
 	  }
   break;
 case 539
 #line 3670 "cs-parser.jay"
   { 
 		yyVal = new SizeOf ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 540
 #line 3678 "cs-parser.jay"
   {
 		yyVal = new CheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 541
 #line 3686 "cs-parser.jay"
   {
 		yyVal = new UnCheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 542
 #line 3694 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new MemberAccess (new Indirection ((Expression) yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop])), lt.Value, lt.Location);
 	  }
   break;
 case 543
 #line 3702 "cs-parser.jay"
   {
 		start_anonymous (false, (ParametersCompiled) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 544
 #line 3706 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 	  }
   break;
 case 545
 #line 3713 "cs-parser.jay"
   {
 		yyVal = ParametersCompiled.Undefined;
 	  }
   break;
 case 547
 #line 3721 "cs-parser.jay"
   {
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 548
 #line 3725 "cs-parser.jay"
   {
 		valid_param_mod = 0;
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 549
 #line 3733 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "default value expression");
 
 		yyVal = new DefaultValueExpression ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 551
 #line 3745 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.LogicalNot, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 552
 #line 3749 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.OnesComplement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 554
 #line 3757 "cs-parser.jay"
   {
 		yyVal = new Cast ((FullNamedExpression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 556
 #line 3770 "cs-parser.jay"
   { 
 	  	yyVal = new Unary (Unary.Operator.UnaryPlus, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 557
 #line 3774 "cs-parser.jay"
   { 
 		yyVal = new Unary (Unary.Operator.UnaryNegation, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 558
 #line 3778 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 559
 #line 3782 "cs-parser.jay"
   {
 		yyVal = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 560
 #line 3786 "cs-parser.jay"
   {
 		yyVal = new Indirection ((Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 561
 #line 3790 "cs-parser.jay"
   {
 		yyVal = new Unary (Unary.Operator.AddressOf, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 563
 #line 3798 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Multiply, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 564
 #line 3803 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Division, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 565
 #line 3808 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Modulus, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 567
 #line 3817 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Addition, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 568
 #line 3822 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 569
 #line 3826 "cs-parser.jay"
   {
 	  	/* Shift/Reduce conflict*/
 		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
   	  }
   break;
 case 570
 #line 3831 "cs-parser.jay"
   {
 		yyVal = new As ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 571
 #line 3835 "cs-parser.jay"
   {
 		yyVal = new Is ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 573
 #line 3843 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LeftShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 574
 #line 3848 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.RightShift, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 576
 #line 3857 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 577
 #line 3862 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThan, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 578
 #line 3867 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LessThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 579
 #line 3872 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.GreaterThanOrEqual, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 581
 #line 3881 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Equality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 582
 #line 3886 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.Inequality, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 584
 #line 3895 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 586
 #line 3904 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.ExclusiveOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 588
 #line 3913 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.BitwiseOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 590
 #line 3922 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalAnd, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 592
 #line 3931 "cs-parser.jay"
   {
 		yyVal = new Binary (Binary.Operator.LogicalOr, 
 			         (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 594
 #line 3940 "cs-parser.jay"
   {
 		if (RootContext.Version < LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "null coalescing operator");
 			
 		yyVal = new Nullable.NullCoalescingOperator ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 596
 #line 3951 "cs-parser.jay"
   {
 		yyVal = new Conditional (new BooleanExpression ((Expression) yyVals[-4+yyTop]), (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 597
 #line 3959 "cs-parser.jay"
   {
 		yyVal = new SimpleAssign ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 598
 #line 3963 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Multiply, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 599
 #line 3968 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Division, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 600
 #line 3973 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Modulus, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 601
 #line 3978 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Addition, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 602
 #line 3983 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 603
 #line 3988 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.LeftShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 604
 #line 3993 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.RightShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 605
 #line 3998 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseAnd, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 606
 #line 4003 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.BitwiseOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 607
 #line 4008 "cs-parser.jay"
   {
 		yyVal = new CompoundAssign (
 			Binary.Operator.ExclusiveOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 608
 #line 4016 "cs-parser.jay"
   {
 		var pars = new List<Parameter> (4);
 		pars.Add ((Parameter) yyVals[0+yyTop]);
 
 		yyVal = pars;
 	  }
   break;
 case 609
 #line 4023 "cs-parser.jay"
   {
 		var pars = (List<Parameter>) yyVals[-2+yyTop];
 		Parameter p = (Parameter)yyVals[0+yyTop];
 		if (pars[0].GetType () != p.GetType ()) {
 			Report.Error (748, p.Location, "All lambda parameters must be typed either explicitly or implicitly");
 		}
 		
 		pars.Add (p);
 		yyVal = pars;
 	  }
   break;
 case 610
 #line 4037 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], null, lt.Location);
 	  }
   break;
 case 611
 #line 4043 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 
 		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, Parameter.Modifier.NONE, null, lt.Location);
 	  }
   break;
 case 612
 #line 4049 "cs-parser.jay"
   {
 	  	var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		yyVal = new ImplicitLambdaParameter (lt.Value, lt.Location);
 	  }
   break;
 case 613
 #line 4056 "cs-parser.jay"
   { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
   break;
 case 614
 #line 4057 "cs-parser.jay"
   { 
 		var pars_list = (List<Parameter>) yyVals[0+yyTop];
 		yyVal = new ParametersCompiled (pars_list.ToArray ());
 	  }
   break;
 case 617
 #line 4069 "cs-parser.jay"
   {
 		start_block (lexer.Location);
 	  }
   break;
 case 618
 #line 4073 "cs-parser.jay"
   {
 		Block b = end_block (lexer.Location);
 		b.AddStatement (new ContextualReturn ((Expression) yyVals[0+yyTop]));
 		yyVal = b;
 	  }
   break;
 case 620
 #line 4083 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	
 		yyVal = EmptyExpression.Null;
 	  }
   break;
 case 621
 #line 4091 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
 		start_anonymous (true, new ParametersCompiled (p), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 622
 #line 4097 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 623
 #line 4102 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.ISO_2)
 			Report.FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "lambda expressions");
 	  
 	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
 	  }
   break;
 case 624
 #line 4109 "cs-parser.jay"
   {
 	  	valid_param_mod = 0;
 		start_anonymous (true, (ParametersCompiled) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 625
 #line 4114 "cs-parser.jay"
   {
 		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 631
 #line 4130 "cs-parser.jay"
   {
 		yyVal = new ArglistAccess (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 633
 #line 4141 "cs-parser.jay"
   {
 		yyVal = new BooleanExpression ((Expression) yyVals[0+yyTop]);
 	  }
   break;
 case 634
 #line 4154 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = true;
 	  }
   break;
 case 635
 #line 4158 "cs-parser.jay"
   {
 		MemberName name = MakeName ((MemberName) yyVals[0+yyTop]);
 		push_current_class (new Class (current_namespace, current_class, name, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), yyVals[-3+yyTop]);
 	  }
   break;
 case 636
 #line 4164 "cs-parser.jay"
   {
 		lexer.ConstraintsParsing = false;
 
 		current_class.SetParameterInfo ((List<Constraints>) yyVals[0+yyTop]);
 		lbag.AddMember (current_class, mod_locations, GetLocation (yyVals[-5+yyTop]));
 
 		if (RootContext.Documentation != null) {
 			current_container.DocComment = Lexer.consume_doc_comment ();
 			Lexer.doc_state = XmlCommentState.Allowed;
 		}
 	  }
   break;
 case 637
 #line 4176 "cs-parser.jay"
   {
 		--lexer.parsing_declaration;
 		if (RootContext.Documentation != null)
 			Lexer.doc_state = XmlCommentState.Allowed;
 	  }
   break;
 case 638
 #line 4182 "cs-parser.jay"
   {
 		lbag.AppendToMember (current_class, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = pop_current_class ();
 	  }
   break;
 case 639
 #line 4190 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 640
 #line 4192 "cs-parser.jay"
   { yyVal = yyVals[0+yyTop]; }
   break;
 case 641
 #line 4197 "cs-parser.jay"
   {
 	    mod_locations = null;
 		yyVal = ModifierNone;
 	  }
   break;
 case 644
 #line 4207 "cs-parser.jay"
   { 
 		var m1 = (Modifiers) yyVals[-1+yyTop];
 		var m2 = (Modifiers) yyVals[0+yyTop];
 
 		if ((m1 & m2) != 0) {
 			Report.Error (1004, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"Duplicate `{0}' modifier", ModifiersExtensions.Name (m2));
 		} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
 			((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
 			Report.Error (107, lexer.Location - ModifiersExtensions.Name (m2).Length,
 				"More than one protection modifier specified");
 		}
 		
 		yyVal = m1 | m2;
 	  }
   break;
 case 645
 #line 4226 "cs-parser.jay"
   {
 		yyVal = Modifiers.NEW;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		
 		if (current_container == RootContext.ToplevelTypes)
 			Report.Error (1530, GetLocation (yyVals[0+yyTop]), "Keyword `new' is not allowed on namespace elements");
 	  }
   break;
 case 646
 #line 4234 "cs-parser.jay"
   {
 		yyVal = Modifiers.PUBLIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 647
 #line 4239 "cs-parser.jay"
   {
 		yyVal = Modifiers.PROTECTED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 648
 #line 4244 "cs-parser.jay"
   {
 		yyVal = Modifiers.INTERNAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 649
 #line 4249 "cs-parser.jay"
   {
 		yyVal = Modifiers.PRIVATE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 650
 #line 4254 "cs-parser.jay"
   {
 		yyVal = Modifiers.ABSTRACT;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 651
 #line 4259 "cs-parser.jay"
   {
 		yyVal = Modifiers.SEALED;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 652
 #line 4264 "cs-parser.jay"
   {
 		yyVal = Modifiers.STATIC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 653
 #line 4269 "cs-parser.jay"
   {
 		yyVal = Modifiers.READONLY;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 654
 #line 4274 "cs-parser.jay"
   {
 		yyVal = Modifiers.VIRTUAL;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 655
 #line 4279 "cs-parser.jay"
   {
 		yyVal = Modifiers.OVERRIDE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 656
 #line 4284 "cs-parser.jay"
   {
 		yyVal = Modifiers.EXTERN;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 657
 #line 4289 "cs-parser.jay"
   {
 		yyVal = Modifiers.VOLATILE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 658
 #line 4294 "cs-parser.jay"
   {
 		yyVal = Modifiers.UNSAFE;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 659
 #line 4301 "cs-parser.jay"
   {
 		yyVal = Modifiers.ASYNC;
 		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 661
 #line 4310 "cs-parser.jay"
   {
 		current_container.AddBasesForPart (current_class, (List<FullNamedExpression>) yyVals[0+yyTop]);
 	 }
   break;
 case 663
 #line 4318 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 664
 #line 4322 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	 }
   break;
 case 665
 #line 4330 "cs-parser.jay"
   {
 		var constraints = new List<Constraints> (1);
 		constraints.Add ((Constraints) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 666
 #line 4336 "cs-parser.jay"
   {
 		var constraints = (List<Constraints>) yyVals[-1+yyTop];
 		Constraints new_constraint = (Constraints)yyVals[0+yyTop];
 
 		foreach (Constraints c in constraints) {
 			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
 				Report.Error (409, new_constraint.Location,
 					"A constraint clause has already been specified for type parameter `{0}'",
 					new_constraint.TypeParameter.Value);
 			}
 		}
 
 		constraints.Add (new_constraint);
 		yyVal = constraints;
 	  }
   break;
 case 667
 #line 4355 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		yyVal = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 	  }
   break;
 case 668
 #line 4363 "cs-parser.jay"
   {
 		var constraints = new List<FullNamedExpression> (1);
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 669
 #line 4369 "cs-parser.jay"
   {
 		var constraints = (List<FullNamedExpression>) yyVals[-2+yyTop];
 		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
 		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
 			Report.Error (401, GetLocation (yyVals[-1+yyTop]), "The `new()' constraint must be the last constraint specified");
 		}
 		
 		prev = yyVals[0+yyTop] as SpecialContraintExpr;
 		if (prev != null) {
 			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
 				Report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
 			} else {
 			 	prev = constraints [0] as SpecialContraintExpr;
 			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
 					Report.Error (451, GetLocation (yyVals[0+yyTop]), "The `new()' constraint cannot be used with the `struct' constraint");
 				}
 			}
 		}
 
 		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
 		yyVal = constraints;
 	  }
   break;
 case 670
 #line 4395 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is ComposedCast)
 			Report.Error (706, GetLocation (yyVals[0+yyTop]), "Invalid constraint type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
 	  
 	  	yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 671
 #line 4402 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation (yyVals[-2+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 672
 #line 4407 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 673
 #line 4411 "cs-parser.jay"
   {
 		yyVal = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 674
 #line 4418 "cs-parser.jay"
   {
 		yyVal = Variance.None;
 	  }
   break;
 case 675
 #line 4422 "cs-parser.jay"
   {
 		if (RootContext.Version <= LanguageVersion.V_3)
 			Report.FeatureIsNotAvailable (lexer.Location, "generic type variance");
 
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 676
 #line 4432 "cs-parser.jay"
   {
 		yyVal = Variance.Covariant;
 	  }
   break;
 case 677
 #line 4436 "cs-parser.jay"
   {
 		yyVal = Variance.Contravariant;
 	  }
   break;
 case 678
 #line 4456 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 679
 #line 4461 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 680
 #line 4468 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 681
 #line 4473 "cs-parser.jay"
   {
 	 	--lexer.parsing_block;
 		yyVal = end_block (lexer.Location);
 	  }
   break;
 case 682
 #line 4482 "cs-parser.jay"
   {
 		++lexer.parsing_block;
 		current_block.StartLocation = GetLocation (yyVals[0+yyTop]);
 	  }
   break;
 case 683
 #line 4487 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 688
 #line 4505 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 689
 #line 4509 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 691
 #line 4514 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 694
 #line 4533 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 695
 #line 4537 "cs-parser.jay"
   {
 		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
 	  }
   break;
 case 724
 #line 4578 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 725
 #line 4583 "cs-parser.jay"
   {
 		  Report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
 		  yyVal = null;
 	  }
   break;
 case 726
 #line 4588 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 727
 #line 4596 "cs-parser.jay"
   {
 		/* Uses lexer.Location because semicolon location is not kept in quick mode*/
 		yyVal = new EmptyStatement (lexer.Location);
 	  }
   break;
 case 728
 #line 4604 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
 
 		current_block.AddLabel (labeled);
 		current_block.AddStatement (labeled);
 	  }
   break;
 case 731
 #line 4617 "cs-parser.jay"
   {
 		if (yyVals[-1+yyTop] is VarExpr)
 			yyVals[-1+yyTop] = new SimpleName ("var", ((VarExpr) yyVals[-1+yyTop]).Location);
 	  
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 732
 #line 4633 "cs-parser.jay"
   { 
 		/* Ok, the above "primary_expression" is there to get rid of*/
 		/* both reduce/reduce and shift/reduces in the grammar, it should*/
 		/* really just be "type_name".  If you use type_name, a reduce/reduce*/
 		/* creeps up.  If you use namespace_or_type_name (which is all we need*/
 		/* really) two shift/reduces appear.*/
 		/* */
 
 		/* So the super-trick is that primary_expression*/
 		/* can only be either a SimpleName or a MemberAccess. */
 		/* The MemberAccess case arises when you have a fully qualified type-name like 
 		/* Foo.Bar.Blah i;*/
 		/* SimpleName is when you have*/
 		/* Blah i;*/
 		
 		Expression expr = (Expression) yyVals[-1+yyTop];
 		if (yyVals[0+yyTop] == null) {
 			SimpleName sn = expr as SimpleName;
 			if (sn != null && sn.Name == "var")
 				yyVal = new VarExpr (sn.Location);
 			else
 				yyVal = yyVals[-1+yyTop];
 		} else if (expr is ATypeNameExpression) {
 			yyVal = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName (expr);
 			yyVal = null;
 		}
 	  }
   break;
 case 733
 #line 4663 "cs-parser.jay"
   {
 		ATypeNameExpression expr = yyVals[-1+yyTop] as ATypeNameExpression;
 
 		if (expr != null) {
 			yyVal = new ComposedCast (expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
 		} else {
 			Error_ExpectingTypeName ((Expression)yyVals[-1+yyTop]);
 			yyVal = expr;
 		}
 	  }
   break;
 case 734
 #line 4674 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] == null)
 			yyVal = yyVals[-1+yyTop];
 		else
 			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 735
 #line 4681 "cs-parser.jay"
   {
 		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 736
 #line 4685 "cs-parser.jay"
   {
 		yyVal = new ComposedCast (new TypeExpression (TypeManager.void_type, GetLocation (yyVals[-1+yyTop])), (ComposedTypeSpecifier) yyVals[0+yyTop]);
 	  }
   break;
 case 737
 #line 4689 "cs-parser.jay"
   {
 		Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), Report);
 		yyVal = new TypeExpression (TypeManager.void_type, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 739
 #line 4698 "cs-parser.jay"
   {
 	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
 	  	yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 740
 #line 4706 "cs-parser.jay"
   {
 		yyVal = ComposedTypeSpecifier.CreatePointer (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 741
 #line 4713 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 742
 #line 4720 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 743
 #line 4726 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockConstantDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 744
 #line 4733 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 746
 #line 4743 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		/* TODO
 	  }
   break;
 case 747
 #line 4748 "cs-parser.jay"
   {
 	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
 			Report.Error (650, lexer.Location,
 				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 	  }
   break;
 case 752
 #line 4770 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, null);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 753
 #line 4779 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_variable.Variable, lt.Value, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 754
 #line 4791 "cs-parser.jay"
   {
 		Report.Error (145, lexer.Location, "A const field requires a value to be provided");
 	  }
   break;
 case 755
 #line 4795 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 	  }
   break;
 case 760
 #line 4812 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, lt.Location);
 		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
 		current_variable.AddDeclarator (d);
 		current_block.AddLocalName (li);
 	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 762
 #line 4825 "cs-parser.jay"
   {
 		yyVal = new StackAlloc ((Expression) yyVals[-3+yyTop], (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 763
 #line 4830 "cs-parser.jay"
   {
 		Report.Error (1575, GetLocation (yyVals[-1+yyTop]), "A stackalloc expression requires [] after type");
 		yyVal = new StackAlloc ((Expression) yyVals[0+yyTop], null, GetLocation (yyVals[-1+yyTop]));		
 	  }
   break;
 case 764
 #line 4838 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 765
 #line 4842 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 766
 #line 4846 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 767
 #line 4847 "cs-parser.jay"
   { yyVal = yyVals[-1+yyTop]; }
   break;
 case 768
 #line 4856 "cs-parser.jay"
   {
 		ExpressionStatement s = yyVals[0+yyTop] as ExpressionStatement;
 		if (s == null) {
 			Expression.Error_InvalidExpressionStatement (Report, GetLocation (yyVals[0+yyTop]));
 			s = EmptyExpressionStatement.Instance;
 		}
 
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 769
 #line 4869 "cs-parser.jay"
   {
 		Expression expr = (Expression) yyVals[0+yyTop];
 		ExpressionStatement s;
 
 	        s = new OptionalAssign (new SimpleName ("$retval", lexer.Location), expr, lexer.Location);
 		yyVal = new StatementExpression (s);
 	  }
   break;
 case 770
 #line 4877 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 773
 #line 4891 "cs-parser.jay"
   { 
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 		
 		yyVal = new If ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 774
 #line 4900 "cs-parser.jay"
   {
 		yyVal = new If ((BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		
 		if (yyVals[-2+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[-2+yyTop]));
 		if (yyVals[0+yyTop] is EmptyStatement)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 775
 #line 4913 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 776
 #line 4917 "cs-parser.jay"
   {
 		yyVal = new Switch ((Expression) yyVals[-5+yyTop], (ExplicitBlock) current_block.Explicit, (List<SwitchSection>) yyVals[-1+yyTop], GetLocation (yyVals[-7+yyTop]));	
 		end_block (GetLocation (yyVals[0+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-4+yyTop]));
 	  }
   break;
 case 777
 #line 4926 "cs-parser.jay"
   {
 		Report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 779
 #line 4935 "cs-parser.jay"
   {
 		var sections = new List<SwitchSection> (4);
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 780
 #line 4942 "cs-parser.jay"
   {
 		var sections = (List<SwitchSection>) yyVals[-1+yyTop];
 
 		sections.Add ((SwitchSection) yyVals[0+yyTop]);
 		yyVal = sections;
 	  }
   break;
 case 781
 #line 4949 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);	  
 		yyVal = new List<SwitchSection> ();
 	  }
   break;
 case 782
 #line 4957 "cs-parser.jay"
   {
 		current_block = current_block.CreateSwitchBlock (lexer.Location);
 	  }
   break;
 case 783
 #line 4961 "cs-parser.jay"
   {
 		yyVal = new SwitchSection ((List<SwitchLabel>) yyVals[-2+yyTop], current_block);
 	  }
   break;
 case 784
 #line 4968 "cs-parser.jay"
   {
 		var labels = new List<SwitchLabel> (4);
 
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 		yyVal = labels;
 	  }
   break;
 case 785
 #line 4975 "cs-parser.jay"
   {
 		var labels = (List<SwitchLabel>) (yyVals[-1+yyTop]);
 		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
 
 		yyVal = labels;
 	  }
   break;
 case 786
 #line 4985 "cs-parser.jay"
   {
 	 	yyVal = new SwitchLabel ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 	 	lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
 	 }
   break;
 case 787
 #line 4990 "cs-parser.jay"
   {
 		yyVal = new SwitchLabel (null, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 792
 #line 5004 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new While ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 793
 #line 5016 "cs-parser.jay"
   {
 		yyVal = new Do ((Statement) yyVals[-5+yyTop], (BooleanExpression) yyVals[-2+yyTop], GetLocation (yyVals[-6+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 794
 #line 5024 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[0+yyTop]));
 		current_block.IsCompilerGenerated = true;
 	  }
   break;
 case 795
 #line 5029 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 796
 #line 5040 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		For f = new For ((Statement) yyVals[-6+yyTop], (BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, current_block.StartLocation, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 
 		yyVal = end_block (GetLocation (yyVals[-5+yyTop]));
 	  }
   break;
 case 797
 #line 5052 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = end_block (current_block.StartLocation);
 	  }
   break;
 case 798
 #line 5059 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 800
 #line 5065 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 801
 #line 5072 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 803
 #line 5080 "cs-parser.jay"
   { yyVal = null; }
   break;
 case 805
 #line 5085 "cs-parser.jay"
   { yyVal = new EmptyStatement (lexer.Location); }
   break;
 case 809
 #line 5096 "cs-parser.jay"
   {
 	  	var sl = yyVals[-2+yyTop] as StatementList;
 	  	if (sl == null) {
 	  		sl = new StatementList ((Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop]);
 			lbag.AddStatement (sl, GetLocation (yyVals[-1+yyTop]));
 	  	} else {
 	  		sl.Add ((Statement) yyVals[0+yyTop]);
 	  		lbag.AppendTo (sl, GetLocation (yyVals[-1+yyTop]));
 	  	}
 	  		
 		yyVal = sl;
 	  }
   break;
 case 810
 #line 5112 "cs-parser.jay"
   {
 		Report.Error (230, GetLocation (yyVals[-5+yyTop]), "Type and identifier are both required in a foreach statement");
 		yyVal = null;
 	  }
   break;
 case 811
 #line 5117 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-5+yyTop]));
 		current_block.IsCompilerGenerated = true;
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.ForeachVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		yyVal = li;
 	  }
   break;
 case 812
 #line 5127 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Foreach f = new Foreach ((Expression) yyVals[-6+yyTop], (LocalVariable) yyVals[-1+yyTop], (Expression) yyVals[-3+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-8+yyTop]));
 		current_block.AddStatement (f);
 		
 		lbag.AddStatement (f, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 819
 #line 5150 "cs-parser.jay"
   {
 		yyVal = new Break (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 820
 #line 5158 "cs-parser.jay"
   {
 		yyVal = new Continue (GetLocation (yyVals[-1+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 821
 #line 5166 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 		yyVal = new Goto (lt.Value, lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 822
 #line 5172 "cs-parser.jay"
   {
 		yyVal = new GotoCase ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 823
 #line 5177 "cs-parser.jay"
   {
 		yyVal = new GotoDefault (GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 824
 #line 5185 "cs-parser.jay"
   {
 		yyVal = new Return ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 825
 #line 5193 "cs-parser.jay"
   {
 		yyVal = new Throw ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 826
 #line 5201 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (yyVals[-1+yyTop] == null) {
 			Report.Error (1627, GetLocation (yyVals[0+yyTop]), "Expression expected after yield return");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new Yield ((Expression) yyVals[-1+yyTop], lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 827
 #line 5217 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		string s = lt.Value;
 		if (s != "yield"){
 			Report.Error (1003, lt.Location, "; expected");
 		} else if (RootContext.Version == LanguageVersion.ISO_1){
 			Report.FeatureIsNotAvailable (lt.Location, "iterators");
 		}
 		
 		current_block.ParametersBlock.TopBlock.IsIterator = true;
 		yyVal = new YieldBreak (lt.Location);
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 830
 #line 5239 "cs-parser.jay"
   {
 		yyVal = new TryCatch ((Block) yyVals[-1+yyTop], (List<Catch>) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]), false);
 	  }
   break;
 case 831
 #line 5243 "cs-parser.jay"
   {
 		yyVal = new TryFinally ((Statement) yyVals[-2+yyTop], (Block) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 832
 #line 5248 "cs-parser.jay"
   {
 		yyVal = new TryFinally (new TryCatch ((Block) yyVals[-3+yyTop], (List<Catch>) yyVals[-2+yyTop], GetLocation (yyVals[-4+yyTop]), true), (Block) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 833
 #line 5253 "cs-parser.jay"
   {
 		Report.Error (1524, GetLocation (yyVals[-2+yyTop]), "Expected catch or finally");
 		yyVal = null;
 	  }
   break;
 case 834
 #line 5261 "cs-parser.jay"
   {
 		var l = new List<Catch> (2);
 
 		l.Add ((Catch) yyVals[0+yyTop]);
 		yyVal = l;
 	  }
   break;
 case 835
 #line 5268 "cs-parser.jay"
   {
 		var l = (List<Catch>) yyVals[-1+yyTop];
 		
 		Catch c = (Catch) yyVals[0+yyTop];
 		if (l [0].IsGeneral) {
 			Report.Error (1017, c.loc, "Try statement already has an empty catch block");
 		} else {
 			if (c.IsGeneral)
 				l.Insert (0, c);
 			else
 				l.Add (c);
 		}
 		
 		yyVal = l;
 	  }
   break;
 case 838
 #line 5292 "cs-parser.jay"
   {
 		yyVal = new Catch ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 839
 #line 5296 "cs-parser.jay"
   {
 		start_block (GetLocation (yyVals[-3+yyTop]));
 		var c = new Catch (current_block, GetLocation (yyVals[-4+yyTop]));
 		c.TypeExpression = (FullNamedExpression) yyVals[-2+yyTop];
 
 		if (yyVals[-1+yyTop] != null) {
 			var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
 			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
 			current_block.AddLocalName (c.Variable);
 		}
 		
 		lbag.AddLocation (c, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
 		yyVal = c;
 	  }
   break;
 case 840
 #line 5311 "cs-parser.jay"
   {
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 841
 #line 5315 "cs-parser.jay"
   {
 	  	if (yyToken == Token.CLOSE_PARENS) {
 			Report.Error (1015, lexer.Location,
 				"A type that derives from `System.Exception', `object', or `string' expected");
 		} else {
 			Error_SyntaxError (yyToken);
 		}
 		
 		yyVal = new Catch (null, GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 842
 #line 5329 "cs-parser.jay"
   {
 		yyVal = new Checked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 843
 #line 5336 "cs-parser.jay"
   {
 		yyVal = new Unchecked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 844
 #line 5343 "cs-parser.jay"
   {
 		if (!RootContext.Unsafe)
 			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
 	  }
   break;
 case 845
 #line 5346 "cs-parser.jay"
   {
 		yyVal = new Unsafe ((Block) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 846
 #line 5353 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		yyVal = new Lock ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 	  }
   break;
 case 847
 #line 5364 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.FixedVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Fixed.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 848
 #line 5373 "cs-parser.jay"
   {
 		yyVal = current_variable;
 		current_variable = null;
 	  }
   break;
 case 849
 #line 5378 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Fixed f = new Fixed ((Fixed.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (f);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 850
 #line 5390 "cs-parser.jay"
   {
 	    start_block (GetLocation (yyVals[-2+yyTop]));
 	    
 		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.UsingVariable | LocalVariable.Flags.Used, lt.Location);
 		current_block.AddLocalName (li);
 		current_variable = new Using.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
 	  }
   break;
 case 851
 #line 5399 "cs-parser.jay"
   {
 		yyVal = current_variable;	  
 		current_variable = null;
 	  }
   break;
 case 852
 #line 5404 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Using.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
 		current_block.AddStatement (u);
 		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
 	  }
   break;
 case 853
 #line 5413 "cs-parser.jay"
   {
 		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
 			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
 	  
 		Using u = new Using ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		lbag.AddStatement (u, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
 		yyVal = u;
 	  }
   break;
 case 854
 #line 5425 "cs-parser.jay"
   {
 		Report.Error (210, lexer.Location, "You must provide an initializer in a fixed or using statement declaration");
 	  }
   break;
 case 855
 #line 5429 "cs-parser.jay"
   {
 		current_variable.Initializer = (Expression) yyVals[0+yyTop];
 		yyVal = current_variable;
 	  }
   break;
 case 856
 #line 5440 "cs-parser.jay"
   {
 		lexer.query_parsing = false;
 			
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 857
 #line 5452 "cs-parser.jay"
   {
 		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
 			
 		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = from;
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 858
 #line 5463 "cs-parser.jay"
   {
 	        lexer.query_parsing = false;
 		yyVal = yyVals[-1+yyTop];
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 859
 #line 5470 "cs-parser.jay"
   {
 	        yyVal = yyVals[-1+yyTop];
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 860
 #line 5479 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 861
 #line 5487 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 862
 #line 5502 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
 	  }
   break;
 case 863
 #line 5510 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.QueryExpression (
 			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
 				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
 			}
 		);
 	  }
   break;
 case 864
 #line 5525 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 865
 #line 5529 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 866
 #line 5540 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 867
 #line 5544 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 
 		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop])) {
 			IdentifierType = (FullNamedExpression)yyVals[-4+yyTop]
 		};
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 868
 #line 5561 "cs-parser.jay"
   {
 	  	Linq.AQueryClause head = (Linq.AQueryClause)yyVals[-1+yyTop];
 		
 		if (yyVals[0+yyTop] != null)
 			head.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 				
 		if (yyVals[-2+yyTop] != null) {
 			Linq.AQueryClause clause = (Linq.AQueryClause)yyVals[-2+yyTop];
 			clause.Tail.Next = head;
 			head = clause;
 		}
 		
 		yyVal = head;
 	  }
   break;
 case 870
 #line 5577 "cs-parser.jay"
   {
 		Error_SyntaxError (yyToken);
 		yyVal = null;
 	  }
   break;
 case 871
 #line 5585 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 872
 #line 5589 "cs-parser.jay"
   {
 		yyVal = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 873
 #line 5596 "cs-parser.jay"
   {
 	  	if (linq_clause_blocks == null)
 	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
 	  }
   break;
 case 874
 #line 5604 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 875
 #line 5611 "cs-parser.jay"
   {
 		yyVal = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)yyVals[-3+yyTop], linq_clause_blocks.Pop (), (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
 		
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 879
 #line 5627 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-1+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-1+yyTop];
 	  }
   break;
 case 885
 #line 5643 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 886
 #line 5647 "cs-parser.jay"
   {
 		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 	  	yyVal = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
 	  	
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 		
 		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 	  }
   break;
 case 887
 #line 5661 "cs-parser.jay"
   {
 	  	current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 888
 #line 5665 "cs-parser.jay"
   {
 		yyVal = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
 
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  }
   break;
 case 889
 #line 5675 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 890
 #line 5683 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 891
 #line 5691 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 892
 #line 5699 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];	
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-11+yyTop]));
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 			
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location);
 
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-11+yyTop]));	
 		}
 
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);
 	  }
   break;
 case 893
 #line 5735 "cs-parser.jay"
   {
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 894
 #line 5743 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
 	  }
   break;
 case 895
 #line 5751 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 896
 #line 5759 "cs-parser.jay"
   {
 		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
 		current_block.SetEndLocation (lexer.Location);
 	  
 		var outer_selector = linq_clause_blocks.Pop ();
 		var block = linq_clause_blocks.Pop ();
 		
 		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];
 		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
 		Linq.RangeVariable into;
 		
 		if (yyVals[0+yyTop] == null) {
 			into = sn;		
 	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};
 		} else {
 			/**/
 			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
 			/**/
 			var parent = block.Parent;
 			while (parent is Linq.QueryBlock) {
 				parent = parent.Parent;
 			}
 			current_block.Parent = parent;
 		
 			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
 		
 			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
 			into = new Linq.RangeVariable (lt.Value, lt.Location); /* TODO
 			
 			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-12+yyTop])) {
 	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
 	  		};			
 		}
 		
 		current_block = block.Parent;
 		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
 	  }
   break;
 case 898
 #line 5803 "cs-parser.jay"
   {
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 899
 #line 5810 "cs-parser.jay"
   {
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 900
 #line 5814 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		yyVal = yyVals[0+yyTop];
 	  }
   break;
 case 902
 #line 5825 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 	  }
   break;
 case 903
 #line 5832 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	  }
   break;
 case 905
 #line 5841 "cs-parser.jay"
   {
 		current_block.SetEndLocation (lexer.Location);
 		current_block = current_block.Parent;
 	  
 		current_block = new Linq.QueryBlock (compiler, (Linq.QueryBlock) current_block, lexer.Location);	 
 	 }
   break;
 case 906
 #line 5848 "cs-parser.jay"
   {
 		((Linq.AQueryClause)yyVals[-3+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
 		yyVal = yyVals[-3+yyTop];
 	 }
   break;
 case 907
 #line 5856 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 908
 #line 5860 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 909
 #line 5864 "cs-parser.jay"
   {
 		yyVal = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 910
 #line 5871 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
 	  }
   break;
 case 911
 #line 5875 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 912
 #line 5879 "cs-parser.jay"
   {
 		yyVal = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
 	  }
   break;
 case 914
 #line 5888 "cs-parser.jay"
   {
 		/* query continuation block is not linked with query block but with block*/
 		/* before. This means each query can use same range variable names for*/
 		/* different identifiers.*/
 
 		current_block.SetEndLocation (GetLocation (yyVals[-1+yyTop]));
 		current_block = current_block.Parent;
 	
 		current_block = new Linq.QueryBlock (compiler, current_block, lexer.Location);
 		
 		if (linq_clause_blocks == null)
 			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
 	  		
 		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
 	  }
   break;
 case 915
 #line 5904 "cs-parser.jay"
   {
 		var current_block = linq_clause_blocks.Pop ();	  
 		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
 		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
   		yyVal = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation (yyVals[-3+yyTop])) {
   			next = (Linq.AQueryClause)yyVals[0+yyTop]
   		};
 	  }
   break;
 case 918
 #line 5930 "cs-parser.jay"
   { 
 	        Evaluator.LoadAliases (current_namespace);
 
 		push_current_class (new Class (current_namespace, current_class, new MemberName ("Class" + class_count++),
 			Modifiers.PUBLIC, null), null);
 
 		var baseclass_list = new List<FullNamedExpression> ();
 		baseclass_list.Add (new TypeExpression (Evaluator.InteractiveBaseClass, lexer.Location));
 		current_container.AddBasesForPart (current_class, baseclass_list);
 
 		/* (ref object retval)*/
 		Parameter [] mpar = new Parameter [1];
 		mpar [0] = new Parameter (new TypeExpression (TypeManager.object_type, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);
 
 		ParametersCompiled pars = new ParametersCompiled (mpar);
 		current_local_parameters = pars;
 		Method method = new Method (
 			current_class,
 			null, /* generic*/
 			new TypeExpression (TypeManager.void_type, Location.Null),
 			Modifiers.PUBLIC | Modifiers.STATIC,
 			new MemberName ("Host"),
 			pars,
 			null /* attributes */);
 
 		oob_stack.Push (method);
 	        ++lexer.parsing_block;
 		start_block (lexer.Location);
 	  }
   break;
 case 919
 #line 5960 "cs-parser.jay"
   {
 		--lexer.parsing_block;
 		Method method = (Method) oob_stack.Pop ();
 
 		method.Block = (ToplevelBlock) end_block(lexer.Location);
 		current_container.AddMethod (method);
 
 		--lexer.parsing_declaration;
 		InteractiveResult = pop_current_class ();
 		current_local_parameters = null;
 	  }
   break;
 case 920
 #line 5971 "cs-parser.jay"
   {
 	        Evaluator.LoadAliases (current_namespace);
 	  }
   break;
 #line default
         }
         yyTop -= yyLen[yyN];
         yyState = yyStates[yyTop];
         int yyM = yyLhs[yyN];
         if (yyState == 0 && yyM == 0) {
           if (debug != null) debug.shift(0, yyFinal);
           yyState = yyFinal;
           if (yyToken < 0) {
             yyToken = yyLex.advance() ? yyLex.token() 
             if (debug != null)
                debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
           }
           if (yyToken == 0) {
             if (debug != null) debug.accept(yyVal);
             return yyVal;
           }
           goto continue_yyLoop;
         }
         if (((yyN = yyGindex[yyM]) != 0) && ((yyN += yyState) >= 0)
             && (yyN < yyTable.Length) && (yyCheck[yyN] == yyState))
           yyState = yyTable[yyN];
         else
           yyState = yyDgoto[yyM];
         if (debug != null) debug.shift(yyStates[yyTop], yyState);
 	 goto continue_yyLoop;
       continue_yyDiscarded
       }
     continue_yyLoop
     }
   }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="69" endline="153">
<![CDATA[
 		public BuildinTypes ()
 		{
 			Object = new BuildinTypeSpec (MemberKind.Class, "System", "Object", BuildinTypeSpec.Type.Object);
 			ValueType = new BuildinTypeSpec (MemberKind.Class, "System", "ValueType", BuildinTypeSpec.Type.ValueType);
 			Attribute = new BuildinTypeSpec (MemberKind.Class, "System", "Attribute", BuildinTypeSpec.Type.Attribute);
 
 			Int = new BuildinTypeSpec (MemberKind.Struct, "System", "Int32", BuildinTypeSpec.Type.Int);
 			Long = new BuildinTypeSpec (MemberKind.Struct, "System", "Int64", BuildinTypeSpec.Type.Long);
 			UInt = new BuildinTypeSpec (MemberKind.Struct, "System", "UInt32", BuildinTypeSpec.Type.UInt);
 			ULong = new BuildinTypeSpec (MemberKind.Struct, "System", "UInt64", BuildinTypeSpec.Type.ULong);
 			Byte = new BuildinTypeSpec (MemberKind.Struct, "System", "Byte", BuildinTypeSpec.Type.Byte);
 			SByte = new BuildinTypeSpec (MemberKind.Struct, "System", "SByte", BuildinTypeSpec.Type.SByte);
 			Short = new BuildinTypeSpec (MemberKind.Struct, "System", "Int16", BuildinTypeSpec.Type.Short);
 			UShort = new BuildinTypeSpec (MemberKind.Struct, "System", "UInt16", BuildinTypeSpec.Type.UShort);
 
 			IEnumerator = new BuildinTypeSpec (MemberKind.Interface, "System.Collections", "IEnumerator", BuildinTypeSpec.Type.IEnumerator);
 			IEnumerable = new BuildinTypeSpec (MemberKind.Interface, "System.Collections", "IEnumerable", BuildinTypeSpec.Type.IEnumerable);
 			IDisposable = new BuildinTypeSpec (MemberKind.Interface, "System", "IDisposable", BuildinTypeSpec.Type.IDisposable);
 
 			Char = new BuildinTypeSpec (MemberKind.Struct, "System", "Char", BuildinTypeSpec.Type.Char);
 			String = new BuildinTypeSpec (MemberKind.Class, "System", "String", BuildinTypeSpec.Type.String);
 			Float = new BuildinTypeSpec (MemberKind.Struct, "System", "Single", BuildinTypeSpec.Type.Float);
 			Double = new BuildinTypeSpec (MemberKind.Struct, "System", "Double", BuildinTypeSpec.Type.Double);
 			Decimal = new BuildinTypeSpec (MemberKind.Struct, "System", "Decimal", BuildinTypeSpec.Type.Decimal);
 			Bool = new BuildinTypeSpec (MemberKind.Struct, "System", "Boolean", BuildinTypeSpec.Type.Bool);
 			IntPtr = new BuildinTypeSpec (MemberKind.Struct, "System", "IntPtr", BuildinTypeSpec.Type.IntPtr);
 			UIntPtr = new BuildinTypeSpec (MemberKind.Struct, "System", "UIntPtr", BuildinTypeSpec.Type.UIntPtr);
 
 			MulticastDelegate = new BuildinTypeSpec (MemberKind.Class, "System", "MulticastDelegate", BuildinTypeSpec.Type.MulticastDelegate);
 			Delegate = new BuildinTypeSpec (MemberKind.Class, "System", "Delegate", BuildinTypeSpec.Type.Delegate);
 			Enum = new BuildinTypeSpec (MemberKind.Class, "System", "Enum", BuildinTypeSpec.Type.Enum);
 			Array = new BuildinTypeSpec (MemberKind.Class, "System", "Array", BuildinTypeSpec.Type.Array);
 			Void = new BuildinTypeSpec (MemberKind.Struct, "System", "Void", BuildinTypeSpec.Type.Void);
 			Type = new BuildinTypeSpec (MemberKind.Class, "System", "Type", BuildinTypeSpec.Type.Type);
 			Exception = new BuildinTypeSpec (MemberKind.Class, "System", "Exception", BuildinTypeSpec.Type.Exception);
 			RuntimeFieldHandle = new BuildinTypeSpec (MemberKind.Struct, "System", "RuntimeFieldHandle", BuildinTypeSpec.Type.RuntimeFieldHandle);
 			RuntimeTypeHandle = new BuildinTypeSpec (MemberKind.Struct, "System", "RuntimeTypeHandle", BuildinTypeSpec.Type.RuntimeTypeHandle);
 
 			Dynamic = new BuildinTypeSpec ("dynamic", BuildinTypeSpec.Type.Dynamic);
 			Null = new BuildinTypeSpec ("null", BuildinTypeSpec.Type.Null);
 			Null.MemberCache = MemberCache.Empty;
 
 			types = new BuildinTypeSpec[] {
 				Object, ValueType, Attribute,
 				Int, UInt, Long, ULong, Float, Double, Char, Short, Decimal, Bool, SByte, Byte, UShort, String,
 				Enum, Delegate, MulticastDelegate, Void, Array, Type, IEnumerator, IEnumerable, IDisposable,
 				IntPtr, UIntPtr, RuntimeFieldHandle, RuntimeTypeHandle, Exception };
 
 			// Deal with obsolete static types
 			// TODO
 			TypeManager.object_type = Object;
 			TypeManager.value_type = ValueType;
 			TypeManager.string_type = String;
 			TypeManager.int32_type = Int;
 			TypeManager.uint32_type = UInt;
 			TypeManager.int64_type = Long;
 			TypeManager.uint64_type = ULong;
 			TypeManager.float_type = Float;
 			TypeManager.double_type = Double;
 			TypeManager.char_type = Char;
 			TypeManager.short_type = Short;
 			TypeManager.decimal_type = Decimal;
 			TypeManager.bool_type = Bool;
 			TypeManager.sbyte_type = SByte;
 			TypeManager.byte_type = Byte;
 			TypeManager.ushort_type = UShort;
 			TypeManager.enum_type = Enum;
 			TypeManager.delegate_type = Delegate;
 			TypeManager.multicast_delegate_type = MulticastDelegate; ;
 			TypeManager.void_type = Void;
 			TypeManager.array_type = Array; ;
 			TypeManager.runtime_handle_type = RuntimeTypeHandle;
 			TypeManager.type_type = Type;
 			TypeManager.ienumerator_type = IEnumerator;
 			TypeManager.ienumerable_type = IEnumerable;
 			TypeManager.idisposable_type = IDisposable;
 			TypeManager.intptr_type = IntPtr;
 			TypeManager.uintptr_type = UIntPtr;
 			TypeManager.runtime_field_handle_type = RuntimeFieldHandle;
 			TypeManager.attribute_type = Attribute;
 			TypeManager.exception_type = Exception;
 
 			InternalType.Dynamic = Dynamic;
 			InternalType.Null = Null;
 		}
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="27" nfragments="2" Csharpe_files="2" vb_files="0" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\attribute.cs" startline="1686" endline="1800">
<![CDATA[
 	}
 
 	//
 	// Predefined attribute types
 	//
 	public class PredefinedAttributes
 	{
 		// Build-in attributes
 		public readonly PredefinedAttribute ParamArray;
 		public readonly PredefinedAttribute Out;
 
 		// Optional attributes
 		public readonly PredefinedAttribute Obsolete;
 		public readonly PredefinedAttribute DllImport;
 		public readonly PredefinedAttribute MethodImpl;
 		public readonly PredefinedAttribute MarshalAs;
 		public readonly PredefinedAttribute In;
 		public readonly PredefinedAttribute IndexerName;
 		public readonly PredefinedAttribute Conditional;
 		public readonly PredefinedAttribute CLSCompliant;
 		public readonly PredefinedAttribute Security;
 		public readonly PredefinedAttribute Required;
 		public readonly PredefinedAttribute Guid;
 		public readonly PredefinedAttribute AssemblyCulture;
 		public readonly PredefinedAttribute AssemblyVersion;
 		public readonly PredefinedAttribute AssemblyAlgorithmId;
 		public readonly PredefinedAttribute AssemblyFlags;
 		public readonly PredefinedAttribute AssemblyFileVersion;
 		public readonly PredefinedAttribute ComImport;
 		public readonly PredefinedAttribute CoClass;
 		public readonly PredefinedAttribute AttributeUsage;
 		public readonly PredefinedAttribute DefaultParameterValue;
 		public readonly PredefinedAttribute OptionalParameter;
 		public readonly PredefinedAttribute UnverifiableCode;
 
 		// New in .NET 2.0
 		//public readonly PredefinedAttribute DefaultCharset;
 		public readonly PredefinedAttribute TypeForwarder;
 		public readonly PredefinedAttribute FixedBuffer;
 		public readonly PredefinedAttribute CompilerGenerated;
 		public readonly PredefinedAttribute InternalsVisibleTo;
 		public readonly PredefinedAttribute RuntimeCompatibility;
 		public readonly PredefinedAttribute DebuggerHidden;
 		public readonly PredefinedAttribute UnsafeValueType;
 
 		// New in .NET 3.5
 		public readonly PredefinedAttribute Extension;
 
 		// New in .NET 4.0
 		public readonly PredefinedDynamicAttribute Dynamic;
 
 		//
 		// Optional types which are used as types and for member lookup
 		//
 		public readonly PredefinedAttribute DefaultMember;
 		public readonly PredefinedDecimalAttribute DecimalConstant;
 		public readonly PredefinedAttribute StructLayout;
 		public readonly PredefinedAttribute FieldOffset;
 
 		public PredefinedAttributes (ModuleContainer module)
 		{
 			ParamArray = new PredefinedAttribute (module, "System", "ParamArrayAttribute");
 			Out = new PredefinedAttribute (module, "System.Runtime.InteropServices", "OutAttribute");
 			ParamArray.Resolve (Location.Null);
 			Out.Resolve (Location.Null);
 
 			Obsolete = new PredefinedAttribute (module, "System", "ObsoleteAttribute");
 			DllImport = new PredefinedAttribute (module, "System.Runtime.InteropServices", "DllImportAttribute");
 			MethodImpl = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "MethodImplAttribute");
 			MarshalAs = new PredefinedAttribute (module, "System.Runtime.InteropServices", "MarshalAsAttribute");
 			In = new PredefinedAttribute (module, "System.Runtime.InteropServices", "InAttribute");
 			IndexerName = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "IndexerNameAttribute");
 			Conditional = new PredefinedAttribute (module, "System.Diagnostics", "ConditionalAttribute");
 			CLSCompliant = new PredefinedAttribute (module, "System", "CLSCompliantAttribute");
 			Security = new PredefinedAttribute (module, "System.Security.Permissions", "SecurityAttribute");
 			Required = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "RequiredAttributeAttribute");
 			Guid = new PredefinedAttribute (module, "System.Runtime.InteropServices", "GuidAttribute");
 			AssemblyCulture = new PredefinedAttribute (module, "System.Reflection", "AssemblyCultureAttribute");
 			AssemblyVersion = new PredefinedAttribute (module, "System.Reflection", "AssemblyVersionAttribute");
 			AssemblyAlgorithmId = new PredefinedAttribute (module, "System.Reflection", "AssemblyAlgorithmIdAttribute");
 			AssemblyFlags = new PredefinedAttribute (module, "System.Reflection", "AssemblyFlagsAttribute");
 			AssemblyFileVersion = new PredefinedAttribute (module, "System.Reflection", "AssemblyFileVersionAttribute");
 			ComImport = new PredefinedAttribute (module, "System.Runtime.InteropServices", "ComImportAttribute");
 			CoClass = new PredefinedAttribute (module, "System.Runtime.InteropServices", "CoClassAttribute");
 			AttributeUsage = new PredefinedAttribute (module, "System", "AttributeUsageAttribute");
 			DefaultParameterValue = new PredefinedAttribute (module, "System.Runtime.InteropServices", "DefaultParameterValueAttribute");
 			OptionalParameter = new PredefinedAttribute (module, "System.Runtime.InteropServices", "OptionalAttribute");
 			UnverifiableCode = new PredefinedAttribute (module, "System.Security", "UnverifiableCodeAttribute");
 
 			//DefaultCharset = new PredefinedAttribute (module, "System.Runtime.InteropServices", "DefaultCharSetAttribute");
 			TypeForwarder = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "TypeForwardedToAttribute");
 			FixedBuffer = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "FixedBufferAttribute");
 			CompilerGenerated = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "CompilerGeneratedAttribute");
 			InternalsVisibleTo = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "InternalsVisibleToAttribute");
 			RuntimeCompatibility = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "RuntimeCompatibilityAttribute");
 			DebuggerHidden = new PredefinedAttribute (module, "System.Diagnostics", "DebuggerHiddenAttribute");
 			UnsafeValueType = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "UnsafeValueTypeAttribute");
 
 			Extension = new PredefinedAttribute (module, "System.Runtime.CompilerServices", "ExtensionAttribute");
 
 			Dynamic = new PredefinedDynamicAttribute (module, "System.Runtime.CompilerServices", "DynamicAttribute");
 
 			DefaultMember = new PredefinedAttribute (module, "System.Reflection", "DefaultMemberAttribute");
 			DecimalConstant = new PredefinedDecimalAttribute (module, "System.Runtime.CompilerServices", "DecimalConstantAttribute");
 			StructLayout = new PredefinedAttribute (module, "System.Runtime.InteropServices", "StructLayoutAttribute");
 			FieldOffset = new PredefinedAttribute (module, "System.Runtime.InteropServices", "FieldOffsetAttribute");
 
 			// TODO
 			const System.Reflection.BindingFlags all_fields = System.Reflection.BindingFlags.Public |
 				System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.DeclaredOnly;
 
 			foreach (var fi in GetType ().GetFields (all_fields)) {
 				((PredefinedAttribute) fi.GetValue (this)).Define ();
 			}
 			foreach (var fi in GetType ().GetFields (all_fields)) {
 				((PredefinedAttribute) fi.GetValue (this)).Define ();
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-2.10\mcs\mcs\typemanager.cs" startline="188" endline="304">
<![CDATA[
 	}
 
 	//
 	// Compiler predefined types. Usually used for compiler generated
 	// code or for comparison against well known framework type
 	//
 	class PredefinedTypes
 	{
 		// TODO
 		public readonly PredefinedType TypedReference;
 		public readonly PredefinedType ArgIterator;
 
 		public readonly PredefinedType MarshalByRefObject;
 		public readonly PredefinedType RuntimeHelpers;
 		public readonly PredefinedType IAsyncResult;
 		public readonly PredefinedType AsyncCallback;
 		public readonly PredefinedType RuntimeArgumentHandle;
 		public readonly PredefinedType CharSet;
 		public readonly PredefinedType IsVolatile;
 		public readonly PredefinedType IEnumeratorGeneric;
 		public readonly PredefinedType IListGeneric;
 		public readonly PredefinedType ICollectionGeneric;
 		public readonly PredefinedType IEnumerableGeneric;
 		public readonly PredefinedType Nullable;
 		public readonly PredefinedType Activator;
 		public readonly PredefinedType Interlocked;
 		public readonly PredefinedType Monitor;
 		public readonly PredefinedType NotSupportedException;
 		public readonly PredefinedType RuntimeFieldHandle;
 		public readonly PredefinedType RuntimeMethodHandle;
 		public readonly PredefinedType SecurityAction;
 
 		//
 		// C# 3.0
 		//
 		public readonly PredefinedType Expression;
 		public readonly PredefinedType ExpressionGeneric;
 		public readonly PredefinedType ParameterExpression;
 		public readonly PredefinedType FieldInfo;
 		public readonly PredefinedType MethodBase;
 		public readonly PredefinedType MethodInfo;
 		public readonly PredefinedType ConstructorInfo;
 
 		//
 		// C# 4.0
 		//
 		public readonly PredefinedType Binder;
 		public readonly PredefinedType CallSite;
 		public readonly PredefinedType CallSiteGeneric;
 		public readonly PredefinedType BinderFlags;
 
 		public PredefinedTypes (ModuleContainer module)
 		{
 			TypedReference = new PredefinedType (module, MemberKind.Struct, "System", "TypedReference");
 			ArgIterator = new PredefinedType (module, MemberKind.Struct, "System", "ArgIterator");
 			MarshalByRefObject = new PredefinedType (module, MemberKind.Class, "System", "MarshalByRefObject");
 			RuntimeHelpers = new PredefinedType (module, MemberKind.Class, "System.Runtime.CompilerServices", "RuntimeHelpers");
 			IAsyncResult = new PredefinedType (module, MemberKind.Interface, "System", "IAsyncResult");
 			AsyncCallback = new PredefinedType (module, MemberKind.Delegate, "System", "AsyncCallback");
 			RuntimeArgumentHandle = new PredefinedType (module, MemberKind.Struct, "System", "RuntimeArgumentHandle");
 			CharSet = new PredefinedType (module, MemberKind.Enum, "System.Runtime.InteropServices", "CharSet");
 			IsVolatile = new PredefinedType (module, MemberKind.Class, "System.Runtime.CompilerServices", "IsVolatile");
 			IEnumeratorGeneric = new PredefinedType (module, MemberKind.Interface, "System.Collections.Generic", "IEnumerator", 1);
 			IListGeneric = new PredefinedType (module, MemberKind.Interface, "System.Collections.Generic", "IList", 1);
 			ICollectionGeneric = new PredefinedType (module, MemberKind.Interface, "System.Collections.Generic", "ICollection", 1);
 			IEnumerableGeneric = new PredefinedType (module, MemberKind.Interface, "System.Collections.Generic", "IEnumerable", 1);
 			Nullable = new PredefinedType (module, MemberKind.Struct, "System", "Nullable", 1);
 			Activator = new PredefinedType (module, MemberKind.Class, "System", "Activator");
 			Interlocked = new PredefinedType (module, MemberKind.Class, "System.Threading", "Interlocked");
 			Monitor = new PredefinedType (module, MemberKind.Class, "System.Threading", "Monitor");
 			NotSupportedException = new PredefinedType (module, MemberKind.Class, "System", "NotSupportedException");
 			RuntimeFieldHandle = new PredefinedType (module, MemberKind.Struct, "System", "RuntimeFieldHandle");
 			RuntimeMethodHandle = new PredefinedType (module, MemberKind.Struct, "System", "RuntimeMethodHandle");
 			SecurityAction = new PredefinedType (module, MemberKind.Enum, "System.Security.Permissions", "SecurityAction");
 
 			Expression = new PredefinedType (module, MemberKind.Class, "System.Linq.Expressions", "Expression");
 			ExpressionGeneric = new PredefinedType (module, MemberKind.Class, "System.Linq.Expressions", "Expression", 1);
 			ParameterExpression = new PredefinedType (module, MemberKind.Class, "System.Linq.Expressions", "ParameterExpression");
 			FieldInfo = new PredefinedType (module, MemberKind.Class, "System.Reflection", "FieldInfo");
 			MethodBase = new PredefinedType (module, MemberKind.Class, "System.Reflection", "MethodBase");
 			MethodInfo = new PredefinedType (module, MemberKind.Class, "System.Reflection", "MethodInfo");
 			ConstructorInfo = new PredefinedType (module, MemberKind.Class, "System.Reflection", "ConstructorInfo");
 
 			CallSite = new PredefinedType (module, MemberKind.Class, "System.Runtime.CompilerServices", "CallSite");
 			CallSiteGeneric = new PredefinedType (module, MemberKind.Class, "System.Runtime.CompilerServices", "CallSite", 1);
 			Binder = new PredefinedType (module, MemberKind.Class, "Microsoft.CSharp.RuntimeBinder", "Binder");
 			BinderFlags = new PredefinedType (module, MemberKind.Enum, "Microsoft.CSharp.RuntimeBinder", "CSharpBinderFlags");
 
 			//
 			// Define types which are used for comparison. It does not matter
 			// if they don't exist as no error report is needed
 			//
 			TypedReference.Define ();
 			ArgIterator.Define ();
 			MarshalByRefObject.Define ();
 			CharSet.Define ();
 
 			IEnumerableGeneric.Define ();
 			IListGeneric.Define ();
 			ICollectionGeneric.Define ();
 			IEnumerableGeneric.Define ();
 			IEnumeratorGeneric.Define ();
 			Nullable.Define ();
 			ExpressionGeneric.Define ();
 
 			// Deal with obsolete static types
 			// TODO
 			TypeManager.typed_reference_type = TypedReference.TypeSpec;
 			TypeManager.arg_iterator_type = ArgIterator.TypeSpec;
 			TypeManager.mbr_type = MarshalByRefObject.TypeSpec;
 			TypeManager.generic_ilist_type = IListGeneric.TypeSpec;
 			TypeManager.generic_icollection_type = ICollectionGeneric.TypeSpec;
 			TypeManager.generic_ienumerator_type = IEnumeratorGeneric.TypeSpec;
 			TypeManager.generic_ienumerable_type = IEnumerableGeneric.TypeSpec;
 			TypeManager.generic_nullable_type = Nullable.TypeSpec;
 			TypeManager.expression_type = ExpressionGeneric.TypeSpec;
 		}
]]>
</clone_fragment>
</clone_group>
</clones>
