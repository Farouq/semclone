<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\Driver.fs" startline="11" endline="41"><![CDATA[
     let writeInColor color msg =
         let oldColor = Console.ForegroundColor
         Console.ForegroundColor <- color
         Console.WriteLine(msg.ToString())
         Console.ForegroundColor <- oldColor
 
     writeInColor ConsoleColor.Green "
 
     let SIPNP = 
         BindingFlags.Static ||| BindingFlags.Instance ||| 
         BindingFlags.Public ||| BindingFlags.NonPublic
     Assembly.GetExecutingAssembly().GetTypes() |> Array.iter (fun typ ->
             typ.GetMethods(SIPNP) |> Array.iter (fun meth ->
                 let customAttrs = meth.GetCustomAttributes(false)
                 try
                     let result = customAttrs |> Array.find (fun attr -> attr 
                     if result 
                         writeInColor ConsoleColor.Blue ("==========> Executing " + (result 
                         try
                             meth.Invoke(null, [| |]) |> ignore
                         with
                         | ex -> 
                             writeInColor ConsoleColor.Red ("Exception
                             writeInColor ConsoleColor.Yellow (ex.StackTrace)
                     else
                         ()
                 with
                 |   ex -> ()
             )
         )
     0
     Assembly.GetExecutingAssembly().GetTypes() |> Array.iter (fun typ ->
             typ.GetMethods(SIPNP) |> Array.iter (fun meth ->
                 let customAttrs = meth.GetCustomAttributes(false)
                 try
                     let result = customAttrs |> Array.find (fun attr -> attr 
                     if result 
                         writeInColor ConsoleColor.Blue ("==========> Executing " + (result 
                         try
                             meth.Invoke(null, [| |]) |> ignore
                         with
                         | ex -> 
                             writeInColor ConsoleColor.Red ("Exception
                             writeInColor ConsoleColor.Yellow (ex.StackTrace)
                     else
                         ()
                 with
                 |   ex -> ()
             )
         )
     0
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="10" endline="58"><![CDATA[
     let x = 12
     match x with
     | 12 -> System.Console.WriteLine("It's 12")
     | _ -> System.Console.WriteLine("It's not 12")
     
     let y = match x with
             | 12 -> 24
             | _ -> 36
             
     
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     List.iter
         (fun (p) -> match p with
                      | (fn, ln, _) -> System.Console.WriteLine("{0} {1}", fn, ln)
                      | _ -> failwith "Unexpected value"
         )
         people
 
     let p = new Person("Ken", "Sipe", 45)
     let lastName = match (p.FirstName, p.LastName, p.Age) with
                     | ("Ken", "Sipe", _) -> p.LastName
                     | _ -> ""
 
     let persons = [
         new Person("Ted", "Neward", 38)
         new Person("Ken", "Sipe", 43)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Amanda", "Sipe", 18)
         ]
     List.iter
         (fun (p 
             match (p.FirstName, p.LastName) with
             | (fn, "Sipe") ->
                 System.Console.WriteLine("Hello, {0}!", fn)
             | (fn, "Neward") ->
                 System.Console.WriteLine("Go away, {0}!", fn)
             | _ ->
                 System.Console.WriteLine("Who the heck are you?")
         )
         persons
     ()
     
 [<Example("Constant pattern matching")>]
 let const_pat_example() =
     let r = (new System.Random()).Next(5)
     let message = match r with
                     | 0 -> "zero"
                     | 1 -> "one"
                     | 2 -> "two"
                     | 3 -> "three"
                     | 4 -> "four"
                     | 5 -> "five"
                     | _ -> "Unknown
     System.Console.WriteLine("We got {0}", message)
     
     let x = (new System.Random()).Next(2)
     let y = (new System.Random()).Next(2)
     let quadrant = match x, y with
                     | 0, 0 -> "(0,0)"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     | _ -> System.Console.WriteLine("It's not 12")
     
     let y = match x with
             | 12 -> 24
             | _ -> 36
             
     
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     List.iter
         (fun (p) -> match p with
                      | (fn, ln, _) -> System.Console.WriteLine("{0} {1}", fn, ln)
                      | _ -> failwith "Unexpected value"
         )
         people
 
     let p = new Person("Ken", "Sipe", 45)
     let lastName = match (p.FirstName, p.LastName, p.Age) with
                     | ("Ken", "Sipe", _) -> p.LastName
                     | _ -> ""
 
     let persons = [
         new Person("Ted", "Neward", 38)
         new Person("Ken", "Sipe", 43)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Amanda", "Sipe", 18)
         ]
     List.iter
         (fun (p 
             match (p.FirstName, p.LastName) with
             | (fn, "Sipe") ->
                 System.Console.WriteLine("Hello, {0}!", fn)
             | (fn, "Neward") ->
                 System.Console.WriteLine("Go away, {0}!", fn)
             | _ ->
                 System.Console.WriteLine("Who the heck are you?")
         )
         persons
     ()
     
 [<Example("Constant pattern matching")>]
 let const_pat_example() =
     let r = (new System.Random()).Next(5)
     let message = match r with
                     | 0 -> "zero"
                     | 1 -> "one"
                     | 2 -> "two"
                     | 3 -> "three"
                     | 4 -> "four"
                     | 5 -> "five"
                     | _ -> "Unknown
     System.Console.WriteLine("We got {0}", message)
     
     let x = (new System.Random()).Next(2)
     let y = (new System.Random()).Next(2)
     let quadrant = match x, y with
                     | 0, 0 -> "(0,0)"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     let y = match x with
             | 12 -> 24
             | _ -> 36
             
     
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     List.iter
         (fun (p) -> match p with
                      | (fn, ln, _) -> System.Console.WriteLine("{0} {1}", fn, ln)
                      | _ -> failwith "Unexpected value"
         )
         people
 
     let p = new Person("Ken", "Sipe", 45)
     let lastName = match (p.FirstName, p.LastName, p.Age) with
                     | ("Ken", "Sipe", _) -> p.LastName
                     | _ -> ""
 
     let persons = [
         new Person("Ted", "Neward", 38)
         new Person("Ken", "Sipe", 43)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Amanda", "Sipe", 18)
         ]
     List.iter
         (fun (p 
             match (p.FirstName, p.LastName) with
             | (fn, "Sipe") ->
                 System.Console.WriteLine("Hello, {0}!", fn)
             | (fn, "Neward") ->
                 System.Console.WriteLine("Go away, {0}!", fn)
             | _ ->
                 System.Console.WriteLine("Who the heck are you?")
         )
         persons
     ()
     
 [<Example("Constant pattern matching")>]
 let const_pat_example() =
     let r = (new System.Random()).Next(5)
     let message = match r with
                     | 0 -> "zero"
                     | 1 -> "one"
                     | 2 -> "two"
                     | 3 -> "three"
                     | 4 -> "four"
                     | 5 -> "five"
                     | _ -> "Unknown
     System.Console.WriteLine("We got {0}", message)
     
     let x = (new System.Random()).Next(2)
     let y = (new System.Random()).Next(2)
     let quadrant = match x, y with
                     | 0, 0 -> "(0,0)"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
             | _ -> 36
             
     
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     List.iter
         (fun (p) -> match p with
                      | (fn, ln, _) -> System.Console.WriteLine("{0} {1}", fn, ln)
                      | _ -> failwith "Unexpected value"
         )
         people
 
     let p = new Person("Ken", "Sipe", 45)
     let lastName = match (p.FirstName, p.LastName, p.Age) with
                     | ("Ken", "Sipe", _) -> p.LastName
                     | _ -> ""
 
     let persons = [
         new Person("Ted", "Neward", 38)
         new Person("Ken", "Sipe", 43)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Amanda", "Sipe", 18)
         ]
     List.iter
         (fun (p 
             match (p.FirstName, p.LastName) with
             | (fn, "Sipe") ->
                 System.Console.WriteLine("Hello, {0}!", fn)
             | (fn, "Neward") ->
                 System.Console.WriteLine("Go away, {0}!", fn)
             | _ ->
                 System.Console.WriteLine("Who the heck are you?")
         )
         persons
     ()
     
 [<Example("Constant pattern matching")>]
 let const_pat_example() =
     let r = (new System.Random()).Next(5)
     let message = match r with
                     | 0 -> "zero"
                     | 1 -> "one"
                     | 2 -> "two"
                     | 3 -> "three"
                     | 4 -> "four"
                     | 5 -> "five"
                     | _ -> "Unknown
     System.Console.WriteLine("We got {0}", message)
     
     let x = (new System.Random()).Next(2)
     let y = (new System.Random()).Next(2)
     let quadrant = match x, y with
                     | 0, 0 -> "(0,0)"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     List.iter
         (fun (p) -> match p with
                      | (fn, ln, _) -> System.Console.WriteLine("{0} {1}", fn, ln)
                      | _ -> failwith "Unexpected value"
         )
         people
 
     let p = new Person("Ken", "Sipe", 45)
     let lastName = match (p.FirstName, p.LastName, p.Age) with
                     | ("Ken", "Sipe", _) -> p.LastName
                     | _ -> ""
 
     let persons = [
         new Person("Ted", "Neward", 38)
         new Person("Ken", "Sipe", 43)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Amanda", "Sipe", 18)
         ]
     List.iter
         (fun (p 
             match (p.FirstName, p.LastName) with
             | (fn, "Sipe") ->
                 System.Console.WriteLine("Hello, {0}!", fn)
             | (fn, "Neward") ->
                 System.Console.WriteLine("Go away, {0}!", fn)
             | _ ->
                 System.Console.WriteLine("Who the heck are you?")
         )
         persons
     ()
     
 [<Example("Constant pattern matching")>]
 let const_pat_example() =
     let r = (new System.Random()).Next(5)
     let message = match r with
                     | 0 -> "zero"
                     | 1 -> "one"
                     | 2 -> "two"
                     | 3 -> "three"
                     | 4 -> "four"
                     | 5 -> "five"
                     | _ -> "Unknown
     System.Console.WriteLine("We got {0}", message)
     
     let x = (new System.Random()).Next(2)
     let y = (new System.Random()).Next(2)
     let quadrant = match x, y with
                     | 0, 0 -> "(0,0)"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | _ -> ""
 
     let persons = [
         new Person("Ted", "Neward", 38)
         new Person("Ken", "Sipe", 43)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Amanda", "Sipe", 18)
         ]
     List.iter
         (fun (p 
             match (p.FirstName, p.LastName) with
             | (fn, "Sipe") ->
                 System.Console.WriteLine("Hello, {0}!", fn)
             | (fn, "Neward") ->
                 System.Console.WriteLine("Go away, {0}!", fn)
             | _ ->
                 System.Console.WriteLine("Who the heck are you?")
         )
         persons
     ()
     
 [<Example("Constant pattern matching")>]
 let const_pat_example() =
     let r = (new System.Random()).Next(5)
     let message = match r with
                     | 0 -> "zero"
                     | 1 -> "one"
                     | 2 -> "two"
                     | 3 -> "three"
                     | 4 -> "four"
                     | 5 -> "five"
                     | _ -> "Unknown
     System.Console.WriteLine("We got {0}", message)
     
     let x = (new System.Random()).Next(2)
     let y = (new System.Random()).Next(2)
     let quadrant = match x, y with
                     | 0, 0 -> "(0,0)"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     let persons = [
         new Person("Ted", "Neward", 38)
         new Person("Ken", "Sipe", 43)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Amanda", "Sipe", 18)
         ]
     List.iter
         (fun (p 
             match (p.FirstName, p.LastName) with
             | (fn, "Sipe") ->
                 System.Console.WriteLine("Hello, {0}!", fn)
             | (fn, "Neward") ->
                 System.Console.WriteLine("Go away, {0}!", fn)
             | _ ->
                 System.Console.WriteLine("Who the heck are you?")
         )
         persons
     ()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="59" endline="85"><![CDATA[
     
 [<Example("Constant pattern matching")>]
 let const_pat_example() =
     let r = (new System.Random()).Next(5)
     let message = match r with
                     | 0 -> "zero"
                     | 1 -> "one"
                     | 2 -> "two"
                     | 3 -> "three"
                     | 4 -> "four"
                     | 5 -> "five"
                     | _ -> "Unknown
     System.Console.WriteLine("We got {0}", message)
     
     let x = (new System.Random()).Next(2)
     let y = (new System.Random()).Next(2)
     let quadrant = match x, y with
                     | 0, 0 -> "(0,0)"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | 1 -> "one"
                     | 2 -> "two"
                     | 3 -> "three"
                     | 4 -> "four"
                     | 5 -> "five"
                     | _ -> "Unknown
     System.Console.WriteLine("We got {0}", message)
     
     let x = (new System.Random()).Next(2)
     let y = (new System.Random()).Next(2)
     let quadrant = match x, y with
                     | 0, 0 -> "(0,0)"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | 2 -> "two"
                     | 3 -> "three"
                     | 4 -> "four"
                     | 5 -> "five"
                     | _ -> "Unknown
     System.Console.WriteLine("We got {0}", message)
     
     let x = (new System.Random()).Next(2)
     let y = (new System.Random()).Next(2)
     let quadrant = match x, y with
                     | 0, 0 -> "(0,0)"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | 3 -> "three"
                     | 4 -> "four"
                     | 5 -> "five"
                     | _ -> "Unknown
     System.Console.WriteLine("We got {0}", message)
     
     let x = (new System.Random()).Next(2)
     let y = (new System.Random()).Next(2)
     let quadrant = match x, y with
                     | 0, 0 -> "(0,0)"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | 4 -> "four"
                     | 5 -> "five"
                     | _ -> "Unknown
     System.Console.WriteLine("We got {0}", message)
     
     let x = (new System.Random()).Next(2)
     let y = (new System.Random()).Next(2)
     let quadrant = match x, y with
                     | 0, 0 -> "(0,0)"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | 5 -> "five"
                     | _ -> "Unknown
     System.Console.WriteLine("We got {0}", message)
     
     let x = (new System.Random()).Next(2)
     let y = (new System.Random()).Next(2)
     let quadrant = match x, y with
                     | 0, 0 -> "(0,0)"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | _ -> "Unknown
     System.Console.WriteLine("We got {0}", message)
     
     let x = (new System.Random()).Next(2)
     let y = (new System.Random()).Next(2)
     let quadrant = match x, y with
                     | 0, 0 -> "(0,0)"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     System.Console.WriteLine("We got {0}", message)
     
     let x = (new System.Random()).Next(2)
     let y = (new System.Random()).Next(2)
     let quadrant = match x, y with
                     | 0, 0 -> "(0,0)"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | 0, 1 -> "(0,1)"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | 0, 2 -> "(0,2)"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | 1, 0 -> "(1,0)"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | 1, 1 -> "(1,1)"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | 1, 2 -> "(1,2)"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | 2, 0 -> "(2,0)"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | 2, 1 -> "(2,1)"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | 2, 2 -> "(2,2)"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     System.Console.WriteLine("We got {0}", message)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="86" endline="98"><![CDATA[
 
 [<Example("Named pattern example")>]
 let named_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | fn -> "Hello, " + fn
     System.Console.WriteLine("We got {0}", message)
 
     let p = new Person("Rachel", "Appel", 25)
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     let message = match p.FirstName with
                     | "Rachel" -> "It's one of the Rachii!!"
                     | fn -> "Alas, you are not a Rachii, " + fn
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     System.Console.WriteLine("We got {0}", message)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="99" endline="106"><![CDATA[
 
 [<Example("AND/OR pattern example")>]
 let andor_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | _ -> "Who are you, again?"
     System.Console.WriteLine("We got {0}", message)
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     System.Console.WriteLine("We got {0}", message)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="107" endline="118"><![CDATA[
 
 
 [<Literal>]
 let rachel = "Rachel"
 
 [<Example("Literals pattern example")>]
 let literal_pat_example() =
     let p = new Person("Rachel", "Reese", 25)
     let message = match p.FirstName with
                     | rachel -> "Howdy, Rachel!"
                     | _ -> "Howdy, whoever you are!"
     System.Console.WriteLine("We got {0}", message)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="119" endline="127"><![CDATA[
 
 [<Example("Tuple pattern maching example")>]
 let tuple_pat_example() =
     let p = ("Aaron", "Erickson", 35)
     let message = match p with
                     | (first, last, age) -> 
                         "Howdy " + first + " " + last +
                         ", I'm glad to hear you're " + age.ToString() + "!"
     System.Console.WriteLine("We got {0}", message)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="128" endline="146"><![CDATA[
 
 [<Example("List pattern matching example")>]
 let list_pat_example() =
     let numbers = [1; 2; 3; 4; 5]
     let rec sumList ns = match ns with
                             | [] -> 0
                             | head 
     let sum = sumList numbers
     System.Console.WriteLine("Sum of numbers = {0}", sum)
     
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     let message = match numbers with
                     | [] -> "List is empty!"
                     | [one] -> 
                         "List has one item
                     | [one; two] ->
                         "List has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | _ -> "List has more than two items"
     System.Console.WriteLine("We got {0}", message)
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     System.Console.WriteLine("We got {0}", message)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="147" endline="159"><![CDATA[
     
 [<Example("Array pattern matching example")>]
 let array_pat_example() =
     let numbers = [|1; 2; 3; 4; 5|]
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     let message = match numbers with
                     | [| |] -> "Array is empty!"
                     | [| one |] ->
                         "Array has one item
                     | [| one; two |] ->
                         "Array has two items
                         one.ToString() + " " + two.ToString()
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | _ -> "Array has more than two items"
     System.Console.WriteLine("We got {0}", message)
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     System.Console.WriteLine("We got {0}", message)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="160" endline="169"><![CDATA[
 
 [<Example("As-pattern pattern maching example")>]    
 let as_pat_example() =
     let t1 = (1, 2)
     let message = match t1 with
                     | (x,y) as t2 ->
                         x.ToString() + " " +
                         y.ToString() + " " +
                         t2.ToString()
     System.Console.WriteLine("We got {0}", message)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="170" endline="230"><![CDATA[
 
 (*    
 let pat_example90() =
     let rec buildMessage (l 
         match l with
             | [(n 
                 System.String.Format("Greetings {0}", n) + buildMessage t
             | [(a 
                 System.String.Format("You're {0}", a) + buildMessage t
             | _ -> "."
     let message = buildMessage ["Fred"; 38]
     System.Console.WriteLine(message)
 *)    
 
 [<Example("When pattern matching example")>]
 let when_pat_example() =
     let p = new Person("Rick", "Minerich", 35)
     let message = match (p.FirstName) with
                     | _ when p.Age > 30 ->
                         "Never found"
                     | "Minerich" when p.FirstName <> "Rick" ->
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                         "Also never found"
                     | "Minerich" ->
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                         "Hiya, Rick!"
                     | _ ->
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                         "Who are you?"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     System.Console.WriteLine("We got {0}", message)
     
     let isOldFogey (person 
         match person with
         | _ when person.Age > 35 || 
             (person.FirstName = "Ted" && 
                 person.LastName = "Neward") ||
             (person.FirstName = "Aaron" && 
                 person.LastName = "Erickson") ->
             true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
             
     let isOldFogey' (person 
         let isOld (p 
             p.Age > 35
         let isTed (p 
             p.FirstName = "Ted" && p.LastName = "Neward"
         let isAaron (p 
             p.FirstName = "Aaron" && p.LastName = "Erickson"
         match p with
             | _ when isOld p || isTed p || isAaron p -> 
                 true
             | _ -> 
                 false
     System.Console.WriteLine("{0} is an old fogey
         p, isOldFogey' p)
         
     let isOldFogey'' (p 
         match p.Age, p.FirstName, p.LastName with
         | _, "Ted", "Neward" -> true
         | _, "Aaron", "Erickson" -> true
         | a, _, _ when a > 35 -> true
         | _ -> false
     System.Console.WriteLine("{0} is an old fogey
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="231" endline="253"><![CDATA[
         p, isOldFogey'' p)
     
 open System.IO
 
 [<Example("Active pattern matching example")>]
 let active_simple_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
     let contains (srchStr 
         inStr.Contains srchStr
     let goodInput inStr =
         contains "<script>" inStr ||
         contains "<object>" inStr ||
         contains "<embed>" inStr ||
         contains "<applet>" inStr
     System.Console.WriteLine("Does the text contain bad data? " +
         (goodInput inputData).ToString())
         
     let (|Contains|) srchStr (inStr 
         inStr.Contains srchStr
     match inputData with
     | Contains "<script>" true -> false
     | Contains "<object>" true -> false
     | Contains "<embed>" true -> false
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="254" endline="273"><![CDATA[
     | Contains "<applet>" true -> false
     | _ -> true
 
 [<Example("Partial-case active pattern example")>]
 let active_partial_pat_example() =
     let inputData = "This is some <script>alert()</script> data"
 
     let (|Contains|_|) pat inStr =
         let results = 
             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
         if results.Count > 0 
             then Some [ for m in results -> m.Value ] 
             else None
 
     match inputData with
     | Contains "http
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     | Contains "\<script\>" _ -> "Found <script>"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     | Contains "\<object\>" _ -> "Found <object>"
     | _ -> "Didn't find what we were looking for"
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="274" endline="298"><![CDATA[
 
 open System.Reflection
 [<Example("Partial-case Reflection active pattern example")>]
 let active_reflect_pat_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (t 
         let fi = t.GetField(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Method|_|) name (t 
         let fi = t.GetMethod(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let (|Property|_|) name (t 
         let fi = t.GetProperty(name, AllBindingFlags) 
         if fi <> null then Some(fi) else None
     let pt = typeof<Person>
     let message = 
         match pt with
         | Property "FirstName" pi -> 
             "Found property " + pi.ToString()
         | Property "LastName" pi -> 
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
             "Found property " + pi.ToString()
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
         | _ -> "There's other stuff, but who cares?"
     System.Console.WriteLine(message)
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     System.Console.WriteLine(message)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="299" endline="342"><![CDATA[
 
 [<Example("Partial-case Reflection duck typing active pattern")>]
 let activepat_ducktyping_example() =
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     let (|Field|_|) name (inst 
         let fi = inst.GetType().GetField(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst)) 
         else None
     let (|Method|_|) name (inst 
         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
         if fi <> null 
         then Some(fi) 
         else None
     let (|Property|_|) name (inst 
         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
         if fi <> null 
         then Some(fi.GetValue(inst, null)) 
         else None
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name? Get the value if it does
     let message = match rm with
                     | Property "FirstName" value ->
                         "FirstName = " + value.ToString()
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                     | _ -> "No FirstName to be found"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     System.Console.WriteLine(message)
 
     let rm = new Person("Rick", "Minerich", 29)
     // Does it have a first name AND a last name?
     let message = match rm with
                     | Property "FirstName" fnval &
                       Property "LastName" lnval ->
                         "Full name = " + fnval.ToString() +
                         " " + lnval.ToString()
                     | Property "FirstName" value ->
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                         "Name = " + value.ToString()
                     | Property "LastName" value ->
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                         "Name = " + value.ToString()
                     | _ -> 
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
                         "No name to be found"
     System.Console.WriteLine(message)
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     System.Console.WriteLine(message)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="343" endline="364"><![CDATA[
 
 [<Example("Multi-case active pattern example")>]
 let active_pat_multicase_example() =
     let (|Property|Method|Field|Constructor|) (mi 
         if (mi 
             Field(mi.Name, (mi 
         elif (mi 
             let mthi = (mi 
             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
         elif (mi 
             let pi = (mi 
             Property(pi.Name, pi.PropertyType)
         elif (mi 
             let ci = (mi 
             Constructor(ci.GetParameters())
         else
             failwith "Unrecognized Reflection type"
     let pt = typeof<Person>
     let AllBindingFlags = 
         BindingFlags.NonPublic ||| BindingFlags.Public |||
         BindingFlags.Instance ||| BindingFlags.Static
     for p in pt.GetMembers(AllBindingFlags) do
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
     for p in pt.GetMembers(AllBindingFlags) do
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="365" endline="388"><![CDATA[
         match p with
         | Property(nm, ty) -> 
             System.Console.WriteLine(
                 "Found prop {1} {0}", nm, ty)
         | Field(nm, ty) ->
             System.Console.WriteLine(
                 "Found fld {1} {0}", nm, ty)
         | Method(nm, rt, parms) ->
             System.Console.WriteLine(
                 "Found mth {1} {0}(...)", nm, rt)
         | Constructor(parms) ->
             System.Console.WriteLine("Found ctor")
 
 let active_pat_example() =
     let (|FileFullName|) (f
     let (|FileName|) (f
     let (|FileExt|) (f
     let (|FileTuple|) (f
     let cmd = new FileInfo(@"C
     match cmd with
 //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
         "Found " + fn.ToString()
     | _ -> "No idea"
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs" startline="110" endline="110"><![CDATA[
 let rachel = "Rachel"
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="11" endline="14"><![CDATA[
     let nothing 
     let something 
     System.Console.WriteLine("nothing = {0}", nothing)
     System.Console.WriteLine("something = {0}", something.Value)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="15" endline="21"><![CDATA[
     
 [<Example("Options 2")>]
 let option_examples_2() =
     let nothing 
     let something 
     System.Console.WriteLine("nothing = {0}", nothing)
     System.Console.WriteLine("something = {0}", something.Value)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="22" endline="367"><![CDATA[
 
 [<Example("Options 3")>]
 let option_examples_3() =
     let possibleValue =
         if (System.DateTime.Now.Millisecond % 2) = 0 then
             None
         else
             Some("Have a happy day!")
     if possibleValue.IsSome then
         System.Console.WriteLine("Ah, we got a good value. Good!")
         System.Console.WriteLine(possibleValue.Value)
 
 [<Example("Options 4")>]
 let option_examples_4() =
     // This will deliberately throw an exception
     //
     let nothing 
     if nothing.Equals(None) then
         System.Console.WriteLine("None.Equals(None)")
     System.Console.WriteLine(nothing.GetHashCode())
     System.Console.WriteLine(nothing.ToString())
 
 [<Example("Options 5")>]
 let option_examples_5() =
     let possibleValue =
         if (System.DateTime.Now.Millisecond % 2) = 0 then
             None
         else
             Some("Have a happy day!")
     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
                 possibleValue
                 
 
 // ======= Tuples ==========
 [<Example("Tuples 1")>]
 let tuple_examples_1() =
     let myName 
     let myDescription 
     System.Console.WriteLine("Hello, {0}", myName)
 
 [<Example("Tuples 2")>]
 let tuple_examples_2() =
     let myName = ("Ted", "Neward")
     let herName = ("Sarah", "Michelle", "Gellar")
     let cityState = ("Phoenix", "AZ")
     System.Console.WriteLine("myName = herName? {0}", 
         myName.GetType().Equals(herName.GetType()))
     System.Console.WriteLine("myName = cityState? {0}", 
         myName.GetType().Equals(cityState.GetType()))
         
 [<Example("Tuples 3")>]
 let tuple_examples_3() =
     let me = ("Ted", "Neward")
     let firstName = fst me
     let lastName = snd me
     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
 
 [<Example("Tuples 4")>]
 let tuple_examples_4() =    
     let me = ("Ted", "Neward", 38, "Redmond", "WA")
     let (firstName, lastName, age, city, state) = me
     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
     
 [<Example("Tuples 5")>]
 let tuple_examples_5() =    
     let me = ("Ted", "Neward", 38, "Redmond", "WA")
     let (firstName, _, _, city, _) = me
     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
 
 [<Example("Tuples 'for' examples")>]
 let tuple_examples_6() =
     let people = [|
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
     |]
     for (firstName, _, age, _, _) in people do
         System.Console.WriteLine("{0} is {1}", firstName, age)
     
 
 // ========= Arrays ==========
 [<Example("Array initialization examples")>]
 let array_examples_1() =
     let emptyArray = [| |]
     let arrayOfIntegers = [| 1; 2; 3; 4; |]
     let arrayOfStrings = [|
         "Fred"
         "Wilma"
         "Barney"
         "Betty"
     |]
     let arrayOfZeroes = Array.create 10 0
     let arrayOfTeds = Array.create 10 "Ted"
     let rangeOfIntegers = [| 1 .. 10 |]
     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
     let mutableArray = Array.create 10 0
     for i = 0 to 9 do
         mutableArray.[i] <- i*i
     let (arrayOfObjects 
     ()
     
 [<Example("Array access examples")>]
 let array_examples_2() =
     let people = [|
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
     |]
     let thirdPerson = people.[2]
     // Happy Birthday, Mark!
     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
     ()
     
 [<Example("Array iteration examples")>]
 let array_examples_3() =
     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
     for i = 0 to array.Length - 1 do
         System.Console.WriteLine(array.[i])
     for p in array do
         System.Console.WriteLine(p)
     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
     ()
 
 [<Example("Array operation examples")>]
 let array_examples_4() =
     let people = [|
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Ken", "Siple", 43)
         new Person("Naomi", "Wilson", 38)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
     |]
     let newardsFound = 
         Array.find (fun (it 
     System.Console.WriteLine(newardsFound)
     let drinkers =
         Array.filter (fun (it 
     Array.iter (fun (it 
         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
         drinkers
     people
         |> Array.filter (fun (it 
         |> Array.iter (fun (it 
             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
     let isADrinker (ar 
         Array.filter (fun (p 
     let haveABeer (ar 
         Array.iter (fun (p 
     people |> isADrinker |> haveABeer
 
 // ========= Lists ==========
 [<Example("List examples 1")>]
 let list_examples_1() =
     let emptyList = []
     let listOfIntegers = [ 1; 2; 3; 4; ]
     let listOfStrings = [
         "Fred"      // Flintstone
         "Wilma"     // Flintstone
         "Barney"    // Rubble
         "Betty"     // Rubble
         ]
     let listOfPeopleTuples = [
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
         ]
     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
         // [ 0; 2; 4; ... 10; ]
     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
     let consedList = 1 
 //    let mutable forBuiltList = []
 //    for i = 1 to 10 do
 //        forBuiltList <- (i * i) 
     let forBuiltList = [ for i in 1 .. 10 -> i * i]
     let concattedList = listOfIntegers @ consedList
         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
     listOfStrings
 
 [<Example("List examples 2")>]
 let list_examples_2() =
     //let notWorkingList = [ 1; "2"; 3.0; ]
     let (objectList 
         (1 
         ("2" 
         (3.0 
     ]
     objectList
 
 [<Example("List access examples")>]
 let list_examples_3() =
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     let peopleHead = people.Head
     System.Console.WriteLine(peopleHead)
     let firstPerson = List.head people
     System.Console.WriteLine(firstPerson)
     let (personOne 
     System.Console.WriteLine(personOne)
     let secondPerson = people.[1]
     System.Console.WriteLine(secondPerson)
     let otherSecondPerson = List.nth people 1
     let noSuchPerson = List.nth people 5
     System.Console.WriteLine("Expecting an exception above")
 
 // ============== Sequences
 [<Example("Sequence initializers")>]
 let seq_examples_1() =
     let threeNums = seq {0 .. 2}
     let lotsOfNums = seq {0 .. 100000000}
     let people = [
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Ken", "Sipe", 43)
     ]
     let seqPeople = Seq.ofList people
     let newards = Seq.filter (fun (it 
     Seq.iter (fun (it 
     let x = seq { for i = 1 to 10 do yield i }
     System.Console.WriteLine(x)
     let y = seq { for i = 1 to 10 do
                     System.Console.WriteLine("Generating {0}", i)
                     yield i }
     let yEnum = y.GetEnumerator()
     if yEnum.MoveNext() then
         System.Console.WriteLine(yEnum.Current)
     let randomNumberGenerator minVal maxVal =
         let randomer = new System.Random(System.DateTime.Now.Millisecond)
         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
     Seq.iter (fun (roll 
 
     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
     System.Console.WriteLine(squares)
 
 [<Example("Sequence directory operations")>]
 let seq_examples2() =
     let dir d = 
         let di = new System.IO.DirectoryInfo(d)
         seq { for fi in di.GetFileSystemInfos() -> fi }
     let printFileInfo (fi 
         System.Console.WriteLine("{0}", fi.FullName)
     let rootFiles = dir "C
     for fi in rootFiles do printFileInfo fi
     
     (* Uncomment this if you really want to iterate the
        entire contents of your hard drive 
     (*
     let rec recursiveDir d =
         let di = new System.IO.DirectoryInfo(d)
         seq {
             for f in di.GetFiles() do yield f
             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
         }
     let allFiles = recursiveDir @"C
     for fi in allFiles do printFileInfo fi
     *)
     ()
 
 // ============== Maps
 [<Example("Map creation example")>]
 let map_creation_example() =
     let nicknames = Map.ofList [ 
                         "Ted", new Person("Ted", "Neward", 38);
                         "Katie", new Person("Katie", "Ellison", 30);
                         "Michael", new Person("Michael", "Neward", 16) 
                     ]
     let moreNicknames = 
         nicknames.Add("Mark", new Person("William", "Richards", 45))
     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
     let nicknames = 
         dict [ 
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     ()
 
 [<Example("Map access example")>]
 let map_access_example() =
     let nicknames = 
         Map.ofList [
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     let ted = nicknames.["Ted"]
     System.Console.WriteLine(ted)
     let ted = Map.find "Ted" nicknames
     System.Console.WriteLine(ted)
 
     try
         let noone = nicknames.["Katie"]
         System.Console.WriteLine(noone)
     with 
     | ex -> System.Console.WriteLine("Katie not found")
     
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
             Some("Have a happy day!")
     if possibleValue.IsSome then
         System.Console.WriteLine("Ah, we got a good value. Good!")
         System.Console.WriteLine(possibleValue.Value)
 
 [<Example("Options 4")>]
 let option_examples_4() =
     // This will deliberately throw an exception
     //
     let nothing 
     if nothing.Equals(None) then
         System.Console.WriteLine("None.Equals(None)")
     System.Console.WriteLine(nothing.GetHashCode())
     System.Console.WriteLine(nothing.ToString())
 
 [<Example("Options 5")>]
 let option_examples_5() =
     let possibleValue =
         if (System.DateTime.Now.Millisecond % 2) = 0 then
             None
         else
             Some("Have a happy day!")
     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
                 possibleValue
                 
 
 // ======= Tuples ==========
 [<Example("Tuples 1")>]
 let tuple_examples_1() =
     let myName 
     let myDescription 
     System.Console.WriteLine("Hello, {0}", myName)
 
 [<Example("Tuples 2")>]
 let tuple_examples_2() =
     let myName = ("Ted", "Neward")
     let herName = ("Sarah", "Michelle", "Gellar")
     let cityState = ("Phoenix", "AZ")
     System.Console.WriteLine("myName = herName? {0}", 
         myName.GetType().Equals(herName.GetType()))
     System.Console.WriteLine("myName = cityState? {0}", 
         myName.GetType().Equals(cityState.GetType()))
         
 [<Example("Tuples 3")>]
 let tuple_examples_3() =
     let me = ("Ted", "Neward")
     let firstName = fst me
     let lastName = snd me
     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
 
 [<Example("Tuples 4")>]
 let tuple_examples_4() =    
     let me = ("Ted", "Neward", 38, "Redmond", "WA")
     let (firstName, lastName, age, city, state) = me
     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
     
 [<Example("Tuples 5")>]
 let tuple_examples_5() =    
     let me = ("Ted", "Neward", 38, "Redmond", "WA")
     let (firstName, _, _, city, _) = me
     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
 
 [<Example("Tuples 'for' examples")>]
 let tuple_examples_6() =
     let people = [|
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
     |]
     for (firstName, _, age, _, _) in people do
         System.Console.WriteLine("{0} is {1}", firstName, age)
     
 
 // ========= Arrays ==========
 [<Example("Array initialization examples")>]
 let array_examples_1() =
     let emptyArray = [| |]
     let arrayOfIntegers = [| 1; 2; 3; 4; |]
     let arrayOfStrings = [|
         "Fred"
         "Wilma"
         "Barney"
         "Betty"
     |]
     let arrayOfZeroes = Array.create 10 0
     let arrayOfTeds = Array.create 10 "Ted"
     let rangeOfIntegers = [| 1 .. 10 |]
     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
     let mutableArray = Array.create 10 0
     for i = 0 to 9 do
         mutableArray.[i] <- i*i
     let (arrayOfObjects 
     ()
     
 [<Example("Array access examples")>]
 let array_examples_2() =
     let people = [|
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
     |]
     let thirdPerson = people.[2]
     // Happy Birthday, Mark!
     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
     ()
     
 [<Example("Array iteration examples")>]
 let array_examples_3() =
     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
     for i = 0 to array.Length - 1 do
         System.Console.WriteLine(array.[i])
     for p in array do
         System.Console.WriteLine(p)
     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
     ()
 
 [<Example("Array operation examples")>]
 let array_examples_4() =
     let people = [|
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Ken", "Siple", 43)
         new Person("Naomi", "Wilson", 38)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
     |]
     let newardsFound = 
         Array.find (fun (it 
     System.Console.WriteLine(newardsFound)
     let drinkers =
         Array.filter (fun (it 
     Array.iter (fun (it 
         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
         drinkers
     people
         |> Array.filter (fun (it 
         |> Array.iter (fun (it 
             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
     let isADrinker (ar 
         Array.filter (fun (p 
     let haveABeer (ar 
         Array.iter (fun (p 
     people |> isADrinker |> haveABeer
 
 // ========= Lists ==========
 [<Example("List examples 1")>]
 let list_examples_1() =
     let emptyList = []
     let listOfIntegers = [ 1; 2; 3; 4; ]
     let listOfStrings = [
         "Fred"      // Flintstone
         "Wilma"     // Flintstone
         "Barney"    // Rubble
         "Betty"     // Rubble
         ]
     let listOfPeopleTuples = [
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
         ]
     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
         // [ 0; 2; 4; ... 10; ]
     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
     let consedList = 1 
 //    let mutable forBuiltList = []
 //    for i = 1 to 10 do
 //        forBuiltList <- (i * i) 
     let forBuiltList = [ for i in 1 .. 10 -> i * i]
     let concattedList = listOfIntegers @ consedList
         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
     listOfStrings
 
 [<Example("List examples 2")>]
 let list_examples_2() =
     //let notWorkingList = [ 1; "2"; 3.0; ]
     let (objectList 
         (1 
         ("2" 
         (3.0 
     ]
     objectList
 
 [<Example("List access examples")>]
 let list_examples_3() =
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     let peopleHead = people.Head
     System.Console.WriteLine(peopleHead)
     let firstPerson = List.head people
     System.Console.WriteLine(firstPerson)
     let (personOne 
     System.Console.WriteLine(personOne)
     let secondPerson = people.[1]
     System.Console.WriteLine(secondPerson)
     let otherSecondPerson = List.nth people 1
     let noSuchPerson = List.nth people 5
     System.Console.WriteLine("Expecting an exception above")
 
 // ============== Sequences
 [<Example("Sequence initializers")>]
 let seq_examples_1() =
     let threeNums = seq {0 .. 2}
     let lotsOfNums = seq {0 .. 100000000}
     let people = [
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Ken", "Sipe", 43)
     ]
     let seqPeople = Seq.ofList people
     let newards = Seq.filter (fun (it 
     Seq.iter (fun (it 
     let x = seq { for i = 1 to 10 do yield i }
     System.Console.WriteLine(x)
     let y = seq { for i = 1 to 10 do
                     System.Console.WriteLine("Generating {0}", i)
                     yield i }
     let yEnum = y.GetEnumerator()
     if yEnum.MoveNext() then
         System.Console.WriteLine(yEnum.Current)
     let randomNumberGenerator minVal maxVal =
         let randomer = new System.Random(System.DateTime.Now.Millisecond)
         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
     Seq.iter (fun (roll 
 
     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
     System.Console.WriteLine(squares)
 
 [<Example("Sequence directory operations")>]
 let seq_examples2() =
     let dir d = 
         let di = new System.IO.DirectoryInfo(d)
         seq { for fi in di.GetFileSystemInfos() -> fi }
     let printFileInfo (fi 
         System.Console.WriteLine("{0}", fi.FullName)
     let rootFiles = dir "C
     for fi in rootFiles do printFileInfo fi
     
     (* Uncomment this if you really want to iterate the
        entire contents of your hard drive 
     (*
     let rec recursiveDir d =
         let di = new System.IO.DirectoryInfo(d)
         seq {
             for f in di.GetFiles() do yield f
             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
         }
     let allFiles = recursiveDir @"C
     for fi in allFiles do printFileInfo fi
     *)
     ()
 
 // ============== Maps
 [<Example("Map creation example")>]
 let map_creation_example() =
     let nicknames = Map.ofList [ 
                         "Ted", new Person("Ted", "Neward", 38);
                         "Katie", new Person("Katie", "Ellison", 30);
                         "Michael", new Person("Michael", "Neward", 16) 
                     ]
     let moreNicknames = 
         nicknames.Add("Mark", new Person("William", "Richards", 45))
     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
     let nicknames = 
         dict [ 
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     ()
 
 [<Example("Map access example")>]
 let map_access_example() =
     let nicknames = 
         Map.ofList [
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     let ted = nicknames.["Ted"]
     System.Console.WriteLine(ted)
     let ted = Map.find "Ted" nicknames
     System.Console.WriteLine(ted)
 
     try
         let noone = nicknames.["Katie"]
         System.Console.WriteLine(noone)
     with 
     | ex -> System.Console.WriteLine("Katie not found")
     
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
     if possibleValue.IsSome then
         System.Console.WriteLine("Ah, we got a good value. Good!")
         System.Console.WriteLine(possibleValue.Value)
 
 [<Example("Options 4")>]
 let option_examples_4() =
     // This will deliberately throw an exception
     //
     let nothing 
     if nothing.Equals(None) then
         System.Console.WriteLine("None.Equals(None)")
     System.Console.WriteLine(nothing.GetHashCode())
     System.Console.WriteLine(nothing.ToString())
 
 [<Example("Options 5")>]
 let option_examples_5() =
     let possibleValue =
         if (System.DateTime.Now.Millisecond % 2) = 0 then
             None
         else
             Some("Have a happy day!")
     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
                 possibleValue
                 
 
 // ======= Tuples ==========
 [<Example("Tuples 1")>]
 let tuple_examples_1() =
     let myName 
     let myDescription 
     System.Console.WriteLine("Hello, {0}", myName)
 
 [<Example("Tuples 2")>]
 let tuple_examples_2() =
     let myName = ("Ted", "Neward")
     let herName = ("Sarah", "Michelle", "Gellar")
     let cityState = ("Phoenix", "AZ")
     System.Console.WriteLine("myName = herName? {0}", 
         myName.GetType().Equals(herName.GetType()))
     System.Console.WriteLine("myName = cityState? {0}", 
         myName.GetType().Equals(cityState.GetType()))
         
 [<Example("Tuples 3")>]
 let tuple_examples_3() =
     let me = ("Ted", "Neward")
     let firstName = fst me
     let lastName = snd me
     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
 
 [<Example("Tuples 4")>]
 let tuple_examples_4() =    
     let me = ("Ted", "Neward", 38, "Redmond", "WA")
     let (firstName, lastName, age, city, state) = me
     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
     
 [<Example("Tuples 5")>]
 let tuple_examples_5() =    
     let me = ("Ted", "Neward", 38, "Redmond", "WA")
     let (firstName, _, _, city, _) = me
     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
 
 [<Example("Tuples 'for' examples")>]
 let tuple_examples_6() =
     let people = [|
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
     |]
     for (firstName, _, age, _, _) in people do
         System.Console.WriteLine("{0} is {1}", firstName, age)
     
 
 // ========= Arrays ==========
 [<Example("Array initialization examples")>]
 let array_examples_1() =
     let emptyArray = [| |]
     let arrayOfIntegers = [| 1; 2; 3; 4; |]
     let arrayOfStrings = [|
         "Fred"
         "Wilma"
         "Barney"
         "Betty"
     |]
     let arrayOfZeroes = Array.create 10 0
     let arrayOfTeds = Array.create 10 "Ted"
     let rangeOfIntegers = [| 1 .. 10 |]
     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
     let mutableArray = Array.create 10 0
     for i = 0 to 9 do
         mutableArray.[i] <- i*i
     let (arrayOfObjects 
     ()
     
 [<Example("Array access examples")>]
 let array_examples_2() =
     let people = [|
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
     |]
     let thirdPerson = people.[2]
     // Happy Birthday, Mark!
     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
     ()
     
 [<Example("Array iteration examples")>]
 let array_examples_3() =
     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
     for i = 0 to array.Length - 1 do
         System.Console.WriteLine(array.[i])
     for p in array do
         System.Console.WriteLine(p)
     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
     ()
 
 [<Example("Array operation examples")>]
 let array_examples_4() =
     let people = [|
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Ken", "Siple", 43)
         new Person("Naomi", "Wilson", 38)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
     |]
     let newardsFound = 
         Array.find (fun (it 
     System.Console.WriteLine(newardsFound)
     let drinkers =
         Array.filter (fun (it 
     Array.iter (fun (it 
         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
         drinkers
     people
         |> Array.filter (fun (it 
         |> Array.iter (fun (it 
             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
     let isADrinker (ar 
         Array.filter (fun (p 
     let haveABeer (ar 
         Array.iter (fun (p 
     people |> isADrinker |> haveABeer
 
 // ========= Lists ==========
 [<Example("List examples 1")>]
 let list_examples_1() =
     let emptyList = []
     let listOfIntegers = [ 1; 2; 3; 4; ]
     let listOfStrings = [
         "Fred"      // Flintstone
         "Wilma"     // Flintstone
         "Barney"    // Rubble
         "Betty"     // Rubble
         ]
     let listOfPeopleTuples = [
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
         ]
     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
         // [ 0; 2; 4; ... 10; ]
     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
     let consedList = 1 
 //    let mutable forBuiltList = []
 //    for i = 1 to 10 do
 //        forBuiltList <- (i * i) 
     let forBuiltList = [ for i in 1 .. 10 -> i * i]
     let concattedList = listOfIntegers @ consedList
         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
     listOfStrings
 
 [<Example("List examples 2")>]
 let list_examples_2() =
     //let notWorkingList = [ 1; "2"; 3.0; ]
     let (objectList 
         (1 
         ("2" 
         (3.0 
     ]
     objectList
 
 [<Example("List access examples")>]
 let list_examples_3() =
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     let peopleHead = people.Head
     System.Console.WriteLine(peopleHead)
     let firstPerson = List.head people
     System.Console.WriteLine(firstPerson)
     let (personOne 
     System.Console.WriteLine(personOne)
     let secondPerson = people.[1]
     System.Console.WriteLine(secondPerson)
     let otherSecondPerson = List.nth people 1
     let noSuchPerson = List.nth people 5
     System.Console.WriteLine("Expecting an exception above")
 
 // ============== Sequences
 [<Example("Sequence initializers")>]
 let seq_examples_1() =
     let threeNums = seq {0 .. 2}
     let lotsOfNums = seq {0 .. 100000000}
     let people = [
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Ken", "Sipe", 43)
     ]
     let seqPeople = Seq.ofList people
     let newards = Seq.filter (fun (it 
     Seq.iter (fun (it 
     let x = seq { for i = 1 to 10 do yield i }
     System.Console.WriteLine(x)
     let y = seq { for i = 1 to 10 do
                     System.Console.WriteLine("Generating {0}", i)
                     yield i }
     let yEnum = y.GetEnumerator()
     if yEnum.MoveNext() then
         System.Console.WriteLine(yEnum.Current)
     let randomNumberGenerator minVal maxVal =
         let randomer = new System.Random(System.DateTime.Now.Millisecond)
         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
     Seq.iter (fun (roll 
 
     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
     System.Console.WriteLine(squares)
 
 [<Example("Sequence directory operations")>]
 let seq_examples2() =
     let dir d = 
         let di = new System.IO.DirectoryInfo(d)
         seq { for fi in di.GetFileSystemInfos() -> fi }
     let printFileInfo (fi 
         System.Console.WriteLine("{0}", fi.FullName)
     let rootFiles = dir "C
     for fi in rootFiles do printFileInfo fi
     
     (* Uncomment this if you really want to iterate the
        entire contents of your hard drive 
     (*
     let rec recursiveDir d =
         let di = new System.IO.DirectoryInfo(d)
         seq {
             for f in di.GetFiles() do yield f
             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
         }
     let allFiles = recursiveDir @"C
     for fi in allFiles do printFileInfo fi
     *)
     ()
 
 // ============== Maps
 [<Example("Map creation example")>]
 let map_creation_example() =
     let nicknames = Map.ofList [ 
                         "Ted", new Person("Ted", "Neward", 38);
                         "Katie", new Person("Katie", "Ellison", 30);
                         "Michael", new Person("Michael", "Neward", 16) 
                     ]
     let moreNicknames = 
         nicknames.Add("Mark", new Person("William", "Richards", 45))
     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
     let nicknames = 
         dict [ 
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     ()
 
 [<Example("Map access example")>]
 let map_access_example() =
     let nicknames = 
         Map.ofList [
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     let ted = nicknames.["Ted"]
     System.Console.WriteLine(ted)
     let ted = Map.find "Ted" nicknames
     System.Console.WriteLine(ted)
 
     try
         let noone = nicknames.["Katie"]
         System.Console.WriteLine(noone)
     with 
     | ex -> System.Console.WriteLine("Katie not found")
     
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="38" endline="42"><![CDATA[
     let nothing 
     if nothing.Equals(None) then
         System.Console.WriteLine("None.Equals(None)")
     System.Console.WriteLine(nothing.GetHashCode())
     System.Console.WriteLine(nothing.ToString())
 
 [<Example("Options 5")>]
 let option_examples_5() =
     let possibleValue =
         if (System.DateTime.Now.Millisecond % 2) = 0 then
             None
         else
             Some("Have a happy day!")
     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
                 possibleValue
                 
 
 // ======= Tuples ==========
 [<Example("Tuples 1")>]
 let tuple_examples_1() =
     let myName 
     let myDescription 
     System.Console.WriteLine("Hello, {0}", myName)
 
 [<Example("Tuples 2")>]
 let tuple_examples_2() =
     let myName = ("Ted", "Neward")
     let herName = ("Sarah", "Michelle", "Gellar")
     let cityState = ("Phoenix", "AZ")
     System.Console.WriteLine("myName = herName? {0}", 
         myName.GetType().Equals(herName.GetType()))
     System.Console.WriteLine("myName = cityState? {0}", 
         myName.GetType().Equals(cityState.GetType()))
         
 [<Example("Tuples 3")>]
 let tuple_examples_3() =
     let me = ("Ted", "Neward")
     let firstName = fst me
     let lastName = snd me
     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
 
 [<Example("Tuples 4")>]
 let tuple_examples_4() =    
     let me = ("Ted", "Neward", 38, "Redmond", "WA")
     let (firstName, lastName, age, city, state) = me
     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
     
 [<Example("Tuples 5")>]
 let tuple_examples_5() =    
     let me = ("Ted", "Neward", 38, "Redmond", "WA")
     let (firstName, _, _, city, _) = me
     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
 
 [<Example("Tuples 'for' examples")>]
 let tuple_examples_6() =
     let people = [|
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
     |]
     for (firstName, _, age, _, _) in people do
         System.Console.WriteLine("{0} is {1}", firstName, age)
     
 
 // ========= Arrays ==========
 [<Example("Array initialization examples")>]
 let array_examples_1() =
     let emptyArray = [| |]
     let arrayOfIntegers = [| 1; 2; 3; 4; |]
     let arrayOfStrings = [|
         "Fred"
         "Wilma"
         "Barney"
         "Betty"
     |]
     let arrayOfZeroes = Array.create 10 0
     let arrayOfTeds = Array.create 10 "Ted"
     let rangeOfIntegers = [| 1 .. 10 |]
     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
     let mutableArray = Array.create 10 0
     for i = 0 to 9 do
         mutableArray.[i] <- i*i
     let (arrayOfObjects 
     ()
     
 [<Example("Array access examples")>]
 let array_examples_2() =
     let people = [|
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
     |]
     let thirdPerson = people.[2]
     // Happy Birthday, Mark!
     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
     ()
     
 [<Example("Array iteration examples")>]
 let array_examples_3() =
     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
     for i = 0 to array.Length - 1 do
         System.Console.WriteLine(array.[i])
     for p in array do
         System.Console.WriteLine(p)
     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
     ()
 
 [<Example("Array operation examples")>]
 let array_examples_4() =
     let people = [|
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Ken", "Siple", 43)
         new Person("Naomi", "Wilson", 38)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
     |]
     let newardsFound = 
         Array.find (fun (it 
     System.Console.WriteLine(newardsFound)
     let drinkers =
         Array.filter (fun (it 
     Array.iter (fun (it 
         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
         drinkers
     people
         |> Array.filter (fun (it 
         |> Array.iter (fun (it 
             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
     let isADrinker (ar 
         Array.filter (fun (p 
     let haveABeer (ar 
         Array.iter (fun (p 
     people |> isADrinker |> haveABeer
 
 // ========= Lists ==========
 [<Example("List examples 1")>]
 let list_examples_1() =
     let emptyList = []
     let listOfIntegers = [ 1; 2; 3; 4; ]
     let listOfStrings = [
         "Fred"      // Flintstone
         "Wilma"     // Flintstone
         "Barney"    // Rubble
         "Betty"     // Rubble
         ]
     let listOfPeopleTuples = [
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
         ]
     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
         // [ 0; 2; 4; ... 10; ]
     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
     let consedList = 1 
 //    let mutable forBuiltList = []
 //    for i = 1 to 10 do
 //        forBuiltList <- (i * i) 
     let forBuiltList = [ for i in 1 .. 10 -> i * i]
     let concattedList = listOfIntegers @ consedList
         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
     listOfStrings
 
 [<Example("List examples 2")>]
 let list_examples_2() =
     //let notWorkingList = [ 1; "2"; 3.0; ]
     let (objectList 
         (1 
         ("2" 
         (3.0 
     ]
     objectList
 
 [<Example("List access examples")>]
 let list_examples_3() =
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     let peopleHead = people.Head
     System.Console.WriteLine(peopleHead)
     let firstPerson = List.head people
     System.Console.WriteLine(firstPerson)
     let (personOne 
     System.Console.WriteLine(personOne)
     let secondPerson = people.[1]
     System.Console.WriteLine(secondPerson)
     let otherSecondPerson = List.nth people 1
     let noSuchPerson = List.nth people 5
     System.Console.WriteLine("Expecting an exception above")
 
 // ============== Sequences
 [<Example("Sequence initializers")>]
 let seq_examples_1() =
     let threeNums = seq {0 .. 2}
     let lotsOfNums = seq {0 .. 100000000}
     let people = [
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Ken", "Sipe", 43)
     ]
     let seqPeople = Seq.ofList people
     let newards = Seq.filter (fun (it 
     Seq.iter (fun (it 
     let x = seq { for i = 1 to 10 do yield i }
     System.Console.WriteLine(x)
     let y = seq { for i = 1 to 10 do
                     System.Console.WriteLine("Generating {0}", i)
                     yield i }
     let yEnum = y.GetEnumerator()
     if yEnum.MoveNext() then
         System.Console.WriteLine(yEnum.Current)
     let randomNumberGenerator minVal maxVal =
         let randomer = new System.Random(System.DateTime.Now.Millisecond)
         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
     Seq.iter (fun (roll 
 
     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
     System.Console.WriteLine(squares)
 
 [<Example("Sequence directory operations")>]
 let seq_examples2() =
     let dir d = 
         let di = new System.IO.DirectoryInfo(d)
         seq { for fi in di.GetFileSystemInfos() -> fi }
     let printFileInfo (fi 
         System.Console.WriteLine("{0}", fi.FullName)
     let rootFiles = dir "C
     for fi in rootFiles do printFileInfo fi
     
     (* Uncomment this if you really want to iterate the
        entire contents of your hard drive 
     (*
     let rec recursiveDir d =
         let di = new System.IO.DirectoryInfo(d)
         seq {
             for f in di.GetFiles() do yield f
             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
         }
     let allFiles = recursiveDir @"C
     for fi in allFiles do printFileInfo fi
     *)
     ()
 
 // ============== Maps
 [<Example("Map creation example")>]
 let map_creation_example() =
     let nicknames = Map.ofList [ 
                         "Ted", new Person("Ted", "Neward", 38);
                         "Katie", new Person("Katie", "Ellison", 30);
                         "Michael", new Person("Michael", "Neward", 16) 
                     ]
     let moreNicknames = 
         nicknames.Add("Mark", new Person("William", "Richards", 45))
     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
     let nicknames = 
         dict [ 
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     ()
 
 [<Example("Map access example")>]
 let map_access_example() =
     let nicknames = 
         Map.ofList [
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     let ted = nicknames.["Ted"]
     System.Console.WriteLine(ted)
     let ted = Map.find "Ted" nicknames
     System.Console.WriteLine(ted)
 
     try
         let noone = nicknames.["Katie"]
         System.Console.WriteLine(noone)
     with 
     | ex -> System.Console.WriteLine("Katie not found")
     
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
     System.Console.WriteLine(nothing.GetHashCode())
     System.Console.WriteLine(nothing.ToString())
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="43" endline="51"><![CDATA[
 
 [<Example("Options 5")>]
 let option_examples_5() =
     let possibleValue =
         if (System.DateTime.Now.Millisecond % 2) = 0 then
             None
         else
             Some("Have a happy day!")
     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
                 possibleValue
                 
 
 // ======= Tuples ==========
 [<Example("Tuples 1")>]
 let tuple_examples_1() =
     let myName 
     let myDescription 
     System.Console.WriteLine("Hello, {0}", myName)
 
 [<Example("Tuples 2")>]
 let tuple_examples_2() =
     let myName = ("Ted", "Neward")
     let herName = ("Sarah", "Michelle", "Gellar")
     let cityState = ("Phoenix", "AZ")
     System.Console.WriteLine("myName = herName? {0}", 
         myName.GetType().Equals(herName.GetType()))
     System.Console.WriteLine("myName = cityState? {0}", 
         myName.GetType().Equals(cityState.GetType()))
         
 [<Example("Tuples 3")>]
 let tuple_examples_3() =
     let me = ("Ted", "Neward")
     let firstName = fst me
     let lastName = snd me
     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
 
 [<Example("Tuples 4")>]
 let tuple_examples_4() =    
     let me = ("Ted", "Neward", 38, "Redmond", "WA")
     let (firstName, lastName, age, city, state) = me
     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
     
 [<Example("Tuples 5")>]
 let tuple_examples_5() =    
     let me = ("Ted", "Neward", 38, "Redmond", "WA")
     let (firstName, _, _, city, _) = me
     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
 
 [<Example("Tuples 'for' examples")>]
 let tuple_examples_6() =
     let people = [|
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
     |]
     for (firstName, _, age, _, _) in people do
         System.Console.WriteLine("{0} is {1}", firstName, age)
     
 
 // ========= Arrays ==========
 [<Example("Array initialization examples")>]
 let array_examples_1() =
     let emptyArray = [| |]
     let arrayOfIntegers = [| 1; 2; 3; 4; |]
     let arrayOfStrings = [|
         "Fred"
         "Wilma"
         "Barney"
         "Betty"
     |]
     let arrayOfZeroes = Array.create 10 0
     let arrayOfTeds = Array.create 10 "Ted"
     let rangeOfIntegers = [| 1 .. 10 |]
     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
     let mutableArray = Array.create 10 0
     for i = 0 to 9 do
         mutableArray.[i] <- i*i
     let (arrayOfObjects 
     ()
     
 [<Example("Array access examples")>]
 let array_examples_2() =
     let people = [|
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
     |]
     let thirdPerson = people.[2]
     // Happy Birthday, Mark!
     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
     ()
     
 [<Example("Array iteration examples")>]
 let array_examples_3() =
     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
     for i = 0 to array.Length - 1 do
         System.Console.WriteLine(array.[i])
     for p in array do
         System.Console.WriteLine(p)
     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
     ()
 
 [<Example("Array operation examples")>]
 let array_examples_4() =
     let people = [|
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Ken", "Siple", 43)
         new Person("Naomi", "Wilson", 38)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
     |]
     let newardsFound = 
         Array.find (fun (it 
     System.Console.WriteLine(newardsFound)
     let drinkers =
         Array.filter (fun (it 
     Array.iter (fun (it 
         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
         drinkers
     people
         |> Array.filter (fun (it 
         |> Array.iter (fun (it 
             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
     let isADrinker (ar 
         Array.filter (fun (p 
     let haveABeer (ar 
         Array.iter (fun (p 
     people |> isADrinker |> haveABeer
 
 // ========= Lists ==========
 [<Example("List examples 1")>]
 let list_examples_1() =
     let emptyList = []
     let listOfIntegers = [ 1; 2; 3; 4; ]
     let listOfStrings = [
         "Fred"      // Flintstone
         "Wilma"     // Flintstone
         "Barney"    // Rubble
         "Betty"     // Rubble
         ]
     let listOfPeopleTuples = [
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
         ]
     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
         // [ 0; 2; 4; ... 10; ]
     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
     let consedList = 1 
 //    let mutable forBuiltList = []
 //    for i = 1 to 10 do
 //        forBuiltList <- (i * i) 
     let forBuiltList = [ for i in 1 .. 10 -> i * i]
     let concattedList = listOfIntegers @ consedList
         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
     listOfStrings
 
 [<Example("List examples 2")>]
 let list_examples_2() =
     //let notWorkingList = [ 1; "2"; 3.0; ]
     let (objectList 
         (1 
         ("2" 
         (3.0 
     ]
     objectList
 
 [<Example("List access examples")>]
 let list_examples_3() =
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     let peopleHead = people.Head
     System.Console.WriteLine(peopleHead)
     let firstPerson = List.head people
     System.Console.WriteLine(firstPerson)
     let (personOne 
     System.Console.WriteLine(personOne)
     let secondPerson = people.[1]
     System.Console.WriteLine(secondPerson)
     let otherSecondPerson = List.nth people 1
     let noSuchPerson = List.nth people 5
     System.Console.WriteLine("Expecting an exception above")
 
 // ============== Sequences
 [<Example("Sequence initializers")>]
 let seq_examples_1() =
     let threeNums = seq {0 .. 2}
     let lotsOfNums = seq {0 .. 100000000}
     let people = [
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Ken", "Sipe", 43)
     ]
     let seqPeople = Seq.ofList people
     let newards = Seq.filter (fun (it 
     Seq.iter (fun (it 
     let x = seq { for i = 1 to 10 do yield i }
     System.Console.WriteLine(x)
     let y = seq { for i = 1 to 10 do
                     System.Console.WriteLine("Generating {0}", i)
                     yield i }
     let yEnum = y.GetEnumerator()
     if yEnum.MoveNext() then
         System.Console.WriteLine(yEnum.Current)
     let randomNumberGenerator minVal maxVal =
         let randomer = new System.Random(System.DateTime.Now.Millisecond)
         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
     Seq.iter (fun (roll 
 
     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
     System.Console.WriteLine(squares)
 
 [<Example("Sequence directory operations")>]
 let seq_examples2() =
     let dir d = 
         let di = new System.IO.DirectoryInfo(d)
         seq { for fi in di.GetFileSystemInfos() -> fi }
     let printFileInfo (fi 
         System.Console.WriteLine("{0}", fi.FullName)
     let rootFiles = dir "C
     for fi in rootFiles do printFileInfo fi
     
     (* Uncomment this if you really want to iterate the
        entire contents of your hard drive 
     (*
     let rec recursiveDir d =
         let di = new System.IO.DirectoryInfo(d)
         seq {
             for f in di.GetFiles() do yield f
             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
         }
     let allFiles = recursiveDir @"C
     for fi in allFiles do printFileInfo fi
     *)
     ()
 
 // ============== Maps
 [<Example("Map creation example")>]
 let map_creation_example() =
     let nicknames = Map.ofList [ 
                         "Ted", new Person("Ted", "Neward", 38);
                         "Katie", new Person("Katie", "Ellison", 30);
                         "Michael", new Person("Michael", "Neward", 16) 
                     ]
     let moreNicknames = 
         nicknames.Add("Mark", new Person("William", "Richards", 45))
     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
     let nicknames = 
         dict [ 
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     ()
 
 [<Example("Map access example")>]
 let map_access_example() =
     let nicknames = 
         Map.ofList [
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     let ted = nicknames.["Ted"]
     System.Console.WriteLine(ted)
     let ted = Map.find "Ted" nicknames
     System.Console.WriteLine(ted)
 
     try
         let noone = nicknames.["Katie"]
         System.Console.WriteLine(noone)
     with 
     | ex -> System.Console.WriteLine("Katie not found")
     
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
             Some("Have a happy day!")
     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
                 possibleValue
                 
 
 // ======= Tuples ==========
 [<Example("Tuples 1")>]
 let tuple_examples_1() =
     let myName 
     let myDescription 
     System.Console.WriteLine("Hello, {0}", myName)
 
 [<Example("Tuples 2")>]
 let tuple_examples_2() =
     let myName = ("Ted", "Neward")
     let herName = ("Sarah", "Michelle", "Gellar")
     let cityState = ("Phoenix", "AZ")
     System.Console.WriteLine("myName = herName? {0}", 
         myName.GetType().Equals(herName.GetType()))
     System.Console.WriteLine("myName = cityState? {0}", 
         myName.GetType().Equals(cityState.GetType()))
         
 [<Example("Tuples 3")>]
 let tuple_examples_3() =
     let me = ("Ted", "Neward")
     let firstName = fst me
     let lastName = snd me
     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
 
 [<Example("Tuples 4")>]
 let tuple_examples_4() =    
     let me = ("Ted", "Neward", 38, "Redmond", "WA")
     let (firstName, lastName, age, city, state) = me
     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
     
 [<Example("Tuples 5")>]
 let tuple_examples_5() =    
     let me = ("Ted", "Neward", 38, "Redmond", "WA")
     let (firstName, _, _, city, _) = me
     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
 
 [<Example("Tuples 'for' examples")>]
 let tuple_examples_6() =
     let people = [|
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
     |]
     for (firstName, _, age, _, _) in people do
         System.Console.WriteLine("{0} is {1}", firstName, age)
     
 
 // ========= Arrays ==========
 [<Example("Array initialization examples")>]
 let array_examples_1() =
     let emptyArray = [| |]
     let arrayOfIntegers = [| 1; 2; 3; 4; |]
     let arrayOfStrings = [|
         "Fred"
         "Wilma"
         "Barney"
         "Betty"
     |]
     let arrayOfZeroes = Array.create 10 0
     let arrayOfTeds = Array.create 10 "Ted"
     let rangeOfIntegers = [| 1 .. 10 |]
     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
     let mutableArray = Array.create 10 0
     for i = 0 to 9 do
         mutableArray.[i] <- i*i
     let (arrayOfObjects 
     ()
     
 [<Example("Array access examples")>]
 let array_examples_2() =
     let people = [|
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
     |]
     let thirdPerson = people.[2]
     // Happy Birthday, Mark!
     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
     ()
     
 [<Example("Array iteration examples")>]
 let array_examples_3() =
     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
     for i = 0 to array.Length - 1 do
         System.Console.WriteLine(array.[i])
     for p in array do
         System.Console.WriteLine(p)
     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
     ()
 
 [<Example("Array operation examples")>]
 let array_examples_4() =
     let people = [|
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Ken", "Siple", 43)
         new Person("Naomi", "Wilson", 38)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
     |]
     let newardsFound = 
         Array.find (fun (it 
     System.Console.WriteLine(newardsFound)
     let drinkers =
         Array.filter (fun (it 
     Array.iter (fun (it 
         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
         drinkers
     people
         |> Array.filter (fun (it 
         |> Array.iter (fun (it 
             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
     let isADrinker (ar 
         Array.filter (fun (p 
     let haveABeer (ar 
         Array.iter (fun (p 
     people |> isADrinker |> haveABeer
 
 // ========= Lists ==========
 [<Example("List examples 1")>]
 let list_examples_1() =
     let emptyList = []
     let listOfIntegers = [ 1; 2; 3; 4; ]
     let listOfStrings = [
         "Fred"      // Flintstone
         "Wilma"     // Flintstone
         "Barney"    // Rubble
         "Betty"     // Rubble
         ]
     let listOfPeopleTuples = [
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
         ]
     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
         // [ 0; 2; 4; ... 10; ]
     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
     let consedList = 1 
 //    let mutable forBuiltList = []
 //    for i = 1 to 10 do
 //        forBuiltList <- (i * i) 
     let forBuiltList = [ for i in 1 .. 10 -> i * i]
     let concattedList = listOfIntegers @ consedList
         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
     listOfStrings
 
 [<Example("List examples 2")>]
 let list_examples_2() =
     //let notWorkingList = [ 1; "2"; 3.0; ]
     let (objectList 
         (1 
         ("2" 
         (3.0 
     ]
     objectList
 
 [<Example("List access examples")>]
 let list_examples_3() =
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     let peopleHead = people.Head
     System.Console.WriteLine(peopleHead)
     let firstPerson = List.head people
     System.Console.WriteLine(firstPerson)
     let (personOne 
     System.Console.WriteLine(personOne)
     let secondPerson = people.[1]
     System.Console.WriteLine(secondPerson)
     let otherSecondPerson = List.nth people 1
     let noSuchPerson = List.nth people 5
     System.Console.WriteLine("Expecting an exception above")
 
 // ============== Sequences
 [<Example("Sequence initializers")>]
 let seq_examples_1() =
     let threeNums = seq {0 .. 2}
     let lotsOfNums = seq {0 .. 100000000}
     let people = [
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Ken", "Sipe", 43)
     ]
     let seqPeople = Seq.ofList people
     let newards = Seq.filter (fun (it 
     Seq.iter (fun (it 
     let x = seq { for i = 1 to 10 do yield i }
     System.Console.WriteLine(x)
     let y = seq { for i = 1 to 10 do
                     System.Console.WriteLine("Generating {0}", i)
                     yield i }
     let yEnum = y.GetEnumerator()
     if yEnum.MoveNext() then
         System.Console.WriteLine(yEnum.Current)
     let randomNumberGenerator minVal maxVal =
         let randomer = new System.Random(System.DateTime.Now.Millisecond)
         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
     Seq.iter (fun (roll 
 
     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
     System.Console.WriteLine(squares)
 
 [<Example("Sequence directory operations")>]
 let seq_examples2() =
     let dir d = 
         let di = new System.IO.DirectoryInfo(d)
         seq { for fi in di.GetFileSystemInfos() -> fi }
     let printFileInfo (fi 
         System.Console.WriteLine("{0}", fi.FullName)
     let rootFiles = dir "C
     for fi in rootFiles do printFileInfo fi
     
     (* Uncomment this if you really want to iterate the
        entire contents of your hard drive 
     (*
     let rec recursiveDir d =
         let di = new System.IO.DirectoryInfo(d)
         seq {
             for f in di.GetFiles() do yield f
             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
         }
     let allFiles = recursiveDir @"C
     for fi in allFiles do printFileInfo fi
     *)
     ()
 
 // ============== Maps
 [<Example("Map creation example")>]
 let map_creation_example() =
     let nicknames = Map.ofList [ 
                         "Ted", new Person("Ted", "Neward", 38);
                         "Katie", new Person("Katie", "Ellison", 30);
                         "Michael", new Person("Michael", "Neward", 16) 
                     ]
     let moreNicknames = 
         nicknames.Add("Mark", new Person("William", "Richards", 45))
     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
     let nicknames = 
         dict [ 
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     ()
 
 [<Example("Map access example")>]
 let map_access_example() =
     let nicknames = 
         Map.ofList [
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     let ted = nicknames.["Ted"]
     System.Console.WriteLine(ted)
     let ted = Map.find "Ted" nicknames
     System.Console.WriteLine(ted)
 
     try
         let noone = nicknames.["Katie"]
         System.Console.WriteLine(noone)
     with 
     | ex -> System.Console.WriteLine("Katie not found")
     
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="52" endline="60"><![CDATA[
                 possibleValue
                 
 
 // ======= Tuples ==========
 [<Example("Tuples 1")>]
 let tuple_examples_1() =
     let myName 
     let myDescription 
     System.Console.WriteLine("Hello, {0}", myName)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="61" endline="69"><![CDATA[
 
 [<Example("Tuples 2")>]
 let tuple_examples_2() =
     let myName = ("Ted", "Neward")
     let herName = ("Sarah", "Michelle", "Gellar")
     let cityState = ("Phoenix", "AZ")
     System.Console.WriteLine("myName = herName? {0}", 
         myName.GetType().Equals(herName.GetType()))
     System.Console.WriteLine("myName = cityState? {0}", 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="70" endline="77"><![CDATA[
         myName.GetType().Equals(cityState.GetType()))
         
 [<Example("Tuples 3")>]
 let tuple_examples_3() =
     let me = ("Ted", "Neward")
     let firstName = fst me
     let lastName = snd me
     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="78" endline="83"><![CDATA[
 
 [<Example("Tuples 4")>]
 let tuple_examples_4() =    
     let me = ("Ted", "Neward", 38, "Redmond", "WA")
     let (firstName, lastName, age, city, state) = me
     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="84" endline="89"><![CDATA[
     
 [<Example("Tuples 5")>]
 let tuple_examples_5() =    
     let me = ("Ted", "Neward", 38, "Redmond", "WA")
     let (firstName, _, _, city, _) = me
     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="90" endline="101"><![CDATA[
 
 [<Example("Tuples 'for' examples")>]
 let tuple_examples_6() =
     let people = [|
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
     |]
     for (firstName, _, age, _, _) in people do
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="102" endline="126"><![CDATA[
         System.Console.WriteLine("{0} is {1}", firstName, age)
     
 
 // ========= Arrays ==========
 [<Example("Array initialization examples")>]
 let array_examples_1() =
     let emptyArray = [| |]
     let arrayOfIntegers = [| 1; 2; 3; 4; |]
     let arrayOfStrings = [|
         "Fred"
         "Wilma"
         "Barney"
         "Betty"
     |]
     let arrayOfZeroes = Array.create 10 0
     let arrayOfTeds = Array.create 10 "Ted"
     let rangeOfIntegers = [| 1 .. 10 |]
     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
     let mutableArray = Array.create 10 0
     for i = 0 to 9 do
         mutableArray.[i] <- i*i
     for i = 0 to 9 do
         mutableArray.[i] <- i*i
     let (arrayOfObjects 
     ()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="127" endline="141"><![CDATA[
     
 [<Example("Array access examples")>]
 let array_examples_2() =
     let people = [|
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
     |]
     let thirdPerson = people.[2]
     // Happy Birthday, Mark!
     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
     ()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="142" endline="151"><![CDATA[
     
 [<Example("Array iteration examples")>]
 let array_examples_3() =
     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
     for i = 0 to array.Length - 1 do
         System.Console.WriteLine(array.[i])
     for i = 0 to array.Length - 1 do
         System.Console.WriteLine(array.[i])
     for p in array do
         System.Console.WriteLine(p)
     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
     ()
 
 [<Example("Array operation examples")>]
 let array_examples_4() =
     let people = [|
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Ken", "Siple", 43)
         new Person("Naomi", "Wilson", 38)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
     |]
     let newardsFound = 
         Array.find (fun (it 
     System.Console.WriteLine(newardsFound)
     let drinkers =
         Array.filter (fun (it 
     Array.iter (fun (it 
         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
         drinkers
     people
         |> Array.filter (fun (it 
         |> Array.iter (fun (it 
             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
     let isADrinker (ar 
         Array.filter (fun (p 
     let haveABeer (ar 
         Array.iter (fun (p 
     people |> isADrinker |> haveABeer
 
 // ========= Lists ==========
 [<Example("List examples 1")>]
 let list_examples_1() =
     let emptyList = []
     let listOfIntegers = [ 1; 2; 3; 4; ]
     let listOfStrings = [
         "Fred"      // Flintstone
         "Wilma"     // Flintstone
         "Barney"    // Rubble
         "Betty"     // Rubble
         ]
     let listOfPeopleTuples = [
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
         ]
     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
         // [ 0; 2; 4; ... 10; ]
     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
     let consedList = 1 
 //    let mutable forBuiltList = []
 //    for i = 1 to 10 do
 //        forBuiltList <- (i * i) 
     let forBuiltList = [ for i in 1 .. 10 -> i * i]
     let concattedList = listOfIntegers @ consedList
         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
     listOfStrings
 
 [<Example("List examples 2")>]
 let list_examples_2() =
     //let notWorkingList = [ 1; "2"; 3.0; ]
     let (objectList 
         (1 
         ("2" 
         (3.0 
     ]
     objectList
 
 [<Example("List access examples")>]
 let list_examples_3() =
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     let peopleHead = people.Head
     System.Console.WriteLine(peopleHead)
     let firstPerson = List.head people
     System.Console.WriteLine(firstPerson)
     let (personOne 
     System.Console.WriteLine(personOne)
     let secondPerson = people.[1]
     System.Console.WriteLine(secondPerson)
     let otherSecondPerson = List.nth people 1
     let noSuchPerson = List.nth people 5
     System.Console.WriteLine("Expecting an exception above")
 
 // ============== Sequences
 [<Example("Sequence initializers")>]
 let seq_examples_1() =
     let threeNums = seq {0 .. 2}
     let lotsOfNums = seq {0 .. 100000000}
     let people = [
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Ken", "Sipe", 43)
     ]
     let seqPeople = Seq.ofList people
     let newards = Seq.filter (fun (it 
     Seq.iter (fun (it 
     let x = seq { for i = 1 to 10 do yield i }
     System.Console.WriteLine(x)
     let y = seq { for i = 1 to 10 do
                     System.Console.WriteLine("Generating {0}", i)
                     yield i }
     let yEnum = y.GetEnumerator()
     if yEnum.MoveNext() then
         System.Console.WriteLine(yEnum.Current)
     let randomNumberGenerator minVal maxVal =
         let randomer = new System.Random(System.DateTime.Now.Millisecond)
         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
     Seq.iter (fun (roll 
 
     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
     System.Console.WriteLine(squares)
 
 [<Example("Sequence directory operations")>]
 let seq_examples2() =
     let dir d = 
         let di = new System.IO.DirectoryInfo(d)
         seq { for fi in di.GetFileSystemInfos() -> fi }
     let printFileInfo (fi 
         System.Console.WriteLine("{0}", fi.FullName)
     let rootFiles = dir "C
     for fi in rootFiles do printFileInfo fi
     
     (* Uncomment this if you really want to iterate the
        entire contents of your hard drive 
     (*
     let rec recursiveDir d =
         let di = new System.IO.DirectoryInfo(d)
         seq {
             for f in di.GetFiles() do yield f
             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
         }
     let allFiles = recursiveDir @"C
     for fi in allFiles do printFileInfo fi
     *)
     ()
 
 // ============== Maps
 [<Example("Map creation example")>]
 let map_creation_example() =
     let nicknames = Map.ofList [ 
                         "Ted", new Person("Ted", "Neward", 38);
                         "Katie", new Person("Katie", "Ellison", 30);
                         "Michael", new Person("Michael", "Neward", 16) 
                     ]
     let moreNicknames = 
         nicknames.Add("Mark", new Person("William", "Richards", 45))
     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
     let nicknames = 
         dict [ 
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     ()
 
 [<Example("Map access example")>]
 let map_access_example() =
     let nicknames = 
         Map.ofList [
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     let ted = nicknames.["Ted"]
     System.Console.WriteLine(ted)
     let ted = Map.find "Ted" nicknames
     System.Console.WriteLine(ted)
 
     try
         let noone = nicknames.["Katie"]
         System.Console.WriteLine(noone)
     with 
     | ex -> System.Console.WriteLine("Katie not found")
     
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
     ()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="152" endline="179"><![CDATA[
 
 [<Example("Array operation examples")>]
 let array_examples_4() =
     let people = [|
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Ken", "Siple", 43)
         new Person("Naomi", "Wilson", 38)
         new Person("Michael", "Neward", 16)
         new Person("Matthew", "Neward", 9)
     |]
     let newardsFound = 
         Array.find (fun (it 
     System.Console.WriteLine(newardsFound)
     let drinkers =
         Array.filter (fun (it 
     Array.iter (fun (it 
         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
         drinkers
     people
         |> Array.filter (fun (it 
         |> Array.iter (fun (it 
             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
     let isADrinker (ar 
         Array.filter (fun (p 
     let haveABeer (ar 
         Array.iter (fun (p 
     people |> isADrinker |> haveABeer
 
 // ========= Lists ==========
 [<Example("List examples 1")>]
 let list_examples_1() =
     let emptyList = []
     let listOfIntegers = [ 1; 2; 3; 4; ]
     let listOfStrings = [
         "Fred"      // Flintstone
         "Wilma"     // Flintstone
         "Barney"    // Rubble
         "Betty"     // Rubble
         ]
     let listOfPeopleTuples = [
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
         ]
     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
         // [ 0; 2; 4; ... 10; ]
     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
     let consedList = 1 
 //    let mutable forBuiltList = []
 //    for i = 1 to 10 do
 //        forBuiltList <- (i * i) 
     let forBuiltList = [ for i in 1 .. 10 -> i * i]
     let concattedList = listOfIntegers @ consedList
         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
     listOfStrings
 
 [<Example("List examples 2")>]
 let list_examples_2() =
     //let notWorkingList = [ 1; "2"; 3.0; ]
     let (objectList 
         (1 
         ("2" 
         (3.0 
     ]
     objectList
 
 [<Example("List access examples")>]
 let list_examples_3() =
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     let peopleHead = people.Head
     System.Console.WriteLine(peopleHead)
     let firstPerson = List.head people
     System.Console.WriteLine(firstPerson)
     let (personOne 
     System.Console.WriteLine(personOne)
     let secondPerson = people.[1]
     System.Console.WriteLine(secondPerson)
     let otherSecondPerson = List.nth people 1
     let noSuchPerson = List.nth people 5
     System.Console.WriteLine("Expecting an exception above")
 
 // ============== Sequences
 [<Example("Sequence initializers")>]
 let seq_examples_1() =
     let threeNums = seq {0 .. 2}
     let lotsOfNums = seq {0 .. 100000000}
     let people = [
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Ken", "Sipe", 43)
     ]
     let seqPeople = Seq.ofList people
     let newards = Seq.filter (fun (it 
     Seq.iter (fun (it 
     let x = seq { for i = 1 to 10 do yield i }
     System.Console.WriteLine(x)
     let y = seq { for i = 1 to 10 do
                     System.Console.WriteLine("Generating {0}", i)
                     yield i }
     let yEnum = y.GetEnumerator()
     if yEnum.MoveNext() then
         System.Console.WriteLine(yEnum.Current)
     let randomNumberGenerator minVal maxVal =
         let randomer = new System.Random(System.DateTime.Now.Millisecond)
         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
     Seq.iter (fun (roll 
 
     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
     System.Console.WriteLine(squares)
 
 [<Example("Sequence directory operations")>]
 let seq_examples2() =
     let dir d = 
         let di = new System.IO.DirectoryInfo(d)
         seq { for fi in di.GetFileSystemInfos() -> fi }
     let printFileInfo (fi 
         System.Console.WriteLine("{0}", fi.FullName)
     let rootFiles = dir "C
     for fi in rootFiles do printFileInfo fi
     
     (* Uncomment this if you really want to iterate the
        entire contents of your hard drive 
     (*
     let rec recursiveDir d =
         let di = new System.IO.DirectoryInfo(d)
         seq {
             for f in di.GetFiles() do yield f
             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
         }
     let allFiles = recursiveDir @"C
     for fi in allFiles do printFileInfo fi
     *)
     ()
 
 // ============== Maps
 [<Example("Map creation example")>]
 let map_creation_example() =
     let nicknames = Map.ofList [ 
                         "Ted", new Person("Ted", "Neward", 38);
                         "Katie", new Person("Katie", "Ellison", 30);
                         "Michael", new Person("Michael", "Neward", 16) 
                     ]
     let moreNicknames = 
         nicknames.Add("Mark", new Person("William", "Richards", 45))
     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
     let nicknames = 
         dict [ 
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     ()
 
 [<Example("Map access example")>]
 let map_access_example() =
     let nicknames = 
         Map.ofList [
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     let ted = nicknames.["Ted"]
     System.Console.WriteLine(ted)
     let ted = Map.find "Ted" nicknames
     System.Console.WriteLine(ted)
 
     try
         let noone = nicknames.["Katie"]
         System.Console.WriteLine(noone)
     with 
     | ex -> System.Console.WriteLine("Katie not found")
     
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
     Array.iter (fun (it 
         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
         drinkers
     people
         |> Array.filter (fun (it 
         |> Array.iter (fun (it 
             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
     let isADrinker (ar 
         Array.filter (fun (p 
     let haveABeer (ar 
         Array.iter (fun (p 
     people |> isADrinker |> haveABeer
 
 // ========= Lists ==========
 [<Example("List examples 1")>]
 let list_examples_1() =
     let emptyList = []
     let listOfIntegers = [ 1; 2; 3; 4; ]
     let listOfStrings = [
         "Fred"      // Flintstone
         "Wilma"     // Flintstone
         "Barney"    // Rubble
         "Betty"     // Rubble
         ]
     let listOfPeopleTuples = [
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
         ]
     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
         // [ 0; 2; 4; ... 10; ]
     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
     let consedList = 1 
 //    let mutable forBuiltList = []
 //    for i = 1 to 10 do
 //        forBuiltList <- (i * i) 
     let forBuiltList = [ for i in 1 .. 10 -> i * i]
     let concattedList = listOfIntegers @ consedList
         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
     listOfStrings
 
 [<Example("List examples 2")>]
 let list_examples_2() =
     //let notWorkingList = [ 1; "2"; 3.0; ]
     let (objectList 
         (1 
         ("2" 
         (3.0 
     ]
     objectList
 
 [<Example("List access examples")>]
 let list_examples_3() =
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     let peopleHead = people.Head
     System.Console.WriteLine(peopleHead)
     let firstPerson = List.head people
     System.Console.WriteLine(firstPerson)
     let (personOne 
     System.Console.WriteLine(personOne)
     let secondPerson = people.[1]
     System.Console.WriteLine(secondPerson)
     let otherSecondPerson = List.nth people 1
     let noSuchPerson = List.nth people 5
     System.Console.WriteLine("Expecting an exception above")
 
 // ============== Sequences
 [<Example("Sequence initializers")>]
 let seq_examples_1() =
     let threeNums = seq {0 .. 2}
     let lotsOfNums = seq {0 .. 100000000}
     let people = [
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Ken", "Sipe", 43)
     ]
     let seqPeople = Seq.ofList people
     let newards = Seq.filter (fun (it 
     Seq.iter (fun (it 
     let x = seq { for i = 1 to 10 do yield i }
     System.Console.WriteLine(x)
     let y = seq { for i = 1 to 10 do
                     System.Console.WriteLine("Generating {0}", i)
                     yield i }
     let yEnum = y.GetEnumerator()
     if yEnum.MoveNext() then
         System.Console.WriteLine(yEnum.Current)
     let randomNumberGenerator minVal maxVal =
         let randomer = new System.Random(System.DateTime.Now.Millisecond)
         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
     Seq.iter (fun (roll 
 
     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
     System.Console.WriteLine(squares)
 
 [<Example("Sequence directory operations")>]
 let seq_examples2() =
     let dir d = 
         let di = new System.IO.DirectoryInfo(d)
         seq { for fi in di.GetFileSystemInfos() -> fi }
     let printFileInfo (fi 
         System.Console.WriteLine("{0}", fi.FullName)
     let rootFiles = dir "C
     for fi in rootFiles do printFileInfo fi
     
     (* Uncomment this if you really want to iterate the
        entire contents of your hard drive 
     (*
     let rec recursiveDir d =
         let di = new System.IO.DirectoryInfo(d)
         seq {
             for f in di.GetFiles() do yield f
             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
         }
     let allFiles = recursiveDir @"C
     for fi in allFiles do printFileInfo fi
     *)
     ()
 
 // ============== Maps
 [<Example("Map creation example")>]
 let map_creation_example() =
     let nicknames = Map.ofList [ 
                         "Ted", new Person("Ted", "Neward", 38);
                         "Katie", new Person("Katie", "Ellison", 30);
                         "Michael", new Person("Michael", "Neward", 16) 
                     ]
     let moreNicknames = 
         nicknames.Add("Mark", new Person("William", "Richards", 45))
     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
     let nicknames = 
         dict [ 
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     ()
 
 [<Example("Map access example")>]
 let map_access_example() =
     let nicknames = 
         Map.ofList [
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     let ted = nicknames.["Ted"]
     System.Console.WriteLine(ted)
     let ted = Map.find "Ted" nicknames
     System.Console.WriteLine(ted)
 
     try
         let noone = nicknames.["Katie"]
         System.Console.WriteLine(noone)
     with 
     | ex -> System.Console.WriteLine("Katie not found")
     
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
         |> Array.iter (fun (it 
             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
     let isADrinker (ar 
         Array.filter (fun (p 
     let haveABeer (ar 
         Array.iter (fun (p 
     people |> isADrinker |> haveABeer
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="180" endline="211"><![CDATA[
 
 // ========= Lists ==========
 [<Example("List examples 1")>]
 let list_examples_1() =
     let emptyList = []
     let listOfIntegers = [ 1; 2; 3; 4; ]
     let listOfStrings = [
         "Fred"      // Flintstone
         "Wilma"     // Flintstone
         "Barney"    // Rubble
         "Betty"     // Rubble
         ]
     let listOfPeopleTuples = [
         ("Ted", "Neward", 38, "Redmond", "WA")
         ("Katie", "Ellison", 30, "Seattle", "WA")
         ("Mark", "Richards", 45, "Boston", "MA")
         ("Rachel", "Reese", 27, "Phoenix", "AZ")
         ("Ken", "Sipe", 43, "St Louis", "MO")
         ("Naomi", "Wilson", 35, "Seattle", "WA")
         ]
     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
         // [ 0; 2; 4; ... 10; ]
     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
     let consedList = 1 
 //    let mutable forBuiltList = []
 //    for i = 1 to 10 do
 //        forBuiltList <- (i * i) 
     let forBuiltList = [ for i in 1 .. 10 -> i * i]
     let concattedList = listOfIntegers @ consedList
         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
     listOfStrings
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="212" endline="221"><![CDATA[
 
 [<Example("List examples 2")>]
 let list_examples_2() =
     //let notWorkingList = [ 1; "2"; 3.0; ]
     let (objectList 
         (1 
         ("2" 
         (3.0 
     ]
     objectList
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="222" endline="367"><![CDATA[
 
 [<Example("List access examples")>]
 let list_examples_3() =
     let people = [
         ("Ted", "Neward", 38)
         ("Mark", "Richards", 45)
         ("Naomi", "Wilson", 38)
         ("Ken", "Sipe", 43)
     ]
     let peopleHead = people.Head
     System.Console.WriteLine(peopleHead)
     let firstPerson = List.head people
     System.Console.WriteLine(firstPerson)
     let (personOne 
     System.Console.WriteLine(personOne)
     let secondPerson = people.[1]
     System.Console.WriteLine(secondPerson)
     let otherSecondPerson = List.nth people 1
     let noSuchPerson = List.nth people 5
     System.Console.WriteLine("Expecting an exception above")
 
 // ============== Sequences
 [<Example("Sequence initializers")>]
 let seq_examples_1() =
     let threeNums = seq {0 .. 2}
     let lotsOfNums = seq {0 .. 100000000}
     let people = [
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Ken", "Sipe", 43)
     ]
     let seqPeople = Seq.ofList people
     let newards = Seq.filter (fun (it 
     Seq.iter (fun (it 
     let x = seq { for i = 1 to 10 do yield i }
     System.Console.WriteLine(x)
     let y = seq { for i = 1 to 10 do
                     System.Console.WriteLine("Generating {0}", i)
                     yield i }
     let yEnum = y.GetEnumerator()
     if yEnum.MoveNext() then
         System.Console.WriteLine(yEnum.Current)
     let randomNumberGenerator minVal maxVal =
         let randomer = new System.Random(System.DateTime.Now.Millisecond)
         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
     Seq.iter (fun (roll 
 
     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
     System.Console.WriteLine(squares)
 
 [<Example("Sequence directory operations")>]
 let seq_examples2() =
     let dir d = 
         let di = new System.IO.DirectoryInfo(d)
         seq { for fi in di.GetFileSystemInfos() -> fi }
     let printFileInfo (fi 
         System.Console.WriteLine("{0}", fi.FullName)
     let rootFiles = dir "C
     for fi in rootFiles do printFileInfo fi
     
     (* Uncomment this if you really want to iterate the
        entire contents of your hard drive 
     (*
     let rec recursiveDir d =
         let di = new System.IO.DirectoryInfo(d)
         seq {
             for f in di.GetFiles() do yield f
             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
         }
     let allFiles = recursiveDir @"C
     for fi in allFiles do printFileInfo fi
     *)
     ()
 
 // ============== Maps
 [<Example("Map creation example")>]
 let map_creation_example() =
     let nicknames = Map.ofList [ 
                         "Ted", new Person("Ted", "Neward", 38);
                         "Katie", new Person("Katie", "Ellison", 30);
                         "Michael", new Person("Michael", "Neward", 16) 
                     ]
     let moreNicknames = 
         nicknames.Add("Mark", new Person("William", "Richards", 45))
     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
     let nicknames = 
         dict [ 
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     ()
 
 [<Example("Map access example")>]
 let map_access_example() =
     let nicknames = 
         Map.ofList [
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     let ted = nicknames.["Ted"]
     System.Console.WriteLine(ted)
     let ted = Map.find "Ted" nicknames
     System.Console.WriteLine(ted)
 
     try
         let noone = nicknames.["Katie"]
         System.Console.WriteLine(noone)
     with 
     | ex -> System.Console.WriteLine("Katie not found")
     
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
     System.Console.WriteLine(personOne)
     let secondPerson = people.[1]
     System.Console.WriteLine(secondPerson)
     let otherSecondPerson = List.nth people 1
     let noSuchPerson = List.nth people 5
     System.Console.WriteLine("Expecting an exception above")
 
 // ============== Sequences
 [<Example("Sequence initializers")>]
 let seq_examples_1() =
     let threeNums = seq {0 .. 2}
     let lotsOfNums = seq {0 .. 100000000}
     let people = [
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Ken", "Sipe", 43)
     ]
     let seqPeople = Seq.ofList people
     let newards = Seq.filter (fun (it 
     Seq.iter (fun (it 
     let x = seq { for i = 1 to 10 do yield i }
     System.Console.WriteLine(x)
     let y = seq { for i = 1 to 10 do
                     System.Console.WriteLine("Generating {0}", i)
                     yield i }
     let yEnum = y.GetEnumerator()
     if yEnum.MoveNext() then
         System.Console.WriteLine(yEnum.Current)
     let randomNumberGenerator minVal maxVal =
         let randomer = new System.Random(System.DateTime.Now.Millisecond)
         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
     Seq.iter (fun (roll 
 
     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
     System.Console.WriteLine(squares)
 
 [<Example("Sequence directory operations")>]
 let seq_examples2() =
     let dir d = 
         let di = new System.IO.DirectoryInfo(d)
         seq { for fi in di.GetFileSystemInfos() -> fi }
     let printFileInfo (fi 
         System.Console.WriteLine("{0}", fi.FullName)
     let rootFiles = dir "C
     for fi in rootFiles do printFileInfo fi
     
     (* Uncomment this if you really want to iterate the
        entire contents of your hard drive 
     (*
     let rec recursiveDir d =
         let di = new System.IO.DirectoryInfo(d)
         seq {
             for f in di.GetFiles() do yield f
             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
         }
     let allFiles = recursiveDir @"C
     for fi in allFiles do printFileInfo fi
     *)
     ()
 
 // ============== Maps
 [<Example("Map creation example")>]
 let map_creation_example() =
     let nicknames = Map.ofList [ 
                         "Ted", new Person("Ted", "Neward", 38);
                         "Katie", new Person("Katie", "Ellison", 30);
                         "Michael", new Person("Michael", "Neward", 16) 
                     ]
     let moreNicknames = 
         nicknames.Add("Mark", new Person("William", "Richards", 45))
     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
     let nicknames = 
         dict [ 
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     ()
 
 [<Example("Map access example")>]
 let map_access_example() =
     let nicknames = 
         Map.ofList [
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     let ted = nicknames.["Ted"]
     System.Console.WriteLine(ted)
     let ted = Map.find "Ted" nicknames
     System.Console.WriteLine(ted)
 
     try
         let noone = nicknames.["Katie"]
         System.Console.WriteLine(noone)
     with 
     | ex -> System.Console.WriteLine("Katie not found")
     
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="246" endline="272"><![CDATA[
     let threeNums = seq {0 .. 2}
     let lotsOfNums = seq {0 .. 100000000}
     let people = [
         new Person("Ted", "Neward", 38)
         new Person("Mark", "Richards", 45)
         new Person("Naomi", "Wilson", 38)
         new Person("Ken", "Sipe", 43)
     ]
     let seqPeople = Seq.ofList people
     let newards = Seq.filter (fun (it 
     Seq.iter (fun (it 
     let x = seq { for i = 1 to 10 do yield i }
     System.Console.WriteLine(x)
     let y = seq { for i = 1 to 10 do
                     System.Console.WriteLine("Generating {0}", i)
                     yield i }
     let yEnum = y.GetEnumerator()
     if yEnum.MoveNext() then
         System.Console.WriteLine(yEnum.Current)
     let randomNumberGenerator minVal maxVal =
         let randomer = new System.Random(System.DateTime.Now.Millisecond)
         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
     Seq.iter (fun (roll 
 
     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
     System.Console.WriteLine(squares)
 
 [<Example("Sequence directory operations")>]
 let seq_examples2() =
     let dir d = 
         let di = new System.IO.DirectoryInfo(d)
         seq { for fi in di.GetFileSystemInfos() -> fi }
     let printFileInfo (fi 
         System.Console.WriteLine("{0}", fi.FullName)
     let rootFiles = dir "C
     for fi in rootFiles do printFileInfo fi
     
     (* Uncomment this if you really want to iterate the
        entire contents of your hard drive 
     (*
     let rec recursiveDir d =
         let di = new System.IO.DirectoryInfo(d)
         seq {
             for f in di.GetFiles() do yield f
             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
         }
     let allFiles = recursiveDir @"C
     for fi in allFiles do printFileInfo fi
     *)
     ()
 
 // ============== Maps
 [<Example("Map creation example")>]
 let map_creation_example() =
     let nicknames = Map.ofList [ 
                         "Ted", new Person("Ted", "Neward", 38);
                         "Katie", new Person("Katie", "Ellison", 30);
                         "Michael", new Person("Michael", "Neward", 16) 
                     ]
     let moreNicknames = 
         nicknames.Add("Mark", new Person("William", "Richards", 45))
     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
     let nicknames = 
         dict [ 
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     ()
 
 [<Example("Map access example")>]
 let map_access_example() =
     let nicknames = 
         Map.ofList [
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     let ted = nicknames.["Ted"]
     System.Console.WriteLine(ted)
     let ted = Map.find "Ted" nicknames
     System.Console.WriteLine(ted)
 
     try
         let noone = nicknames.["Katie"]
         System.Console.WriteLine(noone)
     with 
     | ex -> System.Console.WriteLine("Katie not found")
     
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
     let randomNumberGenerator minVal maxVal =
         let randomer = new System.Random(System.DateTime.Now.Millisecond)
         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
     Seq.iter (fun (roll 
 
     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
     System.Console.WriteLine(squares)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="273" endline="296"><![CDATA[
 
 [<Example("Sequence directory operations")>]
 let seq_examples2() =
     let dir d = 
         let di = new System.IO.DirectoryInfo(d)
         seq { for fi in di.GetFileSystemInfos() -> fi }
     let printFileInfo (fi 
         System.Console.WriteLine("{0}", fi.FullName)
     let rootFiles = dir "C
     for fi in rootFiles do printFileInfo fi
     
     (* Uncomment this if you really want to iterate the
        entire contents of your hard drive 
     (*
     let rec recursiveDir d =
         let di = new System.IO.DirectoryInfo(d)
         seq {
             for f in di.GetFiles() do yield f
             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
         }
     let allFiles = recursiveDir @"C
     for fi in allFiles do printFileInfo fi
     *)
     ()
 
 // ============== Maps
 [<Example("Map creation example")>]
 let map_creation_example() =
     let nicknames = Map.ofList [ 
                         "Ted", new Person("Ted", "Neward", 38);
                         "Katie", new Person("Katie", "Ellison", 30);
                         "Michael", new Person("Michael", "Neward", 16) 
                     ]
     let moreNicknames = 
         nicknames.Add("Mark", new Person("William", "Richards", 45))
     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
     let nicknames = 
         dict [ 
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     ()
 
 [<Example("Map access example")>]
 let map_access_example() =
     let nicknames = 
         Map.ofList [
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     let ted = nicknames.["Ted"]
     System.Console.WriteLine(ted)
     let ted = Map.find "Ted" nicknames
     System.Console.WriteLine(ted)
 
     try
         let noone = nicknames.["Katie"]
         System.Console.WriteLine(noone)
     with 
     | ex -> System.Console.WriteLine("Katie not found")
     
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
     ()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="297" endline="315"><![CDATA[
 
 // ============== Maps
 [<Example("Map creation example")>]
 let map_creation_example() =
     let nicknames = Map.ofList [ 
                         "Ted", new Person("Ted", "Neward", 38);
                         "Katie", new Person("Katie", "Ellison", 30);
                         "Michael", new Person("Michael", "Neward", 16) 
                     ]
     let moreNicknames = 
         nicknames.Add("Mark", new Person("William", "Richards", 45))
     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
     let nicknames = 
         dict [ 
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     ()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="316" endline="367"><![CDATA[
 
 [<Example("Map access example")>]
 let map_access_example() =
     let nicknames = 
         Map.ofList [
             ("Ted", new Person("Theodore", "Neward", 38))
             ("Naomi", new Person("Naomi", "Wilson", 38))
             ("Ken", new Person("Kenneth", "Sipe", 45)) 
         ]
     let ted = nicknames.["Ted"]
     System.Console.WriteLine(ted)
     let ted = Map.find "Ted" nicknames
     System.Console.WriteLine(ted)
 
     try
         let noone = nicknames.["Katie"]
         System.Console.WriteLine(noone)
     with 
     | ex -> System.Console.WriteLine("Katie not found")
     
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
     try
         let noone = Map.find "Katie" nicknames
         System.Console.WriteLine(noone)
     with
     | ex -> System.Console.WriteLine("Katie not found")
     
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
     let notfound = nicknames.TryFind("Katie")
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
         else notfound.Value.ToString()
     )
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
     let notfound = Map.tryFind "Katie" nicknames
     System.Console.WriteLine(
         if notfound = None then "Not found" 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
         else notfound.Value.ToString()
     )
 
 // ============== Sets
 [<Example("Set examples")>]
 let set_examples1() =
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs" startline="356" endline="367"><![CDATA[
     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38);
                                    new Person("Ted", "Neward", 38); ]
     for p in setOfPeople do
         System.Console.WriteLine(p)
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
     for p in setOfNicknames do
         System.Console.WriteLine(p)
         
     ()
 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\FlowControl.fs" startline="9" endline="117"><![CDATA[
     let x = 12
     if x = 12 then
         System.Console.WriteLine("Yes, x is 12")
         
 [<Example("If-else examples")>]
 let if_else_examples() =
     let x = 12
     if x = 12 then
         System.Console.WriteLine("Yes, x is 12")
     else
         System.Console.WriteLine("Nope, it's not 12")
 
 [<Example("If-else-expression examples")>]
 let if_else_expression() =
     let x = 12
     let msg = if x = 12 then "Yes, x is 12" else "Nope, it's not 12"
     System.Console.WriteLine(msg)
     
 [<Example("If-elif examples")>]
 let if_elif_expression() =
     let x = 12
     if x = 12 then
         System.Console.WriteLine("Yes, x is 12")
     elif x = 24 then
         System.Console.WriteLine("Well, now x is 24")
     else
         System.Console.WriteLine("I have no clue what x is")
 
 //let if_else_badexpression =
 //    let x = 12
 //    let msg = if x = 12 then "Yes" else false
 //    System.Console.WriteLine(msg)
 
 //let if_int_example =
 //    let x = 12
 //    if x then
 //        System.Console.WriteLine("Yep, x")
         
 [<Example("While and for examples")>]
 let while_and_for_example() =
     // Uncomment the while loop if it's close to the top of the hour,
     // or else be prepared to wait for a while. ;-)
     (*
     while (System.DateTime.Now.Minute <> 0) do
         System.Console.WriteLine("Not yet the top of the hour...")
     *)
 
     for i = 1 to System.DateTime.Now.Hour do
         System.Console.Write("Cuckoo! ")
 
     System.Console.WriteLine()
     
 [<Example("For downto examples")>]
 let for_downto_example() =
     for i = 10 downto 1 do
         System.Console.WriteLine("i = {0}", i)
 
 [<Example("Exception-handling examples")>]
 let exception_handling_example() =
     let results = 
         try
             let req = System.Net.WebRequest.Create(
                         "Not a legitimate URL")
             let resp = req.GetResponse()
             let stream = resp.GetResponseStream()
             let reader = new System.IO.StreamReader(stream)
             let html = reader.ReadToEnd()
             html
         with
             | 
                 "You gave a bad URL"
             | 
                 "Some other exception
             | ex -> "We got an exception
     System.Console.WriteLine(results)
 
 [<Example("Exception-finally examples")>]
 let exception_handling_example2() =
     // This will throw an exception, since finally doesn't handle the
     // exception itself--thus the yellow stack trace in the console
     // is expected
     let results =
         try
             (12 / 0) 
         finally
             System.Console.WriteLine("In finally block")
     ()
 
 [<Example("Exception-raising examples")>]
 let exception_handling_example3() =
     // This will throw an exception, since finally doesn't handle the
     // exception itself--thus the yellow stack trace in the console
     // is expected
     try
         raise (new System.Exception("I don't wanna!"))
     finally
         System.Console.WriteLine("In finally block")
     ()
 
 exception MyException
 
 [<Example("New exception type examples")>]
 let exception_handling_example4() =
     try
         raise MyException
     with
         | _ -> System.Console.WriteLine("In finally block")
     ()
 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\FlowControl.fs" startline="15" endline="19"><![CDATA[
     let x = 12
     if x = 12 then
         System.Console.WriteLine("Yes, x is 12")
     else
         System.Console.WriteLine("Nope, it's not 12")
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\FlowControl.fs" startline="20" endline="25"><![CDATA[
 
 [<Example("If-else-expression examples")>]
 let if_else_expression() =
     let x = 12
     let msg = if x = 12 then "Yes, x is 12" else "Nope, it's not 12"
     System.Console.WriteLine(msg)
     
 [<Example("If-elif examples")>]
 let if_elif_expression() =
     let x = 12
     if x = 12 then
         System.Console.WriteLine("Yes, x is 12")
     elif x = 24 then
         System.Console.WriteLine("Well, now x is 24")
     else
         System.Console.WriteLine("I have no clue what x is")
 
 //let if_else_badexpression =
 //    let x = 12
 //    let msg = if x = 12 then "Yes" else false
 //    System.Console.WriteLine(msg)
 
 //let if_int_example =
 //    let x = 12
 //    if x then
 //        System.Console.WriteLine("Yep, x")
         
 [<Example("While and for examples")>]
 let while_and_for_example() =
     // Uncomment the while loop if it's close to the top of the hour,
     // or else be prepared to wait for a while. ;-)
     (*
     while (System.DateTime.Now.Minute <> 0) do
         System.Console.WriteLine("Not yet the top of the hour...")
     *)
 
     for i = 1 to System.DateTime.Now.Hour do
         System.Console.Write("Cuckoo! ")
 
     System.Console.WriteLine()
     
 [<Example("For downto examples")>]
 let for_downto_example() =
     for i = 10 downto 1 do
         System.Console.WriteLine("i = {0}", i)
 
 [<Example("Exception-handling examples")>]
 let exception_handling_example() =
     let results = 
         try
             let req = System.Net.WebRequest.Create(
                         "Not a legitimate URL")
             let resp = req.GetResponse()
             let stream = resp.GetResponseStream()
             let reader = new System.IO.StreamReader(stream)
             let html = reader.ReadToEnd()
             html
         with
             | 
                 "You gave a bad URL"
             | 
                 "Some other exception
             | ex -> "We got an exception
     System.Console.WriteLine(results)
 
 [<Example("Exception-finally examples")>]
 let exception_handling_example2() =
     // This will throw an exception, since finally doesn't handle the
     // exception itself--thus the yellow stack trace in the console
     // is expected
     let results =
         try
             (12 / 0) 
         finally
             System.Console.WriteLine("In finally block")
     ()
 
 [<Example("Exception-raising examples")>]
 let exception_handling_example3() =
     // This will throw an exception, since finally doesn't handle the
     // exception itself--thus the yellow stack trace in the console
     // is expected
     try
         raise (new System.Exception("I don't wanna!"))
     finally
         System.Console.WriteLine("In finally block")
     ()
 
 exception MyException
 
 [<Example("New exception type examples")>]
 let exception_handling_example4() =
     try
         raise MyException
     with
         | _ -> System.Console.WriteLine("In finally block")
     ()
 
     let msg = if x = 12 then "Yes, x is 12" else "Nope, it's not 12"
     System.Console.WriteLine(msg)
     
 [<Example("If-elif examples")>]
 let if_elif_expression() =
     let x = 12
     if x = 12 then
         System.Console.WriteLine("Yes, x is 12")
     elif x = 24 then
         System.Console.WriteLine("Well, now x is 24")
     else
         System.Console.WriteLine("I have no clue what x is")
 
 //let if_else_badexpression =
 //    let x = 12
 //    let msg = if x = 12 then "Yes" else false
 //    System.Console.WriteLine(msg)
 
 //let if_int_example =
 //    let x = 12
 //    if x then
 //        System.Console.WriteLine("Yep, x")
         
 [<Example("While and for examples")>]
 let while_and_for_example() =
     // Uncomment the while loop if it's close to the top of the hour,
     // or else be prepared to wait for a while. ;-)
     (*
     while (System.DateTime.Now.Minute <> 0) do
         System.Console.WriteLine("Not yet the top of the hour...")
     *)
 
     for i = 1 to System.DateTime.Now.Hour do
         System.Console.Write("Cuckoo! ")
 
     System.Console.WriteLine()
     
 [<Example("For downto examples")>]
 let for_downto_example() =
     for i = 10 downto 1 do
         System.Console.WriteLine("i = {0}", i)
 
 [<Example("Exception-handling examples")>]
 let exception_handling_example() =
     let results = 
         try
             let req = System.Net.WebRequest.Create(
                         "Not a legitimate URL")
             let resp = req.GetResponse()
             let stream = resp.GetResponseStream()
             let reader = new System.IO.StreamReader(stream)
             let html = reader.ReadToEnd()
             html
         with
             | 
                 "You gave a bad URL"
             | 
                 "Some other exception
             | ex -> "We got an exception
     System.Console.WriteLine(results)
 
 [<Example("Exception-finally examples")>]
 let exception_handling_example2() =
     // This will throw an exception, since finally doesn't handle the
     // exception itself--thus the yellow stack trace in the console
     // is expected
     let results =
         try
             (12 / 0) 
         finally
             System.Console.WriteLine("In finally block")
     ()
 
 [<Example("Exception-raising examples")>]
 let exception_handling_example3() =
     // This will throw an exception, since finally doesn't handle the
     // exception itself--thus the yellow stack trace in the console
     // is expected
     try
         raise (new System.Exception("I don't wanna!"))
     finally
         System.Console.WriteLine("In finally block")
     ()
 
 exception MyException
 
 [<Example("New exception type examples")>]
 let exception_handling_example4() =
     try
         raise MyException
     with
         | _ -> System.Console.WriteLine("In finally block")
     ()
 
     System.Console.WriteLine(msg)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\FlowControl.fs" startline="26" endline="35"><![CDATA[
     
 [<Example("If-elif examples")>]
 let if_elif_expression() =
     let x = 12
     if x = 12 then
         System.Console.WriteLine("Yes, x is 12")
     elif x = 24 then
         System.Console.WriteLine("Well, now x is 24")
     else
         System.Console.WriteLine("I have no clue what x is")
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\FlowControl.fs" startline="36" endline="59"><![CDATA[
 
 //let if_else_badexpression =
 //    let x = 12
 //    let msg = if x = 12 then "Yes" else false
 //    System.Console.WriteLine(msg)
 
 //let if_int_example =
 //    let x = 12
 //    if x then
 //        System.Console.WriteLine("Yep, x")
         
 [<Example("While and for examples")>]
 let while_and_for_example() =
     // Uncomment the while loop if it's close to the top of the hour,
     // or else be prepared to wait for a while. ;-)
     (*
     while (System.DateTime.Now.Minute <> 0) do
         System.Console.WriteLine("Not yet the top of the hour...")
     *)
 
     for i = 1 to System.DateTime.Now.Hour do
         System.Console.Write("Cuckoo! ")
     for i = 1 to System.DateTime.Now.Hour do
         System.Console.Write("Cuckoo! ")
 
     System.Console.WriteLine()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\FlowControl.fs" startline="60" endline="63"><![CDATA[
     
 [<Example("For downto examples")>]
 let for_downto_example() =
     for i = 10 downto 1 do
         System.Console.WriteLine("i = {0}", i)
     for i = 10 downto 1 do
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\FlowControl.fs" startline="64" endline="83"><![CDATA[
         System.Console.WriteLine("i = {0}", i)
 
 [<Example("Exception-handling examples")>]
 let exception_handling_example() =
     let results = 
         try
             let req = System.Net.WebRequest.Create(
                         "Not a legitimate URL")
             let resp = req.GetResponse()
             let stream = resp.GetResponseStream()
             let reader = new System.IO.StreamReader(stream)
             let html = reader.ReadToEnd()
             html
         with
             | 
                 "You gave a bad URL"
         with
             | 
                 "You gave a bad URL"
             | 
                 "Some other exception
         with
             | 
                 "You gave a bad URL"
             | 
                 "Some other exception
             | ex -> "We got an exception
     System.Console.WriteLine(results)
 
 [<Example("Exception-finally examples")>]
 let exception_handling_example2() =
     // This will throw an exception, since finally doesn't handle the
     // exception itself--thus the yellow stack trace in the console
     // is expected
     let results =
         try
             (12 / 0) 
         finally
             System.Console.WriteLine("In finally block")
     ()
 
 [<Example("Exception-raising examples")>]
 let exception_handling_example3() =
     // This will throw an exception, since finally doesn't handle the
     // exception itself--thus the yellow stack trace in the console
     // is expected
     try
         raise (new System.Exception("I don't wanna!"))
     finally
         System.Console.WriteLine("In finally block")
     ()
 
 exception MyException
 
 [<Example("New exception type examples")>]
 let exception_handling_example4() =
     try
         raise MyException
     with
         | _ -> System.Console.WriteLine("In finally block")
     ()
 
     System.Console.WriteLine(results)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\FlowControl.fs" startline="84" endline="95"><![CDATA[
 
 [<Example("Exception-finally examples")>]
 let exception_handling_example2() =
     // This will throw an exception, since finally doesn't handle the
     // exception itself--thus the yellow stack trace in the console
     // is expected
     let results =
         try
             (12 / 0) 
         finally
             System.Console.WriteLine("In finally block")
     ()
 
 [<Example("Exception-raising examples")>]
 let exception_handling_example3() =
     // This will throw an exception, since finally doesn't handle the
     // exception itself--thus the yellow stack trace in the console
     // is expected
     try
         raise (new System.Exception("I don't wanna!"))
     finally
         System.Console.WriteLine("In finally block")
     ()
 
 exception MyException
 
 [<Example("New exception type examples")>]
 let exception_handling_example4() =
     try
         raise MyException
     with
         | _ -> System.Console.WriteLine("In finally block")
     ()
 
     ()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\FlowControl.fs" startline="96" endline="106"><![CDATA[
 
 [<Example("Exception-raising examples")>]
 let exception_handling_example3() =
     // This will throw an exception, since finally doesn't handle the
     // exception itself--thus the yellow stack trace in the console
     // is expected
     try
         raise (new System.Exception("I don't wanna!"))
     finally
         System.Console.WriteLine("In finally block")
     ()
 
 exception MyException
 
 [<Example("New exception type examples")>]
 let exception_handling_example4() =
     try
         raise MyException
     with
         | _ -> System.Console.WriteLine("In finally block")
     ()
 
     ()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\FlowControl.fs" startline="107" endline="117"><![CDATA[
 
 exception MyException
 
 [<Example("New exception type examples")>]
 let exception_handling_example4() =
     try
         raise MyException
     with
         | _ -> System.Console.WriteLine("In finally block")
     ()
 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="9" endline="11"><![CDATA[
     let s = "Howdy, world!"
     let sLength = s.Length
     ()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="12" endline="28"><![CDATA[
 
 /// Bitwise operations
 [<Example("Bitwise operations")>]
 let bitwise_operations() =
     let bitwiseAND = 0b1111 &&& 0b1100
     let bitwiseOR = 0b1111 ||| 0b1100
     let bitwiseXOR = 0b1111 ^^^ 0b1100
     let bitwiseNEG = ~~~ 0b1111
     let bitwiseSHL = 0b1111 <<< 1
     let bitwiseSHR = 0b1111 >>> 1
     
     System.Console.WriteLine("bitwiseAND = {0}", (bitwiseAND = 0b1100))
     System.Console.WriteLine("bitwiseOR = {0}", (bitwiseOR = 0b1111))
     System.Console.WriteLine("bitwiseXOR = {0}", (bitwiseXOR = 0b0011))
     //System.Console.WriteLine("bitwiseNEG = {0
     System.Console.WriteLine("bitwiseSHL = {0}", (bitwiseSHL = 0b11110))
     System.Console.WriteLine("bitwiseSHR = {0}", (bitwiseSHR = 0b0111))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="29" endline="48"><![CDATA[
 
 
 [<Measure>] type usd
 [<Measure>] type euro
 
 [<Example("Bitwise operations")>]
 let uom_calculations =
     let usdRoyaltyCheck = 15000.00<usd>
     let usdToEuro (dollars 
         dollars * 1.5<euro/usd>
     System.Console.WriteLine("Royalties in Euro
 
 let s = "Hello world!"
 
 [<Literal>]
 let s2 = "Hello world again!"
 
 let literals =
     System.Console.WriteLine(s2)
     s2
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="36" endline="48"><![CDATA[
     let usdRoyaltyCheck = 15000.00<usd>
     let usdToEuro (dollars 
         dollars * 1.5<euro/usd>
     System.Console.WriteLine("Royalties in Euro
 
 let s = "Hello world!"
 
 [<Literal>]
 let s2 = "Hello world again!"
 
 let literals =
     System.Console.WriteLine(s2)
     s2
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\F#\Code\Basics\LexicalStructure.fs" startline="16" endline="52"><![CDATA[
 let x = 5
 
 // This is a single-line comment
 
 /// This is a documentation comment. Note that if you are
 /// looking at this file inside of Visual Studio, this
 /// documentation comment will be bound against the first
 /// identifier in the code snippets that follow, which is
 /// the identifier "y".
 
 // These are legitimate identifiers
 //
 let y = 1
 let aReallyLongIdentifierName = 2
 let _underscores_are_OK_too = 3
 let soAreNumbers123AfterALetter = 4
 /// This is not what you think--it will compile, but it
 /// actually defines two different identifiers (abc and
 /// foo) with the same value (5).
 let abc&foo = 5
 //let can'tincludeotherpunctuation,moron = 6
 
 // These are not (uncomment to see for sure)
 //
 // let 123abcNumbersCantComeFirst = 100
 // let abc@foo = 100
 
 // Demonstration of significant whitespace
 //
 let outer =
     let x = 2
     if x = 1 then
         System.Console.WriteLine("Hello, F#")
         if x = 1 then
             System.Console.WriteLine("Again!")
       else
         System.Console.WriteLine("Uh... how did this happen?")
]]></source>
</source_elements></project>
