
//  Microsoft (R) .NET Framework IL Disassembler.  Version 4.0.30319.1
//  Copyright (c) Microsoft Corporation.  All rights reserved.



// Metadata version: v4.0.30319
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern Microsoft.VisualBasic
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 10:0:0:0
}
.assembly extern System
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Drawing
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 4:0:0:0
}
.assembly extern System.Windows.Forms
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern Microsoft.Ink
{
  .publickeytoken = (31 BF 38 56 AD 36 4E 35 )                         // 1.8V.6N5
  .ver 6:1:0:0
}
.assembly extern ParallelExtensionsExtras
{
  .ver 1:2:0:0
}
.assembly extern System.Windows.Forms as System.Windows.Forms_7
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 2:0:0:0
}
.assembly extern System.Drawing as System.Drawing_8
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 2:0:0:0
}
.assembly ImageColorizer
{
  .custom instance void [mscorlib]System.Reflection.AssemblyProductAttribute::.ctor(string) = ( 01 00 0E 49 6D 61 67 65 43 6F 6C 6F 72 69 7A 65   // ...ImageColorize
                                                                                                72 00 00 )                                        // r..
  .custom instance void [mscorlib]System.Reflection.AssemblyDescriptionAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyCopyrightAttribute::.ctor(string) = ( 01 00 39 43 6F 70 79 72 69 67 68 74 20 C2 A9 20   // ..9Copyright .. 
                                                                                                  4D 69 63 72 6F 73 6F 66 74 20 43 6F 72 70 6F 72   // Microsoft Corpor
                                                                                                  61 74 69 6F 6E 2E 20 20 41 6C 6C 20 72 69 67 68   // ation.  All righ
                                                                                                  74 73 20 72 65 73 65 72 76 65 64 2E 00 00 )       // ts reserved...
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyTrademarkAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyCompanyAttribute::.ctor(string) = ( 01 00 15 4D 69 63 72 6F 73 6F 66 74 20 43 6F 72   // ...Microsoft Cor
                                                                                                70 6F 72 61 74 69 6F 6E 00 00 )                   // poration..
  .custom instance void [mscorlib]System.Reflection.AssemblyConfigurationAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyTitleAttribute::.ctor(string) = ( 01 00 0E 49 6D 61 67 65 43 6F 6C 6F 72 69 7A 65   // ...ImageColorize
                                                                                              72 00 00 )                                        // r..

  // --- The following custom attribute is added automatically, do not uncomment -------
  //  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 ) 

  .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx
                                                                                                             63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 )       // ceptionThrows.
  .custom instance void [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) = ( 01 00 1A 2E 4E 45 54 46 72 61 6D 65 77 6F 72 6B   // ....NETFramework
                                                                                                        2C 56 65 72 73 69 6F 6E 3D 76 34 2E 30 01 00 54   // ,Version=v4.0..T
                                                                                                        0E 14 46 72 61 6D 65 77 6F 72 6B 44 69 73 70 6C   // ..FrameworkDispl
                                                                                                        61 79 4E 61 6D 65 10 2E 4E 45 54 20 46 72 61 6D   // ayName..NET Fram
                                                                                                        65 77 6F 72 6B 20 34 )                            // ework 4
  .custom instance void [mscorlib]System.Reflection.AssemblyFileVersionAttribute::.ctor(string) = ( 01 00 07 31 2E 30 2E 30 2E 30 00 00 )             // ...1.0.0.0..
  .custom instance void [mscorlib]System.Runtime.InteropServices.GuidAttribute::.ctor(string) = ( 01 00 24 37 39 36 63 64 65 35 34 2D 30 66 32 32   // ..$796cde54-0f22
                                                                                                  2D 34 33 36 38 2D 38 63 31 66 2D 35 31 33 65 62   // -4368-8c1f-513eb
                                                                                                  33 63 31 39 33 65 31 00 00 )                      // 3c193e1..
  .custom instance void [mscorlib]System.Runtime.InteropServices.ComVisibleAttribute::.ctor(bool) = ( 01 00 00 00 00 ) 
  .hash algorithm 0x00008004
  .ver 1:0:0:0
}
.mresource public Resources.resources
{
  // Offset: 0x00000000 Length: 0x00002776
}
.mresource public Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm.resources
{
  // Offset: 0x0000277A Length: 0x00005CC8
}
.module ImageColorizer.exe
// MVID: {1D19B038-6B55-4368-8FF7-61573EA4BD3A}
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0002       // WINDOWS_GUI
.corflags 0x00000001    //  ILONLY
// Image base: 0x012D0000


// =============== CLASS MEMBERS DECLARATION ===================

.class private auto ansi My.MyApplication
       extends [Microsoft.VisualBasic]Microsoft.VisualBasic.ApplicationServices.ApplicationBase
{
  .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 01 00 00 00 00 00 ) 
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 0A 4D 79 54 65 6D 70 6C 61 74 65 08 31 30   // ...MyTemplate.10
                                                                                                  2E 30 2E 30 2E 30 00 00 )                         // .0.0.0..
  .method public specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       9 (0x9)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [Microsoft.VisualBasic]Microsoft.VisualBasic.ApplicationServices.ApplicationBase::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ret
  } // end of method MyApplication::.ctor

} // end of class My.MyApplication

.class private auto ansi My.MyComputer
       extends [Microsoft.VisualBasic]Microsoft.VisualBasic.Devices.Computer
{
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 0A 4D 79 54 65 6D 70 6C 61 74 65 08 31 30   // ...MyTemplate.10
                                                                                                  2E 30 2E 30 2E 30 00 00 )                         // .0.0.0..
  .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 01 00 00 00 00 00 ) 
  .method public specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 01 00 00 00 00 00 ) 
    // Code size       10 (0xa)
    .maxstack  8
    .language '{3A12D0B8-C26C-11D0-B442-00A0244A1DD2}', '{994B45C4-E6E9-11D2-903F-00C04FA302A1}', '{5A869D0B-6611-11D3-BD2A-0000F80849BD}'
// Source File '17d14f5c-a337-4978-8281-53493378c1071.vb' not found
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  call       instance void [Microsoft.VisualBasic]Microsoft.VisualBasic.Devices.Computer::.ctor()
    IL_0007:  nop
    IL_0008:  nop
    IL_0009:  ret
  } // end of method MyComputer::.ctor

} // end of class My.MyComputer

.class private auto ansi sealed beforefieldinit My.MyProject
       extends [mscorlib]System.Object
{
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 0A 4D 79 54 65 6D 70 6C 61 74 65 08 31 30   // ...MyTemplate.10
                                                                                                  2E 30 2E 30 2E 30 00 00 )                         // .0.0.0..
  .custom instance void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.StandardModuleAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [Microsoft.VisualBasic]Microsoft.VisualBasic.HideModuleNameAttribute::.ctor() = ( 01 00 00 00 ) 
  .class auto ansi sealed nested assembly MyWebServices
         extends [mscorlib]System.Object
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 01 00 00 00 00 00 ) 
    .custom instance void [Microsoft.VisualBasic]Microsoft.VisualBasic.MyGroupCollectionAttribute::.ctor(string,
                                                                                                         string,
                                                                                                         string,
                                                                                                         string) = ( 01 00 34 53 79 73 74 65 6D 2E 57 65 62 2E 53 65   // ..4System.Web.Se
                                                                                                                     72 76 69 63 65 73 2E 50 72 6F 74 6F 63 6F 6C 73   // rvices.Protocols
                                                                                                                     2E 53 6F 61 70 48 74 74 70 43 6C 69 65 6E 74 50   // .SoapHttpClientP
                                                                                                                     72 6F 74 6F 63 6F 6C 12 43 72 65 61 74 65 5F 5F   // rotocol.Create__
                                                                                                                     49 6E 73 74 61 6E 63 65 5F 5F 13 44 69 73 70 6F   // Instance__.Dispo
                                                                                                                     73 65 5F 5F 49 6E 73 74 61 6E 63 65 5F 5F 00 00   // se__Instance__..
                                                                                                                     00 ) 
    .method public strict virtual instance bool 
            Equals(object o) cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 01 00 00 00 00 00 ) 
      // Code size       18 (0x12)
      .maxstack  2
      .locals init ([0] bool Equals)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldarg.1
      IL_0003:  call       object [mscorlib]System.Runtime.CompilerServices.RuntimeHelpers::GetObjectValue(object)
      IL_0008:  call       instance bool [mscorlib]System.Object::Equals(object)
      IL_000d:  stloc.0
      IL_000e:  br.s       IL_0010

      IL_0010:  ldloc.0
      IL_0011:  ret
    } // end of method MyWebServices::Equals

    .method public strict virtual instance int32 
            GetHashCode() cil managed
    {
      .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 01 00 00 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       12 (0xc)
      .maxstack  1
      .locals init ([0] int32 GetHashCode)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance int32 [mscorlib]System.Object::GetHashCode()
      IL_0007:  stloc.0
      IL_0008:  br.s       IL_000a

      IL_000a:  ldloc.0
      IL_000b:  ret
    } // end of method MyWebServices::GetHashCode

    .method assembly hidebysig instance class [mscorlib]System.Type 
            GetType() cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 01 00 00 00 00 00 ) 
      // Code size       16 (0x10)
      .maxstack  1
      .locals init ([0] class [mscorlib]System.Type GetType)
      IL_0000:  nop
      IL_0001:  ldtoken    My.MyProject/MyWebServices
      IL_0006:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
      IL_000b:  stloc.0
      IL_000c:  br.s       IL_000e

      IL_000e:  ldloc.0
      IL_000f:  ret
    } // end of method MyWebServices::GetType

    .method public strict virtual instance string 
            ToString() cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 01 00 00 00 00 00 ) 
      // Code size       12 (0xc)
      .maxstack  1
      .locals init ([0] string ToString)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance string [mscorlib]System.Object::ToString()
      IL_0007:  stloc.0
      IL_0008:  br.s       IL_000a

      IL_000a:  ldloc.0
      IL_000b:  ret
    } // end of method MyWebServices::ToString

    .method private static !!T  Create__Instance__<.ctor T>(!!T 'instance') cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       32 (0x20)
      .maxstack  2
      .locals init ([0] !!T Create__Instance__,
               [1] bool VB$CG$t_bool$S0)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  box        !!T
      IL_0007:  ldnull
      IL_0008:  ceq
      IL_000a:  stloc.1
      IL_000b:  ldloc.1
      IL_000c:  brfalse.s  IL_0018

      IL_000e:  call       !!0 [mscorlib]System.Activator::CreateInstance<!!0>()
      IL_0013:  stloc.0
      IL_0014:  br.s       IL_001e

      IL_0016:  br.s       IL_001d

      IL_0018:  nop
      IL_0019:  ldarg.0
      IL_001a:  stloc.0
      IL_001b:  br.s       IL_001e

      IL_001d:  nop
      IL_001e:  ldloc.0
      IL_001f:  ret
    } // end of method MyWebServices::Create__Instance__

    .method private instance void  Dispose__Instance__<T>(!!T& 'instance') cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       18 (0x12)
      .maxstack  2
      .locals init ([0] !!T VB$t_generic$S0)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  ldloca.s   VB$t_generic$S0
      IL_0004:  initobj    !!T
      IL_000a:  ldloc.0
      IL_000b:  stobj      !!T
      IL_0010:  nop
      IL_0011:  ret
    } // end of method MyWebServices::Dispose__Instance__

    .method public specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 01 00 00 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       10 (0xa)
      .maxstack  8
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0007:  nop
      IL_0008:  nop
      IL_0009:  ret
    } // end of method MyWebServices::.ctor

  } // end of class MyWebServices

  .class auto ansi sealed nested assembly ThreadSafeObjectProvider`1<.ctor T>
         extends [mscorlib]System.Object
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 01 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.InteropServices.ComVisibleAttribute::.ctor(bool) = ( 01 00 00 00 00 ) 
    .field private static !T m_ThreadStaticValue
    .custom instance void [mscorlib]System.ThreadStaticAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .method assembly specialname instance !T 
            get_GetInstance() cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       38 (0x26)
      .maxstack  2
      .locals init ([0] !T GetInstance,
               [1] bool VB$CG$t_bool$S0)
      IL_0000:  nop
      IL_0001:  ldsfld     !0 class My.MyProject/ThreadSafeObjectProvider`1<!T>::m_ThreadStaticValue
      IL_0006:  box        !T
      IL_000b:  ldnull
      IL_000c:  ceq
      IL_000e:  stloc.1
      IL_000f:  ldloc.1
      IL_0010:  brfalse.s  IL_001c

      IL_0012:  call       !!0 [mscorlib]System.Activator::CreateInstance<!T>()
      IL_0017:  stsfld     !0 class My.MyProject/ThreadSafeObjectProvider`1<!T>::m_ThreadStaticValue
      IL_001c:  ldsfld     !0 class My.MyProject/ThreadSafeObjectProvider`1<!T>::m_ThreadStaticValue
      IL_0021:  stloc.0
      IL_0022:  br.s       IL_0024

      IL_0024:  ldloc.0
      IL_0025:  ret
    } // end of method ThreadSafeObjectProvider`1::get_GetInstance

    .method public specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 01 00 00 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       10 (0xa)
      .maxstack  8
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0007:  nop
      IL_0008:  nop
      IL_0009:  ret
    } // end of method ThreadSafeObjectProvider`1::.ctor

    .property instance !T GetInstance()
    {
      .get instance !T My.MyProject/ThreadSafeObjectProvider`1::get_GetInstance()
    } // end of property ThreadSafeObjectProvider`1::GetInstance
  } // end of class ThreadSafeObjectProvider`1

  .field private static initonly class My.MyProject/ThreadSafeObjectProvider`1<class My.MyComputer> m_ComputerObjectProvider
  .field private static initonly class My.MyProject/ThreadSafeObjectProvider`1<class My.MyApplication> m_AppObjectProvider
  .field private static initonly class My.MyProject/ThreadSafeObjectProvider`1<class [Microsoft.VisualBasic]Microsoft.VisualBasic.ApplicationServices.User> m_UserObjectProvider
  .field private static initonly class My.MyProject/ThreadSafeObjectProvider`1<class My.MyProject/MyWebServices> m_MyWebServicesObjectProvider
  .method private specialname rtspecialname static 
          void  .cctor() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       42 (0x2a)
    .maxstack  8
    IL_0000:  newobj     instance void class My.MyProject/ThreadSafeObjectProvider`1<class My.MyComputer>::.ctor()
    IL_0005:  stsfld     class My.MyProject/ThreadSafeObjectProvider`1<class My.MyComputer> My.MyProject::m_ComputerObjectProvider
    IL_000a:  newobj     instance void class My.MyProject/ThreadSafeObjectProvider`1<class My.MyApplication>::.ctor()
    IL_000f:  stsfld     class My.MyProject/ThreadSafeObjectProvider`1<class My.MyApplication> My.MyProject::m_AppObjectProvider
    IL_0014:  newobj     instance void class My.MyProject/ThreadSafeObjectProvider`1<class [Microsoft.VisualBasic]Microsoft.VisualBasic.ApplicationServices.User>::.ctor()
    IL_0019:  stsfld     class My.MyProject/ThreadSafeObjectProvider`1<class [Microsoft.VisualBasic]Microsoft.VisualBasic.ApplicationServices.User> My.MyProject::m_UserObjectProvider
    IL_001e:  newobj     instance void class My.MyProject/ThreadSafeObjectProvider`1<class My.MyProject/MyWebServices>::.ctor()
    IL_0023:  stsfld     class My.MyProject/ThreadSafeObjectProvider`1<class My.MyProject/MyWebServices> My.MyProject::m_MyWebServicesObjectProvider
    IL_0028:  nop
    IL_0029:  ret
  } // end of method MyProject::.cctor

  .method assembly specialname static class My.MyComputer 
          get_Computer() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       16 (0x10)
    .maxstack  1
    .locals init ([0] class My.MyComputer Computer)
    IL_0000:  nop
    IL_0001:  ldsfld     class My.MyProject/ThreadSafeObjectProvider`1<class My.MyComputer> My.MyProject::m_ComputerObjectProvider
    IL_0006:  callvirt   instance !0 class My.MyProject/ThreadSafeObjectProvider`1<class My.MyComputer>::get_GetInstance()
    IL_000b:  stloc.0
    IL_000c:  br.s       IL_000e

    IL_000e:  ldloc.0
    IL_000f:  ret
  } // end of method MyProject::get_Computer

  .method assembly specialname static class My.MyApplication 
          get_Application() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       16 (0x10)
    .maxstack  1
    .locals init ([0] class My.MyApplication Application)
    IL_0000:  nop
    IL_0001:  ldsfld     class My.MyProject/ThreadSafeObjectProvider`1<class My.MyApplication> My.MyProject::m_AppObjectProvider
    IL_0006:  callvirt   instance !0 class My.MyProject/ThreadSafeObjectProvider`1<class My.MyApplication>::get_GetInstance()
    IL_000b:  stloc.0
    IL_000c:  br.s       IL_000e

    IL_000e:  ldloc.0
    IL_000f:  ret
  } // end of method MyProject::get_Application

  .method assembly specialname static class [Microsoft.VisualBasic]Microsoft.VisualBasic.ApplicationServices.User 
          get_User() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       16 (0x10)
    .maxstack  1
    .locals init ([0] class [Microsoft.VisualBasic]Microsoft.VisualBasic.ApplicationServices.User User)
    IL_0000:  nop
    IL_0001:  ldsfld     class My.MyProject/ThreadSafeObjectProvider`1<class [Microsoft.VisualBasic]Microsoft.VisualBasic.ApplicationServices.User> My.MyProject::m_UserObjectProvider
    IL_0006:  callvirt   instance !0 class My.MyProject/ThreadSafeObjectProvider`1<class [Microsoft.VisualBasic]Microsoft.VisualBasic.ApplicationServices.User>::get_GetInstance()
    IL_000b:  stloc.0
    IL_000c:  br.s       IL_000e

    IL_000e:  ldloc.0
    IL_000f:  ret
  } // end of method MyProject::get_User

  .method assembly specialname static class My.MyProject/MyWebServices 
          get_WebServices() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       16 (0x10)
    .maxstack  1
    .locals init ([0] class My.MyProject/MyWebServices WebServices)
    IL_0000:  nop
    IL_0001:  ldsfld     class My.MyProject/ThreadSafeObjectProvider`1<class My.MyProject/MyWebServices> My.MyProject::m_MyWebServicesObjectProvider
    IL_0006:  callvirt   instance !0 class My.MyProject/ThreadSafeObjectProvider`1<class My.MyProject/MyWebServices>::get_GetInstance()
    IL_000b:  stloc.0
    IL_000c:  br.s       IL_000e

    IL_000e:  ldloc.0
    IL_000f:  ret
  } // end of method MyProject::get_WebServices

  .property class My.MyComputer Computer()
  {
    .custom instance void [System]System.ComponentModel.Design.HelpKeywordAttribute::.ctor(string) = ( 01 00 0B 4D 79 2E 43 6F 6D 70 75 74 65 72 00 00 ) // ...My.Computer..
    .get class My.MyComputer My.MyProject::get_Computer()
  } // end of property MyProject::Computer
  .property class My.MyApplication Application()
  {
    .custom instance void [System]System.ComponentModel.Design.HelpKeywordAttribute::.ctor(string) = ( 01 00 0E 4D 79 2E 41 70 70 6C 69 63 61 74 69 6F   // ...My.Applicatio
                                                                                                       6E 00 00 )                                        // n..
    .get class My.MyApplication My.MyProject::get_Application()
  } // end of property MyProject::Application
  .property class [Microsoft.VisualBasic]Microsoft.VisualBasic.ApplicationServices.User
          User()
  {
    .custom instance void [System]System.ComponentModel.Design.HelpKeywordAttribute::.ctor(string) = ( 01 00 07 4D 79 2E 55 73 65 72 00 00 )             // ...My.User..
    .get class [Microsoft.VisualBasic]Microsoft.VisualBasic.ApplicationServices.User My.MyProject::get_User()
  } // end of property MyProject::User
  .property class My.MyProject/MyWebServices
          WebServices()
  {
    .custom instance void [System]System.ComponentModel.Design.HelpKeywordAttribute::.ctor(string) = ( 01 00 0E 4D 79 2E 57 65 62 53 65 72 76 69 63 65   // ...My.WebService
                                                                                                       73 00 00 )                                        // s..
    .get class My.MyProject/MyWebServices My.MyProject::get_WebServices()
  } // end of property MyProject::WebServices
} // end of class My.MyProject

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation
       extends [mscorlib]System.Object
{
  .class auto ansi nested assembly _Closure$__1
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .class auto ansi nested assembly _Closure$__2
           extends [mscorlib]System.Object
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .class auto ansi nested assembly _Closure$__3
             extends [mscorlib]System.Object
      {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
        .class auto ansi nested assembly _Closure$__4
               extends [mscorlib]System.Object
        {
          .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
          .field public int32 $VB$Local_pixelsProcessed
          .field public int32 $VB$Local_saturationWindow
          .field public class [mscorlib]System.Collections.Generic.List`1<float32> $VB$Local_selectedHues
          .field public int32 $VB$Local_totalPixels
          .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 $VB$NonLocal_$VB$Closure_ClosureVariable_1E_56
          .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2 $VB$NonLocal_$VB$Closure_ClosureVariable_40_C
          .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3 $VB$NonLocal_$VB$Closure_ClosureVariable_41_10
          .method public specialname rtspecialname 
                  instance void  .ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4 other) cil managed
          {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
            // Code size       69 (0x45)
            .maxstack  2
            .locals init (bool V_0)
            IL_0000:  ldarg.0
            IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
            IL_0006:  nop
            IL_0007:  ldarg.1
            IL_0008:  ldnull
            IL_0009:  ceq
            IL_000b:  ldc.i4.0
            IL_000c:  ceq
            IL_000e:  stloc.0
            IL_000f:  ldloc.0
            IL_0010:  brfalse.s  IL_0042

            IL_0012:  ldarg.0
            IL_0013:  ldarg.1
            IL_0014:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_saturationWindow
            IL_0019:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_saturationWindow
            IL_001e:  ldarg.0
            IL_001f:  ldarg.1
            IL_0020:  ldfld      class [mscorlib]System.Collections.Generic.List`1<float32> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_selectedHues
            IL_0025:  stfld      class [mscorlib]System.Collections.Generic.List`1<float32> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_selectedHues
            IL_002a:  ldarg.0
            IL_002b:  ldarg.1
            IL_002c:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_totalPixels
            IL_0031:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_totalPixels
            IL_0036:  ldarg.0
            IL_0037:  ldarg.1
            IL_0038:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_pixelsProcessed
            IL_003d:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_pixelsProcessed
            IL_0042:  nop
            IL_0043:  nop
            IL_0044:  ret
          } // end of method _Closure$__4::.ctor

          .method public specialname rtspecialname 
                  instance void  .ctor() cil managed
          {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
            // Code size       9 (0x9)
            .maxstack  8
            IL_0000:  ldarg.0
            IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
            IL_0006:  nop
            IL_0007:  nop
            IL_0008:  ret
          } // end of method _Closure$__4::.ctor

          .method public specialname instance void 
                  _Lambda$__1(int32 y) cil managed
          {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
            // Code size       642 (0x282)
            .maxstack  5
            .locals init ([0] valuetype [System.Drawing]System.Drawing.Color c,
                     [1] float32 pixelHue,
                     [2] bool pixelInSelectedRegion,
                     [3] bool useGrayscale,
                     [4] int32 x,
                     [5] int32 i,
                     [6] valuetype [System.Drawing]System.Drawing.Point p,
                     [7] valuetype [System.Drawing]System.Drawing.RectangleF bound,
                     [8] float32 distance,
                     [9] float32 selectedHue,
                     [10] int32 VB$t_i4$L0,
                     [11] int32 VB$t_i4$L1,
                     [12] valuetype [System.Drawing]System.Drawing.RectangleF[] VB$t_array$L0,
                     [13] valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<float32> VB$t_struct$L0,
                     [14] bool VB$CG$t_bool$S0,
                     [15] bool VB$CG$t_bool$S1,
                     [16] int32 VB$CG$t_i4$S0)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ImageManipulation.vb' 
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
            IL_0000:  nop
//000092:                                                                For x = 0 To width - 1
            IL_0001:  ldc.i4.0
            IL_0002:  ldarg.0
            IL_0003:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_1E_56
            IL_0008:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_width
            IL_000d:  ldc.i4.1
            IL_000e:  sub.ovf
            IL_000f:  stloc.s    VB$t_i4$L0
            IL_0011:  stloc.s    x
            IL_0013:  br         IL_022e

//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
            IL_0018:  ldarg.0
            IL_0019:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_41_10
            IL_001e:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3::$VB$Local_fastOriginalImage
            IL_0023:  ldloc.s    x
            IL_0025:  ldarg.1
            IL_0026:  callvirt   instance valuetype [System.Drawing]System.Drawing.Color [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::GetColor(int32,
                                                                                                                                                          int32)
            IL_002b:  stloc.0
//000095:                                                                    Dim pixelHue = c.GetHue()
            IL_002c:  ldloca.s   c
            IL_002e:  call       instance float32 [System.Drawing]System.Drawing.Color::GetHue()
            IL_0033:  stloc.1
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
            IL_0034:  ldc.i4.0
            IL_0035:  stloc.2
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
            IL_0036:  ldarg.0
            IL_0037:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_1E_56
            IL_003c:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_paths
            IL_0041:  brfalse.s  IL_0059

            IL_0043:  ldarg.0
            IL_0044:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_1E_56
            IL_0049:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_paths
            IL_004e:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Count()
            IL_0053:  ldc.i4.0
            IL_0054:  beq.s      IL_0059

            IL_0056:  ldc.i4.0
            IL_0057:  br.s       IL_005a

            IL_0059:  ldc.i4.1
            IL_005a:  stloc.s    VB$CG$t_bool$S0
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
            IL_005c:  ldloc.s    VB$CG$t_bool$S0
            IL_005e:  brfalse.s  IL_0067

//000103:                                                                        pixelInSelectedRegion = True
            IL_0060:  ldc.i4.1
            IL_0061:  stloc.2
            IL_0062:  br         IL_0116

//000104:                                                                    Else
            IL_0067:  nop
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
            IL_0068:  ldloca.s   p
            IL_006a:  ldloc.s    x
            IL_006c:  ldarg.1
            IL_006d:  call       instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                           int32)
            IL_0072:  nop
//000108:                                                                        Dim i = 0
            IL_0073:  ldc.i4.0
            IL_0074:  stloc.s    i
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
            IL_0076:  br.s       IL_00f5

//000110:                                                                            If pathsBounds(i).Contains(p) Then
            IL_0078:  ldarg.0
            IL_0079:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_1E_56
            IL_007e:  ldfld      valuetype [System.Drawing]System.Drawing.Rectangle[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_pathsBounds
            IL_0083:  ldloc.s    i
            IL_0085:  ldelema    [System.Drawing]System.Drawing.Rectangle
            IL_008a:  ldloc.s    p
            IL_008c:  call       instance bool [System.Drawing]System.Drawing.Rectangle::Contains(valuetype [System.Drawing]System.Drawing.Point)
            IL_0091:  stloc.s    VB$CG$t_bool$S0
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
            IL_0093:  ldloc.s    VB$CG$t_bool$S0
            IL_0095:  brfalse.s  IL_00ed

//000114:                                                                                For Each bound In compositions(i)
            IL_0097:  ldarg.0
            IL_0098:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_1E_56
            IL_009d:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_compositions
            IL_00a2:  ldloc.s    i
            IL_00a4:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]>::get_Item(int32)
            IL_00a9:  stloc.s    VB$t_array$L0
            IL_00ab:  ldc.i4.0
            IL_00ac:  stloc.s    VB$t_i4$L1
            IL_00ae:  br.s       IL_00df

//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
            IL_00b0:  ldloc.s    VB$t_array$L0
            IL_00b2:  ldloc.s    VB$t_i4$L1
            IL_00b4:  ldelema    [System.Drawing]System.Drawing.RectangleF
            IL_00b9:  ldobj      [System.Drawing]System.Drawing.RectangleF
            IL_00be:  stloc.s    bound
//000115:                                                                                    If bound.Contains(x, y) Then
            IL_00c0:  ldloca.s   bound
            IL_00c2:  ldloc.s    x
            IL_00c4:  conv.r4
            IL_00c5:  ldarg.1
            IL_00c6:  conv.r4
            IL_00c7:  call       instance bool [System.Drawing]System.Drawing.RectangleF::Contains(float32,
                                                                                                   float32)
            IL_00cc:  stloc.s    VB$CG$t_bool$S1
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
            IL_00ce:  ldloc.s    VB$CG$t_bool$S1
            IL_00d0:  brfalse.s  IL_00d7

//000117:                                                                                        pixelInSelectedRegion = True
            IL_00d2:  ldc.i4.1
            IL_00d3:  stloc.2
//000118:                                                                                        Exit For
            IL_00d4:  nop
            IL_00d5:  br.s       IL_00ed

//000119:                                                                                    End If
            IL_00d7:  nop
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
            IL_00d8:  ldloc.s    VB$t_i4$L1
            IL_00da:  ldc.i4.1
            IL_00db:  add.ovf
            IL_00dc:  stloc.s    VB$t_i4$L1
//000120:                                                                                Next bound
            IL_00de:  nop
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
            IL_00df:  ldloc.s    VB$t_i4$L1
            IL_00e1:  ldloc.s    VB$t_array$L0
            IL_00e3:  ldlen
            IL_00e4:  conv.ovf.i4
            IL_00e5:  clt
            IL_00e7:  stloc.s    VB$CG$t_bool$S1
            IL_00e9:  ldloc.s    VB$CG$t_bool$S1
            IL_00eb:  brtrue.s   IL_00b0

//000121:                                                                            End If
            IL_00ed:  nop
//000122:                                                                            i += 1
            IL_00ee:  ldloc.s    i
            IL_00f0:  ldc.i4.1
            IL_00f1:  add.ovf
            IL_00f2:  stloc.s    i
//000123:                                                                        Loop
            IL_00f4:  nop
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
            IL_00f5:  ldloc.s    i
            IL_00f7:  ldarg.0
            IL_00f8:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_1E_56
            IL_00fd:  ldfld      valuetype [System.Drawing]System.Drawing.Rectangle[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_pathsBounds
            IL_0102:  ldlen
            IL_0103:  conv.ovf.i4
            IL_0104:  bge.s      IL_0109

            IL_0106:  ldloc.2
            IL_0107:  brfalse.s  IL_010c

            IL_0109:  ldc.i4.0
            IL_010a:  br.s       IL_010d

            IL_010c:  ldc.i4.1
            IL_010d:  stloc.s    VB$CG$t_bool$S1
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
            IL_010f:  ldloc.s    VB$CG$t_bool$S1
            IL_0111:  brtrue     IL_0078

//000124:                                                                    End If
            IL_0116:  nop
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
            IL_0117:  ldc.i4.1
            IL_0118:  stloc.3
//000131:                                                                    If pixelInSelectedRegion Then
            IL_0119:  ldloc.2
            IL_011a:  stloc.s    VB$CG$t_bool$S1
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
            IL_011c:  ldloc.s    VB$CG$t_bool$S1
            IL_011e:  brfalse    IL_0202

            IL_0123:  nop
//000137:                                                                        For Each selectedHue In selectedHues
            .try
            {
              IL_0124:  ldarg.0
              IL_0125:  ldfld      class [mscorlib]System.Collections.Generic.List`1<float32> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_selectedHues
              IL_012a:  callvirt   instance valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<!0> class [mscorlib]System.Collections.Generic.List`1<float32>::GetEnumerator()
              IL_012f:  stloc.s    VB$t_struct$L0
              IL_0131:  br         IL_01e0

//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
              IL_0136:  ldloca.s   VB$t_struct$L0
              IL_0138:  call       instance !0 valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<float32>::get_Current()
              IL_013d:  stloc.s    selectedHue
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
              IL_013f:  ldloc.1
              IL_0140:  ldloc.s    selectedHue
              IL_0142:  sub
              IL_0143:  call       float32 [mscorlib]System.Math::Abs(float32)
              IL_0148:  stloc.s    distance
//000151:                                                                            If distance > 180 Then
              IL_014a:  ldloc.s    distance
              IL_014c:  ldc.r4     180.
              IL_0151:  cgt
              IL_0153:  stloc.s    VB$CG$t_bool$S1
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
              IL_0155:  ldloc.s    VB$CG$t_bool$S1
              IL_0157:  brfalse.s  IL_0163

//000152:                                                                                distance = 360 - distance
              IL_0159:  ldc.r4     360.
              IL_015e:  ldloc.s    distance
              IL_0160:  sub
              IL_0161:  stloc.s    distance
//000153:                                                                            End If
              IL_0163:  nop
//000154: 
//000155:                                                                            If distance <= epsilon Then
              IL_0164:  ldloc.s    distance
              IL_0166:  ldarg.0
              IL_0167:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_1E_56
              IL_016c:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_epsilon
              IL_0171:  conv.r4
              IL_0172:  cgt.un
              IL_0174:  ldc.i4.0
              IL_0175:  ceq
              IL_0177:  stloc.s    VB$CG$t_bool$S1
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
              IL_0179:  ldloc.s    VB$CG$t_bool$S1
              IL_017b:  brfalse.s  IL_0184

//000156:                                                                                useGrayscale = False
              IL_017d:  ldc.i4.0
              IL_017e:  stloc.3
//000157:                                                                                Exit For
              IL_017f:  nop
              IL_0180:  br.s       IL_01f0

              IL_0182:  br.s       IL_01de

//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
              IL_0184:  ldloc.s    distance
              IL_0186:  ldarg.0
              IL_0187:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_1E_56
              IL_018c:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_epsilon
              IL_0191:  conv.r4
              IL_0192:  sub
              IL_0193:  ldarg.0
              IL_0194:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_saturationWindow
              IL_0199:  conv.r4
              IL_019a:  div
              IL_019b:  ldc.r4     1.
              IL_01a0:  clt
              IL_01a2:  stloc.s    VB$CG$t_bool$S1
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
              IL_01a4:  ldloc.s    VB$CG$t_bool$S1
              IL_01a6:  brfalse.s  IL_01de

//000159:                                                                                useGrayscale = False
              IL_01a8:  ldc.i4.0
              IL_01a9:  stloc.3
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
              IL_01aa:  ldloc.1
              IL_01ab:  ldloca.s   c
              IL_01ad:  call       instance float32 [System.Drawing]System.Drawing.Color::GetSaturation()
              IL_01b2:  ldc.r4     1.
              IL_01b7:  ldloc.s    distance
              IL_01b9:  ldarg.0
              IL_01ba:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_1E_56
              IL_01bf:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_epsilon
              IL_01c4:  conv.r4
              IL_01c5:  sub
              IL_01c6:  ldc.r4     10.
              IL_01cb:  div
              IL_01cc:  sub
              IL_01cd:  mul
              IL_01ce:  ldloca.s   c
              IL_01d0:  call       instance float32 [System.Drawing]System.Drawing.Color::GetBrightness()
              IL_01d5:  call       valuetype [System.Drawing]System.Drawing.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ColorFromHsb(float32,
                                                                                                                                                                                 float32,
                                                                                                                                                                                 float32)
              IL_01da:  stloc.0
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
              IL_01db:  nop
              IL_01dc:  br.s       IL_01f0

//000163:                                                                            End If
              IL_01de:  nop
//000164:                                                                        Next selectedHue
              IL_01df:  nop
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
              IL_01e0:  ldloca.s   VB$t_struct$L0
              IL_01e2:  call       instance bool valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<float32>::MoveNext()
              IL_01e7:  stloc.s    VB$CG$t_bool$S1
              IL_01e9:  ldloc.s    VB$CG$t_bool$S1
              IL_01eb:  brtrue     IL_0136

              IL_01f0:  nop
              IL_01f1:  leave.s    IL_0202

            }  // end .try
            finally
            {
              IL_01f3:  ldloca.s   VB$t_struct$L0
              IL_01f5:  constrained. valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<float32>
              IL_01fb:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
              IL_0200:  nop
              IL_0201:  endfinally
//000165:                                                                    End If
            }  // end handler
            IL_0202:  nop
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
            IL_0203:  ldloc.3
            IL_0204:  stloc.s    VB$CG$t_bool$S1
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
            IL_0206:  ldloc.s    VB$CG$t_bool$S1
            IL_0208:  brfalse.s  IL_0211

//000169:                                                                        c = ToGrayscale(c)
            IL_020a:  ldloc.0
            IL_020b:  call       valuetype [System.Drawing]System.Drawing.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ToGrayscale(valuetype [System.Drawing]System.Drawing.Color)
            IL_0210:  stloc.0
//000170:                                                                    End If
            IL_0211:  nop
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
            IL_0212:  ldarg.0
            IL_0213:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_40_C
            IL_0218:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2::$VB$Local_fastColorizedImage
            IL_021d:  ldloc.s    x
            IL_021f:  ldarg.1
            IL_0220:  ldloc.0
            IL_0221:  callvirt   instance void [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::SetColor(int32,
                                                                                                                int32,
                                                                                                                valuetype [System.Drawing]System.Drawing.Color)
            IL_0226:  nop
//000172:                                                                Next x
            IL_0227:  nop
            IL_0228:  ldloc.s    x
            IL_022a:  ldc.i4.1
            IL_022b:  add.ovf
            IL_022c:  stloc.s    x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
            IL_022e:  ldloc.s    x
            IL_0230:  ldloc.s    VB$t_i4$L0
            IL_0232:  stloc.s    VB$CG$t_i4$S0
            IL_0234:  ldloc.s    VB$CG$t_i4$S0
            IL_0236:  ble        IL_0018

//000175:                                                                Interlocked.Add(pixelsProcessed, width)
            IL_023b:  ldarg.0
            IL_023c:  ldflda     int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_pixelsProcessed
            IL_0241:  ldarg.0
            IL_0242:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_1E_56
            IL_0247:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_width
            IL_024c:  call       int32 [mscorlib]System.Threading.Interlocked::Add(int32&,
                                                                                   int32)
            IL_0251:  pop
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
            IL_0252:  ldarg.0
            IL_0253:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_1E_56
            IL_0258:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Me
            IL_025d:  ldc.i4.s   100
            IL_025f:  ldarg.0
            IL_0260:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_pixelsProcessed
            IL_0265:  mul.ovf
            IL_0266:  conv.r8
            IL_0267:  ldarg.0
            IL_0268:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_totalPixels
            IL_026d:  conv.r8
            IL_026e:  div
            IL_026f:  call       float64 [Microsoft.VisualBasic]Microsoft.VisualBasic.Conversion::Fix(float64)
            IL_0274:  call       float64 [mscorlib]System.Math::Round(float64)
            IL_0279:  conv.ovf.i4
            IL_027a:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::OnProgressChanged(int32)
            IL_027f:  nop
//000177:                                                            End Sub
            IL_0280:  nop
            IL_0281:  ret
          } // end of method _Closure$__4::_Lambda$__1

        } // end of class _Closure$__4

        .field public class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap $VB$Local_fastOriginalImage
        .method public specialname rtspecialname 
                instance void  .ctor() cil managed
        {
          .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
          // Code size       9 (0x9)
          .maxstack  8
          IL_0000:  ldarg.0
          IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
          IL_0006:  nop
          IL_0007:  nop
          IL_0008:  ret
        } // end of method _Closure$__3::.ctor

        .method public specialname rtspecialname 
                instance void  .ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3 other) cil managed
        {
          .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
          // Code size       33 (0x21)
          .maxstack  2
          .locals init (bool V_0)
          IL_0000:  ldarg.0
          IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
          IL_0006:  nop
          IL_0007:  ldarg.1
          IL_0008:  ldnull
          IL_0009:  ceq
          IL_000b:  ldc.i4.0
          IL_000c:  ceq
          IL_000e:  stloc.0
          IL_000f:  ldloc.0
          IL_0010:  brfalse.s  IL_001e

          IL_0012:  ldarg.0
          IL_0013:  ldarg.1
          IL_0014:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3::$VB$Local_fastOriginalImage
          IL_0019:  stfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3::$VB$Local_fastOriginalImage
          IL_001e:  nop
          IL_001f:  nop
          IL_0020:  ret
        } // end of method _Closure$__3::.ctor

      } // end of class _Closure$__3

      .field public class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap $VB$Local_fastColorizedImage
      .method public specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
        // Code size       9 (0x9)
        .maxstack  8
        IL_0000:  ldarg.0
        IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0006:  nop
        IL_0007:  nop
        IL_0008:  ret
      } // end of method _Closure$__2::.ctor

      .method public specialname rtspecialname 
              instance void  .ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2 other) cil managed
      {
        .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
        // Code size       33 (0x21)
        .maxstack  2
        .locals init (bool V_0)
        IL_0000:  ldarg.0
        IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0006:  nop
        IL_0007:  ldarg.1
        IL_0008:  ldnull
        IL_0009:  ceq
        IL_000b:  ldc.i4.0
        IL_000c:  ceq
        IL_000e:  stloc.0
        IL_000f:  ldloc.0
        IL_0010:  brfalse.s  IL_001e

        IL_0012:  ldarg.0
        IL_0013:  ldarg.1
        IL_0014:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2::$VB$Local_fastColorizedImage
        IL_0019:  stfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2::$VB$Local_fastColorizedImage
        IL_001e:  nop
        IL_001f:  nop
        IL_0020:  ret
      } // end of method _Closure$__2::.ctor

    } // end of class _Closure$__2

    .field public class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]> $VB$Local_compositions
    .field public int32 $VB$Local_epsilon
    .field public class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> $VB$Local_paths
    .field public valuetype [System.Drawing]System.Drawing.Rectangle[] $VB$Local_pathsBounds
    .field public int32 $VB$Local_width
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation $VB$Me
    .method public specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       9 (0x9)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  nop
      IL_0007:  nop
      IL_0008:  ret
    } // end of method _Closure$__1::.ctor

    .method public specialname rtspecialname 
            instance void  .ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 other) cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       93 (0x5d)
      .maxstack  2
      .locals init (bool V_0)
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  nop
      IL_0007:  ldarg.1
      IL_0008:  ldnull
      IL_0009:  ceq
      IL_000b:  ldc.i4.0
      IL_000c:  ceq
      IL_000e:  stloc.0
      IL_000f:  ldloc.0
      IL_0010:  brfalse.s  IL_005a

      IL_0012:  ldarg.0
      IL_0013:  ldarg.1
      IL_0014:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_epsilon
      IL_0019:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_epsilon
      IL_001e:  ldarg.0
      IL_001f:  ldarg.1
      IL_0020:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Me
      IL_0025:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Me
      IL_002a:  ldarg.0
      IL_002b:  ldarg.1
      IL_002c:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_paths
      IL_0031:  stfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_paths
      IL_0036:  ldarg.0
      IL_0037:  ldarg.1
      IL_0038:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_width
      IL_003d:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_width
      IL_0042:  ldarg.0
      IL_0043:  ldarg.1
      IL_0044:  ldfld      valuetype [System.Drawing]System.Drawing.Rectangle[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_pathsBounds
      IL_0049:  stfld      valuetype [System.Drawing]System.Drawing.Rectangle[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_pathsBounds
      IL_004e:  ldarg.0
      IL_004f:  ldarg.1
      IL_0050:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_compositions
      IL_0055:  stfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_compositions
      IL_005a:  nop
      IL_005b:  nop
      IL_005c:  ret
    } // end of method _Closure$__1::.ctor

  } // end of class _Closure$__1

  .field private static class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> __ENCList
  .field private class [System]System.ComponentModel.ProgressChangedEventHandler ProgressChangedEvent
  .method private specialname rtspecialname static 
          void  .cctor() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       12 (0xc)
    .maxstack  8
    IL_0000:  newobj     instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::.ctor()
    IL_0005:  stsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::__ENCList
    IL_000a:  nop
    IL_000b:  ret
  } // end of method ImageManipulation::.cctor

  .method public specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       16 (0x10)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  ldarg.0
    IL_0008:  call       void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::__ENCAddToList(object)
    IL_000d:  nop
    IL_000e:  nop
    IL_000f:  ret
  } // end of method ImageManipulation::.ctor

  .method private static void  __ENCAddToList(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       243 (0xf3)
    .maxstack  4
    .locals init (int32 V_0,
             int32 V_1,
             class [mscorlib]System.WeakReference V_2,
             class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> V_3,
             bool V_4,
             int32 V_5,
             bool V_6,
             bool V_7,
             int32 V_8)
    IL_0000:  nop
    IL_0001:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::__ENCList
    IL_0006:  stloc.3
    IL_0007:  ldc.i4.0
    IL_0008:  stloc.s    V_4
    IL_000a:  nop
    .try
    {
      IL_000b:  ldloc.3
      IL_000c:  ldloca.s   V_4
      IL_000e:  call       void [mscorlib]System.Threading.Monitor::Enter(object,
                                                                          bool&)
      IL_0013:  nop
      IL_0014:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::__ENCList
      IL_0019:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Count()
      IL_001e:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::__ENCList
      IL_0023:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Capacity()
      IL_0028:  ceq
      IL_002a:  stloc.s    V_6
      IL_002c:  ldloc.s    V_6
      IL_002e:  brfalse    IL_00c4

      IL_0033:  ldc.i4.0
      IL_0034:  stloc.0
      IL_0035:  ldc.i4.0
      IL_0036:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::__ENCList
      IL_003b:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Count()
      IL_0040:  ldc.i4.1
      IL_0041:  sub.ovf
      IL_0042:  stloc.s    V_5
      IL_0044:  stloc.1
      IL_0045:  br.s       IL_008e

      IL_0047:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::__ENCList
      IL_004c:  ldloc.1
      IL_004d:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Item(int32)
      IL_0052:  stloc.2
      IL_0053:  ldloc.2
      IL_0054:  callvirt   instance bool [mscorlib]System.WeakReference::get_IsAlive()
      IL_0059:  stloc.s    V_6
      IL_005b:  ldloc.s    V_6
      IL_005d:  brfalse.s  IL_0088

      IL_005f:  ldloc.1
      IL_0060:  ldloc.0
      IL_0061:  ceq
      IL_0063:  ldc.i4.0
      IL_0064:  ceq
      IL_0066:  stloc.s    V_7
      IL_0068:  ldloc.s    V_7
      IL_006a:  brfalse.s  IL_0083

      IL_006c:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::__ENCList
      IL_0071:  ldloc.0
      IL_0072:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::__ENCList
      IL_0077:  ldloc.1
      IL_0078:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Item(int32)
      IL_007d:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::set_Item(int32,
                                                                                                                                           !0)
      IL_0082:  nop
      IL_0083:  nop
      IL_0084:  ldloc.0
      IL_0085:  ldc.i4.1
      IL_0086:  add.ovf
      IL_0087:  stloc.0
      IL_0088:  nop
      IL_0089:  nop
      IL_008a:  ldloc.1
      IL_008b:  ldc.i4.1
      IL_008c:  add.ovf
      IL_008d:  stloc.1
      IL_008e:  ldloc.1
      IL_008f:  ldloc.s    V_5
      IL_0091:  stloc.s    V_8
      IL_0093:  ldloc.s    V_8
      IL_0095:  ble.s      IL_0047

      IL_0097:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::__ENCList
      IL_009c:  ldloc.0
      IL_009d:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::__ENCList
      IL_00a2:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Count()
      IL_00a7:  ldloc.0
      IL_00a8:  sub.ovf
      IL_00a9:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::RemoveRange(int32,
                                                                                                                                              int32)
      IL_00ae:  nop
      IL_00af:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::__ENCList
      IL_00b4:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::__ENCList
      IL_00b9:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Count()
      IL_00be:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::set_Capacity(int32)
      IL_00c3:  nop
      IL_00c4:  nop
      IL_00c5:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::__ENCList
      IL_00ca:  ldarg.0
      IL_00cb:  call       object [mscorlib]System.Runtime.CompilerServices.RuntimeHelpers::GetObjectValue(object)
      IL_00d0:  newobj     instance void [mscorlib]System.WeakReference::.ctor(object)
      IL_00d5:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::Add(!0)
      IL_00da:  nop
      IL_00db:  nop
      IL_00dc:  leave.s    IL_00f0

    }  // end .try
    finally
    {
      IL_00de:  nop
      IL_00df:  ldloc.s    V_4
      IL_00e1:  stloc.s    V_7
      IL_00e3:  ldloc.s    V_7
      IL_00e5:  brfalse.s  IL_00ee

      IL_00e7:  ldloc.3
      IL_00e8:  call       void [mscorlib]System.Threading.Monitor::Exit(object)
      IL_00ed:  nop
      IL_00ee:  nop
      IL_00ef:  endfinally
    }  // end handler
    IL_00f0:  nop
    IL_00f1:  nop
    IL_00f2:  ret
  } // end of method ImageManipulation::__ENCAddToList

  .method public specialname instance void 
          add_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler obj) cil managed synchronized
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       25 (0x19)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System]System.ComponentModel.ProgressChangedEventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ProgressChangedEvent
    IL_0007:  ldarg.1
    IL_0008:  call       class [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(class [mscorlib]System.Delegate,
                                                                                            class [mscorlib]System.Delegate)
    IL_000d:  castclass  [System]System.ComponentModel.ProgressChangedEventHandler
    IL_0012:  stfld      class [System]System.ComponentModel.ProgressChangedEventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ProgressChangedEvent
    IL_0017:  nop
    IL_0018:  ret
  } // end of method ImageManipulation::add_ProgressChanged

  .method public specialname instance void 
          remove_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler obj) cil managed synchronized
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       25 (0x19)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System]System.ComponentModel.ProgressChangedEventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ProgressChangedEvent
    IL_0007:  ldarg.1
    IL_0008:  call       class [mscorlib]System.Delegate [mscorlib]System.Delegate::Remove(class [mscorlib]System.Delegate,
                                                                                           class [mscorlib]System.Delegate)
    IL_000d:  castclass  [System]System.ComponentModel.ProgressChangedEventHandler
    IL_0012:  stfld      class [System]System.ComponentModel.ProgressChangedEventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ProgressChangedEvent
    IL_0017:  nop
    IL_0018:  ret
  } // end of method ImageManipulation::remove_ProgressChanged

  .method public instance class [System.Drawing]System.Drawing.Bitmap 
          Colorize(class [System.Drawing]System.Drawing.Bitmap original,
                   class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> selectedPixels,
                   int32 epsilon,
                   class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> paths,
                   bool parallel) cil managed
  {
    // Code size       830 (0x33e)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 $VB$Closure_ClosureVariable_1E_56,
             [1] class [System.Drawing]System.Drawing.Bitmap Colorize,
             [2] class [System.Drawing]System.Drawing.Bitmap colorizedImage,
             [3] int32 height,
             [4] int32 i,
             [5] class [System.Drawing]System.Drawing.Drawing2D.Matrix m,
             [6] int32 V_6,
             [7] class [System.Drawing]System.Drawing.Region r,
             [8] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2 $VB$Closure_ClosureVariable_40_C,
             [9] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3 $VB$Closure_ClosureVariable_41_10,
             [10] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4 $VB$Closure_ClosureVariable_FEEFED_0,
             [11] int32 pixelsPerProgressUpdate,
             [12] class [mscorlib]System.Action`1<int32> processRow,
             [13] valuetype [System.Drawing]System.Drawing.Point p,
             [14] int32 y,
             [15] int32 VB$t_i4$L0,
             [16] int32 VB$t_i4$L1,
             [17] valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<valuetype [System.Drawing]System.Drawing.Point> VB$t_struct$L0,
             [18] valuetype [System.Drawing]System.Drawing.Color VB$t_struct$S1,
             [19] int32 VB$t_i4$L2,
             [20] bool VB$CG$t_bool$S0,
             [21] int32 VB$CG$t_i4$S0)
//000030:         Public Function Colorize(ByVal original As Bitmap, ByVal selectedPixels As List(Of Point), ByVal epsilon As Integer,
    IL_0000:  nop
//000031:             ByVal paths As List(Of GraphicsPath), ByVal parallel As Boolean) As Bitmap
//000032:             ' Create a new bitmap with the same size as the original.
//000033:             Dim width = original.Width
//000034:             Dim height = original.Height
//000035:             Dim colorizedImage As New Bitmap(width, height)
//000036: 
//000037:             ' Optimization: For every GraphicsPath, get a bounding rectangle.  This allows for quickly
//000038:             ' ruling out pixels that are definitely not containing within the selected region.
//000039:             Dim pathsBounds() As Rectangle = Nothing
//000040:             If paths IsNot Nothing AndAlso paths.Count > 0 Then
//000041:                 pathsBounds = New Rectangle(paths.Count - 1) {}
//000042:                 For i = 0 To pathsBounds.Length - 1
//000043:                     pathsBounds(i) = Rectangle.Ceiling(paths(i).GetBounds())
//000044:                 Next i
//000045:             End If
//000046: 
//000047:             ' Optimization: Hit-testing against GraphicPaths is relatively slow.  Hit testing
//000048:             ' against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
//000049:             ' with rectangles which can be hit tested against instead of the paths.  Not quite
//000050:             ' as accurate, but much faster.
//000051:             Dim compositions As List(Of RectangleF()) = Nothing
//000052:             If paths IsNot Nothing AndAlso paths.Count > 0 Then
//000053:                 compositions = New List(Of RectangleF())(paths.Count)
//000054:                 Using m As New Matrix()
//000055:                     For i = 0 To paths.Count - 1
//000056:                         Using r As New Region(paths(i))
//000057:                             compositions.Add(r.GetRegionScans(m))
//000058:                         End Using
//000059:                     Next i
//000060:                 End Using
//000061:             End If
//000062: 
//000063:             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
//000064:             ' in the original and in the new images.
//000065:             Using fastColorizedImage As New FastBitmap(colorizedImage)
//000066:                 Using fastOriginalImage As New FastBitmap(original)
//000067:                     ' Extract the selected hues from the selected pixels.
//000068:                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
//000069:                     For Each p In selectedPixels
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_0001:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::.ctor()
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  ldarg.3
    IL_0009:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_epsilon
    IL_000e:  ldloc.0
    IL_000f:  ldarg.0
    IL_0010:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Me
    IL_0015:  ldloc.0
    IL_0016:  ldarg.s    paths
    IL_0018:  stfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_paths
//000033:             Dim width = original.Width
    IL_001d:  ldloc.0
    IL_001e:  ldarg.1
    IL_001f:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0024:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_width
//000034:             Dim height = original.Height
    IL_0029:  ldarg.1
    IL_002a:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_002f:  stloc.3
//000035:             Dim colorizedImage As New Bitmap(width, height)
    IL_0030:  ldloc.0
    IL_0031:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_width
    IL_0036:  ldloc.3
    IL_0037:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(int32,
                                                                                    int32)
    IL_003c:  stloc.2
//000036: 
//000037:             ' Optimization: For every GraphicsPath, get a bounding rectangle.  This allows for quickly
//000038:             ' ruling out pixels that are definitely not containing within the selected region.
//000039:             Dim pathsBounds() As Rectangle = Nothing
    IL_003d:  ldloc.0
    IL_003e:  ldnull
    IL_003f:  stfld      valuetype [System.Drawing]System.Drawing.Rectangle[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_pathsBounds
//000040:             If paths IsNot Nothing AndAlso paths.Count > 0 Then
    IL_0044:  ldloc.0
    IL_0045:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_paths
    IL_004a:  brfalse.s  IL_005a

    IL_004c:  ldloc.0
    IL_004d:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_paths
    IL_0052:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Count()
    IL_0057:  ldc.i4.0
    IL_0058:  bgt.s      IL_005d

    IL_005a:  ldc.i4.0
    IL_005b:  br.s       IL_005e

    IL_005d:  ldc.i4.1
    IL_005e:  stloc.s    VB$CG$t_bool$S0
//000041:                 pathsBounds = New Rectangle(paths.Count - 1) {}
//000042:                 For i = 0 To pathsBounds.Length - 1
//000043:                     pathsBounds(i) = Rectangle.Ceiling(paths(i).GetBounds())
//000044:                 Next i
//000045:             End If
//000046: 
//000047:             ' Optimization: Hit-testing against GraphicPaths is relatively slow.  Hit testing
//000048:             ' against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
//000049:             ' with rectangles which can be hit tested against instead of the paths.  Not quite
//000050:             ' as accurate, but much faster.
//000051:             Dim compositions As List(Of RectangleF()) = Nothing
//000052:             If paths IsNot Nothing AndAlso paths.Count > 0 Then
//000053:                 compositions = New List(Of RectangleF())(paths.Count)
//000054:                 Using m As New Matrix()
//000055:                     For i = 0 To paths.Count - 1
//000056:                         Using r As New Region(paths(i))
//000057:                             compositions.Add(r.GetRegionScans(m))
//000058:                         End Using
//000059:                     Next i
//000060:                 End Using
//000061:             End If
//000062: 
//000063:             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
//000064:             ' in the original and in the new images.
//000065:             Using fastColorizedImage As New FastBitmap(colorizedImage)
//000066:                 Using fastOriginalImage As New FastBitmap(original)
//000067:                     ' Extract the selected hues from the selected pixels.
//000068:                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
//000069:                     For Each p In selectedPixels
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_0060:  ldloc.s    VB$CG$t_bool$S0
    IL_0062:  brfalse.s  IL_00c9

//000041:                 pathsBounds = New Rectangle(paths.Count - 1) {}
    IL_0064:  ldloc.0
    IL_0065:  ldloc.0
    IL_0066:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_paths
    IL_006b:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Count()
    IL_0070:  ldc.i4.1
    IL_0071:  sub.ovf
    IL_0072:  ldc.i4.1
    IL_0073:  add.ovf
    IL_0074:  newarr     [System.Drawing]System.Drawing.Rectangle
    IL_0079:  stfld      valuetype [System.Drawing]System.Drawing.Rectangle[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_pathsBounds
//000042:                 For i = 0 To pathsBounds.Length - 1
    IL_007e:  ldc.i4.0
    IL_007f:  ldloc.0
    IL_0080:  ldfld      valuetype [System.Drawing]System.Drawing.Rectangle[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_pathsBounds
    IL_0085:  ldlen
    IL_0086:  conv.ovf.i4
    IL_0087:  ldc.i4.1
    IL_0088:  sub.ovf
    IL_0089:  stloc.s    VB$t_i4$L0
    IL_008b:  stloc.s    i
    IL_008d:  br.s       IL_00bf

//000043:                     pathsBounds(i) = Rectangle.Ceiling(paths(i).GetBounds())
    IL_008f:  ldloc.0
    IL_0090:  ldfld      valuetype [System.Drawing]System.Drawing.Rectangle[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_pathsBounds
    IL_0095:  ldloc.s    i
    IL_0097:  ldelema    [System.Drawing]System.Drawing.Rectangle
    IL_009c:  ldloc.0
    IL_009d:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_paths
    IL_00a2:  ldloc.s    i
    IL_00a4:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Item(int32)
    IL_00a9:  callvirt   instance valuetype [System.Drawing]System.Drawing.RectangleF [System.Drawing]System.Drawing.Drawing2D.GraphicsPath::GetBounds()
    IL_00ae:  call       valuetype [System.Drawing]System.Drawing.Rectangle [System.Drawing]System.Drawing.Rectangle::Ceiling(valuetype [System.Drawing]System.Drawing.RectangleF)
    IL_00b3:  stobj      [System.Drawing]System.Drawing.Rectangle
//000044:                 Next i
    IL_00b8:  nop
    IL_00b9:  ldloc.s    i
    IL_00bb:  ldc.i4.1
    IL_00bc:  add.ovf
    IL_00bd:  stloc.s    i
//000045:             End If
//000046: 
//000047:             ' Optimization: Hit-testing against GraphicPaths is relatively slow.  Hit testing
//000048:             ' against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
//000049:             ' with rectangles which can be hit tested against instead of the paths.  Not quite
//000050:             ' as accurate, but much faster.
//000051:             Dim compositions As List(Of RectangleF()) = Nothing
//000052:             If paths IsNot Nothing AndAlso paths.Count > 0 Then
//000053:                 compositions = New List(Of RectangleF())(paths.Count)
//000054:                 Using m As New Matrix()
//000055:                     For i = 0 To paths.Count - 1
//000056:                         Using r As New Region(paths(i))
//000057:                             compositions.Add(r.GetRegionScans(m))
//000058:                         End Using
//000059:                     Next i
//000060:                 End Using
//000061:             End If
//000062: 
//000063:             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
//000064:             ' in the original and in the new images.
//000065:             Using fastColorizedImage As New FastBitmap(colorizedImage)
//000066:                 Using fastOriginalImage As New FastBitmap(original)
//000067:                     ' Extract the selected hues from the selected pixels.
//000068:                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
//000069:                     For Each p In selectedPixels
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_00bf:  ldloc.s    i
    IL_00c1:  ldloc.s    VB$t_i4$L0
    IL_00c3:  stloc.s    VB$CG$t_i4$S0
    IL_00c5:  ldloc.s    VB$CG$t_i4$S0
    IL_00c7:  ble.s      IL_008f

//000045:             End If
    IL_00c9:  nop
//000046: 
//000047:             ' Optimization: Hit-testing against GraphicPaths is relatively slow.  Hit testing
//000048:             ' against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
//000049:             ' with rectangles which can be hit tested against instead of the paths.  Not quite
//000050:             ' as accurate, but much faster.
//000051:             Dim compositions As List(Of RectangleF()) = Nothing
    IL_00ca:  ldloc.0
    IL_00cb:  ldnull
    IL_00cc:  stfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_compositions
//000052:             If paths IsNot Nothing AndAlso paths.Count > 0 Then
    IL_00d1:  ldloc.0
    IL_00d2:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_paths
    IL_00d7:  brfalse.s  IL_00e7

    IL_00d9:  ldloc.0
    IL_00da:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_paths
    IL_00df:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Count()
    IL_00e4:  ldc.i4.0
    IL_00e5:  bgt.s      IL_00ea

    IL_00e7:  ldc.i4.0
    IL_00e8:  br.s       IL_00eb

    IL_00ea:  ldc.i4.1
    IL_00eb:  stloc.s    VB$CG$t_bool$S0
//000053:                 compositions = New List(Of RectangleF())(paths.Count)
//000054:                 Using m As New Matrix()
//000055:                     For i = 0 To paths.Count - 1
//000056:                         Using r As New Region(paths(i))
//000057:                             compositions.Add(r.GetRegionScans(m))
//000058:                         End Using
//000059:                     Next i
//000060:                 End Using
//000061:             End If
//000062: 
//000063:             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
//000064:             ' in the original and in the new images.
//000065:             Using fastColorizedImage As New FastBitmap(colorizedImage)
//000066:                 Using fastOriginalImage As New FastBitmap(original)
//000067:                     ' Extract the selected hues from the selected pixels.
//000068:                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
//000069:                     For Each p In selectedPixels
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_00ed:  ldloc.s    VB$CG$t_bool$S0
    IL_00ef:  brfalse    IL_0199

//000053:                 compositions = New List(Of RectangleF())(paths.Count)
    IL_00f4:  ldloc.0
    IL_00f5:  ldloc.0
    IL_00f6:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_paths
    IL_00fb:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Count()
    IL_0100:  newobj     instance void class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]>::.ctor(int32)
    IL_0105:  stfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_compositions
//000054:                 Using m As New Matrix()
    IL_010a:  nop
    IL_010b:  newobj     instance void [System.Drawing]System.Drawing.Drawing2D.Matrix::.ctor()
    IL_0110:  stloc.s    m
//000055:                     For i = 0 To paths.Count - 1
//000056:                         Using r As New Region(paths(i))
//000057:                             compositions.Add(r.GetRegionScans(m))
//000058:                         End Using
//000059:                     Next i
//000060:                 End Using
//000061:             End If
//000062: 
//000063:             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
//000064:             ' in the original and in the new images.
//000065:             Using fastColorizedImage As New FastBitmap(colorizedImage)
//000066:                 Using fastOriginalImage As New FastBitmap(original)
//000067:                     ' Extract the selected hues from the selected pixels.
//000068:                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
//000069:                     For Each p In selectedPixels
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_0112:  nop
//000055:                     For i = 0 To paths.Count - 1
    .try
    {
      IL_0113:  ldc.i4.0
      IL_0114:  ldloc.0
      IL_0115:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_paths
      IL_011a:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Count()
      IL_011f:  ldc.i4.1
      IL_0120:  sub.ovf
      IL_0121:  stloc.s    VB$t_i4$L1
      IL_0123:  stloc.s    V_6
      IL_0125:  br.s       IL_0174

//000056:                         Using r As New Region(paths(i))
      IL_0127:  nop
      IL_0128:  ldloc.0
      IL_0129:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_paths
      IL_012e:  ldloc.s    V_6
      IL_0130:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Item(int32)
      IL_0135:  newobj     instance void [System.Drawing]System.Drawing.Region::.ctor(class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath)
      IL_013a:  stloc.s    r
//000057:                             compositions.Add(r.GetRegionScans(m))
//000058:                         End Using
//000059:                     Next i
//000060:                 End Using
//000061:             End If
//000062: 
//000063:             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
//000064:             ' in the original and in the new images.
//000065:             Using fastColorizedImage As New FastBitmap(colorizedImage)
//000066:                 Using fastOriginalImage As New FastBitmap(original)
//000067:                     ' Extract the selected hues from the selected pixels.
//000068:                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
//000069:                     For Each p In selectedPixels
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
      IL_013c:  nop
//000057:                             compositions.Add(r.GetRegionScans(m))
      .try
      {
        IL_013d:  ldloc.0
        IL_013e:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_compositions
        IL_0143:  ldloc.s    r
        IL_0145:  ldloc.s    m
        IL_0147:  callvirt   instance valuetype [System.Drawing]System.Drawing.RectangleF[] [System.Drawing]System.Drawing.Region::GetRegionScans(class [System.Drawing]System.Drawing.Drawing2D.Matrix)
        IL_014c:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.RectangleF[]>::Add(!0)
        IL_0151:  nop
//000058:                         End Using
        IL_0152:  nop
//000059:                     Next i
//000060:                 End Using
//000061:             End If
//000062: 
//000063:             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
//000064:             ' in the original and in the new images.
//000065:             Using fastColorizedImage As New FastBitmap(colorizedImage)
//000066:                 Using fastOriginalImage As New FastBitmap(original)
//000067:                     ' Extract the selected hues from the selected pixels.
//000068:                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
//000069:                     For Each p In selectedPixels
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
        IL_0153:  leave.s    IL_016d

      }  // end .try
      finally
      {
        IL_0155:  ldloc.s    r
        IL_0157:  ldnull
        IL_0158:  ceq
        IL_015a:  ldc.i4.0
        IL_015b:  ceq
        IL_015d:  stloc.s    VB$CG$t_bool$S0
        IL_015f:  ldloc.s    VB$CG$t_bool$S0
        IL_0161:  brfalse.s  IL_016b

        IL_0163:  ldloc.s    r
        IL_0165:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_016a:  nop
        IL_016b:  nop
        IL_016c:  endfinally
//000059:                     Next i
      }  // end handler
      IL_016d:  nop
      IL_016e:  ldloc.s    V_6
      IL_0170:  ldc.i4.1
      IL_0171:  add.ovf
      IL_0172:  stloc.s    V_6
//000060:                 End Using
//000061:             End If
//000062: 
//000063:             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
//000064:             ' in the original and in the new images.
//000065:             Using fastColorizedImage As New FastBitmap(colorizedImage)
//000066:                 Using fastOriginalImage As New FastBitmap(original)
//000067:                     ' Extract the selected hues from the selected pixels.
//000068:                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
//000069:                     For Each p In selectedPixels
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
      IL_0174:  ldloc.s    V_6
      IL_0176:  ldloc.s    VB$t_i4$L1
      IL_0178:  stloc.s    VB$CG$t_i4$S0
      IL_017a:  ldloc.s    VB$CG$t_i4$S0
      IL_017c:  ble.s      IL_0127

//000060:                 End Using
      IL_017e:  nop
//000061:             End If
//000062: 
//000063:             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
//000064:             ' in the original and in the new images.
//000065:             Using fastColorizedImage As New FastBitmap(colorizedImage)
//000066:                 Using fastOriginalImage As New FastBitmap(original)
//000067:                     ' Extract the selected hues from the selected pixels.
//000068:                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
//000069:                     For Each p In selectedPixels
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
      IL_017f:  leave.s    IL_0199

    }  // end .try
    finally
    {
      IL_0181:  ldloc.s    m
      IL_0183:  ldnull
      IL_0184:  ceq
      IL_0186:  ldc.i4.0
      IL_0187:  ceq
      IL_0189:  stloc.s    VB$CG$t_bool$S0
      IL_018b:  ldloc.s    VB$CG$t_bool$S0
      IL_018d:  brfalse.s  IL_0197

      IL_018f:  ldloc.s    m
      IL_0191:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_0196:  nop
      IL_0197:  nop
      IL_0198:  endfinally
//000061:             End If
    }  // end handler
    IL_0199:  nop
//000062: 
//000063:             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
//000064:             ' in the original and in the new images.
//000065:             Using fastColorizedImage As New FastBitmap(colorizedImage)
    IL_019a:  nop
//000066:                 Using fastOriginalImage As New FastBitmap(original)
//000067:                     ' Extract the selected hues from the selected pixels.
//000068:                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
//000069:                     For Each p In selectedPixels
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_019b:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2::.ctor()
    IL_01a0:  stloc.s    $VB$Closure_ClosureVariable_40_C
//000065:             Using fastColorizedImage As New FastBitmap(colorizedImage)
    IL_01a2:  ldloc.s    $VB$Closure_ClosureVariable_40_C
    IL_01a4:  ldloc.2
    IL_01a5:  newobj     instance void [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::.ctor(class [System.Drawing]System.Drawing.Bitmap)
    IL_01aa:  stfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2::$VB$Local_fastColorizedImage
//000066:                 Using fastOriginalImage As New FastBitmap(original)
//000067:                     ' Extract the selected hues from the selected pixels.
//000068:                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
//000069:                     For Each p In selectedPixels
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_01af:  nop
//000066:                 Using fastOriginalImage As New FastBitmap(original)
    .try
    {
      IL_01b0:  nop
//000067:                     ' Extract the selected hues from the selected pixels.
//000068:                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
//000069:                     For Each p In selectedPixels
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
      IL_01b1:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3::.ctor()
      IL_01b6:  stloc.s    $VB$Closure_ClosureVariable_41_10
//000066:                 Using fastOriginalImage As New FastBitmap(original)
      IL_01b8:  ldloc.s    $VB$Closure_ClosureVariable_41_10
      IL_01ba:  ldarg.1
      IL_01bb:  newobj     instance void [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::.ctor(class [System.Drawing]System.Drawing.Bitmap)
      IL_01c0:  stfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3::$VB$Local_fastOriginalImage
//000067:                     ' Extract the selected hues from the selected pixels.
//000068:                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
//000069:                     For Each p In selectedPixels
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
      IL_01c5:  nop
      .try
      {
        IL_01c6:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::.ctor()
        IL_01cb:  stloc.s    $VB$Closure_ClosureVariable_FEEFED_0
        IL_01cd:  ldloc.s    $VB$Closure_ClosureVariable_FEEFED_0
        IL_01cf:  ldloc.s    $VB$Closure_ClosureVariable_41_10
        IL_01d1:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_41_10
        IL_01d6:  ldloc.s    $VB$Closure_ClosureVariable_FEEFED_0
        IL_01d8:  ldloc.s    $VB$Closure_ClosureVariable_40_C
        IL_01da:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_40_C
        IL_01df:  ldloc.s    $VB$Closure_ClosureVariable_FEEFED_0
        IL_01e1:  ldloc.0
        IL_01e2:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$NonLocal_$VB$Closure_ClosureVariable_1E_56
//000068:                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
        IL_01e7:  ldloc.s    $VB$Closure_ClosureVariable_FEEFED_0
        IL_01e9:  ldarg.2
        IL_01ea:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::get_Count()
        IL_01ef:  newobj     instance void class [mscorlib]System.Collections.Generic.List`1<float32>::.ctor(int32)
        IL_01f4:  stfld      class [mscorlib]System.Collections.Generic.List`1<float32> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_selectedHues
//000069:                     For Each p In selectedPixels
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
        IL_01f9:  nop
//000069:                     For Each p In selectedPixels
        .try
        {
          IL_01fa:  ldarg.2
          IL_01fb:  callvirt   instance valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<!0> class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::GetEnumerator()
          IL_0200:  stloc.s    VB$t_struct$L0
          IL_0202:  br.s       IL_023e

//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
//000071:                     Next p
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
          IL_0204:  ldloca.s   VB$t_struct$L0
          IL_0206:  call       instance !0 valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<valuetype [System.Drawing]System.Drawing.Point>::get_Current()
          IL_020b:  stloc.s    p
//000070:                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
          IL_020d:  ldloc.s    $VB$Closure_ClosureVariable_FEEFED_0
          IL_020f:  ldfld      class [mscorlib]System.Collections.Generic.List`1<float32> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_selectedHues
          IL_0214:  ldloc.s    $VB$Closure_ClosureVariable_41_10
          IL_0216:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3::$VB$Local_fastOriginalImage
          IL_021b:  ldloca.s   p
          IL_021d:  call       instance int32 [System.Drawing]System.Drawing.Point::get_X()
          IL_0222:  ldloca.s   p
          IL_0224:  call       instance int32 [System.Drawing]System.Drawing.Point::get_Y()
          IL_0229:  callvirt   instance valuetype [System.Drawing]System.Drawing.Color [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::GetColor(int32,
                                                                                                                                                        int32)
          IL_022e:  stloc.s    VB$t_struct$S1
          IL_0230:  ldloca.s   VB$t_struct$S1
          IL_0232:  call       instance float32 [System.Drawing]System.Drawing.Color::GetHue()
          IL_0237:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<float32>::Add(!0)
          IL_023c:  nop
//000071:                     Next p
          IL_023d:  nop
//000072: 
//000073:                     ' For progress update purposes, figure out how many pixels there
//000074:                     ' are in total, and how many constitute 1% so that we can raise
//000075:                     ' events after every additional 1% has been completed.
//000076:                     Dim totalPixels = height * width
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
//000078:                     If pixelsPerProgressUpdate = 0 Then
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
          IL_023e:  ldloca.s   VB$t_struct$L0
          IL_0240:  call       instance bool valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<valuetype [System.Drawing]System.Drawing.Point>::MoveNext()
          IL_0245:  stloc.s    VB$CG$t_bool$S0
          IL_0247:  ldloc.s    VB$CG$t_bool$S0
          IL_0249:  brtrue.s   IL_0204

          IL_024b:  nop
          IL_024c:  leave.s    IL_025d

        }  // end .try
        finally
        {
          IL_024e:  ldloca.s   VB$t_struct$L0
          IL_0250:  constrained. valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<valuetype [System.Drawing]System.Drawing.Point>
          IL_0256:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
          IL_025b:  nop
          IL_025c:  endfinally
//000076:                     Dim totalPixels = height * width
        }  // end handler
        IL_025d:  ldloc.s    $VB$Closure_ClosureVariable_FEEFED_0
        IL_025f:  ldloc.3
        IL_0260:  ldloc.0
        IL_0261:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_width
        IL_0266:  mul.ovf
        IL_0267:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_totalPixels
//000077:                     Dim pixelsPerProgressUpdate = totalPixels \ 100
        IL_026c:  ldloc.s    $VB$Closure_ClosureVariable_FEEFED_0
        IL_026e:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_totalPixels
        IL_0273:  ldc.i4.s   100
        IL_0275:  div
        IL_0276:  stloc.s    pixelsPerProgressUpdate
//000078:                     If pixelsPerProgressUpdate = 0 Then
        IL_0278:  ldloc.s    pixelsPerProgressUpdate
        IL_027a:  ldc.i4.0
        IL_027b:  ceq
        IL_027d:  stloc.s    VB$CG$t_bool$S0
//000079:                         pixelsPerProgressUpdate = 1
//000080:                     End If
//000081:                     Dim pixelsProcessed = 0
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
        IL_027f:  ldloc.s    VB$CG$t_bool$S0
        IL_0281:  brfalse.s  IL_0286

//000079:                         pixelsPerProgressUpdate = 1
        IL_0283:  ldc.i4.1
        IL_0284:  stloc.s    pixelsPerProgressUpdate
//000080:                     End If
        IL_0286:  nop
//000081:                     Dim pixelsProcessed = 0
        IL_0287:  ldloc.s    $VB$Closure_ClosureVariable_FEEFED_0
        IL_0289:  ldc.i4.0
        IL_028a:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_pixelsProcessed
//000082: 
//000083:                     ' Pixels close to the selected hue but not close enough may be
//000084:                     ' left partially desaturated.  The saturation window determines
//000085:                     ' what pixels fall into that range.
//000086:                     Const maxSaturationWindow = 10
//000087:                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
        IL_028f:  ldloc.s    $VB$Closure_ClosureVariable_FEEFED_0
        IL_0291:  ldc.i4.s   10
        IL_0293:  ldloc.0
        IL_0294:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1::$VB$Local_epsilon
        IL_0299:  call       int32 [mscorlib]System.Math::Min(int32,
                                                              int32)
        IL_029e:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::$VB$Local_saturationWindow
//000088: 
//000089:                     ' Separated out the body of the loop just to make it easier
//000090:                     ' to switch between sequential and parallel for demo purposes.
//000091:                     Dim processRow As Action(Of Integer) = Sub(y)
        IL_02a3:  ldloc.s    $VB$Closure_ClosureVariable_FEEFED_0
        IL_02a5:  dup
        IL_02a6:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3/_Closure$__4::_Lambda$__1(int32)
        IL_02ac:  newobj     instance void class [mscorlib]System.Action`1<int32>::.ctor(object,
                                                                                         native int)
        IL_02b1:  stloc.s    processRow
//000092:                                                                For x = 0 To width - 1
//000093:                                                                    ' Get the color/hue of th epixel.
//000094:                                                                    Dim c = fastOriginalImage.GetColor(x, y)
//000095:                                                                    Dim pixelHue = c.GetHue()
//000096: 
//000097:                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
//000098:                                                                    Dim pixelInSelectedRegion = False
//000099: 
//000100:                                                                    ' First, if there are no paths, by definition it is in the selected
//000101:                                                                    ' region, since the whole image is then selected.
//000102:                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
//000103:                                                                        pixelInSelectedRegion = True
//000104:                                                                    Else
//000105:                                                                        ' For each path, first see if the pixel is within the bounding
//000106:                                                                        ' rectangle; if it's not, it's not in the selected region.
//000107:                                                                        Dim p As New Point(x, y)
//000108:                                                                        Dim i = 0
//000109:                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
//000110:                                                                            If pathsBounds(i).Contains(p) Then
//000111:                                                                                ' The pixel is within a bounding rectangle, so now
//000112:                                                                                ' see if it's within the composition rectangles
//000113:                                                                                ' approximating the region.
//000114:                                                                                For Each bound In compositions(i)
//000115:                                                                                    If bound.Contains(x, y) Then
//000116:                                                                                        ' If it is, it's in the region.
//000117:                                                                                        pixelInSelectedRegion = True
//000118:                                                                                        Exit For
//000119:                                                                                    End If
//000120:                                                                                Next bound
//000121:                                                                            End If
//000122:                                                                            i += 1
//000123:                                                                        Loop
//000124:                                                                    End If
//000125: 
//000126:                                                                    ' Now that we know whether a pixel is in the region,
//000127:                                                                    ' we can figure out what to do with it.  If the pixel
//000128:                                                                    ' is not in the selected region, it needs to be converted
//000129:                                                                    ' to grayscale.
//000130:                                                                    Dim useGrayscale = True
//000131:                                                                    If pixelInSelectedRegion Then
//000132:                                                                        ' If it is in the selected region, get the color hue's distance 
//000133:                                                                        ' from each target hue.  If that distance is less than the user-selected
//000134:                                                                        ' hue variation limit, leave it in color.  If it's greater than the
//000135:                                                                        ' variation limit, but within the saturation window of the limit,
//000136:                                                                        ' desaturate it proportionally to the distance from the limit.
//000137:                                                                        For Each selectedHue In selectedHues
//000138:                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
//000139:                                                                            ' will be two distances between them, depending on which way you go around
//000140:                                                                            ' the wheel from one to the other (unless they're exactly opposite from
//000141:                                                                            ' each other on the wheel, the two distances will be different).  We always
//000142:                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
//000143:                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
//000144:                                                                            ' we take the absolute value of the difference between the two hues.  If that
//000145:                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
//000146:                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
//000147:                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
//000148:                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
//000149:                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
//000150:                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
//000151:                                                                            If distance > 180 Then
//000152:                                                                                distance = 360 - distance
//000153:                                                                            End If
//000154: 
//000155:                                                                            If distance <= epsilon Then
//000156:                                                                                useGrayscale = False
//000157:                                                                                Exit For
//000158:                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
//000159:                                                                                useGrayscale = False
//000160:                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
//000161:                                                                                         c.GetBrightness())
//000162:                                                                                Exit For
//000163:                                                                            End If
//000164:                                                                        Next selectedHue
//000165:                                                                    End If
//000166: 
//000167:                                                                    ' Set the pixel color into the new image.
//000168:                                                                    If useGrayscale Then
//000169:                                                                        c = ToGrayscale(c)
//000170:                                                                    End If
//000171:                                                                    fastColorizedImage.SetColor(x, y, c)
//000172:                                                                Next x
//000173: 
//000174:                                                                ' Notify any listeners of our progress, if enough progress has been made.
//000175:                                                                Interlocked.Add(pixelsProcessed, width)
//000176:                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
//000177:                                                            End Sub
//000178: 
//000179:                     ' Copy over every single pixel, and possibly transform it in the process.
//000180:                     If parallel Then
        IL_02b3:  ldarg.s    parallel
        IL_02b5:  stloc.s    VB$CG$t_bool$S0
//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
//000182:                     Else
//000183:                         For y = 0 To height - 1
//000184:                             processRow(y)
//000185:                         Next y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
        IL_02b7:  ldloc.s    VB$CG$t_bool$S0
        IL_02b9:  brfalse.s  IL_02c7

//000181:                         System.Threading.Tasks.Parallel.For(0, height, processRow)
        IL_02bb:  ldc.i4.0
        IL_02bc:  ldloc.3
        IL_02bd:  ldloc.s    processRow
        IL_02bf:  call       valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult [mscorlib]System.Threading.Tasks.Parallel::For(int32,
                                                                                                                                          int32,
                                                                                                                                          class [mscorlib]System.Action`1<int32>)
        IL_02c4:  pop
        IL_02c5:  br.s       IL_02ed

//000182:                     Else
        IL_02c7:  nop
//000183:                         For y = 0 To height - 1
        IL_02c8:  ldc.i4.0
        IL_02c9:  ldloc.3
        IL_02ca:  ldc.i4.1
        IL_02cb:  sub.ovf
        IL_02cc:  stloc.s    VB$t_i4$L2
        IL_02ce:  stloc.s    y
        IL_02d0:  br.s       IL_02e3

//000184:                             processRow(y)
        IL_02d2:  ldloc.s    processRow
        IL_02d4:  ldloc.s    y
        IL_02d6:  callvirt   instance void class [mscorlib]System.Action`1<int32>::Invoke(!0)
        IL_02db:  nop
//000185:                         Next y
        IL_02dc:  nop
        IL_02dd:  ldloc.s    y
        IL_02df:  ldc.i4.1
        IL_02e0:  add.ovf
        IL_02e1:  stloc.s    y
//000186:                     End If
//000187:                 End Using
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
        IL_02e3:  ldloc.s    y
        IL_02e5:  ldloc.s    VB$t_i4$L2
        IL_02e7:  stloc.s    VB$CG$t_i4$S0
        IL_02e9:  ldloc.s    VB$CG$t_i4$S0
        IL_02eb:  ble.s      IL_02d2

//000186:                     End If
        IL_02ed:  nop
//000187:                 End Using
        IL_02ee:  nop
//000188:             End Using
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
        IL_02ef:  leave.s    IL_0313

      }  // end .try
      finally
      {
        IL_02f1:  ldloc.s    $VB$Closure_ClosureVariable_41_10
        IL_02f3:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3::$VB$Local_fastOriginalImage
        IL_02f8:  ldnull
        IL_02f9:  ceq
        IL_02fb:  ldc.i4.0
        IL_02fc:  ceq
        IL_02fe:  stloc.s    VB$CG$t_bool$S0
        IL_0300:  ldloc.s    VB$CG$t_bool$S0
        IL_0302:  brfalse.s  IL_0311

        IL_0304:  ldloc.s    $VB$Closure_ClosureVariable_41_10
        IL_0306:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2/_Closure$__3::$VB$Local_fastOriginalImage
        IL_030b:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_0310:  nop
        IL_0311:  nop
        IL_0312:  endfinally
//000188:             End Using
      }  // end handler
      IL_0313:  nop
//000189: 
//000190:             ' We're done creating the image.  Return it.
//000191:             Return colorizedImage
//000192:         End Function
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
      IL_0314:  leave.s    IL_0338

    }  // end .try
    finally
    {
      IL_0316:  ldloc.s    $VB$Closure_ClosureVariable_40_C
      IL_0318:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2::$VB$Local_fastColorizedImage
      IL_031d:  ldnull
      IL_031e:  ceq
      IL_0320:  ldc.i4.0
      IL_0321:  ceq
      IL_0323:  stloc.s    VB$CG$t_bool$S0
      IL_0325:  ldloc.s    VB$CG$t_bool$S0
      IL_0327:  brfalse.s  IL_0336

      IL_0329:  ldloc.s    $VB$Closure_ClosureVariable_40_C
      IL_032b:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation/_Closure$__1/_Closure$__2::$VB$Local_fastColorizedImage
      IL_0330:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_0335:  nop
      IL_0336:  nop
      IL_0337:  endfinally
//000191:             Return colorizedImage
    }  // end handler
    IL_0338:  ldloc.2
    IL_0339:  stloc.1
    IL_033a:  br.s       IL_033c

//000192:         End Function
    IL_033c:  ldloc.1
    IL_033d:  ret
  } // end of method ImageManipulation::Colorize

  .method private instance void  OnProgressChanged(int32 progressPercentage) cil managed
  {
    // Code size       36 (0x24)
    .maxstack  4
    .locals init ([0] class [System]System.ComponentModel.ProgressChangedEventHandler VB$t_ref$S0,
             [1] bool VB$CG$t_bool$S0)
//000193: 
//000194:         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
//000195:         ''' <param name="progressPercentage">The progress percentage.</param>
//000196:         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
    IL_0000:  nop
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
//000198:         End Sub
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
//000206:         End Function
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
//000218:             If 0.0F > h OrElse 360.0F < h Then
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System]System.ComponentModel.ProgressChangedEventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::ProgressChangedEvent
    IL_0007:  stloc.0
//000197:             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
    IL_0008:  ldloc.0
    IL_0009:  ldnull
    IL_000a:  ceq
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  stloc.1
    IL_0010:  ldloc.1
    IL_0011:  brfalse.s  IL_0022

    IL_0013:  ldloc.0
    IL_0014:  ldarg.0
    IL_0015:  ldarg.1
    IL_0016:  ldnull
    IL_0017:  newobj     instance void [System]System.ComponentModel.ProgressChangedEventArgs::.ctor(int32,
                                                                                                     object)
    IL_001c:  callvirt   instance void [System]System.ComponentModel.ProgressChangedEventHandler::Invoke(object,
                                                                                                         class [System]System.ComponentModel.ProgressChangedEventArgs)
    IL_0021:  nop
//000198:         End Sub
    IL_0022:  nop
    IL_0023:  ret
  } // end of method ImageManipulation::OnProgressChanged

  .method private static valuetype [System.Drawing]System.Drawing.Color 
          ToGrayscale(valuetype [System.Drawing]System.Drawing.Color c) cil managed
  {
    // Code size       82 (0x52)
    .maxstack  3
    .locals init ([0] int32 luminance,
             [1] valuetype [System.Drawing]System.Drawing.Color ToGrayscale)
//000199: 
//000200:         ''' <summary>Converts a color to grayscale.</summary>
//000201:         ''' <param name="c">The color to convert.</param>
//000202:         ''' <returns>The grayscale color.</returns>
//000203:         Private Shared Function ToGrayscale(ByVal c As Color) As Color
    IL_0000:  nop
//000204:             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
    IL_0001:  ldc.r8     0.29899999999999999
    IL_000a:  ldarga.s   c
    IL_000c:  call       instance uint8 [System.Drawing]System.Drawing.Color::get_R()
    IL_0011:  conv.r8
    IL_0012:  mul
    IL_0013:  ldc.r8     0.58699999999999997
    IL_001c:  ldarga.s   c
    IL_001e:  call       instance uint8 [System.Drawing]System.Drawing.Color::get_G()
    IL_0023:  conv.r8
    IL_0024:  mul
    IL_0025:  add
    IL_0026:  ldc.r8     0.114
    IL_002f:  ldarga.s   c
    IL_0031:  call       instance uint8 [System.Drawing]System.Drawing.Color::get_B()
    IL_0036:  conv.r8
    IL_0037:  mul
    IL_0038:  add
    IL_0039:  call       float64 [Microsoft.VisualBasic]Microsoft.VisualBasic.Conversion::Fix(float64)
    IL_003e:  call       float64 [mscorlib]System.Math::Round(float64)
    IL_0043:  conv.ovf.i4
    IL_0044:  stloc.0
//000205:             Return Color.FromArgb(luminance, luminance, luminance)
    IL_0045:  ldloc.0
    IL_0046:  ldloc.0
    IL_0047:  ldloc.0
    IL_0048:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_004d:  stloc.1
    IL_004e:  br.s       IL_0050

//000206:         End Function
    IL_0050:  ldloc.1
    IL_0051:  ret
  } // end of method ImageManipulation::ToGrayscale

  .method private static valuetype [System.Drawing]System.Drawing.Color 
          ColorFromHsb(float32 h,
                       float32 s,
                       float32 b) cil managed
  {
    // Code size       579 (0x243)
    .maxstack  4
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Color ColorFromHsb,
             [1] float32 fMax,
             [2] float32 fMid,
             [3] float32 fMin,
             [4] int32 iMax,
             [5] int32 iMid,
             [6] int32 iMin,
             [7] int32 iSextant,
             [8] int32 VB$t_i4$L0,
             [9] bool VB$CG$t_bool$S0,
             [10] int32 VB$CG$t_i4$S0)
//000207: 
//000208:         ''' <summary>HSB to RGB color conversion.</summary>
//000209:         ''' <param name="h">The color's hue.</param>
//000210:         ''' <param name="s">The color's saturation.</param>
//000211:         ''' <param name="b">The color's brightness.</param>
//000212:         ''' <returns>The RGB color for the supplied HSB values.</returns>
//000213:         ''' <remarks>
//000214:         ''' Based on Chris Jackson's conversion routine from:
//000215:         ''' http://blogs.msdn.com/cjacks/archive/2006/04/12/575476.aspx
//000216:         ''' </remarks>
//000217:         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
    IL_0000:  nop
//000218:             If 0.0F > h OrElse 360.0F < h Then
    IL_0001:  ldc.r4     0.0
    IL_0006:  ldarg.0
    IL_0007:  bgt.s      IL_0014

    IL_0009:  ldc.r4     360.
    IL_000e:  ldarg.0
    IL_000f:  blt.s      IL_0014

    IL_0011:  ldc.i4.0
    IL_0012:  br.s       IL_0015

    IL_0014:  ldc.i4.1
    IL_0015:  stloc.s    VB$CG$t_bool$S0
//000219:                 Throw New ArgumentOutOfRangeException("h")
//000220:             End If
//000221:             If 0.0F > s OrElse 1.0F < s Then
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_0017:  ldloc.s    VB$CG$t_bool$S0
    IL_0019:  brfalse.s  IL_0026

//000219:                 Throw New ArgumentOutOfRangeException("h")
    IL_001b:  ldstr      "h"
    IL_0020:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string)
    IL_0025:  throw

//000220:             End If
    IL_0026:  nop
//000221:             If 0.0F > s OrElse 1.0F < s Then
    IL_0027:  ldc.r4     0.0
    IL_002c:  ldarg.1
    IL_002d:  bgt.s      IL_003a

    IL_002f:  ldc.r4     1.
    IL_0034:  ldarg.1
    IL_0035:  blt.s      IL_003a

    IL_0037:  ldc.i4.0
    IL_0038:  br.s       IL_003b

    IL_003a:  ldc.i4.1
    IL_003b:  stloc.s    VB$CG$t_bool$S0
//000222:                 Throw New ArgumentOutOfRangeException("s")
//000223:             End If
//000224:             If 0.0F > b OrElse 1.0F < b Then
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_003d:  ldloc.s    VB$CG$t_bool$S0
    IL_003f:  brfalse.s  IL_004c

//000222:                 Throw New ArgumentOutOfRangeException("s")
    IL_0041:  ldstr      "s"
    IL_0046:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string)
    IL_004b:  throw

//000223:             End If
    IL_004c:  nop
//000224:             If 0.0F > b OrElse 1.0F < b Then
    IL_004d:  ldc.r4     0.0
    IL_0052:  ldarg.2
    IL_0053:  bgt.s      IL_0060

    IL_0055:  ldc.r4     1.
    IL_005a:  ldarg.2
    IL_005b:  blt.s      IL_0060

    IL_005d:  ldc.i4.0
    IL_005e:  br.s       IL_0061

    IL_0060:  ldc.i4.1
    IL_0061:  stloc.s    VB$CG$t_bool$S0
//000225:                 Throw New ArgumentOutOfRangeException("b")
//000226:             End If
//000227: 
//000228:             If 0 = s Then
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_0063:  ldloc.s    VB$CG$t_bool$S0
    IL_0065:  brfalse.s  IL_0072

//000225:                 Throw New ArgumentOutOfRangeException("b")
    IL_0067:  ldstr      "b"
    IL_006c:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string)
    IL_0071:  throw

//000226:             End If
    IL_0072:  nop
//000227: 
//000228:             If 0 = s Then
    IL_0073:  ldc.r4     0.0
    IL_0078:  ldarg.1
    IL_0079:  ceq
    IL_007b:  stloc.s    VB$CG$t_bool$S0
//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
//000230:             End If
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_007d:  ldloc.s    VB$CG$t_bool$S0
    IL_007f:  brfalse.s  IL_00c5

//000229:                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
    IL_0081:  ldarg.2
    IL_0082:  ldc.r4     255.
    IL_0087:  mul
    IL_0088:  call       float32 [Microsoft.VisualBasic]Microsoft.VisualBasic.Conversion::Fix(float32)
    IL_008d:  conv.r8
    IL_008e:  call       float64 [mscorlib]System.Math::Round(float64)
    IL_0093:  conv.ovf.i4
    IL_0094:  ldarg.2
    IL_0095:  ldc.r4     255.
    IL_009a:  mul
    IL_009b:  call       float32 [Microsoft.VisualBasic]Microsoft.VisualBasic.Conversion::Fix(float32)
    IL_00a0:  conv.r8
    IL_00a1:  call       float64 [mscorlib]System.Math::Round(float64)
    IL_00a6:  conv.ovf.i4
    IL_00a7:  ldarg.2
    IL_00a8:  ldc.r4     255.
    IL_00ad:  mul
    IL_00ae:  call       float32 [Microsoft.VisualBasic]Microsoft.VisualBasic.Conversion::Fix(float32)
    IL_00b3:  conv.r8
    IL_00b4:  call       float64 [mscorlib]System.Math::Round(float64)
    IL_00b9:  conv.ovf.i4
    IL_00ba:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_00bf:  stloc.0
    IL_00c0:  br         IL_0241

//000230:             End If
    IL_00c5:  nop
//000231: 
//000232:             Dim fMax, fMid, fMin As Single
//000233:             Dim iSextant, iMax, iMid, iMin As Integer
//000234: 
//000235:             If 0.5 < b Then
    IL_00c6:  ldc.r8     0.5
    IL_00cf:  ldarg.2
    IL_00d0:  conv.r8
    IL_00d1:  clt
    IL_00d3:  stloc.s    VB$CG$t_bool$S0
//000236:                 fMax = b - (b * s) + s
//000237:                 fMin = b + (b * s) - s
//000238:             Else
//000239:                 fMax = b + (b * s)
//000240:                 fMin = b - (b * s)
//000241:             End If
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
//000244:             If 300.0F <= h Then
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_00d5:  ldloc.s    VB$CG$t_bool$S0
    IL_00d7:  brfalse.s  IL_00eb

//000236:                 fMax = b - (b * s) + s
    IL_00d9:  ldarg.2
    IL_00da:  ldarg.2
    IL_00db:  ldarg.1
    IL_00dc:  mul
    IL_00dd:  sub
    IL_00de:  ldarg.1
    IL_00df:  add
    IL_00e0:  stloc.1
//000237:                 fMin = b + (b * s) - s
    IL_00e1:  ldarg.2
    IL_00e2:  ldarg.2
    IL_00e3:  ldarg.1
    IL_00e4:  mul
    IL_00e5:  add
    IL_00e6:  ldarg.1
    IL_00e7:  sub
    IL_00e8:  stloc.3
    IL_00e9:  br.s       IL_00f8

//000238:             Else
    IL_00eb:  nop
//000239:                 fMax = b + (b * s)
    IL_00ec:  ldarg.2
    IL_00ed:  ldarg.2
    IL_00ee:  ldarg.1
    IL_00ef:  mul
    IL_00f0:  add
    IL_00f1:  stloc.1
//000240:                 fMin = b - (b * s)
    IL_00f2:  ldarg.2
    IL_00f3:  ldarg.2
    IL_00f4:  ldarg.1
    IL_00f5:  mul
    IL_00f6:  sub
    IL_00f7:  stloc.3
//000241:             End If
    IL_00f8:  nop
//000242: 
//000243:             iSextant = CInt(Fix(h / 60.0F))
    IL_00f9:  ldarg.0
    IL_00fa:  ldc.r4     60.
    IL_00ff:  div
    IL_0100:  call       float32 [Microsoft.VisualBasic]Microsoft.VisualBasic.Conversion::Fix(float32)
    IL_0105:  conv.r8
    IL_0106:  call       float64 [mscorlib]System.Math::Round(float64)
    IL_010b:  conv.ovf.i4
    IL_010c:  stloc.s    iSextant
//000244:             If 300.0F <= h Then
    IL_010e:  ldc.r4     300.
    IL_0113:  ldarg.0
    IL_0114:  cgt.un
    IL_0116:  ldc.i4.0
    IL_0117:  ceq
    IL_0119:  stloc.s    VB$CG$t_bool$S0
//000245:                 h -= 360.0F
//000246:             End If
//000247:             h /= 60.0F
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
//000249:             If 0 = iSextant Mod 2 Then
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_011b:  ldloc.s    VB$CG$t_bool$S0
    IL_011d:  brfalse.s  IL_0128

//000245:                 h -= 360.0F
    IL_011f:  ldarg.0
    IL_0120:  ldc.r4     360.
    IL_0125:  sub
    IL_0126:  starg.s    h
//000246:             End If
    IL_0128:  nop
//000247:             h /= 60.0F
    IL_0129:  ldarg.0
    IL_012a:  ldc.r4     60.
    IL_012f:  div
    IL_0130:  starg.s    h
//000248:             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
    IL_0132:  ldarg.0
    IL_0133:  ldc.r4     2.
    IL_0138:  ldloc.s    iSextant
    IL_013a:  conv.r4
    IL_013b:  ldc.r4     1.
    IL_0140:  add
    IL_0141:  ldc.r4     6.
    IL_0146:  rem
    IL_0147:  ldc.r4     2.
    IL_014c:  div
    IL_014d:  conv.r8
    IL_014e:  call       float64 [mscorlib]System.Math::Floor(float64)
    IL_0153:  conv.r4
    IL_0154:  mul
    IL_0155:  sub
    IL_0156:  starg.s    h
//000249:             If 0 = iSextant Mod 2 Then
    IL_0158:  ldc.i4.0
    IL_0159:  ldloc.s    iSextant
    IL_015b:  ldc.i4.2
    IL_015c:  rem
    IL_015d:  ceq
    IL_015f:  stloc.s    VB$CG$t_bool$S0
//000250:                 fMid = h * (fMax - fMin) + fMin
//000251:             Else
//000252:                 fMid = fMin - h * (fMax - fMin)
//000253:             End If
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
//000256:             iMid = CInt(Fix(fMid * 255))
//000257:             iMin = CInt(Fix(fMin * 255))
//000258: 
//000259:             Select Case iSextant
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_0161:  ldloc.s    VB$CG$t_bool$S0
    IL_0163:  brfalse.s  IL_016f

//000250:                 fMid = h * (fMax - fMin) + fMin
    IL_0165:  ldarg.0
    IL_0166:  ldloc.1
    IL_0167:  ldloc.3
    IL_0168:  sub
    IL_0169:  mul
    IL_016a:  ldloc.3
    IL_016b:  add
    IL_016c:  stloc.2
    IL_016d:  br.s       IL_0178

//000251:             Else
    IL_016f:  nop
//000252:                 fMid = fMin - h * (fMax - fMin)
    IL_0170:  ldloc.3
    IL_0171:  ldarg.0
    IL_0172:  ldloc.1
    IL_0173:  ldloc.3
    IL_0174:  sub
    IL_0175:  mul
    IL_0176:  sub
    IL_0177:  stloc.2
//000253:             End If
    IL_0178:  nop
//000254: 
//000255:             iMax = CInt(Fix(fMax * 255))
    IL_0179:  ldloc.1
    IL_017a:  ldc.r4     255.
    IL_017f:  mul
    IL_0180:  call       float32 [Microsoft.VisualBasic]Microsoft.VisualBasic.Conversion::Fix(float32)
    IL_0185:  conv.r8
    IL_0186:  call       float64 [mscorlib]System.Math::Round(float64)
    IL_018b:  conv.ovf.i4
    IL_018c:  stloc.s    iMax
//000256:             iMid = CInt(Fix(fMid * 255))
    IL_018e:  ldloc.2
    IL_018f:  ldc.r4     255.
    IL_0194:  mul
    IL_0195:  call       float32 [Microsoft.VisualBasic]Microsoft.VisualBasic.Conversion::Fix(float32)
    IL_019a:  conv.r8
    IL_019b:  call       float64 [mscorlib]System.Math::Round(float64)
    IL_01a0:  conv.ovf.i4
    IL_01a1:  stloc.s    iMid
//000257:             iMin = CInt(Fix(fMin * 255))
    IL_01a3:  ldloc.3
    IL_01a4:  ldc.r4     255.
    IL_01a9:  mul
    IL_01aa:  call       float32 [Microsoft.VisualBasic]Microsoft.VisualBasic.Conversion::Fix(float32)
    IL_01af:  conv.r8
    IL_01b0:  call       float64 [mscorlib]System.Math::Round(float64)
    IL_01b5:  conv.ovf.i4
    IL_01b6:  stloc.s    iMin
//000258: 
//000259:             Select Case iSextant
    IL_01b8:  nop
    IL_01b9:  ldloc.s    iSextant
    IL_01bb:  ldc.i4.1
    IL_01bc:  sub
    IL_01bd:  stloc.s    VB$CG$t_i4$S0
//000260:                 Case 1
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
//000262:                 Case 2
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
//000264:                 Case 3
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
//000266:                 Case 4
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
//000268:                 Case 5
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
//000270:                 Case Else
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
//000272:             End Select
//000273:         End Function
//000274:     End Class
//000275: End Namespace
    IL_01bf:  ldloc.s    VB$CG$t_i4$S0
    IL_01c1:  switch     ( 
                          IL_01dc,
                          IL_01ed,
                          IL_01fe,
                          IL_020f,
                          IL_0220)
    IL_01da:  br.s       IL_0231

//000260:                 Case 1
    IL_01dc:  nop
//000261:                     Return Color.FromArgb(iMid, iMax, iMin)
    IL_01dd:  ldloc.s    iMid
    IL_01df:  ldloc.s    iMax
    IL_01e1:  ldloc.s    iMin
    IL_01e3:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_01e8:  stloc.0
    IL_01e9:  br.s       IL_0241

    IL_01eb:  br.s       IL_0240

//000262:                 Case 2
    IL_01ed:  nop
//000263:                     Return Color.FromArgb(iMin, iMax, iMid)
    IL_01ee:  ldloc.s    iMin
    IL_01f0:  ldloc.s    iMax
    IL_01f2:  ldloc.s    iMid
    IL_01f4:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_01f9:  stloc.0
    IL_01fa:  br.s       IL_0241

    IL_01fc:  br.s       IL_0240

//000264:                 Case 3
    IL_01fe:  nop
//000265:                     Return Color.FromArgb(iMin, iMid, iMax)
    IL_01ff:  ldloc.s    iMin
    IL_0201:  ldloc.s    iMid
    IL_0203:  ldloc.s    iMax
    IL_0205:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_020a:  stloc.0
    IL_020b:  br.s       IL_0241

    IL_020d:  br.s       IL_0240

//000266:                 Case 4
    IL_020f:  nop
//000267:                     Return Color.FromArgb(iMid, iMin, iMax)
    IL_0210:  ldloc.s    iMid
    IL_0212:  ldloc.s    iMin
    IL_0214:  ldloc.s    iMax
    IL_0216:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_021b:  stloc.0
    IL_021c:  br.s       IL_0241

    IL_021e:  br.s       IL_0240

//000268:                 Case 5
    IL_0220:  nop
//000269:                     Return Color.FromArgb(iMax, iMin, iMid)
    IL_0221:  ldloc.s    iMax
    IL_0223:  ldloc.s    iMin
    IL_0225:  ldloc.s    iMid
    IL_0227:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_022c:  stloc.0
    IL_022d:  br.s       IL_0241

    IL_022f:  br.s       IL_0240

//000270:                 Case Else
    IL_0231:  nop
//000271:                     Return Color.FromArgb(iMax, iMid, iMin)
    IL_0232:  ldloc.s    iMax
    IL_0234:  ldloc.s    iMid
    IL_0236:  ldloc.s    iMin
    IL_0238:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_023d:  stloc.0
    IL_023e:  br.s       IL_0241

//000272:             End Select
    IL_0240:  nop
//000273:         End Function
    IL_0241:  ldloc.0
    IL_0242:  ret
  } // end of method ImageManipulation::ColorFromHsb

  .event [System]System.ComponentModel.ProgressChangedEventHandler ProgressChanged
  {
    .addon instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::add_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler)
    .removeon instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::remove_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler)
  } // end of event ImageManipulation::ProgressChanged
} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation

.class public auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm
       extends [System.Windows.Forms]System.Windows.Forms.Form
{
  .field private static class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> __ENCList
  .field private class [System]System.ComponentModel.IContainer components
  .field private class [System]System.ComponentModel.BackgroundWorker _bwColorize
  .custom instance void [mscorlib]System.Runtime.CompilerServices.AccessedThroughPropertyAttribute::.ctor(string) = ( 01 00 0A 62 77 43 6F 6C 6F 72 69 7A 65 00 00 )    // ...bwColorize..
  .field private class [System.Windows.Forms]System.Windows.Forms.Timer _tmRefresh
  .custom instance void [mscorlib]System.Runtime.CompilerServices.AccessedThroughPropertyAttribute::.ctor(string) = ( 01 00 09 74 6D 52 65 66 72 65 73 68 00 00 )       // ...tmRefresh..
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer toolStripContainer
  .field private class [System.Windows.Forms]System.Windows.Forms.PictureBox _pbImage
  .custom instance void [mscorlib]System.Runtime.CompilerServices.AccessedThroughPropertyAttribute::.ctor(string) = ( 01 00 07 70 62 49 6D 61 67 65 00 00 )             // ...pbImage..
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStrip toolStripMain
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripButton _btnLoadImage
  .custom instance void [mscorlib]System.Runtime.CompilerServices.AccessedThroughPropertyAttribute::.ctor(string) = ( 01 00 0C 62 74 6E 4C 6F 61 64 49 6D 61 67 65 00   // ...btnLoadImage.
                                                                                                                      00 ) 
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripButton _btnSaveImage
  .custom instance void [mscorlib]System.Runtime.CompilerServices.AccessedThroughPropertyAttribute::.ctor(string) = ( 01 00 0C 62 74 6E 53 61 76 65 49 6D 61 67 65 00   // ...btnSaveImage.
                                                                                                                      00 ) 
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator separator1
  .field private class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar _tbEpsilon
  .custom instance void [mscorlib]System.Runtime.CompilerServices.AccessedThroughPropertyAttribute::.ctor(string) = ( 01 00 09 74 62 45 70 73 69 6C 6F 6E 00 00 )       // ...tbEpsilon..
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator separator2
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripButton _btnInk
  .custom instance void [mscorlib]System.Runtime.CompilerServices.AccessedThroughPropertyAttribute::.ctor(string) = ( 01 00 06 62 74 6E 49 6E 6B 00 00 )                // ...btnInk..
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripButton _btnEraser
  .custom instance void [mscorlib]System.Runtime.CompilerServices.AccessedThroughPropertyAttribute::.ctor(string) = ( 01 00 09 62 74 6E 45 72 61 73 65 72 00 00 )       // ...btnEraser..
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar pbColorizing
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel _lblHuesSelected
  .custom instance void [mscorlib]System.Runtime.CompilerServices.AccessedThroughPropertyAttribute::.ctor(string) = ( 01 00 0F 6C 62 6C 48 75 65 73 53 65 6C 65 63 74   // ...lblHuesSelect
                                                                                                                      65 64 00 00 )                                     // ed..
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripButton _btnParallel
  .custom instance void [mscorlib]System.Runtime.CompilerServices.AccessedThroughPropertyAttribute::.ctor(string) = ( 01 00 0B 62 74 6E 50 61 72 61 6C 6C 65 6C 00 00 ) // ...btnParallel..
  .field private class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> _selectedPixels
  .field private int32 _lastEpsilon
  .field private valuetype [System.Drawing]System.Drawing.Size _lastPictureBoxSize
  .field private class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> _paths
  .field private class [System.Drawing]System.Drawing.Bitmap _originalImage
  .field private class [System.Drawing]System.Drawing.Bitmap _colorizedImage
  .field private class [Microsoft.Ink]Microsoft.Ink.InkOverlay _overlay
  .field private class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog _ofd
  .method private specialname rtspecialname static 
          void  .cctor() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       12 (0xc)
    .maxstack  8
    IL_0000:  newobj     instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::.ctor()
    IL_0005:  stsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::__ENCList
    IL_000a:  nop
    IL_000b:  ret
  } // end of method MainForm::.cctor

  .method private static void  __ENCAddToList(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       243 (0xf3)
    .maxstack  4
    .locals init (int32 V_0,
             int32 V_1,
             class [mscorlib]System.WeakReference V_2,
             class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> V_3,
             bool V_4,
             int32 V_5,
             bool V_6,
             bool V_7,
             int32 V_8)
    IL_0000:  nop
    IL_0001:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::__ENCList
    IL_0006:  stloc.3
    IL_0007:  ldc.i4.0
    IL_0008:  stloc.s    V_4
    IL_000a:  nop
    .try
    {
      IL_000b:  ldloc.3
      IL_000c:  ldloca.s   V_4
      IL_000e:  call       void [mscorlib]System.Threading.Monitor::Enter(object,
                                                                          bool&)
      IL_0013:  nop
      IL_0014:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::__ENCList
      IL_0019:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Count()
      IL_001e:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::__ENCList
      IL_0023:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Capacity()
      IL_0028:  ceq
      IL_002a:  stloc.s    V_6
      IL_002c:  ldloc.s    V_6
      IL_002e:  brfalse    IL_00c4

      IL_0033:  ldc.i4.0
      IL_0034:  stloc.0
      IL_0035:  ldc.i4.0
      IL_0036:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::__ENCList
      IL_003b:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Count()
      IL_0040:  ldc.i4.1
      IL_0041:  sub.ovf
      IL_0042:  stloc.s    V_5
      IL_0044:  stloc.1
      IL_0045:  br.s       IL_008e

      IL_0047:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::__ENCList
      IL_004c:  ldloc.1
      IL_004d:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Item(int32)
      IL_0052:  stloc.2
      IL_0053:  ldloc.2
      IL_0054:  callvirt   instance bool [mscorlib]System.WeakReference::get_IsAlive()
      IL_0059:  stloc.s    V_6
      IL_005b:  ldloc.s    V_6
      IL_005d:  brfalse.s  IL_0088

      IL_005f:  ldloc.1
      IL_0060:  ldloc.0
      IL_0061:  ceq
      IL_0063:  ldc.i4.0
      IL_0064:  ceq
      IL_0066:  stloc.s    V_7
      IL_0068:  ldloc.s    V_7
      IL_006a:  brfalse.s  IL_0083

      IL_006c:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::__ENCList
      IL_0071:  ldloc.0
      IL_0072:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::__ENCList
      IL_0077:  ldloc.1
      IL_0078:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Item(int32)
      IL_007d:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::set_Item(int32,
                                                                                                                                           !0)
      IL_0082:  nop
      IL_0083:  nop
      IL_0084:  ldloc.0
      IL_0085:  ldc.i4.1
      IL_0086:  add.ovf
      IL_0087:  stloc.0
      IL_0088:  nop
      IL_0089:  nop
      IL_008a:  ldloc.1
      IL_008b:  ldc.i4.1
      IL_008c:  add.ovf
      IL_008d:  stloc.1
      IL_008e:  ldloc.1
      IL_008f:  ldloc.s    V_5
      IL_0091:  stloc.s    V_8
      IL_0093:  ldloc.s    V_8
      IL_0095:  ble.s      IL_0047

      IL_0097:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::__ENCList
      IL_009c:  ldloc.0
      IL_009d:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::__ENCList
      IL_00a2:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Count()
      IL_00a7:  ldloc.0
      IL_00a8:  sub.ovf
      IL_00a9:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::RemoveRange(int32,
                                                                                                                                              int32)
      IL_00ae:  nop
      IL_00af:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::__ENCList
      IL_00b4:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::__ENCList
      IL_00b9:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Count()
      IL_00be:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::set_Capacity(int32)
      IL_00c3:  nop
      IL_00c4:  nop
      IL_00c5:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::__ENCList
      IL_00ca:  ldarg.0
      IL_00cb:  call       object [mscorlib]System.Runtime.CompilerServices.RuntimeHelpers::GetObjectValue(object)
      IL_00d0:  newobj     instance void [mscorlib]System.WeakReference::.ctor(object)
      IL_00d5:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::Add(!0)
      IL_00da:  nop
      IL_00db:  nop
      IL_00dc:  leave.s    IL_00f0

    }  // end .try
    finally
    {
      IL_00de:  nop
      IL_00df:  ldloc.s    V_4
      IL_00e1:  stloc.s    V_7
      IL_00e3:  ldloc.s    V_7
      IL_00e5:  brfalse.s  IL_00ee

      IL_00e7:  ldloc.3
      IL_00e8:  call       void [mscorlib]System.Threading.Monitor::Exit(object)
      IL_00ed:  nop
      IL_00ee:  nop
      IL_00ef:  endfinally
    }  // end handler
    IL_00f0:  nop
    IL_00f1:  nop
    IL_00f2:  ret
  } // end of method MainForm::__ENCAddToList

  .method family strict virtual instance void 
          Dispose(bool disposing) cil managed
  {
    // Code size       43 (0x2b)
    .maxstack  2
    .locals init ([0] bool VB$CG$t_bool$S0)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb' 
//000012:         Protected Overrides Sub Dispose(ByVal disposing As Boolean)
    IL_0000:  nop
//000013:             If disposing AndAlso (components IsNot Nothing) Then
    IL_0001:  ldarg.1
    IL_0002:  brfalse.s  IL_000c

    IL_0004:  ldarg.0
    IL_0005:  ldfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
    IL_000a:  brtrue.s   IL_000f

    IL_000c:  ldc.i4.0
    IL_000d:  br.s       IL_0010

    IL_000f:  ldc.i4.1
    IL_0010:  stloc.0
//000014:                 components.Dispose()
//000015:             End If
//000016:             MyBase.Dispose(disposing)
//000017:         End Sub
//000018: 
//000019: #Region "Windows Form Designer generated code"
//000020: 
//000021:         ''' <summary>
//000022:         ''' Required method for Designer support - do not modify
//000023:         ''' the contents of this method with the code editor.
//000024:         ''' </summary>
//000025:         Private Sub InitializeComponent()
//000026:             Me.components = New System.ComponentModel.Container()
//000027:             Dim resources As New System.ComponentModel.ComponentResourceManager(GetType(MainForm))
//000028:             Me.bwColorize = New System.ComponentModel.BackgroundWorker()
//000029:             Me.tmRefresh = New Timer(Me.components)
//000030:             Me.toolStripContainer = New ToolStripContainer()
//000031:             Me.pbImage = New PictureBox()
//000032:             Me.toolStripMain = New ToolStrip()
//000033:             Me.btnLoadImage = New ToolStripButton()
//000034:             Me.btnSaveImage = New ToolStripButton()
//000035:             Me.separator1 = New ToolStripSeparator()
//000036:             Me.tbEpsilon = New Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar()
//000037:             Me.separator2 = New ToolStripSeparator()
//000038:             Me.btnParallel = New ToolStripButton()
//000039:             Me.btnInk = New ToolStripButton()
//000040:             Me.btnEraser = New ToolStripButton()
//000041:             Me.pbColorizing = New ToolStripProgressBar()
//000042:             Me.lblHuesSelected = New ToolStripLabel()
//000043:             Me.toolStripContainer.ContentPanel.SuspendLayout()
//000044:             Me.toolStripContainer.TopToolStripPanel.SuspendLayout()
//000045:             Me.toolStripContainer.SuspendLayout()
//000046:             CType(Me.pbImage, System.ComponentModel.ISupportInitialize).BeginInit()
//000047:             Me.toolStripMain.SuspendLayout()
//000048:             Me.SuspendLayout()
//000049:             ' 
//000050:             ' bwColorize
//000051:             ' 
//000052:             Me.bwColorize.WorkerReportsProgress = True
//000053:             ' Me.bwColorize.DoWork += New System.ComponentModel.DoWorkEventHandler(Me.bwColorize_DoWork)
//000054:             ' Me.bwColorize.RunWorkerCompleted += New System.ComponentModel.RunWorkerCompletedEventHandler(Me.bwColorize_RunWorkerCompleted)
//000055:             ' Me.bwColorize.ProgressChanged += New System.ComponentModel.ProgressChangedEventHandler(Me.bwColorize_ProgressChanged)
//000056:             ' 
//000057:             ' tmRefresh
//000058:             ' 
//000059:             Me.tmRefresh.Interval = 1000
//000060:             '			Me.tmRefresh.Tick += New System.EventHandler(Me.tmRefresh_Tick)
//000061:             ' 
//000062:             ' toolStripContainer
//000063:             ' 
//000064:             ' 
//000065:             ' toolStripContainer.ContentPanel
//000066:             ' 
//000067:             Me.toolStripContainer.ContentPanel.Controls.Add(Me.pbImage)
//000068:             Me.toolStripContainer.ContentPanel.Size = New Size(619, 397)
//000069:             Me.toolStripContainer.Dock = DockStyle.Fill
//000070:             Me.toolStripContainer.Location = New Point(0, 0)
//000071:             Me.toolStripContainer.Name = "toolStripContainer"
//000072:             Me.toolStripContainer.Size = New Size(619, 422)
//000073:             Me.toolStripContainer.TabIndex = 10
//000074:             Me.toolStripContainer.Text = "toolStripContainer1"
//000075:             ' 
//000076:             ' toolStripContainer.TopToolStripPanel
//000077:             ' 
//000078:             Me.toolStripContainer.TopToolStripPanel.Controls.Add(Me.toolStripMain)
//000079:             ' 
//000080:             ' pbImage
//000081:             ' 
//000082:             Me.pbImage.Anchor = (CType((((AnchorStyles.Top Or AnchorStyles.Bottom) Or AnchorStyles.Left) Or AnchorStyles.Right), AnchorStyles))
//000083:             Me.pbImage.BorderStyle = BorderStyle.Fixed3D
//000084:             Me.pbImage.Cursor = Cursors.Default
//000085:             Me.pbImage.Location = New Point(3, 3)
//000086:             Me.pbImage.Name = "pbImage"
//000087:             Me.pbImage.Size = New Size(613, 391)
//000088:             Me.pbImage.SizeMode = PictureBoxSizeMode.StretchImage
//000089:             Me.pbImage.TabIndex = 10
//000090:             Me.pbImage.TabStop = False
//000091:             ' Me.pbImage.DragDrop += New System.Windows.Forms.DragEventHandler(Me.pbImage_DragDrop)
//000092:             ' Me.pbImage.Resize += New System.EventHandler(Me.pbImage_Resize)
//000093:             ' Me.pbImage.MouseClick += New System.Windows.Forms.MouseEventHandler(Me.pbImage_MouseClick)
//000094:             ' Me.pbImage.DragEnter += New System.Windows.Forms.DragEventHandler(Me.pbImage_DragEnter)
//000095:             ' 
//000096:             ' toolStripMain
//000097:             ' 
//000098:             Me.toolStripMain.AllowItemReorder = True
//000099:             Me.toolStripMain.Dock = DockStyle.None
//000100:             Me.toolStripMain.Items.AddRange(New ToolStripItem() {Me.btnLoadImage, Me.btnSaveImage, Me.separator1, Me.tbEpsilon, Me.separator2, Me.btnParallel, _
//000101:                                                                  Me.btnInk, Me.btnEraser, Me.pbColorizing, Me.lblHuesSelected})
//000102:             Me.toolStripMain.LayoutStyle = ToolStripLayoutStyle.HorizontalStackWithOverflow
//000103:             Me.toolStripMain.Location = New Point(3, 0)
//000104:             Me.toolStripMain.Name = "toolStripMain"
//000105:             Me.toolStripMain.Size = New Size(616, 25)
//000106:             Me.toolStripMain.TabIndex = 9
//000107:             Me.toolStripMain.Text = "toolStrip1"
//000108:             ' 
//000109:             ' btnLoadImage
//000110:             ' 
//000111:             Me.btnLoadImage.Image = My.Resources.InsertPictureHS
//000112:             Me.btnLoadImage.ImageTransparentColor = Color.Magenta
//000113:             Me.btnLoadImage.Name = "btnLoadImage"
//000114:             Me.btnLoadImage.Size = New Size(89, 22)
//000115:             Me.btnLoadImage.Text = "&Load Image"
//000116:             ' Me.btnLoadImage.Click += New System.EventHandler(Me.btnLoadImage_Click)
//000117:             '
//000118:             ' btnSaveImage
//000119:             ' 
//000120:             Me.btnSaveImage.Image = My.Resources.saveHS
//000121:             Me.btnSaveImage.ImageTransparentColor = Color.Magenta
//000122:             Me.btnSaveImage.Name = "btnSaveImage"
//000123:             Me.btnSaveImage.Size = New Size(87, 22)
//000124:             Me.btnSaveImage.Text = "&Save Image"
//000125:             ' Me.btnSaveImage.Click += New System.EventHandler(Me.btnSaveImage_Click)
//000126:             ' 
//000127:             ' separator1
//000128:             ' 
//000129:             Me.separator1.Name = "separator1"
//000130:             Me.separator1.Size = New Size(6, 25)
//000131:             ' 
//000132:             ' tbEpsilon
//000133:             ' 
//000134:             Me.tbEpsilon.BackColor = SystemColors.Control
//000135:             Me.tbEpsilon.Maximum = 180
//000136:             Me.tbEpsilon.Name = "tbEpsilon"
//000137:             Me.tbEpsilon.Size = New Size(150, 22)
//000138:             Me.tbEpsilon.Text = "toolStripTrackBar1"
//000139:             Me.tbEpsilon.Value = 15
//000140:             ' Me.tbEpsilon.ValueChanged += New System.EventHandler(Me.tbEpsilon_ValueChanged)
//000141:             ' 
//000142:             ' separator2
//000143:             ' 
//000144:             Me.separator2.Name = "separator2"
//000145:             Me.separator2.Size = New Size(6, 25)
//000146:             ' 
//000147:             ' btnParallel
//000148:             ' 
//000149:             Me.btnParallel.CheckOnClick = True
//000150:             Me.btnParallel.DisplayStyle = ToolStripItemDisplayStyle.Image
//000151:             Me.btnParallel.Image = (CType(resources.GetObject("btnParallel.Image"), Image))
//000152:             Me.btnParallel.ImageTransparentColor = Color.Magenta
//000153:             Me.btnParallel.Name = "btnParallel"
//000154:             Me.btnParallel.Size = New Size(23, 22)
//000155:             Me.btnParallel.Text = "btnParallel"
//000156:             ' Me.btnParallel.CheckedChanged += New System.EventHandler(Me.btnParallel_CheckedChanged)
//000157:             ' 
//000158:             ' btnInk
//000159:             ' 
//000160:             Me.btnInk.DisplayStyle = ToolStripItemDisplayStyle.Image
//000161:             Me.btnInk.Enabled = False
//000162:             Me.btnInk.Image = My.Resources.pen
//000163:             Me.btnInk.ImageTransparentColor = Color.Magenta
//000164:             Me.btnInk.Name = "btnInk"
//000165:             Me.btnInk.Size = New Size(23, 22)
//000166:             Me.btnInk.Text = "btnInk"
//000167:             ' Me.btnInk.Click += New System.EventHandler(Me.btnInk_Click)
//000168:             ' 
//000169:             ' btnEraser
//000170:             ' 
//000171:             Me.btnEraser.DisplayStyle = ToolStripItemDisplayStyle.Image
//000172:             Me.btnEraser.Enabled = False
//000173:             Me.btnEraser.Image = My.Resources.eraser
//000174:             Me.btnEraser.ImageTransparentColor = Color.Magenta
//000175:             Me.btnEraser.Name = "btnEraser"
//000176:             Me.btnEraser.Size = New Size(23, 22)
//000177:             Me.btnEraser.Text = "btnEraser"
//000178:             ' Me.btnEraser.Click += New System.EventHandler(Me.btnEraser_Click)
//000179:             ' 
//000180:             ' pbColorizing
//000181:             ' 
//000182:             Me.pbColorizing.Alignment = ToolStripItemAlignment.Right
//000183:             Me.pbColorizing.Name = "pbColorizing"
//000184:             Me.pbColorizing.Overflow = ToolStripItemOverflow.Never
//000185:             Me.pbColorizing.Size = New Size(140, 22)
//000186:             Me.pbColorizing.Visible = False
//000187:             ' 
//000188:             ' lblHuesSelected
//000189:             ' 
//000190:             Me.lblHuesSelected.Name = "lblHuesSelected"
//000191:             Me.lblHuesSelected.Size = New Size(81, 15)
//000192:             Me.lblHuesSelected.Text = "Hues Selected"
//000193:             ' Me.lblHuesSelected.Click += New System.EventHandler(Me.lblHuesSelected_Click)
//000194:             ' 
//000195:             ' MainForm
//000196:             ' 
//000197:             Me.AutoScaleDimensions = New SizeF(6.0F, 13.0F)
//000198:             Me.AutoScaleMode = AutoScaleMode.Font
//000199:             Me.ClientSize = New Size(619, 422)
//000200:             Me.Controls.Add(Me.toolStripContainer)
//000201:             Me.Icon = (CType(resources.GetObject("$this.Icon"), Icon))
//000202:             Me.KeyPreview = True
//000203:             Me.Name = "MainForm"
//000204:             Me.Text = "Image Colorizer"
//000205:             ' Me.Load += New System.EventHandler(Me.MainForm_Load)
//000206:             Me.toolStripContainer.ContentPanel.ResumeLayout(False)
//000207:             Me.toolStripContainer.TopToolStripPanel.ResumeLayout(False)
//000208:             Me.toolStripContainer.TopToolStripPanel.PerformLayout()
//000209:             Me.toolStripContainer.ResumeLayout(False)
//000210:             Me.toolStripContainer.PerformLayout()
//000211:             CType(Me.pbImage, System.ComponentModel.ISupportInitialize).EndInit()
//000212:             Me.toolStripMain.ResumeLayout(False)
//000213:             Me.toolStripMain.PerformLayout()
//000214:             Me.ResumeLayout(False)
//000215: 
//000216:         End Sub
//000217: 
//000218: #End Region
//000219: 
//000220:         Private WithEvents bwColorize As System.ComponentModel.BackgroundWorker
//000221:         Private WithEvents tmRefresh As Timer
//000222:         Private toolStripContainer As ToolStripContainer
//000223:         Private WithEvents pbImage As PictureBox
//000224:         Private toolStripMain As ToolStrip
//000225:         Private WithEvents btnLoadImage As ToolStripButton
//000226:         Private WithEvents btnSaveImage As ToolStripButton
//000227:         Private separator1 As ToolStripSeparator
//000228:         Private WithEvents tbEpsilon As ToolStripTrackBar
//000229:         Private separator2 As ToolStripSeparator
//000230:         Private WithEvents btnInk As ToolStripButton
//000231:         Private WithEvents btnEraser As ToolStripButton
//000232:         Private pbColorizing As ToolStripProgressBar
//000233:         Private WithEvents lblHuesSelected As ToolStripLabel
//000234:         Private WithEvents btnParallel As ToolStripButton
//000235:     End Class
//000236: End Namespace
//000237: 
    IL_0011:  ldloc.0
    IL_0012:  brfalse.s  IL_0020

//000014:                 components.Dispose()
    IL_0014:  ldarg.0
    IL_0015:  ldfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
    IL_001a:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
    IL_001f:  nop
//000015:             End If
    IL_0020:  nop
//000016:             MyBase.Dispose(disposing)
    IL_0021:  ldarg.0
    IL_0022:  ldarg.1
    IL_0023:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::Dispose(bool)
    IL_0028:  nop
//000017:         End Sub
    IL_0029:  nop
    IL_002a:  ret
  } // end of method MainForm::Dispose

  .method private instance void  InitializeComponent() cil managed
  {
    // Code size       2106 (0x83a)
    .maxstack  4
    .locals init ([0] class [System]System.ComponentModel.ComponentResourceManager resources,
             [1] valuetype [System.Drawing]System.Drawing.Size VB$t_struct$N0,
             [2] valuetype [System.Drawing]System.Drawing.Size VB$t_struct$S1,
             [3] valuetype [System.Drawing]System.Drawing.Point VB$t_struct$N2,
             [4] valuetype [System.Drawing]System.Drawing.Point VB$t_struct$S3,
             [5] class [System.Windows.Forms]System.Windows.Forms.ToolStripItem[] VB$t_array$S0,
             [6] valuetype [System.Drawing]System.Drawing.Color VB$t_struct$N4,
             [7] valuetype [System.Drawing]System.Drawing.SizeF VB$t_struct$N5,
             [8] valuetype [System.Drawing]System.Drawing.SizeF VB$t_struct$S6)
//000018: 
//000019: #Region "Windows Form Designer generated code"
//000020: 
//000021:         ''' <summary>
//000022:         ''' Required method for Designer support - do not modify
//000023:         ''' the contents of this method with the code editor.
//000024:         ''' </summary>
//000025:         Private Sub InitializeComponent()
    IL_0000:  nop
//000026:             Me.components = New System.ComponentModel.Container()
    IL_0001:  ldarg.0
    IL_0002:  newobj     instance void [System]System.ComponentModel.Container::.ctor()
    IL_0007:  stfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
//000027:             Dim resources As New System.ComponentModel.ComponentResourceManager(GetType(MainForm))
    IL_000c:  ldtoken    Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm
    IL_0011:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_0016:  newobj     instance void [System]System.ComponentModel.ComponentResourceManager::.ctor(class [mscorlib]System.Type)
    IL_001b:  stloc.0
//000028:             Me.bwColorize = New System.ComponentModel.BackgroundWorker()
    IL_001c:  ldarg.0
    IL_001d:  newobj     instance void [System]System.ComponentModel.BackgroundWorker::.ctor()
    IL_0022:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_bwColorize(class [System]System.ComponentModel.BackgroundWorker)
    IL_0027:  nop
//000029:             Me.tmRefresh = New Timer(Me.components)
    IL_0028:  ldarg.0
    IL_0029:  ldarg.0
    IL_002a:  ldfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
    IL_002f:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Timer::.ctor(class [System]System.ComponentModel.IContainer)
    IL_0034:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_tmRefresh(class [System.Windows.Forms]System.Windows.Forms.Timer)
    IL_0039:  nop
//000030:             Me.toolStripContainer = New ToolStripContainer()
    IL_003a:  ldarg.0
    IL_003b:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::.ctor()
    IL_0040:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
//000031:             Me.pbImage = New PictureBox()
    IL_0045:  ldarg.0
    IL_0046:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::.ctor()
    IL_004b:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_pbImage(class [System.Windows.Forms]System.Windows.Forms.PictureBox)
    IL_0050:  nop
//000032:             Me.toolStripMain = New ToolStrip()
    IL_0051:  ldarg.0
    IL_0052:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStrip::.ctor()
    IL_0057:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
//000033:             Me.btnLoadImage = New ToolStripButton()
    IL_005c:  ldarg.0
    IL_005d:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::.ctor()
    IL_0062:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_btnLoadImage(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton)
    IL_0067:  nop
//000034:             Me.btnSaveImage = New ToolStripButton()
    IL_0068:  ldarg.0
    IL_0069:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::.ctor()
    IL_006e:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_btnSaveImage(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton)
    IL_0073:  nop
//000035:             Me.separator1 = New ToolStripSeparator()
    IL_0074:  ldarg.0
    IL_0075:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator::.ctor()
    IL_007a:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator1
//000036:             Me.tbEpsilon = New Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar()
    IL_007f:  ldarg.0
    IL_0080:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::.ctor()
    IL_0085:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_tbEpsilon(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar)
    IL_008a:  nop
//000037:             Me.separator2 = New ToolStripSeparator()
    IL_008b:  ldarg.0
    IL_008c:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator::.ctor()
    IL_0091:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator2
//000038:             Me.btnParallel = New ToolStripButton()
    IL_0096:  ldarg.0
    IL_0097:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::.ctor()
    IL_009c:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_btnParallel(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton)
    IL_00a1:  nop
//000039:             Me.btnInk = New ToolStripButton()
    IL_00a2:  ldarg.0
    IL_00a3:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::.ctor()
    IL_00a8:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_btnInk(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton)
    IL_00ad:  nop
//000040:             Me.btnEraser = New ToolStripButton()
    IL_00ae:  ldarg.0
    IL_00af:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::.ctor()
    IL_00b4:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_btnEraser(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton)
    IL_00b9:  nop
//000041:             Me.pbColorizing = New ToolStripProgressBar()
    IL_00ba:  ldarg.0
    IL_00bb:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar::.ctor()
    IL_00c0:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
//000042:             Me.lblHuesSelected = New ToolStripLabel()
    IL_00c5:  ldarg.0
    IL_00c6:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripLabel::.ctor()
    IL_00cb:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_lblHuesSelected(class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel)
    IL_00d0:  nop
//000043:             Me.toolStripContainer.ContentPanel.SuspendLayout()
    IL_00d1:  ldarg.0
    IL_00d2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_00d7:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripContentPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_ContentPanel()
    IL_00dc:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_00e1:  nop
//000044:             Me.toolStripContainer.TopToolStripPanel.SuspendLayout()
    IL_00e2:  ldarg.0
    IL_00e3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_00e8:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_TopToolStripPanel()
    IL_00ed:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_00f2:  nop
//000045:             Me.toolStripContainer.SuspendLayout()
    IL_00f3:  ldarg.0
    IL_00f4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_00f9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_00fe:  nop
//000046:             CType(Me.pbImage, System.ComponentModel.ISupportInitialize).BeginInit()
    IL_00ff:  ldarg.0
    IL_0100:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0105:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::BeginInit()
    IL_010a:  nop
//000047:             Me.toolStripMain.SuspendLayout()
    IL_010b:  ldarg.0
    IL_010c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_0111:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_0116:  nop
//000048:             Me.SuspendLayout()
    IL_0117:  ldarg.0
    IL_0118:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_011d:  nop
//000049:             ' 
//000050:             ' bwColorize
//000051:             ' 
//000052:             Me.bwColorize.WorkerReportsProgress = True
    IL_011e:  ldarg.0
    IL_011f:  callvirt   instance class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_bwColorize()
    IL_0124:  ldc.i4.1
    IL_0125:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::set_WorkerReportsProgress(bool)
    IL_012a:  nop
//000053:             ' Me.bwColorize.DoWork += New System.ComponentModel.DoWorkEventHandler(Me.bwColorize_DoWork)
//000054:             ' Me.bwColorize.RunWorkerCompleted += New System.ComponentModel.RunWorkerCompletedEventHandler(Me.bwColorize_RunWorkerCompleted)
//000055:             ' Me.bwColorize.ProgressChanged += New System.ComponentModel.ProgressChangedEventHandler(Me.bwColorize_ProgressChanged)
//000056:             ' 
//000057:             ' tmRefresh
//000058:             ' 
//000059:             Me.tmRefresh.Interval = 1000
    IL_012b:  ldarg.0
    IL_012c:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tmRefresh()
    IL_0131:  ldc.i4     0x3e8
    IL_0136:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Timer::set_Interval(int32)
    IL_013b:  nop
//000060:             '			Me.tmRefresh.Tick += New System.EventHandler(Me.tmRefresh_Tick)
//000061:             ' 
//000062:             ' toolStripContainer
//000063:             ' 
//000064:             ' 
//000065:             ' toolStripContainer.ContentPanel
//000066:             ' 
//000067:             Me.toolStripContainer.ContentPanel.Controls.Add(Me.pbImage)
    IL_013c:  ldarg.0
    IL_013d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_0142:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripContentPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_ContentPanel()
    IL_0147:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_014c:  ldarg.0
    IL_014d:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0152:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0157:  nop
//000068:             Me.toolStripContainer.ContentPanel.Size = New Size(619, 397)
    IL_0158:  ldarg.0
    IL_0159:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_015e:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripContentPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_ContentPanel()
    IL_0163:  ldloca.s   VB$t_struct$S1
    IL_0165:  ldc.i4     0x26b
    IL_016a:  ldc.i4     0x18d
    IL_016f:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0174:  nop
    IL_0175:  ldloc.2
    IL_0176:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_017b:  nop
//000069:             Me.toolStripContainer.Dock = DockStyle.Fill
    IL_017c:  ldarg.0
    IL_017d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_0182:  ldc.i4.5
    IL_0183:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Dock(valuetype [System.Windows.Forms]System.Windows.Forms.DockStyle)
    IL_0188:  nop
//000070:             Me.toolStripContainer.Location = New Point(0, 0)
    IL_0189:  ldarg.0
    IL_018a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_018f:  ldloca.s   VB$t_struct$S3
    IL_0191:  ldc.i4.0
    IL_0192:  ldc.i4.0
    IL_0193:  call       instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0198:  nop
    IL_0199:  ldloc.s    VB$t_struct$S3
    IL_019b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_01a0:  nop
//000071:             Me.toolStripContainer.Name = "toolStripContainer"
    IL_01a1:  ldarg.0
    IL_01a2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_01a7:  ldstr      "toolStripContainer"
    IL_01ac:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_01b1:  nop
//000072:             Me.toolStripContainer.Size = New Size(619, 422)
    IL_01b2:  ldarg.0
    IL_01b3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_01b8:  ldloca.s   VB$t_struct$S1
    IL_01ba:  ldc.i4     0x26b
    IL_01bf:  ldc.i4     0x1a6
    IL_01c4:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_01c9:  nop
    IL_01ca:  ldloc.2
    IL_01cb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_01d0:  nop
//000073:             Me.toolStripContainer.TabIndex = 10
    IL_01d1:  ldarg.0
    IL_01d2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_01d7:  ldc.i4.s   10
    IL_01d9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_01de:  nop
//000074:             Me.toolStripContainer.Text = "toolStripContainer1"
    IL_01df:  ldarg.0
    IL_01e0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_01e5:  ldstr      "toolStripContainer1"
    IL_01ea:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_01ef:  nop
//000075:             ' 
//000076:             ' toolStripContainer.TopToolStripPanel
//000077:             ' 
//000078:             Me.toolStripContainer.TopToolStripPanel.Controls.Add(Me.toolStripMain)
    IL_01f0:  ldarg.0
    IL_01f1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_01f6:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_TopToolStripPanel()
    IL_01fb:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0200:  ldarg.0
    IL_0201:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_0206:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_020b:  nop
//000079:             ' 
//000080:             ' pbImage
//000081:             ' 
//000082:             Me.pbImage.Anchor = (CType((((AnchorStyles.Top Or AnchorStyles.Bottom) Or AnchorStyles.Left) Or AnchorStyles.Right), AnchorStyles))
    IL_020c:  ldarg.0
    IL_020d:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0212:  ldc.i4.s   15
    IL_0214:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_0219:  nop
//000083:             Me.pbImage.BorderStyle = BorderStyle.Fixed3D
    IL_021a:  ldarg.0
    IL_021b:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0220:  ldc.i4.2
    IL_0221:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_BorderStyle(valuetype [System.Windows.Forms]System.Windows.Forms.BorderStyle)
    IL_0226:  nop
//000084:             Me.pbImage.Cursor = Cursors.Default
    IL_0227:  ldarg.0
    IL_0228:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_022d:  call       class [System.Windows.Forms]System.Windows.Forms.Cursor [System.Windows.Forms]System.Windows.Forms.Cursors::get_Default()
    IL_0232:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Cursor(class [System.Windows.Forms]System.Windows.Forms.Cursor)
    IL_0237:  nop
//000085:             Me.pbImage.Location = New Point(3, 3)
    IL_0238:  ldarg.0
    IL_0239:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_023e:  ldloca.s   VB$t_struct$S3
    IL_0240:  ldc.i4.3
    IL_0241:  ldc.i4.3
    IL_0242:  call       instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0247:  nop
    IL_0248:  ldloc.s    VB$t_struct$S3
    IL_024a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_024f:  nop
//000086:             Me.pbImage.Name = "pbImage"
    IL_0250:  ldarg.0
    IL_0251:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0256:  ldstr      "pbImage"
    IL_025b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0260:  nop
//000087:             Me.pbImage.Size = New Size(613, 391)
    IL_0261:  ldarg.0
    IL_0262:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0267:  ldloca.s   VB$t_struct$S1
    IL_0269:  ldc.i4     0x265
    IL_026e:  ldc.i4     0x187
    IL_0273:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0278:  nop
    IL_0279:  ldloc.2
    IL_027a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_027f:  nop
//000088:             Me.pbImage.SizeMode = PictureBoxSizeMode.StretchImage
    IL_0280:  ldarg.0
    IL_0281:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0286:  ldc.i4.1
    IL_0287:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_028c:  nop
//000089:             Me.pbImage.TabIndex = 10
    IL_028d:  ldarg.0
    IL_028e:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0293:  ldc.i4.s   10
    IL_0295:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabIndex(int32)
    IL_029a:  nop
//000090:             Me.pbImage.TabStop = False
    IL_029b:  ldarg.0
    IL_029c:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_02a1:  ldc.i4.0
    IL_02a2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabStop(bool)
    IL_02a7:  nop
//000091:             ' Me.pbImage.DragDrop += New System.Windows.Forms.DragEventHandler(Me.pbImage_DragDrop)
//000092:             ' Me.pbImage.Resize += New System.EventHandler(Me.pbImage_Resize)
//000093:             ' Me.pbImage.MouseClick += New System.Windows.Forms.MouseEventHandler(Me.pbImage_MouseClick)
//000094:             ' Me.pbImage.DragEnter += New System.Windows.Forms.DragEventHandler(Me.pbImage_DragEnter)
//000095:             ' 
//000096:             ' toolStripMain
//000097:             ' 
//000098:             Me.toolStripMain.AllowItemReorder = True
    IL_02a8:  ldarg.0
    IL_02a9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_02ae:  ldc.i4.1
    IL_02af:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStrip::set_AllowItemReorder(bool)
    IL_02b4:  nop
//000099:             Me.toolStripMain.Dock = DockStyle.None
    IL_02b5:  ldarg.0
    IL_02b6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_02bb:  ldc.i4.0
    IL_02bc:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStrip::set_Dock(valuetype [System.Windows.Forms]System.Windows.Forms.DockStyle)
    IL_02c1:  nop
//000100:             Me.toolStripMain.Items.AddRange(New ToolStripItem() {Me.btnLoadImage, Me.btnSaveImage, Me.separator1, Me.tbEpsilon, Me.separator2, Me.btnParallel, _
    IL_02c2:  ldarg.0
    IL_02c3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_02c8:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection [System.Windows.Forms]System.Windows.Forms.ToolStrip::get_Items()
    IL_02cd:  ldc.i4.s   10
    IL_02cf:  newarr     [System.Windows.Forms]System.Windows.Forms.ToolStripItem
    IL_02d4:  stloc.s    VB$t_array$S0
    IL_02d6:  ldloc.s    VB$t_array$S0
    IL_02d8:  ldc.i4.0
    IL_02d9:  ldarg.0
    IL_02da:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnLoadImage()
    IL_02df:  stelem.ref
    IL_02e0:  nop
    IL_02e1:  ldloc.s    VB$t_array$S0
    IL_02e3:  ldc.i4.1
    IL_02e4:  ldarg.0
    IL_02e5:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnSaveImage()
    IL_02ea:  stelem.ref
    IL_02eb:  nop
    IL_02ec:  ldloc.s    VB$t_array$S0
    IL_02ee:  ldc.i4.2
    IL_02ef:  ldarg.0
    IL_02f0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator1
    IL_02f5:  stelem.ref
    IL_02f6:  nop
    IL_02f7:  ldloc.s    VB$t_array$S0
    IL_02f9:  ldc.i4.3
    IL_02fa:  ldarg.0
    IL_02fb:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tbEpsilon()
    IL_0300:  stelem.ref
    IL_0301:  nop
    IL_0302:  ldloc.s    VB$t_array$S0
    IL_0304:  ldc.i4.4
    IL_0305:  ldarg.0
    IL_0306:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator2
    IL_030b:  stelem.ref
    IL_030c:  nop
    IL_030d:  ldloc.s    VB$t_array$S0
    IL_030f:  ldc.i4.5
    IL_0310:  ldarg.0
    IL_0311:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnParallel()
    IL_0316:  stelem.ref
    IL_0317:  nop
    IL_0318:  ldloc.s    VB$t_array$S0
    IL_031a:  ldc.i4.6
    IL_031b:  ldarg.0
    IL_031c:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnInk()
    IL_0321:  stelem.ref
    IL_0322:  nop
    IL_0323:  ldloc.s    VB$t_array$S0
    IL_0325:  ldc.i4.7
    IL_0326:  ldarg.0
    IL_0327:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnEraser()
    IL_032c:  stelem.ref
    IL_032d:  nop
    IL_032e:  ldloc.s    VB$t_array$S0
    IL_0330:  ldc.i4.8
    IL_0331:  ldarg.0
    IL_0332:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_0337:  stelem.ref
    IL_0338:  nop
    IL_0339:  ldloc.s    VB$t_array$S0
    IL_033b:  ldc.i4.s   9
    IL_033d:  ldarg.0
    IL_033e:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_lblHuesSelected()
    IL_0343:  stelem.ref
    IL_0344:  nop
    IL_0345:  ldloc.s    VB$t_array$S0
    IL_0347:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection::AddRange(class [System.Windows.Forms]System.Windows.Forms.ToolStripItem[])
    IL_034c:  nop
//000101:                                                                  Me.btnInk, Me.btnEraser, Me.pbColorizing, Me.lblHuesSelected})
//000102:             Me.toolStripMain.LayoutStyle = ToolStripLayoutStyle.HorizontalStackWithOverflow
    IL_034d:  ldarg.0
    IL_034e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_0353:  ldc.i4.1
    IL_0354:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStrip::set_LayoutStyle(valuetype [System.Windows.Forms]System.Windows.Forms.ToolStripLayoutStyle)
    IL_0359:  nop
//000103:             Me.toolStripMain.Location = New Point(3, 0)
    IL_035a:  ldarg.0
    IL_035b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_0360:  ldloca.s   VB$t_struct$S3
    IL_0362:  ldc.i4.3
    IL_0363:  ldc.i4.0
    IL_0364:  call       instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0369:  nop
    IL_036a:  ldloc.s    VB$t_struct$S3
    IL_036c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0371:  nop
//000104:             Me.toolStripMain.Name = "toolStripMain"
    IL_0372:  ldarg.0
    IL_0373:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_0378:  ldstr      "toolStripMain"
    IL_037d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0382:  nop
//000105:             Me.toolStripMain.Size = New Size(616, 25)
    IL_0383:  ldarg.0
    IL_0384:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_0389:  ldloca.s   VB$t_struct$S1
    IL_038b:  ldc.i4     0x268
    IL_0390:  ldc.i4.s   25
    IL_0392:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0397:  nop
    IL_0398:  ldloc.2
    IL_0399:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_039e:  nop
//000106:             Me.toolStripMain.TabIndex = 9
    IL_039f:  ldarg.0
    IL_03a0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_03a5:  ldc.i4.s   9
    IL_03a7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_03ac:  nop
//000107:             Me.toolStripMain.Text = "toolStrip1"
    IL_03ad:  ldarg.0
    IL_03ae:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_03b3:  ldstr      "toolStrip1"
    IL_03b8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_03bd:  nop
//000108:             ' 
//000109:             ' btnLoadImage
//000110:             ' 
//000111:             Me.btnLoadImage.Image = My.Resources.InsertPictureHS
    IL_03be:  ldarg.0
    IL_03bf:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnLoadImage()
    IL_03c4:  call       class [System.Drawing]System.Drawing.Bitmap My.Resources.Resources::get_InsertPictureHS()
    IL_03c9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_03ce:  nop
//000112:             Me.btnLoadImage.ImageTransparentColor = Color.Magenta
    IL_03cf:  ldarg.0
    IL_03d0:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnLoadImage()
    IL_03d5:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Magenta()
    IL_03da:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ImageTransparentColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_03df:  nop
//000113:             Me.btnLoadImage.Name = "btnLoadImage"
    IL_03e0:  ldarg.0
    IL_03e1:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnLoadImage()
    IL_03e6:  ldstr      "btnLoadImage"
    IL_03eb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_03f0:  nop
//000114:             Me.btnLoadImage.Size = New Size(89, 22)
    IL_03f1:  ldarg.0
    IL_03f2:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnLoadImage()
    IL_03f7:  ldloca.s   VB$t_struct$S1
    IL_03f9:  ldc.i4.s   89
    IL_03fb:  ldc.i4.s   22
    IL_03fd:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0402:  nop
    IL_0403:  ldloc.2
    IL_0404:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0409:  nop
//000115:             Me.btnLoadImage.Text = "&Load Image"
    IL_040a:  ldarg.0
    IL_040b:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnLoadImage()
    IL_0410:  ldstr      "&Load Image"
    IL_0415:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_041a:  nop
//000116:             ' Me.btnLoadImage.Click += New System.EventHandler(Me.btnLoadImage_Click)
//000117:             '
//000118:             ' btnSaveImage
//000119:             ' 
//000120:             Me.btnSaveImage.Image = My.Resources.saveHS
    IL_041b:  ldarg.0
    IL_041c:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnSaveImage()
    IL_0421:  call       class [System.Drawing]System.Drawing.Bitmap My.Resources.Resources::get_saveHS()
    IL_0426:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_042b:  nop
//000121:             Me.btnSaveImage.ImageTransparentColor = Color.Magenta
    IL_042c:  ldarg.0
    IL_042d:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnSaveImage()
    IL_0432:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Magenta()
    IL_0437:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ImageTransparentColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_043c:  nop
//000122:             Me.btnSaveImage.Name = "btnSaveImage"
    IL_043d:  ldarg.0
    IL_043e:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnSaveImage()
    IL_0443:  ldstr      "btnSaveImage"
    IL_0448:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_044d:  nop
//000123:             Me.btnSaveImage.Size = New Size(87, 22)
    IL_044e:  ldarg.0
    IL_044f:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnSaveImage()
    IL_0454:  ldloca.s   VB$t_struct$S1
    IL_0456:  ldc.i4.s   87
    IL_0458:  ldc.i4.s   22
    IL_045a:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_045f:  nop
    IL_0460:  ldloc.2
    IL_0461:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0466:  nop
//000124:             Me.btnSaveImage.Text = "&Save Image"
    IL_0467:  ldarg.0
    IL_0468:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnSaveImage()
    IL_046d:  ldstr      "&Save Image"
    IL_0472:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0477:  nop
//000125:             ' Me.btnSaveImage.Click += New System.EventHandler(Me.btnSaveImage_Click)
//000126:             ' 
//000127:             ' separator1
//000128:             ' 
//000129:             Me.separator1.Name = "separator1"
    IL_0478:  ldarg.0
    IL_0479:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator1
    IL_047e:  ldstr      "separator1"
    IL_0483:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0488:  nop
//000130:             Me.separator1.Size = New Size(6, 25)
    IL_0489:  ldarg.0
    IL_048a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator1
    IL_048f:  ldloca.s   VB$t_struct$S1
    IL_0491:  ldc.i4.6
    IL_0492:  ldc.i4.s   25
    IL_0494:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0499:  nop
    IL_049a:  ldloc.2
    IL_049b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_04a0:  nop
//000131:             ' 
//000132:             ' tbEpsilon
//000133:             ' 
//000134:             Me.tbEpsilon.BackColor = SystemColors.Control
    IL_04a1:  ldarg.0
    IL_04a2:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tbEpsilon()
    IL_04a7:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.SystemColors::get_Control()
    IL_04ac:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost::set_BackColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_04b1:  nop
//000135:             Me.tbEpsilon.Maximum = 180
    IL_04b2:  ldarg.0
    IL_04b3:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tbEpsilon()
    IL_04b8:  ldc.i4     0xb4
    IL_04bd:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::set_Maximum(int32)
    IL_04c2:  nop
//000136:             Me.tbEpsilon.Name = "tbEpsilon"
    IL_04c3:  ldarg.0
    IL_04c4:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tbEpsilon()
    IL_04c9:  ldstr      "tbEpsilon"
    IL_04ce:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_04d3:  nop
//000137:             Me.tbEpsilon.Size = New Size(150, 22)
    IL_04d4:  ldarg.0
    IL_04d5:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tbEpsilon()
    IL_04da:  ldloca.s   VB$t_struct$S1
    IL_04dc:  ldc.i4     0x96
    IL_04e1:  ldc.i4.s   22
    IL_04e3:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_04e8:  nop
    IL_04e9:  ldloc.2
    IL_04ea:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_04ef:  nop
//000138:             Me.tbEpsilon.Text = "toolStripTrackBar1"
    IL_04f0:  ldarg.0
    IL_04f1:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tbEpsilon()
    IL_04f6:  ldstr      "toolStripTrackBar1"
    IL_04fb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost::set_Text(string)
    IL_0500:  nop
//000139:             Me.tbEpsilon.Value = 15
    IL_0501:  ldarg.0
    IL_0502:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tbEpsilon()
    IL_0507:  ldc.i4.s   15
    IL_0509:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::set_Value(int32)
    IL_050e:  nop
//000140:             ' Me.tbEpsilon.ValueChanged += New System.EventHandler(Me.tbEpsilon_ValueChanged)
//000141:             ' 
//000142:             ' separator2
//000143:             ' 
//000144:             Me.separator2.Name = "separator2"
    IL_050f:  ldarg.0
    IL_0510:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator2
    IL_0515:  ldstr      "separator2"
    IL_051a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_051f:  nop
//000145:             Me.separator2.Size = New Size(6, 25)
    IL_0520:  ldarg.0
    IL_0521:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::separator2
    IL_0526:  ldloca.s   VB$t_struct$S1
    IL_0528:  ldc.i4.6
    IL_0529:  ldc.i4.s   25
    IL_052b:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0530:  nop
    IL_0531:  ldloc.2
    IL_0532:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0537:  nop
//000146:             ' 
//000147:             ' btnParallel
//000148:             ' 
//000149:             Me.btnParallel.CheckOnClick = True
    IL_0538:  ldarg.0
    IL_0539:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnParallel()
    IL_053e:  ldc.i4.1
    IL_053f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::set_CheckOnClick(bool)
    IL_0544:  nop
//000150:             Me.btnParallel.DisplayStyle = ToolStripItemDisplayStyle.Image
    IL_0545:  ldarg.0
    IL_0546:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnParallel()
    IL_054b:  ldc.i4.2
    IL_054c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_DisplayStyle(valuetype [System.Windows.Forms]System.Windows.Forms.ToolStripItemDisplayStyle)
    IL_0551:  nop
//000151:             Me.btnParallel.Image = (CType(resources.GetObject("btnParallel.Image"), Image))
    IL_0552:  ldarg.0
    IL_0553:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnParallel()
    IL_0558:  ldloc.0
    IL_0559:  ldstr      "btnParallel.Image"
    IL_055e:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string)
    IL_0563:  castclass  [System.Drawing]System.Drawing.Image
    IL_0568:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_056d:  nop
//000152:             Me.btnParallel.ImageTransparentColor = Color.Magenta
    IL_056e:  ldarg.0
    IL_056f:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnParallel()
    IL_0574:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Magenta()
    IL_0579:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ImageTransparentColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_057e:  nop
//000153:             Me.btnParallel.Name = "btnParallel"
    IL_057f:  ldarg.0
    IL_0580:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnParallel()
    IL_0585:  ldstr      "btnParallel"
    IL_058a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_058f:  nop
//000154:             Me.btnParallel.Size = New Size(23, 22)
    IL_0590:  ldarg.0
    IL_0591:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnParallel()
    IL_0596:  ldloca.s   VB$t_struct$S1
    IL_0598:  ldc.i4.s   23
    IL_059a:  ldc.i4.s   22
    IL_059c:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_05a1:  nop
    IL_05a2:  ldloc.2
    IL_05a3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_05a8:  nop
//000155:             Me.btnParallel.Text = "btnParallel"
    IL_05a9:  ldarg.0
    IL_05aa:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnParallel()
    IL_05af:  ldstr      "btnParallel"
    IL_05b4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_05b9:  nop
//000156:             ' Me.btnParallel.CheckedChanged += New System.EventHandler(Me.btnParallel_CheckedChanged)
//000157:             ' 
//000158:             ' btnInk
//000159:             ' 
//000160:             Me.btnInk.DisplayStyle = ToolStripItemDisplayStyle.Image
    IL_05ba:  ldarg.0
    IL_05bb:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnInk()
    IL_05c0:  ldc.i4.2
    IL_05c1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_DisplayStyle(valuetype [System.Windows.Forms]System.Windows.Forms.ToolStripItemDisplayStyle)
    IL_05c6:  nop
//000161:             Me.btnInk.Enabled = False
    IL_05c7:  ldarg.0
    IL_05c8:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnInk()
    IL_05cd:  ldc.i4.0
    IL_05ce:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
    IL_05d3:  nop
//000162:             Me.btnInk.Image = My.Resources.pen
    IL_05d4:  ldarg.0
    IL_05d5:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnInk()
    IL_05da:  call       class [System.Drawing]System.Drawing.Bitmap My.Resources.Resources::get_pen()
    IL_05df:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_05e4:  nop
//000163:             Me.btnInk.ImageTransparentColor = Color.Magenta
    IL_05e5:  ldarg.0
    IL_05e6:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnInk()
    IL_05eb:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Magenta()
    IL_05f0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ImageTransparentColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_05f5:  nop
//000164:             Me.btnInk.Name = "btnInk"
    IL_05f6:  ldarg.0
    IL_05f7:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnInk()
    IL_05fc:  ldstr      "btnInk"
    IL_0601:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0606:  nop
//000165:             Me.btnInk.Size = New Size(23, 22)
    IL_0607:  ldarg.0
    IL_0608:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnInk()
    IL_060d:  ldloca.s   VB$t_struct$S1
    IL_060f:  ldc.i4.s   23
    IL_0611:  ldc.i4.s   22
    IL_0613:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0618:  nop
    IL_0619:  ldloc.2
    IL_061a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_061f:  nop
//000166:             Me.btnInk.Text = "btnInk"
    IL_0620:  ldarg.0
    IL_0621:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnInk()
    IL_0626:  ldstr      "btnInk"
    IL_062b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0630:  nop
//000167:             ' Me.btnInk.Click += New System.EventHandler(Me.btnInk_Click)
//000168:             ' 
//000169:             ' btnEraser
//000170:             ' 
//000171:             Me.btnEraser.DisplayStyle = ToolStripItemDisplayStyle.Image
    IL_0631:  ldarg.0
    IL_0632:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnEraser()
    IL_0637:  ldc.i4.2
    IL_0638:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_DisplayStyle(valuetype [System.Windows.Forms]System.Windows.Forms.ToolStripItemDisplayStyle)
    IL_063d:  nop
//000172:             Me.btnEraser.Enabled = False
    IL_063e:  ldarg.0
    IL_063f:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnEraser()
    IL_0644:  ldc.i4.0
    IL_0645:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
    IL_064a:  nop
//000173:             Me.btnEraser.Image = My.Resources.eraser
    IL_064b:  ldarg.0
    IL_064c:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnEraser()
    IL_0651:  call       class [System.Drawing]System.Drawing.Bitmap My.Resources.Resources::get_eraser()
    IL_0656:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_065b:  nop
//000174:             Me.btnEraser.ImageTransparentColor = Color.Magenta
    IL_065c:  ldarg.0
    IL_065d:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnEraser()
    IL_0662:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Magenta()
    IL_0667:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ImageTransparentColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_066c:  nop
//000175:             Me.btnEraser.Name = "btnEraser"
    IL_066d:  ldarg.0
    IL_066e:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnEraser()
    IL_0673:  ldstr      "btnEraser"
    IL_0678:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_067d:  nop
//000176:             Me.btnEraser.Size = New Size(23, 22)
    IL_067e:  ldarg.0
    IL_067f:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnEraser()
    IL_0684:  ldloca.s   VB$t_struct$S1
    IL_0686:  ldc.i4.s   23
    IL_0688:  ldc.i4.s   22
    IL_068a:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_068f:  nop
    IL_0690:  ldloc.2
    IL_0691:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0696:  nop
//000177:             Me.btnEraser.Text = "btnEraser"
    IL_0697:  ldarg.0
    IL_0698:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnEraser()
    IL_069d:  ldstr      "btnEraser"
    IL_06a2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_06a7:  nop
//000178:             ' Me.btnEraser.Click += New System.EventHandler(Me.btnEraser_Click)
//000179:             ' 
//000180:             ' pbColorizing
//000181:             ' 
//000182:             Me.pbColorizing.Alignment = ToolStripItemAlignment.Right
    IL_06a8:  ldarg.0
    IL_06a9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_06ae:  ldc.i4.1
    IL_06af:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Alignment(valuetype [System.Windows.Forms]System.Windows.Forms.ToolStripItemAlignment)
    IL_06b4:  nop
//000183:             Me.pbColorizing.Name = "pbColorizing"
    IL_06b5:  ldarg.0
    IL_06b6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_06bb:  ldstr      "pbColorizing"
    IL_06c0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_06c5:  nop
//000184:             Me.pbColorizing.Overflow = ToolStripItemOverflow.Never
    IL_06c6:  ldarg.0
    IL_06c7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_06cc:  ldc.i4.0
    IL_06cd:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Overflow(valuetype [System.Windows.Forms]System.Windows.Forms.ToolStripItemOverflow)
    IL_06d2:  nop
//000185:             Me.pbColorizing.Size = New Size(140, 22)
    IL_06d3:  ldarg.0
    IL_06d4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_06d9:  ldloca.s   VB$t_struct$S1
    IL_06db:  ldc.i4     0x8c
    IL_06e0:  ldc.i4.s   22
    IL_06e2:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_06e7:  nop
    IL_06e8:  ldloc.2
    IL_06e9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_06ee:  nop
//000186:             Me.pbColorizing.Visible = False
    IL_06ef:  ldarg.0
    IL_06f0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_06f5:  ldc.i4.0
    IL_06f6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Visible(bool)
    IL_06fb:  nop
//000187:             ' 
//000188:             ' lblHuesSelected
//000189:             ' 
//000190:             Me.lblHuesSelected.Name = "lblHuesSelected"
    IL_06fc:  ldarg.0
    IL_06fd:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_lblHuesSelected()
    IL_0702:  ldstr      "lblHuesSelected"
    IL_0707:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_070c:  nop
//000191:             Me.lblHuesSelected.Size = New Size(81, 15)
    IL_070d:  ldarg.0
    IL_070e:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_lblHuesSelected()
    IL_0713:  ldloca.s   VB$t_struct$S1
    IL_0715:  ldc.i4.s   81
    IL_0717:  ldc.i4.s   15
    IL_0719:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_071e:  nop
    IL_071f:  ldloc.2
    IL_0720:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0725:  nop
//000192:             Me.lblHuesSelected.Text = "Hues Selected"
    IL_0726:  ldarg.0
    IL_0727:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_lblHuesSelected()
    IL_072c:  ldstr      "Hues Selected"
    IL_0731:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0736:  nop
//000193:             ' Me.lblHuesSelected.Click += New System.EventHandler(Me.lblHuesSelected_Click)
//000194:             ' 
//000195:             ' MainForm
//000196:             ' 
//000197:             Me.AutoScaleDimensions = New SizeF(6.0F, 13.0F)
    IL_0737:  ldarg.0
    IL_0738:  ldloca.s   VB$t_struct$S6
    IL_073a:  ldc.r4     6.
    IL_073f:  ldc.r4     13.
    IL_0744:  call       instance void [System.Drawing]System.Drawing.SizeF::.ctor(float32,
                                                                                   float32)
    IL_0749:  nop
    IL_074a:  ldloc.s    VB$t_struct$S6
    IL_074c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleDimensions(valuetype [System.Drawing]System.Drawing.SizeF)
    IL_0751:  nop
//000198:             Me.AutoScaleMode = AutoScaleMode.Font
    IL_0752:  ldarg.0
    IL_0753:  ldc.i4.1
    IL_0754:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleMode(valuetype [System.Windows.Forms]System.Windows.Forms.AutoScaleMode)
    IL_0759:  nop
//000199:             Me.ClientSize = New Size(619, 422)
    IL_075a:  ldarg.0
    IL_075b:  ldloca.s   VB$t_struct$S1
    IL_075d:  ldc.i4     0x26b
    IL_0762:  ldc.i4     0x1a6
    IL_0767:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_076c:  nop
    IL_076d:  ldloc.2
    IL_076e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Form::set_ClientSize(valuetype [System.Drawing]System.Drawing.Size)
    IL_0773:  nop
//000200:             Me.Controls.Add(Me.toolStripContainer)
    IL_0774:  ldarg.0
    IL_0775:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_077a:  ldarg.0
    IL_077b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_0780:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0785:  nop
//000201:             Me.Icon = (CType(resources.GetObject("$this.Icon"), Icon))
    IL_0786:  ldarg.0
    IL_0787:  ldloc.0
    IL_0788:  ldstr      "$this.Icon"
    IL_078d:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string)
    IL_0792:  castclass  [System.Drawing]System.Drawing.Icon
    IL_0797:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Form::set_Icon(class [System.Drawing]System.Drawing.Icon)
    IL_079c:  nop
//000202:             Me.KeyPreview = True
    IL_079d:  ldarg.0
    IL_079e:  ldc.i4.1
    IL_079f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Form::set_KeyPreview(bool)
    IL_07a4:  nop
//000203:             Me.Name = "MainForm"
    IL_07a5:  ldarg.0
    IL_07a6:  ldstr      "MainForm"
    IL_07ab:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_07b0:  nop
//000204:             Me.Text = "Image Colorizer"
    IL_07b1:  ldarg.0
    IL_07b2:  ldstr      "Image Colorizer"
    IL_07b7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Form::set_Text(string)
    IL_07bc:  nop
//000205:             ' Me.Load += New System.EventHandler(Me.MainForm_Load)
//000206:             Me.toolStripContainer.ContentPanel.ResumeLayout(False)
    IL_07bd:  ldarg.0
    IL_07be:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_07c3:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripContentPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_ContentPanel()
    IL_07c8:  ldc.i4.0
    IL_07c9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_07ce:  nop
//000207:             Me.toolStripContainer.TopToolStripPanel.ResumeLayout(False)
    IL_07cf:  ldarg.0
    IL_07d0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_07d5:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_TopToolStripPanel()
    IL_07da:  ldc.i4.0
    IL_07db:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_07e0:  nop
//000208:             Me.toolStripContainer.TopToolStripPanel.PerformLayout()
    IL_07e1:  ldarg.0
    IL_07e2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_07e7:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripPanel [System.Windows.Forms]System.Windows.Forms.ToolStripContainer::get_TopToolStripPanel()
    IL_07ec:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_07f1:  nop
//000209:             Me.toolStripContainer.ResumeLayout(False)
    IL_07f2:  ldarg.0
    IL_07f3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_07f8:  ldc.i4.0
    IL_07f9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_07fe:  nop
//000210:             Me.toolStripContainer.PerformLayout()
    IL_07ff:  ldarg.0
    IL_0800:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripContainer
    IL_0805:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_080a:  nop
//000211:             CType(Me.pbImage, System.ComponentModel.ISupportInitialize).EndInit()
    IL_080b:  ldarg.0
    IL_080c:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0811:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::EndInit()
    IL_0816:  nop
//000212:             Me.toolStripMain.ResumeLayout(False)
    IL_0817:  ldarg.0
    IL_0818:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_081d:  ldc.i4.0
    IL_081e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_0823:  nop
//000213:             Me.toolStripMain.PerformLayout()
    IL_0824:  ldarg.0
    IL_0825:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_082a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_082f:  nop
//000214:             Me.ResumeLayout(False)
    IL_0830:  ldarg.0
    IL_0831:  ldc.i4.0
    IL_0832:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_0837:  nop
//000215: 
//000216:         End Sub
    IL_0838:  nop
    IL_0839:  ret
  } // end of method MainForm::InitializeComponent

  .method private newslot specialname strict virtual 
          instance class [System]System.ComponentModel.BackgroundWorker 
          get_bwColorize() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (class [System]System.ComponentModel.BackgroundWorker V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bwColorize
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method MainForm::get_bwColorize

  .method private newslot specialname strict virtual 
          instance void  set_bwColorize(class [System]System.ComponentModel.BackgroundWorker WithEventsValue) cil managed synchronized
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       163 (0xa3)
    .maxstack  2
    .locals init (class [System]System.ComponentModel.DoWorkEventHandler V_0,
             class [System]System.ComponentModel.ProgressChangedEventHandler V_1,
             class [System]System.ComponentModel.RunWorkerCompletedEventHandler V_2,
             bool V_3)
    IL_0000:  ldarg.0
    IL_0001:  dup
    IL_0002:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize_DoWork(object,
                                                                                                                                  class [System]System.ComponentModel.DoWorkEventArgs)
    IL_0008:  newobj     instance void [System]System.ComponentModel.DoWorkEventHandler::.ctor(object,
                                                                                               native int)
    IL_000d:  stloc.0
    IL_000e:  ldarg.0
    IL_000f:  dup
    IL_0010:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize_ProgressChanged(object,
                                                                                                                                           class [System]System.ComponentModel.ProgressChangedEventArgs)
    IL_0016:  newobj     instance void [System]System.ComponentModel.ProgressChangedEventHandler::.ctor(object,
                                                                                                        native int)
    IL_001b:  stloc.1
    IL_001c:  ldarg.0
    IL_001d:  dup
    IL_001e:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::bwColorize_RunWorkerCompleted(object,
                                                                                                                                              class [System]System.ComponentModel.RunWorkerCompletedEventArgs)
    IL_0024:  newobj     instance void [System]System.ComponentModel.RunWorkerCompletedEventHandler::.ctor(object,
                                                                                                           native int)
    IL_0029:  stloc.2
    IL_002a:  ldarg.0
    IL_002b:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bwColorize
    IL_0030:  ldnull
    IL_0031:  ceq
    IL_0033:  ldc.i4.0
    IL_0034:  ceq
    IL_0036:  stloc.3
    IL_0037:  ldloc.3
    IL_0038:  brfalse.s  IL_0061

    IL_003a:  ldarg.0
    IL_003b:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bwColorize
    IL_0040:  ldloc.0
    IL_0041:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::remove_DoWork(class [System]System.ComponentModel.DoWorkEventHandler)
    IL_0046:  nop
    IL_0047:  ldarg.0
    IL_0048:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bwColorize
    IL_004d:  ldloc.1
    IL_004e:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::remove_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler)
    IL_0053:  nop
    IL_0054:  ldarg.0
    IL_0055:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bwColorize
    IL_005a:  ldloc.2
    IL_005b:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::remove_RunWorkerCompleted(class [System]System.ComponentModel.RunWorkerCompletedEventHandler)
    IL_0060:  nop
    IL_0061:  nop
    IL_0062:  ldarg.0
    IL_0063:  ldarg.1
    IL_0064:  stfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bwColorize
    IL_0069:  ldarg.0
    IL_006a:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bwColorize
    IL_006f:  ldnull
    IL_0070:  ceq
    IL_0072:  ldc.i4.0
    IL_0073:  ceq
    IL_0075:  stloc.3
    IL_0076:  ldloc.3
    IL_0077:  brfalse.s  IL_00a0

    IL_0079:  ldarg.0
    IL_007a:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bwColorize
    IL_007f:  ldloc.0
    IL_0080:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::add_DoWork(class [System]System.ComponentModel.DoWorkEventHandler)
    IL_0085:  nop
    IL_0086:  ldarg.0
    IL_0087:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bwColorize
    IL_008c:  ldloc.1
    IL_008d:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::add_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler)
    IL_0092:  nop
    IL_0093:  ldarg.0
    IL_0094:  ldfld      class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bwColorize
    IL_0099:  ldloc.2
    IL_009a:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::add_RunWorkerCompleted(class [System]System.ComponentModel.RunWorkerCompletedEventHandler)
    IL_009f:  nop
    IL_00a0:  nop
    IL_00a1:  nop
    IL_00a2:  ret
  } // end of method MainForm::set_bwColorize

  .method private newslot specialname strict virtual 
          instance class [System.Windows.Forms]System.Windows.Forms.Timer 
          get_tmRefresh() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (class [System.Windows.Forms]System.Windows.Forms.Timer V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_tmRefresh
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method MainForm::get_tmRefresh

  .method private newslot specialname strict virtual 
          instance void  set_tmRefresh(class [System.Windows.Forms]System.Windows.Forms.Timer WithEventsValue) cil managed synchronized
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       83 (0x53)
    .maxstack  2
    .locals init (class [mscorlib]System.EventHandler V_0,
             bool V_1)
    IL_0000:  ldarg.0
    IL_0001:  dup
    IL_0002:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tmRefresh_Tick(object,
                                                                                                                               class [mscorlib]System.EventArgs)
    IL_0008:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_000d:  stloc.0
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_tmRefresh
    IL_0014:  ldnull
    IL_0015:  ceq
    IL_0017:  ldc.i4.0
    IL_0018:  ceq
    IL_001a:  stloc.1
    IL_001b:  ldloc.1
    IL_001c:  brfalse.s  IL_002b

    IL_001e:  ldarg.0
    IL_001f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_tmRefresh
    IL_0024:  ldloc.0
    IL_0025:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Timer::remove_Tick(class [mscorlib]System.EventHandler)
    IL_002a:  nop
    IL_002b:  nop
    IL_002c:  ldarg.0
    IL_002d:  ldarg.1
    IL_002e:  stfld      class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_tmRefresh
    IL_0033:  ldarg.0
    IL_0034:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_tmRefresh
    IL_0039:  ldnull
    IL_003a:  ceq
    IL_003c:  ldc.i4.0
    IL_003d:  ceq
    IL_003f:  stloc.1
    IL_0040:  ldloc.1
    IL_0041:  brfalse.s  IL_0050

    IL_0043:  ldarg.0
    IL_0044:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_tmRefresh
    IL_0049:  ldloc.0
    IL_004a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Timer::add_Tick(class [mscorlib]System.EventHandler)
    IL_004f:  nop
    IL_0050:  nop
    IL_0051:  nop
    IL_0052:  ret
  } // end of method MainForm::set_tmRefresh

  .method private newslot specialname strict virtual 
          instance class [System.Windows.Forms]System.Windows.Forms.PictureBox 
          get_pbImage() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (class [System.Windows.Forms]System.Windows.Forms.PictureBox V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_pbImage
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method MainForm::get_pbImage

  .method private newslot specialname strict virtual 
          instance void  set_pbImage(class [System.Windows.Forms]System.Windows.Forms.PictureBox WithEventsValue) cil managed synchronized
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       207 (0xcf)
    .maxstack  2
    .locals init (class [mscorlib]System.EventHandler V_0,
             class [System.Windows.Forms]System.Windows.Forms.DragEventHandler V_1,
             class [System.Windows.Forms]System.Windows.Forms.MouseEventHandler V_2,
             class [System.Windows.Forms]System.Windows.Forms.DragEventHandler V_3,
             bool V_4)
    IL_0000:  ldarg.0
    IL_0001:  dup
    IL_0002:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage_Resize(object,
                                                                                                                               class [mscorlib]System.EventArgs)
    IL_0008:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_000d:  stloc.0
    IL_000e:  ldarg.0
    IL_000f:  dup
    IL_0010:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage_DragDrop(object,
                                                                                                                                 class [System.Windows.Forms]System.Windows.Forms.DragEventArgs)
    IL_0016:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.DragEventHandler::.ctor(object,
                                                                                                          native int)
    IL_001b:  stloc.1
    IL_001c:  ldarg.0
    IL_001d:  dup
    IL_001e:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage_MouseClick(object,
                                                                                                                                   class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs)
    IL_0024:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.MouseEventHandler::.ctor(object,
                                                                                                           native int)
    IL_0029:  stloc.2
    IL_002a:  ldarg.0
    IL_002b:  dup
    IL_002c:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbImage_DragEnter(object,
                                                                                                                                  class [System.Windows.Forms]System.Windows.Forms.DragEventArgs)
    IL_0032:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.DragEventHandler::.ctor(object,
                                                                                                          native int)
    IL_0037:  stloc.3
    IL_0038:  ldarg.0
    IL_0039:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_pbImage
    IL_003e:  ldnull
    IL_003f:  ceq
    IL_0041:  ldc.i4.0
    IL_0042:  ceq
    IL_0044:  stloc.s    V_4
    IL_0046:  ldloc.s    V_4
    IL_0048:  brfalse.s  IL_007e

    IL_004a:  ldarg.0
    IL_004b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_pbImage
    IL_0050:  ldloc.0
    IL_0051:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::remove_Resize(class [mscorlib]System.EventHandler)
    IL_0056:  nop
    IL_0057:  ldarg.0
    IL_0058:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_pbImage
    IL_005d:  ldloc.1
    IL_005e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::remove_DragDrop(class [System.Windows.Forms]System.Windows.Forms.DragEventHandler)
    IL_0063:  nop
    IL_0064:  ldarg.0
    IL_0065:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_pbImage
    IL_006a:  ldloc.2
    IL_006b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::remove_MouseClick(class [System.Windows.Forms]System.Windows.Forms.MouseEventHandler)
    IL_0070:  nop
    IL_0071:  ldarg.0
    IL_0072:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_pbImage
    IL_0077:  ldloc.3
    IL_0078:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::remove_DragEnter(class [System.Windows.Forms]System.Windows.Forms.DragEventHandler)
    IL_007d:  nop
    IL_007e:  nop
    IL_007f:  ldarg.0
    IL_0080:  ldarg.1
    IL_0081:  stfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_pbImage
    IL_0086:  ldarg.0
    IL_0087:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_pbImage
    IL_008c:  ldnull
    IL_008d:  ceq
    IL_008f:  ldc.i4.0
    IL_0090:  ceq
    IL_0092:  stloc.s    V_4
    IL_0094:  ldloc.s    V_4
    IL_0096:  brfalse.s  IL_00cc

    IL_0098:  ldarg.0
    IL_0099:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_pbImage
    IL_009e:  ldloc.0
    IL_009f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_Resize(class [mscorlib]System.EventHandler)
    IL_00a4:  nop
    IL_00a5:  ldarg.0
    IL_00a6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_pbImage
    IL_00ab:  ldloc.1
    IL_00ac:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_DragDrop(class [System.Windows.Forms]System.Windows.Forms.DragEventHandler)
    IL_00b1:  nop
    IL_00b2:  ldarg.0
    IL_00b3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_pbImage
    IL_00b8:  ldloc.2
    IL_00b9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_MouseClick(class [System.Windows.Forms]System.Windows.Forms.MouseEventHandler)
    IL_00be:  nop
    IL_00bf:  ldarg.0
    IL_00c0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_pbImage
    IL_00c5:  ldloc.3
    IL_00c6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_DragEnter(class [System.Windows.Forms]System.Windows.Forms.DragEventHandler)
    IL_00cb:  nop
    IL_00cc:  nop
    IL_00cd:  nop
    IL_00ce:  ret
  } // end of method MainForm::set_pbImage

  .method private newslot specialname strict virtual 
          instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton 
          get_btnLoadImage() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (class [System.Windows.Forms]System.Windows.Forms.ToolStripButton V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnLoadImage
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method MainForm::get_btnLoadImage

  .method private newslot specialname strict virtual 
          instance void  set_btnLoadImage(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton WithEventsValue) cil managed synchronized
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       83 (0x53)
    .maxstack  2
    .locals init (class [mscorlib]System.EventHandler V_0,
             bool V_1)
    IL_0000:  ldarg.0
    IL_0001:  dup
    IL_0002:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnLoadImage_Click(object,
                                                                                                                                   class [mscorlib]System.EventArgs)
    IL_0008:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_000d:  stloc.0
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnLoadImage
    IL_0014:  ldnull
    IL_0015:  ceq
    IL_0017:  ldc.i4.0
    IL_0018:  ceq
    IL_001a:  stloc.1
    IL_001b:  ldloc.1
    IL_001c:  brfalse.s  IL_002b

    IL_001e:  ldarg.0
    IL_001f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnLoadImage
    IL_0024:  ldloc.0
    IL_0025:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::remove_Click(class [mscorlib]System.EventHandler)
    IL_002a:  nop
    IL_002b:  nop
    IL_002c:  ldarg.0
    IL_002d:  ldarg.1
    IL_002e:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnLoadImage
    IL_0033:  ldarg.0
    IL_0034:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnLoadImage
    IL_0039:  ldnull
    IL_003a:  ceq
    IL_003c:  ldc.i4.0
    IL_003d:  ceq
    IL_003f:  stloc.1
    IL_0040:  ldloc.1
    IL_0041:  brfalse.s  IL_0050

    IL_0043:  ldarg.0
    IL_0044:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnLoadImage
    IL_0049:  ldloc.0
    IL_004a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_004f:  nop
    IL_0050:  nop
    IL_0051:  nop
    IL_0052:  ret
  } // end of method MainForm::set_btnLoadImage

  .method private newslot specialname strict virtual 
          instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton 
          get_btnSaveImage() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (class [System.Windows.Forms]System.Windows.Forms.ToolStripButton V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnSaveImage
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method MainForm::get_btnSaveImage

  .method private newslot specialname strict virtual 
          instance void  set_btnSaveImage(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton WithEventsValue) cil managed synchronized
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       83 (0x53)
    .maxstack  2
    .locals init (class [mscorlib]System.EventHandler V_0,
             bool V_1)
    IL_0000:  ldarg.0
    IL_0001:  dup
    IL_0002:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnSaveImage_Click(object,
                                                                                                                                   class [mscorlib]System.EventArgs)
    IL_0008:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_000d:  stloc.0
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnSaveImage
    IL_0014:  ldnull
    IL_0015:  ceq
    IL_0017:  ldc.i4.0
    IL_0018:  ceq
    IL_001a:  stloc.1
    IL_001b:  ldloc.1
    IL_001c:  brfalse.s  IL_002b

    IL_001e:  ldarg.0
    IL_001f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnSaveImage
    IL_0024:  ldloc.0
    IL_0025:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::remove_Click(class [mscorlib]System.EventHandler)
    IL_002a:  nop
    IL_002b:  nop
    IL_002c:  ldarg.0
    IL_002d:  ldarg.1
    IL_002e:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnSaveImage
    IL_0033:  ldarg.0
    IL_0034:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnSaveImage
    IL_0039:  ldnull
    IL_003a:  ceq
    IL_003c:  ldc.i4.0
    IL_003d:  ceq
    IL_003f:  stloc.1
    IL_0040:  ldloc.1
    IL_0041:  brfalse.s  IL_0050

    IL_0043:  ldarg.0
    IL_0044:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnSaveImage
    IL_0049:  ldloc.0
    IL_004a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_004f:  nop
    IL_0050:  nop
    IL_0051:  nop
    IL_0052:  ret
  } // end of method MainForm::set_btnSaveImage

  .method private newslot specialname strict virtual 
          instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar 
          get_tbEpsilon() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_tbEpsilon
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method MainForm::get_tbEpsilon

  .method private newslot specialname strict virtual 
          instance void  set_tbEpsilon(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar WithEventsValue) cil managed synchronized
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       83 (0x53)
    .maxstack  2
    .locals init (class [mscorlib]System.EventHandler V_0,
             bool V_1)
    IL_0000:  ldarg.0
    IL_0001:  dup
    IL_0002:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbEpsilon_ValueChanged(object,
                                                                                                                                       class [mscorlib]System.EventArgs)
    IL_0008:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_000d:  stloc.0
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_tbEpsilon
    IL_0014:  ldnull
    IL_0015:  ceq
    IL_0017:  ldc.i4.0
    IL_0018:  ceq
    IL_001a:  stloc.1
    IL_001b:  ldloc.1
    IL_001c:  brfalse.s  IL_002b

    IL_001e:  ldarg.0
    IL_001f:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_tbEpsilon
    IL_0024:  ldloc.0
    IL_0025:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::remove_ValueChanged(class [mscorlib]System.EventHandler)
    IL_002a:  nop
    IL_002b:  nop
    IL_002c:  ldarg.0
    IL_002d:  ldarg.1
    IL_002e:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_tbEpsilon
    IL_0033:  ldarg.0
    IL_0034:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_tbEpsilon
    IL_0039:  ldnull
    IL_003a:  ceq
    IL_003c:  ldc.i4.0
    IL_003d:  ceq
    IL_003f:  stloc.1
    IL_0040:  ldloc.1
    IL_0041:  brfalse.s  IL_0050

    IL_0043:  ldarg.0
    IL_0044:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_tbEpsilon
    IL_0049:  ldloc.0
    IL_004a:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::add_ValueChanged(class [mscorlib]System.EventHandler)
    IL_004f:  nop
    IL_0050:  nop
    IL_0051:  nop
    IL_0052:  ret
  } // end of method MainForm::set_tbEpsilon

  .method private newslot specialname strict virtual 
          instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton 
          get_btnInk() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (class [System.Windows.Forms]System.Windows.Forms.ToolStripButton V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnInk
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method MainForm::get_btnInk

  .method private newslot specialname strict virtual 
          instance void  set_btnInk(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton WithEventsValue) cil managed synchronized
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       83 (0x53)
    .maxstack  2
    .locals init (class [mscorlib]System.EventHandler V_0,
             bool V_1)
    IL_0000:  ldarg.0
    IL_0001:  dup
    IL_0002:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnInk_Click(object,
                                                                                                                             class [mscorlib]System.EventArgs)
    IL_0008:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_000d:  stloc.0
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnInk
    IL_0014:  ldnull
    IL_0015:  ceq
    IL_0017:  ldc.i4.0
    IL_0018:  ceq
    IL_001a:  stloc.1
    IL_001b:  ldloc.1
    IL_001c:  brfalse.s  IL_002b

    IL_001e:  ldarg.0
    IL_001f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnInk
    IL_0024:  ldloc.0
    IL_0025:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::remove_Click(class [mscorlib]System.EventHandler)
    IL_002a:  nop
    IL_002b:  nop
    IL_002c:  ldarg.0
    IL_002d:  ldarg.1
    IL_002e:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnInk
    IL_0033:  ldarg.0
    IL_0034:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnInk
    IL_0039:  ldnull
    IL_003a:  ceq
    IL_003c:  ldc.i4.0
    IL_003d:  ceq
    IL_003f:  stloc.1
    IL_0040:  ldloc.1
    IL_0041:  brfalse.s  IL_0050

    IL_0043:  ldarg.0
    IL_0044:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnInk
    IL_0049:  ldloc.0
    IL_004a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_004f:  nop
    IL_0050:  nop
    IL_0051:  nop
    IL_0052:  ret
  } // end of method MainForm::set_btnInk

  .method private newslot specialname strict virtual 
          instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton 
          get_btnEraser() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (class [System.Windows.Forms]System.Windows.Forms.ToolStripButton V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnEraser
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method MainForm::get_btnEraser

  .method private newslot specialname strict virtual 
          instance void  set_btnEraser(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton WithEventsValue) cil managed synchronized
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       83 (0x53)
    .maxstack  2
    .locals init (class [mscorlib]System.EventHandler V_0,
             bool V_1)
    IL_0000:  ldarg.0
    IL_0001:  dup
    IL_0002:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnEraser_Click(object,
                                                                                                                                class [mscorlib]System.EventArgs)
    IL_0008:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_000d:  stloc.0
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnEraser
    IL_0014:  ldnull
    IL_0015:  ceq
    IL_0017:  ldc.i4.0
    IL_0018:  ceq
    IL_001a:  stloc.1
    IL_001b:  ldloc.1
    IL_001c:  brfalse.s  IL_002b

    IL_001e:  ldarg.0
    IL_001f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnEraser
    IL_0024:  ldloc.0
    IL_0025:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::remove_Click(class [mscorlib]System.EventHandler)
    IL_002a:  nop
    IL_002b:  nop
    IL_002c:  ldarg.0
    IL_002d:  ldarg.1
    IL_002e:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnEraser
    IL_0033:  ldarg.0
    IL_0034:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnEraser
    IL_0039:  ldnull
    IL_003a:  ceq
    IL_003c:  ldc.i4.0
    IL_003d:  ceq
    IL_003f:  stloc.1
    IL_0040:  ldloc.1
    IL_0041:  brfalse.s  IL_0050

    IL_0043:  ldarg.0
    IL_0044:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnEraser
    IL_0049:  ldloc.0
    IL_004a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_004f:  nop
    IL_0050:  nop
    IL_0051:  nop
    IL_0052:  ret
  } // end of method MainForm::set_btnEraser

  .method private newslot specialname strict virtual 
          instance class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel 
          get_lblHuesSelected() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lblHuesSelected
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method MainForm::get_lblHuesSelected

  .method private newslot specialname strict virtual 
          instance void  set_lblHuesSelected(class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel WithEventsValue) cil managed synchronized
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       83 (0x53)
    .maxstack  2
    .locals init (class [mscorlib]System.EventHandler V_0,
             bool V_1)
    IL_0000:  ldarg.0
    IL_0001:  dup
    IL_0002:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblHuesSelected_Click(object,
                                                                                                                                      class [mscorlib]System.EventArgs)
    IL_0008:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_000d:  stloc.0
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lblHuesSelected
    IL_0014:  ldnull
    IL_0015:  ceq
    IL_0017:  ldc.i4.0
    IL_0018:  ceq
    IL_001a:  stloc.1
    IL_001b:  ldloc.1
    IL_001c:  brfalse.s  IL_002b

    IL_001e:  ldarg.0
    IL_001f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lblHuesSelected
    IL_0024:  ldloc.0
    IL_0025:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::remove_Click(class [mscorlib]System.EventHandler)
    IL_002a:  nop
    IL_002b:  nop
    IL_002c:  ldarg.0
    IL_002d:  ldarg.1
    IL_002e:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lblHuesSelected
    IL_0033:  ldarg.0
    IL_0034:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lblHuesSelected
    IL_0039:  ldnull
    IL_003a:  ceq
    IL_003c:  ldc.i4.0
    IL_003d:  ceq
    IL_003f:  stloc.1
    IL_0040:  ldloc.1
    IL_0041:  brfalse.s  IL_0050

    IL_0043:  ldarg.0
    IL_0044:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lblHuesSelected
    IL_0049:  ldloc.0
    IL_004a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_004f:  nop
    IL_0050:  nop
    IL_0051:  nop
    IL_0052:  ret
  } // end of method MainForm::set_lblHuesSelected

  .method private newslot specialname strict virtual 
          instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton 
          get_btnParallel() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (class [System.Windows.Forms]System.Windows.Forms.ToolStripButton V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnParallel
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method MainForm::get_btnParallel

  .method private newslot specialname strict virtual 
          instance void  set_btnParallel(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton WithEventsValue) cil managed synchronized
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       83 (0x53)
    .maxstack  2
    .locals init (class [mscorlib]System.EventHandler V_0,
             bool V_1)
    IL_0000:  ldarg.0
    IL_0001:  dup
    IL_0002:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnParallel_CheckedChanged(object,
                                                                                                                                           class [mscorlib]System.EventArgs)
    IL_0008:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_000d:  stloc.0
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnParallel
    IL_0014:  ldnull
    IL_0015:  ceq
    IL_0017:  ldc.i4.0
    IL_0018:  ceq
    IL_001a:  stloc.1
    IL_001b:  ldloc.1
    IL_001c:  brfalse.s  IL_002b

    IL_001e:  ldarg.0
    IL_001f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnParallel
    IL_0024:  ldloc.0
    IL_0025:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::remove_CheckedChanged(class [mscorlib]System.EventHandler)
    IL_002a:  nop
    IL_002b:  nop
    IL_002c:  ldarg.0
    IL_002d:  ldarg.1
    IL_002e:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnParallel
    IL_0033:  ldarg.0
    IL_0034:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnParallel
    IL_0039:  ldnull
    IL_003a:  ceq
    IL_003c:  ldc.i4.0
    IL_003d:  ceq
    IL_003f:  stloc.1
    IL_0040:  ldloc.1
    IL_0041:  brfalse.s  IL_0050

    IL_0043:  ldarg.0
    IL_0044:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_btnParallel
    IL_0049:  ldloc.0
    IL_004a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::add_CheckedChanged(class [mscorlib]System.EventHandler)
    IL_004f:  nop
    IL_0050:  nop
    IL_0051:  nop
    IL_0052:  ret
  } // end of method MainForm::set_btnParallel

  .method public specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       83 (0x53)
    .maxstack  3
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb' 
//000022: 		Public Sub New()
    IL_0000:  nop
//000023: 			InitializeComponent()
//000024: 		End Sub
//000025: 
//000026: 		''' <summary>A list of all selected points from which colors will be extracted from the image.</summary>
//000027: 		Private _selectedPixels As New List(Of Point)()
//000028: 		''' <summary>The last hue epsilon selected by the user.</summary>
//000029: 		Private _lastEpsilon As Integer = -1
//000030: 		''' <summary>The last size of the image picture box before a resize.</summary>
//000031: 		Private _lastPictureBoxSize As New Size(-1, -1)
//000032: 		''' <summary>A list of GraphicsPaths currently translated from Strokes.</summary>
//000033: 		Private _paths As List(Of GraphicsPath)
//000034: 		''' <summary>The image as originally loaded.</summary>
//000035: 		Private _originalImage As Bitmap
//000036: 		''' <summary>The current image after all color transformations.</summary>
//000037: 		Private _colorizedImage As Bitmap
//000038: 		''' <summary>The InkOverlay used for accepting strokes to be translated into GraphicsPaths.</summary>
//000039: 		Private _overlay As InkOverlay
//000040: 
//000041: 		''' <summary>Loads the form.</summary>
//000042: 		Private Sub MainForm_Load(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Load
//000043: 			' Store the current size of the picture box.  When the picture box is
//000044: 			' resized (due to the form being resized), we need to scale any ink
//000045: 			' that may exist on the form so that it sizes in accordance with the picture box.
//000046: 			_lastPictureBoxSize = pbImage.Size
//000047: 			pbImage.AllowDrop = True
//000048: 
//000049:             ' If the current platform supports ink, initialize the InkOverlay.
//000050: 			If PlatformDetection.SupportsInk Then
//000051: 				InitializeInk()
//000052: 			End If
//000053: 
//000054:             ' Setup the help text for the toolstrip.
//000055: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000056: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000057: 		End Sub
//000058: 
//000059: 		Private _ofd As OpenFileDialog
//000060: 
//000061: 		''' <summary>Shows an OpenFileDialog and loads the selected image into the app.</summary>
//000062: 		Private Sub btnLoadImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnLoadImage.Click
//000063:             ' Show a dialog to select JPG files.
//000064: 			If _ofd Is Nothing Then
//000065: 				_ofd = New OpenFileDialog()
//000066: 				_ofd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif"
//000067: 				_ofd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures)
//000068: 			End If
//000069: 			If _ofd.ShowDialog() = DialogResult.OK Then
//000070: 				LoadImage(_ofd.FileName)
//000071: 			End If
//000072: 		End Sub
//000073: 
//000074: 		Private Sub LoadImage(ByVal path As String)
//000075: 			Try
//000076: 				_originalImage = New Bitmap(path)
//000077: 				pbImage.Image = _originalImage
//000078: 
//000079: 				' Disable saving of the image.  We only allow saving once changes have been made.
//000080: 				btnSaveImage.Enabled = False
//000081: 
//000082: 				' Change the cursor on the picture box to let the user know they
//000083: 				' can click on the image to select a hue.
//000084:                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand
//000085: 
//000086: 
//000087: 				' If ink is available on the current machine, enable the button that
//000088: 				' turns on the overlay, and clear any existing ink from previous images
//000089:                 ' that may have existed in the app.
//000090: 				If PlatformDetection.SupportsInk Then
//000091: 					btnInk.Enabled = True
//000092: 					ClearInk()
//000093: 				End If
//000094: 			Catch e1 As ArgumentException
//000095: 			End Try
//000096: 		End Sub
//000097: 
//000098: 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
//000099: 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
//000100:             ' Only run if an image has been loaded and if ink isn't being drawn.
//000101: 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
//000102: 				' Get the point in the original image.  To get this we need
//000103: 				' to scale the selected point based on how much the image
//000104: 				' is being resized for display.
//000105: 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
//000106: 
//000107: 				' Add the selected point to the list or make it the only
//000108:                 ' point in the list, based on whether the shift key is being held down.
//000109: 				If Control.ModifierKeys <> Keys.Shift Then
//000110: 					_selectedPixels.Clear()
//000111: 				End If
//000112: 				_selectedPixels.Add(p)
//000113: 
//000114: 				' With our updated list of selected pixels in hand, update
//000115:                 ' the toolstrip help text.
//000116: 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000117: 
//000118:                 ' Start recomputing the image based on the new parameters.
//000119: 				StartColorizeImage()
//000120: 			End If
//000121: 		End Sub
//000122: 
//000123: 		Private Sub StartColorizeImage()
//000124: 			' Stop the timer if it's running, since the timer's purpose
//000125:             ' is to cause this method to be called when the timer expires.
//000126: 			tmRefresh.Stop()
//000127: 			_lastEpsilon = tbEpsilon.Value
//000128: 
//000129: 			' If we have an image and if a pixel has been selected
//000130: 			' and if we're not currently recomputing the image...
//000131: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
//000132:                 ' If there are any strokes, turn them into GraphicsPaths.
//000133: 				If PlatformDetection.SupportsInk Then
//000134: 					If _paths IsNot Nothing Then
//000135: 						For Each path As GraphicsPath In _paths
//000136: 							path.Dispose()
//000137: 						Next path
//000138: 					End If
//000139: 					_paths = InkToGraphicsPaths(True)
//000140: 				End If
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
//000144: 				pbImage.Enabled = False
//000145: 				pbColorizing.Value = 0
//000146: 				pbColorizing.Visible = True
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
//000150: 			End If
//000151: 		End Sub
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0001:  ldarg.0
    IL_0002:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::.ctor()
    IL_0007:  nop
    IL_0008:  ldarg.0
    IL_0009:  ldarg.0
    IL_000a:  dup
    IL_000b:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::MainForm_Load(object,
                                                                                                                              class [mscorlib]System.EventArgs)
    IL_0011:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0016:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::add_Load(class [mscorlib]System.EventHandler)
    IL_001b:  nop
    IL_001c:  ldarg.0
    IL_001d:  call       void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::__ENCAddToList(object)
    IL_0022:  nop
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb' 
//000006:         Private components As System.ComponentModel.IContainer = Nothing
    IL_0023:  ldarg.0
    IL_0024:  ldnull
    IL_0025:  stfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb' 
//000027: 		Private _selectedPixels As New List(Of Point)()
    IL_002a:  ldarg.0
    IL_002b:  newobj     instance void class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::.ctor()
    IL_0030:  stfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
//000028: 		''' <summary>The last hue epsilon selected by the user.</summary>
//000029: 		Private _lastEpsilon As Integer = -1
    IL_0035:  ldarg.0
    IL_0036:  ldc.i4.m1
    IL_0037:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastEpsilon
//000030: 		''' <summary>The last size of the image picture box before a resize.</summary>
//000031: 		Private _lastPictureBoxSize As New Size(-1, -1)
    IL_003c:  ldarg.0
    IL_003d:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
    IL_0042:  ldc.i4.m1
    IL_0043:  ldc.i4.m1
    IL_0044:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0049:  nop
//000023: 			InitializeComponent()
    IL_004a:  ldarg.0
    IL_004b:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::InitializeComponent()
    IL_0050:  nop
//000024: 		End Sub
    IL_0051:  nop
    IL_0052:  ret
  } // end of method MainForm::.ctor

  .method private instance void  MainForm_Load(object sender,
                                               class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       126 (0x7e)
    .maxstack  3
    .locals init ([0] bool VB$CG$t_bool$S0)
//000025: 
//000026: 		''' <summary>A list of all selected points from which colors will be extracted from the image.</summary>
//000027: 		Private _selectedPixels As New List(Of Point)()
//000028: 		''' <summary>The last hue epsilon selected by the user.</summary>
//000029: 		Private _lastEpsilon As Integer = -1
//000030: 		''' <summary>The last size of the image picture box before a resize.</summary>
//000031: 		Private _lastPictureBoxSize As New Size(-1, -1)
//000032: 		''' <summary>A list of GraphicsPaths currently translated from Strokes.</summary>
//000033: 		Private _paths As List(Of GraphicsPath)
//000034: 		''' <summary>The image as originally loaded.</summary>
//000035: 		Private _originalImage As Bitmap
//000036: 		''' <summary>The current image after all color transformations.</summary>
//000037: 		Private _colorizedImage As Bitmap
//000038: 		''' <summary>The InkOverlay used for accepting strokes to be translated into GraphicsPaths.</summary>
//000039: 		Private _overlay As InkOverlay
//000040: 
//000041: 		''' <summary>Loads the form.</summary>
//000042: 		Private Sub MainForm_Load(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Load
    IL_0000:  nop
//000043: 			' Store the current size of the picture box.  When the picture box is
//000044: 			' resized (due to the form being resized), we need to scale any ink
//000045: 			' that may exist on the form so that it sizes in accordance with the picture box.
//000046: 			_lastPictureBoxSize = pbImage.Size
    IL_0001:  ldarg.0
    IL_0002:  ldarg.0
    IL_0003:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0008:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Control::get_Size()
    IL_000d:  stfld      valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
//000047: 			pbImage.AllowDrop = True
    IL_0012:  ldarg.0
    IL_0013:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0018:  ldc.i4.1
    IL_0019:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_AllowDrop(bool)
    IL_001e:  nop
//000048: 
//000049:             ' If the current platform supports ink, initialize the InkOverlay.
//000050: 			If PlatformDetection.SupportsInk Then
    IL_001f:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_SupportsInk()
    IL_0024:  stloc.0
//000051: 				InitializeInk()
//000052: 			End If
//000053: 
//000054:             ' Setup the help text for the toolstrip.
//000055: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000056: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000057: 		End Sub
//000058: 
//000059: 		Private _ofd As OpenFileDialog
//000060: 
//000061: 		''' <summary>Shows an OpenFileDialog and loads the selected image into the app.</summary>
//000062: 		Private Sub btnLoadImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnLoadImage.Click
//000063:             ' Show a dialog to select JPG files.
//000064: 			If _ofd Is Nothing Then
//000065: 				_ofd = New OpenFileDialog()
//000066: 				_ofd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif"
//000067: 				_ofd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures)
//000068: 			End If
//000069: 			If _ofd.ShowDialog() = DialogResult.OK Then
//000070: 				LoadImage(_ofd.FileName)
//000071: 			End If
//000072: 		End Sub
//000073: 
//000074: 		Private Sub LoadImage(ByVal path As String)
//000075: 			Try
//000076: 				_originalImage = New Bitmap(path)
//000077: 				pbImage.Image = _originalImage
//000078: 
//000079: 				' Disable saving of the image.  We only allow saving once changes have been made.
//000080: 				btnSaveImage.Enabled = False
//000081: 
//000082: 				' Change the cursor on the picture box to let the user know they
//000083: 				' can click on the image to select a hue.
//000084:                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand
//000085: 
//000086: 
//000087: 				' If ink is available on the current machine, enable the button that
//000088: 				' turns on the overlay, and clear any existing ink from previous images
//000089:                 ' that may have existed in the app.
//000090: 				If PlatformDetection.SupportsInk Then
//000091: 					btnInk.Enabled = True
//000092: 					ClearInk()
//000093: 				End If
//000094: 			Catch e1 As ArgumentException
//000095: 			End Try
//000096: 		End Sub
//000097: 
//000098: 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
//000099: 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
//000100:             ' Only run if an image has been loaded and if ink isn't being drawn.
//000101: 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
//000102: 				' Get the point in the original image.  To get this we need
//000103: 				' to scale the selected point based on how much the image
//000104: 				' is being resized for display.
//000105: 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
//000106: 
//000107: 				' Add the selected point to the list or make it the only
//000108:                 ' point in the list, based on whether the shift key is being held down.
//000109: 				If Control.ModifierKeys <> Keys.Shift Then
//000110: 					_selectedPixels.Clear()
//000111: 				End If
//000112: 				_selectedPixels.Add(p)
//000113: 
//000114: 				' With our updated list of selected pixels in hand, update
//000115:                 ' the toolstrip help text.
//000116: 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000117: 
//000118:                 ' Start recomputing the image based on the new parameters.
//000119: 				StartColorizeImage()
//000120: 			End If
//000121: 		End Sub
//000122: 
//000123: 		Private Sub StartColorizeImage()
//000124: 			' Stop the timer if it's running, since the timer's purpose
//000125:             ' is to cause this method to be called when the timer expires.
//000126: 			tmRefresh.Stop()
//000127: 			_lastEpsilon = tbEpsilon.Value
//000128: 
//000129: 			' If we have an image and if a pixel has been selected
//000130: 			' and if we're not currently recomputing the image...
//000131: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
//000132:                 ' If there are any strokes, turn them into GraphicsPaths.
//000133: 				If PlatformDetection.SupportsInk Then
//000134: 					If _paths IsNot Nothing Then
//000135: 						For Each path As GraphicsPath In _paths
//000136: 							path.Dispose()
//000137: 						Next path
//000138: 					End If
//000139: 					_paths = InkToGraphicsPaths(True)
//000140: 				End If
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
//000144: 				pbImage.Enabled = False
//000145: 				pbColorizing.Value = 0
//000146: 				pbColorizing.Visible = True
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
//000150: 			End If
//000151: 		End Sub
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0025:  ldloc.0
    IL_0026:  brfalse.s  IL_002f

//000051: 				InitializeInk()
    IL_0028:  ldarg.0
    IL_0029:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::InitializeInk()
    IL_002e:  nop
//000052: 			End If
    IL_002f:  nop
//000053: 
//000054:             ' Setup the help text for the toolstrip.
//000055: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
    IL_0030:  ldarg.0
    IL_0031:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_lblHuesSelected()
    IL_0036:  call       string My.Resources.Resources::get_HuesSelectedDisplay()
    IL_003b:  ldarg.0
    IL_003c:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_0041:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::get_Count()
    IL_0046:  box        [mscorlib]System.Int32
    IL_004b:  call       string [mscorlib]System.String::Format(string,
                                                                object)
    IL_0050:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0055:  nop
//000056: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
    IL_0056:  ldarg.0
    IL_0057:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tbEpsilon()
    IL_005c:  call       string My.Resources.Resources::get_EpsilonDisplay()
    IL_0061:  ldarg.0
    IL_0062:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tbEpsilon()
    IL_0067:  callvirt   instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_Value()
    IL_006c:  box        [mscorlib]System.Int32
    IL_0071:  call       string [mscorlib]System.String::Format(string,
                                                                object)
    IL_0076:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ToolTipText(string)
    IL_007b:  nop
//000057: 		End Sub
    IL_007c:  nop
    IL_007d:  ret
  } // end of method MainForm::MainForm_Load

  .method private instance void  btnLoadImage_Click(object sender,
                                                    class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       101 (0x65)
    .maxstack  2
    .locals init ([0] bool VB$CG$t_bool$S0)
//000058: 
//000059: 		Private _ofd As OpenFileDialog
//000060: 
//000061: 		''' <summary>Shows an OpenFileDialog and loads the selected image into the app.</summary>
//000062: 		Private Sub btnLoadImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnLoadImage.Click
    IL_0000:  nop
//000063:             ' Show a dialog to select JPG files.
//000064: 			If _ofd Is Nothing Then
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_ofd
    IL_0007:  ldnull
    IL_0008:  ceq
    IL_000a:  stloc.0
//000065: 				_ofd = New OpenFileDialog()
//000066: 				_ofd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif"
//000067: 				_ofd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures)
//000068: 			End If
//000069: 			If _ofd.ShowDialog() = DialogResult.OK Then
//000070: 				LoadImage(_ofd.FileName)
//000071: 			End If
//000072: 		End Sub
//000073: 
//000074: 		Private Sub LoadImage(ByVal path As String)
//000075: 			Try
//000076: 				_originalImage = New Bitmap(path)
//000077: 				pbImage.Image = _originalImage
//000078: 
//000079: 				' Disable saving of the image.  We only allow saving once changes have been made.
//000080: 				btnSaveImage.Enabled = False
//000081: 
//000082: 				' Change the cursor on the picture box to let the user know they
//000083: 				' can click on the image to select a hue.
//000084:                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand
//000085: 
//000086: 
//000087: 				' If ink is available on the current machine, enable the button that
//000088: 				' turns on the overlay, and clear any existing ink from previous images
//000089:                 ' that may have existed in the app.
//000090: 				If PlatformDetection.SupportsInk Then
//000091: 					btnInk.Enabled = True
//000092: 					ClearInk()
//000093: 				End If
//000094: 			Catch e1 As ArgumentException
//000095: 			End Try
//000096: 		End Sub
//000097: 
//000098: 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
//000099: 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
//000100:             ' Only run if an image has been loaded and if ink isn't being drawn.
//000101: 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
//000102: 				' Get the point in the original image.  To get this we need
//000103: 				' to scale the selected point based on how much the image
//000104: 				' is being resized for display.
//000105: 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
//000106: 
//000107: 				' Add the selected point to the list or make it the only
//000108:                 ' point in the list, based on whether the shift key is being held down.
//000109: 				If Control.ModifierKeys <> Keys.Shift Then
//000110: 					_selectedPixels.Clear()
//000111: 				End If
//000112: 				_selectedPixels.Add(p)
//000113: 
//000114: 				' With our updated list of selected pixels in hand, update
//000115:                 ' the toolstrip help text.
//000116: 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000117: 
//000118:                 ' Start recomputing the image based on the new parameters.
//000119: 				StartColorizeImage()
//000120: 			End If
//000121: 		End Sub
//000122: 
//000123: 		Private Sub StartColorizeImage()
//000124: 			' Stop the timer if it's running, since the timer's purpose
//000125:             ' is to cause this method to be called when the timer expires.
//000126: 			tmRefresh.Stop()
//000127: 			_lastEpsilon = tbEpsilon.Value
//000128: 
//000129: 			' If we have an image and if a pixel has been selected
//000130: 			' and if we're not currently recomputing the image...
//000131: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
//000132:                 ' If there are any strokes, turn them into GraphicsPaths.
//000133: 				If PlatformDetection.SupportsInk Then
//000134: 					If _paths IsNot Nothing Then
//000135: 						For Each path As GraphicsPath In _paths
//000136: 							path.Dispose()
//000137: 						Next path
//000138: 					End If
//000139: 					_paths = InkToGraphicsPaths(True)
//000140: 				End If
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
//000144: 				pbImage.Enabled = False
//000145: 				pbColorizing.Value = 0
//000146: 				pbColorizing.Visible = True
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
//000150: 			End If
//000151: 		End Sub
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_000b:  ldloc.0
    IL_000c:  brfalse.s  IL_003d

//000065: 				_ofd = New OpenFileDialog()
    IL_000e:  ldarg.0
    IL_000f:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.OpenFileDialog::.ctor()
    IL_0014:  stfld      class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_ofd
//000066: 				_ofd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif"
    IL_0019:  ldarg.0
    IL_001a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_ofd
    IL_001f:  ldstr      "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.b"
    + "mp;*.png;*.gif"
    IL_0024:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.FileDialog::set_Filter(string)
    IL_0029:  nop
//000067: 				_ofd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures)
    IL_002a:  ldarg.0
    IL_002b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_ofd
    IL_0030:  ldc.i4.s   39
    IL_0032:  call       string [mscorlib]System.Environment::GetFolderPath(valuetype [mscorlib]System.Environment/SpecialFolder)
    IL_0037:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.FileDialog::set_InitialDirectory(string)
    IL_003c:  nop
//000068: 			End If
    IL_003d:  nop
//000069: 			If _ofd.ShowDialog() = DialogResult.OK Then
    IL_003e:  ldarg.0
    IL_003f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_ofd
    IL_0044:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.DialogResult [System.Windows.Forms]System.Windows.Forms.CommonDialog::ShowDialog()
    IL_0049:  ldc.i4.1
    IL_004a:  ceq
    IL_004c:  stloc.0
//000070: 				LoadImage(_ofd.FileName)
//000071: 			End If
//000072: 		End Sub
//000073: 
//000074: 		Private Sub LoadImage(ByVal path As String)
//000075: 			Try
//000076: 				_originalImage = New Bitmap(path)
//000077: 				pbImage.Image = _originalImage
//000078: 
//000079: 				' Disable saving of the image.  We only allow saving once changes have been made.
//000080: 				btnSaveImage.Enabled = False
//000081: 
//000082: 				' Change the cursor on the picture box to let the user know they
//000083: 				' can click on the image to select a hue.
//000084:                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand
//000085: 
//000086: 
//000087: 				' If ink is available on the current machine, enable the button that
//000088: 				' turns on the overlay, and clear any existing ink from previous images
//000089:                 ' that may have existed in the app.
//000090: 				If PlatformDetection.SupportsInk Then
//000091: 					btnInk.Enabled = True
//000092: 					ClearInk()
//000093: 				End If
//000094: 			Catch e1 As ArgumentException
//000095: 			End Try
//000096: 		End Sub
//000097: 
//000098: 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
//000099: 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
//000100:             ' Only run if an image has been loaded and if ink isn't being drawn.
//000101: 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
//000102: 				' Get the point in the original image.  To get this we need
//000103: 				' to scale the selected point based on how much the image
//000104: 				' is being resized for display.
//000105: 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
//000106: 
//000107: 				' Add the selected point to the list or make it the only
//000108:                 ' point in the list, based on whether the shift key is being held down.
//000109: 				If Control.ModifierKeys <> Keys.Shift Then
//000110: 					_selectedPixels.Clear()
//000111: 				End If
//000112: 				_selectedPixels.Add(p)
//000113: 
//000114: 				' With our updated list of selected pixels in hand, update
//000115:                 ' the toolstrip help text.
//000116: 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000117: 
//000118:                 ' Start recomputing the image based on the new parameters.
//000119: 				StartColorizeImage()
//000120: 			End If
//000121: 		End Sub
//000122: 
//000123: 		Private Sub StartColorizeImage()
//000124: 			' Stop the timer if it's running, since the timer's purpose
//000125:             ' is to cause this method to be called when the timer expires.
//000126: 			tmRefresh.Stop()
//000127: 			_lastEpsilon = tbEpsilon.Value
//000128: 
//000129: 			' If we have an image and if a pixel has been selected
//000130: 			' and if we're not currently recomputing the image...
//000131: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
//000132:                 ' If there are any strokes, turn them into GraphicsPaths.
//000133: 				If PlatformDetection.SupportsInk Then
//000134: 					If _paths IsNot Nothing Then
//000135: 						For Each path As GraphicsPath In _paths
//000136: 							path.Dispose()
//000137: 						Next path
//000138: 					End If
//000139: 					_paths = InkToGraphicsPaths(True)
//000140: 				End If
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
//000144: 				pbImage.Enabled = False
//000145: 				pbColorizing.Value = 0
//000146: 				pbColorizing.Visible = True
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
//000150: 			End If
//000151: 		End Sub
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_004d:  ldloc.0
    IL_004e:  brfalse.s  IL_0062

//000070: 				LoadImage(_ofd.FileName)
    IL_0050:  ldarg.0
    IL_0051:  ldarg.0
    IL_0052:  ldfld      class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_ofd
    IL_0057:  callvirt   instance string [System.Windows.Forms]System.Windows.Forms.FileDialog::get_FileName()
    IL_005c:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::LoadImage(string)
    IL_0061:  nop
//000071: 			End If
    IL_0062:  nop
//000072: 		End Sub
    IL_0063:  nop
    IL_0064:  ret
  } // end of method MainForm::btnLoadImage_Click

  .method private instance void  LoadImage(string path) cil managed
  {
    // Code size       112 (0x70)
    .maxstack  2
    .locals init ([0] class [mscorlib]System.ArgumentException e1,
             [1] bool VB$CG$t_bool$S0)
//000073: 
//000074: 		Private Sub LoadImage(ByVal path As String)
    IL_0000:  nop
//000075: 			Try
    IL_0001:  nop
//000076: 				_originalImage = New Bitmap(path)
    .try
    {
      IL_0002:  ldarg.0
      IL_0003:  ldarg.1
      IL_0004:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(string)
      IL_0009:  stfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
//000077: 				pbImage.Image = _originalImage
      IL_000e:  ldarg.0
      IL_000f:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
      IL_0014:  ldarg.0
      IL_0015:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
      IL_001a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
      IL_001f:  nop
//000078: 
//000079: 				' Disable saving of the image.  We only allow saving once changes have been made.
//000080: 				btnSaveImage.Enabled = False
      IL_0020:  ldarg.0
      IL_0021:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnSaveImage()
      IL_0026:  ldc.i4.0
      IL_0027:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
      IL_002c:  nop
//000081: 
//000082: 				' Change the cursor on the picture box to let the user know they
//000083: 				' can click on the image to select a hue.
//000084:                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand
      IL_002d:  ldarg.0
      IL_002e:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
      IL_0033:  call       class [System.Windows.Forms]System.Windows.Forms.Cursor [System.Windows.Forms]System.Windows.Forms.Cursors::get_Hand()
      IL_0038:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Cursor(class [System.Windows.Forms]System.Windows.Forms.Cursor)
      IL_003d:  nop
//000085: 
//000086: 
//000087: 				' If ink is available on the current machine, enable the button that
//000088: 				' turns on the overlay, and clear any existing ink from previous images
//000089:                 ' that may have existed in the app.
//000090: 				If PlatformDetection.SupportsInk Then
      IL_003e:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_SupportsInk()
      IL_0043:  stloc.1
//000091: 					btnInk.Enabled = True
//000092: 					ClearInk()
//000093: 				End If
//000094: 			Catch e1 As ArgumentException
//000095: 			End Try
//000096: 		End Sub
//000097: 
//000098: 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
//000099: 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
//000100:             ' Only run if an image has been loaded and if ink isn't being drawn.
//000101: 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
//000102: 				' Get the point in the original image.  To get this we need
//000103: 				' to scale the selected point based on how much the image
//000104: 				' is being resized for display.
//000105: 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
//000106: 
//000107: 				' Add the selected point to the list or make it the only
//000108:                 ' point in the list, based on whether the shift key is being held down.
//000109: 				If Control.ModifierKeys <> Keys.Shift Then
//000110: 					_selectedPixels.Clear()
//000111: 				End If
//000112: 				_selectedPixels.Add(p)
//000113: 
//000114: 				' With our updated list of selected pixels in hand, update
//000115:                 ' the toolstrip help text.
//000116: 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000117: 
//000118:                 ' Start recomputing the image based on the new parameters.
//000119: 				StartColorizeImage()
//000120: 			End If
//000121: 		End Sub
//000122: 
//000123: 		Private Sub StartColorizeImage()
//000124: 			' Stop the timer if it's running, since the timer's purpose
//000125:             ' is to cause this method to be called when the timer expires.
//000126: 			tmRefresh.Stop()
//000127: 			_lastEpsilon = tbEpsilon.Value
//000128: 
//000129: 			' If we have an image and if a pixel has been selected
//000130: 			' and if we're not currently recomputing the image...
//000131: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
//000132:                 ' If there are any strokes, turn them into GraphicsPaths.
//000133: 				If PlatformDetection.SupportsInk Then
//000134: 					If _paths IsNot Nothing Then
//000135: 						For Each path As GraphicsPath In _paths
//000136: 							path.Dispose()
//000137: 						Next path
//000138: 					End If
//000139: 					_paths = InkToGraphicsPaths(True)
//000140: 				End If
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
//000144: 				pbImage.Enabled = False
//000145: 				pbColorizing.Value = 0
//000146: 				pbColorizing.Visible = True
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
//000150: 			End If
//000151: 		End Sub
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_0044:  ldloc.1
      IL_0045:  brfalse.s  IL_005b

//000091: 					btnInk.Enabled = True
      IL_0047:  ldarg.0
      IL_0048:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnInk()
      IL_004d:  ldc.i4.1
      IL_004e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
      IL_0053:  nop
//000092: 					ClearInk()
      IL_0054:  ldarg.0
      IL_0055:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::ClearInk()
      IL_005a:  nop
//000093: 				End If
      IL_005b:  nop
//000094: 			Catch e1 As ArgumentException
//000095: 			End Try
//000096: 		End Sub
//000097: 
//000098: 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
//000099: 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
//000100:             ' Only run if an image has been loaded and if ink isn't being drawn.
//000101: 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
//000102: 				' Get the point in the original image.  To get this we need
//000103: 				' to scale the selected point based on how much the image
//000104: 				' is being resized for display.
//000105: 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
//000106: 
//000107: 				' Add the selected point to the list or make it the only
//000108:                 ' point in the list, based on whether the shift key is being held down.
//000109: 				If Control.ModifierKeys <> Keys.Shift Then
//000110: 					_selectedPixels.Clear()
//000111: 				End If
//000112: 				_selectedPixels.Add(p)
//000113: 
//000114: 				' With our updated list of selected pixels in hand, update
//000115:                 ' the toolstrip help text.
//000116: 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000117: 
//000118:                 ' Start recomputing the image based on the new parameters.
//000119: 				StartColorizeImage()
//000120: 			End If
//000121: 		End Sub
//000122: 
//000123: 		Private Sub StartColorizeImage()
//000124: 			' Stop the timer if it's running, since the timer's purpose
//000125:             ' is to cause this method to be called when the timer expires.
//000126: 			tmRefresh.Stop()
//000127: 			_lastEpsilon = tbEpsilon.Value
//000128: 
//000129: 			' If we have an image and if a pixel has been selected
//000130: 			' and if we're not currently recomputing the image...
//000131: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
//000132:                 ' If there are any strokes, turn them into GraphicsPaths.
//000133: 				If PlatformDetection.SupportsInk Then
//000134: 					If _paths IsNot Nothing Then
//000135: 						For Each path As GraphicsPath In _paths
//000136: 							path.Dispose()
//000137: 						Next path
//000138: 					End If
//000139: 					_paths = InkToGraphicsPaths(True)
//000140: 				End If
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
//000144: 				pbImage.Enabled = False
//000145: 				pbColorizing.Value = 0
//000146: 				pbColorizing.Visible = True
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
//000150: 			End If
//000151: 		End Sub
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_005c:  leave.s    IL_006d

    }  // end .try
    catch [mscorlib]System.ArgumentException 
    {
      IL_005e:  dup
      IL_005f:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::SetProjectError(class [mscorlib]System.Exception)
      IL_0064:  stloc.0
//000094: 			Catch e1 As ArgumentException
      IL_0065:  nop
      IL_0066:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::ClearProjectError()
//000095: 			End Try
//000096: 		End Sub
//000097: 
//000098: 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
//000099: 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
//000100:             ' Only run if an image has been loaded and if ink isn't being drawn.
//000101: 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
//000102: 				' Get the point in the original image.  To get this we need
//000103: 				' to scale the selected point based on how much the image
//000104: 				' is being resized for display.
//000105: 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
//000106: 
//000107: 				' Add the selected point to the list or make it the only
//000108:                 ' point in the list, based on whether the shift key is being held down.
//000109: 				If Control.ModifierKeys <> Keys.Shift Then
//000110: 					_selectedPixels.Clear()
//000111: 				End If
//000112: 				_selectedPixels.Add(p)
//000113: 
//000114: 				' With our updated list of selected pixels in hand, update
//000115:                 ' the toolstrip help text.
//000116: 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000117: 
//000118:                 ' Start recomputing the image based on the new parameters.
//000119: 				StartColorizeImage()
//000120: 			End If
//000121: 		End Sub
//000122: 
//000123: 		Private Sub StartColorizeImage()
//000124: 			' Stop the timer if it's running, since the timer's purpose
//000125:             ' is to cause this method to be called when the timer expires.
//000126: 			tmRefresh.Stop()
//000127: 			_lastEpsilon = tbEpsilon.Value
//000128: 
//000129: 			' If we have an image and if a pixel has been selected
//000130: 			' and if we're not currently recomputing the image...
//000131: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
//000132:                 ' If there are any strokes, turn them into GraphicsPaths.
//000133: 				If PlatformDetection.SupportsInk Then
//000134: 					If _paths IsNot Nothing Then
//000135: 						For Each path As GraphicsPath In _paths
//000136: 							path.Dispose()
//000137: 						Next path
//000138: 					End If
//000139: 					_paths = InkToGraphicsPaths(True)
//000140: 				End If
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
//000144: 				pbImage.Enabled = False
//000145: 				pbColorizing.Value = 0
//000146: 				pbColorizing.Visible = True
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
//000150: 			End If
//000151: 		End Sub
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_006b:  leave.s    IL_006d

//000095: 			End Try
    }  // end handler
    IL_006d:  nop
//000096: 		End Sub
    IL_006e:  nop
    IL_006f:  ret
  } // end of method MainForm::LoadImage

  .method private instance void  pbImage_MouseClick(object sender,
                                                    class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs e) cil managed
  {
    // Code size       233 (0xe9)
    .maxstack  4
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Point p,
             [1] bool VB$CG$t_bool$S0)
//000097: 
//000098: 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
//000099: 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
    IL_0000:  nop
//000100:             ' Only run if an image has been loaded and if ink isn't being drawn.
//000101: 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0007:  brfalse.s  IL_0023

    IL_0009:  ldarg.0
    IL_000a:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnInk()
    IL_000f:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.ToolStripItem::get_Enabled()
    IL_0014:  brfalse.s  IL_0026

    IL_0016:  ldarg.0
    IL_0017:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnInk()
    IL_001c:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.ToolStripButton::get_Checked()
    IL_0021:  brfalse.s  IL_0026

    IL_0023:  ldc.i4.0
    IL_0024:  br.s       IL_0027

    IL_0026:  ldc.i4.1
    IL_0027:  stloc.1
//000102: 				' Get the point in the original image.  To get this we need
//000103: 				' to scale the selected point based on how much the image
//000104: 				' is being resized for display.
//000105: 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
//000106: 
//000107: 				' Add the selected point to the list or make it the only
//000108:                 ' point in the list, based on whether the shift key is being held down.
//000109: 				If Control.ModifierKeys <> Keys.Shift Then
//000110: 					_selectedPixels.Clear()
//000111: 				End If
//000112: 				_selectedPixels.Add(p)
//000113: 
//000114: 				' With our updated list of selected pixels in hand, update
//000115:                 ' the toolstrip help text.
//000116: 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000117: 
//000118:                 ' Start recomputing the image based on the new parameters.
//000119: 				StartColorizeImage()
//000120: 			End If
//000121: 		End Sub
//000122: 
//000123: 		Private Sub StartColorizeImage()
//000124: 			' Stop the timer if it's running, since the timer's purpose
//000125:             ' is to cause this method to be called when the timer expires.
//000126: 			tmRefresh.Stop()
//000127: 			_lastEpsilon = tbEpsilon.Value
//000128: 
//000129: 			' If we have an image and if a pixel has been selected
//000130: 			' and if we're not currently recomputing the image...
//000131: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
//000132:                 ' If there are any strokes, turn them into GraphicsPaths.
//000133: 				If PlatformDetection.SupportsInk Then
//000134: 					If _paths IsNot Nothing Then
//000135: 						For Each path As GraphicsPath In _paths
//000136: 							path.Dispose()
//000137: 						Next path
//000138: 					End If
//000139: 					_paths = InkToGraphicsPaths(True)
//000140: 				End If
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
//000144: 				pbImage.Enabled = False
//000145: 				pbColorizing.Value = 0
//000146: 				pbColorizing.Visible = True
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
//000150: 			End If
//000151: 		End Sub
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0028:  ldloc.1
    IL_0029:  brfalse    IL_00e6

//000105: 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
    IL_002e:  ldloca.s   p
    IL_0030:  ldarg.2
    IL_0031:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_X()
    IL_0036:  ldarg.0
    IL_0037:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_003c:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0041:  mul.ovf
    IL_0042:  conv.r8
    IL_0043:  ldarg.0
    IL_0044:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0049:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
    IL_004e:  conv.r8
    IL_004f:  div
    IL_0050:  call       float64 [Microsoft.VisualBasic]Microsoft.VisualBasic.Conversion::Fix(float64)
    IL_0055:  call       float64 [mscorlib]System.Math::Round(float64)
    IL_005a:  conv.ovf.i4
    IL_005b:  ldarg.2
    IL_005c:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Y()
    IL_0061:  ldarg.0
    IL_0062:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0067:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_006c:  mul.ovf
    IL_006d:  conv.r8
    IL_006e:  ldarg.0
    IL_006f:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0074:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
    IL_0079:  conv.r8
    IL_007a:  div
    IL_007b:  call       float64 [Microsoft.VisualBasic]Microsoft.VisualBasic.Conversion::Fix(float64)
    IL_0080:  call       float64 [mscorlib]System.Math::Round(float64)
    IL_0085:  conv.ovf.i4
    IL_0086:  call       instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_008b:  nop
//000106: 
//000107: 				' Add the selected point to the list or make it the only
//000108:                 ' point in the list, based on whether the shift key is being held down.
//000109: 				If Control.ModifierKeys <> Keys.Shift Then
    IL_008c:  call       valuetype [System.Windows.Forms]System.Windows.Forms.Keys [System.Windows.Forms]System.Windows.Forms.Control::get_ModifierKeys()
    IL_0091:  ldc.i4     0x10000
    IL_0096:  ceq
    IL_0098:  ldc.i4.0
    IL_0099:  ceq
    IL_009b:  stloc.1
//000110: 					_selectedPixels.Clear()
//000111: 				End If
//000112: 				_selectedPixels.Add(p)
//000113: 
//000114: 				' With our updated list of selected pixels in hand, update
//000115:                 ' the toolstrip help text.
//000116: 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000117: 
//000118:                 ' Start recomputing the image based on the new parameters.
//000119: 				StartColorizeImage()
//000120: 			End If
//000121: 		End Sub
//000122: 
//000123: 		Private Sub StartColorizeImage()
//000124: 			' Stop the timer if it's running, since the timer's purpose
//000125:             ' is to cause this method to be called when the timer expires.
//000126: 			tmRefresh.Stop()
//000127: 			_lastEpsilon = tbEpsilon.Value
//000128: 
//000129: 			' If we have an image and if a pixel has been selected
//000130: 			' and if we're not currently recomputing the image...
//000131: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
//000132:                 ' If there are any strokes, turn them into GraphicsPaths.
//000133: 				If PlatformDetection.SupportsInk Then
//000134: 					If _paths IsNot Nothing Then
//000135: 						For Each path As GraphicsPath In _paths
//000136: 							path.Dispose()
//000137: 						Next path
//000138: 					End If
//000139: 					_paths = InkToGraphicsPaths(True)
//000140: 				End If
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
//000144: 				pbImage.Enabled = False
//000145: 				pbColorizing.Value = 0
//000146: 				pbColorizing.Visible = True
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
//000150: 			End If
//000151: 		End Sub
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_009c:  ldloc.1
    IL_009d:  brfalse.s  IL_00ab

//000110: 					_selectedPixels.Clear()
    IL_009f:  ldarg.0
    IL_00a0:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_00a5:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::Clear()
    IL_00aa:  nop
//000111: 				End If
    IL_00ab:  nop
//000112: 				_selectedPixels.Add(p)
    IL_00ac:  ldarg.0
    IL_00ad:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_00b2:  ldloc.0
    IL_00b3:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::Add(!0)
    IL_00b8:  nop
//000113: 
//000114: 				' With our updated list of selected pixels in hand, update
//000115:                 ' the toolstrip help text.
//000116: 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
    IL_00b9:  ldarg.0
    IL_00ba:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_lblHuesSelected()
    IL_00bf:  call       string My.Resources.Resources::get_HuesSelectedDisplay()
    IL_00c4:  ldarg.0
    IL_00c5:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_00ca:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::get_Count()
    IL_00cf:  box        [mscorlib]System.Int32
    IL_00d4:  call       string [mscorlib]System.String::Format(string,
                                                                object)
    IL_00d9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_00de:  nop
//000117: 
//000118:                 ' Start recomputing the image based on the new parameters.
//000119: 				StartColorizeImage()
    IL_00df:  ldarg.0
    IL_00e0:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::StartColorizeImage()
    IL_00e5:  nop
//000120: 			End If
    IL_00e6:  nop
//000121: 		End Sub
    IL_00e7:  nop
    IL_00e8:  ret
  } // end of method MainForm::pbImage_MouseClick

  .method private instance void  StartColorizeImage() cil managed
  {
    // Code size       247 (0xf7)
    .maxstack  3
    .locals init ([0] class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath path,
             [1] valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> VB$t_struct$L0,
             [2] bool VB$CG$t_bool$S0,
             [3] bool VB$CG$t_bool$S1,
             [4] bool VB$CG$t_bool$S2)
//000122: 
//000123: 		Private Sub StartColorizeImage()
    IL_0000:  nop
//000124: 			' Stop the timer if it's running, since the timer's purpose
//000125:             ' is to cause this method to be called when the timer expires.
//000126: 			tmRefresh.Stop()
    IL_0001:  ldarg.0
    IL_0002:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tmRefresh()
    IL_0007:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Timer::Stop()
    IL_000c:  nop
//000127: 			_lastEpsilon = tbEpsilon.Value
    IL_000d:  ldarg.0
    IL_000e:  ldarg.0
    IL_000f:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tbEpsilon()
    IL_0014:  callvirt   instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_Value()
    IL_0019:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastEpsilon
//000128: 
//000129: 			' If we have an image and if a pixel has been selected
//000130: 			' and if we're not currently recomputing the image...
//000131: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
    IL_001e:  ldarg.0
    IL_001f:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0024:  brfalse.s  IL_0041

    IL_0026:  ldarg.0
    IL_0027:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_002c:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::get_Count()
    IL_0031:  ldc.i4.0
    IL_0032:  ble.s      IL_0041

    IL_0034:  ldarg.0
    IL_0035:  callvirt   instance class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_bwColorize()
    IL_003a:  callvirt   instance bool [System]System.ComponentModel.BackgroundWorker::get_IsBusy()
    IL_003f:  brfalse.s  IL_0044

    IL_0041:  ldc.i4.0
    IL_0042:  br.s       IL_0045

    IL_0044:  ldc.i4.1
    IL_0045:  stloc.2
//000132:                 ' If there are any strokes, turn them into GraphicsPaths.
//000133: 				If PlatformDetection.SupportsInk Then
//000134: 					If _paths IsNot Nothing Then
//000135: 						For Each path As GraphicsPath In _paths
//000136: 							path.Dispose()
//000137: 						Next path
//000138: 					End If
//000139: 					_paths = InkToGraphicsPaths(True)
//000140: 				End If
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
//000144: 				pbImage.Enabled = False
//000145: 				pbColorizing.Value = 0
//000146: 				pbColorizing.Visible = True
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
//000150: 			End If
//000151: 		End Sub
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0046:  ldloc.2
    IL_0047:  brfalse    IL_00f4

//000133: 				If PlatformDetection.SupportsInk Then
    IL_004c:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_SupportsInk()
    IL_0051:  stloc.3
//000134: 					If _paths IsNot Nothing Then
//000135: 						For Each path As GraphicsPath In _paths
//000136: 							path.Dispose()
//000137: 						Next path
//000138: 					End If
//000139: 					_paths = InkToGraphicsPaths(True)
//000140: 				End If
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
//000144: 				pbImage.Enabled = False
//000145: 				pbColorizing.Value = 0
//000146: 				pbColorizing.Visible = True
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
//000150: 			End If
//000151: 		End Sub
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0052:  ldloc.3
    IL_0053:  brfalse.s  IL_00b3

//000134: 					If _paths IsNot Nothing Then
    IL_0055:  ldarg.0
    IL_0056:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_paths
    IL_005b:  ldnull
    IL_005c:  ceq
    IL_005e:  ldc.i4.0
    IL_005f:  ceq
    IL_0061:  stloc.s    VB$CG$t_bool$S2
//000135: 						For Each path As GraphicsPath In _paths
//000136: 							path.Dispose()
//000137: 						Next path
//000138: 					End If
//000139: 					_paths = InkToGraphicsPaths(True)
//000140: 				End If
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
//000144: 				pbImage.Enabled = False
//000145: 				pbColorizing.Value = 0
//000146: 				pbColorizing.Visible = True
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
//000150: 			End If
//000151: 		End Sub
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0063:  ldloc.s    VB$CG$t_bool$S2
    IL_0065:  brfalse.s  IL_00a5

    IL_0067:  nop
//000135: 						For Each path As GraphicsPath In _paths
    .try
    {
      IL_0068:  ldarg.0
      IL_0069:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_paths
      IL_006e:  callvirt   instance valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<!0> class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::GetEnumerator()
      IL_0073:  stloc.1
      IL_0074:  br.s       IL_0086

//000136: 							path.Dispose()
//000137: 						Next path
//000138: 					End If
//000139: 					_paths = InkToGraphicsPaths(True)
//000140: 				End If
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
//000144: 				pbImage.Enabled = False
//000145: 				pbColorizing.Value = 0
//000146: 				pbColorizing.Visible = True
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
//000150: 			End If
//000151: 		End Sub
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_0076:  ldloca.s   VB$t_struct$L0
      IL_0078:  call       instance !0 valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::get_Current()
      IL_007d:  stloc.0
//000136: 							path.Dispose()
      IL_007e:  ldloc.0
      IL_007f:  callvirt   instance void [System.Drawing]System.Drawing.Drawing2D.GraphicsPath::Dispose()
      IL_0084:  nop
//000137: 						Next path
      IL_0085:  nop
//000138: 					End If
//000139: 					_paths = InkToGraphicsPaths(True)
//000140: 				End If
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
//000144: 				pbImage.Enabled = False
//000145: 				pbColorizing.Value = 0
//000146: 				pbColorizing.Visible = True
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
//000150: 			End If
//000151: 		End Sub
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_0086:  ldloca.s   VB$t_struct$L0
      IL_0088:  call       instance bool valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::MoveNext()
      IL_008d:  stloc.s    VB$CG$t_bool$S2
      IL_008f:  ldloc.s    VB$CG$t_bool$S2
      IL_0091:  brtrue.s   IL_0076

      IL_0093:  nop
      IL_0094:  leave.s    IL_00a5

    }  // end .try
    finally
    {
      IL_0096:  ldloca.s   VB$t_struct$L0
      IL_0098:  constrained. valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>
      IL_009e:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_00a3:  nop
      IL_00a4:  endfinally
//000138: 					End If
    }  // end handler
    IL_00a5:  nop
//000139: 					_paths = InkToGraphicsPaths(True)
    IL_00a6:  ldarg.0
    IL_00a7:  ldarg.0
    IL_00a8:  ldc.i4.1
    IL_00a9:  callvirt   instance class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::InkToGraphicsPaths(bool)
    IL_00ae:  stfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_paths
//000140: 				End If
    IL_00b3:  nop
//000141: 
//000142:                 ' Modify the UI for progress.
//000143: 				toolStripMain.Enabled = False
    IL_00b4:  ldarg.0
    IL_00b5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_00ba:  ldc.i4.0
    IL_00bb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_00c0:  nop
//000144: 				pbImage.Enabled = False
    IL_00c1:  ldarg.0
    IL_00c2:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_00c7:  ldc.i4.0
    IL_00c8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_00cd:  nop
//000145: 				pbColorizing.Value = 0
    IL_00ce:  ldarg.0
    IL_00cf:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_00d4:  ldc.i4.0
    IL_00d5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar::set_Value(int32)
    IL_00da:  nop
//000146: 				pbColorizing.Visible = True
    IL_00db:  ldarg.0
    IL_00dc:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_00e1:  ldc.i4.1
    IL_00e2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Visible(bool)
    IL_00e7:  nop
//000147: 
//000148:                 ' Recompute the image!.
//000149: 				bwColorize.RunWorkerAsync()
    IL_00e8:  ldarg.0
    IL_00e9:  callvirt   instance class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_bwColorize()
    IL_00ee:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::RunWorkerAsync()
    IL_00f3:  nop
//000150: 			End If
    IL_00f4:  nop
//000151: 		End Sub
    IL_00f5:  nop
    IL_00f6:  ret
  } // end of method MainForm::StartColorizeImage

  .method private instance void  bwColorize_DoWork(object sender,
                                                   class [System]System.ComponentModel.DoWorkEventArgs e) cil managed
  {
    // Code size       147 (0x93)
    .maxstack  7
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation colorizer,
             [1] class [System.Drawing]System.Drawing.Bitmap workImage,
             [2] valuetype [System.Drawing]System.Drawing.Rectangle VB$t_struct$S0,
             [3] bool VB$CG$t_bool$S0)
//000152: 
//000153: 		''' <summary>Colorizes the image on a background thread.</summary>
//000154: 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
    IL_0000:  nop
//000155: 			' Create the colorizer instance.  Any progress updates
//000156: 			' will in turn update the progress through the BackgroundWorker.
//000157: 			Dim colorizer As New ImageManipulation()
    IL_0001:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::.ctor()
    IL_0006:  stloc.0
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
    IL_0007:  ldloc.0
    IL_0008:  ldarg.0
    IL_0009:  dup
    IL_000a:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_Lambda$__2(object,
                                                                                                                            class [System]System.ComponentModel.ProgressChangedEventArgs)
    IL_0010:  newobj     instance void [System]System.ComponentModel.ProgressChangedEventHandler::.ctor(object,
                                                                                                        native int)
    IL_0015:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::add_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler)
    IL_001a:  nop
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
    IL_001b:  nop
    IL_001c:  ldarg.0
    IL_001d:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0022:  ldloca.s   VB$t_struct$S0
    IL_0024:  ldc.i4.0
    IL_0025:  ldc.i4.0
    IL_0026:  ldarg.0
    IL_0027:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_002c:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0031:  ldarg.0
    IL_0032:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0037:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_003c:  call       instance void [System.Drawing]System.Drawing.Rectangle::.ctor(int32,
                                                                                       int32,
                                                                                       int32,
                                                                                       int32)
    IL_0041:  nop
    IL_0042:  ldloc.2
    IL_0043:  ldc.i4     0x21808
    IL_0048:  callvirt   instance class [System.Drawing]System.Drawing.Bitmap [System.Drawing]System.Drawing.Bitmap::Clone(valuetype [System.Drawing]System.Drawing.Rectangle,
                                                                                                                           valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
    IL_004d:  stloc.1
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_004e:  nop
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
    .try
    {
      IL_004f:  ldarg.2
      IL_0050:  ldloc.0
      IL_0051:  ldloc.1
      IL_0052:  ldarg.0
      IL_0053:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
      IL_0058:  ldarg.0
      IL_0059:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastEpsilon
      IL_005e:  ldarg.0
      IL_005f:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_paths
      IL_0064:  ldarg.0
      IL_0065:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnParallel()
      IL_006a:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.ToolStripButton::get_Checked()
      IL_006f:  callvirt   instance class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ImageManipulation::Colorize(class [System.Drawing]System.Drawing.Bitmap,
                                                                                                                                                                           class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>,
                                                                                                                                                                           int32,
                                                                                                                                                                           class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>,
                                                                                                                                                                           bool)
      IL_0074:  callvirt   instance void [System]System.ComponentModel.DoWorkEventArgs::set_Result(object)
      IL_0079:  nop
//000165:             End Using
      IL_007a:  nop
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_007b:  leave.s    IL_0091

    }  // end .try
    finally
    {
      IL_007d:  ldloc.1
      IL_007e:  ldnull
      IL_007f:  ceq
      IL_0081:  ldc.i4.0
      IL_0082:  ceq
      IL_0084:  stloc.3
      IL_0085:  ldloc.3
      IL_0086:  brfalse.s  IL_008f

      IL_0088:  ldloc.1
      IL_0089:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_008e:  nop
      IL_008f:  nop
      IL_0090:  endfinally
//000166: 		End Sub
    }  // end handler
    IL_0091:  nop
    IL_0092:  ret
  } // end of method MainForm::bwColorize_DoWork

  .method private instance void  bwColorize_RunWorkerCompleted(object sender,
                                                               class [System]System.ComponentModel.RunWorkerCompletedEventArgs e) cil managed
  {
    // Code size       231 (0xe7)
    .maxstack  2
    .locals init ([0] bool VB$CG$t_bool$S0)
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
    IL_0000:  nop
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_0007:  ldc.i4.0
    IL_0008:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Visible(bool)
    IL_000d:  nop
//000172: 			toolStripMain.Enabled = True
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStrip Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::toolStripMain
    IL_0014:  ldc.i4.1
    IL_0015:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_001a:  nop
//000173: 			pbImage.Enabled = True
    IL_001b:  ldarg.0
    IL_001c:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0021:  ldc.i4.1
    IL_0022:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0027:  nop
//000174: 			btnLoadImage.Enabled = True
    IL_0028:  ldarg.0
    IL_0029:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnLoadImage()
    IL_002e:  ldc.i4.1
    IL_002f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
    IL_0034:  nop
//000175: 			btnSaveImage.Enabled = True
    IL_0035:  ldarg.0
    IL_0036:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnSaveImage()
    IL_003b:  ldc.i4.1
    IL_003c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
    IL_0041:  nop
//000176: 			tbEpsilon.Focus()
    IL_0042:  ldarg.0
    IL_0043:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tbEpsilon()
    IL_0048:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost::Focus()
    IL_004d:  nop
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
    IL_004e:  ldarg.2
    IL_004f:  callvirt   instance class [mscorlib]System.Exception [System]System.ComponentModel.AsyncCompletedEventArgs::get_Error()
    IL_0054:  ldnull
    IL_0055:  ceq
    IL_0057:  ldc.i4.0
    IL_0058:  ceq
    IL_005a:  stloc.0
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_005b:  ldloc.0
    IL_005c:  brfalse.s  IL_006a

//000180: 				Throw New TargetInvocationException(e.Error)
    IL_005e:  ldarg.2
    IL_005f:  callvirt   instance class [mscorlib]System.Exception [System]System.ComponentModel.AsyncCompletedEventArgs::get_Error()
    IL_0064:  newobj     instance void [mscorlib]System.Reflection.TargetInvocationException::.ctor(class [mscorlib]System.Exception)
    IL_0069:  throw

//000181: 			End If
    IL_006a:  nop
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
    IL_006b:  ldarg.0
    IL_006c:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
    IL_0071:  ldnull
    IL_0072:  ceq
    IL_0074:  ldc.i4.0
    IL_0075:  ceq
    IL_0077:  stloc.0
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0078:  ldloc.0
    IL_0079:  brfalse.s  IL_0087

//000185: 				_colorizedImage.Dispose()
    IL_007b:  ldarg.0
    IL_007c:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
    IL_0081:  callvirt   instance void [System.Drawing]System.Drawing.Image::Dispose()
    IL_0086:  nop
//000186: 			End If
    IL_0087:  nop
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
    IL_0088:  ldarg.0
    IL_0089:  ldarg.2
    IL_008a:  callvirt   instance object [System]System.ComponentModel.RunWorkerCompletedEventArgs::get_Result()
    IL_008f:  castclass  [System.Drawing]System.Drawing.Bitmap
    IL_0094:  stfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
    IL_0099:  ldarg.0
    IL_009a:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_009f:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_00a4:  brfalse.s  IL_00b9

    IL_00a6:  ldarg.0
    IL_00a7:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_00ac:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_00b1:  ldarg.0
    IL_00b2:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_00b7:  bne.un.s   IL_00bc

    IL_00b9:  ldc.i4.0
    IL_00ba:  br.s       IL_00bd

    IL_00bc:  ldc.i4.1
    IL_00bd:  stloc.0
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_00be:  ldloc.0
    IL_00bf:  brfalse.s  IL_00d2

//000191: 				pbImage.Image.Dispose()
    IL_00c1:  ldarg.0
    IL_00c2:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_00c7:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_00cc:  callvirt   instance void [System.Drawing]System.Drawing.Image::Dispose()
    IL_00d1:  nop
//000192: 			End If
    IL_00d2:  nop
//000193: 			pbImage.Image = _colorizedImage
    IL_00d3:  ldarg.0
    IL_00d4:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_00d9:  ldarg.0
    IL_00da:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
    IL_00df:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_00e4:  nop
//000194: 		End Sub
    IL_00e5:  nop
    IL_00e6:  ret
  } // end of method MainForm::bwColorize_RunWorkerCompleted

  .method private instance void  bwColorize_ProgressChanged(object sender,
                                                            class [System]System.ComponentModel.ProgressChangedEventArgs e) cil managed
  {
    // Code size       45 (0x2d)
    .maxstack  2
    .locals init ([0] bool VB$CG$t_bool$S0)
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
    IL_0000:  nop
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
    IL_0001:  ldarg.2
    IL_0002:  callvirt   instance int32 [System]System.ComponentModel.ProgressChangedEventArgs::get_ProgressPercentage()
    IL_0007:  ldarg.0
    IL_0008:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_000d:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar::get_Value()
    IL_0012:  cgt
    IL_0014:  stloc.0
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0015:  ldloc.0
    IL_0016:  brfalse.s  IL_002a

//000199: 				pbColorizing.Value = e.ProgressPercentage
    IL_0018:  ldarg.0
    IL_0019:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbColorizing
    IL_001e:  ldarg.2
    IL_001f:  callvirt   instance int32 [System]System.ComponentModel.ProgressChangedEventArgs::get_ProgressPercentage()
    IL_0024:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripProgressBar::set_Value(int32)
    IL_0029:  nop
//000200: 			End If
    IL_002a:  nop
//000201: 		End Sub
    IL_002b:  nop
    IL_002c:  ret
  } // end of method MainForm::bwColorize_ProgressChanged

  .method private instance void  btnSaveImage_Click(object sender,
                                                    class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       86 (0x56)
    .maxstack  3
    .locals init ([0] class [System.Windows.Forms]System.Windows.Forms.SaveFileDialog sfd,
             [1] bool VB$CG$t_bool$S0)
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
    IL_0000:  nop
//000205: 			If _colorizedImage IsNot Nothing Then
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
    IL_0007:  ldnull
    IL_0008:  ceq
    IL_000a:  ldc.i4.0
    IL_000b:  ceq
    IL_000d:  stloc.1
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_000e:  ldloc.1
    IL_000f:  brfalse.s  IL_0053

//000206: 				Dim sfd As New SaveFileDialog()
    IL_0011:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.SaveFileDialog::.ctor()
    IL_0016:  stloc.0
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
    IL_0017:  ldloc.0
    IL_0018:  ldstr      "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.b"
    + "mp;*.png;*.gif|All files (*.*)|*.*"
    IL_001d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.FileDialog::set_Filter(string)
    IL_0022:  nop
//000208: 				sfd.DefaultExt = ".jpg"
    IL_0023:  ldloc.0
    IL_0024:  ldstr      ".jpg"
    IL_0029:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.FileDialog::set_DefaultExt(string)
    IL_002e:  nop
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
    IL_002f:  ldloc.0
    IL_0030:  ldarg.0
    IL_0031:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.DialogResult [System.Windows.Forms]System.Windows.Forms.CommonDialog::ShowDialog(class [System.Windows.Forms]System.Windows.Forms.IWin32Window)
    IL_0036:  ldc.i4.1
    IL_0037:  ceq
    IL_0039:  stloc.1
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_003a:  ldloc.1
    IL_003b:  brfalse.s  IL_0052

//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
    IL_003d:  ldarg.0
    IL_003e:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
    IL_0043:  ldloc.0
    IL_0044:  callvirt   instance string [System.Windows.Forms]System.Windows.Forms.FileDialog::get_FileName()
    IL_0049:  ldc.i4.s   100
    IL_004b:  conv.i8
    IL_004c:  call       void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::SaveImage(class [System.Drawing]System.Drawing.Bitmap,
                                                                                                                 string,
                                                                                                                 int64)
    IL_0051:  nop
//000211: 				End If
    IL_0052:  nop
//000212: 			End If
    IL_0053:  nop
//000213: 		End Sub
    IL_0054:  nop
    IL_0055:  ret
  } // end of method MainForm::btnSaveImage_Click

  .method private static void  SaveImage(class [System.Drawing]System.Drawing.Bitmap bmp,
                                         string path,
                                         int64 quality) cil managed
  {
    // Code size       426 (0x1aa)
    .maxstack  4
    .locals init ([0] class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo jpegCodec,
             [1] class [System.Drawing]System.Drawing.Imaging.EncoderParameters codecParams,
             [2] class [System.Drawing]System.Drawing.Imaging.EncoderParameter ratio,
             [3] string VB$t_string$L0,
             [4] bool VB$CG$t_bool$S0)
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
    IL_0000:  nop
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
    IL_0001:  ldarg.0
    IL_0002:  ldnull
    IL_0003:  ceq
    IL_0005:  stloc.s    VB$CG$t_bool$S0
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0007:  ldloc.s    VB$CG$t_bool$S0
    IL_0009:  brfalse.s  IL_0016

//000222: 				Throw New ArgumentNullException("bmp")
    IL_000b:  ldstr      "bmp"
    IL_0010:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_0015:  throw

//000223: 			End If
    IL_0016:  nop
//000224: 			If path Is Nothing Then
    IL_0017:  ldarg.1
    IL_0018:  ldnull
    IL_0019:  ceq
    IL_001b:  stloc.s    VB$CG$t_bool$S0
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_001d:  ldloc.s    VB$CG$t_bool$S0
    IL_001f:  brfalse.s  IL_002c

//000225: 				Throw New ArgumentNullException("path")
    IL_0021:  ldstr      "path"
    IL_0026:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_002b:  throw

//000226: 			End If
    IL_002c:  nop
//000227: 			If quality < 1 OrElse quality > 100 Then
    IL_002d:  ldarg.2
    IL_002e:  ldc.i4.1
    IL_002f:  conv.i8
    IL_0030:  blt.s      IL_003b

    IL_0032:  ldarg.2
    IL_0033:  ldc.i4.s   100
    IL_0035:  conv.i8
    IL_0036:  bgt.s      IL_003b

    IL_0038:  ldc.i4.0
    IL_0039:  br.s       IL_003c

    IL_003b:  ldc.i4.1
    IL_003c:  stloc.s    VB$CG$t_bool$S0
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_003e:  ldloc.s    VB$CG$t_bool$S0
    IL_0040:  brfalse.s  IL_0058

//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
    IL_0042:  ldstr      "quality"
    IL_0047:  ldarg.2
    IL_0048:  box        [mscorlib]System.Int64
    IL_004d:  ldstr      "Quality out of range."
    IL_0052:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string,
                                                                                           object,
                                                                                           string)
    IL_0057:  throw

//000229: 			End If
    IL_0058:  nop
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
    IL_0059:  nop
    IL_005a:  ldarg.1
    IL_005b:  call       string [mscorlib]System.IO.Path::GetExtension(string)
    IL_0060:  callvirt   instance string [mscorlib]System.String::ToLowerInvariant()
    IL_0065:  stloc.3
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0066:  nop
    IL_0067:  ldloc.3
    IL_0068:  ldstr      ".bmp"
    IL_006d:  ldc.i4.0
    IL_006e:  call       int32 [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.Operators::CompareString(string,
                                                                                                                      string,
                                                                                                                      bool)
    IL_0073:  ldc.i4.0
    IL_0074:  ceq
    IL_0076:  stloc.s    VB$CG$t_bool$S0
    IL_0078:  ldloc.s    VB$CG$t_bool$S0
    IL_007a:  brfalse.s  IL_008f

//000234:                 Case ".bmp"
    IL_007c:  nop
//000235:                     bmp.Save(path, ImageFormat.Bmp)
    IL_007d:  ldarg.0
    IL_007e:  ldarg.1
    IL_007f:  call       class [System.Drawing]System.Drawing.Imaging.ImageFormat [System.Drawing]System.Drawing.Imaging.ImageFormat::get_Bmp()
    IL_0084:  callvirt   instance void [System.Drawing]System.Drawing.Image::Save(string,
                                                                                  class [System.Drawing]System.Drawing.Imaging.ImageFormat)
    IL_0089:  nop
    IL_008a:  br         IL_01a7

//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_008f:  nop
    IL_0090:  ldloc.3
    IL_0091:  ldstr      ".png"
    IL_0096:  ldc.i4.0
    IL_0097:  call       int32 [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.Operators::CompareString(string,
                                                                                                                      string,
                                                                                                                      bool)
    IL_009c:  ldc.i4.0
    IL_009d:  ceq
    IL_009f:  stloc.s    VB$CG$t_bool$S0
    IL_00a1:  ldloc.s    VB$CG$t_bool$S0
    IL_00a3:  brfalse.s  IL_00b8

//000236:                 Case ".png"
    IL_00a5:  nop
//000237:                     bmp.Save(path, ImageFormat.Png)
    IL_00a6:  ldarg.0
    IL_00a7:  ldarg.1
    IL_00a8:  call       class [System.Drawing]System.Drawing.Imaging.ImageFormat [System.Drawing]System.Drawing.Imaging.ImageFormat::get_Png()
    IL_00ad:  callvirt   instance void [System.Drawing]System.Drawing.Image::Save(string,
                                                                                  class [System.Drawing]System.Drawing.Imaging.ImageFormat)
    IL_00b2:  nop
    IL_00b3:  br         IL_01a7

//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_00b8:  nop
    IL_00b9:  ldloc.3
    IL_00ba:  ldstr      ".gif"
    IL_00bf:  ldc.i4.0
    IL_00c0:  call       int32 [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.Operators::CompareString(string,
                                                                                                                      string,
                                                                                                                      bool)
    IL_00c5:  ldc.i4.0
    IL_00c6:  ceq
    IL_00c8:  stloc.s    VB$CG$t_bool$S0
    IL_00ca:  ldloc.s    VB$CG$t_bool$S0
    IL_00cc:  brfalse.s  IL_00e1

//000238:                 Case ".gif"
    IL_00ce:  nop
//000239:                     bmp.Save(path, ImageFormat.Gif)
    IL_00cf:  ldarg.0
    IL_00d0:  ldarg.1
    IL_00d1:  call       class [System.Drawing]System.Drawing.Imaging.ImageFormat [System.Drawing]System.Drawing.Imaging.ImageFormat::get_Gif()
    IL_00d6:  callvirt   instance void [System.Drawing]System.Drawing.Image::Save(string,
                                                                                  class [System.Drawing]System.Drawing.Imaging.ImageFormat)
    IL_00db:  nop
    IL_00dc:  br         IL_01a7

//000240:                 Case ".tif", ".tiff"
    IL_00e1:  nop
    IL_00e2:  ldloc.3
    IL_00e3:  ldstr      ".tif"
    IL_00e8:  ldc.i4.0
    IL_00e9:  call       int32 [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.Operators::CompareString(string,
                                                                                                                      string,
                                                                                                                      bool)
    IL_00ee:  ldc.i4.0
    IL_00ef:  beq.s      IL_0103

    IL_00f1:  ldloc.3
    IL_00f2:  ldstr      ".tiff"
    IL_00f7:  ldc.i4.0
    IL_00f8:  call       int32 [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.Operators::CompareString(string,
                                                                                                                      string,
                                                                                                                      bool)
    IL_00fd:  ldc.i4.0
    IL_00fe:  beq.s      IL_0103

    IL_0100:  ldc.i4.0
    IL_0101:  br.s       IL_0104

    IL_0103:  ldc.i4.1
    IL_0104:  stloc.s    VB$CG$t_bool$S0
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0106:  ldloc.s    VB$CG$t_bool$S0
    IL_0108:  brfalse.s  IL_011c

//000241:                     bmp.Save(path, ImageFormat.Tiff)
    IL_010a:  ldarg.0
    IL_010b:  ldarg.1
    IL_010c:  call       class [System.Drawing]System.Drawing.Imaging.ImageFormat [System.Drawing]System.Drawing.Imaging.ImageFormat::get_Tiff()
    IL_0111:  callvirt   instance void [System.Drawing]System.Drawing.Image::Save(string,
                                                                                  class [System.Drawing]System.Drawing.Imaging.ImageFormat)
    IL_0116:  nop
    IL_0117:  br         IL_01a7

//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_011c:  nop
    IL_011d:  ldloc.3
    IL_011e:  ldstr      ".jpg"
    IL_0123:  ldc.i4.0
    IL_0124:  call       int32 [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.Operators::CompareString(string,
                                                                                                                      string,
                                                                                                                      bool)
    IL_0129:  ldc.i4.0
    IL_012a:  ceq
    IL_012c:  stloc.s    VB$CG$t_bool$S0
    IL_012e:  ldloc.s    VB$CG$t_bool$S0
    IL_0130:  brfalse.s  IL_01a7

//000242:                 Case ".jpg"
    IL_0132:  nop
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
    IL_0133:  call       class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo[] [System.Drawing]System.Drawing.Imaging.ImageCodecInfo::GetImageEncoders()
    IL_0138:  ldnull
    IL_0139:  ldftn      bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_Lambda$__3(class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo)
    IL_013f:  newobj     instance void class [mscorlib]System.Predicate`1<class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo>::.ctor(object,
                                                                                                                                              native int)
    IL_0144:  call       !!0 [mscorlib]System.Array::Find<class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo>(!!0[],
                                                                                                                       class [mscorlib]System.Predicate`1<!!0>)
    IL_0149:  stloc.0
//000245:                     Using codecParams As New EncoderParameters(1)
    IL_014a:  nop
    IL_014b:  ldc.i4.1
    IL_014c:  newobj     instance void [System.Drawing]System.Drawing.Imaging.EncoderParameters::.ctor(int32)
    IL_0151:  stloc.1
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0152:  nop
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
    .try
    {
      IL_0153:  nop
      IL_0154:  ldsfld     class [System.Drawing]System.Drawing.Imaging.Encoder [System.Drawing]System.Drawing.Imaging.Encoder::Quality
      IL_0159:  ldarg.2
      IL_015a:  newobj     instance void [System.Drawing]System.Drawing.Imaging.EncoderParameter::.ctor(class [System.Drawing]System.Drawing.Imaging.Encoder,
                                                                                                        int64)
      IL_015f:  stloc.2
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_0160:  nop
//000248:                             codecParams.Param(0) = ratio
      .try
      {
        IL_0161:  ldloc.1
        IL_0162:  callvirt   instance class [System.Drawing]System.Drawing.Imaging.EncoderParameter[] [System.Drawing]System.Drawing.Imaging.EncoderParameters::get_Param()
        IL_0167:  ldc.i4.0
        IL_0168:  ldloc.2
        IL_0169:  stelem.ref
        IL_016a:  nop
//000249:                             bmp.Save(path, jpegCodec, codecParams)
        IL_016b:  ldarg.0
        IL_016c:  ldarg.1
        IL_016d:  ldloc.0
        IL_016e:  ldloc.1
        IL_016f:  callvirt   instance void [System.Drawing]System.Drawing.Image::Save(string,
                                                                                      class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo,
                                                                                      class [System.Drawing]System.Drawing.Imaging.EncoderParameters)
        IL_0174:  nop
//000250:                         End Using
        IL_0175:  nop
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
        IL_0176:  leave.s    IL_018e

      }  // end .try
      finally
      {
        IL_0178:  ldloc.2
        IL_0179:  ldnull
        IL_017a:  ceq
        IL_017c:  ldc.i4.0
        IL_017d:  ceq
        IL_017f:  stloc.s    VB$CG$t_bool$S0
        IL_0181:  ldloc.s    VB$CG$t_bool$S0
        IL_0183:  brfalse.s  IL_018c

        IL_0185:  ldloc.2
        IL_0186:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_018b:  nop
        IL_018c:  nop
        IL_018d:  endfinally
//000251:                     End Using
      }  // end handler
      IL_018e:  nop
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_018f:  leave.s    IL_01a7

    }  // end .try
    finally
    {
      IL_0191:  ldloc.1
      IL_0192:  ldnull
      IL_0193:  ceq
      IL_0195:  ldc.i4.0
      IL_0196:  ceq
      IL_0198:  stloc.s    VB$CG$t_bool$S0
      IL_019a:  ldloc.s    VB$CG$t_bool$S0
      IL_019c:  brfalse.s  IL_01a5

      IL_019e:  ldloc.1
      IL_019f:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_01a4:  nop
      IL_01a5:  nop
      IL_01a6:  endfinally
//000252:             End Select
    }  // end handler
    IL_01a7:  nop
//000253: 		End Sub
    IL_01a8:  nop
    IL_01a9:  ret
  } // end of method MainForm::SaveImage

  .method private instance void  tmRefresh_Tick(object sender,
                                                class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
    IL_0000:  nop
//000257: 			StartColorizeImage()
    IL_0001:  ldarg.0
    IL_0002:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::StartColorizeImage()
    IL_0007:  nop
//000258: 		End Sub
    IL_0008:  nop
    IL_0009:  ret
  } // end of method MainForm::tmRefresh_Tick

  .method private instance void  tbEpsilon_ValueChanged(object sender,
                                                        class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       48 (0x30)
    .maxstack  8
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
    IL_0000:  nop
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
    IL_0001:  ldarg.0
    IL_0002:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tbEpsilon()
    IL_0007:  call       string My.Resources.Resources::get_EpsilonDisplay()
    IL_000c:  ldarg.0
    IL_000d:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tbEpsilon()
    IL_0012:  callvirt   instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_Value()
    IL_0017:  box        [mscorlib]System.Int32
    IL_001c:  call       string [mscorlib]System.String::Format(string,
                                                                object)
    IL_0021:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ToolTipText(string)
    IL_0026:  nop
//000263: 			StartRefreshTimer()
    IL_0027:  ldarg.0
    IL_0028:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::StartRefreshTimer()
    IL_002d:  nop
//000264: 		End Sub
    IL_002e:  nop
    IL_002f:  ret
  } // end of method MainForm::tbEpsilon_ValueChanged

  .method private instance void  StartRefreshTimer() cil managed
  {
    // Code size       93 (0x5d)
    .maxstack  2
    .locals init ([0] bool VB$CG$t_bool$S0)
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
    IL_0000:  nop
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0007:  brfalse.s  IL_002d

    IL_0009:  ldarg.0
    IL_000a:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_000f:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::get_Count()
    IL_0014:  ldc.i4.0
    IL_0015:  ble.s      IL_002d

    IL_0017:  ldarg.0
    IL_0018:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastEpsilon
    IL_001d:  ldc.i4.0
    IL_001e:  blt.s      IL_002d

    IL_0020:  ldarg.0
    IL_0021:  callvirt   instance class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_bwColorize()
    IL_0026:  callvirt   instance bool [System]System.ComponentModel.BackgroundWorker::get_IsBusy()
    IL_002b:  brfalse.s  IL_0030

    IL_002d:  ldc.i4.0
    IL_002e:  br.s       IL_0031

    IL_0030:  ldc.i4.1
    IL_0031:  stloc.0
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0032:  ldloc.0
    IL_0033:  brfalse.s  IL_005a

//000269: 				btnLoadImage.Enabled = False
    IL_0035:  ldarg.0
    IL_0036:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnLoadImage()
    IL_003b:  ldc.i4.0
    IL_003c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
    IL_0041:  nop
//000270: 				tmRefresh.Stop()
    IL_0042:  ldarg.0
    IL_0043:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tmRefresh()
    IL_0048:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Timer::Stop()
    IL_004d:  nop
//000271: 				tmRefresh.Start()
    IL_004e:  ldarg.0
    IL_004f:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tmRefresh()
    IL_0054:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Timer::Start()
    IL_0059:  nop
//000272: 			End If
    IL_005a:  nop
//000273: 		End Sub
    IL_005b:  nop
    IL_005c:  ret
  } // end of method MainForm::StartRefreshTimer

  .method private instance void  pbImage_Resize(object sender,
                                                class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       71 (0x47)
    .maxstack  2
    .locals init ([0] bool VB$CG$t_bool$S0)
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
    IL_0000:  nop
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
    IL_0001:  ldarg.0
    IL_0002:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
    IL_0007:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_000c:  ldc.i4.0
    IL_000d:  ble.s      IL_0024

    IL_000f:  ldarg.0
    IL_0010:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
    IL_0015:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_001a:  ldc.i4.0
    IL_001b:  ble.s      IL_0024

    IL_001d:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_SupportsInk()
    IL_0022:  brtrue.s   IL_0027

    IL_0024:  ldc.i4.0
    IL_0025:  br.s       IL_0028

    IL_0027:  ldc.i4.1
    IL_0028:  stloc.0
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
//000304: 		End Sub
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
//000309: 			_overlay.Ink.DeleteStrokes()
//000310: 		End Sub
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0029:  ldloc.0
    IL_002a:  brfalse.s  IL_0033

//000278: 				ScaleInk()
    IL_002c:  ldarg.0
    IL_002d:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::ScaleInk()
    IL_0032:  nop
//000279: 			End If
    IL_0033:  nop
//000280: 			_lastPictureBoxSize = pbImage.Size
    IL_0034:  ldarg.0
    IL_0035:  ldarg.0
    IL_0036:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_003b:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Control::get_Size()
    IL_0040:  stfld      valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
//000281: 		End Sub
    IL_0045:  nop
    IL_0046:  ret
  } // end of method MainForm::pbImage_Resize

  .method private instance void  InitializeInk() cil managed noinlining
  {
    // Code size       133 (0x85)
    .maxstack  3
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Color VB$t_struct$N0)
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
    IL_0000:  nop
//000286: 			_overlay = New InkOverlay(pbImage, True)
    IL_0001:  ldarg.0
    IL_0002:  ldarg.0
    IL_0003:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0008:  ldc.i4.1
    IL_0009:  newobj     instance void [Microsoft.Ink]Microsoft.Ink.InkOverlay::.ctor(class [System.Windows.Forms_7]System.Windows.Forms.Control,
                                                                                      bool)
    IL_000e:  stfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
    IL_0013:  ldarg.0
    IL_0014:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0019:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.DrawingAttributes [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_DefaultDrawingAttributes()
    IL_001e:  ldc.r4     1.
    IL_0023:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.DrawingAttributes::set_Width(float32)
    IL_0028:  nop
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
    IL_0029:  ldarg.0
    IL_002a:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_002f:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.DrawingAttributes [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_DefaultDrawingAttributes()
    IL_0034:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Red()
    IL_0039:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.DrawingAttributes::set_Color(valuetype [System.Drawing_8]System.Drawing.Color)
    IL_003e:  nop
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
    IL_003f:  ldarg.0
    IL_0040:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0045:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.DrawingAttributes [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_DefaultDrawingAttributes()
    IL_004a:  ldc.i4.1
    IL_004b:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.DrawingAttributes::set_IgnorePressure(bool)
    IL_0050:  nop
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
    IL_0051:  ldarg.0
    IL_0052:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0057:  ldarg.0
    IL_0058:  dup
    IL_0059:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_Lambda$__4(object,
                                                                                                                            class [Microsoft.Ink]Microsoft.Ink.InkCollectorStrokeEventArgs)
    IL_005f:  newobj     instance void [Microsoft.Ink]Microsoft.Ink.InkCollectorStrokeEventHandler::.ctor(object,
                                                                                                          native int)
    IL_0064:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.InkOverlay::add_Stroke(class [Microsoft.Ink]Microsoft.Ink.InkCollectorStrokeEventHandler)
    IL_0069:  nop
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
    IL_006a:  ldarg.0
    IL_006b:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0070:  ldarg.0
    IL_0071:  dup
    IL_0072:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_Lambda$__6(object,
                                                                                                                            class [Microsoft.Ink]Microsoft.Ink.InkCollectorNewPacketsEventArgs)
    IL_0078:  newobj     instance void [Microsoft.Ink]Microsoft.Ink.InkCollectorNewPacketsEventHandler::.ctor(object,
                                                                                                              native int)
    IL_007d:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.InkOverlay::add_NewPackets(class [Microsoft.Ink]Microsoft.Ink.InkCollectorNewPacketsEventHandler)
    IL_0082:  nop
//000304: 		End Sub
    IL_0083:  nop
    IL_0084:  ret
  } // end of method MainForm::InitializeInk

  .method private instance void  ClearInk() cil managed noinlining
  {
    // Code size       20 (0x14)
    .maxstack  8
//000305: 
//000306: 		''' <summary>Clears all ink from the overlay.</summary>
//000307: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000308: 		Private Sub ClearInk()
    IL_0000:  nop
//000309: 			_overlay.Ink.DeleteStrokes()
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0007:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Ink [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_Ink()
    IL_000c:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.Ink::DeleteStrokes()
    IL_0011:  nop
//000310: 		End Sub
    IL_0012:  nop
    IL_0013:  ret
  } // end of method MainForm::ClearInk

  .method private instance void  ScaleInk() cil managed noinlining
  {
    // Code size       182 (0xb6)
    .maxstack  4
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Size VB$t_struct$S0,
             [1] valuetype [System.Drawing]System.Drawing.Size VB$t_struct$S1,
             [2] valuetype [System.Drawing]System.Drawing.Size VB$t_struct$S2,
             [3] valuetype [System.Drawing]System.Drawing.Size VB$t_struct$S3,
             [4] bool VB$CG$t_bool$S0)
//000311: 
//000312: 		''' <summary>Scales the ink in the overlay.</summary>
//000313: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000314: 		Private Sub ScaleInk()
    IL_0000:  nop
//000315: 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
    IL_0001:  ldarg.0
    IL_0002:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0007:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Control::get_Size()
    IL_000c:  stloc.0
    IL_000d:  ldloca.s   VB$t_struct$S0
    IL_000f:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_0014:  ldc.i4.0
    IL_0015:  ble.s      IL_0051

    IL_0017:  ldarg.0
    IL_0018:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_001d:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Control::get_Size()
    IL_0022:  stloc.1
    IL_0023:  ldloca.s   VB$t_struct$S1
    IL_0025:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_002a:  ldc.i4.0
    IL_002b:  ble.s      IL_0051

    IL_002d:  ldarg.0
    IL_002e:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
    IL_0033:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_0038:  ldc.i4.0
    IL_0039:  ble.s      IL_0051

    IL_003b:  ldarg.0
    IL_003c:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
    IL_0041:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_0046:  ldc.i4.0
    IL_0047:  ble.s      IL_0051

    IL_0049:  ldarg.0
    IL_004a:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_004f:  brtrue.s   IL_0054

    IL_0051:  ldc.i4.0
    IL_0052:  br.s       IL_0055

    IL_0054:  ldc.i4.1
    IL_0055:  stloc.s    VB$CG$t_bool$S0
//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
//000317: 			End If
//000318: 		End Sub
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
//000325:             Dim renderer = _overlay.Renderer
//000326:             Dim strokes = _overlay.Ink.Strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
//000330: 
//000331: 			If strokes.Count > 0 Then
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0057:  ldloc.s    VB$CG$t_bool$S0
    IL_0059:  brfalse.s  IL_00b3

//000316:                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
    IL_005b:  ldarg.0
    IL_005c:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0061:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Ink [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_Ink()
    IL_0066:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Strokes [Microsoft.Ink]Microsoft.Ink.Ink::get_Strokes()
    IL_006b:  ldarg.0
    IL_006c:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0071:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Control::get_Size()
    IL_0076:  stloc.2
    IL_0077:  ldloca.s   VB$t_struct$S2
    IL_0079:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_007e:  conv.r4
    IL_007f:  ldarg.0
    IL_0080:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
    IL_0085:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_008a:  conv.r4
    IL_008b:  div
    IL_008c:  ldarg.0
    IL_008d:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0092:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Windows.Forms]System.Windows.Forms.Control::get_Size()
    IL_0097:  stloc.3
    IL_0098:  ldloca.s   VB$t_struct$S3
    IL_009a:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_009f:  conv.r4
    IL_00a0:  ldarg.0
    IL_00a1:  ldflda     valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_lastPictureBoxSize
    IL_00a6:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_00ab:  conv.r4
    IL_00ac:  div
    IL_00ad:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.Strokes::Scale(float32,
                                                                                   float32)
    IL_00b2:  nop
//000317: 			End If
    IL_00b3:  nop
//000318: 		End Sub
    IL_00b4:  nop
    IL_00b5:  ret
  } // end of method MainForm::ScaleInk

  .method private instance class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> 
          InkToGraphicsPaths(bool scalePath) cil managed noinlining
  {
    // Code size       398 (0x18e)
    .maxstack  5
    .locals init ([0] class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> InkToGraphicsPaths,
             [1] class [Microsoft.Ink]Microsoft.Ink.Renderer renderer,
             [2] float32 scaleX,
             [3] float32 scaleY,
             [4] class [Microsoft.Ink]Microsoft.Ink.Strokes strokes,
             [5] class [System.Drawing]System.Drawing.Graphics g,
             [6] class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath> paths,
             [7] valuetype [System.Drawing]System.Drawing.Point[] points,
             [8] class [Microsoft.Ink]Microsoft.Ink.Stroke stroke,
             [9] class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath path,
             [10] int32 i,
             [11] class [Microsoft.Ink]Microsoft.Ink.Strokes/StrokesEnumerator VB$t_ref$L0,
             [12] int32 VB$t_i4$L0,
             [13] bool VB$CG$t_bool$S0,
             [14] int32 VB$CG$t_i4$S0)
//000319: 
//000320: 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
//000321: 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
//000322: 		''' <returns>The list of converted GraphicsPath instances.</returns>
//000323: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000324: 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
    IL_0000:  nop
//000325:             Dim renderer = _overlay.Renderer
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0007:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Renderer [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_Renderer()
    IL_000c:  stloc.1
//000326:             Dim strokes = _overlay.Ink.Strokes
    IL_000d:  ldarg.0
    IL_000e:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0013:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Ink [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_Ink()
    IL_0018:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Strokes [Microsoft.Ink]Microsoft.Ink.Ink::get_Strokes()
    IL_001d:  stloc.s    strokes
//000327: 
//000328:             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
    IL_001f:  ldarg.0
    IL_0020:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0025:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_002a:  conv.r4
    IL_002b:  ldarg.0
    IL_002c:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0031:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
    IL_0036:  conv.r4
    IL_0037:  div
    IL_0038:  stloc.2
//000329:             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
    IL_0039:  ldarg.0
    IL_003a:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_003f:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_0044:  conv.r4
    IL_0045:  ldarg.0
    IL_0046:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_004b:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
    IL_0050:  conv.r4
    IL_0051:  div
    IL_0052:  stloc.3
//000330: 
//000331: 			If strokes.Count > 0 Then
    IL_0053:  ldloc.s    strokes
    IL_0055:  callvirt   instance int32 [Microsoft.Ink]Microsoft.Ink.Strokes::get_Count()
    IL_005a:  ldc.i4.0
    IL_005b:  cgt
    IL_005d:  stloc.s    VB$CG$t_bool$S0
//000332:                 Using g = CreateGraphics()
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_005f:  ldloc.s    VB$CG$t_bool$S0
    IL_0061:  brfalse    IL_0187

//000332:                 Using g = CreateGraphics()
    IL_0066:  nop
    IL_0067:  ldarg.0
    IL_0068:  callvirt   instance class [System.Drawing]System.Drawing.Graphics [System.Windows.Forms]System.Windows.Forms.Control::CreateGraphics()
    IL_006d:  stloc.s    g
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
//000334:                     For Each stroke As Stroke In strokes
//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_006f:  nop
//000333:                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
    .try
    {
      IL_0070:  ldloc.s    strokes
      IL_0072:  callvirt   instance int32 [Microsoft.Ink]Microsoft.Ink.Strokes::get_Count()
      IL_0077:  newobj     instance void class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::.ctor(int32)
      IL_007c:  stloc.s    paths
//000334:                     For Each stroke As Stroke In strokes
      IL_007e:  ldloc.s    strokes
      IL_0080:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Strokes/StrokesEnumerator [Microsoft.Ink]Microsoft.Ink.Strokes::GetEnumerator()
      IL_0085:  stloc.s    VB$t_ref$L0
      IL_0087:  br         IL_0157

//000335:                         Dim points() = stroke.GetPoints()
//000336:                         If points.Length >= 3 Then
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_008c:  ldloc.s    VB$t_ref$L0
      IL_008e:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Stroke [Microsoft.Ink]Microsoft.Ink.Strokes/StrokesEnumerator::get_Current()
      IL_0093:  stloc.s    stroke
//000335:                         Dim points() = stroke.GetPoints()
      IL_0095:  ldloc.s    stroke
      IL_0097:  callvirt   instance valuetype [System.Drawing_8]System.Drawing.Point[] [Microsoft.Ink]Microsoft.Ink.Stroke::GetPoints()
      IL_009c:  stloc.s    points
//000336:                         If points.Length >= 3 Then
      IL_009e:  ldloc.s    points
      IL_00a0:  ldlen
      IL_00a1:  conv.ovf.i4
      IL_00a2:  ldc.i4.3
      IL_00a3:  clt
      IL_00a5:  ldc.i4.0
      IL_00a6:  ceq
      IL_00a8:  stloc.s    VB$CG$t_bool$S0
//000337:                             For i = 0 To points.Length - 1
//000338:                                 renderer.InkSpaceToPixel(g, points(i))
//000339:                                 If scalePath Then
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_00aa:  ldloc.s    VB$CG$t_bool$S0
      IL_00ac:  brfalse    IL_0155

//000337:                             For i = 0 To points.Length - 1
      IL_00b1:  ldc.i4.0
      IL_00b2:  ldloc.s    points
      IL_00b4:  ldlen
      IL_00b5:  conv.ovf.i4
      IL_00b6:  ldc.i4.1
      IL_00b7:  sub.ovf
      IL_00b8:  stloc.s    VB$t_i4$L0
      IL_00ba:  stloc.s    i
      IL_00bc:  br.s       IL_0128

//000338:                                 renderer.InkSpaceToPixel(g, points(i))
      IL_00be:  ldloc.1
      IL_00bf:  ldloc.s    g
      IL_00c1:  ldloc.s    points
      IL_00c3:  ldloc.s    i
      IL_00c5:  ldelema    [System.Drawing]System.Drawing.Point
      IL_00ca:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.Renderer::InkSpaceToPixel(class [System.Drawing_8]System.Drawing.Graphics,
                                                                                                valuetype [System.Drawing_8]System.Drawing.Point&)
      IL_00cf:  nop
//000339:                                 If scalePath Then
      IL_00d0:  ldarg.1
      IL_00d1:  stloc.s    VB$CG$t_bool$S0
//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
//000341:                                 End If
//000342:                             Next i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_00d3:  ldloc.s    VB$CG$t_bool$S0
      IL_00d5:  brfalse.s  IL_0120

//000340:                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
      IL_00d7:  ldloc.s    points
      IL_00d9:  ldloc.s    i
      IL_00db:  ldelema    [System.Drawing]System.Drawing.Point
      IL_00e0:  ldloc.2
      IL_00e1:  ldloc.s    points
      IL_00e3:  ldloc.s    i
      IL_00e5:  ldelema    [System.Drawing]System.Drawing.Point
      IL_00ea:  call       instance int32 [System.Drawing]System.Drawing.Point::get_X()
      IL_00ef:  conv.r4
      IL_00f0:  mul
      IL_00f1:  call       float32 [Microsoft.VisualBasic]Microsoft.VisualBasic.Conversion::Fix(float32)
      IL_00f6:  conv.r8
      IL_00f7:  call       float64 [mscorlib]System.Math::Round(float64)
      IL_00fc:  conv.ovf.i4
      IL_00fd:  ldloc.3
      IL_00fe:  ldloc.s    points
      IL_0100:  ldloc.s    i
      IL_0102:  ldelema    [System.Drawing]System.Drawing.Point
      IL_0107:  call       instance int32 [System.Drawing]System.Drawing.Point::get_Y()
      IL_010c:  conv.r4
      IL_010d:  mul
      IL_010e:  call       float32 [Microsoft.VisualBasic]Microsoft.VisualBasic.Conversion::Fix(float32)
      IL_0113:  conv.r8
      IL_0114:  call       float64 [mscorlib]System.Math::Round(float64)
      IL_0119:  conv.ovf.i4
      IL_011a:  call       instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                     int32)
      IL_011f:  nop
//000341:                                 End If
      IL_0120:  nop
//000342:                             Next i
      IL_0121:  nop
      IL_0122:  ldloc.s    i
      IL_0124:  ldc.i4.1
      IL_0125:  add.ovf
      IL_0126:  stloc.s    i
//000343:                             Dim path As New GraphicsPath()
//000344:                             path.AddPolygon(points)
//000345:                             path.CloseFigure()
//000346:                             paths.Add(path)
//000347:                         End If
//000348:                     Next stroke
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_0128:  ldloc.s    i
      IL_012a:  ldloc.s    VB$t_i4$L0
      IL_012c:  stloc.s    VB$CG$t_i4$S0
      IL_012e:  ldloc.s    VB$CG$t_i4$S0
      IL_0130:  ble.s      IL_00be

//000343:                             Dim path As New GraphicsPath()
      IL_0132:  newobj     instance void [System.Drawing]System.Drawing.Drawing2D.GraphicsPath::.ctor()
      IL_0137:  stloc.s    path
//000344:                             path.AddPolygon(points)
      IL_0139:  ldloc.s    path
      IL_013b:  ldloc.s    points
      IL_013d:  callvirt   instance void [System.Drawing]System.Drawing.Drawing2D.GraphicsPath::AddPolygon(valuetype [System.Drawing]System.Drawing.Point[])
      IL_0142:  nop
//000345:                             path.CloseFigure()
      IL_0143:  ldloc.s    path
      IL_0145:  callvirt   instance void [System.Drawing]System.Drawing.Drawing2D.GraphicsPath::CloseFigure()
      IL_014a:  nop
//000346:                             paths.Add(path)
      IL_014b:  ldloc.s    paths
      IL_014d:  ldloc.s    path
      IL_014f:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [System.Drawing]System.Drawing.Drawing2D.GraphicsPath>::Add(!0)
      IL_0154:  nop
//000347:                         End If
      IL_0155:  nop
//000348:                     Next stroke
      IL_0156:  nop
//000349:                     Return paths
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_0157:  ldloc.s    VB$t_ref$L0
      IL_0159:  callvirt   instance bool [Microsoft.Ink]Microsoft.Ink.Strokes/StrokesEnumerator::MoveNext()
      IL_015e:  stloc.s    VB$CG$t_bool$S0
      IL_0160:  ldloc.s    VB$CG$t_bool$S0
      IL_0162:  brtrue     IL_008c

//000349:                     Return paths
      IL_0167:  ldloc.s    paths
      IL_0169:  stloc.0
//000350:                 End Using
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_016a:  leave.s    IL_018c

//000350:                 End Using
      IL_016c:  nop
//000351: 			End If
//000352: 			Return Nothing
//000353: 		End Function
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
//000357: 			_overlay.Enabled = Not _overlay.Enabled
//000358: 			btnInk.Checked = _overlay.Enabled
//000359: 			btnEraser.Enabled = btnInk.Checked
//000360: 		End Sub
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
//000366: 		End Sub
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
//000370: 			_selectedPixels.Clear()
//000371: 			pbImage.Image = _originalImage
//000372: 			If _colorizedImage IsNot Nothing Then
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
      IL_016d:  leave.s    IL_0187

    }  // end .try
    finally
    {
      IL_016f:  ldloc.s    g
      IL_0171:  ldnull
      IL_0172:  ceq
      IL_0174:  ldc.i4.0
      IL_0175:  ceq
      IL_0177:  stloc.s    VB$CG$t_bool$S0
      IL_0179:  ldloc.s    VB$CG$t_bool$S0
      IL_017b:  brfalse.s  IL_0185

      IL_017d:  ldloc.s    g
      IL_017f:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_0184:  nop
      IL_0185:  nop
      IL_0186:  endfinally
//000351: 			End If
    }  // end handler
    IL_0187:  nop
//000352: 			Return Nothing
    IL_0188:  ldnull
    IL_0189:  stloc.0
    IL_018a:  br.s       IL_018c

//000353: 		End Function
    IL_018c:  ldloc.0
    IL_018d:  ret
  } // end of method MainForm::InkToGraphicsPaths

  .method private instance void  btnInk_Click(object sender,
                                              class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       75 (0x4b)
    .maxstack  3
//000354: 
//000355: 		''' <summary>Enables or disables the InkOverlay.</summary>
//000356: 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
    IL_0000:  nop
//000357: 			_overlay.Enabled = Not _overlay.Enabled
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0007:  ldarg.0
    IL_0008:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_000d:  callvirt   instance bool [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_Enabled()
    IL_0012:  ldc.i4.0
    IL_0013:  ceq
    IL_0015:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.InkOverlay::set_Enabled(bool)
    IL_001a:  nop
//000358: 			btnInk.Checked = _overlay.Enabled
    IL_001b:  ldarg.0
    IL_001c:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnInk()
    IL_0021:  ldarg.0
    IL_0022:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0027:  callvirt   instance bool [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_Enabled()
    IL_002c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::set_Checked(bool)
    IL_0031:  nop
//000359: 			btnEraser.Enabled = btnInk.Checked
    IL_0032:  ldarg.0
    IL_0033:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnEraser()
    IL_0038:  ldarg.0
    IL_0039:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnInk()
    IL_003e:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.ToolStripButton::get_Checked()
    IL_0043:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Enabled(bool)
    IL_0048:  nop
//000360: 		End Sub
    IL_0049:  nop
    IL_004a:  ret
  } // end of method MainForm::btnInk_Click

  .method private instance void  btnEraser_Click(object sender,
                                                 class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       59 (0x3b)
    .maxstack  8
//000361: 
//000362: 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
//000363: 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
    IL_0000:  nop
//000364: 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_0007:  ldarg.0
    IL_0008:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_000d:  callvirt   instance valuetype [Microsoft.Ink]Microsoft.Ink.InkOverlayEditingMode [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_EditingMode()
    IL_0012:  ldc.i4.1
    IL_0013:  beq.s      IL_0018

    IL_0015:  ldc.i4.1
    IL_0016:  br.s       IL_0019

    IL_0018:  ldc.i4.0
    IL_0019:  callvirt   instance void [Microsoft.Ink]Microsoft.Ink.InkOverlay::set_EditingMode(valuetype [Microsoft.Ink]Microsoft.Ink.InkOverlayEditingMode)
    IL_001e:  nop
//000365: 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
    IL_001f:  ldarg.0
    IL_0020:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnEraser()
    IL_0025:  ldarg.0
    IL_0026:  ldfld      class [Microsoft.Ink]Microsoft.Ink.InkOverlay Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_overlay
    IL_002b:  callvirt   instance valuetype [Microsoft.Ink]Microsoft.Ink.InkOverlayEditingMode [Microsoft.Ink]Microsoft.Ink.InkOverlay::get_EditingMode()
    IL_0030:  ldc.i4.1
    IL_0031:  ceq
    IL_0033:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripButton::set_Checked(bool)
    IL_0038:  nop
//000366: 		End Sub
    IL_0039:  nop
    IL_003a:  ret
  } // end of method MainForm::btnEraser_Click

  .method private instance void  lblHuesSelected_Click(object sender,
                                                       class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       120 (0x78)
    .maxstack  3
    .locals init ([0] bool VB$CG$t_bool$S0)
//000367: 
//000368: 		''' <summary>Resets back to the original image.</summary>
//000369: 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
    IL_0000:  nop
//000370: 			_selectedPixels.Clear()
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_0007:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::Clear()
    IL_000c:  nop
//000371: 			pbImage.Image = _originalImage
    IL_000d:  ldarg.0
    IL_000e:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
    IL_0013:  ldarg.0
    IL_0014:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_originalImage
    IL_0019:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_001e:  nop
//000372: 			If _colorizedImage IsNot Nothing Then
    IL_001f:  ldarg.0
    IL_0020:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
    IL_0025:  ldnull
    IL_0026:  ceq
    IL_0028:  ldc.i4.0
    IL_0029:  ceq
    IL_002b:  stloc.0
//000373: 				_colorizedImage.Dispose()
//000374: 				_colorizedImage = Nothing
//000375: 			End If
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
//000378: 			lblHuesSelected.ToolTipText = Nothing
//000379: 		End Sub
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_002c:  ldloc.0
    IL_002d:  brfalse.s  IL_0042

//000373: 				_colorizedImage.Dispose()
    IL_002f:  ldarg.0
    IL_0030:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
    IL_0035:  callvirt   instance void [System.Drawing]System.Drawing.Image::Dispose()
    IL_003a:  nop
//000374: 				_colorizedImage = Nothing
    IL_003b:  ldarg.0
    IL_003c:  ldnull
    IL_003d:  stfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_colorizedImage
//000375: 			End If
    IL_0042:  nop
//000376: 
//000377: 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
    IL_0043:  ldarg.0
    IL_0044:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_lblHuesSelected()
    IL_0049:  call       string My.Resources.Resources::get_HuesSelectedDisplay()
    IL_004e:  ldarg.0
    IL_004f:  ldfld      class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_selectedPixels
    IL_0054:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<valuetype [System.Drawing]System.Drawing.Point>::get_Count()
    IL_0059:  box        [mscorlib]System.Int32
    IL_005e:  call       string [mscorlib]System.String::Format(string,
                                                                object)
    IL_0063:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0068:  nop
//000378: 			lblHuesSelected.ToolTipText = Nothing
    IL_0069:  ldarg.0
    IL_006a:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_lblHuesSelected()
    IL_006f:  ldnull
    IL_0070:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ToolTipText(string)
    IL_0075:  nop
//000379: 		End Sub
    IL_0076:  nop
    IL_0077:  ret
  } // end of method MainForm::lblHuesSelected_Click

  .method private instance void  pbImage_DragEnter(object sender,
                                                   class [System.Windows.Forms]System.Windows.Forms.DragEventArgs e) cil managed
  {
    // Code size       64 (0x40)
    .maxstack  2
    .locals init ([0] bool VB$CG$t_bool$S0)
//000380: 
//000381: 		''' <summary>Sets up a drag & drop affect.</summary>
//000382: 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
    IL_0000:  nop
//000383: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
    IL_0001:  ldarg.2
    IL_0002:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.IDataObject [System.Windows.Forms]System.Windows.Forms.DragEventArgs::get_Data()
    IL_0007:  ldsfld     string [System.Windows.Forms]System.Windows.Forms.DataFormats::FileDrop
    IL_000c:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.IDataObject::GetDataPresent(string)
    IL_0011:  brfalse.s  IL_002d

    IL_0013:  ldarg.2
    IL_0014:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.IDataObject [System.Windows.Forms]System.Windows.Forms.DragEventArgs::get_Data()
    IL_0019:  ldsfld     string [System.Windows.Forms]System.Windows.Forms.DataFormats::FileDrop
    IL_001e:  callvirt   instance object [System.Windows.Forms]System.Windows.Forms.IDataObject::GetData(string)
    IL_0023:  castclass  string[]
    IL_0028:  ldlen
    IL_0029:  conv.ovf.i4
    IL_002a:  ldc.i4.1
    IL_002b:  beq.s      IL_0030

    IL_002d:  ldc.i4.0
    IL_002e:  br.s       IL_0031

    IL_0030:  ldc.i4.1
    IL_0031:  stloc.0
//000384: 				e.Effect = DragDropEffects.Copy
//000385: 			End If
//000386: 		End Sub
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0032:  ldloc.0
    IL_0033:  brfalse.s  IL_003d

//000384: 				e.Effect = DragDropEffects.Copy
    IL_0035:  ldarg.2
    IL_0036:  ldc.i4.1
    IL_0037:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.DragEventArgs::set_Effect(valuetype [System.Windows.Forms]System.Windows.Forms.DragDropEffects)
    IL_003c:  nop
//000385: 			End If
    IL_003d:  nop
//000386: 		End Sub
    IL_003e:  nop
    IL_003f:  ret
  } // end of method MainForm::pbImage_DragEnter

  .method private instance void  pbImage_DragDrop(object sender,
                                                  class [System.Windows.Forms]System.Windows.Forms.DragEventArgs e) cil managed
  {
    // Code size       82 (0x52)
    .maxstack  3
    .locals init ([0] string[] paths,
             [1] bool VB$CG$t_bool$S0)
//000387: 
//000388: 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
//000389: 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
    IL_0000:  nop
//000390: 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
    IL_0001:  ldarg.2
    IL_0002:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.IDataObject [System.Windows.Forms]System.Windows.Forms.DragEventArgs::get_Data()
    IL_0007:  ldsfld     string [System.Windows.Forms]System.Windows.Forms.DataFormats::FileDrop
    IL_000c:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.IDataObject::GetDataPresent(string)
    IL_0011:  brfalse.s  IL_001c

    IL_0013:  ldarg.2
    IL_0014:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.DragDropEffects [System.Windows.Forms]System.Windows.Forms.DragEventArgs::get_Effect()
    IL_0019:  ldc.i4.1
    IL_001a:  beq.s      IL_001f

    IL_001c:  ldc.i4.0
    IL_001d:  br.s       IL_0020

    IL_001f:  ldc.i4.1
    IL_0020:  stloc.1
//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
//000392: 				If paths.Length = 1 Then
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0021:  ldloc.1
    IL_0022:  brfalse.s  IL_004f

//000391:                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
    IL_0024:  ldarg.2
    IL_0025:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.IDataObject [System.Windows.Forms]System.Windows.Forms.DragEventArgs::get_Data()
    IL_002a:  ldsfld     string [System.Windows.Forms]System.Windows.Forms.DataFormats::FileDrop
    IL_002f:  callvirt   instance object [System.Windows.Forms]System.Windows.Forms.IDataObject::GetData(string)
    IL_0034:  castclass  string[]
    IL_0039:  stloc.0
//000392: 				If paths.Length = 1 Then
    IL_003a:  ldloc.0
    IL_003b:  ldlen
    IL_003c:  conv.ovf.i4
    IL_003d:  ldc.i4.1
    IL_003e:  ceq
    IL_0040:  stloc.1
//000393: 					LoadImage(paths(0))
//000394: 				End If
//000395: 			End If
//000396: 		End Sub
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
//000399: 			StartColorizeImage()
//000400: 		End Sub
//000401: 	End Class
//000402: End Namespace
    IL_0041:  ldloc.1
    IL_0042:  brfalse.s  IL_004e

//000393: 					LoadImage(paths(0))
    IL_0044:  ldarg.0
    IL_0045:  ldloc.0
    IL_0046:  ldc.i4.0
    IL_0047:  ldelem.ref
    IL_0048:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::LoadImage(string)
    IL_004d:  nop
//000394: 				End If
    IL_004e:  nop
//000395: 			End If
    IL_004f:  nop
//000396: 		End Sub
    IL_0050:  nop
    IL_0051:  ret
  } // end of method MainForm::pbImage_DragDrop

  .method private instance void  btnParallel_CheckedChanged(object sender,
                                                            class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
//000397: 
//000398: 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
    IL_0000:  nop
//000399: 			StartColorizeImage()
    IL_0001:  ldarg.0
    IL_0002:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::StartColorizeImage()
    IL_0007:  nop
//000400: 		End Sub
    IL_0008:  nop
    IL_0009:  ret
  } // end of method MainForm::btnParallel_CheckedChanged

  .method private specialname instance void 
          _Lambda$__2(object s,
                      class [System]System.ComponentModel.ProgressChangedEventArgs pcea) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       23 (0x17)
    .maxstack  8
//000158: 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
    IL_0000:  ldarg.0
    IL_0001:  callvirt   instance class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_bwColorize()
    IL_0006:  ldarg.2
    IL_0007:  callvirt   instance int32 [System]System.ComponentModel.ProgressChangedEventArgs::get_ProgressPercentage()
    IL_000c:  callvirt   instance void [System]System.ComponentModel.BackgroundWorker::ReportProgress(int32)
    IL_0011:  nop
    IL_0012:  nop
    IL_0013:  br.s       IL_0015

    IL_0015:  nop
    IL_0016:  ret
  } // end of method MainForm::_Lambda$__2

  .method private specialname static bool 
          _Lambda$__3(class [System.Drawing]System.Drawing.Imaging.ImageCodecInfo ici) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       25 (0x19)
    .maxstack  3
    .locals init ([0] bool _Lambda$__3)
//000159: 
//000160: 			' Create a clone of the original image, so that we can lock its bits
//000161:             ' while still allowing the UI to refresh and resize appropriately.
//000162:             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
//000163:                 ' Colorize the image and store the resulting Bitmap.
//000164:                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
//000165:             End Using
//000166: 		End Sub
//000167: 
//000168: 		''' <summary>Configures the MainForm after colorization is complete.</summary>
//000169: 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
//000170:             ' Reenable the UI.
//000171: 			pbColorizing.Visible = False
//000172: 			toolStripMain.Enabled = True
//000173: 			pbImage.Enabled = True
//000174: 			btnLoadImage.Enabled = True
//000175: 			btnSaveImage.Enabled = True
//000176: 			tbEpsilon.Focus()
//000177: 
//000178:             ' Rethrow any exceptions.
//000179: 			If e.Error IsNot Nothing Then
//000180: 				Throw New TargetInvocationException(e.Error)
//000181: 			End If
//000182: 
//000183:             ' Get the newly computed image.
//000184: 			If _colorizedImage IsNot Nothing Then
//000185: 				_colorizedImage.Dispose()
//000186: 			End If
//000187: 			_colorizedImage = CType(e.Result, Bitmap)
//000188: 
//000189:             ' Set the newly computed image into the PictureBox.
//000190: 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
//000191: 				pbImage.Image.Dispose()
//000192: 			End If
//000193: 			pbImage.Image = _colorizedImage
//000194: 		End Sub
//000195: 
//000196: 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
//000197: 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
//000198: 			If e.ProgressPercentage > pbColorizing.Value Then
//000199: 				pbColorizing.Value = e.ProgressPercentage
//000200: 			End If
//000201: 		End Sub
//000202: 
//000203: 		''' <summary>Saves the colorized image to a file.</summary>
//000204: 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
//000205: 			If _colorizedImage IsNot Nothing Then
//000206: 				Dim sfd As New SaveFileDialog()
//000207: 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
//000208: 				sfd.DefaultExt = ".jpg"
//000209: 				If sfd.ShowDialog(Me) = DialogResult.OK Then
//000210: 					SaveImage(_colorizedImage, sfd.FileName, 100)
//000211: 				End If
//000212: 			End If
//000213: 		End Sub
//000214: 
//000215: 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
//000216: 		''' <param name="bmp">The image to be saved.</param>
//000217: 		''' <param name="path">The path where to save the image.</param>
//000218: 		''' <param name="quality">The quality of the image to save.</param>
//000219: 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
//000220:             ' Validate parameters.
//000221: 			If bmp Is Nothing Then
//000222: 				Throw New ArgumentNullException("bmp")
//000223: 			End If
//000224: 			If path Is Nothing Then
//000225: 				Throw New ArgumentNullException("path")
//000226: 			End If
//000227: 			If quality < 1 OrElse quality > 100 Then
//000228: 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
//000229: 			End If
//000230: 
//000231:             ' Save it to a file format based on the path's extension.
//000232: 
//000233:             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
//000234:                 Case ".bmp"
//000235:                     bmp.Save(path, ImageFormat.Bmp)
//000236:                 Case ".png"
//000237:                     bmp.Save(path, ImageFormat.Png)
//000238:                 Case ".gif"
//000239:                     bmp.Save(path, ImageFormat.Gif)
//000240:                 Case ".tif", ".tiff"
//000241:                     bmp.Save(path, ImageFormat.Tiff)
//000242:                 Case ".jpg"
//000243: 
//000244:                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
    IL_0000:  ldarg.0
    IL_0001:  callvirt   instance string [System.Drawing]System.Drawing.Imaging.ImageCodecInfo::get_MimeType()
    IL_0006:  ldstr      "image/jpeg"
    IL_000b:  ldc.i4.0
    IL_000c:  call       int32 [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.Operators::CompareString(string,
                                                                                                                      string,
                                                                                                                      bool)
    IL_0011:  ldc.i4.0
    IL_0012:  ceq
    IL_0014:  stloc.0
    IL_0015:  br.s       IL_0017

    IL_0017:  ldloc.0
    IL_0018:  ret
  } // end of method MainForm::_Lambda$__3

  .method private specialname instance void 
          _Lambda$__4(object a0,
                      class [Microsoft.Ink]Microsoft.Ink.InkCollectorStrokeEventArgs a1) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerStepThroughAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       24 (0x18)
    .maxstack  8
//000245:                     Using codecParams As New EncoderParameters(1)
//000246:                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
//000247:                             ' Set the JPEG quality value and save the image.
//000248:                             codecParams.Param(0) = ratio
//000249:                             bmp.Save(path, jpegCodec, codecParams)
//000250:                         End Using
//000251:                     End Using
//000252:             End Select
//000253: 		End Sub
//000254: 
//000255: 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
//000256: 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
//000257: 			StartColorizeImage()
//000258: 		End Sub
//000259: 
//000260: 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
//000261: 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
//000262: 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
//000263: 			StartRefreshTimer()
//000264: 		End Sub
//000265: 
//000266: 		''' <summary>Starts/restarts the refresh timer.</summary>
//000267: 		Private Sub StartRefreshTimer()
//000268: 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
//000269: 				btnLoadImage.Enabled = False
//000270: 				tmRefresh.Stop()
//000271: 				tmRefresh.Start()
//000272: 			End If
//000273: 		End Sub
//000274: 
//000275: 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
//000276: 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
//000277: 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
//000278: 				ScaleInk()
//000279: 			End If
//000280: 			_lastPictureBoxSize = pbImage.Size
//000281: 		End Sub
//000282: 
//000283: 		''' <summary>Initializes the InkOverlay.</summary>
//000284: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000285: 		Private Sub InitializeInk()
//000286: 			_overlay = New InkOverlay(pbImage, True)
//000287: 			_overlay.DefaultDrawingAttributes.Width = 1
//000288: 			_overlay.DefaultDrawingAttributes.Color = Color.Red
//000289: 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
//000290: 
//000291: 			' When a stroke is received, we start a timer that, when expiring,
//000292: 			' will cause the image to be redrawn.  This timer allows the user
//000293: 			' to draw multiple strokes without the image having to be redrawn
//000294: 			' after each.
//000295: 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
    IL_0000:  ldarg.0
    IL_0001:  dup
    IL_0002:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_Lambda$__5()
    IL_0008:  newobj     instance void VB$AnonymousDelegate_3::.ctor(object,
                                                                     native int)
    IL_000d:  callvirt   instance void VB$AnonymousDelegate_3::Invoke()
    IL_0012:  nop
    IL_0013:  nop
    IL_0014:  br.s       IL_0016

    IL_0016:  nop
    IL_0017:  ret
  } // end of method MainForm::_Lambda$__4

  .method private specialname instance void 
          _Lambda$__5() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       12 (0xc)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::StartRefreshTimer()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  br.s       IL_000a

    IL_000a:  nop
    IL_000b:  ret
  } // end of method MainForm::_Lambda$__5

  .method private specialname instance void 
          _Lambda$__6(object a0,
                      class [Microsoft.Ink]Microsoft.Ink.InkCollectorNewPacketsEventArgs a1) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerStepThroughAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       24 (0x18)
    .maxstack  8
//000296: 
//000297: 			' We also don't want the image to be redrawn midstroke (which
//000298: 			' could happen if the user drew a stroke, causing the timer
//000299: 			' to start, and then took longer than a second to draw the
//000300: 			' second stroke), so when new packets are received, the timer
//000301: 			' is stopped; it'll be restarted by the above when the Stroke
//000302: 			' is completed.
//000303: 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
    IL_0000:  ldarg.0
    IL_0001:  dup
    IL_0002:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_Lambda$__7()
    IL_0008:  newobj     instance void VB$AnonymousDelegate_3::.ctor(object,
                                                                     native int)
    IL_000d:  callvirt   instance void VB$AnonymousDelegate_3::Invoke()
    IL_0012:  nop
    IL_0013:  nop
    IL_0014:  br.s       IL_0016

    IL_0016:  nop
    IL_0017:  ret
  } // end of method MainForm::_Lambda$__6

  .method private specialname instance void 
          _Lambda$__7() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       17 (0x11)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tmRefresh()
    IL_0006:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Timer::Stop()
    IL_000b:  nop
    IL_000c:  nop
    IL_000d:  br.s       IL_000f

    IL_000f:  nop
    IL_0010:  ret
  } // end of method MainForm::_Lambda$__7

  .property instance class [System]System.ComponentModel.BackgroundWorker
          bwColorize()
  {
    .get instance class [System]System.ComponentModel.BackgroundWorker Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_bwColorize()
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_bwColorize(class [System]System.ComponentModel.BackgroundWorker)
  } // end of property MainForm::bwColorize
  .property instance class [System.Windows.Forms]System.Windows.Forms.Timer
          tmRefresh()
  {
    .get instance class [System.Windows.Forms]System.Windows.Forms.Timer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tmRefresh()
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_tmRefresh(class [System.Windows.Forms]System.Windows.Forms.Timer)
  } // end of property MainForm::tmRefresh
  .property instance class [System.Windows.Forms]System.Windows.Forms.PictureBox
          pbImage()
  {
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_pbImage(class [System.Windows.Forms]System.Windows.Forms.PictureBox)
    .get instance class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_pbImage()
  } // end of property MainForm::pbImage
  .property instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton
          btnLoadImage()
  {
    .get instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnLoadImage()
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_btnLoadImage(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton)
  } // end of property MainForm::btnLoadImage
  .property instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton
          btnSaveImage()
  {
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_btnSaveImage(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton)
    .get instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnSaveImage()
  } // end of property MainForm::btnSaveImage
  .property instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar
          tbEpsilon()
  {
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_tbEpsilon(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar)
    .get instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_tbEpsilon()
  } // end of property MainForm::tbEpsilon
  .property instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton
          btnInk()
  {
    .get instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnInk()
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_btnInk(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton)
  } // end of property MainForm::btnInk
  .property instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton
          btnEraser()
  {
    .get instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnEraser()
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_btnEraser(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton)
  } // end of property MainForm::btnEraser
  .property instance class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel
          lblHuesSelected()
  {
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_lblHuesSelected(class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel)
    .get instance class [System.Windows.Forms]System.Windows.Forms.ToolStripLabel Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_lblHuesSelected()
  } // end of property MainForm::lblHuesSelected
  .property instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton
          btnParallel()
  {
    .get instance class [System.Windows.Forms]System.Windows.Forms.ToolStripButton Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::get_btnParallel()
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::set_btnParallel(class [System.Windows.Forms]System.Windows.Forms.ToolStripButton)
  } // end of property MainForm::btnParallel
} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm

.class private auto ansi sealed Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Module1
       extends [mscorlib]System.Object
{
  .custom instance void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.StandardModuleAttribute::.ctor() = ( 01 00 00 00 ) 
  .class auto ansi sealed nested assembly Program
         extends [mscorlib]System.Object
  {
    .method private specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       10 (0xa)
      .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\Module1.vb' 
//000010:             Private Sub New()
      IL_0000:  nop
//000011:             End Sub
//000012:             <STAThread()>
//000013:                 Shared Sub Main(ByVal args() As String)
//000014:                 Application.EnableVisualStyles()
//000015:                 Application.SetCompatibleTextRenderingDefault(False)
//000016:                 Application.Run(New MainForm())
//000017:             End Sub
//000018:         End Class
//000019: 
//000020:     End Module
//000021: 
//000022: End Namespace
//000023: 
      IL_0001:  ldarg.0
      IL_0002:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0007:  nop
//000011:             End Sub
      IL_0008:  nop
      IL_0009:  ret
    } // end of method Program::.ctor

    .method public static void  Main(string[] args) cil managed
    {
      .entrypoint
      .custom instance void [mscorlib]System.STAThreadAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       27 (0x1b)
      .maxstack  8
//000012:             <STAThread()>
//000013:                 Shared Sub Main(ByVal args() As String)
      IL_0000:  nop
//000014:                 Application.EnableVisualStyles()
      IL_0001:  call       void [System.Windows.Forms]System.Windows.Forms.Application::EnableVisualStyles()
      IL_0006:  nop
//000015:                 Application.SetCompatibleTextRenderingDefault(False)
      IL_0007:  ldc.i4.0
      IL_0008:  call       void [System.Windows.Forms]System.Windows.Forms.Application::SetCompatibleTextRenderingDefault(bool)
      IL_000d:  nop
//000016:                 Application.Run(New MainForm())
      IL_000e:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::.ctor()
      IL_0013:  call       void [System.Windows.Forms]System.Windows.Forms.Application::Run(class [System.Windows.Forms]System.Windows.Forms.Form)
      IL_0018:  nop
//000017:             End Sub
      IL_0019:  nop
      IL_001a:  ret
    } // end of method Program::Main

  } // end of class Program

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Module1

.class private auto ansi sealed My.Resources.Resources
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.StandardModuleAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 33 53 79 73 74 65 6D 2E 52 65 73 6F 75 72   // ..3System.Resour
                                                                                                  63 65 73 2E 54 6F 6F 6C 73 2E 53 74 72 6F 6E 67   // ces.Tools.Strong
                                                                                                  6C 79 54 79 70 65 64 52 65 73 6F 75 72 63 65 42   // lyTypedResourceB
                                                                                                  75 69 6C 64 65 72 07 34 2E 30 2E 30 2E 30 00 00 ) // uilder.4.0.0.0..
  .custom instance void [Microsoft.VisualBasic]Microsoft.VisualBasic.HideModuleNameAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Resources.ResourceManager resourceMan
  .field private static class [mscorlib]System.Globalization.CultureInfo resourceCulture
  .method assembly specialname static class [mscorlib]System.Resources.ResourceManager 
          get_ResourceManager() cil managed
  {
    // Code size       59 (0x3b)
    .maxstack  2
    .locals init ([0] class [mscorlib]System.Resources.ResourceManager ResourceManager,
             [1] class [mscorlib]System.Resources.ResourceManager temp,
             [2] bool VB$CG$t_bool$S0)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\My Project\Resources.Designer.vb' 
//000040: 			Get
    IL_0000:  nop
//000041: 				If Object.ReferenceEquals(resourceMan, Nothing) Then
    IL_0001:  ldsfld     class [mscorlib]System.Resources.ResourceManager My.Resources.Resources::resourceMan
    IL_0006:  ldnull
    IL_0007:  call       bool [mscorlib]System.Object::ReferenceEquals(object,
                                                                       object)
    IL_000c:  stloc.2
//000042: 					Dim temp As New Global.System.Resources.ResourceManager("Resourc" & "es", GetType(Resources).Assembly)
//000043: 					resourceMan = temp
//000044: 				End If
//000045: 				Return resourceMan
//000046: 			End Get
//000047: 		End Property
//000048: 
//000049: 		''' <summary>
//000050: 		'''   Overrides the current thread's CurrentUICulture property for all
//000051: 		'''   resource lookups using this strongly typed resource class.
//000052: 		''' </summary>
//000053: 		<Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>
//000054: 		Friend Property Culture() As Global.System.Globalization.CultureInfo
//000055: 			Get
//000056: 				Return resourceCulture
//000057: 			End Get
//000058: 			Set(ByVal value As System.Globalization.CultureInfo)
//000059: 				resourceCulture = value
//000060: 			End Set
//000061: 		End Property
//000062: 
//000063: 		''' <summary>
//000064: 		'''   Looks up a localized string similar to Hue variation: {0}.
//000065: 		''' </summary>
//000066: 		Friend ReadOnly Property EpsilonDisplay() As String
//000067: 			Get
//000068: 				Return ResourceManager.GetString("EpsilonDisplay", resourceCulture)
//000069: 			End Get
//000070: 		End Property
//000071: 
//000072: 		Friend ReadOnly Property eraser() As Bitmap
//000073: 			Get
//000074:                 Dim obj = ResourceManager.GetObject("eraser", resourceCulture)
//000075: 				Return (CType(obj, Bitmap))
//000076: 			End Get
//000077: 		End Property
//000078: 
//000079: 		''' <summary>
//000080: 		'''   Looks up a localized string similar to Hues selected: {0}.
//000081: 		''' </summary>
//000082: 		Friend ReadOnly Property HuesSelectedDisplay() As String
//000083: 			Get
//000084: 				Return ResourceManager.GetString("HuesSelectedDisplay", resourceCulture)
//000085: 			End Get
//000086: 		End Property
//000087: 
//000088: 		Friend ReadOnly Property InsertPictureHS() As Bitmap
//000089: 			Get
//000090:                 Dim obj = ResourceManager.GetObject("InsertPictureHS", resourceCulture)
//000091: 				Return (CType(obj, Bitmap))
//000092: 			End Get
//000093: 		End Property
//000094: 
//000095: 		Friend ReadOnly Property pen() As Bitmap
//000096: 			Get
//000097:                 Dim obj = ResourceManager.GetObject("pen", resourceCulture)
//000098: 				Return (CType(obj, Bitmap))
//000099: 			End Get
//000100: 		End Property
//000101: 
//000102: 		Friend ReadOnly Property saveHS() As Bitmap
//000103: 			Get
//000104:                 Dim obj = ResourceManager.GetObject("saveHS", resourceCulture)
//000105: 				Return (CType(obj, Bitmap))
//000106: 			End Get
//000107: 		End Property
//000108: 	End Module
//000109: End Namespace
    IL_000d:  ldloc.2
    IL_000e:  brfalse.s  IL_0030

//000042: 					Dim temp As New Global.System.Resources.ResourceManager("Resourc" & "es", GetType(Resources).Assembly)
    IL_0010:  ldstr      "Resources"
    IL_0015:  ldtoken    My.Resources.Resources
    IL_001a:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_001f:  callvirt   instance class [mscorlib]System.Reflection.Assembly [mscorlib]System.Type::get_Assembly()
    IL_0024:  newobj     instance void [mscorlib]System.Resources.ResourceManager::.ctor(string,
                                                                                         class [mscorlib]System.Reflection.Assembly)
    IL_0029:  stloc.1
//000043: 					resourceMan = temp
    IL_002a:  ldloc.1
    IL_002b:  stsfld     class [mscorlib]System.Resources.ResourceManager My.Resources.Resources::resourceMan
//000044: 				End If
    IL_0030:  nop
//000045: 				Return resourceMan
    IL_0031:  ldsfld     class [mscorlib]System.Resources.ResourceManager My.Resources.Resources::resourceMan
    IL_0036:  stloc.0
    IL_0037:  br.s       IL_0039

//000046: 			End Get
    IL_0039:  ldloc.0
    IL_003a:  ret
  } // end of method Resources::get_ResourceManager

  .method assembly specialname static class [mscorlib]System.Globalization.CultureInfo 
          get_Culture() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Globalization.CultureInfo Culture)
//000047: 		End Property
//000048: 
//000049: 		''' <summary>
//000050: 		'''   Overrides the current thread's CurrentUICulture property for all
//000051: 		'''   resource lookups using this strongly typed resource class.
//000052: 		''' </summary>
//000053: 		<Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>
//000054: 		Friend Property Culture() As Global.System.Globalization.CultureInfo
//000055: 			Get
    IL_0000:  nop
//000056: 				Return resourceCulture
    IL_0001:  ldsfld     class [mscorlib]System.Globalization.CultureInfo My.Resources.Resources::resourceCulture
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000057: 			End Get
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Resources::get_Culture

  .method assembly specialname static void 
          set_Culture(class [mscorlib]System.Globalization.CultureInfo 'value') cil managed
  {
    // Code size       9 (0x9)
    .maxstack  8
//000058: 			Set(ByVal value As System.Globalization.CultureInfo)
    IL_0000:  nop
//000059: 				resourceCulture = value
    IL_0001:  ldarg.0
    IL_0002:  stsfld     class [mscorlib]System.Globalization.CultureInfo My.Resources.Resources::resourceCulture
//000060: 			End Set
    IL_0007:  nop
    IL_0008:  ret
  } // end of method Resources::set_Culture

  .method assembly specialname static string 
          get_EpsilonDisplay() cil managed
  {
    // Code size       26 (0x1a)
    .maxstack  3
    .locals init ([0] string EpsilonDisplay)
//000061: 		End Property
//000062: 
//000063: 		''' <summary>
//000064: 		'''   Looks up a localized string similar to Hue variation: {0}.
//000065: 		''' </summary>
//000066: 		Friend ReadOnly Property EpsilonDisplay() As String
//000067: 			Get
    IL_0000:  nop
//000068: 				Return ResourceManager.GetString("EpsilonDisplay", resourceCulture)
    IL_0001:  call       class [mscorlib]System.Resources.ResourceManager My.Resources.Resources::get_ResourceManager()
    IL_0006:  ldstr      "EpsilonDisplay"
    IL_000b:  ldsfld     class [mscorlib]System.Globalization.CultureInfo My.Resources.Resources::resourceCulture
    IL_0010:  callvirt   instance string [mscorlib]System.Resources.ResourceManager::GetString(string,
                                                                                               class [mscorlib]System.Globalization.CultureInfo)
    IL_0015:  stloc.0
    IL_0016:  br.s       IL_0018

//000069: 			End Get
    IL_0018:  ldloc.0
    IL_0019:  ret
  } // end of method Resources::get_EpsilonDisplay

  .method assembly specialname static class [System.Drawing]System.Drawing.Bitmap 
          get_eraser() cil managed
  {
    // Code size       38 (0x26)
    .maxstack  3
    .locals init ([0] class [System.Drawing]System.Drawing.Bitmap eraser,
             [1] object obj)
//000070: 		End Property
//000071: 
//000072: 		Friend ReadOnly Property eraser() As Bitmap
//000073: 			Get
    IL_0000:  nop
//000074:                 Dim obj = ResourceManager.GetObject("eraser", resourceCulture)
    IL_0001:  call       class [mscorlib]System.Resources.ResourceManager My.Resources.Resources::get_ResourceManager()
    IL_0006:  ldstr      "eraser"
    IL_000b:  ldsfld     class [mscorlib]System.Globalization.CultureInfo My.Resources.Resources::resourceCulture
    IL_0010:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string,
                                                                                               class [mscorlib]System.Globalization.CultureInfo)
    IL_0015:  call       object [mscorlib]System.Runtime.CompilerServices.RuntimeHelpers::GetObjectValue(object)
    IL_001a:  stloc.1
//000075: 				Return (CType(obj, Bitmap))
    IL_001b:  ldloc.1
    IL_001c:  castclass  [System.Drawing]System.Drawing.Bitmap
    IL_0021:  stloc.0
    IL_0022:  br.s       IL_0024

//000076: 			End Get
    IL_0024:  ldloc.0
    IL_0025:  ret
  } // end of method Resources::get_eraser

  .method assembly specialname static string 
          get_HuesSelectedDisplay() cil managed
  {
    // Code size       26 (0x1a)
    .maxstack  3
    .locals init ([0] string HuesSelectedDisplay)
//000077: 		End Property
//000078: 
//000079: 		''' <summary>
//000080: 		'''   Looks up a localized string similar to Hues selected: {0}.
//000081: 		''' </summary>
//000082: 		Friend ReadOnly Property HuesSelectedDisplay() As String
//000083: 			Get
    IL_0000:  nop
//000084: 				Return ResourceManager.GetString("HuesSelectedDisplay", resourceCulture)
    IL_0001:  call       class [mscorlib]System.Resources.ResourceManager My.Resources.Resources::get_ResourceManager()
    IL_0006:  ldstr      "HuesSelectedDisplay"
    IL_000b:  ldsfld     class [mscorlib]System.Globalization.CultureInfo My.Resources.Resources::resourceCulture
    IL_0010:  callvirt   instance string [mscorlib]System.Resources.ResourceManager::GetString(string,
                                                                                               class [mscorlib]System.Globalization.CultureInfo)
    IL_0015:  stloc.0
    IL_0016:  br.s       IL_0018

//000085: 			End Get
    IL_0018:  ldloc.0
    IL_0019:  ret
  } // end of method Resources::get_HuesSelectedDisplay

  .method assembly specialname static class [System.Drawing]System.Drawing.Bitmap 
          get_InsertPictureHS() cil managed
  {
    // Code size       38 (0x26)
    .maxstack  3
    .locals init ([0] class [System.Drawing]System.Drawing.Bitmap InsertPictureHS,
             [1] object obj)
//000086: 		End Property
//000087: 
//000088: 		Friend ReadOnly Property InsertPictureHS() As Bitmap
//000089: 			Get
    IL_0000:  nop
//000090:                 Dim obj = ResourceManager.GetObject("InsertPictureHS", resourceCulture)
    IL_0001:  call       class [mscorlib]System.Resources.ResourceManager My.Resources.Resources::get_ResourceManager()
    IL_0006:  ldstr      "InsertPictureHS"
    IL_000b:  ldsfld     class [mscorlib]System.Globalization.CultureInfo My.Resources.Resources::resourceCulture
    IL_0010:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string,
                                                                                               class [mscorlib]System.Globalization.CultureInfo)
    IL_0015:  call       object [mscorlib]System.Runtime.CompilerServices.RuntimeHelpers::GetObjectValue(object)
    IL_001a:  stloc.1
//000091: 				Return (CType(obj, Bitmap))
    IL_001b:  ldloc.1
    IL_001c:  castclass  [System.Drawing]System.Drawing.Bitmap
    IL_0021:  stloc.0
    IL_0022:  br.s       IL_0024

//000092: 			End Get
    IL_0024:  ldloc.0
    IL_0025:  ret
  } // end of method Resources::get_InsertPictureHS

  .method assembly specialname static class [System.Drawing]System.Drawing.Bitmap 
          get_pen() cil managed
  {
    // Code size       38 (0x26)
    .maxstack  3
    .locals init ([0] object obj,
             [1] class [System.Drawing]System.Drawing.Bitmap pen)
//000093: 		End Property
//000094: 
//000095: 		Friend ReadOnly Property pen() As Bitmap
//000096: 			Get
    IL_0000:  nop
//000097:                 Dim obj = ResourceManager.GetObject("pen", resourceCulture)
    IL_0001:  call       class [mscorlib]System.Resources.ResourceManager My.Resources.Resources::get_ResourceManager()
    IL_0006:  ldstr      "pen"
    IL_000b:  ldsfld     class [mscorlib]System.Globalization.CultureInfo My.Resources.Resources::resourceCulture
    IL_0010:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string,
                                                                                               class [mscorlib]System.Globalization.CultureInfo)
    IL_0015:  call       object [mscorlib]System.Runtime.CompilerServices.RuntimeHelpers::GetObjectValue(object)
    IL_001a:  stloc.0
//000098: 				Return (CType(obj, Bitmap))
    IL_001b:  ldloc.0
    IL_001c:  castclass  [System.Drawing]System.Drawing.Bitmap
    IL_0021:  stloc.1
    IL_0022:  br.s       IL_0024

//000099: 			End Get
    IL_0024:  ldloc.1
    IL_0025:  ret
  } // end of method Resources::get_pen

  .method assembly specialname static class [System.Drawing]System.Drawing.Bitmap 
          get_saveHS() cil managed
  {
    // Code size       38 (0x26)
    .maxstack  3
    .locals init ([0] object obj,
             [1] class [System.Drawing]System.Drawing.Bitmap saveHS)
//000100: 		End Property
//000101: 
//000102: 		Friend ReadOnly Property saveHS() As Bitmap
//000103: 			Get
    IL_0000:  nop
//000104:                 Dim obj = ResourceManager.GetObject("saveHS", resourceCulture)
    IL_0001:  call       class [mscorlib]System.Resources.ResourceManager My.Resources.Resources::get_ResourceManager()
    IL_0006:  ldstr      "saveHS"
    IL_000b:  ldsfld     class [mscorlib]System.Globalization.CultureInfo My.Resources.Resources::resourceCulture
    IL_0010:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string,
                                                                                               class [mscorlib]System.Globalization.CultureInfo)
    IL_0015:  call       object [mscorlib]System.Runtime.CompilerServices.RuntimeHelpers::GetObjectValue(object)
    IL_001a:  stloc.0
//000105: 				Return (CType(obj, Bitmap))
    IL_001b:  ldloc.0
    IL_001c:  castclass  [System.Drawing]System.Drawing.Bitmap
    IL_0021:  stloc.1
    IL_0022:  br.s       IL_0024

//000106: 			End Get
    IL_0024:  ldloc.1
    IL_0025:  ret
  } // end of method Resources::get_saveHS

  .property class [mscorlib]System.Resources.ResourceManager
          ResourceManager()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .get class [mscorlib]System.Resources.ResourceManager My.Resources.Resources::get_ResourceManager()
  } // end of property Resources::ResourceManager
  .property class [mscorlib]System.Globalization.CultureInfo
          Culture()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .set void My.Resources.Resources::set_Culture(class [mscorlib]System.Globalization.CultureInfo)
    .get class [mscorlib]System.Globalization.CultureInfo My.Resources.Resources::get_Culture()
  } // end of property Resources::Culture
  .property string EpsilonDisplay()
  {
    .get string My.Resources.Resources::get_EpsilonDisplay()
  } // end of property Resources::EpsilonDisplay
  .property class [System.Drawing]System.Drawing.Bitmap
          eraser()
  {
    .get class [System.Drawing]System.Drawing.Bitmap My.Resources.Resources::get_eraser()
  } // end of property Resources::eraser
  .property string HuesSelectedDisplay()
  {
    .get string My.Resources.Resources::get_HuesSelectedDisplay()
  } // end of property Resources::HuesSelectedDisplay
  .property class [System.Drawing]System.Drawing.Bitmap
          InsertPictureHS()
  {
    .get class [System.Drawing]System.Drawing.Bitmap My.Resources.Resources::get_InsertPictureHS()
  } // end of property Resources::InsertPictureHS
  .property class [System.Drawing]System.Drawing.Bitmap
          pen()
  {
    .get class [System.Drawing]System.Drawing.Bitmap My.Resources.Resources::get_pen()
  } // end of property Resources::pen
  .property class [System.Drawing]System.Drawing.Bitmap
          saveHS()
  {
    .get class [System.Drawing]System.Drawing.Bitmap My.Resources.Resources::get_saveHS()
  } // end of property Resources::saveHS
} // end of class My.Resources.Resources

.class private auto ansi sealed beforefieldinit My.Settings
       extends [System]System.Configuration.ApplicationSettingsBase
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 4B 4D 69 63 72 6F 73 6F 66 74 2E 56 69 73   // ..KMicrosoft.Vis
                                                                                                  75 61 6C 53 74 75 64 69 6F 2E 45 64 69 74 6F 72   // ualStudio.Editor
                                                                                                  73 2E 53 65 74 74 69 6E 67 73 44 65 73 69 67 6E   // s.SettingsDesign
                                                                                                  65 72 2E 53 65 74 74 69 6E 67 73 53 69 6E 67 6C   // er.SettingsSingl
                                                                                                  65 46 69 6C 65 47 65 6E 65 72 61 74 6F 72 08 31   // eFileGenerator.1
                                                                                                  30 2E 30 2E 30 2E 30 00 00 )                      // 0.0.0.0..
  .field private static class My.Settings defaultInstance
  .method private specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       22 (0x16)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\My Project\Settings.Designer.vb' 
//000019:         Private Shared defaultInstance As Settings = (CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New Settings()), Settings))
    IL_0000:  newobj     instance void My.Settings::.ctor()
    IL_0005:  call       class [System]System.Configuration.SettingsBase [System]System.Configuration.SettingsBase::Synchronized(class [System]System.Configuration.SettingsBase)
    IL_000a:  castclass  My.Settings
    IL_000f:  stsfld     class My.Settings My.Settings::defaultInstance
    IL_0014:  nop
    IL_0015:  ret
  } // end of method Settings::.cctor

  .method public specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       9 (0x9)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [System]System.Configuration.ApplicationSettingsBase::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ret
  } // end of method Settings::.ctor

  .method public specialname static class My.Settings 
          get_Default() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class My.Settings Default)
//000020: 
//000021:         Public Shared ReadOnly Property [Default]() As Settings
//000022:             Get
    IL_0000:  nop
//000023:                 Return defaultInstance
    IL_0001:  ldsfld     class My.Settings My.Settings::defaultInstance
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000024:             End Get
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Settings::get_Default

  .property class My.Settings Default()
  {
    .get class My.Settings My.Settings::get_Default()
  } // end of property Settings::Default
} // end of class My.Settings

.class private auto ansi sealed beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection
       extends [mscorlib]System.Object
{
  .field private static bool _inkAssemblyAvailable
  .method private specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       18 (0x12)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\PlatformDetection.vb' 
//000027: 		Private Shared _inkAssemblyAvailable As Boolean = (LoadInkAssembly() IsNot Nothing)
    IL_0000:  call       class [mscorlib]System.Reflection.Assembly Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::LoadInkAssembly()
    IL_0005:  ldnull
    IL_0006:  ceq
    IL_0008:  ldc.i4.0
    IL_0009:  ceq
    IL_000b:  stsfld     bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::_inkAssemblyAvailable
    IL_0010:  nop
    IL_0011:  ret
  } // end of method PlatformDetection::.cctor

  .method private specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
//000023: 		Private Sub New()
    IL_0000:  nop
//000024: 		End Sub
//000025: 
//000026: 		''' <summary>Whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000027: 		Private Shared _inkAssemblyAvailable As Boolean = (LoadInkAssembly() IsNot Nothing)
//000028: 
//000029: 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000030: 		''' <returns>The Assembly instance for Microsoft.Ink if it's available; null, otherwise.</returns>
//000031: 		Private Shared Function LoadInkAssembly() As System.Reflection.Assembly
//000032: 			Try
//000033: 				Return LoadInkAssemblyInternal()
//000034: 			Catch e1 As TypeLoadException
//000035: 			Catch e2 As IOException
//000036: 			Catch e3 As SecurityException
//000037: 			Catch e4 As BadImageFormatException
//000038: 			End Try
//000039: 			Return Nothing
//000040: 		End Function
//000041: 
//000042: 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000043: 		''' <returns>The Assembly instance for Microsoft.Ink.</returns>
//000044: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000045: 		Private Shared Function LoadInkAssemblyInternal() As System.Reflection.Assembly
//000046: 			Return GetType(InkOverlay).Assembly
//000047: 		End Function
//000048: 
//000049: 		''' <summary>Gets whether this platform supports using ink.</summary>
//000050: 		Public Shared ReadOnly Property SupportsInk() As Boolean
//000051: 			Get
//000052: 				Return InkAssemblyAvailable AndAlso RecognizerInstalled
//000053: 			End Get
//000054: 		End Property
//000055: 
//000056: 		''' <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000057: 		Public Shared ReadOnly Property InkAssemblyAvailable() As Boolean
//000058: 			Get
//000059: 				Return _inkAssemblyAvailable
//000060: 			End Get
//000061: 		End Property
//000062: 
//000063: 		''' <summary>Gets whether a valid recognizer is installed.</summary>
//000064: 		Public Shared ReadOnly Property RecognizerInstalled() As Boolean
//000065: 			Get
//000066: 				If Not _inkAssemblyAvailable Then
//000067: 					Return False
//000068: 				End If
//000069: 				Return GetDefaultRecognizer() IsNot Nothing
//000070: 			End Get
//000071: 		End Property
//000072: 
//000073: 		''' <summary>Gets the best recognizer for the current locale.</summary>
//000074: 		''' <returns>The best recognizer for the current locale.</returns>
//000075: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000076: 		Public Shared Function GetDefaultRecognizer() As Recognizer
//000077: 			Dim recognizer As Recognizer = Nothing
//000078: 			Try
//000079: 				Dim recognizers As New Recognizers()
//000080: 				If recognizers.Count > 1 Then
//000081:                     ' First try the current locale's recognizer.
//000082: 					Try
//000083: 						recognizer = recognizers.GetDefaultRecognizer()
//000084: 					Catch
//000085: 					End Try
//000086: 
//000087:                     ' Fallback to the en-US (1033) recognizer.
//000088: 					If recognizer Is Nothing Then
//000089: 						Try
//000090: 							recognizer = recognizers.GetDefaultRecognizer(1033)
//000091: 						Catch
//000092: 						End Try
//000093: 					End If
//000094: 				End If
//000095: 			Catch
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
    IL_0001:  ldarg.0
    IL_0002:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0007:  nop
//000024: 		End Sub
    IL_0008:  nop
    IL_0009:  ret
  } // end of method PlatformDetection::.ctor

  .method private static class [mscorlib]System.Reflection.Assembly 
          LoadInkAssembly() cil managed
  {
    // Code size       80 (0x50)
    .maxstack  2
    .locals init ([0] class [mscorlib]System.Reflection.Assembly LoadInkAssembly,
             [1] class [mscorlib]System.TypeLoadException e1,
             [2] class [mscorlib]System.IO.IOException e2,
             [3] class [mscorlib]System.Security.SecurityException e3,
             [4] class [mscorlib]System.BadImageFormatException e4)
//000025: 
//000026: 		''' <summary>Whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000027: 		Private Shared _inkAssemblyAvailable As Boolean = (LoadInkAssembly() IsNot Nothing)
//000028: 
//000029: 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000030: 		''' <returns>The Assembly instance for Microsoft.Ink if it's available; null, otherwise.</returns>
//000031: 		Private Shared Function LoadInkAssembly() As System.Reflection.Assembly
    IL_0000:  nop
//000032: 			Try
    IL_0001:  nop
//000033: 				Return LoadInkAssemblyInternal()
    .try
    {
      IL_0002:  call       class [mscorlib]System.Reflection.Assembly Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::LoadInkAssemblyInternal()
      IL_0007:  stloc.0
//000034: 			Catch e1 As TypeLoadException
//000035: 			Catch e2 As IOException
//000036: 			Catch e3 As SecurityException
//000037: 			Catch e4 As BadImageFormatException
//000038: 			End Try
//000039: 			Return Nothing
//000040: 		End Function
//000041: 
//000042: 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000043: 		''' <returns>The Assembly instance for Microsoft.Ink.</returns>
//000044: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000045: 		Private Shared Function LoadInkAssemblyInternal() As System.Reflection.Assembly
//000046: 			Return GetType(InkOverlay).Assembly
//000047: 		End Function
//000048: 
//000049: 		''' <summary>Gets whether this platform supports using ink.</summary>
//000050: 		Public Shared ReadOnly Property SupportsInk() As Boolean
//000051: 			Get
//000052: 				Return InkAssemblyAvailable AndAlso RecognizerInstalled
//000053: 			End Get
//000054: 		End Property
//000055: 
//000056: 		''' <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000057: 		Public Shared ReadOnly Property InkAssemblyAvailable() As Boolean
//000058: 			Get
//000059: 				Return _inkAssemblyAvailable
//000060: 			End Get
//000061: 		End Property
//000062: 
//000063: 		''' <summary>Gets whether a valid recognizer is installed.</summary>
//000064: 		Public Shared ReadOnly Property RecognizerInstalled() As Boolean
//000065: 			Get
//000066: 				If Not _inkAssemblyAvailable Then
//000067: 					Return False
//000068: 				End If
//000069: 				Return GetDefaultRecognizer() IsNot Nothing
//000070: 			End Get
//000071: 		End Property
//000072: 
//000073: 		''' <summary>Gets the best recognizer for the current locale.</summary>
//000074: 		''' <returns>The best recognizer for the current locale.</returns>
//000075: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000076: 		Public Shared Function GetDefaultRecognizer() As Recognizer
//000077: 			Dim recognizer As Recognizer = Nothing
//000078: 			Try
//000079: 				Dim recognizers As New Recognizers()
//000080: 				If recognizers.Count > 1 Then
//000081:                     ' First try the current locale's recognizer.
//000082: 					Try
//000083: 						recognizer = recognizers.GetDefaultRecognizer()
//000084: 					Catch
//000085: 					End Try
//000086: 
//000087:                     ' Fallback to the en-US (1033) recognizer.
//000088: 					If recognizer Is Nothing Then
//000089: 						Try
//000090: 							recognizer = recognizers.GetDefaultRecognizer(1033)
//000091: 						Catch
//000092: 						End Try
//000093: 					End If
//000094: 				End If
//000095: 			Catch
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
      IL_0008:  leave.s    IL_004e

      IL_000a:  leave.s    IL_0049

    }  // end .try
    catch [mscorlib]System.TypeLoadException 
    {
      IL_000c:  dup
      IL_000d:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::SetProjectError(class [mscorlib]System.Exception)
      IL_0012:  stloc.1
//000034: 			Catch e1 As TypeLoadException
      IL_0013:  nop
      IL_0014:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::ClearProjectError()
//000035: 			Catch e2 As IOException
//000036: 			Catch e3 As SecurityException
//000037: 			Catch e4 As BadImageFormatException
//000038: 			End Try
//000039: 			Return Nothing
//000040: 		End Function
//000041: 
//000042: 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000043: 		''' <returns>The Assembly instance for Microsoft.Ink.</returns>
//000044: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000045: 		Private Shared Function LoadInkAssemblyInternal() As System.Reflection.Assembly
//000046: 			Return GetType(InkOverlay).Assembly
//000047: 		End Function
//000048: 
//000049: 		''' <summary>Gets whether this platform supports using ink.</summary>
//000050: 		Public Shared ReadOnly Property SupportsInk() As Boolean
//000051: 			Get
//000052: 				Return InkAssemblyAvailable AndAlso RecognizerInstalled
//000053: 			End Get
//000054: 		End Property
//000055: 
//000056: 		''' <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000057: 		Public Shared ReadOnly Property InkAssemblyAvailable() As Boolean
//000058: 			Get
//000059: 				Return _inkAssemblyAvailable
//000060: 			End Get
//000061: 		End Property
//000062: 
//000063: 		''' <summary>Gets whether a valid recognizer is installed.</summary>
//000064: 		Public Shared ReadOnly Property RecognizerInstalled() As Boolean
//000065: 			Get
//000066: 				If Not _inkAssemblyAvailable Then
//000067: 					Return False
//000068: 				End If
//000069: 				Return GetDefaultRecognizer() IsNot Nothing
//000070: 			End Get
//000071: 		End Property
//000072: 
//000073: 		''' <summary>Gets the best recognizer for the current locale.</summary>
//000074: 		''' <returns>The best recognizer for the current locale.</returns>
//000075: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000076: 		Public Shared Function GetDefaultRecognizer() As Recognizer
//000077: 			Dim recognizer As Recognizer = Nothing
//000078: 			Try
//000079: 				Dim recognizers As New Recognizers()
//000080: 				If recognizers.Count > 1 Then
//000081:                     ' First try the current locale's recognizer.
//000082: 					Try
//000083: 						recognizer = recognizers.GetDefaultRecognizer()
//000084: 					Catch
//000085: 					End Try
//000086: 
//000087:                     ' Fallback to the en-US (1033) recognizer.
//000088: 					If recognizer Is Nothing Then
//000089: 						Try
//000090: 							recognizer = recognizers.GetDefaultRecognizer(1033)
//000091: 						Catch
//000092: 						End Try
//000093: 					End If
//000094: 				End If
//000095: 			Catch
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
      IL_0019:  leave.s    IL_0049

    }  // end handler
    catch [mscorlib]System.IO.IOException 
    {
      IL_001b:  dup
      IL_001c:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::SetProjectError(class [mscorlib]System.Exception)
      IL_0021:  stloc.2
//000035: 			Catch e2 As IOException
      IL_0022:  nop
      IL_0023:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::ClearProjectError()
//000036: 			Catch e3 As SecurityException
//000037: 			Catch e4 As BadImageFormatException
//000038: 			End Try
//000039: 			Return Nothing
//000040: 		End Function
//000041: 
//000042: 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000043: 		''' <returns>The Assembly instance for Microsoft.Ink.</returns>
//000044: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000045: 		Private Shared Function LoadInkAssemblyInternal() As System.Reflection.Assembly
//000046: 			Return GetType(InkOverlay).Assembly
//000047: 		End Function
//000048: 
//000049: 		''' <summary>Gets whether this platform supports using ink.</summary>
//000050: 		Public Shared ReadOnly Property SupportsInk() As Boolean
//000051: 			Get
//000052: 				Return InkAssemblyAvailable AndAlso RecognizerInstalled
//000053: 			End Get
//000054: 		End Property
//000055: 
//000056: 		''' <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000057: 		Public Shared ReadOnly Property InkAssemblyAvailable() As Boolean
//000058: 			Get
//000059: 				Return _inkAssemblyAvailable
//000060: 			End Get
//000061: 		End Property
//000062: 
//000063: 		''' <summary>Gets whether a valid recognizer is installed.</summary>
//000064: 		Public Shared ReadOnly Property RecognizerInstalled() As Boolean
//000065: 			Get
//000066: 				If Not _inkAssemblyAvailable Then
//000067: 					Return False
//000068: 				End If
//000069: 				Return GetDefaultRecognizer() IsNot Nothing
//000070: 			End Get
//000071: 		End Property
//000072: 
//000073: 		''' <summary>Gets the best recognizer for the current locale.</summary>
//000074: 		''' <returns>The best recognizer for the current locale.</returns>
//000075: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000076: 		Public Shared Function GetDefaultRecognizer() As Recognizer
//000077: 			Dim recognizer As Recognizer = Nothing
//000078: 			Try
//000079: 				Dim recognizers As New Recognizers()
//000080: 				If recognizers.Count > 1 Then
//000081:                     ' First try the current locale's recognizer.
//000082: 					Try
//000083: 						recognizer = recognizers.GetDefaultRecognizer()
//000084: 					Catch
//000085: 					End Try
//000086: 
//000087:                     ' Fallback to the en-US (1033) recognizer.
//000088: 					If recognizer Is Nothing Then
//000089: 						Try
//000090: 							recognizer = recognizers.GetDefaultRecognizer(1033)
//000091: 						Catch
//000092: 						End Try
//000093: 					End If
//000094: 				End If
//000095: 			Catch
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
      IL_0028:  leave.s    IL_0049

    }  // end handler
    catch [mscorlib]System.Security.SecurityException 
    {
      IL_002a:  dup
      IL_002b:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::SetProjectError(class [mscorlib]System.Exception)
      IL_0030:  stloc.3
//000036: 			Catch e3 As SecurityException
      IL_0031:  nop
      IL_0032:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::ClearProjectError()
//000037: 			Catch e4 As BadImageFormatException
//000038: 			End Try
//000039: 			Return Nothing
//000040: 		End Function
//000041: 
//000042: 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000043: 		''' <returns>The Assembly instance for Microsoft.Ink.</returns>
//000044: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000045: 		Private Shared Function LoadInkAssemblyInternal() As System.Reflection.Assembly
//000046: 			Return GetType(InkOverlay).Assembly
//000047: 		End Function
//000048: 
//000049: 		''' <summary>Gets whether this platform supports using ink.</summary>
//000050: 		Public Shared ReadOnly Property SupportsInk() As Boolean
//000051: 			Get
//000052: 				Return InkAssemblyAvailable AndAlso RecognizerInstalled
//000053: 			End Get
//000054: 		End Property
//000055: 
//000056: 		''' <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000057: 		Public Shared ReadOnly Property InkAssemblyAvailable() As Boolean
//000058: 			Get
//000059: 				Return _inkAssemblyAvailable
//000060: 			End Get
//000061: 		End Property
//000062: 
//000063: 		''' <summary>Gets whether a valid recognizer is installed.</summary>
//000064: 		Public Shared ReadOnly Property RecognizerInstalled() As Boolean
//000065: 			Get
//000066: 				If Not _inkAssemblyAvailable Then
//000067: 					Return False
//000068: 				End If
//000069: 				Return GetDefaultRecognizer() IsNot Nothing
//000070: 			End Get
//000071: 		End Property
//000072: 
//000073: 		''' <summary>Gets the best recognizer for the current locale.</summary>
//000074: 		''' <returns>The best recognizer for the current locale.</returns>
//000075: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000076: 		Public Shared Function GetDefaultRecognizer() As Recognizer
//000077: 			Dim recognizer As Recognizer = Nothing
//000078: 			Try
//000079: 				Dim recognizers As New Recognizers()
//000080: 				If recognizers.Count > 1 Then
//000081:                     ' First try the current locale's recognizer.
//000082: 					Try
//000083: 						recognizer = recognizers.GetDefaultRecognizer()
//000084: 					Catch
//000085: 					End Try
//000086: 
//000087:                     ' Fallback to the en-US (1033) recognizer.
//000088: 					If recognizer Is Nothing Then
//000089: 						Try
//000090: 							recognizer = recognizers.GetDefaultRecognizer(1033)
//000091: 						Catch
//000092: 						End Try
//000093: 					End If
//000094: 				End If
//000095: 			Catch
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
      IL_0037:  leave.s    IL_0049

    }  // end handler
    catch [mscorlib]System.BadImageFormatException 
    {
      IL_0039:  dup
      IL_003a:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::SetProjectError(class [mscorlib]System.Exception)
      IL_003f:  stloc.s    e4
//000037: 			Catch e4 As BadImageFormatException
      IL_0041:  nop
      IL_0042:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::ClearProjectError()
//000038: 			End Try
//000039: 			Return Nothing
//000040: 		End Function
//000041: 
//000042: 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000043: 		''' <returns>The Assembly instance for Microsoft.Ink.</returns>
//000044: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000045: 		Private Shared Function LoadInkAssemblyInternal() As System.Reflection.Assembly
//000046: 			Return GetType(InkOverlay).Assembly
//000047: 		End Function
//000048: 
//000049: 		''' <summary>Gets whether this platform supports using ink.</summary>
//000050: 		Public Shared ReadOnly Property SupportsInk() As Boolean
//000051: 			Get
//000052: 				Return InkAssemblyAvailable AndAlso RecognizerInstalled
//000053: 			End Get
//000054: 		End Property
//000055: 
//000056: 		''' <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000057: 		Public Shared ReadOnly Property InkAssemblyAvailable() As Boolean
//000058: 			Get
//000059: 				Return _inkAssemblyAvailable
//000060: 			End Get
//000061: 		End Property
//000062: 
//000063: 		''' <summary>Gets whether a valid recognizer is installed.</summary>
//000064: 		Public Shared ReadOnly Property RecognizerInstalled() As Boolean
//000065: 			Get
//000066: 				If Not _inkAssemblyAvailable Then
//000067: 					Return False
//000068: 				End If
//000069: 				Return GetDefaultRecognizer() IsNot Nothing
//000070: 			End Get
//000071: 		End Property
//000072: 
//000073: 		''' <summary>Gets the best recognizer for the current locale.</summary>
//000074: 		''' <returns>The best recognizer for the current locale.</returns>
//000075: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000076: 		Public Shared Function GetDefaultRecognizer() As Recognizer
//000077: 			Dim recognizer As Recognizer = Nothing
//000078: 			Try
//000079: 				Dim recognizers As New Recognizers()
//000080: 				If recognizers.Count > 1 Then
//000081:                     ' First try the current locale's recognizer.
//000082: 					Try
//000083: 						recognizer = recognizers.GetDefaultRecognizer()
//000084: 					Catch
//000085: 					End Try
//000086: 
//000087:                     ' Fallback to the en-US (1033) recognizer.
//000088: 					If recognizer Is Nothing Then
//000089: 						Try
//000090: 							recognizer = recognizers.GetDefaultRecognizer(1033)
//000091: 						Catch
//000092: 						End Try
//000093: 					End If
//000094: 				End If
//000095: 			Catch
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
      IL_0047:  leave.s    IL_0049

//000038: 			End Try
    }  // end handler
    IL_0049:  nop
//000039: 			Return Nothing
    IL_004a:  ldnull
    IL_004b:  stloc.0
    IL_004c:  br.s       IL_004e

//000040: 		End Function
    IL_004e:  ldloc.0
    IL_004f:  ret
  } // end of method PlatformDetection::LoadInkAssembly

  .method private static class [mscorlib]System.Reflection.Assembly 
          LoadInkAssemblyInternal() cil managed noinlining
  {
    // Code size       21 (0x15)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Reflection.Assembly LoadInkAssemblyInternal)
//000041: 
//000042: 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
//000043: 		''' <returns>The Assembly instance for Microsoft.Ink.</returns>
//000044: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000045: 		Private Shared Function LoadInkAssemblyInternal() As System.Reflection.Assembly
    IL_0000:  nop
//000046: 			Return GetType(InkOverlay).Assembly
    IL_0001:  ldtoken    [Microsoft.Ink]Microsoft.Ink.InkOverlay
    IL_0006:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_000b:  callvirt   instance class [mscorlib]System.Reflection.Assembly [mscorlib]System.Type::get_Assembly()
    IL_0010:  stloc.0
    IL_0011:  br.s       IL_0013

//000047: 		End Function
    IL_0013:  ldloc.0
    IL_0014:  ret
  } // end of method PlatformDetection::LoadInkAssemblyInternal

  .method public specialname static bool 
          get_SupportsInk() cil managed
  {
    // Code size       24 (0x18)
    .maxstack  1
    .locals init ([0] bool SupportsInk)
//000048: 
//000049: 		''' <summary>Gets whether this platform supports using ink.</summary>
//000050: 		Public Shared ReadOnly Property SupportsInk() As Boolean
//000051: 			Get
    IL_0000:  nop
//000052: 				Return InkAssemblyAvailable AndAlso RecognizerInstalled
    IL_0001:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_InkAssemblyAvailable()
    IL_0006:  brfalse.s  IL_000f

    IL_0008:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_RecognizerInstalled()
    IL_000d:  brtrue.s   IL_0012

    IL_000f:  ldc.i4.0
    IL_0010:  br.s       IL_0013

    IL_0012:  ldc.i4.1
    IL_0013:  stloc.0
    IL_0014:  br.s       IL_0016

//000053: 			End Get
    IL_0016:  ldloc.0
    IL_0017:  ret
  } // end of method PlatformDetection::get_SupportsInk

  .method public specialname static bool 
          get_InkAssemblyAvailable() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] bool InkAssemblyAvailable)
//000054: 		End Property
//000055: 
//000056: 		''' <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
//000057: 		Public Shared ReadOnly Property InkAssemblyAvailable() As Boolean
//000058: 			Get
    IL_0000:  nop
//000059: 				Return _inkAssemblyAvailable
    IL_0001:  ldsfld     bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::_inkAssemblyAvailable
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000060: 			End Get
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method PlatformDetection::get_InkAssemblyAvailable

  .method public specialname static bool 
          get_RecognizerInstalled() cil managed
  {
    // Code size       34 (0x22)
    .maxstack  2
    .locals init ([0] bool RecognizerInstalled,
             [1] bool VB$CG$t_bool$S0)
//000061: 		End Property
//000062: 
//000063: 		''' <summary>Gets whether a valid recognizer is installed.</summary>
//000064: 		Public Shared ReadOnly Property RecognizerInstalled() As Boolean
//000065: 			Get
    IL_0000:  nop
//000066: 				If Not _inkAssemblyAvailable Then
    IL_0001:  ldsfld     bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::_inkAssemblyAvailable
    IL_0006:  ldc.i4.0
    IL_0007:  ceq
    IL_0009:  stloc.1
//000067: 					Return False
//000068: 				End If
//000069: 				Return GetDefaultRecognizer() IsNot Nothing
//000070: 			End Get
//000071: 		End Property
//000072: 
//000073: 		''' <summary>Gets the best recognizer for the current locale.</summary>
//000074: 		''' <returns>The best recognizer for the current locale.</returns>
//000075: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000076: 		Public Shared Function GetDefaultRecognizer() As Recognizer
//000077: 			Dim recognizer As Recognizer = Nothing
//000078: 			Try
//000079: 				Dim recognizers As New Recognizers()
//000080: 				If recognizers.Count > 1 Then
//000081:                     ' First try the current locale's recognizer.
//000082: 					Try
//000083: 						recognizer = recognizers.GetDefaultRecognizer()
//000084: 					Catch
//000085: 					End Try
//000086: 
//000087:                     ' Fallback to the en-US (1033) recognizer.
//000088: 					If recognizer Is Nothing Then
//000089: 						Try
//000090: 							recognizer = recognizers.GetDefaultRecognizer(1033)
//000091: 						Catch
//000092: 						End Try
//000093: 					End If
//000094: 				End If
//000095: 			Catch
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
    IL_000a:  ldloc.1
    IL_000b:  brfalse.s  IL_0011

//000067: 					Return False
    IL_000d:  ldc.i4.0
    IL_000e:  stloc.0
    IL_000f:  br.s       IL_0020

//000068: 				End If
    IL_0011:  nop
//000069: 				Return GetDefaultRecognizer() IsNot Nothing
    IL_0012:  call       class [Microsoft.Ink]Microsoft.Ink.Recognizer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::GetDefaultRecognizer()
    IL_0017:  ldnull
    IL_0018:  ceq
    IL_001a:  ldc.i4.0
    IL_001b:  ceq
    IL_001d:  stloc.0
    IL_001e:  br.s       IL_0020

//000070: 			End Get
    IL_0020:  ldloc.0
    IL_0021:  ret
  } // end of method PlatformDetection::get_RecognizerInstalled

  .method public static class [Microsoft.Ink]Microsoft.Ink.Recognizer 
          GetDefaultRecognizer() cil managed noinlining
  {
    // Code size       108 (0x6c)
    .maxstack  2
    .locals init ([0] class [Microsoft.Ink]Microsoft.Ink.Recognizer GetDefaultRecognizer,
             [1] class [Microsoft.Ink]Microsoft.Ink.Recognizer recognizer,
             [2] class [Microsoft.Ink]Microsoft.Ink.Recognizers recognizers,
             [3] bool VB$CG$t_bool$S0)
//000071: 		End Property
//000072: 
//000073: 		''' <summary>Gets the best recognizer for the current locale.</summary>
//000074: 		''' <returns>The best recognizer for the current locale.</returns>
//000075: 		<MethodImpl(MethodImplOptions.NoInlining)>
//000076: 		Public Shared Function GetDefaultRecognizer() As Recognizer
    IL_0000:  nop
//000077: 			Dim recognizer As Recognizer = Nothing
    IL_0001:  ldnull
    IL_0002:  stloc.1
//000078: 			Try
    IL_0003:  nop
//000079: 				Dim recognizers As New Recognizers()
    .try
    {
      IL_0004:  newobj     instance void [Microsoft.Ink]Microsoft.Ink.Recognizers::.ctor()
      IL_0009:  stloc.2
//000080: 				If recognizers.Count > 1 Then
      IL_000a:  ldloc.2
      IL_000b:  callvirt   instance int32 [Microsoft.Ink]Microsoft.Ink.Recognizers::get_Count()
      IL_0010:  ldc.i4.1
      IL_0011:  cgt
      IL_0013:  stloc.3
//000081:                     ' First try the current locale's recognizer.
//000082: 					Try
//000083: 						recognizer = recognizers.GetDefaultRecognizer()
//000084: 					Catch
//000085: 					End Try
//000086: 
//000087:                     ' Fallback to the en-US (1033) recognizer.
//000088: 					If recognizer Is Nothing Then
//000089: 						Try
//000090: 							recognizer = recognizers.GetDefaultRecognizer(1033)
//000091: 						Catch
//000092: 						End Try
//000093: 					End If
//000094: 				End If
//000095: 			Catch
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
      IL_0014:  ldloc.3
      IL_0015:  brfalse.s  IL_0055

//000082: 					Try
      IL_0017:  nop
//000083: 						recognizer = recognizers.GetDefaultRecognizer()
      .try
      {
        IL_0018:  ldloc.2
        IL_0019:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Recognizer [Microsoft.Ink]Microsoft.Ink.Recognizers::GetDefaultRecognizer()
        IL_001e:  stloc.1
//000084: 					Catch
//000085: 					End Try
//000086: 
//000087:                     ' Fallback to the en-US (1033) recognizer.
//000088: 					If recognizer Is Nothing Then
//000089: 						Try
//000090: 							recognizer = recognizers.GetDefaultRecognizer(1033)
//000091: 						Catch
//000092: 						End Try
//000093: 					End If
//000094: 				End If
//000095: 			Catch
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
        IL_001f:  leave.s    IL_002e

      }  // end .try
      catch [mscorlib]System.Exception 
      {
        IL_0021:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::SetProjectError(class [mscorlib]System.Exception)
//000084: 					Catch
        IL_0026:  nop
        IL_0027:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::ClearProjectError()
//000085: 					End Try
//000086: 
//000087:                     ' Fallback to the en-US (1033) recognizer.
//000088: 					If recognizer Is Nothing Then
//000089: 						Try
//000090: 							recognizer = recognizers.GetDefaultRecognizer(1033)
//000091: 						Catch
//000092: 						End Try
//000093: 					End If
//000094: 				End If
//000095: 			Catch
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
        IL_002c:  leave.s    IL_002e

//000085: 					End Try
      }  // end handler
      IL_002e:  nop
//000086: 
//000087:                     ' Fallback to the en-US (1033) recognizer.
//000088: 					If recognizer Is Nothing Then
      IL_002f:  ldloc.1
      IL_0030:  ldnull
      IL_0031:  ceq
      IL_0033:  stloc.3
//000089: 						Try
//000090: 							recognizer = recognizers.GetDefaultRecognizer(1033)
//000091: 						Catch
//000092: 						End Try
//000093: 					End If
//000094: 				End If
//000095: 			Catch
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
      IL_0034:  ldloc.3
      IL_0035:  brfalse.s  IL_0054

//000089: 						Try
      IL_0037:  nop
//000090: 							recognizer = recognizers.GetDefaultRecognizer(1033)
      .try
      {
        IL_0038:  ldloc.2
        IL_0039:  ldc.i4     0x409
        IL_003e:  callvirt   instance class [Microsoft.Ink]Microsoft.Ink.Recognizer [Microsoft.Ink]Microsoft.Ink.Recognizers::GetDefaultRecognizer(int32)
        IL_0043:  stloc.1
//000091: 						Catch
//000092: 						End Try
//000093: 					End If
//000094: 				End If
//000095: 			Catch
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
        IL_0044:  leave.s    IL_0053

      }  // end .try
      catch [mscorlib]System.Exception 
      {
        IL_0046:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::SetProjectError(class [mscorlib]System.Exception)
//000091: 						Catch
        IL_004b:  nop
        IL_004c:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::ClearProjectError()
//000092: 						End Try
//000093: 					End If
//000094: 				End If
//000095: 			Catch
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
        IL_0051:  leave.s    IL_0053

//000092: 						End Try
      }  // end handler
      IL_0053:  nop
//000093: 					End If
      IL_0054:  nop
//000094: 				End If
      IL_0055:  nop
//000095: 			Catch
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
      IL_0056:  leave.s    IL_0065

    }  // end .try
    catch [mscorlib]System.Exception 
    {
      IL_0058:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::SetProjectError(class [mscorlib]System.Exception)
//000095: 			Catch
      IL_005d:  nop
      IL_005e:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::ClearProjectError()
//000096: 			End Try
//000097: 			Return recognizer
//000098: 		End Function
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
//000104: 			End Get
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
//000112: 				Try
//000113: 					Dim recognizers As New Recognizers()
//000114: 					If recognizers.Count > 0 Then
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
      IL_0063:  leave.s    IL_0065

//000096: 			End Try
    }  // end handler
    IL_0065:  nop
//000097: 			Return recognizer
    IL_0066:  ldloc.1
    IL_0067:  stloc.0
    IL_0068:  br.s       IL_006a

//000098: 		End Function
    IL_006a:  ldloc.0
    IL_006b:  ret
  } // end of method PlatformDetection::GetDefaultRecognizer

  .method public specialname static bool 
          get_GestureRecognizerInstalled() cil managed
  {
    // Code size       24 (0x18)
    .maxstack  1
    .locals init ([0] bool GestureRecognizerInstalled)
//000099: 
//000100: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000101: 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
//000102: 			Get
    IL_0000:  nop
//000103: 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
    IL_0001:  ldsfld     bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::_inkAssemblyAvailable
    IL_0006:  brfalse.s  IL_000f

    IL_0008:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_GestureRecognizerInstalledInternal()
    IL_000d:  brtrue.s   IL_0012

    IL_000f:  ldc.i4.0
    IL_0010:  br.s       IL_0013

    IL_0012:  ldc.i4.1
    IL_0013:  stloc.0
    IL_0014:  br.s       IL_0016

//000104: 			End Get
    IL_0016:  ldloc.0
    IL_0017:  ret
  } // end of method PlatformDetection::get_GestureRecognizerInstalled

  .method private specialname static bool 
          get_GestureRecognizerInstalledInternal() cil managed noinlining
  {
    // Code size       79 (0x4f)
    .maxstack  2
    .locals init ([0] bool GestureRecognizerInstalledInternal,
             [1] class [Microsoft.Ink]Microsoft.Ink.Recognizers recognizers,
             [2] class [Microsoft.Ink]Microsoft.StylusInput.GestureRecognizer TempGestureRecognizer,
             [3] bool VB$CG$t_bool$S0)
//000105: 		End Property
//000106: 
//000107: 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
//000108: 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
//000109: 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
//000110: 			<MethodImpl(MethodImplOptions.NoInlining)>
//000111: 			Get
    IL_0000:  nop
//000112: 				Try
    IL_0001:  nop
//000113: 					Dim recognizers As New Recognizers()
    .try
    {
      IL_0002:  newobj     instance void [Microsoft.Ink]Microsoft.Ink.Recognizers::.ctor()
      IL_0007:  stloc.1
//000114: 					If recognizers.Count > 0 Then
      IL_0008:  ldloc.1
      IL_0009:  callvirt   instance int32 [Microsoft.Ink]Microsoft.Ink.Recognizers::get_Count()
      IL_000e:  ldc.i4.0
      IL_000f:  cgt
      IL_0011:  stloc.3
//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
      IL_0012:  ldloc.3
      IL_0013:  brfalse.s  IL_0038

//000115:                         Using TempGestureRecognizer = New GestureRecognizer()
      IL_0015:  nop
      IL_0016:  newobj     instance void [Microsoft.Ink]Microsoft.StylusInput.GestureRecognizer::.ctor()
      IL_001b:  stloc.2
//000116:                             Return True
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
      IL_001c:  nop
//000116:                             Return True
      .try
      {
        IL_001d:  ldc.i4.1
        IL_001e:  stloc.0
//000117:                         End Using
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
        IL_001f:  leave.s    IL_004d

//000117:                         End Using
        IL_0021:  nop
//000118: 					End If
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
        IL_0022:  leave.s    IL_0038

      }  // end .try
      finally
      {
        IL_0024:  ldloc.2
        IL_0025:  ldnull
        IL_0026:  ceq
        IL_0028:  ldc.i4.0
        IL_0029:  ceq
        IL_002b:  stloc.3
        IL_002c:  ldloc.3
        IL_002d:  brfalse.s  IL_0036

        IL_002f:  ldloc.2
        IL_0030:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_0035:  nop
        IL_0036:  nop
        IL_0037:  endfinally
//000118: 					End If
      }  // end handler
      IL_0038:  nop
//000119: 				Catch
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
      IL_0039:  leave.s    IL_0048

    }  // end .try
    catch [mscorlib]System.Exception 
    {
      IL_003b:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::SetProjectError(class [mscorlib]System.Exception)
//000119: 				Catch
      IL_0040:  nop
      IL_0041:  call       void [Microsoft.VisualBasic]Microsoft.VisualBasic.CompilerServices.ProjectData::ClearProjectError()
//000120: 				End Try
//000121: 				Return False
//000122: 			End Get
//000123: 		End Property
//000124: 	End Class
//000125: End Namespace
      IL_0046:  leave.s    IL_0048

//000120: 				End Try
    }  // end handler
    IL_0048:  nop
//000121: 				Return False
    IL_0049:  ldc.i4.0
    IL_004a:  stloc.0
    IL_004b:  br.s       IL_004d

//000122: 			End Get
    IL_004d:  ldloc.0
    IL_004e:  ret
  } // end of method PlatformDetection::get_GestureRecognizerInstalledInternal

  .property bool SupportsInk()
  {
    .get bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_SupportsInk()
  } // end of property PlatformDetection::SupportsInk
  .property bool InkAssemblyAvailable()
  {
    .get bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_InkAssemblyAvailable()
  } // end of property PlatformDetection::InkAssemblyAvailable
  .property bool RecognizerInstalled()
  {
    .get bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_RecognizerInstalled()
  } // end of property PlatformDetection::RecognizerInstalled
  .property bool GestureRecognizerInstalled()
  {
    .get bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_GestureRecognizerInstalled()
  } // end of property PlatformDetection::GestureRecognizerInstalled
  .property bool GestureRecognizerInstalledInternal()
  {
    .get bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection::get_GestureRecognizerInstalledInternal()
  } // end of property PlatformDetection::GestureRecognizerInstalledInternal
} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.PlatformDetection

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar
       extends [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost
{
  .custom instance void [System]System.ComponentModel.DesignerCategoryAttribute::.ctor(string) = ( 01 00 04 63 6F 64 65 00 00 )                      // ...code..
  .custom instance void [System.Windows.Forms]System.Windows.Forms.Design.ToolStripItemDesignerAvailabilityAttribute::.ctor(valuetype [System.Windows.Forms]System.Windows.Forms.Design.ToolStripItemDesignerAvailability) = ( 01 00 09 00 00 00 00 00 ) 
  .field private static class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> __ENCList
  .field private class [mscorlib]System.EventHandler ValueChangedEvent
  .method private specialname rtspecialname static 
          void  .cctor() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       12 (0xc)
    .maxstack  8
    IL_0000:  newobj     instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::.ctor()
    IL_0005:  stsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::__ENCList
    IL_000a:  nop
    IL_000b:  ret
  } // end of method ToolStripTrackBar::.cctor

  .method private static void  __ENCAddToList(object 'value') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       243 (0xf3)
    .maxstack  4
    .locals init (int32 V_0,
             int32 V_1,
             class [mscorlib]System.WeakReference V_2,
             class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> V_3,
             bool V_4,
             int32 V_5,
             bool V_6,
             bool V_7,
             int32 V_8)
    IL_0000:  nop
    IL_0001:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::__ENCList
    IL_0006:  stloc.3
    IL_0007:  ldc.i4.0
    IL_0008:  stloc.s    V_4
    IL_000a:  nop
    .try
    {
      IL_000b:  ldloc.3
      IL_000c:  ldloca.s   V_4
      IL_000e:  call       void [mscorlib]System.Threading.Monitor::Enter(object,
                                                                          bool&)
      IL_0013:  nop
      IL_0014:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::__ENCList
      IL_0019:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Count()
      IL_001e:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::__ENCList
      IL_0023:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Capacity()
      IL_0028:  ceq
      IL_002a:  stloc.s    V_6
      IL_002c:  ldloc.s    V_6
      IL_002e:  brfalse    IL_00c4

      IL_0033:  ldc.i4.0
      IL_0034:  stloc.0
      IL_0035:  ldc.i4.0
      IL_0036:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::__ENCList
      IL_003b:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Count()
      IL_0040:  ldc.i4.1
      IL_0041:  sub.ovf
      IL_0042:  stloc.s    V_5
      IL_0044:  stloc.1
      IL_0045:  br.s       IL_008e

      IL_0047:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::__ENCList
      IL_004c:  ldloc.1
      IL_004d:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Item(int32)
      IL_0052:  stloc.2
      IL_0053:  ldloc.2
      IL_0054:  callvirt   instance bool [mscorlib]System.WeakReference::get_IsAlive()
      IL_0059:  stloc.s    V_6
      IL_005b:  ldloc.s    V_6
      IL_005d:  brfalse.s  IL_0088

      IL_005f:  ldloc.1
      IL_0060:  ldloc.0
      IL_0061:  ceq
      IL_0063:  ldc.i4.0
      IL_0064:  ceq
      IL_0066:  stloc.s    V_7
      IL_0068:  ldloc.s    V_7
      IL_006a:  brfalse.s  IL_0083

      IL_006c:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::__ENCList
      IL_0071:  ldloc.0
      IL_0072:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::__ENCList
      IL_0077:  ldloc.1
      IL_0078:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Item(int32)
      IL_007d:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::set_Item(int32,
                                                                                                                                           !0)
      IL_0082:  nop
      IL_0083:  nop
      IL_0084:  ldloc.0
      IL_0085:  ldc.i4.1
      IL_0086:  add.ovf
      IL_0087:  stloc.0
      IL_0088:  nop
      IL_0089:  nop
      IL_008a:  ldloc.1
      IL_008b:  ldc.i4.1
      IL_008c:  add.ovf
      IL_008d:  stloc.1
      IL_008e:  ldloc.1
      IL_008f:  ldloc.s    V_5
      IL_0091:  stloc.s    V_8
      IL_0093:  ldloc.s    V_8
      IL_0095:  ble.s      IL_0047

      IL_0097:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::__ENCList
      IL_009c:  ldloc.0
      IL_009d:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::__ENCList
      IL_00a2:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Count()
      IL_00a7:  ldloc.0
      IL_00a8:  sub.ovf
      IL_00a9:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::RemoveRange(int32,
                                                                                                                                              int32)
      IL_00ae:  nop
      IL_00af:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::__ENCList
      IL_00b4:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::__ENCList
      IL_00b9:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::get_Count()
      IL_00be:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::set_Capacity(int32)
      IL_00c3:  nop
      IL_00c4:  nop
      IL_00c5:  ldsfld     class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::__ENCList
      IL_00ca:  ldarg.0
      IL_00cb:  call       object [mscorlib]System.Runtime.CompilerServices.RuntimeHelpers::GetObjectValue(object)
      IL_00d0:  newobj     instance void [mscorlib]System.WeakReference::.ctor(object)
      IL_00d5:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.WeakReference>::Add(!0)
      IL_00da:  nop
      IL_00db:  nop
      IL_00dc:  leave.s    IL_00f0

    }  // end .try
    finally
    {
      IL_00de:  nop
      IL_00df:  ldloc.s    V_4
      IL_00e1:  stloc.s    V_7
      IL_00e3:  ldloc.s    V_7
      IL_00e5:  brfalse.s  IL_00ee

      IL_00e7:  ldloc.3
      IL_00e8:  call       void [mscorlib]System.Threading.Monitor::Exit(object)
      IL_00ed:  nop
      IL_00ee:  nop
      IL_00ef:  endfinally
    }  // end handler
    IL_00f0:  nop
    IL_00f1:  nop
    IL_00f2:  ret
  } // end of method ToolStripTrackBar::__ENCAddToList

  .method public specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       22 (0x16)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb' 
//000019:         Public Sub New()
    IL_0000:  nop
//000020:             MyBase.New(CreateControlInstance())
    IL_0001:  ldarg.0
    IL_0002:  call       class [System.Windows.Forms]System.Windows.Forms.Control Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::CreateControlInstance()
    IL_0007:  call       instance void [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost::.ctor(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_000c:  nop
//000021:         End Sub
//000022: 
//000023:         ''' <summary>Gets the actual TrackBar instance.</summary>
//000024:         Public ReadOnly Property TrackBar() As TrackBar
//000025:             Get
//000026:                 Return TryCast(Control, TrackBar)
//000027:             End Get
//000028:         End Property
//000029: 
//000030:         ''' <summary>Create the actual TrackBar control.</summary>
//000031:         Private Shared Function CreateControlInstance() As Control
//000032:             Dim t As New TrackBar()
//000033:             t.AutoSize = False
//000034:             t.Height = 16
//000035:             t.TickStyle = TickStyle.None
//000036:             t.Minimum = 0
//000037:             t.Maximum = 100
//000038:             t.Value = 0
//000039:             Return t
//000040:         End Function
//000041: 
//000042:         ''' <summary>Gets the current TrackBar value.</summary>
//000043:         <DefaultValue(0)>
//000044:         Public Property Value() As Integer
//000045:             Get
//000046:                 Return TrackBar.Value
//000047:             End Get
//000048:             Set(ByVal value As Integer)
//000049:                 TrackBar.Value = value
//000050:             End Set
//000051:         End Property
//000052: 
//000053:         ''' <summary>Gets the minimum TrackBar value.</summary>
//000054:         <DefaultValue(0)>
//000055:         Public Property Minimum() As Integer
//000056:             Get
//000057:                 Return TrackBar.Minimum
//000058:             End Get
//000059:             Set(ByVal value As Integer)
//000060:                 TrackBar.Minimum = value
//000061:             End Set
//000062:         End Property
//000063: 
//000064:         ''' <summary>Gets the maximum TrackBar value.</summary>
//000065:         <DefaultValue(100)>
//000066:         Public Property Maximum() As Integer
//000067:             Get
//000068:                 Return TrackBar.Maximum
//000069:             End Get
//000070:             Set(ByVal value As Integer)
//000071:                 TrackBar.Maximum = value
//000072:             End Set
//000073:         End Property
//000074: 
//000075:         ''' <summary>Attach to events that need to be wrapped.</summary>
//000076:         Protected Overrides Sub OnSubscribeControlEvents(ByVal control As Control)
//000077:             MyBase.OnSubscribeControlEvents(control)
//000078:             AddHandler (CType(control, TrackBar)).ValueChanged, AddressOf trackBar_ValueChanged
//000079:         End Sub
//000080: 
//000081:         ''' <summary>Detach from events that were wrapped.</summary>
//000082:         Protected Overrides Sub OnUnsubscribeControlEvents(ByVal control As Control)
//000083:             MyBase.OnUnsubscribeControlEvents(control)
//000084:             RemoveHandler (CType(control, TrackBar)).ValueChanged, AddressOf trackBar_ValueChanged
//000085:         End Sub
//000086: 
//000087:         ''' <summary>Raise the ValueChanged event.</summary>
//000088:         Private Sub trackBar_ValueChanged(ByVal sender As Object, ByVal e As EventArgs)
//000089:             RaiseEvent ValueChanged(sender, e)
//000090:         End Sub
//000091: 
//000092:         ''' <summary>Event used to notify when the TrackBar's value changes.</summary>
//000093:         Public Event ValueChanged As EventHandler
//000094: 
//000095:         ''' <summary>Gets the default size for the control.</summary>
//000096:         Protected Overrides ReadOnly Property DefaultSize() As Size
//000097:             Get
//000098:                 Return New Size(200, 16)
//000099:             End Get
//000100:         End Property
//000101:     End Class
//000102: End Namespace
    IL_000d:  ldarg.0
    IL_000e:  call       void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::__ENCAddToList(object)
    IL_0013:  nop
//000021:         End Sub
    IL_0014:  nop
    IL_0015:  ret
  } // end of method ToolStripTrackBar::.ctor

  .method public specialname instance class [System.Windows.Forms]System.Windows.Forms.TrackBar 
          get_TrackBar() cil managed
  {
    // Code size       17 (0x11)
    .maxstack  1
    .locals init ([0] class [System.Windows.Forms]System.Windows.Forms.TrackBar TrackBar)
//000022: 
//000023:         ''' <summary>Gets the actual TrackBar instance.</summary>
//000024:         Public ReadOnly Property TrackBar() As TrackBar
//000025:             Get
    IL_0000:  nop
//000026:                 Return TryCast(Control, TrackBar)
    IL_0001:  ldarg.0
    IL_0002:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Control [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost::get_Control()
    IL_0007:  isinst     [System.Windows.Forms]System.Windows.Forms.TrackBar
    IL_000c:  stloc.0
    IL_000d:  br.s       IL_000f

//000027:             End Get
    IL_000f:  ldloc.0
    IL_0010:  ret
  } // end of method ToolStripTrackBar::get_TrackBar

  .method private static class [System.Windows.Forms]System.Windows.Forms.Control 
          CreateControlInstance() cil managed
  {
    // Code size       63 (0x3f)
    .maxstack  2
    .locals init ([0] class [System.Windows.Forms]System.Windows.Forms.Control CreateControlInstance,
             [1] class [System.Windows.Forms]System.Windows.Forms.TrackBar t)
//000028:         End Property
//000029: 
//000030:         ''' <summary>Create the actual TrackBar control.</summary>
//000031:         Private Shared Function CreateControlInstance() As Control
    IL_0000:  nop
//000032:             Dim t As New TrackBar()
    IL_0001:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::.ctor()
    IL_0006:  stloc.1
//000033:             t.AutoSize = False
    IL_0007:  ldloc.1
    IL_0008:  ldc.i4.0
    IL_0009:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_AutoSize(bool)
    IL_000e:  nop
//000034:             t.Height = 16
    IL_000f:  ldloc.1
    IL_0010:  ldc.i4.s   16
    IL_0012:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Height(int32)
    IL_0017:  nop
//000035:             t.TickStyle = TickStyle.None
    IL_0018:  ldloc.1
    IL_0019:  ldc.i4.0
    IL_001a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_TickStyle(valuetype [System.Windows.Forms]System.Windows.Forms.TickStyle)
    IL_001f:  nop
//000036:             t.Minimum = 0
    IL_0020:  ldloc.1
    IL_0021:  ldc.i4.0
    IL_0022:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Minimum(int32)
    IL_0027:  nop
//000037:             t.Maximum = 100
    IL_0028:  ldloc.1
    IL_0029:  ldc.i4.s   100
    IL_002b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Maximum(int32)
    IL_0030:  nop
//000038:             t.Value = 0
    IL_0031:  ldloc.1
    IL_0032:  ldc.i4.0
    IL_0033:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Value(int32)
    IL_0038:  nop
//000039:             Return t
    IL_0039:  ldloc.1
    IL_003a:  stloc.0
    IL_003b:  br.s       IL_003d

//000040:         End Function
    IL_003d:  ldloc.0
    IL_003e:  ret
  } // end of method ToolStripTrackBar::CreateControlInstance

  .method public specialname instance int32 
          get_Value() cil managed
  {
    // Code size       17 (0x11)
    .maxstack  1
    .locals init ([0] int32 Value)
//000041: 
//000042:         ''' <summary>Gets the current TrackBar value.</summary>
//000043:         <DefaultValue(0)>
//000044:         Public Property Value() As Integer
//000045:             Get
    IL_0000:  nop
//000046:                 Return TrackBar.Value
    IL_0001:  ldarg.0
    IL_0002:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_TrackBar()
    IL_0007:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Value()
    IL_000c:  stloc.0
    IL_000d:  br.s       IL_000f

//000047:             End Get
    IL_000f:  ldloc.0
    IL_0010:  ret
  } // end of method ToolStripTrackBar::get_Value

  .method public specialname instance void 
          set_Value(int32 'value') cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
//000048:             Set(ByVal value As Integer)
    IL_0000:  nop
//000049:                 TrackBar.Value = value
    IL_0001:  ldarg.0
    IL_0002:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_TrackBar()
    IL_0007:  ldarg.1
    IL_0008:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Value(int32)
    IL_000d:  nop
//000050:             End Set
    IL_000e:  nop
    IL_000f:  ret
  } // end of method ToolStripTrackBar::set_Value

  .method public specialname instance int32 
          get_Minimum() cil managed
  {
    // Code size       17 (0x11)
    .maxstack  1
    .locals init ([0] int32 Minimum)
//000051:         End Property
//000052: 
//000053:         ''' <summary>Gets the minimum TrackBar value.</summary>
//000054:         <DefaultValue(0)>
//000055:         Public Property Minimum() As Integer
//000056:             Get
    IL_0000:  nop
//000057:                 Return TrackBar.Minimum
    IL_0001:  ldarg.0
    IL_0002:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_TrackBar()
    IL_0007:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Minimum()
    IL_000c:  stloc.0
    IL_000d:  br.s       IL_000f

//000058:             End Get
    IL_000f:  ldloc.0
    IL_0010:  ret
  } // end of method ToolStripTrackBar::get_Minimum

  .method public specialname instance void 
          set_Minimum(int32 'value') cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
//000059:             Set(ByVal value As Integer)
    IL_0000:  nop
//000060:                 TrackBar.Minimum = value
    IL_0001:  ldarg.0
    IL_0002:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_TrackBar()
    IL_0007:  ldarg.1
    IL_0008:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Minimum(int32)
    IL_000d:  nop
//000061:             End Set
    IL_000e:  nop
    IL_000f:  ret
  } // end of method ToolStripTrackBar::set_Minimum

  .method public specialname instance int32 
          get_Maximum() cil managed
  {
    // Code size       17 (0x11)
    .maxstack  1
    .locals init ([0] int32 Maximum)
//000062:         End Property
//000063: 
//000064:         ''' <summary>Gets the maximum TrackBar value.</summary>
//000065:         <DefaultValue(100)>
//000066:         Public Property Maximum() As Integer
//000067:             Get
    IL_0000:  nop
//000068:                 Return TrackBar.Maximum
    IL_0001:  ldarg.0
    IL_0002:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_TrackBar()
    IL_0007:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Maximum()
    IL_000c:  stloc.0
    IL_000d:  br.s       IL_000f

//000069:             End Get
    IL_000f:  ldloc.0
    IL_0010:  ret
  } // end of method ToolStripTrackBar::get_Maximum

  .method public specialname instance void 
          set_Maximum(int32 'value') cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
//000070:             Set(ByVal value As Integer)
    IL_0000:  nop
//000071:                 TrackBar.Maximum = value
    IL_0001:  ldarg.0
    IL_0002:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_TrackBar()
    IL_0007:  ldarg.1
    IL_0008:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Maximum(int32)
    IL_000d:  nop
//000072:             End Set
    IL_000e:  nop
    IL_000f:  ret
  } // end of method ToolStripTrackBar::set_Maximum

  .method family strict virtual instance void 
          OnSubscribeControlEvents(class [System.Windows.Forms]System.Windows.Forms.Control control) cil managed
  {
    // Code size       36 (0x24)
    .maxstack  8
//000073:         End Property
//000074: 
//000075:         ''' <summary>Attach to events that need to be wrapped.</summary>
//000076:         Protected Overrides Sub OnSubscribeControlEvents(ByVal control As Control)
    IL_0000:  nop
//000077:             MyBase.OnSubscribeControlEvents(control)
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  call       instance void [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost::OnSubscribeControlEvents(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0008:  nop
//000078:             AddHandler (CType(control, TrackBar)).ValueChanged, AddressOf trackBar_ValueChanged
    IL_0009:  ldarg.1
    IL_000a:  castclass  [System.Windows.Forms]System.Windows.Forms.TrackBar
    IL_000f:  ldarg.0
    IL_0010:  dup
    IL_0011:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::trackBar_ValueChanged(object,
                                                                                                                                               class [mscorlib]System.EventArgs)
    IL_0017:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_001c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::add_ValueChanged(class [mscorlib]System.EventHandler)
    IL_0021:  nop
//000079:         End Sub
    IL_0022:  nop
    IL_0023:  ret
  } // end of method ToolStripTrackBar::OnSubscribeControlEvents

  .method family strict virtual instance void 
          OnUnsubscribeControlEvents(class [System.Windows.Forms]System.Windows.Forms.Control control) cil managed
  {
    // Code size       36 (0x24)
    .maxstack  8
//000080: 
//000081:         ''' <summary>Detach from events that were wrapped.</summary>
//000082:         Protected Overrides Sub OnUnsubscribeControlEvents(ByVal control As Control)
    IL_0000:  nop
//000083:             MyBase.OnUnsubscribeControlEvents(control)
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  call       instance void [System.Windows.Forms]System.Windows.Forms.ToolStripControlHost::OnUnsubscribeControlEvents(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0008:  nop
//000084:             RemoveHandler (CType(control, TrackBar)).ValueChanged, AddressOf trackBar_ValueChanged
    IL_0009:  ldarg.1
    IL_000a:  castclass  [System.Windows.Forms]System.Windows.Forms.TrackBar
    IL_000f:  ldarg.0
    IL_0010:  dup
    IL_0011:  ldvirtftn  instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::trackBar_ValueChanged(object,
                                                                                                                                               class [mscorlib]System.EventArgs)
    IL_0017:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_001c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::remove_ValueChanged(class [mscorlib]System.EventHandler)
    IL_0021:  nop
//000085:         End Sub
    IL_0022:  nop
    IL_0023:  ret
  } // end of method ToolStripTrackBar::OnUnsubscribeControlEvents

  .method private instance void  trackBar_ValueChanged(object sender,
                                                       class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       35 (0x23)
    .maxstack  3
    .locals init ([0] class [mscorlib]System.EventHandler VB$t_ref$S0,
             [1] bool VB$CG$t_bool$S0)
//000086: 
//000087:         ''' <summary>Raise the ValueChanged event.</summary>
//000088:         Private Sub trackBar_ValueChanged(ByVal sender As Object, ByVal e As EventArgs)
    IL_0000:  nop
//000089:             RaiseEvent ValueChanged(sender, e)
//000090:         End Sub
//000091: 
//000092:         ''' <summary>Event used to notify when the TrackBar's value changes.</summary>
//000093:         Public Event ValueChanged As EventHandler
//000094: 
//000095:         ''' <summary>Gets the default size for the control.</summary>
//000096:         Protected Overrides ReadOnly Property DefaultSize() As Size
//000097:             Get
//000098:                 Return New Size(200, 16)
//000099:             End Get
//000100:         End Property
//000101:     End Class
//000102: End Namespace
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [mscorlib]System.EventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::ValueChangedEvent
    IL_0007:  stloc.0
//000089:             RaiseEvent ValueChanged(sender, e)
    IL_0008:  ldloc.0
    IL_0009:  ldnull
    IL_000a:  ceq
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  stloc.1
    IL_0010:  ldloc.1
    IL_0011:  brfalse.s  IL_0021

    IL_0013:  ldloc.0
    IL_0014:  ldarg.1
    IL_0015:  call       object [mscorlib]System.Runtime.CompilerServices.RuntimeHelpers::GetObjectValue(object)
    IL_001a:  ldarg.2
    IL_001b:  callvirt   instance void [mscorlib]System.EventHandler::Invoke(object,
                                                                             class [mscorlib]System.EventArgs)
    IL_0020:  nop
//000090:         End Sub
    IL_0021:  nop
    IL_0022:  ret
  } // end of method ToolStripTrackBar::trackBar_ValueChanged

  .method public specialname instance void 
          add_ValueChanged(class [mscorlib]System.EventHandler obj) cil managed synchronized
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       25 (0x19)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [mscorlib]System.EventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::ValueChangedEvent
    IL_0007:  ldarg.1
    IL_0008:  call       class [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(class [mscorlib]System.Delegate,
                                                                                            class [mscorlib]System.Delegate)
    IL_000d:  castclass  [mscorlib]System.EventHandler
    IL_0012:  stfld      class [mscorlib]System.EventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::ValueChangedEvent
    IL_0017:  nop
    IL_0018:  ret
  } // end of method ToolStripTrackBar::add_ValueChanged

  .method public specialname instance void 
          remove_ValueChanged(class [mscorlib]System.EventHandler obj) cil managed synchronized
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       25 (0x19)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [mscorlib]System.EventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::ValueChangedEvent
    IL_0007:  ldarg.1
    IL_0008:  call       class [mscorlib]System.Delegate [mscorlib]System.Delegate::Remove(class [mscorlib]System.Delegate,
                                                                                           class [mscorlib]System.Delegate)
    IL_000d:  castclass  [mscorlib]System.EventHandler
    IL_0012:  stfld      class [mscorlib]System.EventHandler Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::ValueChangedEvent
    IL_0017:  nop
    IL_0018:  ret
  } // end of method ToolStripTrackBar::remove_ValueChanged

  .method family specialname strict virtual 
          instance valuetype [System.Drawing]System.Drawing.Size 
          get_DefaultSize() cil managed
  {
    // Code size       22 (0x16)
    .maxstack  3
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Size DefaultSize,
             [1] valuetype [System.Drawing]System.Drawing.Size VB$t_struct$S0)
//000091: 
//000092:         ''' <summary>Event used to notify when the TrackBar's value changes.</summary>
//000093:         Public Event ValueChanged As EventHandler
//000094: 
//000095:         ''' <summary>Gets the default size for the control.</summary>
//000096:         Protected Overrides ReadOnly Property DefaultSize() As Size
//000097:             Get
    IL_0000:  nop
//000098:                 Return New Size(200, 16)
    IL_0001:  ldloca.s   VB$t_struct$S0
    IL_0003:  ldc.i4     0xc8
    IL_0008:  ldc.i4.s   16
    IL_000a:  call       instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_000f:  nop
    IL_0010:  ldloc.1
    IL_0011:  stloc.0
    IL_0012:  br.s       IL_0014

//000099:             End Get
    IL_0014:  ldloc.0
    IL_0015:  ret
  } // end of method ToolStripTrackBar::get_DefaultSize

  .event [mscorlib]System.EventHandler ValueChanged
  {
    .addon instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::add_ValueChanged(class [mscorlib]System.EventHandler)
    .removeon instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::remove_ValueChanged(class [mscorlib]System.EventHandler)
  } // end of event ToolStripTrackBar::ValueChanged
  .property instance class [System.Windows.Forms]System.Windows.Forms.TrackBar
          TrackBar()
  {
    .get instance class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_TrackBar()
  } // end of property ToolStripTrackBar::TrackBar
  .property instance int32 Value()
  {
    .custom instance void [System]System.ComponentModel.DefaultValueAttribute::.ctor(int32) = ( 01 00 00 00 00 00 00 00 ) 
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::set_Value(int32)
    .get instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_Value()
  } // end of property ToolStripTrackBar::Value
  .property instance int32 Minimum()
  {
    .custom instance void [System]System.ComponentModel.DefaultValueAttribute::.ctor(int32) = ( 01 00 00 00 00 00 00 00 ) 
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::set_Minimum(int32)
    .get instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_Minimum()
  } // end of property ToolStripTrackBar::Minimum
  .property instance int32 Maximum()
  {
    .custom instance void [System]System.ComponentModel.DefaultValueAttribute::.ctor(int32) = ( 01 00 64 00 00 00 00 00 )                         // ..d.....
    .set instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::set_Maximum(int32)
    .get instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_Maximum()
  } // end of property ToolStripTrackBar::Maximum
  .property instance valuetype [System.Drawing]System.Drawing.Size
          DefaultSize()
  {
    .get instance valuetype [System.Drawing]System.Drawing.Size Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar::get_DefaultSize()
  } // end of property ToolStripTrackBar::DefaultSize
} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar

.class private auto ansi sealed VB$AnonymousDelegate_3
       extends [mscorlib]System.MulticastDelegate
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerDisplayAttribute::.ctor(string) = ( 01 00 12 3C 67 65 6E 65 72 61 74 65 64 20 6D 65   // ...<generated me
                                                                                                 74 68 6F 64 3E 01 00 54 0E 04 54 79 70 65 12 3C   // thod>..T..Type.<
                                                                                                 67 65 6E 65 72 61 74 65 64 20 6D 65 74 68 6F 64   // generated method
                                                                                                 3E )                                              // >
  .method public specialname rtspecialname 
          instance void  .ctor(object TargetObject,
                               native int TargetMethod) runtime managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  } // end of method VB$AnonymousDelegate_3::.ctor

  .method public newslot strict virtual instance class [mscorlib]System.IAsyncResult 
          BeginInvoke(class [mscorlib]System.AsyncCallback DelegateCallback,
                      object DelegateAsyncState) runtime managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  } // end of method VB$AnonymousDelegate_3::BeginInvoke

  .method public newslot strict virtual instance void 
          EndInvoke(class [mscorlib]System.IAsyncResult DelegateAsyncResult) runtime managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  } // end of method VB$AnonymousDelegate_3::EndInvoke

  .method public newslot strict virtual instance void 
          Invoke() runtime managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  } // end of method VB$AnonymousDelegate_3::Invoke

} // end of class VB$AnonymousDelegate_3


// =============================================================

// *********** DISASSEMBLY COMPLETE ***********************
