<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\obj\x86\Debug\App.g.cs" startline="47" endline="4"><![CDATA[
         public void InitializeComponent() {
              StartupUri="MainWindow.xaml">
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\obj\x86\Debug\App.g.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\obj\x86\Debug\App.g.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="23" endline="44"><![CDATA[
         private double m_stepSize = 5000.0;
 
         Stopwatch m_stopwatch = new Stopwatch();
         DispatcherTimer m_timer = new DispatcherTimer();
         Dictionary<string, Action<double>> m_executeAlgorithm;
 
         public MainWindow()
         {
             InitializeComponent();
 
             SizeChanged += new SizeChangedEventHandler(WindowSizeChangedEvent);
             numParticlesSlider.ValueChanged += NumParticlesValueChanged;
             SetNumCoresSliderProperties();
 
             ResetSimulation(true, Convert.ToInt32(numParticlesSlider.Value));
 
             FillDelegateLists();
             algorithmList.ItemsSource = m_executeAlgorithm.Keys;
 
             m_timer.Interval = TimeSpan.FromMilliseconds(20);
             m_timer.Tick += new EventHandler(ComputeNextPosition);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="45" endline="53"><![CDATA[
 
         private void SetNumCoresSliderProperties()
         {
             var numProcs = Environment.ProcessorCount;
             numCoresSlider.SelectionEnd = numProcs;
             numCoresSlider.Maximum = numProcs;
             numCoresSlider.Value = numProcs;
             numCoresLabel.Content = numProcs;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="54" endline="60"><![CDATA[
 
         private void AlgorithmTypeSelection(object sender, SelectionChangedEventArgs e)
         {
             var selection = expanderSelection.SelectedIndex;
             if (selection != 0)
                 throw new ArgumentOutOfRangeException("Expander selection has only one choice");
         }
 
         private void NumCoresValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
         {
             Globals.gNumCoresUsed = (int)e.NewValue;
             numCoresLabel.Content = e.NewValue.ToString();
         }
 
         private void NumParticlesValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
         {
             int newNumParticles = Convert.ToInt32(e.NewValue);
             ResetSimulation(true, newNumParticles);
             StartSimulation();
         }
 
         private void StepSizeValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
         {
             m_stepSize = e.NewValue;
             ResetSimulation(false, -1);
         }
 
         private void WindowSizeChangedEvent(object sender, SizeChangedEventArgs e)
         {
             var newCanvasHeight = (this.ActualHeight - windowTopBar.ActualHeight) / 2;
             var newCanvasWidth = (this.ActualWidth - windowSideBar.ActualWidth) / 2;
             ellipseCanvas.Height = newCanvasHeight;
             ellipseCanvas.Width = newCanvasWidth;
         }
 
         private void FillDelegateLists()
         {
             m_executeAlgorithm = new Dictionary<string, Action<double>>{
                 {"Sequential", step => NBodyParallelized.UpdateParticlesParallelFor(step, false)},
                 {"Parallel", step => NBodyParallelized.UpdateParticlesParallelFor(step, true)}};
         }
 
         void UpdateVelocity()
         {
             var algorithmListSelection = (string)algorithmList.SelectedItem;
             var expanderSelectionItem = expanderSelection.SelectedIndex;
             if (expanderSelectionItem == -1 || algorithmList.SelectedIndex == -1)
             {
                 var defaultSelection = "Sequential";
                 m_executeAlgorithm[defaultSelection](m_stepSize);
                 algorithmName.Content = defaultSelection;
             }
             else
             {
                 m_executeAlgorithm[algorithmListSelection](m_stepSize);
                 algorithmName.Content = algorithmListSelection;
             }
         }
 
         void ComputeNextPosition(object sender, EventArgs evArg)
         {
             m_stopwatch.Restart();
             UpdateVelocity();
 
             int i = 0;
             foreach (var e in Globals.globalState)
             {
                 var xDrag = e.px * Globals.particleSystemCentroid;
                 var yDrag = e.py * Globals.particleSystemCentroid;
                 var newXVel = Globals.globalState[i].vx;
                 var newYVel = Globals.globalState[i].vy;
                 var xVel = newXVel + xDrag;
                 var yVel = newYVel + yDrag;
 
                 Canvas.SetLeft(ellipseCanvas.Children[i], 100 * e.px);
                 Canvas.SetTop(ellipseCanvas.Children[i], 100 * e.py);
                 Globals.globalState[i].px = e.px + xVel * m_stepSize;
 
                 Globals.globalState[i].py = e.py + yVel * m_stepSize;
                 Globals.globalState[i].vx = xVel - xDrag;
                 Globals.globalState[i].vy = yVel - yDrag;
 
                 i++;
             }
 
             var fps = (1.0 / (m_stopwatch.Elapsed.TotalSeconds));
             displayTimeElapsed.Content = fps.ToString("F2");
         }
 
         private void StartSimulation()
         {
             InitParticles();
             startButton.IsEnabled = false;
             m_timer.Start();
             numParticlesLabel.Content = numParticlesSlider.Value;
             resetButton.IsEnabled = true;
         }
 
         private void ResetSimulation(bool changeNumber, int newNumParticles)
         {
             resetButton.IsEnabled = false;
             m_timer.Stop();
             ellipseCanvas.Children.Clear();
             if (changeNumber)
                 Globals.changeNumberOfParticles(newNumParticles);
             else
                 Globals.restart();
             startButton.IsEnabled = true;
         }
 
         private void StartButtonClick(object sender, RoutedEventArgs e)
         {
             StartSimulation();
         }
 
         private void ResetButtonClick(object sender, RoutedEventArgs e)
         {
             ResetSimulation(false, -1);
         }
 
         private Brush GetRadialBrush(Color edgeColor, Color focalColor)
         {
             return new RadialGradientBrush(focalColor, edgeColor) {
                 GradientOrigin = new Point(0.5, 0.5),
                 SpreadMethod = GradientSpreadMethod.Pad
             };
         }
 
         public void InitParticles()
         {
             var pList = Globals.globalState;
             int particleIndex = 0;
             foreach (var p in pList)
             {
                 var edgeColor = Color.FromArgb(0x00, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
                 var focalColor = Color.FromArgb(0x35, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
 
                 // get radial brush
                 var eBrush = GetRadialBrush(edgeColor, focalColor);
 
                 var size = System.Math.Pow((p.mass / Globals.nominalMass), 0.3333) * Globals.drawParticleSizeScale;
 
                 // create new ellipse!
                 var curEllipse = new Ellipse() { Fill = eBrush, Height = size, Width = size };
                 ellipseCanvas.Children.Add(curEllipse);
                 Canvas.SetLeft(curEllipse, 100 * p.px);
                 Canvas.SetTop(curEllipse, 100 * p.py);
 
                 particleIndex++;
             }
         }
     }
 }
                 throw new ArgumentOutOfRangeException("Expander selection has only one choice");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="61" endline="66"><![CDATA[
 
         private void NumCoresValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
         {
             Globals.gNumCoresUsed = (int)e.NewValue;
             numCoresLabel.Content = e.NewValue.ToString();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="67" endline="73"><![CDATA[
 
         private void NumParticlesValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
         {
             int newNumParticles = Convert.ToInt32(e.NewValue);
             ResetSimulation(true, newNumParticles);
             StartSimulation();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="74" endline="79"><![CDATA[
 
         private void StepSizeValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
         {
             m_stepSize = e.NewValue;
             ResetSimulation(false, -1);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="80" endline="87"><![CDATA[
 
         private void WindowSizeChangedEvent(object sender, SizeChangedEventArgs e)
         {
             var newCanvasHeight = (this.ActualHeight - windowTopBar.ActualHeight) / 2;
             var newCanvasWidth = (this.ActualWidth - windowSideBar.ActualWidth) / 2;
             ellipseCanvas.Height = newCanvasHeight;
             ellipseCanvas.Width = newCanvasWidth;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="88" endline="94"><![CDATA[
 
         private void FillDelegateLists()
         {
             m_executeAlgorithm = new Dictionary<string, Action<double>>{
                 {"Sequential", step => NBodyParallelized.UpdateParticlesParallelFor(step, false)},
                 {"Parallel", step => NBodyParallelized.UpdateParticlesParallelFor(step, true)}};
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="95" endline="111"><![CDATA[
 
         void UpdateVelocity()
         {
             var algorithmListSelection = (string)algorithmList.SelectedItem;
             var expanderSelectionItem = expanderSelection.SelectedIndex;
             if (expanderSelectionItem == -1 || algorithmList.SelectedIndex == -1)
             {
                 var defaultSelection = "Sequential";
                 m_executeAlgorithm[defaultSelection](m_stepSize);
                 algorithmName.Content = defaultSelection;
             }
             else
             {
                 m_executeAlgorithm[algorithmListSelection](m_stepSize);
                 algorithmName.Content = algorithmListSelection;
             }
         }
 
         void ComputeNextPosition(object sender, EventArgs evArg)
         {
             m_stopwatch.Restart();
             UpdateVelocity();
 
             int i = 0;
             foreach (var e in Globals.globalState)
             {
                 var xDrag = e.px * Globals.particleSystemCentroid;
                 var yDrag = e.py * Globals.particleSystemCentroid;
                 var newXVel = Globals.globalState[i].vx;
                 var newYVel = Globals.globalState[i].vy;
                 var xVel = newXVel + xDrag;
                 var yVel = newYVel + yDrag;
 
                 Canvas.SetLeft(ellipseCanvas.Children[i], 100 * e.px);
                 Canvas.SetTop(ellipseCanvas.Children[i], 100 * e.py);
                 Globals.globalState[i].px = e.px + xVel * m_stepSize;
 
                 Globals.globalState[i].py = e.py + yVel * m_stepSize;
                 Globals.globalState[i].vx = xVel - xDrag;
                 Globals.globalState[i].vy = yVel - yDrag;
 
                 i++;
             }
 
             var fps = (1.0 / (m_stopwatch.Elapsed.TotalSeconds));
             displayTimeElapsed.Content = fps.ToString("F2");
         }
 
         private void StartSimulation()
         {
             InitParticles();
             startButton.IsEnabled = false;
             m_timer.Start();
             numParticlesLabel.Content = numParticlesSlider.Value;
             resetButton.IsEnabled = true;
         }
 
         private void ResetSimulation(bool changeNumber, int newNumParticles)
         {
             resetButton.IsEnabled = false;
             m_timer.Stop();
             ellipseCanvas.Children.Clear();
             if (changeNumber)
                 Globals.changeNumberOfParticles(newNumParticles);
             else
                 Globals.restart();
             startButton.IsEnabled = true;
         }
 
         private void StartButtonClick(object sender, RoutedEventArgs e)
         {
             StartSimulation();
         }
 
         private void ResetButtonClick(object sender, RoutedEventArgs e)
         {
             ResetSimulation(false, -1);
         }
 
         private Brush GetRadialBrush(Color edgeColor, Color focalColor)
         {
             return new RadialGradientBrush(focalColor, edgeColor) {
                 GradientOrigin = new Point(0.5, 0.5),
                 SpreadMethod = GradientSpreadMethod.Pad
             };
         }
 
         public void InitParticles()
         {
             var pList = Globals.globalState;
             int particleIndex = 0;
             foreach (var p in pList)
             {
                 var edgeColor = Color.FromArgb(0x00, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
                 var focalColor = Color.FromArgb(0x35, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
 
                 // get radial brush
                 var eBrush = GetRadialBrush(edgeColor, focalColor);
 
                 var size = System.Math.Pow((p.mass / Globals.nominalMass), 0.3333) * Globals.drawParticleSizeScale;
 
                 // create new ellipse!
                 var curEllipse = new Ellipse() { Fill = eBrush, Height = size, Width = size };
                 ellipseCanvas.Children.Add(curEllipse);
                 Canvas.SetLeft(curEllipse, 100 * p.px);
                 Canvas.SetTop(curEllipse, 100 * p.py);
 
                 particleIndex++;
             }
         }
     }
 }
             {
                 var defaultSelection = "Sequential";
                 m_executeAlgorithm[defaultSelection](m_stepSize);
                 algorithmName.Content = defaultSelection;
             }
             else
             {
                 m_executeAlgorithm[algorithmListSelection](m_stepSize);
                 algorithmName.Content = algorithmListSelection;
             }
         }
 
         void ComputeNextPosition(object sender, EventArgs evArg)
         {
             m_stopwatch.Restart();
             UpdateVelocity();
 
             int i = 0;
             foreach (var e in Globals.globalState)
             {
                 var xDrag = e.px * Globals.particleSystemCentroid;
                 var yDrag = e.py * Globals.particleSystemCentroid;
                 var newXVel = Globals.globalState[i].vx;
                 var newYVel = Globals.globalState[i].vy;
                 var xVel = newXVel + xDrag;
                 var yVel = newYVel + yDrag;
 
                 Canvas.SetLeft(ellipseCanvas.Children[i], 100 * e.px);
                 Canvas.SetTop(ellipseCanvas.Children[i], 100 * e.py);
                 Globals.globalState[i].px = e.px + xVel * m_stepSize;
 
                 Globals.globalState[i].py = e.py + yVel * m_stepSize;
                 Globals.globalState[i].vx = xVel - xDrag;
                 Globals.globalState[i].vy = yVel - yDrag;
 
                 i++;
             }
 
             var fps = (1.0 / (m_stopwatch.Elapsed.TotalSeconds));
             displayTimeElapsed.Content = fps.ToString("F2");
         }
 
         private void StartSimulation()
         {
             InitParticles();
             startButton.IsEnabled = false;
             m_timer.Start();
             numParticlesLabel.Content = numParticlesSlider.Value;
             resetButton.IsEnabled = true;
         }
 
         private void ResetSimulation(bool changeNumber, int newNumParticles)
         {
             resetButton.IsEnabled = false;
             m_timer.Stop();
             ellipseCanvas.Children.Clear();
             if (changeNumber)
                 Globals.changeNumberOfParticles(newNumParticles);
             else
                 Globals.restart();
             startButton.IsEnabled = true;
         }
 
         private void StartButtonClick(object sender, RoutedEventArgs e)
         {
             StartSimulation();
         }
 
         private void ResetButtonClick(object sender, RoutedEventArgs e)
         {
             ResetSimulation(false, -1);
         }
 
         private Brush GetRadialBrush(Color edgeColor, Color focalColor)
         {
             return new RadialGradientBrush(focalColor, edgeColor) {
                 GradientOrigin = new Point(0.5, 0.5),
                 SpreadMethod = GradientSpreadMethod.Pad
             };
         }
 
         public void InitParticles()
         {
             var pList = Globals.globalState;
             int particleIndex = 0;
             foreach (var p in pList)
             {
                 var edgeColor = Color.FromArgb(0x00, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
                 var focalColor = Color.FromArgb(0x35, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
 
                 // get radial brush
                 var eBrush = GetRadialBrush(edgeColor, focalColor);
 
                 var size = System.Math.Pow((p.mass / Globals.nominalMass), 0.3333) * Globals.drawParticleSizeScale;
 
                 // create new ellipse!
                 var curEllipse = new Ellipse() { Fill = eBrush, Height = size, Width = size };
                 ellipseCanvas.Children.Add(curEllipse);
                 Canvas.SetLeft(curEllipse, 100 * p.px);
                 Canvas.SetTop(curEllipse, 100 * p.py);
 
                 particleIndex++;
             }
         }
     }
 }
             {
                 m_executeAlgorithm[algorithmListSelection](m_stepSize);
                 algorithmName.Content = algorithmListSelection;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="112" endline="141"><![CDATA[
 
         void ComputeNextPosition(object sender, EventArgs evArg)
         {
             m_stopwatch.Restart();
             UpdateVelocity();
 
             int i = 0;
             foreach (var e in Globals.globalState)
             {
                 var xDrag = e.px * Globals.particleSystemCentroid;
                 var yDrag = e.py * Globals.particleSystemCentroid;
                 var newXVel = Globals.globalState[i].vx;
                 var newYVel = Globals.globalState[i].vy;
                 var xVel = newXVel + xDrag;
                 var yVel = newYVel + yDrag;
 
                 Canvas.SetLeft(ellipseCanvas.Children[i], 100 * e.px);
                 Canvas.SetTop(ellipseCanvas.Children[i], 100 * e.py);
                 Globals.globalState[i].px = e.px + xVel * m_stepSize;
 
                 Globals.globalState[i].py = e.py + yVel * m_stepSize;
                 Globals.globalState[i].vx = xVel - xDrag;
                 Globals.globalState[i].vy = yVel - yDrag;
 
                 i++;
             }
 
             var fps = (1.0 / (m_stopwatch.Elapsed.TotalSeconds));
             displayTimeElapsed.Content = fps.ToString("F2");
         }
 
         private void StartSimulation()
         {
             InitParticles();
             startButton.IsEnabled = false;
             m_timer.Start();
             numParticlesLabel.Content = numParticlesSlider.Value;
             resetButton.IsEnabled = true;
         }
 
         private void ResetSimulation(bool changeNumber, int newNumParticles)
         {
             resetButton.IsEnabled = false;
             m_timer.Stop();
             ellipseCanvas.Children.Clear();
             if (changeNumber)
                 Globals.changeNumberOfParticles(newNumParticles);
             else
                 Globals.restart();
             startButton.IsEnabled = true;
         }
 
         private void StartButtonClick(object sender, RoutedEventArgs e)
         {
             StartSimulation();
         }
 
         private void ResetButtonClick(object sender, RoutedEventArgs e)
         {
             ResetSimulation(false, -1);
         }
 
         private Brush GetRadialBrush(Color edgeColor, Color focalColor)
         {
             return new RadialGradientBrush(focalColor, edgeColor) {
                 GradientOrigin = new Point(0.5, 0.5),
                 SpreadMethod = GradientSpreadMethod.Pad
             };
         }
 
         public void InitParticles()
         {
             var pList = Globals.globalState;
             int particleIndex = 0;
             foreach (var p in pList)
             {
                 var edgeColor = Color.FromArgb(0x00, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
                 var focalColor = Color.FromArgb(0x35, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
 
                 // get radial brush
                 var eBrush = GetRadialBrush(edgeColor, focalColor);
 
                 var size = System.Math.Pow((p.mass / Globals.nominalMass), 0.3333) * Globals.drawParticleSizeScale;
 
                 // create new ellipse!
                 var curEllipse = new Ellipse() { Fill = eBrush, Height = size, Width = size };
                 ellipseCanvas.Children.Add(curEllipse);
                 Canvas.SetLeft(curEllipse, 100 * p.px);
                 Canvas.SetTop(curEllipse, 100 * p.py);
 
                 particleIndex++;
             }
         }
     }
 }
             foreach (var e in Globals.globalState)
             {
                 var xDrag = e.px * Globals.particleSystemCentroid;
                 var yDrag = e.py * Globals.particleSystemCentroid;
                 var newXVel = Globals.globalState[i].vx;
                 var newYVel = Globals.globalState[i].vy;
                 var xVel = newXVel + xDrag;
                 var yVel = newYVel + yDrag;
 
                 Canvas.SetLeft(ellipseCanvas.Children[i], 100 * e.px);
                 Canvas.SetTop(ellipseCanvas.Children[i], 100 * e.py);
                 Globals.globalState[i].px = e.px + xVel * m_stepSize;
 
                 Globals.globalState[i].py = e.py + yVel * m_stepSize;
                 Globals.globalState[i].vx = xVel - xDrag;
                 Globals.globalState[i].vy = yVel - yDrag;
 
                 i++;
             }
 
             var fps = (1.0 / (m_stopwatch.Elapsed.TotalSeconds));
             displayTimeElapsed.Content = fps.ToString("F2");
         }
 
         private void StartSimulation()
         {
             InitParticles();
             startButton.IsEnabled = false;
             m_timer.Start();
             numParticlesLabel.Content = numParticlesSlider.Value;
             resetButton.IsEnabled = true;
         }
 
         private void ResetSimulation(bool changeNumber, int newNumParticles)
         {
             resetButton.IsEnabled = false;
             m_timer.Stop();
             ellipseCanvas.Children.Clear();
             if (changeNumber)
                 Globals.changeNumberOfParticles(newNumParticles);
             else
                 Globals.restart();
             startButton.IsEnabled = true;
         }
 
         private void StartButtonClick(object sender, RoutedEventArgs e)
         {
             StartSimulation();
         }
 
         private void ResetButtonClick(object sender, RoutedEventArgs e)
         {
             ResetSimulation(false, -1);
         }
 
         private Brush GetRadialBrush(Color edgeColor, Color focalColor)
         {
             return new RadialGradientBrush(focalColor, edgeColor) {
                 GradientOrigin = new Point(0.5, 0.5),
                 SpreadMethod = GradientSpreadMethod.Pad
             };
         }
 
         public void InitParticles()
         {
             var pList = Globals.globalState;
             int particleIndex = 0;
             foreach (var p in pList)
             {
                 var edgeColor = Color.FromArgb(0x00, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
                 var focalColor = Color.FromArgb(0x35, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
 
                 // get radial brush
                 var eBrush = GetRadialBrush(edgeColor, focalColor);
 
                 var size = System.Math.Pow((p.mass / Globals.nominalMass), 0.3333) * Globals.drawParticleSizeScale;
 
                 // create new ellipse!
                 var curEllipse = new Ellipse() { Fill = eBrush, Height = size, Width = size };
                 ellipseCanvas.Children.Add(curEllipse);
                 Canvas.SetLeft(curEllipse, 100 * p.px);
                 Canvas.SetTop(curEllipse, 100 * p.py);
 
                 particleIndex++;
             }
         }
     }
 }
             foreach (var e in Globals.globalState)
             {
                 var xDrag = e.px * Globals.particleSystemCentroid;
                 var yDrag = e.py * Globals.particleSystemCentroid;
                 var newXVel = Globals.globalState[i].vx;
                 var newYVel = Globals.globalState[i].vy;
                 var xVel = newXVel + xDrag;
                 var yVel = newYVel + yDrag;
 
                 Canvas.SetLeft(ellipseCanvas.Children[i], 100 * e.px);
                 Canvas.SetTop(ellipseCanvas.Children[i], 100 * e.py);
                 Globals.globalState[i].px = e.px + xVel * m_stepSize;
 
                 Globals.globalState[i].py = e.py + yVel * m_stepSize;
                 Globals.globalState[i].vx = xVel - xDrag;
                 Globals.globalState[i].vy = yVel - yDrag;
 
                 i++;
             }
 
             var fps = (1.0 / (m_stopwatch.Elapsed.TotalSeconds));
             displayTimeElapsed.Content = fps.ToString("F2");
         }
 
         private void StartSimulation()
         {
             InitParticles();
             startButton.IsEnabled = false;
             m_timer.Start();
             numParticlesLabel.Content = numParticlesSlider.Value;
             resetButton.IsEnabled = true;
         }
 
         private void ResetSimulation(bool changeNumber, int newNumParticles)
         {
             resetButton.IsEnabled = false;
             m_timer.Stop();
             ellipseCanvas.Children.Clear();
             if (changeNumber)
                 Globals.changeNumberOfParticles(newNumParticles);
             else
                 Globals.restart();
             startButton.IsEnabled = true;
         }
 
         private void StartButtonClick(object sender, RoutedEventArgs e)
         {
             StartSimulation();
         }
 
         private void ResetButtonClick(object sender, RoutedEventArgs e)
         {
             ResetSimulation(false, -1);
         }
 
         private Brush GetRadialBrush(Color edgeColor, Color focalColor)
         {
             return new RadialGradientBrush(focalColor, edgeColor) {
                 GradientOrigin = new Point(0.5, 0.5),
                 SpreadMethod = GradientSpreadMethod.Pad
             };
         }
 
         public void InitParticles()
         {
             var pList = Globals.globalState;
             int particleIndex = 0;
             foreach (var p in pList)
             {
                 var edgeColor = Color.FromArgb(0x00, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
                 var focalColor = Color.FromArgb(0x35, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
 
                 // get radial brush
                 var eBrush = GetRadialBrush(edgeColor, focalColor);
 
                 var size = System.Math.Pow((p.mass / Globals.nominalMass), 0.3333) * Globals.drawParticleSizeScale;
 
                 // create new ellipse!
                 var curEllipse = new Ellipse() { Fill = eBrush, Height = size, Width = size };
                 ellipseCanvas.Children.Add(curEllipse);
                 Canvas.SetLeft(curEllipse, 100 * p.px);
                 Canvas.SetTop(curEllipse, 100 * p.py);
 
                 particleIndex++;
             }
         }
     }
 }
             var fps = (1.0 / (m_stopwatch.Elapsed.TotalSeconds));
             displayTimeElapsed.Content = fps.ToString("F2");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="142" endline="150"><![CDATA[
 
         private void StartSimulation()
         {
             InitParticles();
             startButton.IsEnabled = false;
             m_timer.Start();
             numParticlesLabel.Content = numParticlesSlider.Value;
             resetButton.IsEnabled = true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="151" endline="162"><![CDATA[
 
         private void ResetSimulation(bool changeNumber, int newNumParticles)
         {
             resetButton.IsEnabled = false;
             m_timer.Stop();
             ellipseCanvas.Children.Clear();
             if (changeNumber)
                 Globals.changeNumberOfParticles(newNumParticles);
             else
                 Globals.restart();
             startButton.IsEnabled = true;
         }
 
         private void StartButtonClick(object sender, RoutedEventArgs e)
         {
             StartSimulation();
         }
 
         private void ResetButtonClick(object sender, RoutedEventArgs e)
         {
             ResetSimulation(false, -1);
         }
 
         private Brush GetRadialBrush(Color edgeColor, Color focalColor)
         {
             return new RadialGradientBrush(focalColor, edgeColor) {
                 GradientOrigin = new Point(0.5, 0.5),
                 SpreadMethod = GradientSpreadMethod.Pad
             };
         }
 
         public void InitParticles()
         {
             var pList = Globals.globalState;
             int particleIndex = 0;
             foreach (var p in pList)
             {
                 var edgeColor = Color.FromArgb(0x00, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
                 var focalColor = Color.FromArgb(0x35, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
 
                 // get radial brush
                 var eBrush = GetRadialBrush(edgeColor, focalColor);
 
                 var size = System.Math.Pow((p.mass / Globals.nominalMass), 0.3333) * Globals.drawParticleSizeScale;
 
                 // create new ellipse!
                 var curEllipse = new Ellipse() { Fill = eBrush, Height = size, Width = size };
                 ellipseCanvas.Children.Add(curEllipse);
                 Canvas.SetLeft(curEllipse, 100 * p.px);
                 Canvas.SetTop(curEllipse, 100 * p.py);
 
                 particleIndex++;
             }
         }
     }
 }
                 Globals.changeNumberOfParticles(newNumParticles);
             else
                 Globals.restart();
             startButton.IsEnabled = true;
         }
 
         private void StartButtonClick(object sender, RoutedEventArgs e)
         {
             StartSimulation();
         }
 
         private void ResetButtonClick(object sender, RoutedEventArgs e)
         {
             ResetSimulation(false, -1);
         }
 
         private Brush GetRadialBrush(Color edgeColor, Color focalColor)
         {
             return new RadialGradientBrush(focalColor, edgeColor) {
                 GradientOrigin = new Point(0.5, 0.5),
                 SpreadMethod = GradientSpreadMethod.Pad
             };
         }
 
         public void InitParticles()
         {
             var pList = Globals.globalState;
             int particleIndex = 0;
             foreach (var p in pList)
             {
                 var edgeColor = Color.FromArgb(0x00, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
                 var focalColor = Color.FromArgb(0x35, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
 
                 // get radial brush
                 var eBrush = GetRadialBrush(edgeColor, focalColor);
 
                 var size = System.Math.Pow((p.mass / Globals.nominalMass), 0.3333) * Globals.drawParticleSizeScale;
 
                 // create new ellipse!
                 var curEllipse = new Ellipse() { Fill = eBrush, Height = size, Width = size };
                 ellipseCanvas.Children.Add(curEllipse);
                 Canvas.SetLeft(curEllipse, 100 * p.px);
                 Canvas.SetTop(curEllipse, 100 * p.py);
 
                 particleIndex++;
             }
         }
     }
 }
                 Globals.restart();
             startButton.IsEnabled = true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="163" endline="167"><![CDATA[
 
         private void StartButtonClick(object sender, RoutedEventArgs e)
         {
             StartSimulation();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="168" endline="172"><![CDATA[
 
         private void ResetButtonClick(object sender, RoutedEventArgs e)
         {
             ResetSimulation(false, -1);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="173" endline="180"><![CDATA[
 
         private Brush GetRadialBrush(Color edgeColor, Color focalColor)
         {
             return new RadialGradientBrush(focalColor, edgeColor) {
                 GradientOrigin = new Point(0.5, 0.5),
                 SpreadMethod = GradientSpreadMethod.Pad
             };
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="181" endline="204"><![CDATA[
 
         public void InitParticles()
         {
             var pList = Globals.globalState;
             int particleIndex = 0;
             foreach (var p in pList)
             {
                 var edgeColor = Color.FromArgb(0x00, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
                 var focalColor = Color.FromArgb(0x35, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
 
                 // get radial brush
                 var eBrush = GetRadialBrush(edgeColor, focalColor);
 
                 var size = System.Math.Pow((p.mass / Globals.nominalMass), 0.3333) * Globals.drawParticleSizeScale;
 
                 // create new ellipse!
                 var curEllipse = new Ellipse() { Fill = eBrush, Height = size, Width = size };
                 ellipseCanvas.Children.Add(curEllipse);
                 Canvas.SetLeft(curEllipse, 100 * p.px);
                 Canvas.SetTop(curEllipse, 100 * p.py);
 
                 particleIndex++;
             }
         }
     }
 }
             foreach (var p in pList)
             {
                 var edgeColor = Color.FromArgb(0x00, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
                 var focalColor = Color.FromArgb(0x35, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
 
                 // get radial brush
                 var eBrush = GetRadialBrush(edgeColor, focalColor);
 
                 var size = System.Math.Pow((p.mass / Globals.nominalMass), 0.3333) * Globals.drawParticleSizeScale;
 
                 // create new ellipse!
                 var curEllipse = new Ellipse() { Fill = eBrush, Height = size, Width = size };
                 ellipseCanvas.Children.Add(curEllipse);
                 Canvas.SetLeft(curEllipse, 100 * p.px);
                 Canvas.SetTop(curEllipse, 100 * p.py);
 
                 particleIndex++;
             }
         }
     }
 }
             foreach (var p in pList)
             {
                 var edgeColor = Color.FromArgb(0x00, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
                 var focalColor = Color.FromArgb(0x35, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
 
                 // get radial brush
                 var eBrush = GetRadialBrush(edgeColor, focalColor);
 
                 var size = System.Math.Pow((p.mass / Globals.nominalMass), 0.3333) * Globals.drawParticleSizeScale;
 
                 // create new ellipse!
                 var curEllipse = new Ellipse() { Fill = eBrush, Height = size, Width = size };
                 ellipseCanvas.Children.Add(curEllipse);
                 Canvas.SetLeft(curEllipse, 100 * p.px);
                 Canvas.SetTop(curEllipse, 100 * p.py);
 
                 particleIndex++;
             }
         }
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\obj\x86\Debug\MainWindow.g.cs" startline="1" endline="1"><![CDATA[
 ?<Window x
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\obj\x86\Debug\MainWindow.g.cs" startline="28" endline="77"><![CDATA[
                                 IsSnapToTickEnabled="True" Foreground="White" TickPlacement="BottomRight" SelectionStart="1" Minimum="1" TickFrequency="1" ValueChanged="NumCoresValueChanged"/>
                                 <ListBox Background="Black" SelectionMode="Single" x
                                         BorderBrush="Orange" FontSize="15" Width="75" Click="StartButtonClick">Start</Button>
                                 <Button x
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="92" endline="206"><![CDATA[
                 {"Sequential", step => NBodyParallelized.UpdateParticlesParallelFor(step, false)},
                 {"Parallel", step => NBodyParallelized.UpdateParticlesParallelFor(step, true)}};
         }
 
         void UpdateVelocity()
         {
             var algorithmListSelection = (string)algorithmList.SelectedItem;
             var expanderSelectionItem = expanderSelection.SelectedIndex;
             if (expanderSelectionItem == -1 || algorithmList.SelectedIndex == -1)
             {
                 var defaultSelection = "Sequential";
                 m_executeAlgorithm[defaultSelection](m_stepSize);
                 algorithmName.Content = defaultSelection;
             }
             else
             {
                 m_executeAlgorithm[algorithmListSelection](m_stepSize);
                 algorithmName.Content = algorithmListSelection;
             }
         }
 
         void ComputeNextPosition(object sender, EventArgs evArg)
         {
             m_stopwatch.Restart();
             UpdateVelocity();
 
             int i = 0;
             foreach (var e in Globals.globalState)
             {
                 var xDrag = e.px * Globals.particleSystemCentroid;
                 var yDrag = e.py * Globals.particleSystemCentroid;
                 var newXVel = Globals.globalState[i].vx;
                 var newYVel = Globals.globalState[i].vy;
                 var xVel = newXVel + xDrag;
                 var yVel = newYVel + yDrag;
 
                 Canvas.SetLeft(ellipseCanvas.Children[i], 100 * e.px);
                 Canvas.SetTop(ellipseCanvas.Children[i], 100 * e.py);
                 Globals.globalState[i].px = e.px + xVel * m_stepSize;
 
                 Globals.globalState[i].py = e.py + yVel * m_stepSize;
                 Globals.globalState[i].vx = xVel - xDrag;
                 Globals.globalState[i].vy = yVel - yDrag;
 
                 i++;
             }
 
             var fps = (1.0 / (m_stopwatch.Elapsed.TotalSeconds));
             displayTimeElapsed.Content = fps.ToString("F2");
         }
 
         private void StartSimulation()
         {
             InitParticles();
             startButton.IsEnabled = false;
             m_timer.Start();
             numParticlesLabel.Content = numParticlesSlider.Value;
             resetButton.IsEnabled = true;
         }
 
         private void ResetSimulation(bool changeNumber, int newNumParticles)
         {
             resetButton.IsEnabled = false;
             m_timer.Stop();
             ellipseCanvas.Children.Clear();
             if (changeNumber)
                 Globals.changeNumberOfParticles(newNumParticles);
             else
                 Globals.restart();
             startButton.IsEnabled = true;
         }
 
         private void StartButtonClick(object sender, RoutedEventArgs e)
         {
             StartSimulation();
         }
 
         private void ResetButtonClick(object sender, RoutedEventArgs e)
         {
             ResetSimulation(false, -1);
         }
 
         private Brush GetRadialBrush(Color edgeColor, Color focalColor)
         {
             return new RadialGradientBrush(focalColor, edgeColor) {
                 GradientOrigin = new Point(0.5, 0.5),
                 SpreadMethod = GradientSpreadMethod.Pad
             };
         }
 
         public void InitParticles()
         {
             var pList = Globals.globalState;
             int particleIndex = 0;
             foreach (var p in pList)
             {
                 var edgeColor = Color.FromArgb(0x00, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
                 var focalColor = Color.FromArgb(0x35, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
 
                 // get radial brush
                 var eBrush = GetRadialBrush(edgeColor, focalColor);
 
                 var size = System.Math.Pow((p.mass / Globals.nominalMass), 0.3333) * Globals.drawParticleSizeScale;
 
                 // create new ellipse!
                 var curEllipse = new Ellipse() { Fill = eBrush, Height = size, Width = size };
                 ellipseCanvas.Children.Add(curEllipse);
                 Canvas.SetLeft(curEllipse, 100 * p.px);
                 Canvas.SetTop(curEllipse, 100 * p.py);
 
                 particleIndex++;
             }
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\MainWindow.xaml.cs" startline="93" endline="206"><![CDATA[
                 {"Parallel", step => NBodyParallelized.UpdateParticlesParallelFor(step, true)}};
         }
 
         void UpdateVelocity()
         {
             var algorithmListSelection = (string)algorithmList.SelectedItem;
             var expanderSelectionItem = expanderSelection.SelectedIndex;
             if (expanderSelectionItem == -1 || algorithmList.SelectedIndex == -1)
             {
                 var defaultSelection = "Sequential";
                 m_executeAlgorithm[defaultSelection](m_stepSize);
                 algorithmName.Content = defaultSelection;
             }
             else
             {
                 m_executeAlgorithm[algorithmListSelection](m_stepSize);
                 algorithmName.Content = algorithmListSelection;
             }
         }
 
         void ComputeNextPosition(object sender, EventArgs evArg)
         {
             m_stopwatch.Restart();
             UpdateVelocity();
 
             int i = 0;
             foreach (var e in Globals.globalState)
             {
                 var xDrag = e.px * Globals.particleSystemCentroid;
                 var yDrag = e.py * Globals.particleSystemCentroid;
                 var newXVel = Globals.globalState[i].vx;
                 var newYVel = Globals.globalState[i].vy;
                 var xVel = newXVel + xDrag;
                 var yVel = newYVel + yDrag;
 
                 Canvas.SetLeft(ellipseCanvas.Children[i], 100 * e.px);
                 Canvas.SetTop(ellipseCanvas.Children[i], 100 * e.py);
                 Globals.globalState[i].px = e.px + xVel * m_stepSize;
 
                 Globals.globalState[i].py = e.py + yVel * m_stepSize;
                 Globals.globalState[i].vx = xVel - xDrag;
                 Globals.globalState[i].vy = yVel - yDrag;
 
                 i++;
             }
 
             var fps = (1.0 / (m_stopwatch.Elapsed.TotalSeconds));
             displayTimeElapsed.Content = fps.ToString("F2");
         }
 
         private void StartSimulation()
         {
             InitParticles();
             startButton.IsEnabled = false;
             m_timer.Start();
             numParticlesLabel.Content = numParticlesSlider.Value;
             resetButton.IsEnabled = true;
         }
 
         private void ResetSimulation(bool changeNumber, int newNumParticles)
         {
             resetButton.IsEnabled = false;
             m_timer.Stop();
             ellipseCanvas.Children.Clear();
             if (changeNumber)
                 Globals.changeNumberOfParticles(newNumParticles);
             else
                 Globals.restart();
             startButton.IsEnabled = true;
         }
 
         private void StartButtonClick(object sender, RoutedEventArgs e)
         {
             StartSimulation();
         }
 
         private void ResetButtonClick(object sender, RoutedEventArgs e)
         {
             ResetSimulation(false, -1);
         }
 
         private Brush GetRadialBrush(Color edgeColor, Color focalColor)
         {
             return new RadialGradientBrush(focalColor, edgeColor) {
                 GradientOrigin = new Point(0.5, 0.5),
                 SpreadMethod = GradientSpreadMethod.Pad
             };
         }
 
         public void InitParticles()
         {
             var pList = Globals.globalState;
             int particleIndex = 0;
             foreach (var p in pList)
             {
                 var edgeColor = Color.FromArgb(0x00, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
                 var focalColor = Color.FromArgb(0x35, Globals.defaultFocalColor.R, Globals.defaultFocalColor.G, Globals.defaultFocalColor.B);
 
                 // get radial brush
                 var eBrush = GetRadialBrush(edgeColor, focalColor);
 
                 var size = System.Math.Pow((p.mass / Globals.nominalMass), 0.3333) * Globals.drawParticleSizeScale;
 
                 // create new ellipse!
                 var curEllipse = new Ellipse() { Fill = eBrush, Height = size, Width = size };
                 ellipseCanvas.Children.Add(curEllipse);
                 Canvas.SetLeft(curEllipse, 100 * p.px);
                 Canvas.SetTop(curEllipse, 100 * p.py);
 
                 particleIndex++;
             }
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\Properties\Settings.Designer.cs" startline="25" endline="27"><![CDATA[
             {
                 return defaultInstance;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\Properties\Settings.Designer.cs" startline="20" endline="30"><![CDATA[
         private static Settings defaultInstance = ((Settings)(global
 
         public static Settings Default
         {
             get
             {
                 return defaultInstance;
             }
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\Properties\Resources.Designer.cs" startline="32" endline="35"><![CDATA[
         [global
         internal Resources()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\Properties\Resources.Designer.cs" startline="36" endline="51"><![CDATA[
 
         /// <summary>
         ///   Returns the cached ResourceManager instance used by this class.
         /// </summary>
         [global
         internal static global
         {
             get
             {
                 if ((resourceMan == null))
                 {
                     global
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
         }
 
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
         {
             get
             {
                 return resourceCulture;
             }
             set
             {
                 resourceCulture = value;
             }
         }
     }
 }
                 {
                     global
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\Properties\Resources.Designer.cs" startline="52" endline="64"><![CDATA[
         }
 
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
         {
             get
             {
                 return resourceCulture;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\NBodySimulation\NBodySimulation\Properties\Resources.Designer.cs" startline="65" endline="68"><![CDATA[
             set
             {
                 resourceCulture = value;
             }
]]></source>
</source_elements></project>
